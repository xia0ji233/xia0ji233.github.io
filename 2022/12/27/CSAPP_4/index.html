<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CS:APP第四章复习 | xia0ji233's blog</title><meta name="author" content="xia0ji233"><meta name="copyright" content="xia0ji233"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="其实第四章一开始感觉不是我该学的，但是想想自己也要考研，计组也会讲这些，而这本书应该是会比计组讲的好的，所以还是硬着头皮学吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="CS:APP第四章复习">
<meta property="og:url" content="https://xia0ji233.github.io/2022/12/27/CSAPP_4/index.html">
<meta property="og:site_name" content="xia0ji233&#39;s blog">
<meta property="og:description" content="其实第四章一开始感觉不是我该学的，但是想想自己也要考研，计组也会讲这些，而这本书应该是会比计组讲的好的，所以还是硬着头皮学吧。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xia0ji233.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-12-27T11:00:00.000Z">
<meta property="article:modified_time" content="2025-01-16T13:21:17.716Z">
<meta property="article:author" content="xia0ji233">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xia0ji233.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xia0ji233.github.io/2022/12/27/CSAPP_4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS:APP第四章复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-16 21:21:17'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="xia0ji233's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">310</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">90</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/backgroud.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="xia0ji233's blog"><span class="site-name">xia0ji233's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CS:APP第四章复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-27T11:00:00.000Z" title="发表于 2022-12-27 19:00:00">2022-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-16T13:21:17.716Z" title="更新于 2025-01-16 21:21:17">2025-01-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/">书籍阅读</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/CSAPP/">CSAPP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CS:APP第四章复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>其实第四章一开始感觉不是我该学的，但是想想自己也要考研，计组也会讲这些，而这本书应该是会比计组讲的好的，所以还是硬着头皮学吧。</p>
<ul>
<li>2022-12-27 UPDATE:完成了这一章</li>
</ul>
<span id="more"></span>

<p>每天 % 一遍：CSAPP 永远的神！！！计算机的教科书我愿称他为最好！</p>
<p>计算机体系结构图</p>
<img src="/2022/12/27/CSAPP_4/1.png" class="">

<h2 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h2><p>我们知道，x86-64 指令集体系结构的电脑是很经典的 CISC（complex instruction set computer）。这里方便学习就定义一个精简指令集 Y86-64 结构。</p>
<h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><ul>
<li>Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分，这称为<strong>程序员可见的状态</strong>。</li>
<li>这里的“程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器</li>
</ul>
<p>Y86-64 的状态类似 x86-64。有 15 个寄存器：%rax，%rcx，%rdx，%rbx，%rsp，%rbp，%rsi，%rdi 以及 %r8-%r14。为了方便指令编码，少了一个 %r15 寄存器。</p>
<p>其中，%rsp 被用于入栈出栈，程序计数器（PC，也就是%rip）存放当前指令执行的地址，还包含了 3 位的条件码用于条件跳转，程序状态的最后一个部分是状态码（Stat），表明了程序正常运行或者是出现了某种异常。</p>
<p>程序员可见的状态：各类通用寄存器，PC，条件码，Stat。</p>
<p>程序员不可见的状态：指令寄存器（Instrument Register），主存数据寄存器（Memory Data Register），主存地址寄存器（Memory Address Register）。这些都是辅助 CPU 执行的寄存器，对我们来说不知道也没必要知道，我们只需要知道通用寄存器里面有什么就可以了。</p>
<h3 id="Y86-64指令"><a href="#Y86-64指令" class="headerlink" title="Y86-64指令"></a>Y86-64指令</h3><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>x86-64 的 movq 指令被分为了 4 个不同的指令。就是对应了源目的的种类数：立即数-寄存器，寄存器-寄存器，内存-寄存器，寄存器-内存，与 x86-64 相同，不允许直接从内存地址传送到另一个内存地址，必须通过寄存器传送。</p>
<h4 id="整数操作指令"><a href="#整数操作指令" class="headerlink" title="整数操作指令"></a>整数操作指令</h4><p>有四种类型的整数操作（addq，subq，andq，xorq），它们的代码部分（code）相同，功能不同，功能用于选择是对两个数进行加法，减法，按位与还是按位或运算。</p>
<h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>有七个跳转指令，与前面介绍的类似，一个无条件跳转和六个条件跳转（jle，jl，je，jne，jge，jg）。</p>
<h4 id="条件传送指令"><a href="#条件传送指令" class="headerlink" title="条件传送指令"></a>条件传送指令</h4><p>有六个条件传送指令，与条件跳转类似。</p>
<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>call指令，与 x86-64 类似</p>
<h4 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h4><p>也与 x86-64 类似，有入栈（push）和出栈（pop）的操作。</p>
<h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p>参考书上这个图</p>
<img src="/2022/12/27/CSAPP_4/2.png" class="">

<p>因为我们有 15 个寄存器，所以 0-E 刚好表示 15 个寄存器，剩下一个 F 表示该操作数不为寄存器，可能为一个立即数。例如 irmovq 指令的源操作数是立即数，因此源操作数这一位用 F 替代。</p>
<p>再比如，pushq 和 popq 指令是单操作数，因此第二个字节后八位默认也是 F。</p>
<p>分支指令调用的地址是绝对地址而不是 PC 寻址，指令集一个比较重要的是字节编码必须有唯一的解释，不能产生歧义。</p>
<h3 id="Y86-64异常"><a href="#Y86-64异常" class="headerlink" title="Y86-64异常"></a>Y86-64异常</h3><table>
<thead>
<tr>
<th>值</th>
<th>名字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>AOK</td>
<td>正常操作</td>
</tr>
<tr>
<td>2</td>
<td>HLT</td>
<td>遇到halt指令</td>
</tr>
<tr>
<td>3</td>
<td>ADR</td>
<td>遇到非法地址</td>
</tr>
<tr>
<td>4</td>
<td>INS</td>
<td>遇到非法指令</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Y86-64在遇到异常的时候只会简单地停止处理器的运行，但是完整的设计应该需要让处理器调用一个异常处理程序（exception handler）。</p>
<h3 id="Y86-64程序"><a href="#Y86-64程序" class="headerlink" title="Y86-64程序"></a>Y86-64程序</h3><p>这里需要注意，add 指令不能直接加一个常数，Opq指令只能对两个寄存器做运算，因此要对立即数运算需要先把立即数加载到寄存器当中才可以。</p>
<p>subq 指令可以直接设置条件码，而在 x86-64 架构下，我们需要再多一个 test 命令才能实现设置条件码。</p>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.pos 0</span><br><span class="line">irmovq stack,%rsp</span><br><span class="line">call main</span><br><span class="line">halt</span><br><span class="line"></span><br><span class="line">array:</span><br><span class="line">	.quad 0x000d000d000d</span><br><span class="line">	.quad 0x00c000c000c0</span><br><span class="line">	.quad 0x0b000b000b00</span><br><span class="line">	.quad 0xa000a000a000</span><br><span class="line">	</span><br><span class="line">main:</span><br><span class="line">	irmovq array,%rdi</span><br><span class="line">	irmovq $4,%rsi</span><br><span class="line">	call sum;sum(array,4)</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">sum:</span><br><span class="line">	irmovq $8,%r8</span><br><span class="line">	irmovq $1,%r9</span><br><span class="line">	xorq %rax,%rax;set %rax=0</span><br><span class="line">	andq %rsi,%rsi;test rsi</span><br><span class="line">	jmp test</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	mrmovq (%rdi),%r10;get (%rdi) save in %r10</span><br><span class="line">	addq %r10,%rax;%rax+=%r10</span><br><span class="line">	addq %r8,%rdi;%rdi+=8</span><br><span class="line">	subq %r9,%rsi;%rsi-=1</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">	jne loop;not equal == not zero simple to while(rsi!=0)</span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">	.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>

<p>以 . 开头的词是汇编器伪指令，.pos 他告诉汇编器调整地址，从那里开始产生数据或者汇编代码。</p>
<p>其实逐行分析逻辑我们不难得到 sum 函数的一个定义：WORD sum(WORD *array,WORD length)，而该函数会求出 array[0]~array[length] 的和返回。</p>
<p>再上面的程序中，最终 sum 会返回 0xabcdabcdabcd。</p>
<h3 id="一些-Y86-64-指令的详情"><a href="#一些-Y86-64-指令的详情" class="headerlink" title="一些 Y86-64 指令的详情"></a>一些 Y86-64 指令的详情</h3><p>有些指令会更改指定寄存器的状态，比如 pushq 指令会令 %rsp 减去 8，将值放入该栈空间。当我们执行 pushq %rsp 时，处理器的行为是不确定的，因为入栈的寄存器会在这条指令中被更改状态，这种情况下就会存在两种不同的结果：</p>
<ul>
<li>压入 %rsp 的原始值（x86-64采用的约定）</li>
<li>压入减去 8 的 %rsp 的值</li>
</ul>
<p>经过一个测试程序，我们发现，pushq 指令并不按照我们常规的理解，先减后放，而是先放后减。</p>
<p>其实在我看来，如果以流水线执行指令的方式去理解这个问题会好理解的多，这个在后面具体讲讲自己的看法吧。</p>
<p>对于 popq %rsp 指令，书中给了一个练习，有如下的测试程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movq %rsp,%rdi</span><br><span class="line">pushq $0xabcd</span><br><span class="line">popq %rsp</span><br><span class="line">movq %rsp,%rax</span><br><span class="line">movq %rdi,%rsp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>发现这个函数的结果总是会返回 0xabcd，说明 pop %rsp 是先减去了 %rsp 再赋的值，这个略微有点复杂，在讲指令流水的时候也会讲这个情况的处理方式。</p>
<p>不过现在这个阶段，我们照着上面的理解即可，是先移动指针再取出来。</p>
<p>push 和 pop 两个指令在对 %rsp 寄存器本身操作时，都会尽量保证得到的值是原始值。</p>
<p>pushq %rsp 一定会压最初的 %rsp。</p>
<p>popq %rsp 一定是把那个值正确地给到了 %rsp。</p>
<p>跳转链接：<a href="#1">push 的理解</a></p>
<p>跳转链接：<a href="#2">pop 的理解</a></p>
<h2 id="逻辑设计和硬件控制语言HCL"><a href="#逻辑设计和硬件控制语言HCL" class="headerlink" title="逻辑设计和硬件控制语言HCL"></a>逻辑设计和硬件控制语言HCL</h2><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p>这个就是数电的知识复习了，常见的逻辑门就是 and or not，并且 and or 常见为两输入，但是可以扩展到 n 输入的状态，比如三输入的与门用 HCL 表示就为 a&amp;&amp;b&amp;&amp;c，逻辑门总是活动的，一旦一个门的输入发生变化，在很短的时间内输出也会相应变化。</p>
<h3 id="组合电路和HCL布尔表达式"><a href="#组合电路和HCL布尔表达式" class="headerlink" title="组合电路和HCL布尔表达式"></a>组合电路和HCL布尔表达式</h3><p>用很多逻辑门相互连接形成一张网，就能构建计算块，称为组合逻辑电路，构建这个网有以下限制</p>
<ul>
<li>每个逻辑门的输入必须连接到一下三个选项之一：系统输入，某逻辑单元的输出，某逻辑门的输出</li>
<li>两个或多个逻辑门的输出不能连接在一起</li>
<li>网必须无环</li>
</ul>
<p>多路复用器（MUX）根据输入控制信号的值，从一组不同的数据信号中选择一个作为输出。</p>
<p>HCL表达式和C表达式会有以下区别：</p>
<ul>
<li>C表达式的参数允许是任意整数，非 0 的值均被视为 1，而 HCL 的输入只允许 1 或 0</li>
<li>C逻辑表达式可能会出现部分求值的特性，如果一个 and 或者 or 运算只对第一个参数求值之后就能确定，那么就不会对第二个参数求值了，而组合逻辑电路没有这种规则。</li>
</ul>
<h3 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a>字级的组合电路和HCL整数表达式</h3><p>处理器中会遇到很多多路复用器，我们用情况表达式来描述，通用格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">select1:expr1;</span><br><span class="line">select2:expr2;</span><br><span class="line">select3:expr3;</span><br><span class="line">...</span><br><span class="line">selectk:exprk;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这个表达式包含了一系列情况，表明了什么时候选择这种情况，后者是指得到的值。</p>
<p>同 switch 不同，不要求选择表达式之间互吃，从逻辑上来讲，它们会被顺序求值，且第一额为 1 的情况会被选中。</p>
<p>有一个比较有意思的例子</p>
<p>如果需要寻找 A，B，C 中的最小值输出，用一般的HCL可以这么描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	A&lt;=B&amp;&amp;A&lt;=C:A;</span><br><span class="line">	B&lt;=A&amp;&amp;B&lt;=C:B;</span><br><span class="line">	<span class="number">1</span>:C</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这个比较经典，但是下面会让我们用三个比较来实现功能，其实不难得出，如果上述条件不满足，那么A肯定不是最小的，如果A都不是最小的了，我也没必要拿它来比了，所以我们的 HCL就可以简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	A&lt;=B&amp;&amp;A&lt;=C:A;</span><br><span class="line">	B&lt;=C:B;</span><br><span class="line">	1:C</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h3><p>用于匹配多个值中的其中一个，可以理解为集合中的属于。</p>
<p>常用格式就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iexpr in &#123;iexpr1,iexpr2...,iexprk&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><ul>
<li>时钟寄存器（简称寄存器）：存储单个位或字，时钟信号控制加载输入值。</li>
<li>随机访问存储器（简称内存，Random Access Memory）：存储多个字，通过地址选择该读或该写哪些字。</li>
</ul>
<p>这里注意一个概念就是关于寄存器，在硬件中，寄存器就是一个电子器件，在机器级编程时它是一个寄存器文件，我们把这两类概念分别称为硬件寄存器和程序寄存器。</p>
<p>在每个时钟信号上升沿时，值才会从寄存器输入给到输出。</p>
<img src="/2022/12/27/CSAPP_4/3.png" class="">

<p>如上图所示，对于整个寄存器文件，有两个读端口，一个写端口，每个端口都有一个地址输入，这里的地址表明该选哪个寄存器进行读或者是写。</p>
<p>因为允许同时读写，因此可能会发生冲突，如果发生了冲突，肯定会按照固定的逻辑去执行操作的。</p>
<img src="/2022/12/27/CSAPP_4/4.png" class="">

<p>这个内存有一个地址输人，一个写的数据输入，以及一个读的数据输出。同寄存器文件 一样，从内存中读的操作方式类似于组合逻辑：如果我们在输入 address 上提供一个地址, 并将 write 控制信号设置为 0, 那么在经过一些延迟之后，存储在那个地址上的值会出现在 输出 data 上。如果地址超出了范围，error 信号会设置为 1，否则就设置为 0。写内存是由 时钟控制的：我们将 address 设置为期望的地址，将 data in 设置为期望的值，而 write 设 置为 1。然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。对于读 操作来说，如果地址是不合法的，error 信号会被设置为 1。这个信号是由组合逻辑产生的， 因为所需要的边界检查纯粹就是地址输人的函数，不涉及保存任何状态。</p>
<p>这里其实可以这么看，地址就是主存地址寄存器（Memory Address Register），数据输入就是 主存数据寄存器（Memory Data Register），数据输出应该也是会输出到主存数据寄存器中。</p>
<h2 id="Y86-64-的顺序实现"><a href="#Y86-64-的顺序实现" class="headerlink" title="Y86-64 的顺序实现"></a>Y86-64 的顺序实现</h2><p>首先，我们描述一个称为 SEQ 的处理器。每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步骤。不过如果是这样一条指令的执行就会显得时间很慢，我们需要降低时钟周期以便于适配所有指令。开发 SEQ 的目标就是提供实现最终目的的第一步：是实现一个<strong>高效的、流水线化的处理器</strong>。</p>
<h3 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h3><p>处理一条指令包括很多操作，通常我们分为以下6个步骤。</p>
<ul>
<li>取指（fetch）：取指阶段从内存读取指令字节，地址为程序计数器（PC）的值。从指令中抽取出指令指示符字节的两个四位部分，称为icode（指令代码）和ifun（指令功能）。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符rA和rB。它还可能取出一个四字节常数字valc。它按顺序方式计算当前指令的下一条指令的地址valP。也就是说，valP等于PC的值加上已取出指令的长度。</li>
<li>译码（decode）：译码阶段从寄存器文件读入最多两个操作数，得到值va1A和&#x2F;或valB。通常，它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器rsp的。</li>
<li>执行（execute）：在执行阶段，算术&#x2F;逻辑单元（ALU）要么执行指令指明的操作（根据ifun的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为valE。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检验条件码和传送条件（由ifun给出），如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。</li>
<li>访存（memory）：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为valM，这一步理解为读写内存数据。</li>
<li>写回（write back）：写回阶段最多可以写两个结果到寄存器文件，这一步可以理解为更新寄存器。</li>
<li>更新PC（PC update）：将PC设置成下一条指令的地址，更新 %rip 寄存器。</li>
</ul>
<p>通用指令的指令执行步骤：</p>
<img src="/2022/12/27/CSAPP_4/5.png" class="">

<p>这里需要注意，OPq 操作会设置条件码，用于条件跳转和条件传送指令。</p>
<div id="1"></div>因为它是按照这个顺序执行的，所以也可以理解一点前面 pushq %rsp 的问题了，因为在访存阶段会把地址和数据分别放到 MAR 和 MDR 中，因此当我更新 %rsp 寄存器的时候，访存已经完成，此时 %rsp 的原石值在 MDR 当中，因此就会显得是先把数据放入栈中再移动栈指针的感觉，实际上是由这样流水作业的顺序完成的。

<p>比如下面的 demo</p>
<img src="/2022/12/27/CSAPP_4/6.png" class="">

<p>跟踪第六行代码的执行情况可以得到以下结果</p>
<img src="/2022/12/27/CSAPP_4/7.png" class="">

<p>不难看出，译码阶段如果 valA 取出 %rsp 寄存器的值，那么得到的一定是 %rsp 的原始值，因为 %rsp 在写回阶段才会更新。</p>
<p>所以顺序一定是先更新内存，再更新寄存器，popq %rsp 也是同理，首先读内存，然后再增加栈指针。</p>
<p>最后我们看看 ret 指令的执行并跟踪上面 demo 的第 13 行。</p>
<img src="/2022/12/27/CSAPP_4/8.png" class="">

<p>访存阶段读取了栈顶内存并将此设为了新的 PC。</p>
<h3 id="SEQ-硬件结构"><a href="#SEQ-硬件结构" class="headerlink" title="SEQ 硬件结构"></a>SEQ 硬件结构</h3><p>SEQ 的硬件结构如下图所示</p>
<img src="/2022/12/27/CSAPP_4/9.png" class="">

<p>从下网上看这张图，可以看到指令的一个执行过程以及硬件连接的情况。</p>
<ul>
<li>取指（Fetch）阶段：根据 PC 的值从内存中读取指令，计算指令长度并将新的 PC 暂时放入值 valP 当中。</li>
<li>译码（Decode）阶段：会根据指令中需要的寄存器从寄存器文件中读取对应寄存器的值，得到两个操作数。</li>
<li>执行（Execute）阶段：将操作数送入 ALU 中计算得到 valE，可能会写回寄存器，从端口 E 中写回，这一步会更新标志寄存器。</li>
<li>访存（Memory）阶段：根据 MAR 和 MDR 对内存进行访问（读&#x2F;写），读出的结果若要写寄存器则会从端口 M 写寄存器文件。</li>
<li>写回（Write Back）阶段：将新的寄存器值更新到寄存器文件中，这里有两个更新端口，一个是 E 用于接收 ALU 计算的结果，一个是 valM 用于接收读取内存的结果。</li>
<li>更新PC（PC update）阶段：根据预先保存的地址或者是之前计算的指令预计的下一步位置去更新 PC。</li>
</ul>
<h3 id="SEQ的时序"><a href="#SEQ的时序" class="headerlink" title="SEQ的时序"></a>SEQ的时序</h3><p>SEQ 的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存 器），随机访问存储器（寄存器文件、指令内存和数据内存）。组合逻辑不需要任何时序或 控制—只要输人变化了，值就通过逻辑门网络传播。我们也将读随 机访问存储器看成和组合逻辑一样的操作，根据地址输人产生输出字。对于较小的存储器 来说(例如寄存器文件），这是一个合理的假设，而对于较大的电路来说，可以用特殊的时 钟电路来模拟这个效果。由于指令内存只用来读指令，因此我们可以将这个单元看成是组合逻辑。 </p>
<p>现在还有四个硬件单元需要对他们的时序进行明确的控制——程序计数器、 条件码寄存器、数据内存和寄存器文件，这些单元通过一个时钟信号来控制，它触发将新值装载到寄存器以及将值写到随机访问存储器。每个时钟周期，程序计数器都会装载新的指令地址。因为只有在 OPq 操作时才会改变操作码，在执行数据传送指令（mov），push，call 的时候才会进行写数据内存，所以我们只需要控制内存和寄存器的时钟控制信号即可实现一模一样的效果，即使所有的状态更新实际上同时发生， 且只在时钟上升开始下一个周期时。之所以能保持这样的等价性，是由于 Y86-64 指令集 的本质，因为我们遵循以下原则组织计算 ：</p>
<ul>
<li>原则：从不回读</li>
</ul>
<p>处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</p>
<h3 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a>SEQ阶段的实现</h3><p>首先给出如下常数定义</p>
<img src="/2022/12/27/CSAPP_4/10.png" class="">

<h4 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h4><img src="/2022/12/27/CSAPP_4/11.png" class="">

<p>就像这个图所示，首先取出 PC 所指示的内存的第一个字节分割得到高四位的 icode 和低四位的 ifun，然后会判断该指令是否合法，由图示信号 Instr valid 得到，同时也可以计算得到该指令是否包含常数（Need valC）以及寄存器（Need regids）。</p>
<p>这里的 Instr valid 可以用 HCL 描述为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instr_valid=</span><br><span class="line">icode in&#123;</span><br><span class="line">	<span class="number">0xC</span>,<span class="number">0xD</span>,<span class="number">0xE</span>,<span class="number">0xF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样 Need_regids 也可以用 HCL 描述为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Need_regids =</span><br><span class="line">icode in &#123; </span><br><span class="line">    IRRMOVQ,IOPQ,IPUSHQ,IPOPQ,</span><br><span class="line">    IIRMOVQ,IRMMOVQ,IMRMOVQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Need_valC 用 HCL 描述为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Need_valC=</span><br><span class="line">icode in&#123;</span><br><span class="line">	IIRMOVQ,IMRMOVQ,IRMMOVQ,</span><br><span class="line">	IJXX,ICALL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h4><h5 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h5><p>图 4-28 给出了 SEQ 中实现译码和写回阶段的逻辑的详细情况。把这两个阶段联系在 一起是因为它们都要访问寄存器文件。</p>
<img src="/2022/12/27/CSAPP_4/12.png" class="">

<p>每个端口都有一个地址连接和一个数据连接，地址连接是一个寄存器 ID, 而数据连接是一组 64 根线路，既可以作为寄存器文件的输出字（对读 端口来说），也可以作为它的输人字（对写端口来说）。 两个读端口的地址输人为 srcA 和 srcB，而两个写端 口的地址输人为 dstE 和 dstM。如果某个地址端口上 的值为特殊标识符 OxF( RNONE)，则表明不需要访问 寄存器。</p>
<p>就是说， srcA 和 srcB 决定我从哪个寄存器读数据，对应从 valA 和 valB 中读出。同理 destE 和 destM 决定我要去写哪个寄存器，对应数据从 valE 和 valM 中写入。</p>
<p>下面两题比较有意思：</p>
<p>第一个是取 srcA 的一个信号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word srcA = [</span><br><span class="line">    icode in &#123;IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ &#125; : rA;</span><br><span class="line">    icode in &#123;IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">    1 : RNONE; # Don&#x27;t need register</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是， srcA 是用于读的一个寄存器，因此只有在 rrmovq，rmmovq，OPq，pushq 指令需要读取操作数所包含的寄存器。这里只有两个数据传送指令，其余的指令，比如说 mrmovq，这个可能需要看看之前那个大表了，它的源操作数在 rB，目的操作数在 rA，所以 rA 没必要被读取。再比如说 irmovq，源操作数为立即数 rA 为 0xF，也就是 RNONE。</p>
<p>然后第二个条件，也就是说在 popq 和 ret 两个指令执行的时候，我们需要额外读取一个 rsp 寄存器，</p>
<p>第二个是取 srcB 的信号，先给出答案吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word srcB = [</span><br><span class="line">    icode in &#123;IRMMOVQ, IMRMOVQ, IOPQ  &#125; : rB;</span><br><span class="line">    icode in &#123;IPOPQ, IRET, ICALL, IPUSHQ &#125; : RRSP;</span><br><span class="line">    1 : RNONE; # Don&#x27;t need register</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄存器→内存 的一个过程，内存我们需要读取寄存器与一个偏移的立即数相加，因此需要读取 rB 寄存器的值算出地址得到目的操作数的具体地址。而 内存→寄存器 的一个过程，前面说过了，因为它的寄存器反了，源操作数那边的寄存器为 rB，所以为了计算内存地址我们依然要读取这个寄存器。</p>
<p>这里多了的 pushq 指令，除了源操作数 rA 以外，需要额外读取一个 rsp 寄存器以方便我们放入栈中，call 指令其实就是 push rip + jmp 指令，因此同理，只是不太清楚这个 popq 和 ret 怎么来的。</p>
<h5 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h5><p>其实就是对寄存器文件的写，其实很简单，想想对目的操作数为寄存器的几个指令即可。</p>
<p>那么很容易写出 dstE 的 HCL 描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word dstE = [</span><br><span class="line">    icode in &#123; IRRMOVQ &#125; : rB;</span><br><span class="line">    icode in &#123; IIRMOVQ, I0PQ&#125; : rB;</span><br><span class="line">    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    1 : RNONE; # Don&#x27;t write any register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>首先我们需要清楚，dstE 是从 ALU 中计算得到的结果，rrmovq 相当于是从 rA 中取出值 +0 写回 rB，因此写回的值是从 ALU中出来的，OPq 指令也一样，结果是从 ALU 取得写回目的寄存器，以及 irmovq同理。</p>
<p>特别的，pushq，popq，call，ret指令会改变 rsp，rsp是会通过 ALU 进行 +8 -8的，这四个指令都会更新 rsp。</p>
<p>dstM 的 HCL 描述如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word dstM = [</span><br><span class="line">	icode in &#123;IMRMOVQ,POPQ&#125;:rA;</span><br><span class="line">	1 : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>这个可以参考前面的各个指令的执行阶段，mrmovq 很好理解，就是从内存中读出的值写到了目的寄存器， 也就是valM。popq也一样，从栈中取得值放到目的寄存器中。这里再提一下，就是 rmmovq 的目的寄存器是 rA。</p>
<div id="2"></div>

<blockquote>
<p>练习4.22  只有popq指令会同时用到寄存器文件的两个写端口。对于指令popq %rsp，E和M两个写端口会用到同一个地址，但是写入的数据不同。为了解决这个冲突，必须对两个写端口设立一个优先级，这样一来，当同一个周期内两个写端口都试图对一个寄存器进行写时，只有较高优先级端口上的写才会发生。那么要实现练习题4.8中确定的行为，哪个端口该具有较高的优先级呢？</p>
</blockquote>
<p>那么这里也描述的很清楚了，当读写端口的两个写操作指向了同一个寄存器，那么会设置优先级来确保其唯一，根据之前的一个特性观察我们会发现 pop %rsp 执行完成之后总是会使用栈（内存）中的数据给到 %rsp。那么不难得出 dstM 的优先级会高于 dstE。</p>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>执行阶段的逻辑图如下图所示</p>
<img src="/2022/12/27/CSAPP_4/13.png" class="">

<p>执行阶段包括算术&#x2F;逻辑单元（ALU)。这个单 元根据 alufun 信号的设置，对输人 aluA 和 aluB 执行 ADD、SUBTRACT、 AND 或 EXCLUSIVEOR 运算。如图 4-29 所示，这些数据和控制信号 是由三个控制块产生的。ALU 的输出就是 valE 信号。</p>
<h5 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h5><p>执行阶段的第一步就 是每条指令的 ALU 计算。列出的操作数 aluB 在 前面，后面是 aluA，这样是为了保证 subq 指令 是 valB 减去 valA。可以看到，根据指令的类型， aluA 的值可以是 valA、valC, 或者是 -8 或+8。 因此可以用如下的 HCL 表达式来描述 aluA 的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">word aluA=[</span><br><span class="line">    icode in &#123; IRRMOVQ,IOPQ&#125;:valA; </span><br><span class="line">    icode in &#123; IIRMOVQ,IRMMOVQ,IMRMOVQ&#125;:valC; </span><br><span class="line">    icode in &#123; ICALL,IPUSHQ&#125;:-8; </span><br><span class="line">    icode in &#123; IRET,IPOPQ&#125;:8;</span><br><span class="line">    #Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>来解释一波：</p>
<ul>
<li>OPq 指令就不用说了，本身就会用到 ALU 的，aluA 的输入就是源操作数，也就是 rA 寄存器读出的 valA。</li>
<li>rrmovq 指令是把源寄存器的值赋值给目的寄存器，虽然只是简单的数据传送，但是写寄存器只有两个端口：要么是内存里来的从 dstM 出，要么是 ALU 来的，从 dstE 中出。这里显然我们还是要经过 ALU，那么目的操作数可以直接给 0 然后作个加法输出，所以它的源操作数也是从 rA 寄存器读出的 valA。</li>
<li>irmovq 指令是将立即数赋值给目的寄存器，我们需要从指令中取出这个立即数经过算术逻辑单元 +0 之后写寄存器，因此它的输入就是 valC</li>
<li>rmmovq 和 mrmovq 同理，因为它们都有一个偏移量要和目的寄存器相加，也得从指令中取出立即数经过 ALU 与寄存器的值相加。因此这两个指令的 aluA 输入都是 valC。</li>
<li>call 和 push 基本一致，只是 call 指令比 push 多了一个 jmp 而已，这个指令需要我们对 %rsp 寄存器操作，而 %rsp 是目的操作数，而源操作数自然是 -8 让栈顶抬高 8 个字节。</li>
<li>ret 和 popq 同理，就是让栈降低 8 个字节，源操作数为 +8。</li>
</ul>
<p>下面有一个练习让我们写出 aluB 的 HCL 描述，其实比较简单，甚至比上面的简单。指令肯定还是那些指令，不同的就是 跟栈操作相关的目的操作数皆为 %rsp 也就是从 valB 中读出来的值，因此这四个指令都是 valB。除此之外，OPq，mrmovq，rmmovq 的目的操作数皆为目的寄存器 rB，因此从中读出来的 valB 也就是 aluB 的输入。</p>
<p>但是之前还提到了，有两个只是数据传送的指令，相当于是要 +0，那么那两个指令的目的操作数就是 0，那我们很容易写出它的 HCL 描述了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word aluB=[</span><br><span class="line">    icode in &#123; IRMMOVQ,IMRMOVQ,IOPQ,ICALL,IPUSHQ,IRET,IPOPQ&#125; : valB; </span><br><span class="line">    icode in &#123; IRRMOVQ,IIRMOVQ&#125;:0;</span><br><span class="line">    # Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h5 id="行为控制"><a href="#行为控制" class="headerlink" title="行为控制"></a>行为控制</h5><p>ALU（Arithmetic logic unit） 叫 《算数逻辑单元》，肯定不能只会简单的加法，还得实现 Y86-64 架构下面的其它运算，减法，异或，按位与。</p>
<p>因此这里有一个信号 ALUfun 用于控制 ALU 让它对操作数执行什么运算。</p>
<p>对于这个信号我们也很好写出它的 HCL 描述：只在执行 OPq 指令的时候根据 func 功能位去选择运算种类。其它情况都使用加法即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word alufun = [</span><br><span class="line">	icode == IOPQ : ifun;</span><br><span class="line">	1 : ALUADD</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>特别地，在 ALU 执行 OPq 指令的时候会设置条件寄存器（CC），那么有一个信号 setCC 就是告诉 ALU 是否对执行结果设置 CC。它的 HCL 可以描述为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool set_cc = icode in &#123;IOPQ&#125;;</span><br></pre></td></tr></table></figure>

<p>标号为 cond 的硬件单元会根据条件码和功能码来确定是否进行条件分支或者条件 数据传送。它产生信号 Cnd, 用于设置条件传送的 dstE，也用在条件分支的下 个 PC 逻辑中。对于其他指令，取决于指令的功能码和条件码的设置，Cnd 信号可以被设置为 1 或者 0，这里我们不管它如何实现条件判断，只给一个简单的设定：Cnd 信号为 1 表示条件满足，为 0 表示不满足。</p>
<p>这里还有一个 练习24 让我们修改 dstE 的 HCL 描述让它可以实现条件传送，也很简单：我们只需要在进行 rrmovq 的时候判断一下 Cnd 信号是否有效即可，如果不满足则将 dstE 设置为 RNONE 表示不需要写回任何寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word dstE = [</span><br><span class="line">    icode in &#123; IRRMOVQ &#125; : rB;</span><br><span class="line">    icode in &#123; IIRMOVQ, I0PQ&#125; : rB;</span><br><span class="line">    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    1 : RNONE; # Don&#x27;t write any register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="访存"><a href="#访存" class="headerlink" title="访存"></a>访存</h4><p>逻辑如图所示</p>
<img src="/2022/12/27/CSAPP_4/14.png" class="">

<p>访存阶段的任务就是读或者写程序数据。如图 4-30 所示，两个控制块产生内存地址和内存输入数据（为写操作）的值。另外两个块产生表明应该执行读操作还是写操作的控制信号。当执行读操作时， 数据内存产生值 valM。</p>
<p>图 4-1 8 图 4-2 1 的访存阶段给出了每个指令 类型所需要的内存操作。可以看到内存读和写的 地址总是 valE 或 valA。 这个块用 HCL 描述 就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word mem_addr=[</span><br><span class="line">    icode in&#123;IRMMOVQ,IPUSHQ,ICALL,IMRMOVQ&#125; : valE;</span><br><span class="line">    icode in&#123;IPOPQ,IRET&#125; : valA;</span><br><span class="line">    #Other instructions don&#x27;t need address</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>也来解释一下这个例子吧</p>
<p>访存不论是读还是写，都需要指明读写的地址，所以我们要观察地址怎么得出的，是 ALU 计算过了（valE），还是直接寄存器取出（valA）。</p>
<ul>
<li>对于 rmmovq 指令，我们的内存地址需要经过一个寄存器和一个加法运算，得到的才是最终访问的地址，所以是 valE，mrmovq 同理，只不过前者是写，后者是读。</li>
<li>pushq 和 call 一样，都是有一个入栈操作。我们来想想入栈是需要写的，写的内存在哪？ %rsp - 8 的位置上，而这个 -8 就不是从寄存器来的，也是 ALU 中来的，因此这两个指令也是 valE 作为地址访问。</li>
<li>popq 和 ret 指令都包含出栈操作，出栈是读操作，读的其实就是 %rsp 所指示的地址的值，因此它不需要经过 ALU 计算，直接从 valA 中取值即可。</li>
</ul>
<p>来看看练习 25：</p>
<blockquote>
<p>观察图 4-18 图 4-21 所示的不同指令的访存操作 ，我们可以看到内存 写的数据总是 valA 或 valP。写出 SEQ 中信号 mem_data 的 HCL 代码。 我们希望只为从内存读数据的指令设置控制信号 mem_read，用 HCL 代码表示就是：bool mem_read &#x3D; icode in { IMRMOVQ, IPOPQ, IRET };</p>
</blockquote>
<p>其实这里大部分都是 valA 要被写入内存，valP 就是下一条指令的地址，这个我们只会在 call 指令中遇到，会把这个值保存在栈中，其它要写内存的指令大部分都是直接给源操作数 valA。</p>
<p>所以 HCL 代码就很好写出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word mem_data = [</span><br><span class="line">	icode in &#123;IPUSHQ,IRMMOVQ&#125; : valA;</span><br><span class="line">	icode in &#123;ICALL&#125; : valP;</span><br><span class="line">	#other instructions don&#x27;t need mem_data</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>再来看看练习 26：</p>
<blockquote>
<p>我们希望只为向内存写数据的指令设置控制信号 mem_write。写出 SEQ 中信号 mem_write 的 HCL 代码 。</p>
</blockquote>
<p>就上面那三个指令需要写，判断是否在执行那三个指令即可了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool mem_write = icode in &#123;IPUSHQ,IRMMOVQ,ICALL&#125;</span><br></pre></td></tr></table></figure>

<p>练习27 倒是没啥，用它自带的信号发生器，给 Stat 设置就好了，如果某个异常信号为 1 了就直接设置 Stat。</p>
<h4 id="更新-PC"><a href="#更新-PC" class="headerlink" title="更新 PC"></a>更新 PC</h4><img src="/2022/12/27/CSAPP_4/15.png" class="">

<p>最后一个阶段，更新PC，比较简单，因为 PC 要么就是用 valP 赋值，要么是 ret 了从 valM 中赋值，要么是 call 或者是 jmp，从 valC 中读取值过来作为新的 PC，但是还有条件跳转，这里就需要用 Cnd 信号了。</p>
<p>用 HCL 描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word new_pc = [</span><br><span class="line">    # Call. Use instruction constant</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    # Taken branch. Use instruction con</span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    # Completion of RET instruction. Use value from stack</span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    # Default: Use incremented PC</span><br><span class="line">    1 : valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="SEQ小结"><a href="#SEQ小结" class="headerlink" title="SEQ小结"></a>SEQ小结</h4><p>可以看到，通过将执行每条 不同指令所需的步骤组织成一个统一的流程，就可以用很少量的各种硬件单元以及一个时 钟来控制计算的顺序，从而实现整个处理器。不过这样一来，控制逻辑就必须要在这些单 元之间路由信号，并根据指令类型和分支条件产生适当的控制信号。</p>
<p>SEQ 唯一的问题就是它太慢了。时钟必须非常慢，以使信号能在一个周期内传播所 有的阶段。让我们来看看处理一条 ret 指令的例子。在时钟周期起始时，从更新过的 PC 开始，要从指令内存中读出指令，从寄存器文件中读出栈指针，ALU 将栈指针加 8, 为了 得到程序计数器的下一个值，还要从内存中读出返回地址。所有这一切都必须在这个周期 结束之前完成。</p>
<p>这种实现方法不能充分利用硬件单元，因为每个单元只在整个时钟周期的一部分时间 内才被使用。我们会看到引入流水线能获得更好的性能。 </p>
<h2 id="流水线设计的通用原理"><a href="#流水线设计的通用原理" class="headerlink" title="流水线设计的通用原理"></a>流水线设计的通用原理</h2><p>流水线字面意思来讲可以指一些工厂，比如生产一个零件，如果我让一个工人从锻造铁开始，然后一直到打磨成可以用的零件都让一个人来完成的话，可能生产一颗螺丝钉都要一天。但是如果我多安排几个工人，一个工人只干生产中的一件事，那么工人干重复的事效率就会大大提高。</p>
<h3 id="计算流水线"><a href="#计算流水线" class="headerlink" title="计算流水线"></a>计算流水线</h3><p>下图给出了一个很简单的非流水线化的硬件系统的例子，就是由一些执行计算的逻辑以及一个保存结果的寄存器组成的，时钟信号会在每个特定的时间间隔去保存寄存器。图中的计算块是用组合逻辑来实现的，意味着信号会穿过一系列逻辑门，在一定时间的延迟之后，输出就成为了输入的某个函数。</p>
<img src="/2022/12/27/CSAPP_4/16.png" class="">

<p>ps（皮秒，10e-12S） 是时间单位。在这个例子中，我们假设运算逻辑需要 300ps，加载寄存器需要 20ps，那么整个指令周期就是 320ps。</p>
<p>吞吐量就是十亿条指令&#x2F;S（GIPS）作为单位，在上面的例子中，这个系统的吞吐量就是 $\frac{1}{320\times 10^{-12}}&#x3D;3.12GIPS$，这么说我突然想到了寄组里面的 MIPS，因为这个跟一个指令集名字是一样的，就记住了，它是每秒百万条指令，这个 M 理解为 mega 而不是 million 会比较好，因为和这里的 GIPS 相对应嘛，而书上写的好像是 million。</p>
<p>那么假设将系统执行的计算分成三个阶段（A、B和C），每个阶段需要100ps。然后在各个阶段之间放上流水线寄存器，这样每条指令都会按照这三步经过这个系统，从头到尾完成一次就需要三个完整的时钟周期。</p>
<img src="/2022/12/27/CSAPP_4/17.png" class="">

<p>就像刚刚举的例子，这样就可以让三个阶段同时在工作，增加效率，但是执行单条指令所需时间增加。类比一下出来就是说，我一个人生产，因为零件一直在我的手上，我让零件进入新的阶段生产时，不需要重新了解这个零件，而在流水线中，因为不同阶段是不同的人在操作，因此一个人拿到上一个阶段的产物时，需要花少量时间去了解这个零件然后再操作，这在时间上面就会有开销，在上图中的形象的理解就是每经过一个阶段都需要花一定时间去读寄存器。</p>
<h3 id="流水线操作的详细说明"><a href="#流水线操作的详细说明" class="headerlink" title="流水线操作的详细说明"></a>流水线操作的详细说明</h3><p>把指令分为三个阶段，同一时间可能就会有三条指令经过不同的阶段，如图中的 240-360 这个阶段。</p>
<img src="/2022/12/27/CSAPP_4/18.png" class="">

<p>那么在下图中我们就跟踪了 240-360 这个时间段的电路活动。</p>
<img src="/2022/12/27/CSAPP_4/19.png" class="">

<p>指令I1经过阶段C，12经过阶段B，而13经过阶段A。就在时刻240（点1）时钟上升之前，阶段A中计算的指令I2的值已经到达第一个流水线寄存器的输入，但是该寄存器的状态和输出还保持为指令Il在阶段A中计算的值。指令Il在阶段B中计算的值已经到达第二个流水线寄存器的输入。当时钟上升时，这些输入被加载到流水线寄存器中，成为寄存器的输出（点2）。另外，阶段A的输入被设置成发起指令I3的计算。然后信号传播通过各个阶段的组合逻辑（点3）。就像图中点3处的曲线化的波阵面（curved wavefront）表明的那样，信号可能以不同的速率通过各个不同的部分。在时刻360之前，结果值到达流水线寄存器的输入（点4）。当时刻360时钟上升时，各条指令会前进经过一个流水线阶段。</p>
<p>从这个对流水线操作详细的描述中，我们可以看到减缓时钟不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方面，如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，因此当时钟上升时，寄存器的输入还不是合法的值。</p>
<p>如果时钟减缓运行，只不过是组合逻辑运行完成之后，不能够及时更新寄存器，但是也不会影响最终结果，但是如果加快时钟的话，如果某条指令某个阶段运行超出时钟周期，就会导致后面的指令取出一个不合法的值，出现严重错误。</p>
<h3 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h3><p>4-33 的图给出的例子就是比较礼箱的流水线化的系统，在这个系统当中可以分成三个相互独立的阶段，每个阶段所需时间都是一模一样的，但是会出现一些其它的因素降低流水线的效率。</p>
<img src="/2022/12/27/CSAPP_4/17.png" class="">

<h4 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a>不一致的划分</h4><p>实际情况不可能刚刚好，我们指令分出来的三个阶段刚好所需时间相等，当我们把时钟周期设置为 120ps 的时候，每一时刻，指令没有空闲。但是实际情况往往不能等分时间</p>
<img src="/2022/12/27/CSAPP_4/20.png" class="">

<p>图4-36展示的系统中和前面一样，我们将计算划分为了三个阶段，但是通过这些阶段的延迟从50ps到150ps不等。通过所有阶段的延迟和仍然为300ps。不过，运行时钟的速率是由最慢的阶段的延迟限制的。流水线图表明，每个时钟周期，阶段A都会空闲（用白色方框表示）100ps，而阶段C会空闲50ps。只有阶段B会一直处于活动状态。我们必须将时钟周期设  为150+20&#x3D;170ps，得到吞吐量为5.88GIPS。另外，由于时钟周期减慢，延迟增加到了 510ps。</p>
<p>对硬件设计者来说，将指令过程进行等分是很困难的，通常，处理器中的某些硬件单元，如ALU和内存，是不能被划分成多个延迟较小的单元的。这就使得创建一组平衡的阶段非常困难。在设计流水线化的Y86-64处理器中，我们不会过于关注这一层次的细节，但是理解时序优化在实际系统设计中的重要性还是非常重要的。</p>
<p>吞吐量为流水线单阶段最高的延时的倒数，延迟为完整执行一条指令所需的时间。</p>
<h4 id="流水线过深，收益反而下降"><a href="#流水线过深，收益反而下降" class="headerlink" title="流水线过深，收益反而下降"></a>流水线过深，收益反而下降</h4><p>如图所示</p>
<img src="/2022/12/27/CSAPP_4/21.png" class="">

<p>我们在这里划分了 50ps 一个阶段，那么我们所需最小时钟周期为 70ps，比起划分为 100ps 一个阶段，性能提高了 120&#x2F;70&#x3D;1.71 倍的效率，虽然我们将划分的阶段时长减小到了二分之一，但是效率确没有提高 2 倍，主要是流水线寄存器产生的延迟。如图这种情况，流水线寄存器的延迟占到了 28.6%。</p>
<p>现代的处理器采用了很深的流水线（15或者更多），它们把一条指令的执行分成很多简单的步骤，这样一来，每个阶段的延迟就很小。</p>
<h3 id="带反馈的流水线"><a href="#带反馈的流水线" class="headerlink" title="带反馈的流水线"></a>带反馈的流水线</h3><p>如果考虑上一条指令和下一条的指令没有任何关系，那么我们设计的流水线便畅通无阻，然而事实往往没那么简单，比如下面这个例子。</p>
<img src="/2022/12/27/CSAPP_4/22.png" class="">

<p>在第一条指令的执行阶段，可能第二条指令正在译码，甚至没有执行完毕等到 %rax 的最终结果，直到第一条指令写回才更新 %rax 寄存器，此时第二条指令已经过了执行阶段了，那么我的流水线就改变了这一整个代码的行为。</p>
<p>第二个例子是一个控制相关的例子：</p>
<img src="/2022/12/27/CSAPP_4/23.png" class="">

<p>通过流水线技术的加速，我们改变了整个系统的行为</p>
<img src="/2022/12/27/CSAPP_4/24.png" class="">

<p>当我们将流水线技术引入Y86-64处理器时，必须正确处理反馈的影响。很明显，像图4-38中的例子那样改变系统的行为是不可接受的。我们必须以某种方式来处理指令间的数据和控制相关，以使得到的行为与ISA定义的模型相符。</p>
<h2 id="Y86-64的流水线实现"><a href="#Y86-64的流水线实现" class="headerlink" title="Y86-64的流水线实现"></a>Y86-64的流水线实现</h2><p>我们终于准备好要开始本章的主要任务——设计一个流水线化的Y86-64处理器。首先，对顺序的SEQ处理器做一点小的改动，将PC的计算挪到取指阶段。然后，在各个阶段之间加上流水线寄存器。到这个时候，我们的尝试还不能正确处理各种数据和控制相关。不过，做一些修改，就能实现我们的目标——一个高效的、流水线化的实现Y86-64 ISA的处理器。</p>
<h3 id="SEQ-：重新安排计算阶段"><a href="#SEQ-：重新安排计算阶段" class="headerlink" title="SEQ+：重新安排计算阶段"></a>SEQ+：重新安排计算阶段</h3><img src="/2022/12/27/CSAPP_4/25.png" class="">

<p>我们移动PC阶段，使得它的逻辑在时钟周期开始时活动，使它计算当前指令的PC值。图4-39给出了SEQ和SEQ+在PC计算上的不同之处。在SEQ中（图4-39a），PC计算发生在时钟周期结束的时候，根据当前时钟周期内计算出的信号值来计算PC寄存器的新值。在SEQ+中（图4-39b），我们创建<strong>状态寄存器</strong>来保存在一条指令执行过程中计算出来的信号。</p>
<p>SEQ+不会有硬件寄存器来存放 PC，而是根据前一条指令保存下来的一些状态信息动态地计算 PC。比如取指的第一条指令是 irmovq，那么在取完之后我马上能知道下一条指令在 +8 的位置了。</p>
<p>SEQ到SEQ+中对状态单元的改变是一种很通用的改进的例子，这种改进称为电路重定时（circuit retiming）。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段之间的延迟。</p>
<h3 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h3><p>我们先来看一看整体的 SEQ+ 的硬件结构</p>
<img src="/2022/12/27/CSAPP_4/26.png" class="">

<p>可以看到取指阶段就对 PC 进行了增加，使得其更适合流水线工作。</p>
<p>然后我们需要用寄存器把五个阶段分隔开来。</p>
<p>流水线寄存器按如下方式标号：</p>
<ul>
<li>F（Fetch Code）保存程序计数器的预测值。</li>
<li>D（Decode）位于取指和译码阶段之间。它保存关于最新取出的指令的信息，即将由译码阶段进行处理。</li>
<li>E（Execute）位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理。</li>
<li>M（Memory Access）位于执行和访存阶段之间。它保存最新执行的指令的结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。</li>
<li>W（Write Back）位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成ret指令时，它还要向PC选择逻辑提供返回地址。</li>
</ul>
<p>于是我们得到了 PIPE- 架构</p>
<img src="/2022/12/27/CSAPP_4/27.png" class="">

<p>下面我们用一个五个指令的执行流程图来解释一下流水线的步骤。</p>
<img src="/2022/12/27/CSAPP_4/28.png" class="">

<p>这里给的图中，在第一个周期，I1 取指阶段，在第五个周期结束，I2 在第2个周期取指，第六个周期结束……</p>
<p>我们取出第五个周期的情况可以看看， I1 处于写回阶段，I2 处于访存解读那，I3 处于执行阶段，I4 处于译码阶段，I5 处于取指阶段，从下往上画的原因是为了让流水线看起来是自底向上流动的。</p>
<h3 id="对信号进行重新排列和标号"><a href="#对信号进行重新排列和标号" class="headerlink" title="对信号进行重新排列和标号"></a>对信号进行重新排列和标号</h3><p>顺序实现SEQ和SEQ+在一个时刻只处理一条指令，因此诸如 valC、srcA和valE这样的信号值有唯一的值。在流水线化的设计中，与各个指令相关联的这些值有多个版本，会随着指令一起流过系统。</p>
<p>例如，在PIPE一的详细结构中，有4个标号为“Stat”的白色方框，保存着4条不同指令的状态码（参见图4-41）。我们需要很小心以确保使用的是正确版本的信号，否则会有很严重的错误，例如将一条指令计算出的结果存放到了另一条指令指定的目的寄存器。我们采用的命名机制，通过在信号名前面加上大写的流水线寄存器名字作为前缀，存储在流水线寄存器中的信号可以唯一地被标识。</p>
<p>例如，4个状态码可以被命名为D_stat、E_stat、M_stat和W_stat。我们还需要引用某些在一个阶段内刚刚计算出来的信号。它们的命名是在信号名前面加上小写的阶段名的第一个字母作为前缀。以状态码为例，可以看到在取指和访存阶段中标号为“Stat”的控制逻辑块。因而，这些块的输出被命名为f_stat和m_stat。</p>
<p>我们还可以看到整个处理器的实际状态Stat是根据流水线寄存器 W 中的状态值，由写回阶段中的块计算出来的。</p>
<blockquote>
<p>在命名系统中，大与的丽级“D、“上”、“M和“W指的走流水线奇仔器，所以M_stat指的是流水线寄存器M的状态码字段。小写的前缓“f”、“d”、“e”、“m”和“w”指的是流水线阶段，所以mstat指的是在访存阶段中由控制逻辑块产生出的状态信号。</p>
</blockquote>
<p>后面这里提到的一个问题是，我们的寄存器 id 取自指令，它在译码阶段被取出，在写回阶段可能也会用到，就是说，我在译码阶段读出的 rA，rB 可能在写回阶段都要用，如果什么措施都不采取，就直接上流水线的话，我再写回阶段可能写到的是此时正在执行译码阶段的那个寄存器，这显然就改变了它指令的行为，因此我们中间需要插入流水线寄存器确保信息是正确的。</p>
<p>PIPE一中有一个块在相同表示形式的SEQ+中是没有的，那就是译码阶段中标号为“SelectA”的块。我们可以看出，这个块会从来自流水线寄存器D的valP或从寄存器文件A端口中读出的值中选择一个，作为流水线寄存器E的值valA。</p>
<p>包括这个块是为了减少要携带给流水线寄存器E和M的状态数量。在所有的指令中，只有ca11在访存阶段需要valP的值（压入下一个PC）。只有跳转指令在执行阶段（当不需要进行跳转时）需要valp的值。而这些指令又都不需要从寄存器文件中读出的值。因此我们合并这两个信号，将它们作为信号va1A携带穿过流水线，从而可以减少流水线寄存器的状态数量。这样做就消除了SEQ（图4-23）和SEQ+（图4-40）中标号为“Data”的块，这个块完成的是类似的功能。在硬件设计中，像这样仔细确认信号是如何使用的，然后通过合并信号来减少寄存器状态和线路的数量，是很常见的。</p>
<h3 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h3><p>在PIPE-设计中，我们采取了一些措施来正确处理控制相关。流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成。要是达到这个目的也就意味着吞吐量是每个时钟周期一条指令。要做到这一点，我们必须在取出当前指令之后，马上确定下一条指令的位置。不幸的是，如果取出的指令是条件分支指令，要到几个周期后，也就是指令通过执行阶段之后，我们才能知道是否要选择分支。类似地，如果取出的指令是ret，要到指令通过访存阶段，才能确定返回地址。</p>
<p>但是除此之外，我们都能在取指阶段结束后马上知道下一跳指令的地址，对于无条件跳转来说，下一条指令的地址是指令中的一个常数 valC，对于其他指令来说就是 valP。对于条件跳转指令来说，如果选择了跳转，那么 PC 新的值应当是 valC，如果选择不跳转，那么 PC 新的值应当是 valP。我们既可以预测选择了分支，也可以预测没有选择分支，既然预测能解决以上流水线的问题，我们还必须解决预测错误带来的麻烦，因为发现预测错误的时候往往已经执行了部分我们预测的指令，在之后我们会讨论这个错误处理。</p>
<h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p>我们需要在流水线中引入反馈系统，因为当相邻指令有关联的时候，前一条指令并不能和后一条指令并行执行。这个关联有两种形式</p>
<ul>
<li>数据相关：后一条指令需要读取前一条指令执行的结果</li>
<li>控制相关：后一条指令为条件跳转，条件取决于当前语句的执行状态。</li>
</ul>
<p>这些相关有可能会导致指令执行得到错误的结果，称为冒险。同相关一样，冒险也可以氛围数据冒险和控制冒险。我们先考虑数据冒险。</p>
<h4 id="数据冒险的解决方案"><a href="#数据冒险的解决方案" class="headerlink" title="数据冒险的解决方案"></a>数据冒险的解决方案</h4><h5 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h5><p>我们可以使用空指令（NOP）来避免冒险，只要我们在译码阶段保证上一条可能会影响我的指令已经完成了写回即可。在中间插入三条 NOP 指令，这样就可以在前一条指令的写回阶段我们再译码，确保不出问题。<br>当然这是宏观上面我们最容易理解的思路，实际上处理器会自己处理自动阻塞可能会发生冒险的指令，直到冒险条件去除才会继续执行而不是真的插入 NOP 指令，但是实际上执行起来就像插入了 NOP 指令一样。<br>缺点我们都看得出来，会严重降低整体的吞吐量。</p>
<h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>其实很简单，因为译码阶段已经可以确定寄存器和立即数，如果在 irmovq 的译码阶段我直接取出这个数，给较早的流水线阶段，这样甚至能避免下一条指令译码取数，这样就能避免暂停，这种技术称为数据转发（简称转发或者旁路（bypassing））。<br>有时候，值可能是在执行阶段得到的，我们在这个阶段得到的值同样可以给到下一条指令，但是需要硬件提供点小小的支持。</p>
<h5 id="加载-使用冒险"><a href="#加载-使用冒险" class="headerlink" title="加载&#x2F;使用冒险"></a>加载&#x2F;使用冒险</h5><p>转发操作不能解决这种冒险，如果有一个指令是访存得到寄存器的值（Load），它将在访存阶段才能拿到，而紧接着的下一条指令会使用这个寄存器，那么此时转发就不能解决了，因为下一条指令已经进入了执行阶段。</p>
<p>因此我们可以使用暂停+转发两种思想结合的方式解决冒险，如果发现访存得到的结果需要在下一条指令马上被访问，那么我就暂停一个指令周期等到访存结束之后马上转发给下一条指令，此时下一条指令正在译码阶段，还能来得及。</p>
<h5 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h5><p>当遇到条件跳转语句或 ret 指令的时候，处理器无法仅仅通过 PC 来预测下一条指令的地址。</p>
<p>不难发现，当执行 ret 的时候，我们需要等到 ret 访存完毕的时候才可以预测到下一条指令的地址，因此我们需要在中间插入三个 bubble。</p>
<p>而条件跳转指令预测错误的后果就是会多处理两条不该执行的指令，好在它们执行的指令只是到了译码阶段，并没有对实际的寄存器和内存做出什么变动，唯一的后果就是浪费了两条指令的处理能力。</p>
<hr>
<p>这一章彻底结束吧，把最基本的冒险，和解决方案了解完真的感觉差不多了，后面基本都是硬件部分，正式进入第五章了！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xia0ji233.github.io">xia0ji233</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xia0ji233.github.io/2022/12/27/CSAPP_4/">https://xia0ji233.github.io/2022/12/27/CSAPP_4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xia0ji233.github.io" target="_blank">xia0ji233's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/27/Go5/" title="Golang入门学习（5）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang入门学习（5）</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/26/Go4/" title="Golang入门学习（4）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Golang入门学习（4）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><a href="/"> <div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></a><div class="author-info__name">xia0ji233</div><div class="author-info__description">Nepnep team</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">310</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">90</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xia0ji233"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xia0ji233" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xia0ji233@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">老当益壮，宁移白首之心？穷且益坚，不坠青云之志。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Y86-64指令集体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8F%AF%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">程序员可见的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Y86-64%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">Y86-64指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据传送指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">整数操作指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">跳转指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.4.</span> <span class="toc-text">条件传送指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.6.</span> <span class="toc-text">栈操作指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">指令编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Y86-64%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.</span> <span class="toc-text">Y86-64异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Y86-64%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">Y86-64程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#demo"><span class="toc-number">1.5.1.</span> <span class="toc-text">demo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B-Y86-64-%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%A6%E6%83%85"><span class="toc-number">1.6.</span> <span class="toc-text">一些 Y86-64 指令的详情</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80HCL"><span class="toc-number">2.</span> <span class="toc-text">逻辑设计和硬件控制语言HCL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%97%A8"><span class="toc-number">2.1.</span> <span class="toc-text">逻辑门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E5%92%8CHCL%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">组合电路和HCL布尔表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%BA%A7%E7%9A%84%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E5%92%8CHCL%E6%95%B4%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">字级的组合电路和HCL整数表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">2.4.</span> <span class="toc-text">集合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8C%E6%97%B6%E9%92%9F"><span class="toc-number">2.5.</span> <span class="toc-text">存储器和时钟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64-%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">Y86-64 的顺序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%A4%84%E7%90%86%E7%BB%84%E7%BB%87%E6%88%90%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.</span> <span class="toc-text">将处理组织成阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">SEQ 硬件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ%E7%9A%84%E6%97%B6%E5%BA%8F"><span class="toc-number">3.3.</span> <span class="toc-text">SEQ的时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ%E9%98%B6%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">SEQ阶段的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%8C%87%E9%98%B6%E6%AE%B5"><span class="toc-number">3.4.1.</span> <span class="toc-text">取指阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%91%E7%A0%81%E5%92%8C%E5%86%99%E5%9B%9E%E9%98%B6%E6%AE%B5"><span class="toc-number">3.4.2.</span> <span class="toc-text">译码和写回阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%91%E7%A0%81"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">译码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%9B%9E"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">写回</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-number">3.4.3.</span> <span class="toc-text">执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">数据输入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">行为控制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E5%AD%98"><span class="toc-number">3.4.4.</span> <span class="toc-text">访存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0-PC"><span class="toc-number">3.4.5.</span> <span class="toc-text">更新 PC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SEQ%E5%B0%8F%E7%BB%93"><span class="toc-number">3.4.6.</span> <span class="toc-text">SEQ小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%80%9A%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">流水线设计的通用原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">4.1.</span> <span class="toc-text">计算流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">流水线操作的详细说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">流水线的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">4.3.1.</span> <span class="toc-text">不一致的划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%BF%87%E6%B7%B1%EF%BC%8C%E6%94%B6%E7%9B%8A%E5%8F%8D%E8%80%8C%E4%B8%8B%E9%99%8D"><span class="toc-number">4.3.2.</span> <span class="toc-text">流水线过深，收益反而下降</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%8D%E9%A6%88%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">4.4.</span> <span class="toc-text">带反馈的流水线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">Y86-64的流水线实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ-%EF%BC%9A%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%AE%A1%E7%AE%97%E9%98%B6%E6%AE%B5"><span class="toc-number">5.1.</span> <span class="toc-text">SEQ+：重新安排计算阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">插入流水线寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BF%A1%E5%8F%B7%E8%BF%9B%E8%A1%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%92%8C%E6%A0%87%E5%8F%B7"><span class="toc-number">5.3.</span> <span class="toc-text">对信号进行重新排列和标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E4%B8%8B%E4%B8%80%E4%B8%AAPC"><span class="toc-number">5.4.</span> <span class="toc-text">预测下一个PC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%92%E9%99%A9"><span class="toc-number">5.5.</span> <span class="toc-text">流水线冒险</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.5.1.</span> <span class="toc-text">数据冒险的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%82%E5%81%9C"><span class="toc-number">5.5.1.1.</span> <span class="toc-text">暂停</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91"><span class="toc-number">5.5.1.2.</span> <span class="toc-text">转发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-%E4%BD%BF%E7%94%A8%E5%86%92%E9%99%A9"><span class="toc-number">5.5.1.3.</span> <span class="toc-text">加载&#x2F;使用冒险</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9"><span class="toc-number">5.5.1.4.</span> <span class="toc-text">避免控制冒险</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/26/qwb2025_final/" title="无题">无题</a><time datetime="2025-11-26T15:16:12.318Z" title="发表于 2025-11-26 23:16:12">2025-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/16/Android1/" title="Android逆向学习（1）">Android逆向学习（1）</a><time datetime="2025-11-16T02:00:00.000Z" title="发表于 2025-11-16 10:00:00">2025-11-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/20/qwb2025_pre_reverse/" title="强网杯S9初赛Reverse writeup">强网杯S9初赛Reverse writeup</a><time datetime="2025-10-20T02:00:00.000Z" title="发表于 2025-10-20 10:00:00">2025-10-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/14/tencent-race-2025-final/" title="腾讯游戏安全竞赛2025决赛题解">腾讯游戏安全竞赛2025决赛题解</a><time datetime="2025-04-14T02:00:00.000Z" title="发表于 2025-04-14 10:00:00">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/31/tencent-race-2025-pre/" title="腾讯游戏安全大赛2025初赛题解">腾讯游戏安全大赛2025初赛题解</a><time datetime="2025-03-31T02:00:00.000Z" title="发表于 2025-03-31 10:00:00">2025-03-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By xia0ji233</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><script src="/live2d-widget/dist/autoload.js"></script><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>