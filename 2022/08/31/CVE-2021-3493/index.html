<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CVE-2021-3493复现 | xia0ji233's blog</title><meta name="author" content="xia0ji233"><meta name="copyright" content="xia0ji233"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="来复现一下这次的CVE-2021-3493">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2021-3493复现">
<meta property="og:url" content="https://xia0ji233.github.io/2022/08/31/CVE-2021-3493/index.html">
<meta property="og:site_name" content="xia0ji233&#39;s blog">
<meta property="og:description" content="来复现一下这次的CVE-2021-3493">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xia0ji233.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-08-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-01-17T10:49:22.757Z">
<meta property="article:author" content="xia0ji233">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xia0ji233.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xia0ji233.github.io/2022/08/31/CVE-2021-3493/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CVE-2021-3493复现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-17 18:49:22'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="xia0ji233's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">283</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">169</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/backgroud.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="xia0ji233's blog"><span class="site-name">xia0ji233's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CVE-2021-3493复现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-30T16:00:00.000Z" title="发表于 2022-08-31 00:00:00">2022-08-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-17T10:49:22.757Z" title="更新于 2025-01-17 18:49:22">2025-01-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-3493/">CVE-2021-3493</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CVE-2021-3493复现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>来复现一下这次的CVE-2021-3493</p>
<span id="more"></span>

<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>该漏洞是通过创建一个虚拟环境，在虚拟环境当中通过某软件赋予某文件高权限，由于程序检查不严密，该权限逃逸到现实环境中也生效。</p>
<h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><p><code>overlayfs</code> ：虚拟的，堆叠文件系统</p>
<p><code>capability</code>：权限管理机制</p>
<p><code>namespace</code>：一种命名空间</p>
<h3 id="overlayfs"><a href="#overlayfs" class="headerlink" title="overlayfs"></a>overlayfs</h3><p>能把多个文件夹里的文件合并为到同一个文件夹当中，这么听起来这个文件系统好像挺鸡肋的，但是它支持了一个我们最喜欢用的软件：docker。docker里面分容器和镜像的概念，一个镜像可以派生出多个容器，跟虚拟机差不多，一个镜像可以创建多个虚拟机。容器分公有数据和私有数据，docker比虚拟机优势的一点就是docker中的公有数据所有容器共享，这样就能省磁盘空间，私有数据则可以各个容器独占，保证数据独立。docker的实现机制就是通过 <code>overlayfs</code> 文件系统实现的。</p>
<p><code>overlayfs</code> 依赖并建立在其它的文件系统之上（例如ext4fs和xfs等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。</p>
<img src="/2022/08/31/CVE-2021-3493/1.png" class="">



<p>其中lower dirA &#x2F; lower dirB目录和upper dir目录为来自底层文件系统的不同目录，用户可以自行指定，内部包含了用户想要合并的文件和目录，merge dir目录为挂载点。当文件系统挂载后，在merge目录下将会同时看到来自各lower和upper目录下的内容，并且用户也无法（无需）感知这些文件分别哪些来自lower dir，哪些来自upper dir，用户看见的只是一个普通的文件系统根目录而已（lower dir可以有多个也可以只有一个）。</p>
<h4 id="overlayfs挂载"><a href="#overlayfs挂载" class="headerlink" title="overlayfs挂载"></a><code>overlayfs</code>挂载</h4><p>挂载一个overlay文件系统，可以通过mount -t overlay -o <options> overlay <mount point>来实现。</p>
<p><mount point>是最终overlay的挂载点。</p>
<p>其中overlay的options有如下：</p>
<ul>
<li>lower dir&#x3D;<dir>：指定用户需要挂载的lower层目录，lower层支持多个目录，用“:”间隔，优先级依次降低。最多支持500层。</li>
<li>upper dir&#x3D;<dir>：指定用户需要挂载的upper层目录，upper层优先级高于所有的lower层目录。</li>
<li>work dir&#x3D;<dir>：指定文件系统挂载后用于存放临时和间接文件的工作基础目录。</li>
</ul>
<p>下面将lower和upper进行overlay，挂载到merge目录，临时workdir为work目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay -o lowerdir=lower,upperdir=upper,workdir=work overlay merge</span><br></pre></td></tr></table></figure>

<p> 如下同样将lower和upper进行overlay到merge，但是merge为只读属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay -o lowerdir=upper:lower overlay merge</span><br></pre></td></tr></table></figure>

<p>在使用如上mount进行<code>overlayfs</code>合并之后，遵循如下规则：</p>
<ol>
<li><code>lower dir</code>和<code>upper dir</code>两个目录存在同名文件时，<code>lower dir</code>的文件将会被隐藏，用户只能看到<code>upper dir</code>的文件。</li>
<li><code>lower dir</code>低优先级的同目录同名文件将会被隐藏。</li>
<li>如果存在同名目录，那么<code>lower dir</code>和<code>upper dir</code>目录中的内容将会合并。</li>
<li>当用户修改<code>merge dir</code>中来自<code>upper dir</code>的数据时，数据将直接写入<code>upper dir</code>中原来目录中，删除文件也同理。</li>
<li>当用户修改<code>merge dir</code>中来自<code>lower dir</code>的数据时，<code>lower dir</code>中内容均不会发生任何改变。因为<code>lower dir</code>是只读的，用户想修改来自<code>lower dir</code>数据时，<code>overlayfs</code>会首先拷贝一份<code>lower dir</code>中文件副本到<code>upper dir</code>中。后续修改或删除将会在<code>upper dir</code>下的副本中进行，<code>lower dir</code>中原文件将会被隐藏。</li>
</ol>
<h4 id="docker如何使用overlayfs"><a href="#docker如何使用overlayfs" class="headerlink" title="docker如何使用overlayfs"></a>docker如何使用overlayfs</h4><p>在docker当中，我们为了方便理解，假设只有三个目录：<code>upper dir</code>,<code>lower dir</code>和<code>merge dir</code>。我们的镜像处于<code>lower dir</code>当中，初始情况下，我们通过镜像创建出来一个容器，<code>lower dir</code> 中就是一个镜像，<code>upper dir</code> 中为空，我们创建多个容器得到的都是和镜像一模一样的系统。当我尝试查看容器中的某个文件，根据规则1，因为 <code>upper dir</code> 为空，我们看的的内容是 <code>lower dir</code> 中的内容，也就是镜像的内容；当我尝试修改容器中的文件内容时，根据规则5，<code>lower dir</code> 中的内容只读，因此拷贝一份到 <code>upper dir</code> 中，根据规则1，我们之后将只能看到该文件 <code>upper dir</code> 中的内容，修改完成会将结果保存在 <code>upper dir</code> 当中，之后再次修改这个文件，将只在<code>upper dir</code> 当中进行。但是在我们的视角当中，我们跟操作一个完整的操作系统并没有很大的区别。并且多个容器大部分数据是共享的，因此比较节省磁盘空间。</p>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>我们新建四个文件夹：<code>upper</code>，<code>lower </code>，<code>work</code> 和 <code>merge</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay overlay -o lowerdir=./lower,upperdir=./upper,workdir=./work ./merge</span><br></pre></td></tr></table></figure>

<p><code>mount</code> 命令用于挂载操作，第一个 <code>overlay</code> 指定挂载类型为 <code>overlay</code> 第二个 <code>overlay</code> 指定挂载点，<code>-o</code> 选项指定上层目录，下层目录，工作目录，最后挂载到 <code>merge</code> 目录下。</p>
<p>挂载完成之后我们在 <code>lower</code> 和 <code>upper</code> 中分别创建 <code>1.txt</code> 和 <code>2.txt</code>。我们使用 <code>ls -lR</code> 来查看目录</p>
<img src="/2022/08/31/CVE-2021-3493/2.png" class="">

<p>我们可以发现， <code>merge</code> 目录中也出现了 <code>1.txt</code> 和 <code>2.txt</code>。</p>
<p>我们修改 <code>upper</code> 和 <code>lower</code> 中文件对应的内容，可以发现，<code>merge</code> 目录中也会有相同的改变，这非常符合 <code>overlayfs</code> 的规则。</p>
<p>我们尝试直接在 <code>merge</code> 目录中修改在 <code>upper</code> 目录中出现的文件再观察一下变化。</p>
<img src="/2022/08/31/CVE-2021-3493/3.png" class="">

<p>可以发现我们在 <code>merge</code> 目录中修改 <code>upper</code> 目录中出现的文件，对应也修改了 <code>upper</code> 目录的主体文件。</p>
<p>我们尝试在 <code>merge</code> 目录中修改只在 <code>lower</code> 目录出现的文件再观察一下变化。</p>
<img src="/2022/08/31/CVE-2021-3493/4.png" class="">

<p>我们发现，<code>lower</code> 目录中对应的 <code>1.txt</code> 并没有发生改变，反而是 <code>upper</code> 目录多了一个 <code>1.txt</code> 文件，并且内容与我们填写的一致。</p>
<p>那么这个 <code>1.txt</code> 就可以理解为docker中的镜像，<code>2.txt</code> 就是我容器中不同于镜像的文件。</p>
<h3 id="capability"><a href="#capability" class="headerlink" title="capability"></a>capability</h3><p>首先介绍几个概念：<code>uid</code>，<code>ruid</code>，<code>euid</code>，<code>suid</code>。</p>
<h4 id="uid-ruid"><a href="#uid-ruid" class="headerlink" title="uid(ruid)"></a>uid(ruid)</h4><p>标识用户身份， 比如常见的 <code>root </code>就是0，我们安装完操作系统获得的第一个账号就是1000，当登录完成之后，这个用户的ruid就是确定的了。</p>
<h4 id="euid"><a href="#euid" class="headerlink" title="euid"></a>euid</h4><p>euid是用户的有效id，用于系统决定对系统资源的访问权限，通常情况下，<code>euid=ruid</code>。我们都知道：只有进程的创建者和root用户才有权利对该进程进行操作（<code>kill</code>，或者挂起，又或者是 <code>fork</code>）。于是，记录一个进程的创建者(也就是属主)就显得非常必要，进程的 <code>uid</code> 通常就是进程创建者的 <code>uid</code>，若创建者为另一个进程（<code>fork</code>），那么这个进程的 <code>uid</code> 会被继承，除非子进程被设置了 <code>suid</code>。</p>
<h4 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h4><p>用于对外权限的开放。跟<code>ruid</code>及<code>euid</code>是用一个用户绑定不同，它是跟文件而不是跟用户绑定，在运行这个文件时，用户会暂时获得属主的身份。</p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>进程运行之后，会获得和运行者一样的权限，它们同样受到了自身的权限访问控制。事实上这样的管理是比较安全的，我如果想自己无法直接访问这个文件，那么我通过创建进程访问文件同样会没有权限。但是如果这样管理则不能满足一些需要，比如密码文件 <code>/etc/shadow</code>，这个文件的权限是 <code>r--------</code>，属主和数组均为 <code>root</code>，那就意味着，除了 <code>root</code> 用户没有人可以查看或者修改这个文件，但是里面同时也存了我自己的密码，如果我不管怎样都获得不了 <code>root</code> 权限，那意味着我自己都修改不了我自己的密码，那这显然不太合理。于是乎就出现了 <code>suid</code>（<code>Set User ID execution</code>），我们都知道在 <code>linux</code> 当中，我们想修改自己的密码是使用 <code>passwd</code> 命令，那我们查看 <code>passwd</code> 的权限发现它被设置了 <code>suid</code> 选项。它允许我在执行这个程序的时候短暂地获得 <code>root</code> 权限，这个进程拥有 <code>root</code> 权限之后，我们就能修改 <code>/etc/shadow</code> 文件，修改完成之后，进程直接退出。</p>
<p>这么一看确实挺方便了，但是会带来很大的安全问题：假设， <code>passwd</code> 文件在编写的时候，存在漏洞，若在执行 <code>passwd</code> 的过程中，能通过漏洞创建一个 <code>shell</code> 进程，那么这个 <code>shell</code> 进程也会是 <code>root</code> 权限，简而言之，**<code>SUID</code> 机制增大了系统的安全攻击面。**</p>
<p>为了对 root 权限进行更细粒度的控制，实现按需授权，Linux 引入了另一种机制叫 <code>capability</code>。</p>
<h4 id="capability是什么"><a href="#capability是什么" class="headerlink" title="capability是什么"></a>capability是什么</h4><p><code>Capabilities</code> 机制是在 Linux 内核 <code>2.2</code> 之后引入的一个权限管理机制，原理就是把超级用户 <code>root(uid=0)</code> 的特权划分为不同的功能组，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。</p>
<p>这样一来，我权限检查就变成了：如果非 <code>root</code> 用户，那么检查进程是否有对应的操作权限，决定是否可以进行该操作。同样，这个权限可以在执行的时候赋予：根据进程创建者或者 <code>setuid</code> 获得，也可以从父进程继承。假如我给 <code>nginx</code> 可执行文件赋予了 <code>CAP_NET_BIND_SERVICE capabilities</code> ，那么它就能以普通用户的身份运行并监听一个1024以内的端口。</p>
<h4 id="进程的capability"><a href="#进程的capability" class="headerlink" title="进程的capability"></a>进程的capability</h4><p>每一个进程，具有 5 个 capabilities 集合，每一个集合使用 64 位掩码来表示，显示为 16 进制格式。这 5 个 capabilities 集合分别是：</p>
<ul>
<li>Permitted</li>
<li>Effective</li>
<li>Inheritable</li>
<li>Bounding</li>
<li>Ambient</li>
</ul>
<p>这5个集合的具体含义如下：</p>
<h5 id="Permitted"><a href="#Permitted" class="headerlink" title="Permitted"></a>Permitted</h5><p>在进程执行时，该可执行文件的 <strong>Permitted 集合</strong>中的 <strong>capabilites</strong> 自动被加入到进程的 <strong>Permitted 集合</strong>中。进程可以通过系统调用 <code>capset()</code> 来从 <code>Effective</code> 或 <code>Inheritable</code> 集合中添加或删除 capability，前提是添加或删除的 capability 必须包含在 <code>Permitted</code> 集合中。</p>
<h5 id="Effective"><a href="#Effective" class="headerlink" title="Effective"></a>Effective</h5><p>内核检查线程是否可以进行特权操作时，检查的对象便是 <code>Effective</code> 集合。如之前所说，<code>Permitted</code> 集合定义了上限，线程可以删除 Effective 集合中的某 capability，随后在需要时，再从 Permitted 集合中恢复该 capability，以此达到临时禁用 capability 的功能。</p>
<p>比如我可能一个程序可能中间需要用户来操作，但是呢，我不希望它有过高的权限，那么我在交给用户操作的时候，我把一些权限较高的<code>capability</code> 禁用了，如果用户通过漏洞获取持久权限那将也不能够获取较高的权限。</p>
<h5 id="Inheritable"><a href="#Inheritable" class="headerlink" title="Inheritable"></a>Inheritable</h5><p>当执行<code>exec()</code> 系统调用时，能够被新的可执行文件继承的 capabilities，被包含在 <code>Inheritable</code> 集合中。这里需要说明一下，包含在该集合中的 capabilities 并不会自动继承给新的可执行文件，即不会添加到子进程的 <code>Effective</code> 集合或 <code>Inheritable</code>，它只会影响新线程的 <code>Permitted</code> 集合。</p>
<h5 id="Bounding"><a href="#Bounding" class="headerlink" title="Bounding"></a>Bounding</h5><p><code>Bounding</code> 集合，它定义了能被继承的权限的上限，是 <code>Inheritable</code> 集合的超集，如果某个 capability 不在 <code>Bounding</code> 集合中，即使它在 <code>Permitted</code> 集合中，该线程也不能将该 capability 添加到它的 <code>Inheritable</code> 集合中。</p>
<p><code>Bounding</code> 集合的 <code>capabilities</code> 在执行 <code>fork()</code> 系统调用时会传递给子进程的 Bounding 集合，并且在执行 <code>execve</code> 系统调用后保持不变。</p>
<ul>
<li>当线程运行时，不能向 <code>Bounding</code> 集合中添加 <code>capabilities</code>。</li>
<li>一旦某个 <code>capability</code> 被从 <code>Bounding</code> 集合中删除，便不能再添加回来。</li>
<li>将某个 <code>capability</code> 从 <code>Bounding</code> 集合中删除后，如果之前 <code>Inherited</code> 集合包含该 <code>capability</code>，将继续保留。但如果后续从 <code>Inheritable</code> 集合中删除了该 <code>capability</code>，便不能再添加回来。</li>
</ul>
<h5 id="Ambient"><a href="#Ambient" class="headerlink" title="Ambient"></a>Ambient</h5><p>Linux <code>4.3</code> 内核新增了一个 capabilities 集合叫 <code>Ambient</code> ，用来弥补 <code>Inheritable</code> 的不足。<code>Ambient</code> 具有如下特性：</p>
<ul>
<li><code>Permitted</code> 和 <code>Inheritable</code> 未设置的 <code>capabilities</code>，<code>Ambient</code> 也不能设置。</li>
<li>当 <code>Permitted</code> 和 <code>Inheritable</code> 关闭某权限后，<code>Ambient</code> 也随之关闭对应权限。这样就确保了降低权限后子进程也会降低权限。</li>
<li>非特权用户如果在 <code>Permitted</code> 集合中有一个 <code>capability</code>，那么可以添加到 <code>Ambient</code> 集合中，这样它的子进程便可以在 <code>Ambient</code>、<code>Permitted</code> 和 <code>Effective</code> 集合中获取这个 <code>capability</code>。</li>
</ul>
<h4 id="文件的capability"><a href="#文件的capability" class="headerlink" title="文件的capability"></a>文件的capability</h4><p>文件的 <code>capabilities</code> 被保存在文件的扩展属性中。如果想修改这些属性，需要具有 <code>CAP_SETFCAP</code> 的 <code>capability</code>。文件与进程的 <code>capabilities</code> 共同决定了通过 <code>execve()</code> 运行该文件后的线程的 <code>capabilities</code>。</p>
<p>文件的 <code>capabilities</code> 功能，需要文件系统的支持。如果文件系统使用了 <code>nouuid</code> 选项进行挂载，那么文件的 <code>capabilities</code> 将会被忽略。</p>
<p>类似于进程的 <code>capabilities</code>，文件的 <code>capabilities</code> 包含了 3 个集合：</p>
<ul>
<li>Permitted</li>
<li>Inheritable</li>
<li>Effective</li>
</ul>
<p>这3个集合的具体含义如下：</p>
<h5 id="Permitted-1"><a href="#Permitted-1" class="headerlink" title="Permitted"></a>Permitted</h5><p>这个集合中包含的 <code>capabilities</code>，在文件被执行时，会与进程的 <code>Bounding</code> 集合计算交集，然后添加到该进程的 <code>Permitted</code> 集合中。</p>
<h5 id="Inheritable-1"><a href="#Inheritable-1" class="headerlink" title="Inheritable"></a>Inheritable</h5><p>这个集合与线程的 <code>Inheritable</code> 集合的交集，会被添加到执行完 <code>execve()</code> 后的线程的 <code>Permitted</code> 集合中。</p>
<h5 id="Effective-1"><a href="#Effective-1" class="headerlink" title="Effective"></a>Effective</h5><p>这不是一个集合，仅仅是一个标志位。如果设置开启，那么在执行完 <code>execve()</code> 后，线程 <code>Permitted</code> 集合中的 <code>capabilities</code> 会自动添加到它的 <code>Effective</code> 集合中。对于一些旧的可执行文件，由于其不会调用 <code>capabilities</code> 相关函数设置自身的 <code>Effective</code> 集合，所以可以将可执行文件的 <code>Effective bit</code> 开启，从而可以将 <code>Permitted</code> 集合中的 <code>capabilities</code> 自动添加到 <code>Effective</code> 集合中。</p>
<h4 id="常见的capability"><a href="#常见的capability" class="headerlink" title="常见的capability"></a>常见的capability</h4><p>共40个</p>
<table>
<thead>
<tr>
<th>capability 名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CAP_AUDIT_CONTROL</td>
<td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td>
</tr>
<tr>
<td>CAP_AUDIT_READ</td>
<td>允许通过 multicast netlink 套接字读取审计日志</td>
</tr>
<tr>
<td>CAP_AUDIT_WRITE</td>
<td>将记录写入内核审计日志</td>
</tr>
<tr>
<td>CAP_BLOCK_SUSPEND</td>
<td>使用可以阻止系统挂起的特性</td>
</tr>
<tr>
<td>CAP_CHOWN</td>
<td>修改文件所有者的权限</td>
</tr>
<tr>
<td>CAP_DAC_OVERRIDE</td>
<td>忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_DAC_READ_SEARCH</td>
<td>忽略文件读及目录搜索的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_FOWNER</td>
<td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td>
</tr>
<tr>
<td>CAP_FSETID</td>
<td>允许设置文件的 setuid 位</td>
</tr>
<tr>
<td>CAP_IPC_LOCK</td>
<td>允许锁定共享内存片段</td>
</tr>
<tr>
<td>CAP_IPC_OWNER</td>
<td>忽略 IPC 所有权检查</td>
</tr>
<tr>
<td>CAP_KILL</td>
<td>允许对不属于自己的进程发送信号</td>
</tr>
<tr>
<td>CAP_LEASE</td>
<td>允许修改文件锁的 FL_LEASE 标志</td>
</tr>
<tr>
<td>CAP_LINUX_IMMUTABLE</td>
<td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td>
</tr>
<tr>
<td>CAP_MAC_ADMIN</td>
<td>允许 MAC 配置或状态更改</td>
</tr>
<tr>
<td>CAP_MAC_OVERRIDE</td>
<td>忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_MKNOD</td>
<td>允许使用 mknod() 系统调用</td>
</tr>
<tr>
<td>CAP_NET_ADMIN</td>
<td>允许执行网络管理任务</td>
</tr>
<tr>
<td>CAP_NET_BIND_SERVICE</td>
<td>允许绑定到小于 1024 的端口</td>
</tr>
<tr>
<td>CAP_NET_BROADCAST</td>
<td>允许网络广播和多播访问</td>
</tr>
<tr>
<td>CAP_NET_RAW</td>
<td>允许使用原始套接字</td>
</tr>
<tr>
<td>CAP_SETGID</td>
<td>允许改变进程的 GID</td>
</tr>
<tr>
<td>CAP_SETFCAP</td>
<td>允许为文件设置任意的 capabilities</td>
</tr>
<tr>
<td>CAP_SETPCAP</td>
<td>参考 capabilities man page</td>
</tr>
<tr>
<td>CAP_SETUID</td>
<td>允许改变进程的 UID</td>
</tr>
<tr>
<td>CAP_SYS_ADMIN</td>
<td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td>
</tr>
<tr>
<td>CAP_SYS_BOOT</td>
<td>允许重新启动系统</td>
</tr>
<tr>
<td>CAP_SYS_CHROOT</td>
<td>允许使用 chroot() 系统调用</td>
</tr>
<tr>
<td>CAP_SYS_MODULE</td>
<td>允许插入和删除内核模块</td>
</tr>
<tr>
<td>CAP_SYS_NICE</td>
<td>允许提升优先级及设置其他进程的优先级</td>
</tr>
<tr>
<td>CAP_SYS_PACCT</td>
<td>允许执行进程的 BSD 式审计</td>
</tr>
<tr>
<td>CAP_SYS_PTRACE</td>
<td>允许跟踪任何进程</td>
</tr>
<tr>
<td>CAP_SYS_RAWIO</td>
<td>允许直接访问 &#x2F;devport、&#x2F;dev&#x2F;mem、&#x2F;dev&#x2F;kmem 及原始块设备</td>
</tr>
<tr>
<td>CAP_SYS_RESOURCE</td>
<td>忽略资源限制</td>
</tr>
<tr>
<td>CAP_SYS_TIME</td>
<td>允许改变系统时钟</td>
</tr>
<tr>
<td>CAP_SYS_TTY_CONFIG</td>
<td>允许配置 TTY 设备</td>
</tr>
<tr>
<td>CAP_SYSLOG</td>
<td>允许使用 syslog() 系统调用</td>
</tr>
<tr>
<td>CAP_WAKE_ALARM</td>
<td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)</td>
</tr>
</tbody></table>
<p>比如我们熟知的 <code>ping</code> 命令，它所用到的底层是使用 <code>socket</code> 实现的，而 <code>socket</code> 是 <code>root</code> 用户才有权限使用的。在 <code>Ubuntu 18.04LTS</code>  的发行版当中，我们看看它是怎么解决这个权限问题的。</p>
<img src="/2022/08/31/CVE-2021-3493/5.png" class="">

<p>它设置了 <code>s</code> 权限位，意味着我运行 <code>ping</code> 的时候， <code>ping</code> 这个 <code>process</code> <code>uid</code> 为 <code>0</code>，也就是 <code>root</code> 用户。</p>
<p>若我取消设置它的 <code>s </code>权限位，它将不再具有 <code>ping</code> 的功能。</p>
<img src="/2022/08/31/CVE-2021-3493/6.png" class="">

<p>原因就如上所示，底层的 <code>socket</code> 并不允许普通用户运行。</p>
<img src="/2022/08/31/CVE-2021-3493/7.png" class="">

<p>而当我把自己权限提升之后又能够使用 <code>ping</code> 命令了，是因为 <code>root</code> 用户执行读写和某些底层操作时不检查权限。</p>
<p>在这里我们只需要使用 <code>setcap</code> 命令将 <code>ping</code> 加上 <code>socket</code> 权限就可以让我们运行的时候获得 <code>socket</code> 权限，正常使用 <code>ping</code> 命令，这么做的好处就是假如我的 <code>ping</code> 命令有漏洞存在，那么当别人借着 <code>ping</code> 命令来提权我的计算机时会发现它获得的 <code>shell</code> 只拥有 <code>socket</code> 这么一个特权操作，其它的操作与普通用户并没有区别，这样极大地降低了安全风险，而如果我使用 <code>s</code> 权限位，那么别人通过这个获取漏洞之后将能直接获得 <code>root</code> 权限能操作计算机的一切资源。</p>
<img src="/2022/08/31/CVE-2021-3493/8.png" class="">

<p>在添加完权限之后，我们发现又可以使用 <code>ping</code> 命令了，这是因为我们通过 <code>setcap</code> 让 <code>/bin/ping</code> 重新拥有了 <code>socket</code> 权限。</p>
<p>在这个地方我们对 <code>capability</code> 也不再深入下去了。</p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>引用一下 <code>wiki</code> 对 <code>namespace</code> 的定义</p>
<blockquote>
<p>Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same namespace for a set of resources and processes, but those namespaces refer to distinct resources.</p>
</blockquote>
<p>直观翻译就是</p>
<blockquote>
<p>namespace 是 Linux 内核的一项特性，它可以对内核资源进行分区，使得一组进程可以看到一组资源；而另一组进程可以看到另一组不同的资源。该功能的原理是为一组资源和进程使用相同的 namespace，但是这些 namespace 实际上引用的是不同的资源。</p>
</blockquote>
<p>简单来说 <code>namespace</code> 是由 <code>Linux</code> 内核提供的，用于进程间资源隔离的一种技术。将全局的系统资源包装在一个抽象里，让进程（看起来）拥有独立的全局资源实例。同时 <code>Linux</code> 也默认提供了多种 <code>namespace</code>，用于对多种不同资源进行隔离。</p>
<p><code>Linux</code> 从 <code>2.4</code> 版本加入了 <code>namespace</code> 机制到 <code>3.8</code> 版本实现了 <code>User namespace</code>。</p>
<p><code>Cgroup namespace</code> 是进程的 <code>cgroups</code> 的虚拟化视图，通过 <code>/proc/[pid]/cgroup</code> 和 <code>/proc/[pid]/mountinfo</code> 展示。</p>
<table>
<thead>
<tr>
<th>namespace名称</th>
<th>系统调用参数</th>
<th>控制内容</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>主机名和域名</td>
<td>2.6.19</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>信号量，消息队列，共享内存</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>Process IDs进程号</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>网络设备，协议栈，端口等等</td>
<td>2.6.29</td>
</tr>
<tr>
<td>Cgroup</td>
<td>CLONE_NEWCGROUP</td>
<td>Cgroup root directory cgroup 根目录</td>
<td>2.6.29</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>Mount points挂载点</td>
<td>2.4.19</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>用户和组 ID</td>
<td>3.8</td>
</tr>
</tbody></table>
<p>有了namespace之后，PID,IPC,Network等系统资源不再是全局性的，而是属于特定的Namespace。每个Namespace里面的资源对其他Namespace都是透明的。<strong>要创建新的Namespace，只需要在调用clone时指定相应的flag。</strong></p>
<p>以上为自己搜集的资料整理，以下为自己个人解读。</p>
<p>电脑开机的时候，系统会创建7个 <code>init</code> 的 <code>namespace</code>，一个进程只能切必须属于七个特定不同的 <code>namespace</code>，那么这个就是我们默认的 <code>namespace</code>。使用 <code>ls -l /proc/$$/ns</code> 可以查看本进程的 <code>namespace</code> 在这里 <code>$$</code> 变量表示自己的进程号。</p>
<p>在这之前我一直有一个疑问，就是为什么我普通用户 <code>-map-root-user</code> 会导致我没有 <code>root</code> 的操作权限而 <code>root</code> 用户创建的 <code>namespace</code> 即使是普通用户也有操作权限。比如如下两个例子。</p>
<p><code>unshare</code> 命令用于取消子进程的共享 <code>namespace</code>，通过<code>--user --map-root-user</code> 选项可以新建一个 <code>user  namespace</code> 并使新建进程的用户为 <code>root</code> 用户。</p>
<img src="/2022/08/31/CVE-2021-3493/9.png" class="">

<p>此时出现了 <code>root</code> 用户无法操作 <code>/etc/shadow</code> 的场面，但是我们无论是 <code>id</code> 还是 <code>whoami</code> 看上去都跟真的 <code>root</code> 一样，确没有操作权限，确实也是比较奇怪的。但是，又合情合理，因为我普通用户我不通过 <code>su</code> 或者是 <code>sudo</code> 命令去正常提权那都是利用漏洞。</p>
<p>然后再来看另一个例子</p>
<img src="/2022/08/31/CVE-2021-3493/10.png" class="">

<p>虽然看起来我是普通用户，但是实际上我有 <code>root</code>的权限。</p>
<p>因此我在这里一直不理解 <code>namespace</code> 的组织形式，直到我看到一篇博客上面画着树状图，我才猛然顿悟。</p>
<p><code>namespace</code> 是树状图的一种形式，然后文件系统中在标记属主的时候会标记一个 <code>namespace</code> 字段，标识由哪一个 <code>namespace</code> 的用户创建的，然后再检查权限的时候若当前用户不属于当前 <code>namespace</code> 那么就会向上寻找，直到找到对应的 <code>namespace</code>，然后检查是谁创建的。然后对应的权限就是那个 <code>namespace</code> 的创建者的。如果是这样的话，那么就能解释通了，我之前疑惑的点不在于为什么我没有操作权限而是它怎么判断的我没有操作权限，因为没有操作权限属于正常现象，如果我的想法不对也请师傅们指正，这只是一个我认为比较合理能解释得通的解释。</p>
<h2 id="漏洞利用步骤"><a href="#漏洞利用步骤" class="headerlink" title="漏洞利用步骤"></a>漏洞利用步骤</h2><p>我们先创建好 <code>overlayfs</code> 的那几个文件夹，准备挂载，然后在其中的 <code>upper</code> 目录中写上我们的 <code>exp</code> 并编译好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    execve(<span class="string">&quot;/bin/bash&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exp</code> 非常简单，就是 <code>setuid</code> 和 <code>setgid</code> 为 <code>0</code>，也就是 <code>root</code>。</p>
<p>然后我们再创建一个 <code>user namepsace</code> 和 <code>mount namespace</code> 。</p>
<p>在 <code>./merge</code> 当中，我们为刚刚编译的 <code>exp</code> 设置 <code>setuid</code> 的权限。</p>
<p>然后再开一个终端，我们发现 <code>upper</code> 目录中的 <code>exp</code> 同样具有了 <code>setuid</code> 的权限，说明我们的权限逃逸成功了。</p>
<img src="/2022/08/31/CVE-2021-3493/11.png" class="">

<p>我们运行 <code>exp</code> 成功获得了真实的 <code>root</code> 权限。</p>
<img src="/2022/08/31/CVE-2021-3493/12.png" class="">

<h2 id="内核代码分析"><a href="#内核代码分析" class="headerlink" title="内核代码分析"></a>内核代码分析</h2><h3 id="namespace结构"><a href="#namespace结构" class="headerlink" title="namespace结构"></a>namespace结构</h3><p>首先我第一步呢，就是去求证了一下我上面的猜想是否正确，在 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/64222515138e43da1fcf288f0289ef1020427b87/include/linux/user_namespace.h">github</a> 上找到对应的 <code>namespace</code> 的代码，这里不用管什么版本了，大体变化是不会很大的，我们先来看 <code>user_namespace</code> 结构体的定义：</p>
<img src="/2022/08/31/CVE-2021-3493/13.png" class="">

<p>我们很清楚地能看到里面的一个定义：<code>user_namespace *parent</code>，这里也能说明，它是存在父子关系的，和我们之前的猜测大体是一样的，并且会标注 <code>owner</code> 和 <code>group</code>，这里应该是创建这个 <code>namespace</code> 的属主和属组。我们同时也看到还有一个 <code>level</code> 变量，这里我大概猜测一下，是 <code>namespace</code> 的深度，也就是往后迭代了多少次，这个学过算法设计应该还是好理解的，我在建立树的时候，我们一般也会标记深度方便去查找，我猜测在这里我们需要的就是进行权限检查，如果 <code>namespace</code> 双方为父子关系，那么我们直接看父亲的权限即可，然而实际情况比较复杂，首先谁是父亲谁是儿子就很难判断，所以我跟上深度能很容易知道谁是父亲谁是儿子，如果不是父子关系，那么我们可以查 <code>LCA</code> 找到最近公共祖先，看看两个 <code>namespace</code> 的创建者权限如何。</p>
<p>我们找到对应的 <code>user_namespace.c</code> 文件，看看创建一个 <code>namespace</code> 的时候发生了什么。这里推荐给大家读内核代码的一些思路：大部分的代码都会写一个完全不带安全检查的函数，比如我创建一个 <code>namespace</code>，那么我们一定能找到只实现创建 <code>namespace</code> 的一个函数，这个函数通常会在进行了一系列安全检查之后才允许被调用，包括我们平时做一些网站开发之类的也一样，我们会写一个定向只做某些事情的接口，但是接口不会直接被调用而是会进行一系列安全检查，诸如非法数据判断和权限问题，我们默认传进去的参数都是合法的，它常规的三部曲就是：检查，执行，善后。那么言归正传，看到代码</p>
<h5 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h5><img src="/2022/08/31/CVE-2021-3493/14.png" class="">

<p>参数应该是一个父进程，因为它在第一行写了 <code>parent_ns=new-&gt;user_ns</code>，<code>parent_ns</code> 我们很容易知道是父 <code>namespace</code>，而这里传进去的是一个 <code>cred</code> 结构体，结构体中有一个 <code>user_ns</code> 应该是 <code>user_namespace</code>。下面两行设置了 <code>euid</code> 和 <code>egid</code>，那么很清晰了，<code>owner</code> 和 <code>group</code> 就是创建这个 <code>namespace</code> 的属主和属组。</p>
<p>下面有一个如果父进程的 <code>user namepsace</code> 层数超过 <code>32</code> 那么直接 <code>goto fail</code>，那就是说这里不允许这棵树创建超过32的深度。</p>
<p>后面执行一个 <code>inc_user_namespaces</code> 函数并判断是否执行成功，我们往下深挖一下代码，这里因为代码比较短，就贴这里了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ucounts *<span class="title function_">inc_ucount</span><span class="params">(<span class="keyword">struct</span> user_namespace *ns, <span class="type">kuid_t</span> uid,</span></span><br><span class="line"><span class="params">               <span class="keyword">enum</span> ucount_type type)</span><span class="comment">//in kernel/ucount.c</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>, *<span class="title">iter</span>, *<span class="title">bad</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">tns</span>;</span></span><br><span class="line">    ucounts = alloc_ucounts(ns, uid);</span><br><span class="line">    <span class="keyword">for</span> (iter = ucounts; iter; iter = tns-&gt;ucounts) &#123;</span><br><span class="line">        <span class="type">long</span> max;</span><br><span class="line">        tns = iter-&gt;ns;</span><br><span class="line">        max = READ_ONCE(tns-&gt;ucount_max[type]);</span><br><span class="line">        <span class="keyword">if</span> (!atomic_long_inc_below(&amp;iter-&gt;ucount[type], max))</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ucounts;</span><br><span class="line">fail:</span><br><span class="line">    bad = iter;</span><br><span class="line">    <span class="keyword">for</span> (iter = ucounts; iter != bad; iter = iter-&gt;ns-&gt;ucounts)</span><br><span class="line">        atomic_long_dec(&amp;iter-&gt;ucount[type]);</span><br><span class="line"></span><br><span class="line">    put_ucounts(ucounts);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ucounts *<span class="title function_">inc_user_namespaces</span><span class="params">(<span class="keyword">struct</span> user_namespace *ns, <span class="type">kuid_t</span> uid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出来，这里应该只是分配一个 <code>ucounts</code> 结构体的内存，我猜测 <code>ucounts</code> 应该是 <code>namespace</code> 的衍生类，因为我们看到 <code>inc_user_namespace</code> 增加 <code>user namespace</code> 实际就是调用增加 <code>ucounts</code> 的一个方法，并且估计其它的 <code>namespace</code> 也需要通过这个调用来分配内存，并且我们观察枚举类也能发现有我们所有 <code>namespace</code> 的一个定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ucount_type</span> &#123;</span></span><br><span class="line">    UCOUNT_USER_NAMESPACES,</span><br><span class="line">    UCOUNT_PID_NAMESPACES,</span><br><span class="line">    UCOUNT_UTS_NAMESPACES,</span><br><span class="line">    UCOUNT_IPC_NAMESPACES,</span><br><span class="line">    UCOUNT_NET_NAMESPACES,</span><br><span class="line">    UCOUNT_MNT_NAMESPACES,</span><br><span class="line">    UCOUNT_CGROUP_NAMESPACES,</span><br><span class="line">    UCOUNT_TIME_NAMESPACES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_INOTIFY_USER</span></span><br><span class="line">    UCOUNT_INOTIFY_INSTANCES,</span><br><span class="line">    UCOUNT_INOTIFY_WATCHES,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FANOTIFY</span></span><br><span class="line">    UCOUNT_FANOTIFY_GROUPS,</span><br><span class="line">    UCOUNT_FANOTIFY_MARKS,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    UCOUNT_RLIMIT_NPROC,</span><br><span class="line">    UCOUNT_RLIMIT_MSGQUEUE,</span><br><span class="line">    UCOUNT_RLIMIT_SIGPENDING,</span><br><span class="line">    UCOUNT_RLIMIT_MEMLOCK,</span><br><span class="line">    UCOUNT_COUNTS,</span><br><span class="line">&#125;;<span class="comment">//in user_namespace.h</span></span><br></pre></td></tr></table></figure>

<p>但是去看了 <code>ucounts</code> 结构体的定义发现里面就定义了一个 <code>user_namespace</code> 的指针和一个链表，队列，以及标识了一个 <code>uid</code>。这个 <code>ucounts</code> 可能只是一个用于做某些标记的东西，我们暂且不管把先。</p>
<p>后面有一个 <code>current_chrooted</code> 函数，我们同样看看它的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">current_chrooted</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Does the current process have a non-standard root */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">ns_root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">fs_root</span>;</span></span><br><span class="line">    <span class="type">bool</span> chrooted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find the namespace root */</span></span><br><span class="line">    ns_root.mnt = &amp;current-&gt;nsproxy-&gt;mnt_ns-&gt;root-&gt;mnt;</span><br><span class="line">    ns_root.dentry = ns_root.mnt-&gt;mnt_root;</span><br><span class="line">    path_get(&amp;ns_root);</span><br><span class="line">    <span class="keyword">while</span> (d_mountpoint(ns_root.dentry) &amp;&amp; follow_down_one(&amp;ns_root))</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    get_fs_root(current-&gt;fs, &amp;fs_root);</span><br><span class="line"></span><br><span class="line">    chrooted = !path_equal(&amp;fs_root, &amp;ns_root);</span><br><span class="line"></span><br><span class="line">    path_put(&amp;fs_root);</span><br><span class="line">    path_put(&amp;ns_root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chrooted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释以及关键的语句 <code>chrooted = !path_equal(&amp;fs_root, &amp;ns_root);</code> 我们大概也能猜测出来，它应该就是判断 <code>namespace</code> 的根目录是否于文件系统一致，一致才允许你创建这个 <code>namespace</code>。</p>
<h5 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h5><img src="/2022/08/31/CVE-2021-3493/15.png" class="">

<p>然后在这里需要判断一下属主和数组是否映映射到了父 <code>namespace</code> 上。</p>
<p>后面的话基本上和我们复现的漏洞无关了，我们这么来了解了一下构成形式，<code>namespace</code> 确实是树状图形式，而且下面我们很清楚地能看到 <code>ns-&gt;level=parent_ns-&gt;level+1</code>。</p>
<h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><p>这里我们来查看对应版本的代码，<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.14.291/source/fs/xattr.c">链接贴上</a>。</p>
<p>先来看到 <code>416</code> 行，对 <code>setxattr</code> 函数进行分析，这里解释一下 <code>setxattr</code> 的一个名字由来（自己意淫的，非官方说法，经供参考），<code>set</code> 就是设置， <code>x</code> 其实它可以代表 <code>extended</code> 扩展的，<code>attr</code> 就是属性了，连起来就是<strong>设置扩展属性</strong>，这里的扩展属性就是指 <code>capability</code>。其实我感觉吧， <code>x</code> 好像能表示一切 <code>ex</code> 开头的单词，比如我们经常见到的三个权限位，用 <code>x</code> 标识 <code>execute</code>。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Extended attribute SET operations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">void</span> *kvalue = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> kname[XATTR_NAME_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    error = strncpy_from_user(kname, name, <span class="keyword">sizeof</span>(kname));</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="number">0</span> || error == <span class="keyword">sizeof</span>(kname))</span><br><span class="line">        error = -ERANGE;</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; XATTR_SIZE_MAX)</span><br><span class="line">            <span class="keyword">return</span> -E2BIG;</span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line">            error = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_ACCESS) == <span class="number">0</span>) ||</span><br><span class="line">            (<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == <span class="number">0</span>))</span><br><span class="line">            posix_acl_fix_xattr_from_user(kvalue, size);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(kname, XATTR_NAME_CAPS) == <span class="number">0</span>) &#123;</span><br><span class="line">            error = cap_convert_nscap(d, &amp;kvalue, size);</span><br><span class="line">            <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            size = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = vfs_setxattr(d, kname, kvalue, size, flags);</span><br><span class="line">out:</span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看逻辑有点小复杂，主要是很多的宏定义和很多没见过的函数，也不太能够望文生义，于是我找到了Linux手册对于 <code>setxattr</code> 的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$man 2 setxattr</span><br></pre></td></tr></table></figure>

<blockquote>
<p>setxattr()  sets the value of the extended attribute identified by name and associated with the given path in the filesystem.  The  size  argument  specifies  the  size  (in bytes) of value; a zero-length value is permitted.</p>
</blockquote>
<p>貌似介绍的也比较笼统，还是靠自己试试吧。</p>
<h4 id="part1-1"><a href="#part1-1" class="headerlink" title="part1"></a>part1</h4><p><code>flags &amp; ~(XATTR_CREATE|XATTR_REPLACE)</code>，这其实是很常见的掩码写法，差不多意思就是 <code>flag</code> 标志只在 <code>create</code> 和 <code>replace</code> 位上设置，如果设置了其它位则退出。</p>
<p><code>strncpy_from_user(kname, name, sizeof(kname))</code> 对传入的 <code>name</code> 参数进行拷贝，拷贝到了 <code>kname</code> 也就是内核栈当中。第一个判断应该是判断空字符串和防止溢出，因为如果 <code>sizeof(kname)</code> 字节都被占满了那么这个字符串还会跟下面连续的字符串相连，造成一些错误。</p>
<p>这里出现了我的知识盲区，这里也来解释一下，在内核里面，看见全大写字母的变量基本都不是变量，都是宏定义。而我实在不知道字符串常量有直接拼接的做法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s1 <span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s2 <span class="string">&quot;456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s3 s1 s2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(s3);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*output: </span></span><br><span class="line"><span class="comment">123456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我还以为是宏定义的特殊写法呢，这里mark一下。</p>
<p>这里给出这些宏定义的最终结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XATTR_NAME_POSIX_ACL_ACCESS <span class="string">&quot;system.posix_acl_access&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XATTR_NAME_POSIX_ACL_DEFAULT <span class="string">&quot;system.posix_acl_default&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XATTR_NAME_CAPS <span class="string">&quot;security.capability&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>那么第一个 <code>if</code> 我们 <code>duck</code> 不必关心，我们主要关心第二个跟 <code>capability</code> 相关的分支。</p>
<p>我们具体逻辑也不进一步分析了，我们就看看这个函数给的注释：</p>
<p><code>This function will then take care to map the inode according to @mnt_userns before checking permissions.</code></p>
<p>我们也不难看出来，在检查权限之前就是会对文件系统和 <code>user namespace </code> 进行映射，这个函数叫 <code>cap_convert_nscap</code>，那其实就是对 <code>capability</code> 的 <code>userns</code> 进行一个映射了（应该是这个意思。</p>
<p>就是可能，它会在不同的 <code>namespace</code> 上嘛，比如这个文件夹是其中一个 <code>user namespace</code> 创建的，不可能我换一个 <code>namespace</code> 去检测权限也是相同的手法，肯定是要把权限映射一下的，映射到同一个 <code>namespace</code> 上才能进行权限检查。</p>
<p>经过一系列检查之后，走到了 <code>vfs_setxattr</code>，也就是虚拟文件系统的扩展属性设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfs_setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">void</span> *value,</span></span><br><span class="line"><span class="params">        <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = xattr_permission(inode, name, MAY_WRITE);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    inode_lock(inode);</span><br><span class="line">    error = security_inode_setxattr(dentry, name, value, size, flags);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = __vfs_setxattr_noperm(dentry, name, value, size, flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    inode_unlock(inode);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一条不深入挖下去了，就是判断有没有写的权限，然后上锁，防止发生竞争，然后进行 <code>security_inode_setxattr</code> 函数进行进一步的权限校验，最后执行 <code>__vfs_setxattr_noperm</code> 函数，它的后缀 <code>noperm</code> 就是还没有进行权限检查的 <code>__vfs_setxattr</code> 与我们之前说的分析思路是一致的。在这个函数里面有一个大 <code>if</code> 判断文件是否有权限，最终调用一个 <code>__vfs_setxattr</code> 去真实设置 <code>xattr</code>。</p>
<p>因此我们可以发现，在调用设置文件扩展属性时候，会有一系列的检查，比如你是否是 <code>root</code>，你对文件操作是否有权限之类的，因为即使你是 <code>root</code> 也得看看那个文件系统的权限是否归你所有，有可能是其它 <code>user_namespace</code> 的用户创建的，那么你有可能也是没有权限的，这个地方是不会出现越权行为的。</p>
<p>然后我们看到 <code>overlayfs</code> 的设置文件扩展属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ovl_xattr_set</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode *inode, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">upperdentry</span> =</span> ovl_i_dentry_upper(inode);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">realdentry</span> =</span> upperdentry ?: ovl_dentry_lower(dentry);</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    err = ovl_want_write(dentry);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!value &amp;&amp; !upperdentry) &#123;</span><br><span class="line">        err = vfs_getxattr(realdentry, name, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out_drop_write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!upperdentry) &#123;</span><br><span class="line">        err = ovl_copy_up(dentry);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out_drop_write;</span><br><span class="line"></span><br><span class="line">        realdentry = ovl_dentry_upper(dentry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    old_cred = ovl_override_creds(dentry-&gt;d_sb);</span><br><span class="line">    <span class="keyword">if</span> (value)</span><br><span class="line">        err = vfs_setxattr(realdentry, name, value, size, flags);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        WARN_ON(flags != XATTR_REPLACE);</span><br><span class="line">        err = vfs_removexattr(realdentry, name);</span><br><span class="line">    &#125;</span><br><span class="line">    revert_creds(old_cred);</span><br><span class="line"></span><br><span class="line">out_drop_write:</span><br><span class="line">    ovl_drop_write(dentry);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;<span class="comment">///fs/overlayfs/inode.c</span></span><br></pre></td></tr></table></figure>

<p>其它的我们不看，我们解释比较容易理解的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!upperdentry) &#123;</span><br><span class="line">    err = ovl_copy_up(dentry);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> out_drop_write;</span><br><span class="line"></span><br><span class="line">    realdentry = ovl_dentry_upper(dentry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个地方其实就是我们说的，如果文件在 <code>lower</code> 当中，那么拷贝一份到 <code>upper</code> 当中去，然后把新的文件节点指向 <code>upper</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">    err = vfs_setxattr(realdentry, name, value, size, flags);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    WARN_ON(flags != XATTR_REPLACE);</span><br><span class="line">    err = vfs_removexattr(realdentry, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后直接调用 <code>vfs_setxattr</code> 函数了，我们知道在 <code>vfs_setxattr</code> 之前有一个入口，也就是 <code>setxattr</code> 这个地方会有一个调用，调用 <code>cap_convert_nscap</code> 函数去检查  <code>user namespace</code> 是否一致。而这里直接调用 <code>vfs_setxattr</code> 这个函数就绕过了 <code>namespace</code> 的检查。</p>
<p>所以我们之前的利用步骤就是先创建了一个 <code>namespace</code>，然后挂载了一个 <code>overlayfs</code>，在 <code>merge</code> 文件夹中是我们创建的 <code>fs namespace</code>，因此我们创建的 <code>root</code> 用户对这个 <code>fs namespace</code> 有设置 <code>capability</code> 的操作权限，这个其实没有问题，因为我即使运行了这个 <code>a.out</code> 也不会有真正的 <code>root</code> 权限，有的只是我们创建的这个 <code>user namespace</code> 的 <code>root</code> 权限，而这个权限实际是 <code>init</code> 的 <code>user</code> 创建的，因此实际操作还是获得不了真实的 <code>root</code>，但是问题就是 <code>overlayfs</code> 的这个特性：我们修改了 <code>merge</code> 中的 <code>a.out</code> 会反向修改之前在 <code>upper</code> 中的 <code>a.out</code>，因此我们给它 <code>setuid</code> 的权限导致了 <code>upper/a.out</code> 也有 <code>setuid</code> 的权限，而 <code>upper/a.out</code> 是在实际的 <code>init user namespace</code> 创建的，因此它有了 <code>init user namespace</code> 的 <code>setuid</code> 权限。我们运行 <code>upper/a.out</code> 直接获取真实 <code>root</code> 权限。</p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>这个其实我个人认为应该是 <code>overlayfs</code> 的问题，在修改的时候应该检查 <code>user namespace</code> 才对，但是它修改了 <code>xattr.c</code> 中的 <code>vfs_setxattr</code> 函数，这个函数重新用了一个 <code>cap_convert_nscap</code> 函数检查 <code>namespace</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v5.19.6/source/fs/xattr.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfs_setxattr</span><span class="params">(<span class="keyword">struct</span> user_namespace *mnt_userns, <span class="keyword">struct</span> dentry *dentry,</span></span><br><span class="line"><span class="params">         <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">delegated_inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>  *orig_value = value;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &amp;&amp; <span class="built_in">strcmp</span>(name, XATTR_NAME_CAPS) == <span class="number">0</span>) &#123;</span><br><span class="line">        error = cap_convert_nscap(mnt_userns, dentry, &amp;value, size);<span class="comment">//这里是新增的namespace检查</span></span><br><span class="line">        <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        size = error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry_deleg:</span><br><span class="line">    inode_lock(inode);</span><br><span class="line">    error = __vfs_setxattr_locked(mnt_userns, dentry, name, value, size,</span><br><span class="line">                      flags, &amp;delegated_inode);</span><br><span class="line">    inode_unlock(inode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delegated_inode) &#123;</span><br><span class="line">        error = break_deleg_wait(&amp;delegated_inode);</span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            <span class="keyword">goto</span> retry_deleg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != orig_value)</span><br><span class="line">        kfree(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这样也能完成漏洞的修复，不过我认为在其它文件系统中这里检查了两次就比较没有必要，也是比较困惑的点吧，也可能防止其它文件系统调用这个函数也没有检查，大概是这样的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xia0ji233.github.io">xia0ji233</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xia0ji233.github.io/2022/08/31/CVE-2021-3493/">https://xia0ji233.github.io/2022/08/31/CVE-2021-3493/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xia0ji233.github.io" target="_blank">xia0ji233's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/14/KanxueBook/" title="《加密与解密》的学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《加密与解密》的学习</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" title="icpc数学基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">icpc数学基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><a href="/"> <div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></a><div class="author-info__name">xia0ji233</div><div class="author-info__description">Nepnep team</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">283</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">169</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xia0ji233"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xia0ji233" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xia0ji233@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">老当益壮，宁移白首之心？穷且益坚，不坠青云之志。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E8%8A%9D%E5%A3%AB"><span class="toc-number">2.</span> <span class="toc-text">前置芝士</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#overlayfs"><span class="toc-number">2.1.</span> <span class="toc-text">overlayfs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#overlayfs%E6%8C%82%E8%BD%BD"><span class="toc-number">2.1.1.</span> <span class="toc-text">overlayfs挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8overlayfs"><span class="toc-number">2.1.2.</span> <span class="toc-text">docker如何使用overlayfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#demo"><span class="toc-number">2.1.3.</span> <span class="toc-text">demo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#capability"><span class="toc-number">2.2.</span> <span class="toc-text">capability</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uid-ruid"><span class="toc-number">2.2.1.</span> <span class="toc-text">uid(ruid)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#euid"><span class="toc-number">2.2.2.</span> <span class="toc-text">euid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#suid"><span class="toc-number">2.2.3.</span> <span class="toc-text">suid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">2.2.4.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#capability%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.5.</span> <span class="toc-text">capability是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84capability"><span class="toc-number">2.2.6.</span> <span class="toc-text">进程的capability</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Permitted"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">Permitted</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Effective"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">Effective</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Inheritable"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">Inheritable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bounding"><span class="toc-number">2.2.6.4.</span> <span class="toc-text">Bounding</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Ambient"><span class="toc-number">2.2.6.5.</span> <span class="toc-text">Ambient</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84capability"><span class="toc-number">2.2.7.</span> <span class="toc-text">文件的capability</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Permitted-1"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">Permitted</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Inheritable-1"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">Inheritable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Effective-1"><span class="toc-number">2.2.7.3.</span> <span class="toc-text">Effective</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84capability"><span class="toc-number">2.2.8.</span> <span class="toc-text">常见的capability</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#namespace"><span class="toc-number">2.3.</span> <span class="toc-text">namespace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">内核代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#namespace%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">namespace结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#part1"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">part1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#part2"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">part2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.2.</span> <span class="toc-text">权限设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#part1-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">part1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="toc-number">5.</span> <span class="toc-text">修复方案</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/31/Summary2024/" title="2024年终总结">2024年终总结</a><time datetime="2024-12-31T11:00:00.000Z" title="发表于 2024-12-31 19:00:00">2024-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/qwb2024_final_reverse/" title="强网杯S8决赛Reverse writeup">强网杯S8决赛Reverse writeup</a><time datetime="2024-12-11T05:00:00.000Z" title="发表于 2024-12-11 13:00:00">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/08/qwb2024_final/" title="强网杯S8决赛pwn writeup">强网杯S8决赛pwn writeup</a><time datetime="2024-12-07T17:00:00.000Z" title="发表于 2024-12-08 01:00:00">2024-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/24/WindowsDriver1/" title="windows驱动开发（1）——Windows驱动字符串">windows驱动开发（1）——Windows驱动字符串</a><time datetime="2024-11-24T15:00:00.000Z" title="发表于 2024-11-24 23:00:00">2024-11-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/23/WindowsDriver0/" title="windows驱动开发（0）——Windows驱动开发的基础知识">windows驱动开发（0）——Windows驱动开发的基础知识</a><time datetime="2024-11-22T19:00:00.000Z" title="发表于 2024-11-23 03:00:00">2024-11-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By xia0ji233</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>