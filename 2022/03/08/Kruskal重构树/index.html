<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kruskal 重构树的学习笔记 | xia0ji233's blog</title><meta name="author" content="xia0ji233"><meta name="copyright" content="xia0ji233"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="比赛遇到了新鲜的图论题，特此记录。">
<meta property="og:type" content="article">
<meta property="og:title" content="Kruskal 重构树的学习笔记">
<meta property="og:url" content="https://xia0ji233.github.io/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/index.html">
<meta property="og:site_name" content="xia0ji233&#39;s blog">
<meta property="og:description" content="比赛遇到了新鲜的图论题，特此记录。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xia0ji233.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-03-08T03:00:00.000Z">
<meta property="article:modified_time" content="2025-01-19T18:36:33.938Z">
<meta property="article:author" content="xia0ji233">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xia0ji233.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xia0ji233.github.io/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kruskal 重构树的学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-20 02:36:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="xia0ji233's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">283</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">119</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/backgroud.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="xia0ji233's blog"><span class="site-name">xia0ji233's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kruskal 重构树的学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-08T03:00:00.000Z" title="发表于 2022-03-08 11:00:00">2022-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-19T18:36:33.938Z" title="更新于 2025-01-20 02:36:33">2025-01-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ICPC/">ICPC</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ICPC/%E5%9B%BE%E8%AE%BA/">图论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kruskal 重构树的学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>比赛遇到了新鲜的图论题，特此记录。</p>
<span id="more"></span>

<h2 id="什么是Kruskal重构树？"><a href="#什么是Kruskal重构树？" class="headerlink" title="什么是Kruskal重构树？"></a>什么是Kruskal重构树？</h2><p> $\text{Kruskal}$ 重构树，和 $\text{Kruskal}$ 算法的思想差不多，就是在这个过程中建出一个有着非常优秀的性质的数据结构，这是一个非常少见和小众的算法，但是如果碰到了合适的题目，就会体现出其优越性。</p>
<h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>既然它叫 $\text{Kruskal}$ 重构树，那么它必然与 $\text{Kruskal}$ 有着密不可分的联系。首先我们回顾一下 $\text{Kruskal}$ 最小生成树是怎么实现的，先将所有边按照权值排序，然后再从小到大添加边，如果添加边的两个顶点都在生成树当中则跳过这条边，直到添加过n-1次算法结束。</p>
<p>我们在添加边的时候构造一棵这样的树：当边e被添加时，e的两顶点一定在不同的生成树内，因此将两个顶点所在的树用一个点连接起来，点的权值为这条边的权值，这个点的权值表示了什么呢？就是这两个子树上，其中一个子树所有的顶点到另一个子树的所有顶点中经过的边的最大值的最小值为这条边的边权。</p>
<p>首先先解释一下什么叫<strong>最大值的最小值</strong>，这句话可能有点抽象，那我具体举一个例子。我一个节点从 $u\to v$ 有可能经过多条边，这里面的最大值是我要计算的，而可能不止这一种走法，我现在希望这个最大值最小，这就是所谓的最大值的最小值啦。最大值指的是一条路径的最大值，最小值指的是所有路径中的这个值最小。</p>
<p>其次，很容易证明我们得到的树是一颗二叉树，因为对于n个点，每次我都是添加根节点连接两个子树或者节点，也很容易证明叶节点都为原图中的节点，因为我们只为这些节点不停地添加父亲而没有给他们儿子，自然就是叶子节点啦。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>exp(指example</p>
<p>举个例子，下面这个图。</p>
<img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/1.png" class="">

<p>第一步，我们先选择1和2，发现不在同一集合，选择添加，我们新建一个节点来作为它们的父亲，它的点的权值为1，这里我换个颜色避免引起歧义，这里的1表示值而不是编号。</p>
<img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/2.png" class="">

<p>重复第一步，找到2，然后。</p>
<img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/3.png" class="">

<p>然后找到权值为3的点，发现1，3同属于一个树，跳过。再找到4，添加，得到下面这张图。</p>
<img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/4.png" class="">

<p>我们来看看符不符合我们上面总结的那个结论。</p>
<p>1和2我们走过的最短路径显然就是1；1到3我们需要走过路径最大值的最小值是2，虽然我能一步到达，但是先走2，再走3我们的路径长度为 $\to 1\to 2 \to$ 显然这样走过的最长的路的最小值就是2了，可以发现1和3由根节点权值为2的点连接，也没问题，同理其它任何四个点两两之间都符合这个规律。</p>
<p>在实现上面我们可以通过LCA来快速查询两个点之间的最大路径的最小值，因为也可以发现两个点之间的LCA的权值就是我想要的答案，这一部分可以倍增预处理然后打到一次 $log_2n$ 的复杂度。</p>
<h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><p>这应该是我们最应该关心的问题了，学了一个数据结构应该想办法加以利用。来看一道经典例题：</p>
<hr>
<p>给出n个点，m条边构成的无向图，要求指定两点，算出它们之间的最短路径值。</p>
<p>这题很容易知道可以使用单源最短路算法，但是我们也会想到动态规划。因为我到了一个点之后，我不需要关心这个点是怎么到的，这个叫无后效性，即前面的决策不影响后面的答案。</p>
<p>那我们对此题稍微改一下：要求求出所有我经过路径最大值的最小值是多少？</p>
<p>这题显然，也是无后效性我们只需要一步步往前推然后保存最大值即可。但是问题来了，如果我再加上多个询问呢？那么此时算法的时间复杂度将加上n倍，一次处理相当于进行一次的 $\text{dijkstra}$，$O(nlog_2n)$的复杂度，妥妥的超时。如果我们选择 $\text{Kruskal}$ 重构树预处理，再加上加上LCA，把一次询问的复杂度降低到 $O(log_2n)$ ，那么最终得到的算法复杂度就会低很多了。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>直接拿上ICPC2021上海站的I题——<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/29789/H">Life is a game</a></p>
<hr>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Life is a game.</p>
<p> The world can be regarded as an undirected connected graph of $n$ cities and mmm undirected roads between the cities. Now you, the life game player, are going to play the life game on the world graph.</p>
<p> Initially, you are at the $x$-th city and of $k$ social ability points. You can earn social ability points by living and working. Specifically, you can earn $a_i$ social ability points by living and working in the $i$-th city. But in this problem, you cannot earn social ability points duplicatedly in one city, so you want to travel the world and earn more social ability points. However, the roads are not easy. Specifically, there is an ability threshold $i$_iwi​ for the $i$-th road, you should be of at least $w_i$ social ability points to go through the road. Moreover, Your social ability point will not decrease when passing roads but just need to be at least $w_i$​ if you want to go through the $i$-th road.</p>
<p> So as you can see, the life game is just living, working and traveling repeatedly. There are $q$ game saves. For each game save, the initial city and social ability point is given and the player has not lived or worked in any city. Now you, the real life game player, need to determine the maximum possible number of social ability points you can have in the end of the game and output it for each given game save.</p>
<p>这里来解释一下这个题意。</p>
<p>就是说有一个 $n$ 点 $m$ 边的无向带权图，每个点上有权值。当你经过一个点，你能获得一定能力值，每个地方的能力值只能获得一次，只有能力值不小于边权我才能通过这条边到达另一个点。给定起点和初始能力值，问你最后最多有多少能力值。</p>
<p>所以，我们能不能到达另一个点取决于整条路经的最大值是否大于我的能力值，若大于则我不能通过这条路到达该点，如果该最大值最小，则以我目前能力值无法到达该点。</p>
<p>我们就使用 $\text{Kruskal}$ 构造树，寻找它的祖先节点，可以证明，它祖先节点一定不是叶节点，所以如果我的能力值大于该祖先节点的值，那么我可以任意访问以这个祖先节点为根节点的任意节点，能力值可以直接加上这么多，然后再去寻找祖先节点，直到连它的父亲都无法到达或者是当前节点已经是根节点了，那就结束，那么我最终获得的能力值就是当前节点为根节点的子树的所有能力值之和加上初始值。</p>
<p>以某某节点为根节点的子树能力值之和可以通过 dfs 在 $O(E)$ 的复杂度得出，排序+ $\text{Kruskal}$ 构造树 $O(E)+O(Elog_2E)$ 的复杂度。寻找根节点可以用预处理倍增查询的方式去得到。这样最终我们每次查询的复杂度就是 $O(log_2n)$ 的复杂度。在本题我们可以认为它都是 $n$ ，因为它们的最大值都是一样的，这样的复杂度最终能被接受。</p>
<p>这里给出我写的程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">//int不够直接int改long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eee</span>&#123;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cin&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> eee &amp;a)&#123;<span class="comment">//重载小于号便于排序</span></span><br><span class="line">        <span class="keyword">return</span> w&lt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> v[maxn&lt;&lt;<span class="number">1</span>],root[maxn&lt;&lt;<span class="number">1</span>],fa[maxn&lt;&lt;<span class="number">1</span>],value[maxn&lt;&lt;<span class="number">1</span>],a[maxn&lt;&lt;<span class="number">1</span>],dep[maxn&lt;&lt;<span class="number">1</span>],n,m,q,cnt;</span><br><span class="line"><span class="type">int</span> lca[maxn&lt;&lt;<span class="number">1</span>][<span class="number">30</span>];<span class="comment">//这里忘开两倍内存导致2小时的TLE RE WA各种的问题。</span></span><br><span class="line"><span class="comment">//v表示节点权值，value表示子树a和，a表示该点的能量 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ee</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++)fa[i]=i;<span class="comment">//初始化集合</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> from=e[i].from,to=e[i].to;</span><br><span class="line">        from=<span class="built_in">find</span>(from),to=<span class="built_in">find</span>(to);<span class="comment">//寻找并查集</span></span><br><span class="line">        <span class="keyword">if</span>(from==to)<span class="keyword">continue</span>;</span><br><span class="line">        v[++j+n]=e[i].w;<span class="comment">//新建一个点，点权为该边边权，并连接这两个点</span></span><br><span class="line">        <span class="built_in">add</span>(from,j+n);<span class="comment">//添加两个边。</span></span><br><span class="line">        <span class="built_in">add</span>(j+n,from);</span><br><span class="line">        <span class="built_in">add</span>(to,j+n);</span><br><span class="line">        <span class="built_in">add</span>(j+n,to);</span><br><span class="line">        fa[from]=fa[j+n];<span class="comment">//让这两个点的父亲都指向这个节点，这其实相当于一个集合的合并。</span></span><br><span class="line">        fa[to]=fa[j+n];</span><br><span class="line">        <span class="keyword">if</span>(j==n<span class="number">-1</span>)<span class="keyword">break</span>;<span class="comment">//寻找到n-1条边之后则直接退出</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=a[now];</span><br><span class="line">    fa[now]=father;</span><br><span class="line">    lca[now][<span class="number">0</span>]=father;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line">        lca[now][i]=lca[lca[now][i<span class="number">-1</span>]][i<span class="number">-1</span>]<span class="comment">//直接整，暴力出log_2(1e5)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=root[now];i;i=edge[i].next)&#123;<span class="comment">//朴实无华的深搜</span></span><br><span class="line">        <span class="type">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==father)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">    value[now]=ans;<span class="comment">//保存该节点为根节点时的所有子孙节点上的能力值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        e[i].<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上为输入</span></span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m);<span class="comment">//边按照权值排序</span></span><br><span class="line">    <span class="built_in">Kruskal</span>();<span class="comment">//重构树</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">2</span>*n<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">//深搜填value，获得以每个节点为根节点能获得的能力值，顺便处理一下LCA</span></span><br><span class="line">    v[<span class="number">0</span>]=<span class="number">1e18</span>;<span class="comment">//防止到0之后无法终止递归</span></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;k;</span><br><span class="line">        <span class="type">int</span> t=x;</span><br><span class="line">        <span class="type">int</span> now=value[x]+k;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> las = x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> fa = lca[x][i];</span><br><span class="line">                <span class="keyword">if</span>(now &gt;= v[fa]) x = fa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x == las)<span class="keyword">break</span>;</span><br><span class="line">            now = value[x] + k;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//完结撒花</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序注释提到了，咱因为数组越界查了两个小时的错误，硬生生没看到LCA没有开两倍的内存。</p>
<img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/5.png" class="">

<p>又一图论算法收入囊中，挺开心的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xia0ji233.github.io">xia0ji233</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xia0ji233.github.io/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/">https://xia0ji233.github.io/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xia0ji233.github.io" target="_blank">xia0ji233's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/19/CF1626C/" title="CF1626C"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CF1626C</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/05/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AC%94%E8%AE%B0/" title="最小费用最大流笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">最小费用最大流笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><a href="/"> <div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></a><div class="author-info__name">xia0ji233</div><div class="author-info__description">Nepnep team</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">283</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">119</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xia0ji233"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xia0ji233" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xia0ji233@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">老当益壮，宁移白首之心？穷且益坚，不坠青云之志。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFKruskal%E9%87%8D%E6%9E%84%E6%A0%91%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是Kruskal重构树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exp"><span class="toc-number">2.1.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.0.1.</span> <span class="toc-text">题目描述</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/31/Summary2024/" title="2024年终总结">2024年终总结</a><time datetime="2024-12-31T11:00:00.000Z" title="发表于 2024-12-31 19:00:00">2024-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/qwb2024_final_reverse/" title="强网杯S8决赛Reverse writeup">强网杯S8决赛Reverse writeup</a><time datetime="2024-12-11T05:00:00.000Z" title="发表于 2024-12-11 13:00:00">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/08/qwb2024_final/" title="强网杯S8决赛pwn writeup">强网杯S8决赛pwn writeup</a><time datetime="2024-12-07T17:00:00.000Z" title="发表于 2024-12-08 01:00:00">2024-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/24/WindowsDriver1/" title="windows驱动开发（1）——Windows驱动字符串">windows驱动开发（1）——Windows驱动字符串</a><time datetime="2024-11-24T15:00:00.000Z" title="发表于 2024-11-24 23:00:00">2024-11-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/23/WindowsDriver0/" title="windows驱动开发（0）——Windows驱动开发的基础知识">windows驱动开发（0）——Windows驱动开发的基础知识</a><time datetime="2024-11-22T19:00:00.000Z" title="发表于 2024-11-23 03:00:00">2024-11-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By xia0ji233</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>