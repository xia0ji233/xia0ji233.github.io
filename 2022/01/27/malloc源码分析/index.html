<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>malloc源码分析 | xia0ji233's blog</title><meta name="author" content="xia0ji233"><meta name="copyright" content="xia0ji233"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学了这么久堆漏洞了，我想应该把&#96;glibc&#96;的&#96;malloc&#96;和&#96;free&#96;源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="malloc源码分析">
<meta property="og:url" content="https://xia0ji233.github.io/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="xia0ji233&#39;s blog">
<meta property="og:description" content="学了这么久堆漏洞了，我想应该把&#96;glibc&#96;的&#96;malloc&#96;和&#96;free&#96;源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xia0ji233.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-01-26T18:00:00.000Z">
<meta property="article:modified_time" content="2025-01-20T06:07:02.659Z">
<meta property="article:author" content="xia0ji233">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xia0ji233.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xia0ji233.github.io/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'malloc源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-20 14:07:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="xia0ji233's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">307</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">87</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/backgroud.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="xia0ji233's blog"><span class="site-name">xia0ji233's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">malloc源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-26T18:00:00.000Z" title="发表于 2022-01-27 02:00:00">2022-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-20T06:07:02.659Z" title="更新于 2025-01-20 14:07:02">2025-01-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/Pwn/">Pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="malloc源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>学了这么久堆漏洞了，我想应该把<code>glibc</code>的<code>malloc</code>和<code>free</code>源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。</p>
<span id="more"></span>

<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>我们平时写程序的时候，某些变量可能需要在开始就分配内存，这些内存是不可避免的。那么这些内存就是静态分配的，当程序编译完成之后，它就确定了占用这么多的内存。但是有时候，实际问题的规模没有预期那么大，我们不一定需要很大的内存，如果每次都按最大考虑那么就有很大一部分内存是被浪费的，这就是静态分配内存的弊端，虽然咱打acm的时候都是静态分配的，但是这没啥，因为每个问题不要超过它的总内存上限问题就不大(狗头。但是在内存不足的年代，如果都这样使用静态分配内存的方式，那么计算机的效率会被拖垮很多，所以就有动态分配内存的概念了。</p>
<p><code>glibc</code>采用<code>ptmalloc</code>的管理方式去分配内存。</p>
<h2 id="ptmalloc2的分配策略"><a href="#ptmalloc2的分配策略" class="headerlink" title="ptmalloc2的分配策略"></a>ptmalloc2的分配策略</h2><p>那么动态分配内存要怎么去分配呢？如果我们需要占用除了我程序本身占用的内存以外的一块内存，那程序指定是没权限用的，得先向操作系统申请这一块内存的使用权。而操作系统没那么闲，分配几个字节的内存都要它去管，操作系统管理都是按页式的管理。而一页的内存是<code>0x1000B</code>，如果每一次申请我都向操作系统申请，每一次归还都直接归还给操作系统那么必定会增大操作系统的负担。因此分配内存的时候可以按照一个策略去分配，分配一定得尽量避免过多地使用系统调用，归还的时候可以等到程序结束时一并归还，这样的话操作系统的负担就大大下降了。</p>
<p><code>ptmalloc2</code>的分配方式会在你第一次<code>malloc</code>的时候向操作系统申请<code>0x21000B(132KB)</code>的内存，然后后续分配就不会向操作系统申请内存，只有用完了的时候才会再次申请内存。</p>
<p>操作系统的问题解决了之后我们再来看看<code>glibc</code>怎么处理具体的分配细节。分配的时候我一定是切出一块特定大小才是最优的策略的，比如程序<code>malloc(4)</code>，那我接切个4字节的内存给它用，<code>malloc(1)</code>那就给它一字节去使用。然而现实没有那么理想，因为如果我切下来的块用户程序完全可写的话，那么我怎么区分这个内存块是否被使用呢？然后内存块的分界线又如何界定呢？所以分割内存块的时候不可避免地要在内存块中额外开出一部分区域用于管理。那么可以在每个分配的内存块加上一个<code>int</code>数据作为此内存块的<code>size</code>，64位的操作系统可以使用<code>long long</code>。同理，为了管理方便，<code>glibc</code>在分配<code>chunk</code>的时候也并不是分配这么多就只能写这么多的。它也不想闲到去管1字节2字节这样的内存块。而且如果有这样的内存块，那么在分配指针的时候内存没办法对齐会出现很多麻烦的事。所以在分配内存块的时候，有一个<code>SIZE_SZ</code>，一次分配的内存必定是<code>SIZE_SZ*2</code>的整倍数，<code>SIZE_SZ</code>在32位操作系统下的值是<code>4</code>，64位的值是<code>8</code>。为了方便，以下把内存块统一叫<code>chunk</code>。</p>
<p>以32位操作系统为例，size的值必定为8的整数倍，二进制角度下看来，低三位永远是0，这样有点浪费了内存，因此规定<code>size</code>的低三位不作为实际的<code>chunk</code>大小，而是标志位。三个标志位从高位到低位分别是：</p>
<ol>
<li><code>NON_MAIN_ARENA</code>:是否为主分配，0表示是主分配，权值为4</li>
<li><code>IS_MMAPPED</code>:表示内存是否为<code>mmap</code>获得，0表示不是，权值为2</li>
<li><code>PREV_INUSE</code>:表示前面一个内存块是否被使用，0表示不被使用，权值为1</li>
</ol>
<p>在64位操作系统中，多出一个标志位，但是这个标志位无任何意义，可能后续会赋予别的意义，但是它一样不影响<code>chunk</code>的大小。</p>
<p>在看malloc源码的时候可以看到一个宏定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure>

<p>那么就可以看到<code>chunksize</code>在取实际<code>size</code>的时候与了一个<code>0xfffffff8</code>，忽略了最低三位，64位操作系统则会忽略最低四位。</p>
<p>以下例子为64位操作系统</p>
<p><code>chunk</code>最小的大小为<code>0x20</code>，为什么没有<code>0x10</code>大小的<code>chunk</code>呢，这么看来<code>size</code>占了<code>8</code>字节还能有8字节给用户去写似乎没问题。大不了我超过<code>8B</code>再分配<code>0x20</code>大小的内存嘛，这个疑问先放一下，我们来看看这样的策略它还有没有什么问题。</p>
<p>如果一个<code>chunk</code>被确定释放了，那么该以什么方式去管理。你会想到前面有一个<code>prev_inuse</code>位可以确定一个堆块是否被释放，你会想到改下一个<code>chunk</code>的标志位就可以了，但是如果这个内存块再次被需要呢，难道去遍历每一个<code>chunk</code>，一来要看<code>size</code>符不符合，二来还要看它有没有被使用，这样时间开销太大了。因为空闲的<code>chunk</code>可能散落在内存各个角落，管理零碎内存最好的办法就是链表。链表还得有表头，这个表头其实就是我们的<code>main_arena</code>中的<code>bin</code>。因此<code>chunk</code>上还得有一块内存是指针，指针又占了<code>8</code>个字节。</p>
<p>但是你可能想到，指针它只在块被释放的时候有用啊，<code>0x10</code>的块，一个<code>size</code>，一个指针，被分配的时候用指针作为数据域，被释放的时候指针用于链式管理。这样就解决了，这样也的确没问题。但是看看它这样的分配策略还有没有问题？如果我多次分配<code>chunk</code>很小的块，<code>free</code>之后它们便只能用于分配这么大的内存了。如果不加另一种策略组织起来，导致内存碎片越来越多，就容易耗尽系统内存。</p>
<p>那么就有<code>ptmalloc</code>的又一个策略：尽量合并物理相邻的<code>free_chunk</code>。咱们前面一直提到切割内存块，合并内存块就是切割的一个逆过程。在合并的时候我可能前面会有<code>free</code>的内存块，后面也会有<code>free</code>的内存块。那么我怎么在只知道我自身信息的情况下准确找到前后的<code>chunk</code>具体在哪呢。</p>
<p>想找到后面的很容易，我知道我自己所在的位置（指针），也知道我的<code>size</code>，那么相加就可以找到后面的<code>size</code>了。那么我如何找前面的<code>size</code>在什么位置呢？所以就不得不再开辟一个内存来存前一个<code>chunk</code>的信息了。通过<code>prev_inuse</code>位我很容易得知前一个<code>chunk</code>有没有被<code>free</code>，但是我并不知道前一个<code>chunk</code>的大小啊。所以在一个<code>chunk</code>的结构体，在size之前还会有一个<code>prev_size</code>。与前面那个指针同理，我只有在前一个块被<code>free</code>需要合并的时候才会想看看它在哪，他要是都还在用我都没必要去使用这个<code>prev_size</code>字段了。但是要注意，这个<code>prev_size</code>是服务于上一个<code>chunk</code>的。所以一个chunk的结构体就有<code>0x10</code>个不得不分配的字节，而且自己还不能用。因此<code>0x10</code>的<code>chunk</code>就没有意义了。所以源码中也会找到这样的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE 4*SIZE_SZ</span></span><br></pre></td></tr></table></figure>

<p>说了这么多了，<code>ptmalloc</code>的策略大致总结一下就是：</p>
<ol>
<li><p>一次系统调用会分配大块内存</p>
</li>
<li><p>程序结束后统一归还内存给操作系统</p>
</li>
<li><p>方便管理，内存分配尽量对齐，也就是所谓的size为某某整倍数</p>
</li>
<li><p>尽量分配最小能满足的内存块</p>
</li>
<li><p>链式管理空闲空间，适当的时候合并物理相邻的<code>chunk</code></p>
</li>
</ol>
<p>而且根据以上分析我们可以得出一些关于<code>chunk</code>的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> prev_size;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    chunk *fd;</span><br><span class="line">    chunk *bk;<span class="comment">//因为链式管理还有可能是双向链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们大致就明白了<code>ptmalloc</code>的分配方式。</p>
<h2 id="ptmalloc2的具体分配策略"><a href="#ptmalloc2的具体分配策略" class="headerlink" title="ptmalloc2的具体分配策略"></a>ptmalloc2的具体分配策略</h2><p>前面我们讲到了，对于空闲块使用了链式管理方式。但是对于不同大小的<code>chunk</code>，它又有细分。这里先给一个概念：<code>bin</code>，字面意义垃圾桶，用于装<code>free_chunk</code>的垃圾桶，在这里可以理解为链表表头。</p>
<p>以下均以<code>glibc 2.23</code>版本解析</p>
<h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>对于<code>size</code>较小的<code>free_chunk</code>，我们认为它很快就会被再次用到，因此在<code>free</code> <code>0x20~0x80</code>大小的<code>chunk</code>时，我们会把它扔进<code>fast bin</code>里面，字面意义，里面存的<code>free_chunk</code>很快会被再次用到。<code>fast bin</code> 管理<code>free_chunk</code>采用单链表方式，并且符合后进先出（<code>FILO</code>）的原则，比如以下程序段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">y=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"><span class="built_in">free</span>(y);</span><br><span class="line">z=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">w=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure>

<p>那么z会得到y的指针，w会得到x的指针。</p>
<p>并且<code>fast bin</code>的<code>chunk</code>的之后的<code>chunk</code> <code>prev_inuse</code>位永远为1。也就是说它永远被视为在使用中，但是通常这个使用中是用于检测参不参与物理相邻<code>chunk</code>的合并，所以不会参与物理相邻的<code>chunk</code>的合并，也不会被切割。它的匹配规则就是，定量匹配。比如我想要一个<code>0x30</code>的<code>chunk</code>，没有就是没有，没有我就找其它的，不会说<code>0x40</code>好像还挺合适就拿了，不会。</p>
<p><code>fast bin</code>一共有<code>10</code>个，<code>main_arena</code>结构体中，用<code>fastbinsY</code>来存储每一个<code>fast bin</code>的链表头部，32位系统中，<code>fast bin</code>，从0x10开始到<code>0x40</code>，有7种<code>fast bin</code>，64位系统从<code>0x20</code>开始到<code>0x80</code>，也是七种<code>fast bin</code>。单个<code>fast bin</code>链表上的<code>chunk</code>大小一定严格相等。</p>
<p>一定情况下可以修改<code>global_max_fast</code>的值来调整<code>fast bin</code>的个数，64位系统下这个值通常为<code>0x80</code>，代表小于等于<code>0x80</code>的<code>chunk</code>都为<code>fast bin</code>。</p>
<p>其余的链表头部都在<code>bin</code>数组当中。并且由于只有<code>fast bin</code>是单链表结构，其余<code>bin</code>都是双向链表结构，<code>bin</code>会成对出现。</p>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>对于非<code>fast bin</code>大小的<code>chunk</code>，被释放时会首先进入<code>unsorted bin</code>。<code>unsorted bin</code>在特定的时候会进入<code>small bin</code> 和 <code>large bin</code>。</p>
<p>非<code>fast bin</code>的<code>bin</code>都是用一对<code>bin</code>指针来描述的，这两个<code>bins</code>也要看成一个<code>chunk</code>，然后初始它们的<code>fd</code>和<code>bk</code>都指向自身的<code>prev_size</code>那个位置。比如<code>main_arena+104</code>这个地方是<code>bin</code>数组的第一个，然后呢<code>main_arena+104</code>和<code>main_arena+112</code>分别就是<code>unsorted bin</code>的头部，它们本身虽然不是<code>chunk</code>，但是要理解它们的初始状态还是得看成一个<code>chunk</code>。所以<code>main_arena+104</code>和<code>main_arena+112</code>的初始值就是<code>main_arena+88</code>。如图：</p>
<img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" class="">

<p>设置这一个<code>bin</code>的主要目的是扮演一个缓存层的角色以加快分配和释放的操作，链表中<code>chunk</code>大小不一定相等且无序排列。</p>
<p>当需要检查<code>unsorted bin</code>的时候，会遍历整个链表，寻找第一个能满足的<code>chunk</code>大小切割。如果切割后的大小不足<code>2*SIZE_SZ</code>，则不会切割，而是将整个堆块返回给用户使用。</p>
<h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>一共有<code>62</code>个，从最小的<code>chunk</code>开始，公差为<code>SIZE_SZ*2</code>，双链表管理。它的特点也是跟fast bin一样，单条链表<code>chunk</code>大小相等，但是它会参与合并，切割。先进先出（<code>FIFO</code>）的策略。它表示的范围就是<code>4*SIZE_SZ~126*SIZE_SZ</code></p>
<h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><p><code>large bin</code>与<code>small bin</code>不一样，<code>large bin</code>表示的是一个范围。一共有<code>63</code>个(假设下标<code>0~62</code>)，从<code>small bin</code>最小不能表示的<code>chunk</code>开始，大到无穷。</p>
<p>它表示的范围类似一个等差数列。</p>
<table>
<thead>
<tr>
<th>起下标</th>
<th>止下标</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>31</td>
<td>16*SIZE_SZ</td>
</tr>
<tr>
<td>32</td>
<td>47</td>
<td>32*SIZE_SZ</td>
</tr>
<tr>
<td>48</td>
<td>55</td>
<td>64*SIZE_SZ</td>
</tr>
<tr>
<td>56</td>
<td>59</td>
<td>128*SIZE_SZ</td>
</tr>
<tr>
<td>60</td>
<td>61</td>
<td>256*SIZE_SZ</td>
</tr>
<tr>
<td>62</td>
<td>62</td>
<td>∞</td>
</tr>
</tbody></table>
<p>最小的<code>large bin</code>是<code>small bin</code>的最小不能表示的大小。</p>
<p>所以<code>large bin</code>从<code>128*SIZE_SZ</code>开始。那么下标为<code>0</code>的<code>large bin</code>表示的范围就是<code>128*SIZE_SZ~144*SIZE_SZ</code>(左闭右开)，同理下标为1的<code>large bin</code>表示的范围就是<code>144*SIZE_SZ~160*SIZE_SZ</code>，以此类推，等到<code>32</code>的时候就在原来的基础上加<code>32*SIZE_SZ</code>作为右开区间</p>
<p>它会以二维双向链表进行维护，对于<code>bin</code>中所有的<code>chunk</code>，相同大小的<code>chunk</code>用<code>fd</code>和<code>bk</code>指针相连，对于不同大小的<code>chunk</code>，采用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针连接。并且沿着<code>fd_nextsize</code>指针，<code>chunk</code>大小递增。</p>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top_chunk"></a>top_chunk</h3><p>我们之前说过，第一次<code>malloc</code>的时候，操作系统会给我们<code>0x21000B</code>的内存，它是作为一个<code>top_chunk</code>存在的，可以把<code>top_chunk</code>看成<code>heap</code>的边界。<code>top_chunk</code>的地址会被记录在main_arena+88的位置。<code>gdb</code>中通过<code>p/x main_arena</code>的命令也可以查看<code>main_arena</code> 的具体结构。</p>
<h3 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h3><p>首先用户<code>malloc</code>请求一个内存，先将请求的内存大小转换成<code>chunk</code>的大小，通过以下宏定义转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>

<p>大概逻辑就是寻找一个最小能满足的<code>chunksize</code>作为<code>chunk</code>大小。</p>
<p>什么是最小能满足呢，我们看看一个<code>size=0x20</code>的<code>chunk</code>能有多少区域给用户写：<code>0x20</code>字节分别为<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，<code>prev_size</code>和<code>size</code>都不允许写，但是我们可以写<code>fd</code>和<code>bk</code>，以及下一个块的<code>prev_size</code>，前面我们也说过，当这个块没有被<code>free</code>的时候，它的<code>fd</code>,<code>bk</code>以及下一个<code>chunk</code>的<code>prevsize</code>位都是可以给用户任意写数据的，所以<code>size=0x20</code>，我们可以写的数据段为<code>0x18</code>。最小能满足就是说，当我请求的内存小于等于<code>0x18</code>的时候，我给你<code>size=0x20</code>的<code>chunk</code>，一旦多了就继续加<code>0x10</code>，也就是<code>2*SIZE_SZ</code>。这里用了其它宏定义去描述它我们尚且不管，如果用一个函数来实现它的话大概就是这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">request2size</span><span class="params">(<span class="type">size_t</span> req)</span>&#123;</span><br><span class="line">    chunk_size=SIZE_SZ*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(chunk_size&lt;req)chunk_size+=<span class="number">2</span>*SIZE_SZ;</span><br><span class="line">    <span class="keyword">return</span> chunk_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在分配的时候我们尽量选择<code>0x18</code>,<code>0x28</code>这样刚刚好的数值，这样更容易发生溢出，哪怕溢出一个字节，也能够加以利用。</p>
<p>那么算出了它的<code>chunk_size</code>之后呢，我们先会判断这个<code>chunk_size</code>是否<code>&lt;=global_max_fast</code>，也就是是否在<code>fast bin</code>范围内。如果在则优先寻找能匹配的<code>fast bin</code>，如果该<code>size</code>的<code>fast bin</code>为空则会寻找<code>small bin</code>，<code>small bin</code>会寻找特定<code>size</code>的<code>chunk</code>返回。如果<code>small bin</code>也为空，或者找不到能满足的那就会去<code>large bin</code>中寻找，同样是最小能满足，找到之后返回或者切割之后返回。还找不到就会去<code>unsorted bin</code>，<code>unsorted bin</code>则会找第一个能满足的<code>chunk</code>并返回或者切割之后返回，<code>unsorted bin</code> 中每遍历一个不满足要求的<code>unsorted bin</code>就会把该<code>unsorted bin</code>加到合适的small bin或者<code>large bin</code>当中。如果切割之后剩余的部分&lt;<code>MINSIZE</code>，那么则不会切割整个返回。</p>
<p>如果还是找不到，那么就会切割<code>top_chunk</code>。如果<code>top_chunk</code>都不能满足请求的大小，则会<code>free</code> <code>top_chunk</code>并再一次向操作系统申请新的<code>top_chunk</code>，这次申请同样还是申请一个<code>0x21000B</code>的<code>top_chunk</code>，通常情况下旧的<code>top_chunk</code>和新申请的<code>top_chunk</code>物理相邻，那么如果<code>free</code> 旧的<code>top_chunk</code>进入了一个非<code>fast bin</code>的链当中，就会被新的<code>top_chunk</code>合并。</p>
<p>如果一次申请的内存超过<code>0x200000B</code>，那么就不会在heap段上分配内存，将会使用<code>mmap</code>在<code>libc</code>的<code>data</code>段分配内存。通常利用就是每次分配给分配地址，分配<code>size</code>没限制那就<code>malloc</code>一个很大的内存就可以直接泄露<code>libc</code>的地址。</p>
<p>分配方式到此就讲完了。</p>
<h2 id="malloc源码分析"><a href="#malloc源码分析" class="headerlink" title="malloc源码分析"></a>malloc源码分析</h2><p>接下来我们直接解读一下<code>malloc</code>的源码。</p>
<h3 id="libc-malloc源码分析"><a href="#libc-malloc源码分析" class="headerlink" title="__libc_malloc源码分析"></a>__libc_malloc源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc实际上会直接调用这里的<code>__libc_malloc</code>函数，然后<code>__libc_malloc</code>也只不过是一层包装而已，实际上大部分的逻辑都是调用<code>_int_malloc</code>函数完成的，那么先来分析外面。</p>
<p>第一段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>定义了一个<code>hook</code>函数指针，如果<code>hook!=NULL</code>则直接调用<code>hook</code>指向的内容。<code>hook</code>是为了方便开发者调试的一个东西，比如我自己写了一个<code>malloc</code>函数想测试它的性能如何，那么我在这里直接让<code>__malloc_hook=my_malloc</code>就可以直接调用我自己写的malloc函数了。但是同时它也是最容易被劫持的，刚开始我们很多题目都是靠写<code>__malloc_hook</code>为一个<code>onegadget</code>，然后调用<code>malloc</code>去<code>getshell</code>的。在<code>2.34</code>版本中，<code>__malloc_hook</code>同其它大部分的<code>hook</code>都被删除了。</p>
<p>第二段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arena_get (ar_ptr, bytes);</span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure>

<p>通过<code>arena_get</code>获得一个分配区，<code>arena_get</code>是个宏定义，定义在<code>arena.c</code>中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      arena_lookup (ptr);                           \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);                         \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><code>arena_lookup</code>定义如下，也是获取分配器指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lookup(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">      void *vptr = NULL;                              \</span></span><br><span class="line"><span class="meta">      ptr = (mstate) tsd_getspecific (arena_key, vptr);             \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>然后加锁，没了，获取分配器指针这一段不是我们主要要分析的，也就不过多去解析了。</p>
<p>第三段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure>

<p>它本身注释也写清楚了，在能够找到一个可用的<code>arena</code>之前尝试寻找另外一个<code>arena</code>，我这英文比较飘还请亲见谅。如果<code>arena</code>找到了但是<code>_int_malloc</code>居然返回0了，那么就重新寻找另一个分配器再次调用一次<code>_int_malloc</code>。完了之后呢，要给<code>arena</code>解锁，然后返回得到的<code>chunk</code>指针。</p>
<h3 id="int-malloc源码分析"><a href="#int-malloc源码分析" class="headerlink" title="_int_malloc源码分析"></a>_int_malloc源码分析</h3><p>由于比较长，为了摆脱水长度的嫌疑就不给看总代码了，需要的自己找<code>glibc</code>的源码就好了，下面我一段一段分析。</p>
<h3 id="第一段：main-arena初始化"><a href="#第一段：main-arena初始化" class="headerlink" title="第一段：main_arena初始化"></a>第一段：main_arena初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line"><span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;  </span><br><span class="line">checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);<span class="built_in">free</span>的源码分析先咕一会，主要是吧，熬夜写这玩意受不了。。</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量定义就不用看了，源码中也都标注出来了，这里最主要就是把用户请求的<code>bytes</code>转换成最小能满足的<code>chunk size</code>，然后它的变量名应该是<code>nb</code>，这个<code>nb</code>应该是<code>nbytes</code>的缩写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;                          \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);                              \</span></span><br><span class="line"><span class="meta">      return 0;                                      \</span></span><br><span class="line"><span class="meta">    &#125;                                          \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure>

<p>这里原来也给注释了，这俩宏定义就是一样的，只不过做一个参数check。</p>
<p>这里还要注意一下那些宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__glibc_unlikely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为假。</span><br><span class="line">__glibc_likely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为真。</span><br><span class="line">__builtin_expect(<span class="built_in">exp</span>,value)表示<span class="built_in">exp</span>==value大概率成立</span><br></pre></td></tr></table></figure>

<p>这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。</p>
<p>那么这一段的逻辑就是，如果在分配的时候<code>arena</code>为空，那就调用<code>sys_malloc</code>系统调用去请求一个<code>chunk</code>，然后<code>memset</code>这个<code>chunk</code>的数据段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------ Testing support ----------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> perturb_byte;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_perturb</span> <span class="params">(<span class="type">char</span> *p, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下<code>perturb_byte</code>为假，差不多意思就是如果你没有特殊设置，那么<code>data</code>段全为0字节，实际情况也确实是这样的。</p>
<h3 id="第二段：fast-bin的处理"><a href="#第二段：fast-bin的处理" class="headerlink" title="第二段：fast bin的处理"></a>第二段：fast bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//在malloc的时候检查了fastbin的size发现不对</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里嘛就会判断，你申请的这个<code>nb</code>是否<code>&lt;=global_max_fast</code>，如果成立那么就会先在<code>fast bin</code>中寻找能满足的<code>chunk</code>，并且一定是完全匹配。它先找到<code>av-&gt;fastbinY[idx]</code>观察是否为0，如果不为0则说明该<code>size</code>的<code>fast bin</code>有<code>chunk</code>，那么就做以下动作：</p>
<p>取出<code>av-&gt;fastbinY[idx]</code>给<code>victim</code></p>
<p>链表中删除这个<code>victim</code>，然后重新接回去。</p>
<p>中间有一个<code>check</code>，就是判断所给<code>chunk</code>的<code>fastbinY</code>链上的<code>size</code>是否＝我需要的<code>size</code>，如果不相等那么直接报错退出。</p>
<p>末尾也有一个<code>check</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Properties of chunks recycled from fastbins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));</span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))</span><br><span class="line">        assert (av != &amp;main_arena);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);</span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));</span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就是<code>check</code>各个标志位，一般不会被触发，所以可以理解为<code>fast bin</code>在分配的时候只有这一个<code>check</code>，就是那个<code>chunk</code>的<code>size</code>一定是等于我申请的<code>size</code>的，过了就把这个<code>chunk</code>的指针返回，<code>check</code>没过报错，如果根本都没取到<code>fast bin</code>，那么就进行下面的逻辑了。</p>
<h3 id="第三段：small-bin的处理"><a href="#第三段：small-bin的处理" class="headerlink" title="第三段：small bin的处理"></a>第三段：small bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                  \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先判断它在不在<code>small bin</code>的范围内，然后取出这个<code>size</code>的<code>small bin</code>的最后一个<code>chunk</code>。它添加是在头部添加的，因此是符合先进先出的，嗯。然后需要判断，如果最后一个chunk!&#x3D;自身的话，两个情况：要么没初始化<code>arena</code>，那就初始化，要么它有一个合法的块。如果它指向自身那就没必要做过多的判断了，没有这个大小的<code>small bin</code>。</p>
<p>这里是调用了<code>malloc_consolidate</code>函数去初始话这个<code>arena</code>分配器，该函数逻辑如下，不重点解读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span>mlined version of consolidation code in <span class="title function_">free</span><span class="params">()</span> *</span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      check_inuse_chunk(av, p);</span><br><span class="line">      nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">      size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">      nextchunk = chunk_at_offset(p, size);</span><br><span class="line">      nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = p-&gt;prev_size;</span><br><span class="line">        size += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">        unlink(av, p, bck, fwd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">          size += nextsize;</span><br><span class="line">          unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">        unsorted_bin-&gt;fd = p;</span><br><span class="line">        first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">          p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        p-&gt;bk = unsorted_bin;</span><br><span class="line">        p-&gt;fd = first_unsorted;</span><br><span class="line">        set_foot(p, size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致意思就是清空所有<code>arena</code>的<code>chunk</code>，可以看到大的<code>if</code>是判断<code>global_max_fast</code>是否为0，为0则初始化，调用<code>malloc_init_state</code>和<code>check_malloc_state</code>函数初始化堆。否则把所有的<code>fast bin</code> 取出来，先清除它们的标志位，然后扔到<code>unsorted bin</code>中尝试向前合并或者向后合并。</p>
<p>这个呢，不太能运行到，因为<code>victim==0</code>的时候，必还没初始化，没初始化到这里就要初始化，初始化了之后<code>victim</code>又不可能<code>=0</code>了，所以这里可以理解为就是初始化<code>arena</code>的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)                          \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>

<p>这里判断了一下<code>victim-&gt;bk-&gt;fd==victim</code>。也就是当前这个堆块后一个堆块的<code>fd</code>指针是否指向<code>victim</code>，如果不等说明链表被破坏了，那么就报错退出。</p>
<p>然后<code>set_inuse_bit_at_offset</code>，这个也不难理解，因为现在这个<code>small bin</code>被取出来了要使用了，所以我得设置后一个块的<code>prev_inuse</code>为1证明它不是空闲堆块了。然后就是进行<code>unlink</code>操作，对链表熟悉的同学应该看得懂。如果我要删除<code>victim</code>元素那应该怎么写逻辑？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd-&gt;bk=victim-&gt;bk;</span><br><span class="line">victime-&gt;bk-&gt;fd=victim-&gt;fd;</span><br></pre></td></tr></table></figure>

<p>在这里呢，我们取链的最后一个<code>chunk</code>，也就是<code>bin-&gt;bk=victim</code>所以<code>victim-&gt;fd=bin</code></p>
<p>然后前面有一个赋值就是<code>bck=victim-&gt;bk</code>。带进上面的式子就得到了源码里面这样的写法。</p>
<p>然后下面设置<code>main_arena</code>标志位，一波同样的<code>check</code>，然后返回内存指针。也就是这里的<code>chunk2mem</code>，我们这里用的<code>chunk</code>指针，但是其实我们要返回的应该是<code>chunk</code>中数据域的指针，所以这里用了这样的宏定义做替换。</p>
<p>然后就是清除<code>data</code>数据，但是这个一般不会被执行，前面也分析过了，然后返回。这是<code>small bin</code>找到对应的<code>chunk</code>的逻辑，如果<code>small bin</code>还没找到那么接下来应该要去找<code>large bin</code>了，那么我们接着往下读。</p>
<h3 id="第四段：分配largebin时的操作"><a href="#第四段：分配largebin时的操作" class="headerlink" title="第四段：分配largebin时的操作"></a>第四段：分配largebin时的操作</h3><p>那么如果没有在small bin的范围内呢。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步比较耐人寻味。</p>
<p>先获取<code>large bin</code>的<code>index</code>，然后如果<code>fast bin</code>不为空，调用<code>malloc_consolidate</code>。这一步是什么意思呢？我们前面分析过<code>malloc_consolidate</code>，如果没有初始化，那么初始化，如果初始化了，那么合并所有的<code>fast bin</code>。但是这里，都已经有<code>fast bin</code>存在了，那么堆指定已经初始化了，所以这里执行的逻辑基本只能是合并所有<code>fast chunk</code>。为什么要在搜索<code>large bin</code>的时候合并所有<code>fast bin</code>呢？因为<code>large bin</code>的匹配方式是最小能满足，然后切割。</p>
<p>考虑这样一种情况：</p>
<p>如果一个<code>0x20</code>的<code>fast bin</code>和0x500的<code>large bin</code>物理相邻。此时我要申请一个<code>0x510</code>的<code>large bin</code>，如果此时<code>fast bin</code>被合并了，那么我就能找到一个<code>0x520</code>的<code>large bin</code>并把它返回给用户。如果我不做这一步，那么我找不到<code>0x510</code>大小的<code>large bin</code>，我就被迫只能切割<code>top_chunk</code>了，这样子就浪费了很大的一块内存。</p>
<p>那么这个会不会有多此一举的时候呢，也是会的，还是刚刚那种情况，假如我申请<code>0x500</code>的<code>chunk</code>。这样子合并之后又会被切割，那么这样子，之前的合并就显得多次一举了，但是它只是浪费了一部分时间开销，内存分配上还是执行上面的逻辑比较占优势。所以这一步可以理解为空间上的优化，但是牺牲了小部分时间。看不来的话可以多看看上面举得例子。</p>
<h3 id="第五段：large-bin和unsorted-bin的相爱相杀"><a href="#第五段：large-bin和unsorted-bin的相爱相杀" class="headerlink" title="第五段：large bin和unsorted bin的相爱相杀"></a>第五段：large bin和unsorted bin的相爱相杀</h3><p>这里开始逻辑都混合起来了，不仅有<code>large bin</code>，unsorted bin，切割<code>top_chunk</code>，还有系统调用重新分配<code>top_chunk</code>。</p>
<h4 id="第1小块"><a href="#第1小块" class="headerlink" title="第1小块"></a>第1小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           ......</span><br><span class="line">         &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先外面套了一个<code>while(1)</code>，然后里面有一个<code>while</code>循环，判断内容就是取得最后一个<code>unsorted chunk</code>是否与这个<code>bin</code>相等，这里大概就是开始遍历<code>unsorted chunk</code>了。</p>
<p>然后这里又有一个<code>check</code>。<code>victim-&gt;size &lt;= 2 * SIZE_SZ</code>就是说<code>chunk</code>的<code>size</code>小于等于<code>0x10</code>，<code>victim-&gt;size &gt; av-&gt;system_mem</code>就是说我一个块的<code>size</code>居然比我系统调用申请来的内存都多，那这肯定不合理啊，所以任意满足一个就会报错了。</p>
<h4 id="第二小块"><a href="#第二小块" class="headerlink" title="第二小块"></a>第二小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有四个条件：</p>
<ol>
<li><code>in_smallbin_range (nb)</code>：申请<code>small bin</code>范围内的<code>chunk</code></li>
<li><code>bck == unsorted_chunks (av)</code>：<code>bck=victim-&gt;bk=unsorted_chunks(av)-&gt;bk-&gt;bk</code>，也就是说<code>unsorted_chunks (av)-&gt;bk-&gt;bk=unsorted_chunks (av)</code>，翻译一下差不多就是<code>unsorted bin中</code>只有一个<code>chunk</code>。</li>
<li><code>victim == av-&gt;last_remainder</code>：就是说这个chunk刚好是最近被分割过的剩余部分。</li>
<li><code>(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</code>：保证我找到的这个<code>chunksize</code> &gt; 需要的最小块+<code>MINSIZE</code>。为了保证等会我切割出<code>nb size</code>之后剩余的<code>chunk</code>能&gt;<code>MINSIZE</code>，这里我也不知道为什么不能等于，可能解读哪里有误吧，如果您知道请帮我勘误一下，谢谢了。</li>
</ol>
<p>然后接下来就是切割<code>victim</code>，切割出一块刚刚好大小的<code>chunk</code>给用户，切割出来的<code>chunk</code>作为新的<code>av-&gt;last_remainder</code>，注意如果切割剩余的<code>chunk size</code>不符合<code>small bin</code>的大小，则<code>fd_nextsize</code>和<code>bk_nextisze</code>会被清空，因为剩余的的<code>chunk</code>会被放到<code>unsorted bin</code>当中。</p>
<p>然后设置<code>victim</code>的<code>size</code>为<code>nb|PREV_INUSE</code>，然后判断是否为主分配加上标记。</p>
<p>然后把remainder的<code>prev_inuse</code>位设置为1，因为前一个块已经被拿走使用了，所以这个<code>prev_inuse</code>要设置为1。</p>
<p>然后因为<code>remainder</code>的<code>size</code>发生了改表，所以下一个<code>chunk</code>的<code>prev_size</code>也要相应地改变。</p>
<p>剩下的前面类似的都讲过就不赘述了。</p>
<h4 id="第三小块"><a href="#第三小块" class="headerlink" title="第三小块"></a>第三小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>否则会先取出这最后一个<code>chunk</code>，把它移除<code>unsorted bin</code>。如果取出的这个<code>size</code>刚好等于这个<code>nb</code>，那就说明这个块一定是最合适的，直接把它返回了，不要迟疑。如果并不是最合适呢，那么先会判断一下它是否属于<code>small bin</code>，属于则执行以下的逻辑，把<code>bck</code>对应<code>bin</code>的<code>bk</code>，<code>fwd</code>为对应<code>bin</code>的<code>fd</code>，也就是找到那一对<code>bin</code>，<code>fwd</code>在前，<code>bck</code>在后。就没了，预计等会就要用这些指针把<code>chunk</code>链进去了。</p>
<h4 id="第四小块"><a href="#第四小块" class="headerlink" title="第四小块"></a>第四小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是<code>small bin</code>，那就得进<code>large bin</code>了，要进<code>large bin</code>。这里要知道，<code>large bin</code>可是所有<code>bin</code>当中最复杂的<code>bin</code>了，一个<code>chunk</code>四个指针，一对<code>bin</code>管理一个二维双向链表，<code>fd</code>,<code>bk</code>指针与相同大小的<code>chunk</code>连接，<code>fd_nextsize</code>和<code>bk_nextsize</code>与不同大小的<code>chunk</code>连接。</p>
<p>然后呢，虽然<code>fd</code>和<code>bk</code>是连接相同大小的<code>chunk</code>，但是那一对bin还是相当于是<code>fd</code>和<code>bk</code>字段。除了表头以外，其余的不同大小的chunk都是靠<code>fd_nextsize</code>和<code>bk_nextsize</code>的。并且沿着<code>bk_nextsize</code>，<code>chunksize</code>递增。也就是说<code>av-&gt;bin[index]-&gt;bk</code>是第一个<code>chunk</code>，并且<code>size</code> 最小，然后通过<code>bk_nextsize</code>字段一直连接到<code>av-&gt;bin[index]-&gt;fd</code>，反向同理。还有一点需要注意：<code>large bin</code>所在的<code>chunk</code>并不与<code>chunk</code>双向连接。</p>
<p>这里给出一张<code>large bin</code>的结构图，看看能不能帮助理解一下</p>
<img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" class="">

<p>那么这里的<code>bck</code>指的是<code>bin</code>所在的<code>chunk</code>，<code>fwd</code>指的是最大的这个<code>chunk</code>。</p>
<p><code>bck-&gt;bk</code>指的就是图上的n号<code>chunk</code>，也是这个<code>large bin</code>中最小的那个<code>chunk</code>，如果拿出来的<code>unsorted bin</code>它比最小的<code>chunk</code>还要小，那就已经可以确定插入在哪了，就不用做下面的循环再看看它在哪了。然后就是一个链表的插入操作，这里要注意的是，<code>bin</code>所在的<code>chunk</code>只有<code>fd</code>和bk指针，而其它<code>chunk</code>都是<code>fd_nextsize</code>和<code>bk_nextsize</code>连接的。我们只需要先在最大块和最小块之间插入，然后把<code>bin-&gt;bk</code>指向<code>victim</code>即可。</p>
<p>那么我们大概自己写一下操作看看与源码是否一致。首先不考虑bin，只考虑链表的情况下，我们先找到最大块和最小块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fwd=bin-&gt;fd;</span><br><span class="line">bck=bin-&gt;bk;</span><br><span class="line">victim-&gt;bk_nextsize=bck;</span><br><span class="line">victim-&gt;fd_nextsize=fwd;</span><br><span class="line">fwd-&gt;bk_nextsize=bck-&gt;fd_nextsize=victim;</span><br></pre></td></tr></table></figure>

<p>跟上面大致一样，只不过它这里<code>fwd</code>的值是那个<code>large bin</code>的<code>chunk</code>，直接通过<code>fd</code>指针也能直接找到最大的<code>chunk</code>。所以我后面的主要代码应该把<code>fwd</code>改成<code>fwd-&gt;fd</code>就跟上面一模一样了。</p>
<p>如果不是，那就接着往<code>bk_nextsize</code>这个指针上面找，找到大于等于的<code>chunk</code>为止。然后如果等于，就只需要用<code>fd</code>和<code>bk</code>指针与相等大小的<code>chunk</code>相连，如果没有相等，就得在<code>fd_nextsize</code>和<code>bk_nextsize</code>方向上插入，然后<code>fd</code>和<code>bk</code>都默认指向自己。这个我就不演试了，跟前面那个基本是一样的。</p>
<h4 id="第五小块"><a href="#第五小块" class="headerlink" title="第五小块"></a>第五小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line"><span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这个就很简单了，就是一个插入操作，前面既然已经找到了插入的位置，这里一气呵成直接解决了。然后这里还有一个遍历<code>unsorted bin</code>的最大值，一次最多遍历<code>10000</code>个<code>unsorted bin</code>，这个也可以理解，如果我一次产生了很多的<code>unsorted bin</code>，然后我一次<code>malloc</code>，那边一直在循环搞这个<code>unsorted bin</code>，迟迟就没分配内存回来所以这里设定一个最大值。</p>
<p>到了这里，对<code>unsorted bin</code>的遍历就结束了。</p>
<h4 id="第六小块"><a href="#第六小块" class="headerlink" title="第六小块"></a>第六小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">            victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">            victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): cor</span></span><br><span class="line"><span class="string">                    rupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边就看这个最小能满足的<code>nb</code>是否在<code>small bin</code>的范围内。不在则执行，其实如果在的话，那前面有一个<code>small bin</code>的范围判断，如果<code>small bin</code>范围那，<code>idx</code>就是<code>small bin</code>，不在则是<code>large bin</code>的<code>idx</code>。<code>small bin</code>之前已经判断过一遍了，并且判断策略也跟之前不一样，所以这里加一个<code>!in_small_bin_range</code>的判断还是很有必要的。</p>
<p>来看下面的if语句，两个条件。</p>
<ol>
<li><code>(victim = first (bin)) != bin</code>：这个bin里面有<code>chunk</code>，并使<code>victim=bin-&gt;fd</code></li>
<li><code>(unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)</code>：找到目标chunk的size要大于等于这个最小能满足的size  nb。</li>
</ol>
<p>同时满足那么就可能要取这一块chunk来分配了，正如注释所说，如果bin为空或者最大的chunk还是比较小，那就跳过这个逻辑。然后<code>victim = victim-&gt;bk_nextsize</code>，这里<code>victim</code>是最大块，最大块的<code>bk_nextsize</code>就是最小块，这里应该也是尽量寻找最小能满足的块。正如循环所描述，如果<code>victim</code>的<code>chunk size</code>比我所需的最小能满足的<code>chunk size</code> <code>nb</code>还小，那就去寻找比他大的，因为是递增，所以能保证在<code>chunk</code>当中我一定会找到一个最小能满足的<code>chunk</code>。</p>
<p>这里解释一下两个最小能满足的意思：</p>
<p>首先<code>nb</code>是指用户需要的最小能满足的块的<code>size</code>，比如我只需要1个字节，但是我最小的<code>chunk size</code>都是<code>0x20</code>了，<code>0x20</code>的<code>chunk</code>就是对用户最小能满足的<code>chunk size</code>了。</p>
<p>如果能找到<code>size=nb</code>的块，当然是最好不过了，但是现实往往不会那么顺利，比如我只有一个<code>0x30</code>的块，如果我只有<code>0x30</code>而没有<code>0x20</code>的块，那么<code>0x30</code>就是我所有<code>free</code>块当中的最小能满足，其实这里<code>nb</code>应该叫最优能满足，但是我还是习惯这么叫了hhh。</p>
<p>然后呢找到这个之后就<code>unlink</code>这个块，把它从链中删除，拿出来之后进行一个判断，如果切割之后的块小于MINSIZE，那就不切割了，直接把它物理相邻的下一个快<code>prev_inuse</code>位设1，这个块就直接返回给用户了。否则就是切割，设置各种东西，这个前面有差不多的代码，我们主要看看剩下的块去哪里了，很明显，重新链入<code>unsorted bin</code>了。后面有一个<code>check</code>，如果<code>unsorted bin-&gt;fd-&gt;bk!=unsorted bin</code>，那么报错退出。这里需要注意，它只检测了<code>unsorted bin-&gt;fd-&gt;bk</code>是否等于那个<code>unsorted bin</code>，对于堆块来说我就是只检测了<code>bk</code>指针，这意味着<code>fd</code>指针如果修改为任意值不会在这里被检测到，这是一个利用小技巧，也只有你读过源码后才能好好理解这个<code>unsorted bin attack</code>了。然后如果剩余大小不在<code>small bin</code>范围内把<code>nextsize</code>指针全部清空，其它就是正常返回了。如果被切割的剩下<code>chunk</code>不在<code>small bin</code>范围内，就会清空它的<code>fd_nextsize</code>和<code>bk_nextsize</code>。因为它要回到<code>unsorted bin</code>里面，这两个字段就没什么用了，就会被清空。</p>
<h4 id="第七小块"><a href="#第七小块" class="headerlink" title="第七小块"></a>第七小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br></pre></td></tr></table></figure>

<p>我们来讲一讲<code>arena</code>的<code>binmap</code>结构，这个用于快速检索一个<code>bin</code>是否为空，每一个<code>bit</code>表示对应的<code>bin</code>中是否存在空闲<code>chunk</code>，虽然不知道为什么前面没有用到。这一段就是说，如果<code>large bin</code>搜索完了都没有找到合适的<code>chunk</code>，那么就去下一个<code>idx</code>里面寻找，这很合理。然后一共有4个int，每个<code>int</code>32位表示一块<code>map</code>，一共表示<code>128</code>位。</p>
<h4 id="第八小块"><a href="#第八小块" class="headerlink" title="第八小块"></a>第八小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看两个条件</p>
<ol>
<li><code>bit&gt;map</code>：如果这个位的权值都比它整个的<code>map</code>都大了，说明<code>map</code>上那个<code>bit</code>的权值必定为0</li>
<li><code>bit==0</code>：如果这个<code>bit</code>都是0说明这个<code>index</code>也不对。</li>
</ol>
<p>满足其一就看看别的<code>index</code>。</p>
<p>然后如果说<code>map==0</code>，说明这整个<code>block</code>都没有空闲块，就直接跳过，不为0则退出去执行下面的操作，如果超过了<code>block</code>的总数，那就说明<code>unsorted bin</code>和<code>large bin</code>中也没有合适的<code>chunk</code>，那我们就切割<code>top_chunk</code>了，这里用了一个<code>goto</code>跳转，我们后面分析。</p>
<h4 id="第九小块"><a href="#第九小块" class="headerlink" title="第九小块"></a>第九小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert (bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last (bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin)</span><br><span class="line">&#123;</span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时我已经找到了一个合适的<code>block</code>，然后就是看<code>block</code>的各个位了。从低位开始，如果检查到<code>map</code>那一位对应为0就找下一位，我们前面提到bk为<code>large bin</code>的最小块，所以先考虑它，当然不能说<code>map</code>里面说这里有它就有，我还得自己判断一下这个<code>bin</code>里面是不是真的有，如果没有(<code>bin-&gt;bk==bin</code>)，那么我就要及时把标志位清除然后<code>bit&lt;&lt;1</code>去寻找下一个<code>index</code>。</p>
<h4 id="最后一小块"><a href="#最后一小块" class="headerlink" title="最后一小块"></a>最后一小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">        have to perform a complete insert here.  */</span></span><br><span class="line">        bck = unsorted_chunks (av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果它确实有<code>chunk</code>呢？然后其实它还是跟前面一样的，在<code>large bin</code>中找到<code>chunk</code>的处理方式，<code>unlink</code>，切割，判断，设置标志位，切割后及时更新<code>last_remainder</code>，这里就是一个<code>large bin</code>的遍历。</p>
<p>还要讲一下的就是这个<code>check</code>，依旧是对<code>unsorted bin</code>的一个<code>check</code>，判断第一个<code>unsorted chunk</code>的<code>bk</code>指针是否指向<code>unsorted bin</code>的位置。这里需要把割剩下的<code>chunk</code>重新放回<code>unsorted bin</code>。至此整个<code>unsorted bin</code>和<code>large bin</code>的分配就讲完了。</p>
<h3 id="第六段：切割top-chunk"><a href="#第六段：切割top-chunk" class="headerlink" title="第六段：切割top_chunk"></a>第六段：切割top_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">             (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">             search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">             less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">             be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">             limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">             MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">             exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">             reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">             to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        av-&gt;top = remainder;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">             here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">            <span class="comment">/* restore original bin index */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                idx = smallbin_index (nb);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">                alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步比较简单，就是说先从<code>av-&gt;top</code>拿到<code>top_chunk</code>的地址。判断大小尝试切割，如果不能切割，它也不会尽量去麻烦操作系统，先调用<code>malloc_consolidate</code>去合并所有的<code>fast bin</code>里面的<code>chunk</code>。然后合并之后接着步入之前的循环，重新找一次<code>small bin</code> <code>large bin</code> <code>unsorted bin</code>，因为现在可能已经有合适的<code>chunk</code>了对吧。</p>
<p>然后如果还是没有合适的呢？就会进入这里的<code>else</code>，调用<code>sysmalloc</code>去分配内存，一次还是分配<code>0x21000</code>的<code>chunk</code>作为新的<code>top_chunk</code>，原来的<code>top_chunk</code>将会被<code>free</code>，一般来说如果你没有改过<code>top_chunk</code>的<code>size</code>，那么新的和旧的<code>top_chunk</code>将会是物理相邻，如果<code>free</code> 的<code>top_chunk</code>不在<code>fast bin</code>范围内，那就会和新的<code>top_chunk</code>发生合并。那么这一整个<code>malloc</code>源码就解读完了，我们来做一下总结。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>检查是否设置了<code>malloc_hook</code>，若设置了则跳转进入<code>malloc_hook</code>，若未设置则获取当前的分配区，进入<code>int_malloc</code>函数。</p>
</li>
<li><p>如果当前的分配区为空，则调用<code>sysmalloc</code>分配空间，返回指向新<code>chunk</code>的指针，否则进入下一步。</p>
</li>
<li><p>若用户申请的大小在<code>fast bin</code>的范围内，则考虑寻找对应<code>size</code>的<code>fast bin chunk</code>，判断该<code>size</code>的<code>fast bin</code>是否为空，不为空则取出第一个<code>chunk</code>返回，否则进入下一步。</p>
</li>
<li><p>如果用户申请的大小符合<code>small bin</code>的范围，则在相应大小的链表中寻找<code>chunk</code>，若<code>small bin</code>未初始化，则调用<code>malloc_consolidate</code>初始化分配器，然后继续下面的步骤，否则寻找对应的<code>small bin</code>的链表，如果该<code>size</code> 的<code>small bin</code>不为空则取出返回，否则继续下面的步骤。如果申请的不在<code>small bin</code>的范围那么调用<code>malloc_consolidate</code>去合并所有<code>fast bin</code>并继续下面的步骤。</p>
</li>
<li><p>用户申请的大小符合<code>large bin</code>或<code>small bin</code>链表为空，开始处理<code>unsorted bin</code>链表中的<code>chunk</code>。在<code>unsorted bin</code>链表中查找符合大小的<code>chunk</code>，若用户申请的大小为<code>small bin</code>，<code>unsorted bin</code>中只有一块chunk并指向<code>last_remainder</code>，且<code>chunk size</code>的大小大于<code>size+MINSIZE</code>，则对当前的<code>chunk</code>进行分割，更新分配器中的<code>last_remainder</code>，切出的<code>chunk</code>返回给用户，剩余的<code>chunk</code>回<code>unsorted bin</code>。否则进入下一步。</p>
</li>
<li><p>将当前的<code>unsorted bin</code>中的<code>chunk</code>取下，若其<code>size</code>恰好为用户申请的<code>size</code>，则将<code>chunk</code>返回给用户。否则进入下一步</p>
</li>
<li><p>获取当前<code>chunk size</code>所对应的bins数组中的头指针。（<code>large bin</code>需要保证从大到小的顺序，因此需要遍历）将其插入到对应的链表中。如果处理的chunk的数量大于<code>MAX_ITERS</code>则不在处理。进入下一步。</p>
</li>
<li><p>如果用户申请的空间的大小符合<code>large bin</code>的范围或者对应的small bin链表为空且<code>unsorted bin</code>链表中没有符合大小的<code>chunk</code>，则在对应的<code>large bin</code>链表中查找符合条件的<code>chunk</code>（即其大小要大于用户申请的<code>size</code>）。若找到相应的<code>chunk</code>则对<code>chunk</code>进行拆分，返回符合要求的<code>chunk</code>（无法拆分时整块返回）。否则进入下一步。</p>
</li>
<li><p>根据<code>binmap</code>找到表示更大<code>size</code>的<code>large bin</code>链表，若其中存在空闲的<code>chunk</code>，则将<code>chunk</code>拆分之后返回符合要求的部分，并更新<code>last_remainder</code>。否则进入下一步。</p>
</li>
<li><p>若<code>top_chunk</code>的大小大于用户申请的空间的大小，则将<code>top_chunk</code>拆分，返回符合用户要求的<code>chunk</code>，并更新<code>last_remainder</code>，否则进入下一步。</p>
</li>
<li><p>若<code>fast bin</code>不为空，则调用<code>malloc_consolidate</code>合并<code>fast bin</code>，重新回到第四步再次从<code>small bin</code>搜索。否则进入下一步。</p>
</li>
<li><p>调用<code>sysmalloc</code>分配空间，<code>free top chunk</code>返回指向新<code>chunk</code>的指针。</p>
</li>
<li><p>若<code>_int_malloc</code>函数返回的<code>chunk</code>指针为空，且当前分配区指针不为空，则再次尝试<code>_int_malloc</code></p>
</li>
<li><p>对<code>chunk</code>指针进行检查，主要检查<code>chunk</code>是否为<code>mmap</code>，且位于当前的分配区内。</p>
<h2 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h2></li>
</ol>
<p>那我们现在开始解读一下<code>free</code>的源码</p>
<h3 id="libc-free源码分析"><a href="#libc-free源码分析" class="headerlink" title="__libc_free源码分析"></a>__libc_free源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>free</code>函数也是直接调用这里的<code>__libc_free</code>函数完成<code>chunk</code>的释放的操作的。</p>
<p>跟<code>malloc</code>一样，先读取<code>__free_hook</code>看看是否为空，如果为空则直接由<code>free_hook</code>指向的函数代为执行<code>free</code>，这里也是我们经常劫持的钩子函数，而且<code>free_hook</code>劫持起来比<code>malloc_hook</code>困难。但是一旦劫持成功也会很方便，就是说<code>malloc</code>_hook函数我只能写<code>one_gadget</code>，而一旦条件苛刻那么就还得调栈啊之类的一些操作。劫持到了<code>free_hook</code>我们就直接写<code>system</code>函数，然后<code>free</code>一个内容为<code>/bin/sh</code>的堆块就能稳定<code>get shell</code>。</p>
<p>然后执行<code>free(NULL)</code>无任何效果，直接返回。</p>
<p>将传入的指针转换为<code>chunk</code>的指针，因为用户得到的指针其实是<code>&amp;chunk-&gt;fd</code>，这里改为<code>chunk</code>的指针。然后这里需要寻找这个堆块的分配器，看看这个堆块是从哪里分配出来的。之后就是调用<code>_int_free</code>函数去真正释放chunk</p>
<h3 id="int-free源码分析"><a href="#int-free源码分析" class="headerlink" title="_int_free源码分析"></a>_int_free源码分析</h3><p>同样我们分成几段来讲解，总源码也不直接给了。</p>
<h4 id="第一段：free前的各种check"><a href="#第一段：free前的各种check" class="headerlink" title="第一段：free前的各种check"></a>第一段：free前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line">INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line"><span class="type">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>首先变量定义是差不多的，然后这里进行了一项<code>check</code>。</p>
<ol>
<li><code>(uintptr_t) p &gt; (uintptr_t) -size</code>：这里让我有点费解，指针和size进行比较。通常情况下size取负之后会变得很大，比如<code>0xfff...</code>这样的大数值通常指针不会指向这样的地址，f开头的一般都是内核地址。所以<code>p&gt;0xfff....</code>主要是应该要检测被<code>free</code>的<code>chunk</code>的<code>size</code>不要过大。</li>
<li><code>misaligned_chunk (p)</code>：这里的话主要是这个<code>chunk</code>的指针与上掩码，掩码就是<code>0x10-1</code>也就是<code>0xf</code>，取出后四位观察是否为0，如果不为0则说明指针错误了，机会在这里报错。这里主要是检查对齐，指针需要指到<code>0x10</code>的整倍数的<code>chunk</code>才能被正常<code>free</code>，就是不知道<code>malloc</code>为什么不开这个检测，开了又有一大批利用手段用不了了(狗头。</li>
</ol>
<p><code>check</code>不通过就会用<code>malloc_printerr</code>打印错误信息，然后处理锁上的一些内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure>

<p>又有一个<code>check</code></p>
<ol>
<li><code>size &lt; MINSIZE</code>：如果<code>size</code>还比<code>MINSIZE</code>要小，那肯定<code>size</code>肯定出错了。</li>
<li><code>!aligned_OK (size)</code>：<code>chunk size</code>也要对齐，但是这个<code>check</code>一般不会被触发，因为再取出<code>chunk size</code>的时候就会把最低位与掉。</li>
</ol>
<p>然后它这里需要<code>check</code>一下这个<code>free</code>的<code>chunk</code>是正在使用的，怎么<code>check</code>呢，那就肯定是下一个<code>chunk</code>的<code>prev_inuse</code>位为0啦，具体的实现函数是这样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_inuse_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr next;</span><br><span class="line"></span><br><span class="line">  do_check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* mmapped chunks have no next/prev */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check whether it claims to be in use ... */</span></span><br><span class="line">  assert (inuse (p));</span><br><span class="line"></span><br><span class="line">  next = next_chunk (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... and is surrounded by OK chunks.</span></span><br><span class="line"><span class="comment">     Since more things can be checked with free chunks than inuse ones,</span></span><br><span class="line"><span class="comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Note that we cannot even look at prev unless it is not inuse */</span></span><br><span class="line">      mchunkptr prv = prev_chunk (p);</span><br><span class="line">      assert (next_chunk (prv) == p);</span><br><span class="line">      do_check_free_chunk (av, prv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">      assert (prev_inuse (next));</span><br><span class="line">      assert (chunksize (next) &gt;= MINSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!inuse (next))</span><br><span class="line">    do_check_free_chunk (av, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多的也不说了，相信都能理解的，根据自身指针和自身大小就可以很容易知道下一个<code>chunk</code>的位置，然后检测一下<code>prev_inuse</code>位判断我当前<code>chunk</code>是否被使用。</p>
<h3 id="fast-bin范围的处理"><a href="#fast-bin范围的处理" class="headerlink" title="fast bin范围的处理"></a>fast bin范围的处理</h3><h4 id="fast-bin的check"><a href="#fast-bin的check" class="headerlink" title="fast bin的check"></a>fast bin的check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">    &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">        of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">        after getting the lock.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock</span><br><span class="line">        || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">        || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">        &#125;))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! have_lock)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个大条件很明显就是判断这个<code>free</code>的<code>chunk</code>是否为<code>fast bin</code>，后面又判断且这个<code>chunk</code>的后一个<code>chunk</code>不为<code>top_chunk</code>，虽然根据自己的经验好像判断后一个不为<code>top_chunk</code>没什么意义。</p>
<p>然后满足的话就是一个<code>check</code>，判断<code>size</code>是否小于<code>MINSIZE</code>或者是<code>size&gt;=system_mem</code>。就是排除一些不合理的情况然后会重新尝试拿分配器的锁然后再做一个判断，如果刚刚那个条件还是成立的话那就说明<code>size</code>真的被改成了非法数值，那就报错退出。</p>
<p>如果进来了但是没有执行报错呢，说明可能多线程有点问题，就释放这个<code>arena</code>的锁，这里我多线程不是很好也不知道该如何解释，但是这个应该不是主要分析的，咱们平时做题基本也不会遇到多线程编程的题目。</p>
<h4 id="free-fast-bin"><a href="#free-fast-bin" class="headerlink" title="free fast bin"></a>free fast bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT        (1U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">        (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">        size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">        only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">        deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">            old_idx = fastbin_index(chunksize(old));</span><br><span class="line">        p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它先执行了一个<code>free_perturb</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free_perturb</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">free_perturb</span> <span class="params">(<span class="type">char</span> *p, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实跟前面<code>malloc</code>那个函数差不多，就是看你有没有设置那个值，如果设置了就在<code>free</code>之前把堆块进行<code>memset</code>清空，但是不一样的是，<code>perturb</code>中<code>memset</code>第二个参数是要根据你设置的值再异或一个<code>0xff</code>的。</p>
<p>然后是用<code>set_fastchunks(av)</code>宏定义去初始化<code>fast bin</code>。之后根据<code>size</code>算出下标找到对应的<code>fast bin</code>，之后就应该把这个<code>free</code>的<code>chunk</code>链入<code>fast bin</code>里面。这里还有一个<code>check</code>，如果<code>bin</code>顶部的那个<code>chunk</code>和这次要<code>free</code>的<code>chunk</code>相等的话，就报错退出，这也就是我们熟知的<code>double free</code>漏洞了。那么说到<code>double free</code>我们来看看<code>double free</code>能造成什么后果。</p>
<p>假如我要<code>free</code>的<code>chunk</code>是A，我第一次<code>free</code> A，<code>bin</code>为空，链入其中，<code>fast bin</code>中多了一个A。第二次<code>free</code> A，A再次被加入<code>fast bin</code>中，然后会导致产生一个自己指向自己的指针。<code>fast bin</code>中的情况就是两个A，<code>A-&gt;A</code>。此时我申请一个和A一样大的<code>chunk</code>，A被申请走，<code>fast bin</code>中还剩下一个A，但是此时用户手里有一个A，<code>fast bin</code>中也有一个A。用户可以直接编辑A的指针域，比如我让它指向了<code>got</code>表中的<code>free</code>函数。那么此时<code>fast bin</code>中的情况就是<code>A-&gt;free@got</code>。然后我再次申请和A一样大小的<code>chunk</code>，A被取出来，<code>fast bin</code>中剩下<code>free@got</code>。那么我第三次申请就得到了在<code>free@got</code>那边的<code>chunk</code>，然后假如我偷偷修改一下<code>free@got</code>为<code>system</code>，那就能轻松<code>get shell</code>了。这里可以看到，<code>free@got</code>这个指针我是能任意编辑的，也就是说我想申请到哪都不是问题，这样我就能任意地址写了。</p>
<p>你可能有点疑问，我<code>free</code>了2个堆块，怎么出来3个堆块。那我们想想，如果遍历一个单链表，你怎么判断结尾？咱们一般都是判断<code>x-&gt;next!=NULL</code>但是原来那边A的<code>next</code>指针确实是<code>NULL</code>，但是你把指针改过了，就会认为<code>fast bin</code>还没有空。</p>
<p>但是实际情况往往没有那么简单，前面我们说过了，<code>malloc</code>取出一个<code>fast bin</code>的<code>chunk</code>的时候，会判断它<code>chunk</code>的<code>size</code>是否等于当前我要申请的<code>size</code>，如果不是就会报错退出。所以<code>double free</code>在利用的时候还是没那么”任意”的，而且这里也不允许你直接<code>double free</code>，但是直接不能不代表不能间接<code>double free</code>，如果我先<code>free</code>一个A，<code>free</code>一个B之后再<code>free</code>一个A，那么我再申请到A的时候修改A的指针域一样可以劫持，并且可以绕过这里的检测。</p>
<p>然后如果过了检测，那就将这个<code>chunk</code>假如<code>fast bin</code>的顶部。这里就是一个单链表的插入，具体自己写的话应该是这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd=av-&gt;fastbinY[index]-&gt;fd;</span><br><span class="line">av-&gt;fastbinY[index]-&gt;fd=p;</span><br></pre></td></tr></table></figure>

<p>源码中与这个略微有点不一样，效果是一样的。所以也可以看出来这个是后进先出，只在<code>fast bin</code>的一端插入删除，跟栈差不多。</p>
<p>末尾还有一个<code>check</code>，但是这个<code>check</code>通常不会被触发，有会的师傅也请帮帮，因为是真的不知道hhh。</p>
<h4 id="free非fast-bin"><a href="#free非fast-bin" class="headerlink" title="free非fast bin"></a>free非fast bin</h4><p>这里分了两种情况，如果<code>chunk</code>是<code>mmap</code>分配的话那就调用<code>munmap_chunk</code>函数去<code>free</code>这个<code>chunk</code>，这个情况不属于我们主要要分析的内容，所以那边的else分支我们跳过，只分析非<code>mmap</code>分配的<code>chunk</code>。</p>
<h4 id="第一部分：锁"><a href="#第一部分：锁" class="headerlink" title="第一部分：锁"></a>第一部分：锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    assert (locked);</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这我熟，就是在用一个分配器的时候先加锁，用完了释放就行了。这主要是为了防止多个线程之间发生竞争，虽然我看过多线程是说有独立的堆空间，但是假设堆块正常使用，正常分配，不去做指针的越界操作，那么同一个分配器分配给不同的线程用也是完全可行的，我只拿到我自己用的指针在合法范围内用一样不会造成竞争的现象。以上出于我自己的大胆推测，如有不对还请指正。</p>
<h4 id="第二部分：free之前的各种check"><a href="#第二部分：free之前的各种check" class="headerlink" title="第二部分：free之前的各种check"></a>第二部分：free之前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">                      &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">                      &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<span class="comment">//后面块的prev in use标志位为0时发生free</span></span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure>

<p>好，我们来看第一个<code>check</code>。</p>
<ol>
<li><code>p == av-&gt;top</code>：<code>free</code>的<code>chunk</code>为<code>top_chunk</code>。</li>
</ol>
<p><code>top_chunk</code>和其它<code>bin</code>一样，都是出于待分配状态，<code>top_chunk</code>永远不会被使用。因为如果切割了<code>top_chunk</code>，<code>top_chunk</code>马上会下移，所以正常分配是绝对不会分配到现在的<code>top_chunk</code>指针的，所以当你尝试<code>free</code> <code>top_chunk</code>的时候，就会报这个错。</p>
<p>第二个<code>check</code></p>
<ol>
<li><code>contiguous (av)</code>：检查分配器上的<code>flags</code>，其实我也不知道是干嘛的(捂脸。</li>
<li><code>(char *) nextchunk&gt;=(char *) av-&gt;top + chunksize(av-&gt;top)</code>：然后这个条件呢就是说如果我这个<code>chunk</code>的下一个<code>chunk</code>居然在<code>top_chunk</code>之后，那肯定就也有错了。</li>
</ol>
<p>第三个<code>check</code></p>
<ol>
<li><code>!prev_inuse(nextchunk)</code>：就是说如果后一个<code>chunk</code>的<code>prev_inuse</code>为0，也就是说这个<code>chunk</code>处于被<code>free</code>的状态，那么这一次<code>free</code>就有可能造成<code>double free</code>了，就会报错。</li>
</ol>
<p>第四个<code>check</code></p>
<ol>
<li><code>nextchunk-&gt;size &lt;= 2 * SIZE_SZ</code>：如果下一个<code>chunk</code>的<code>size</code>有问题一样也要报错退出，这里说的就是下一个<code>chunk</code>的<code>size</code>小于<code>MINSIZE</code>的情况，free的话因为会涉及到chunk的向前合并或者向后合并，因此对前后堆块的检查都很严格。</li>
<li><code>nextsize &gt;= av-&gt;system_mem</code>：<code>size</code>超出系统分配给分配器的内存，那也报错。</li>
</ol>
<h4 id="第三部分：free之后向前合并"><a href="#第三部分：free之后向前合并" class="headerlink" title="第三部分：free之后向前合并"></a>第三部分：free之后向前合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就提到了我们之前讲到的一个问题，我一个堆块怎么向前合并，也就是如何准确地找到前一个堆块。向前合并的时候我先判断一下前一个<code>chunk</code>是否被使用，如果不被使用那么就要和前面的<code>chunk</code>合并。这里我就可以通过<code>prev_size</code>位去找到这个堆块，用自身指针减去<code>prev_size</code>就得到了前一个<code>chunk</code>的指针。</p>
<p>这里需要注意，因为前面那个<code>chunk</code>可能在<code>large bin</code>,<code>small bin</code>或者是<code>unsorted bin</code>的链表当中，那么我就得先把它从这些<code>bin</code>里面解脱出来，也就是<code>unlink</code>操作，合并之后成为一个新的<code>chunk</code>然后再加入<code>unsorted bin</code>。</p>
<p>这里向前合并的操作呢应该也没有很复杂，就是改个<code>size</code>然后把<code>free</code>的指针指到前面去，相当于是要<code>free</code>合并后的<code>chunk</code>了。然后<code>unlink</code>把前面的<code>chunk</code>在<code>bin</code>中删除。</p>
<h4 id="第四部分：free之后向后合并"><a href="#第四部分：free之后向后合并" class="headerlink" title="第四部分：free之后向后合并"></a>第四部分：free之后向后合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate forward */</span></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">    not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">    been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;fd = fwd;</span><br><span class="line">    p-&gt;bk = bck;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bck-&gt;fd = p;</span><br><span class="line">    fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个特判后面的<code>chunk</code>是否为<code>top_chunk</code>，<code>top_chunk</code>的情况就非常简单，因为合并的<code>chunk</code>并不在任何<code>bin</code>里面，<code>top_chunk</code>后面也没有堆块不需要设置标志位。只需要改一下<code>top_chunk</code>的<code>size</code>，然后改一下指针，就完了。</p>
<p>那么我们分析不是<code>top_chunk</code>的情况，首先我先获取一下下一个<code>chunk</code>的是否被使用，如果没有被使用，那么把后面的<code>chunk</code>就先<code>unlink</code>了，然后自己<code>chunk</code>的<code>size</code>加上后面那个<code>chunk</code>的<code>size</code>成为新的<code>chunk</code>。否则，我就直接清空后面<code>chunk</code>的<code>prev_inuse</code>位，就是表示我这个<code>chunk</code>已经不被使用了。好了之后那就是把这个<code>chunk</code>链入<code>unsorted bin</code>。这里还有一个<code>check</code>，跟<code>malloc</code>那个一样，，后面基本也都一样了，就不细讲了，链入，设置标记为，设置<code>prev_size</code>，如果不在<code>small chunk</code>的大小还会清空<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，如果不理解可以往上翻一下看看。目录标题为“最后一小块”，那边是切割<code>bin</code>的时候设置的。</p>
<h4 id="第五部分：最后的处理"><a href="#第五部分：最后的处理" class="headerlink" title="第五部分：最后的处理"></a>第五部分：最后的处理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">            systrim(mp_.top_pad, av);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">       large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如注释所说，如果我一次释放了一个很大的空间(<code>0x10000B</code>)，那么会调用<code>malloc_consolidate</code>合并所有<code>fast bin</code>，如果进程所在的分配区是主分配区并且可以收缩内存的话，就调用<code>systrim</code>收缩内存，否则就获得非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>收缩<code>heap</code>。因为我们认为一次<code>free</code>很大的空间那么操作系统可以适当回收点内存了，大不了等你不够就再像我要嘛，资源的合理配置，很合理。</p>
<p>至此，<code>free</code>部分的源码也都分析完啦。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>就不向<code>malloc</code>一样描述具体步骤了，因为本身逻辑没有很复杂。主要就是<code>free</code>非<code>fast bin chunk</code>的向前合并或者向后合并。</p>
<p><code>free</code>在<code>fast bin</code>范围内的<code>chunk</code>，直接将<code>chunk</code>链入<code>fast bin</code>，<code>free</code>非<code>fast bin</code>范围的<code>chunk</code>视具体情况向前合并或者向后合并然后加入<code>unsorted bin</code>，如果一次<code>free</code>太多的空间有可能会被操作系统回收。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>源码分析也就完结撒花了，后续可能会出heap的各种利用方式和利用手段，或者局部分析其它版本的libc。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xia0ji233.github.io">xia0ji233</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xia0ji233.github.io/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://xia0ji233.github.io/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xia0ji233.github.io" target="_blank">xia0ji233's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/02/actf_2019_onerepeater%20writeup/" title="actf_2019_onerepeater writeup"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">actf_2019_onerepeater writeup</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/" title="分块入门2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分块入门2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><a href="/"> <div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></a><div class="author-info__name">xia0ji233</div><div class="author-info__description">Nepnep team</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">307</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">87</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xia0ji233"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xia0ji233" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xia0ji233@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">老当益壮，宁移白首之心？穷且益坚，不坠青云之志。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ptmalloc2%E7%9A%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.</span> <span class="toc-text">ptmalloc2的分配策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ptmalloc2%E7%9A%84%E5%85%B7%E4%BD%93%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.</span> <span class="toc-text">ptmalloc2的具体分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin"><span class="toc-number">3.1.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin"><span class="toc-number">3.2.</span> <span class="toc-text">unsorted bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#small-bin"><span class="toc-number">3.3.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin"><span class="toc-number">3.4.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-chunk"><span class="toc-number">3.5.</span> <span class="toc-text">top_chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.</span> <span class="toc-text">分配流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">malloc源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">__libc_malloc源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">_int_malloc源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AE%B5%EF%BC%9Amain-arena%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">第一段：main_arena初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AE%B5%EF%BC%9Afast-bin%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">第二段：fast bin的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AE%B5%EF%BC%9Asmall-bin%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">第三段：small bin的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AE%B5%EF%BC%9A%E5%88%86%E9%85%8Dlargebin%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.6.</span> <span class="toc-text">第四段：分配largebin时的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AE%B5%EF%BC%9Alarge-bin%E5%92%8Cunsorted-bin%E7%9A%84%E7%9B%B8%E7%88%B1%E7%9B%B8%E6%9D%80"><span class="toc-number">4.7.</span> <span class="toc-text">第五段：large bin和unsorted bin的相爱相杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC1%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.1.</span> <span class="toc-text">第1小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.2.</span> <span class="toc-text">第二小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.3.</span> <span class="toc-text">第三小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.4.</span> <span class="toc-text">第四小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.5.</span> <span class="toc-text">第五小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.6.</span> <span class="toc-text">第六小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.7.</span> <span class="toc-text">第七小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.8.</span> <span class="toc-text">第八小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.9.</span> <span class="toc-text">第九小块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%B0%8F%E5%9D%97"><span class="toc-number">4.7.10.</span> <span class="toc-text">最后一小块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AE%B5%EF%BC%9A%E5%88%87%E5%89%B2top-chunk"><span class="toc-number">4.8.</span> <span class="toc-text">第六段：切割top_chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">free源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.1.</span> <span class="toc-text">__libc_free源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">_int_free源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AE%B5%EF%BC%9Afree%E5%89%8D%E7%9A%84%E5%90%84%E7%A7%8Dcheck"><span class="toc-number">5.2.1.</span> <span class="toc-text">第一段：free前的各种check</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin%E8%8C%83%E5%9B%B4%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">fast bin范围的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fast-bin%E7%9A%84check"><span class="toc-number">5.3.1.</span> <span class="toc-text">fast bin的check</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free-fast-bin"><span class="toc-number">5.3.2.</span> <span class="toc-text">free fast bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free%E9%9D%9Efast-bin"><span class="toc-number">5.3.3.</span> <span class="toc-text">free非fast bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E9%94%81"><span class="toc-number">5.3.4.</span> <span class="toc-text">第一部分：锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9Afree%E4%B9%8B%E5%89%8D%E7%9A%84%E5%90%84%E7%A7%8Dcheck"><span class="toc-number">5.3.5.</span> <span class="toc-text">第二部分：free之前的各种check</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9Afree%E4%B9%8B%E5%90%8E%E5%90%91%E5%89%8D%E5%90%88%E5%B9%B6"><span class="toc-number">5.3.6.</span> <span class="toc-text">第三部分：free之后向前合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9Afree%E4%B9%8B%E5%90%8E%E5%90%91%E5%90%8E%E5%90%88%E5%B9%B6"><span class="toc-number">5.3.7.</span> <span class="toc-text">第四部分：free之后向后合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%EF%BC%9A%E6%9C%80%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.3.8.</span> <span class="toc-text">第五部分：最后的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/14/tencent-race-2025-final/" title="腾讯游戏安全竞赛2025决赛题解">腾讯游戏安全竞赛2025决赛题解</a><time datetime="2025-04-14T02:00:00.000Z" title="发表于 2025-04-14 10:00:00">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/31/tencent-race-2025-pre/" title="腾讯游戏安全大赛2025初赛题解">腾讯游戏安全大赛2025初赛题解</a><time datetime="2025-03-31T02:00:00.000Z" title="发表于 2025-03-31 10:00:00">2025-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/WindowsAPC2/" title="windowsAPC学习（2）——APC挂入与执行">windowsAPC学习（2）——APC挂入与执行</a><time datetime="2025-02-17T05:00:00.000Z" title="发表于 2025-02-17 13:00:00">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/14/Game6/" title="某二次元开放世界冒险游戏反作弊分析报告">某二次元开放世界冒险游戏反作弊分析报告</a><time datetime="2025-02-14T03:00:00.000Z" title="发表于 2025-02-14 11:00:00">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/09/WindowsAPC1/" title="windowsAPC学习（1）——APC简介">windowsAPC学习（1）——APC简介</a><time datetime="2025-02-09T12:00:00.000Z" title="发表于 2025-02-09 20:00:00">2025-02-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By xia0ji233</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><script src="/live2d-widget/dist/autoload.js"></script><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>