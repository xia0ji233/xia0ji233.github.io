<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-21T16:46:40.895Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codeforces Round 784 (Div.4)</title>
    <link href="http://example.com/2022/04/22/codeforces%20round%20784(div.4)/"/>
    <id>http://example.com/2022/04/22/codeforces%20round%20784(div.4)/</id>
    <published>2022-04-21T16:35:00.000Z</published>
    <updated>2022-04-21T16:46:40.895Z</updated>
    
    <content type="html"><![CDATA[<p>今天来打个<a href="https://codeforces.com/contest/1669">div4</a>。</p><span id="more"></span><h2 id="A-Division"><a href="#A-Division" class="headerlink" title="A. Division?"></a>A. Division?</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这应该是描述了 <code>cf</code> 四个层次比赛的最高积分要求，超过将 <code>unrated</code> 进行比赛。直接按他的要求把四个等级判断输出一下就好了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1399</span>)&#123;</span><br><span class="line">        k=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1599</span>)&#123;</span><br><span class="line">        k=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1899</span>)&#123;</span><br><span class="line">        k=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        k=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Division %d\n&quot;</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Triple"><a href="#B-Triple" class="headerlink" title="B. Triple"></a>B. Triple</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>随便输出一个出现过三次的数就好了，但是要注意出现之后不要马上结束，把剩下的输入读完。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(ma);</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            ma[x]++;</span><br><span class="line">            <span class="keyword">if</span>(ma[x]==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Odd-Even-Increments"><a href="#C-Odd-Even-Increments" class="headerlink" title="C. Odd/Even Increments"></a>C. Odd/Even Increments</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>偶数位置或者奇数位置同时+1，问能否达到全奇数或者全偶数的状态，直接判断奇数位置上是否全为奇数或者全为偶数和偶数位置上是否全为奇数或者全为偶数即可。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span>!=a[i<span class="number">-2</span>]%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span>!=a[i<span class="number">-2</span>]%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Colorful-Stamp"><a href="#D-Colorful-Stamp" class="headerlink" title="D. Colorful Stamp"></a>D. Colorful Stamp</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>有一个长度为2的红蓝印章，每次打印上去可以使相邻两个格子的颜色一个为红，一个为蓝，颜色可以覆盖。那么格子将出现三种状态：白，红，蓝。我们以白色方格作为分割，容易发现不可能存在长度为1的红色或者蓝色色块，所以只有一个格子的时候那个格子必为白色，不可能是红色或者蓝色。对于一个连续的色块，可以发现必须同时存在蓝色和红色。因此只要所有的连续色块满足这个要求就可以啦。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    s[n++]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>&amp;&amp;flag!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            len=<span class="number">0</span>;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                flag|=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">                flag|=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-2-Letter-Strings"><a href="#E-2-Letter-Strings" class="headerlink" title="E. 2-Letter Strings"></a>E. 2-Letter Strings</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/5.png" alt="5"></p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定若干个长度只有2的字符串，要求输出符合要求的对数，要求为两对字符串有且仅有1个位置字符不一样。由于数据点较小，我们很容易想到把字符串转int类型比较，由于字符只有11种，理论上可以一个char压缩字符串，但是我选择用short进行，因为复杂度绰绰有余。</p><p>然后对于转换成的整数类型进行比较，若发现高位或者低位相同，则将答案加上 $num[i]*num[j]$，题目已经提示long long，其它的也没啥了。</p><h3 id="标程-4"><a href="#标程-4" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        a[((s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)&lt;&lt;<span class="number">8</span>)|(s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (i&amp;<span class="number">0x0000ff00</span>)==(j&amp;<span class="number">0x0000ff00</span>)||(i&amp;<span class="number">0x000000ff</span>)==(j&amp;<span class="number">0x000000ff</span>) )&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&amp;&amp;a[j])&#123;</span><br><span class="line">                    ans+=<span class="number">1ll</span>*a[i]*a[j];</span><br><span class="line">                    <span class="comment">//printf(&quot;0x%x 0x%x\n&quot;,i,j);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,a[0x101]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Eating-Candies"><a href="#F-Eating-Candies" class="headerlink" title="F. Eating Candies"></a>F. Eating Candies</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/6.png" alt="6"></p><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是一个人只能从左吃，另一个人只能从右开始吃，问最后吃的重量一样的情况下的最多糖果。这个直接贪心好了，如果左边人少了那就左边的人吃，否则右边的人吃，一旦重量一样了保存结果，最后输出即可。</p><h3 id="标程-5"><a href="#标程-5" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> w[N+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=n;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">            ans=i<span class="number">-1</span>+n-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">            a+=w[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b+=w[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,i,j);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==b)ans=n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Fall-Down"><a href="#G-Fall-Down" class="headerlink" title="G. Fall Down"></a>G. Fall Down</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/7.png" alt="7"></p><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>模拟题，直接按要求下落石块就行，注意判断一下下落条件即可。</p><h3 id="标程-6"><a href="#标程-6" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fall</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//a[y++][x];</span></span><br><span class="line">    <span class="keyword">while</span>(y!=n&amp;&amp;a[y+<span class="number">1</span>][x]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        a[y][x]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        y++;</span><br><span class="line">        a[y][x]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            a[i][j]=s[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">fall</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Maximal-AND"><a href="#H-Maximal-AND" class="headerlink" title="H. Maximal AND"></a>H. Maximal AND</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/8.png" alt="8"></p><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><p>有k次机会让某一个数的二进制位变成1，最后求所有数的与最大值。我们直接统计所有位的情况，从最高位开始，如果当前k的值允许变为全1则直接给了，然后答案加上那一位即可。</p><h3 id="标程-7"><a href="#标程-7" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_bit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            a[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="built_in">get_bit</span>(x);</span><br><span class="line">        <span class="comment">//puts(&quot;1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=n-a[i])&#123;</span><br><span class="line">            k-=n-a[i];</span><br><span class="line">            ans|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次在cf上ak，也算成功吧，虽然都挺简单的hhh。</p><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/9.png" alt="9"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来打个&lt;a href=&quot;https://codeforces.com/contest/1669&quot;&gt;div4&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="codeforces" scheme="http://example.com/categories/icpc/codeforces/"/>
    
    <category term="签到" scheme="http://example.com/categories/icpc/codeforces/%E7%AD%BE%E5%88%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>codeforces round 783(Div.2)解析</title>
    <link href="http://example.com/2022/04/20/codeforces%20round%20783(div.2)/"/>
    <id>http://example.com/2022/04/20/codeforces%20round%20783(div.2)/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-21T06:14:28.181Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1668">Codeforces Round #783 (Div. 2)</a></p><span id="more"></span><h2 id="A-Direction-Change"><a href="#A-Direction-Change" class="headerlink" title="A. Direction Change"></a>A. Direction Change</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/codeforces%20round%20783(div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>不难发现，我最优的路线只能是向右或者向下走。我先不妨设 $m\ge n$，如果走到底了，不得以我只能向上转变方向然后再右下，这样循环走直到终点，只考虑到了最后一行的情况，不难发现，每次长度+1变为奇数时，走的步数+1，否则+3。最后特判一下走不了的情况，当只有一行且有超过2列的情况为走不了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m)&#123;<span class="comment">//m&gt;n</span></span><br><span class="line">        <span class="built_in">swap</span>(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    ans+=<span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">    m-=n;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=<span class="number">2</span>*m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=<span class="number">2</span>*m<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Social-Distance"><a href="#B-Social-Distance" class="headerlink" title="B.Social Distance"></a>B.Social Distance</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/codeforces%20round%20783(div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>n个人要做在m把椅子上，每个人对自己有要求，要求左右两边必须有一定数目把空椅子。这个交错两发，后面发现这些人不是按顺序坐的，可以随意排，那么不难发现我们可以对要求从小到大排序然后相邻之间的要求取max最后取和得到一个值与m比较即可。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000006</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]+<span class="number">1</span>&gt;m)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    </span><br><span class="line">    a[<span class="number">0</span>]=a[n];</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">max</span>(a[i],a[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=m)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Make-it-Increasing"><a href="#C-Make-it-Increasing" class="headerlink" title="C. Make it Increasing"></a>C. Make it Increasing</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/codeforces%20round%20783(div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定一个初始值全为0的数组，每个位置可以固定加或减一定的值，要求序列严格递增，求最少操作次数。对于这个问题只需要抓住一个重点：那就是谁为0，根据给定的 $n&lt;5000$ 基本可以判断出来这个要 $O(n^2)$ 的算法。我们只需要循环把一个数强制设置为0，然后0往左边递减，往右边递增，这里我也可以往左边递增，因为减去和加上差不多的嘛，我加上让它递增和减去让它递减是差不多的。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0x7fffffffffffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//zero</span></span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(b[j+<span class="number">1</span>]+<span class="number">1</span>)/a[j]);</span><br><span class="line">            ans+=k;</span><br><span class="line">            b[j]=k*a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(b[j<span class="number">-1</span>]+<span class="number">1</span>)/a[j]);</span><br><span class="line">            ans+=k;</span><br><span class="line">            b[j]=k*a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">min</span>(res,ans);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时也有点没注意到就是数值可能很大，大到超过int，当时初值我只给了0x7fffffff就wa了一发。</p><p>这场比赛失误了很多吧，不过最后还得感谢大自然的馈赠，写了一个明显有问题的程序让我hack了，没至于让我掉太多分。</p><p><img src="/2022/04/20/codeforces%20round%20783(div.2)/4.png" alt="4"></p><p>继续加油吧，上分之路还很漫长。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1668&quot;&gt;Codeforces Round #783 (Div. 2)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="codeforces" scheme="http://example.com/categories/icpc/codeforces/"/>
    
    <category term="思维" scheme="http://example.com/categories/icpc/codeforces/%E6%80%9D%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>概率论在icpc的应用</title>
    <link href="http://example.com/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2022-04-18T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.852Z</updated>
    
    <content type="html"><![CDATA[<p>昆明打铁之后，痛定思痛，来重修概率论了。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="样本空间、事件和概率"><a href="#样本空间、事件和概率" class="headerlink" title="样本空间、事件和概率"></a>样本空间、事件和概率</h2><p><strong>样本空间</strong> S 是一个集合，它的元素称为<strong>基本事件</strong>。样本空间的一个子集被称为事件， 根据定义，所有基本事件<strong>互斥</strong>。</p><p><strong>互斥事件</strong>：若事件 A 发生<strong>一定</strong>能推导出 B 不发生，B 发生<strong>一定</strong>能推导出A不发生，则称 A，B 互斥，不难得出，两个事件同时发生的概率为 0，至少发生其中一个事件的概率为两者概率之和（概率公理3）。这个理论可以推导到 n 个事件，若有 n 个<strong>两两互斥</strong>事件 $a_1,a_2…a_n$，则任意两个事件同时发生的概率为 0，任意发生一个事件的概率就为 $\sum _{i=1}^n a_i$ 。</p><p><strong>概率公理</strong>：</p><ol><li>对于任意事件 A，事件发生的概率满足 $0\le P{A}\le1$</li><li>对于样本空间 S，有$P{S}=1$</li><li>对于两个互斥事件 A，B，有 $P{A∪B}=P{A}+P{B}$</li></ol><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>如果对样本空间 S 中的任意事件 e，都有<strong>唯一</strong>的实数 <strong>X(e)</strong> 与之对应，则称 <strong>X=X(e)</strong> 为样 本空间 S 上的随机变量。这个随机变量怎么理解呢，首先看下面这张图：</p><p><img src="/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/1.png" alt="1"></p><p>还不能理解的话，就举个栗子，如果掷一个骰子，那么它的样本空间为 **{1,2,3,4,5,6}**，把它一次掷骰子出的点数作为一个随机变量的话，那么很容易得到映射 X 就是一个普通的 $X(e)=e$，或者说，随机变量为样本点 e 的函数，以样本点为自变量，确定一个对应关系得到的应变量就是一个随机变量。</p><p>其中<strong>离散型随机变量</strong>和<strong>连续型随机变量</strong>比较常见。</p><h3 id="离散型随机变量及其概率分布"><a href="#离散型随机变量及其概率分布" class="headerlink" title="离散型随机变量及其概率分布"></a>离散型随机变量及其概率分布</h3><p>离散型随机变量取值范围为<strong>有限可数</strong>或者<strong>无限可数</strong>，或者说取值范围不在实数范围内连续。设离散型随机变量 X 的取值为 $\text{x}_i$ 时的概率为 $p_i(i=1,2…)$，则称 X 的所有取值及其概率为随机变量 X 的概率分布。离散型变量常见的分布有两点分布，二项分布，几何分布，超几何分布，泊松分布。</p><h3 id="连续性随机变量及其概率分布"><a href="#连续性随机变量及其概率分布" class="headerlink" title="连续性随机变量及其概率分布"></a>连续性随机变量及其概率分布</h3><p>如果 X 是在实数域或区间上<strong>取连续值</strong>的随机变量，设 X 的概率分布函数为 $F(x)=P{X\le x}$，若存在非负可积函数 $f(x)$，使得对任意的 x，有 $F(x)=\int _{-∞}^{x}f(t)dt$，则称 X 为连续随机变量，称 $f(x)$ 为 X 的<strong>概率密度函数</strong>。常见的连续性随机变量分布有均匀分布，正态分布，指数分布。</p><p>概率密度函数的几何意义：随机变量的取值落在某个区域之内的概率为概率密度函数在这个区域上的积分。当概率密度函数存在的时候，累积分布函数是概率密度函数的积分，对概率密度函数作傅里叶变换可得特征函数。</p><p>在数学中，连续型随机变量的概率密度函数（在不至于混淆时可以简称为密度函数）是一个描述这个随机变量的输出值，在某个确定的取值点附近的可能性的函数。而随机变量的取值落在某个区域之内的概率则为概率密度函数在这个区域上的积分。当概率密度函数存在的时候，累积分布函数是概率密度函数的积分。</p><h4 id="连续型随机向量及其概率分布"><a href="#连续型随机向量及其概率分布" class="headerlink" title="连续型随机向量及其概率分布"></a>连续型随机向量及其概率分布</h4><p>待更新</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昆明打铁之后，痛定思痛，来重修概率论了。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="数学" scheme="http://example.com/categories/icpc/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="概率论" scheme="http://example.com/categories/icpc/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>codeforces round 782(div2)解析</title>
    <link href="http://example.com/2022/04/18/codeforces%20round%20782(div2)/"/>
    <id>http://example.com/2022/04/18/codeforces%20round%20782(div2)/</id>
    <published>2022-04-17T16:01:00.000Z</published>
    <updated>2022-04-18T06:51:22.776Z</updated>
    
    <content type="html"><![CDATA[<p>还是很开心的，第一次CF打出来D题，嘎嘎上132分，目前1584分，紫名指日可待。</p><span id="more"></span><h2 id="A-Red-Versus-Blue"><a href="#A-Red-Versus-Blue" class="headerlink" title="A.Red Versus Blue"></a>A.Red Versus Blue</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/04/18/codeforces%20round%20782(div2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>知道双方赢球场次，要求构造一个输赢序列使得总比赛中最大连赢场数最小，即给定两种字符及个数，输出一个字符串使得由相同字符构成的子串最短。</p><p>首先题目给定了B的数目严格小于R，那么最优的情况一定是一输一赢，考虑在 b 个 B 中插入R，容易得到总共有 b+1 个可以插入的位置。若 r 可以整除 b+1，则可以得出答案为 r/(b+1)，若否，则得到 r/(b+1)+1。</p><p>我们先在b+1个位置中每个放上 r/(b+1) 个 R，剩下r%(b+1)个R则随便给，只要不要一个位置给两次就可以了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,r,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r&gt;&gt;b;</span><br><span class="line">    <span class="keyword">int</span> k=r/(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res=r%(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">            res--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Bit-Flipping"><a href="#B-Bit-Flipping" class="headerlink" title="B. Bit Flipping"></a>B. Bit Flipping</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/04/18/codeforces%20round%20782(div2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定二进制字符串和k次的操作，要求输出最大字典序的字符串。一次操作会使任意一个位置的字符不变，其它的全部取反。那么容易得到一个结论：对任意一个位置操作偶数次不会该边整体字符串。</p><p>如果k为偶数，则未操作过的数（或者说操作次数为偶数）的数将不变，操作过的数（或者说操作次数为奇数）的数将取反。</p><p>如果k为奇数，则与偶数情况刚好相反。</p><p>我们考虑偶数情况，字符串高位开始，若碰到0则取反变成1，减少一次操作次数并记录在这个位置。若操作到所有序列为全1，则将剩余的操作全部甩给最后一位，使得最后的结果只存在 $111…1$ 和 $111…0$。如果为奇数的话，把0当成1，1当成0即可，我们最后输出的时候把0输出为1，1输出为0，操作按偶数方法操作并且尽量使得字符串结果为0。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> p=k%<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;k)&#123;</span><br><span class="line">                s[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                a[i]=<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;k)&#123;</span><br><span class="line">                s[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                a[i]=<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[n<span class="number">-1</span>]+=k;</span><br><span class="line">    <span class="keyword">if</span>(k%<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            s[n<span class="number">-1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[n<span class="number">-1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p^(s[i]==<span class="string">&#x27;1&#x27;</span>))<span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Line-Empire"><a href="#C-Line-Empire" class="headerlink" title="C. Line Empire"></a>C. Line Empire</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/18/codeforces%20round%20782(div2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定占领的国家的位置和占领花费系数以及迁都花费系数，求最少花费占领所有王国。</p><p>我们可以算迁都产生的花费和产生的收益进行比较，当收益&gt;=花费时我们选择迁都，否则选择直接攻打那些国家。</p><p>不难得到迁都产生的花费为 $b|x_i-pos|$，pos为当前首都的位置，得到的收益为：$a|x_i-pos|*(n-i)$，判断一下模拟就直接过。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;b,&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    x[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//attack</span></span><br><span class="line">        ans+=a*(x[i]-pos);</span><br><span class="line"><span class="comment">//        printf(&quot;attack %d %d %d\n&quot;,i,x[i],a);</span></span><br><span class="line"><span class="comment">//        printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">        <span class="keyword">int</span> cost=(n-i)*a*(x[i]-pos);</span><br><span class="line">        <span class="keyword">if</span>(cost&gt;=b*(x[i]-pos))&#123;</span><br><span class="line">            ans+=b*(x[i]-pos);</span><br><span class="line">            pos=x[i];</span><br><span class="line"><span class="comment">//            printf(&quot;move in pos %d\n&quot;,i);</span></span><br><span class="line"><span class="comment">//            printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Reverse-Sort-Sum"><a href="#D-Reverse-Sort-Sum" class="headerlink" title="D. Reverse Sort Sum"></a>D. Reverse Sort Sum</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/18/codeforces%20round%20782(div2)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你描述了一个序列 A 的值为 $\sum _{i=1}^{n}f(i,A)$，$f(i,A)$ 函数得到的序列就是将序列 A 的前 i 个数排序，数的取值只有0,1。现在给定最终的结果，让你逆向分析初始可能的0,1序列。</p><p>这个我写了个假算法，我自己也无法证明这个算法的正确性，但是他就是过了。。</p><p>首先分析序列后半部分，容易得到，若$a_i&lt;i$，那么 $x_i=0$，否则$x_i=1$，因为后半部分至少有一半的值是来自自己贡献的。拿最后一个举例，如果最后一个值为1或0，那么原序列最后一个值必是0。否则是最后一个值一定是 n，没有其它情况，可以很容易得到的。</p><p>对于前半部分的序列的值确定了第$i$个0的位置，当然后半部分我们都确定好了，如果超出则直接结束循环输出结果。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">        a[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;n/<span class="number">2</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]&lt;i)&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x[i])&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)x[i]+=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[i]==n)<span class="keyword">break</span>;</span><br><span class="line">        a[x[i]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D题可能有点问题，欢迎大家hack。</p><p>总之第一次Div2能做出四题，还是很开心的。</p><p>提交记录：</p><p><img src="/2022/04/18/codeforces%20round%20782(div2)/5.png" alt="5"></p><p><img src="/2022/04/18/codeforces%20round%20782(div2)/6.png" alt="6"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是很开心的，第一次CF打出来D题，嘎嘎上132分，目前1584分，紫名指日可待。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="codeforces" scheme="http://example.com/categories/icpc/codeforces/"/>
    
    <category term="思维" scheme="http://example.com/categories/icpc/codeforces/%E6%80%9D%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA加密原理解析</title>
    <link href="http://example.com/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2022-04-15T00:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.730Z</updated>
    
    <content type="html"><![CDATA[<p>今天来深度解析一下<code>RSA</code>加密</p><span id="more"></span><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>还是最朴素的例子，<code>Alice</code>和<code>Bob</code>要在不安全的路线上发送信息，整条线路完全被窃听者<code>Eve</code>所知，如何让<code>Alice</code>和<code>Bob</code>安全地通信呢？如果这个例子略难懂，那换一个来讲，我要给别人寄个快递，我怎样让别人不知道我寄的是什么，一般情况下，如果没什么特殊情况，快递是不会被随便拆开查看的，但是也很难说，如果我给我实际要送的东西上把锁，那么即使我送的快递被拆开，没有钥匙也不会有人知道我送的是啥，而钥匙只有收件人拥有。</p><p>这就是非对称加密的一个例子了，一个人只有锁，另一个人有钥匙，可以这么说，当把锁关上的那一刻，寄件人都没办法打开去检查他寄的是啥，如果这个锁足够强大的话。</p><h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2><p>rsa主要是利用一系列的数学公式，让推导难以逆向分析，常见的有右移运算或者取模运算，RSA主要是使用取模运算。首先，我选择一个指数(e)，让明文(m)进行这么多次的幂运算，再模上一个数(N)，这也就得到了密文(c)，这个密文难以逆向得到明文，因为取模运算不可逆，这个e和N是公开的，所有人都可以加密，也就是锁，但是钥匙只有自己拥有。</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/1.png" alt="1"></p><p>这里也先给出加密和解密的公式：</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2.png" alt="2"></p><p>在这里d由一个公式算得：d相当于e在模φ(n)意义下的逆元。也就是它们满足这个公式：</p><p>$e\times d \ \ \text{mod}\ \ φ(n)=1$</p><h2 id="RSA加密原理解析"><a href="#RSA加密原理解析" class="headerlink" title="RSA加密原理解析"></a>RSA加密原理解析</h2><p>为什么满足了这个关系就能通过上面的公式解密了呢？</p><p>通过e和d满足的关系我们可以得到这样的式子：</p><p>$e \times d=1+k*φ(n)$</p><p>k为任意整数。</p><p>$d=\frac{1+k*φ(n)}{e}$</p><p>这里还需要一个定理：欧拉定理</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>这个算费马小定理的扩展吧，费马小定理的表达式如下：</p><p>对于任意整数a和任意质数p有以下式子成立：</p><p>$a^p$与$a$在$\ \text{mod}\ p$ 意义下同余，即$a^{p-1}\ \text{mod}\ p=1$</p><p>而对于任意质数，它的欧拉函数就是自己-1，欧拉函数的描述为</p><blockquote><p>欧拉函数 是小于或等于n的正整数中与n互质的数的数目</p></blockquote><p>而对于非质数，它一定可以写成若干个质数相乘，即</p><p>$n=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times……\times p_n^{a_n}$</p><p>$a_i$为任意整数，$p_i$为任意质数，就是说，任何一个大于2的整数一定会有上式成立。</p><p>它的欧拉函数则是</p><p>$φ(n)=(p_1-1)p_1^{a_1-1}\times(p_2-1)p_2^{a_2-1}\times(p_3-1)p_3^{a_3-1}\times……\times(p_n-1)p_n^{a_n-1}$</p><p>那么欧拉定理的表达式是什么呢，那就是下面这个式子：</p><p>任意正整数a和p，有以下式子成立</p><p>$a^{φ(p)}\ \text{mod}\ p=1$</p><p>有了这个式子之后我们再代入上面那个式子，可以得到</p><p>$m^{e\times d}\ \text{mod}\  n=m^{1+kφ(n)}\ \text{mod}\ n$</p><p>这里需要用到一些简单的同余定理：</p><p>$a\times b\ \text{mod}\ n=((a\ \text{mod}\ n)\times (b\ \text{mod}\ n))\ \text{mod}\ n$</p><p>那么$m^{1+kφ(n)}\ \text{mod}\ n=m*(m^{φ(n)}\ \text{mod}\ n)^k\ \text{mod}\ n$</p><p>而括号里的表达式恒为1，最后结果就变成了$m$</p><p>可以发现，如果m不大于n，那么m的值应当是唯一的，而加密出现的中间产物$c$若没有$d$则永远无法推到得到$m$，这也就是<code>RSA</code>算法的核心了。</p><h2 id="RSA密钥生成"><a href="#RSA密钥生成" class="headerlink" title="RSA密钥生成"></a>RSA密钥生成</h2><p>讲完了原理之后我们来讲讲怎么生成RSA密钥，首先选取两个很大的质数p,q，这里得到n=p*q，那么容易得到n的欧拉函数$φ(n)=(p-1)\times (q-1)$</p><p>再任意选取一个质数e作为加密质数，也很容易算出解密指数$d=\text{inverse}(e,φ(n))$ ，inverse为求模逆元的函数。</p><p>$(e,n)$就是公钥，$(d,n)$就是私钥，这样我们的密钥就生成完毕了。</p><h2 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h2><p>这里用到一个<code>Crypto</code>库，安装方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><p>demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p=getPrime(<span class="number">512</span>)</span><br><span class="line">q=getPrime(<span class="number">512</span>)</span><br><span class="line">n=p*q</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">m=<span class="number">123456</span></span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">dec=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(dec)</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/3.png" alt="3"></p><p>你也可以多取几个其它的数试试看，看看能不能得到一样的结果，因为质数随机生成，print(c)这一步不能保证一模一样，但是dec的值一定是和你输入的m一样的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来深度解析一下&lt;code&gt;RSA&lt;/code&gt;加密&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="crypto" scheme="http://example.com/categories/ctf/crypto/"/>
    
    
  </entry>
  
  <entry>
    <title>SA板子</title>
    <link href="http://example.com/2022/04/02/SA%E6%9D%BF%E5%AD%90/"/>
    <id>http://example.com/2022/04/02/SA%E6%9D%BF%E5%AD%90/</id>
    <published>2022-04-02T14:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.735Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客只有板子。</p><span id="more"></span><p>sa[i]：排名为i的后缀的下标</p><p>rak[i]：后缀suff[i]的排名</p><p>Height[i]：后缀按照字典排序之后，该后缀与上一个后缀的最长公共前缀，也就是排名为i的后缀字符串和排名为i-1的后缀字符串的最长公共前缀。</p><h2 id="DA算法-O-nlogn"><a href="#DA算法-O-nlogn" class="headerlink" title="DA算法(O(nlogn))"></a>DA算法(O(nlogn))</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],wss[N],rak[N],height[N],cal[N],n,sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[x[i]=r[i]]++;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">     <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[x[i]]]=i;</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,M=p) &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rak[sa[i]]=i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rak[i++]]=k)</span><br><span class="line">     <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rak[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)rak[i]=rak[i<span class="number">-1</span>],sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cas=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>))&#123;</span><br><span class="line">        n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            cal[i]=s[i];</span><br><span class="line">        cal[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">da</span>(cal+<span class="number">1</span>,sa,n+<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(cal+<span class="number">1</span>,sa,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,height[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rak[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans+=rak[i]-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DC3算法-O-n"><a href="#DC3算法-O-n" class="headerlink" title="DC3算法(O(n))"></a>DC3算法(O(n))</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3</span>*(<span class="number">1e5</span>+<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> wa[N], wb[N], ws[N], wv[N], sa[N];</span><br><span class="line"><span class="keyword">int</span> rak[N], height[N], cal[N],n;</span><br><span class="line"><span class="keyword">char</span> s[N],ans[N],s1[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c0</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a + <span class="number">1</span>] == r[b + <span class="number">1</span>] &amp;&amp; r[a + <span class="number">2</span>] == r[b + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c12</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> *r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; <span class="built_in">c12</span>(<span class="number">1</span>, r, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; wv[a + <span class="number">1</span>] &lt; wv[b + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rsort</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) wv[i] = r[a[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) ws[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ws[wv[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) ws[i] += ws[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) b[--ws[wv[i]]] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dc3</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, *rn = r + n, *san = sa + n, ta = <span class="number">0</span>, tb = (n + <span class="number">1</span>) / <span class="number">3</span>, tbc = <span class="number">0</span>, p;</span><br><span class="line">    r[n] = r[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) wa[tbc++] = i;</span><br><span class="line">    <span class="built_in">Rsort</span>(r + <span class="number">2</span>, wa, wb, tbc, m);</span><br><span class="line">    <span class="built_in">Rsort</span>(r + <span class="number">1</span>, wb, wa, tbc, m);</span><br><span class="line">    <span class="built_in">Rsort</span>(r, wa, wb, tbc, m);</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">1</span>, rn[<span class="built_in">F</span>(wb[<span class="number">0</span>])] = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; tbc; i++)</span><br><span class="line">        rn[<span class="built_in">F</span>(wb[i])] = <span class="built_in">c0</span>(r, wb[i - <span class="number">1</span>], wb[i]) ? p - <span class="number">1</span> : p++;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; tbc) <span class="built_in">dc3</span>(rn, san, tbc, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) san[rn[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) <span class="keyword">if</span> (san[i] &lt; tb) wb[ta++] = san[i] * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) wb[ta++] = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Rsort</span>(r, wb, wa, ta, m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) wv[wb[i] = <span class="built_in">G</span>(san[i])] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; ta &amp;&amp; j &lt; tbc; p++)</span><br><span class="line">        sa[p] = <span class="built_in">c12</span>(wb[j] % <span class="number">3</span>, r, wa[i], wb[j]) ? wa[i++] : wb[j++];</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ta; p++) sa[p] = wa[i++];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; tbc; p++) sa[p] = wb[j++];</span><br><span class="line">    <span class="comment">//for(int i=n;i;i--) rak[i]=rak[i-1];</span></span><br><span class="line">    <span class="comment">//for(int i=n;i;i--) sa[i]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) rak[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; height[rak[i++]] = k)</span><br><span class="line">        <span class="keyword">for</span> (k ? k-- : <span class="number">0</span>, j = sa[rak[i] - <span class="number">1</span>]; r[i + k] == r[j + k]; k++);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) rak[i]=rak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>)&amp;&amp;s[<span class="number">1</span>] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cal[i] = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        cal[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dc3</span>(cal+<span class="number">1</span>, sa, n + <span class="number">1</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(cal+<span class="number">1</span>, sa, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,height[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客只有板子。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="字符串" scheme="http://example.com/categories/icpc/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="SA" scheme="http://example.com/categories/icpc/%E5%AD%97%E7%AC%A6%E4%B8%B2/SA/"/>
    
    
  </entry>
  
  <entry>
    <title>主席树的学习</title>
    <link href="http://example.com/2022/04/02/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>http://example.com/2022/04/02/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2022-04-02T06:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.813Z</updated>
    
    <content type="html"><![CDATA[<p>主席树应用之一：区间第k大，中间还有用到vector离散化</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">    <span class="comment">//l为一个离散化变量的左边界，r为右边界，都是对于值域而言的，sum存储数值在[l,r]区间内的数的个数 </span></span><br><span class="line">&#125;node;</span><br><span class="line">node tree[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x)-v.<span class="built_in">begin</span>()+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,po=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)&amp;&amp;ch!=<span class="string">&#x27;-&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) po=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a=a*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a*po; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],root[maxn],cnt;<span class="comment">//n,m如题意所示，a为原数组，cnt为已分配节点数量 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pre,<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[++cnt]=tree[pre];</span><br><span class="line">    now=cnt;</span><br><span class="line">    tree[now].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=m)<span class="built_in">insert</span>(l,m,tree[pre].l,tree[now].l,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(m+<span class="number">1</span>,r,tree[pre].r,tree[now].r,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=tree[tree[end].l].sum-tree[tree[start].l].sum;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=tmp)<span class="keyword">return</span> <span class="built_in">query</span>(l,m,tree[start].l,tree[end].l,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(m+<span class="number">1</span>,r,tree[start].r,tree[end].r,k-tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(a[i]=<span class="built_in">read</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="number">1</span>,v.<span class="built_in">size</span>(),root[i<span class="number">-1</span>],root[i],<span class="built_in">getid</span>(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r,k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">        cout&lt;&lt;v[<span class="built_in">query</span>(<span class="number">1</span>,v.<span class="built_in">size</span>(),root[l<span class="number">-1</span>],root[r],k)<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;主席树应用之一：区间第k大，中间还有用到vector离散化&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="数据结构" scheme="http://example.com/categories/icpc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="主席树" scheme="http://example.com/categories/icpc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>AC自动机的学习</title>
    <link href="http://example.com/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-02T05:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.707Z</updated>
    
    <content type="html"><![CDATA[<p>洛谷的板子</p><span id="more"></span><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> b[maxn];</span><br><span class="line">string word,s;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    A *fail;</span><br><span class="line">    A *next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> word;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fail=<span class="literal">NULL</span>; </span><br><span class="line">        word=<span class="number">0</span>;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node;</span><br><span class="line">node *root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_word</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=word.<span class="built_in">length</span>();</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[k]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node *temp;</span><br><span class="line">            temp=<span class="keyword">new</span> node;</span><br><span class="line">            temp-&gt;<span class="built_in">a</span>();</span><br><span class="line">            p-&gt;next[k]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next[k];    </span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;word=j;</span><br><span class="line">    p-&gt;num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;node *&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                node *t=p-&gt;next[i];</span><br><span class="line">                <span class="keyword">if</span>(p==root)&#123;</span><br><span class="line">                    t-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    node *fafail=p-&gt;fail;</span><br><span class="line">                    <span class="keyword">while</span>(fafail!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(fafail-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                            t-&gt;fail=fafail-&gt;next[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fafail=fafail-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(fafail==<span class="literal">NULL</span>)t-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=root&amp;&amp;p-&gt;next[k]==<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;fail;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            p=root;</span><br><span class="line">        node *temp=p;</span><br><span class="line">        <span class="comment">//while(temp!=root)&#123;</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;word&amp;&amp;!b[temp-&gt;word])&#123;</span><br><span class="line">                b[temp-&gt;word]=<span class="number">1</span>;</span><br><span class="line">                ans+=temp-&gt;num;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//    temp=temp-&gt;fail;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int c[10001];</span></span><br><span class="line"><span class="comment">int all=0;</span></span><br><span class="line"><span class="comment">void print()&#123;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=all;i++)&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%c&quot;,b[i]+&#x27;a&#x27;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void dfs(node *t)&#123;</span></span><br><span class="line"><span class="comment">    if(t-&gt;word)print();</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;26;i++)&#123;</span></span><br><span class="line"><span class="comment">        if(t-&gt;next[i]!=NULL)&#123;</span></span><br><span class="line"><span class="comment">            c[++all]=i;</span></span><br><span class="line"><span class="comment">            dfs(t-&gt;next[i]);</span></span><br><span class="line"><span class="comment">            all--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3808.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;P3808.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    root=<span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;<span class="built_in">a</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;word;</span><br><span class="line">        <span class="built_in">insert_word</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dfs(root);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fail</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">query</span>();</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="2"></p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> word;</span><br><span class="line">    A* fail;</span><br><span class="line">    A* next[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aaa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        word=<span class="number">0</span>;</span><br><span class="line">        fail=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node;</span><br><span class="line">node *root;</span><br><span class="line">queue&lt;node*&gt;q;</span><br><span class="line">map&lt;string,<span class="keyword">int</span>&gt;tmap;</span><br><span class="line">string word[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">int</span> len=word[x].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=word[x][i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[k]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node *new_node=<span class="keyword">new</span> node;</span><br><span class="line">            new_node-&gt;<span class="built_in">aaa</span>();</span><br><span class="line">            p-&gt;next[k]=new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;word=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                node *k=p-&gt;next[i];</span><br><span class="line">                q.<span class="built_in">push</span>(k);</span><br><span class="line">                <span class="keyword">if</span>(p==root)&#123;</span><br><span class="line">                    k-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    node *fafail=p-&gt;fail;</span><br><span class="line">                    <span class="keyword">while</span>(fafail!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(fafail-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                            k-&gt;fail=fafail-&gt;next[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fafail=fafail-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(fafail==<span class="literal">NULL</span>)k-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(t);</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=t[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next[k]==<span class="literal">NULL</span>&amp;&amp;p!=root)p=p-&gt;fail;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)p=root;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node *temp=p;</span><br><span class="line">            <span class="keyword">while</span>(temp!=root)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;word)&#123;</span><br><span class="line">                    num[temp-&gt;word]++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[tmap[a]]==num[tmap[b]])<span class="keyword">return</span> tmap[a]&lt;tmap[b];</span><br><span class="line">    <span class="keyword">return</span> num[tmap[a]]&gt;num[tmap[b]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">        tmap.<span class="built_in">clear</span>();</span><br><span class="line">        root=<span class="keyword">new</span> node;</span><br><span class="line">        root-&gt;<span class="built_in">aaa</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;word[i];</span><br><span class="line">            tmap[word[i]]=i;</span><br><span class="line">            <span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build_fail</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t);</span><br><span class="line">        <span class="built_in">query</span>();</span><br><span class="line">        <span class="built_in">sort</span>(word+<span class="number">1</span>,word+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="built_in">sort</span>(num+<span class="number">1</span>,num+<span class="number">1</span>+n,cmp1);</span><br><span class="line">        <span class="keyword">int</span> maxnum=num[<span class="number">1</span>];</span><br><span class="line">        cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==maxnum)&#123;</span><br><span class="line">                cout&lt;&lt;word[i]&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> word;<span class="keyword">int</span> deg,val;</span><br><span class="line">    node *fail , *next[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">node</span>() &#123;</span><br><span class="line">        word = deg = val = <span class="number">0</span>;fail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*ext=(node*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(node)*maxn),*root;</span><br><span class="line"></span><br><span class="line">queue&lt;node*&gt; Q;</span><br><span class="line"><span class="keyword">char</span> t[maxn], word[maxn];<span class="keyword">int</span> num[maxn],ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> node* <span class="title">Ot</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *ext=<span class="built_in">node</span>(),ext++;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = root;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[k] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next[k] = <span class="built_in">Ot</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;word) &#123;</span><br><span class="line">        p-&gt;word = x;</span><br><span class="line">    &#125;</span><br><span class="line">    num[x] = p-&gt;word;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(root-&gt;next[i]) root-&gt;next[i]-&gt;fail=root,Q.<span class="built_in">push</span>(root-&gt;next[i]); <span class="keyword">else</span> root-&gt;next[i]=root;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node* p = Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// printf(&quot;%ld\n&quot;,p-root);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next[i]) &#123;</span><br><span class="line">                p-&gt;next[i]-&gt;fail = p-&gt;fail-&gt;next[i],p-&gt;fail-&gt;next[i]-&gt;deg++;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;next[i]!=root) Q.<span class="built_in">push</span>(p-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next[i] = p-&gt;fail-&gt;next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="comment">// printf(&quot;len:%d\n&quot;,len);</span></span><br><span class="line">    node* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;i:%d p:%ld np:%ld\n&quot;,i,p-root,p-&gt;next[t[i]-&#x27;a&#x27;]);</span></span><br><span class="line">        <span class="keyword">int</span> k = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p=p-&gt;next[k];p-&gt;val++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;OUT&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(node *i=root;i&lt;ext;i++) <span class="keyword">if</span>(!i-&gt;deg) Q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();ans[p-&gt;word]=p-&gt;val;</span><br><span class="line">        <span class="comment">// printf(&quot;p:%ld\n&quot;,p-root);</span></span><br><span class="line">        <span class="keyword">if</span>(p!=root)&#123;</span><br><span class="line">            p-&gt;fail-&gt;val += p-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(--p-&gt;fail-&gt;deg==<span class="number">0</span>) Q.<span class="built_in">push</span>(p-&gt;fail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);root=<span class="built_in">Ot</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, word);</span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t);</span><br><span class="line">    <span class="built_in">query</span>();<span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cout&lt;&lt;ans[num[i]]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;洛谷的板子&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="字符串" scheme="http://example.com/categories/icpc/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="AC自动机" scheme="http://example.com/categories/icpc/%E5%AD%97%E7%AC%A6%E4%B8%B2/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>最小费用最大流应用</title>
    <link href="http://example.com/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/</id>
    <published>2022-04-02T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.839Z</updated>
    
    <content type="html"><![CDATA[<p>一道小思维题</p><span id="more"></span><p>题目描述</p><p><img src="/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/1.png" alt="1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 6000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    </span><br><span class="line">&#125;e[maxn*<span class="number">3000</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt=<span class="number">1</span>,dep[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,q,x,y;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;        </span><br><span class="line">    ch = <span class="built_in">getchar</span>();               </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;  </span><br><span class="line">    x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    ch = <span class="built_in">getchar</span>();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x * w; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> w=e[i].w,v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!w||dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">2</span>*n+<span class="number">1</span>)<span class="keyword">return</span> in;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(dep[v]&gt;dep[u]&amp;&amp;w)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">Dinic</span>(v,<span class="built_in">min</span>(in,w));</span><br><span class="line">            e[i].w-=res;</span><br><span class="line">            e[i^<span class="number">1</span>].w+=res;</span><br><span class="line">            in-=res;</span><br><span class="line">            ans+=res;</span><br><span class="line">            <span class="keyword">if</span>(!in)<span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)dep[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    m=<span class="built_in">rd</span>();</span><br><span class="line">    q=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,x,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">add</span>(i,i+n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i+n,i,<span class="number">0</span>);</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">while</span>(x--)&#123;</span><br><span class="line">            y=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">add</span>(i+n,y,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(y,i+n,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">add</span>(x+n,<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">2</span>*n+<span class="number">1</span>,x+n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans+=<span class="built_in">Dinic</span>(<span class="number">0</span>,<span class="number">0x7fffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道小思维题&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最小费用最大流" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
    
  </entry>
  
  <entry>
    <title>关于钉钉保存回放的方式</title>
    <link href="http://example.com/2022/03/20/Dingtalk/"/>
    <id>http://example.com/2022/03/20/Dingtalk/</id>
    <published>2022-03-20T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.716Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要下载钉钉的录屏回放，但是管理员禁止了下载，找到了众多的方法都不得行，后面自己开辟了一个方法（我也不敢确定是不是没有人用这个方法，反正这个方法不是通过搜索得到的。。</p><span id="more"></span><p>先说说我通过搜索资源得到了些什么方法吧，其实大多数就指向一种方法——通过fd抓包找到m3u8的下载地址，然而我在用fd抓包的时候并没有找到m3u8的下载地址，也有说用旧版本的钉钉的，但是我发现根本扫不上去，于是我仔细观察fd得到的包，发现播放视频的时候大部分出现了 .TS文件格式的url请求。</p><p><img src="/2022/03/20/Dingtalk/1.png" alt="1"></p><p>可以看到每过一会就会请求一个对应的 <code>ts</code> 文件，我也去搜了一下 <code>ts</code> 文件的含义，差不多就是视频的切片。因此如果我能得到所有的ts的下载地址，那么我就相当于得到了这个视频。</p><p>但是在请求这个 <code>ts</code> 文件的时候必须加上一个 <code>auth_key</code> 参数，然后这个参数貌似也是个随机的散列值，目前信息有限没办法计算出这个散列值的排布规律，但是我能得到一个最朴素的做法：暴力得到所有的 <code>ts</code> 的url，然后一个一个下载，最后用 <code>ffmpeg</code> 去合并就好了。</p><p>然而这里我们并不需要看完所有的视频，我们可以快进，我理解的原理是这样的：假如把你的视频切成 20S一片，在你需要的时候请求，然而假如我不看完，直接跳过这个请求，那么它马上就会请求下一个视频的地址，然后此时被我们捕获到了，之后循环往复我们就能快速地得到所有的请求url，这里的话仅复制url可以快速把url全部复制过来。</p><p>这里我选择按键模拟器去点击这个右键播放，然后间隔频率设置成0.2S，每看1S跳过50S，相当于快进50倍，一个50min的视频我们在1min就能整完，这个效率还是不错的，如果发现ts有丢失那么你可以定位到那个地方重新观察一下请求，然后url复制过来。</p><p><img src="/2022/03/20/Dingtalk/2.png" alt="2"></p><p>我本来想这么多url用爬虫读取url一个个爬然后保存的，结果不知道为啥报错了，于是我选择最蠢的办法：cmd命令。</p><p>在所有url前加上start，然后后缀改一下bat，为了防止电脑卡顿，在每一个start前加上一个暂停的命令，然后我们得到了一个这样的文件：</p><p><img src="/2022/03/20/Dingtalk/3.png" alt="3"></p><p>最后就是枯燥的请求了，这个等着吧，如果你觉得电脑hold的住那么你可以不加暂停的，它会周期弹网页出来，情况就是这样子的：</p><p><img src="/2022/03/20/Dingtalk/4.png" alt="4"></p><p>我还发现一个问题，就是它有时候这个回放并不是严格的就是正整数递增的，中间我有遇到过那种 <code>10000001.ts</code> 的文件，就是突然这样的，也不知道为啥，所以最后写合并指令的时候也比较难，但是难处千千万，靠自己还是能解决的。选择直接在里面放一个python脚本自动合并，合并的命令是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i &quot;concat:文件1|文件2|文件3|……|文件n&quot; -c copy output.mp4</span><br></pre></td></tr></table></figure><p>里面主要的就是要扫一下目录获取所有的文件名并让他们按一定顺序排列，这个我也直接放一下吧，也挺简单的，没什么需要解释的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">f=os.listdir(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">num=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">if</span> i[-<span class="number">2</span>:]!=<span class="string">&#x27;ts&#x27;</span>:<span class="keyword">continue</span></span><br><span class="line">    num.append(<span class="built_in">int</span>(i[:-<span class="number">3</span>]))</span><br><span class="line">num.sort()</span><br><span class="line">fi=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> num:</span><br><span class="line">    fi+=<span class="built_in">str</span>(q)+<span class="string">&#x27;.ts|&#x27;</span></span><br><span class="line">cmd=<span class="string">&#x27;ffmpeg -i &quot;concat:&#x27;</span>+fi[:-<span class="number">1</span>]+<span class="string">&#x27;&quot; -c copy output.mp4&#x27;</span></span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure><p>如果不放心可以先print一下看看得到的cmd是什么样的，下面给出我的目录图和运行图：</p><p><img src="/2022/03/20/Dingtalk/5.png" alt="5"></p><p>最后就是运行一遍那个命令了，看看有没有得到你们心心念念的视频吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要下载钉钉的录屏回放，但是管理员禁止了下载，找到了众多的方法都不得行，后面自己开辟了一个方法（我也不敢确定是不是没有人用这个方法，反正这个方法不是通过搜索得到的。。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CF1626C</title>
    <link href="http://example.com/2022/03/19/CF1626C/"/>
    <id>http://example.com/2022/03/19/CF1626C/</id>
    <published>2022-03-19T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.711Z</updated>
    
    <content type="html"><![CDATA[<p>一道思维好题，写篇题解纪念一下。</p><span id="more"></span><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有 $n$ 个敌人，你需要在第 $k_i$ 秒用至少 $h_i$ 的攻击力打败这个敌人。</p><p>攻击力的计算方式如下：</p><ol><li> 第一秒时，你有 $1$ 攻击力</li><li> 对于后面的任意一秒，若前一秒你的攻击力为 $x$，则这一秒你的攻击力可以为 $x+1$ 或 $1$</li></ol><p>一秒内，如果你的攻击力为 $x$，则你就需要消耗 $x$ 的能量。</p><p>请问，在你打败所有敌人的情况下，最少需要消耗多少能量。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>在一秒内，你可以继承之前的攻击力，但是继承攻击力的代价就是你要花费相当于继承之后攻击力的法力值来保存你的攻击力。只有当前攻击力大于当前出现的怪物的血量的时候，你才能杀死他。在任意一秒，你可以选择摆烂，但是摆烂的代价就是会丢失上一秒的攻击力，使你在下一秒的时候无法有之前那么高的攻击，摆烂可以选择从 $0$ 开始或者从 $1$ 开始。显然可以发现，当 $k_i\ge h_i$ 的时候，主角总是有办法杀死所有的怪物的。 </p><p>在杀死所有的怪物的怪物下要保证消耗的法力值最少，那就需要我们合理分配增加攻击的时间了。我们不难得出以下结论：</p><p>如果在第 $k_i$ 秒遇到了血量为 $h_i$ 的怪物，那么在 $(k_i-h_i,k_i]$ 的时间区间内，我不能出现摆烂的情况，即攻击力不能掉，在 $k_i-h_i$ 的时刻，攻击力不能减为 $0$。</p><p>那么第 $i$ 个怪物需要我花费的最少法力值就是从 $1$ 到 $h_i$ 的等差数列，假设我打完怪物之后我都能立刻摆烂，那么不难得出总法力消耗就是 $\sum _{i=1}^{n} \sum _{j=1}^{h_i} j$ 。但是并不是每一次打完怪物我都能摆烂，如果我摆烂到 $0$，剩下的时间不足以我积攒足够的攻击去击杀接下来的怪物那就不能摆烂而是接着蓄力。</p><p>对于每一个怪物我们都构造一个区间，区间范围为 $[k_i-h_i+1,k_i]$ ，当区间出现相交，则合并两个区间，最后根据区间长度计算法力值即可。</p><p>对于每一个区间我观察我的左端点是否会落在上一个区间内，如果在，则需要合并前面的区间，因为我们默认按照 $k_i$ 排序了，也就是按照区间右端点值排序，所以我可以用 $\text{lower_bound}$ 来寻找合并的区间。因为如果最后一个怪物它要求我从第一秒开始蓄力的话，那么前面的所有区间我都要合并，所以这里必须考虑合并的区间。对于合并的区间我们修改 $l$ 为其中最小值，$r$ 为其中最大值。然后在计算区间的时候特判一下连续的区间是否相等，达到只计算一次的目的即可。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> h[maxn],k[maxn],l[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(l));</span><br><span class="line">    <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(l));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;k[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;h[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        l[i]=k[i]-h[i]+<span class="number">1</span>;</span><br><span class="line">        r[i]=k[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]&lt;=r[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">int</span> p=<span class="built_in">lower_bound</span>(r+<span class="number">1</span>,r+<span class="number">1</span>+i,l[i])-r;</span><br><span class="line">            <span class="comment">//if(p==0)p++;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;=i;j++)&#123;</span><br><span class="line">                l[j]=<span class="built_in">min</span>(l[p],l[i]);</span><br><span class="line">                r[j]=r[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]==l[i<span class="number">-1</span>]&amp;&amp;r[i]==r[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> num=r[i]-l[i]+<span class="number">1</span>;</span><br><span class="line">        ans+=<span class="number">1ll</span>*(num+<span class="number">1</span>)*num/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l[i]-r[i<span class="number">-1</span>]&gt;<span class="number">1</span>&amp;&amp;l[i<span class="number">-1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            ;<span class="comment">//ans+=l[i]-r[i-1]-1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道思维好题，写篇题解纪念一下。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="思维" scheme="http://example.com/categories/icpc/%E6%80%9D%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>Kruskal 重构树的学习笔记</title>
    <link href="http://example.com/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    <id>http://example.com/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/</id>
    <published>2022-03-08T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.720Z</updated>
    
    <content type="html"><![CDATA[<p>比赛遇到了新鲜的图论题，特此记录。</p><span id="more"></span><h2 id="什么是Kruskal重构树？"><a href="#什么是Kruskal重构树？" class="headerlink" title="什么是Kruskal重构树？"></a>什么是Kruskal重构树？</h2><p> $\text{Kruskal}$ 重构树，和 $\text{Kruskal}$ 算法的思想差不多，就是在这个过程中建出一个有着非常优秀的性质的数据结构，这是一个非常少见和小众的算法，但是如果碰到了合适的题目，就会体现出其优越性。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>既然它叫 $\text{Kruskal}$ 重构树，那么它必然与 $\text{Kruskal}$ 有着密不可分的联系。首先我们回顾一下 $\text{Kruskal}$ 最小生成树是怎么实现的，先将所有边按照权值排序，然后再从小到大添加边，如果添加边的两个顶点都在生成树当中则跳过这条边，直到添加过n-1次算法结束。</p><p>我们在添加边的时候构造一棵这样的树：当边e被添加时，e的两顶点一定在不同的生成树内，因此将两个顶点所在的树用一个点连接起来，点的权值为这条边的权值，这个点的权值表示了什么呢？就是这两个子树上，其中一个子树所有的顶点到另一个子树的所有顶点中经过的边的最大值的最小值为这条边的边权。</p><p>首先先解释一下什么叫<strong>最大值的最小值</strong>，这句话可能有点抽象，那我具体举一个例子。我一个节点从 $u\to v$ 有可能经过多条边，这里面的最大值是我要计算的，而可能不止这一种走法，我现在希望这个最大值最小，这就是所谓的最大值的最小值啦。最大值指的是一条路径的最大值，最小值指的是所有路径中的这个值最小。</p><p>其次，很容易证明我们得到的树是一颗二叉树，因为对于n个点，每次我都是添加根节点连接两个子树或者节点，也很容易证明叶节点都为原图中的节点，因为我们只为这些节点不停地添加父亲而没有给他们儿子，自然就是叶子节点啦。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>exp(指example</p><p>举个例子，下面这个图。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/1.png" alt="1"></p><p>第一步，我们先选择1和2，发现不在同一集合，选择添加，我们新建一个节点来作为它们的父亲，它的点的权值为1，这里我换个颜色避免引起歧义，这里的1表示值而不是编号。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/2.png" alt="2"></p><p>重复第一步，找到2，然后。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/3.png" alt="3"></p><p>然后找到权值为3的点，发现1，3同属于一个树，跳过。再找到4，添加，得到下面这张图。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/4.png" alt="4"></p><p>我们来看看符不符合我们上面总结的那个结论。</p><p>1和2我们走过的最短路径显然就是1；1到3我们需要走过路径最大值的最小值是2，虽然我能一步到达，但是先走2，再走3我们的路径长度为 $\to 1\to 2 \to$ 显然这样走过的最长的路的最小值就是2了，可以发现1和3由根节点权值为2的点连接，也没问题，同理其它任何四个点两两之间都符合这个规律。</p><p>在实现上面我们可以通过LCA来快速查询两个点之间的最大路径的最小值，因为也可以发现两个点之间的LCA的权值就是我想要的答案，这一部分可以倍增预处理然后打到一次 $log_2n$ 的复杂度。</p><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><p>这应该是我们最应该关心的问题了，学了一个数据结构应该想办法加以利用。来看一道经典例题：</p><hr><p>给出n个点，m条边构成的无向图，要求指定两点，算出它们之间的最短路径值。</p><p>这题很容易知道可以使用单源最短路算法，但是我们也会想到动态规划。因为我到了一个点之后，我不需要关心这个点是怎么到的，这个叫无后效性，即前面的决策不影响后面的答案。</p><p>那我们对此题稍微改一下：要求求出所有我经过路径最大值的最小值是多少？</p><p>这题显然，也是无后效性我们只需要一步步往前推然后保存最大值即可。但是问题来了，如果我再加上多个询问呢？那么此时算法的时间复杂度将加上n倍，一次处理相当于进行一次的 $\text{dijkstra}$，$O(nlog_2n)$的复杂度，妥妥的超时。如果我们选择 $\text{Kruskal}$ 重构树预处理，再加上加上LCA，把一次询问的复杂度降低到 $O(log_2n)$ ，那么最终得到的算法复杂度就会低很多了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>直接拿上ICPC2021上海站的I题——<a href="https://ac.nowcoder.com/acm/contest/29789/H">Life is a game</a></p><hr><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Life is a game.</p><p> The world can be regarded as an undirected connected graph of $n$ cities and mmm undirected roads between the cities. Now you, the life game player, are going to play the life game on the world graph.</p><p> Initially, you are at the $x$-th city and of $k$ social ability points. You can earn social ability points by living and working. Specifically, you can earn $a_i$ social ability points by living and working in the $i$-th city. But in this problem, you cannot earn social ability points duplicatedly in one city, so you want to travel the world and earn more social ability points. However, the roads are not easy. Specifically, there is an ability threshold $i$_iwi​ for the $i$-th road, you should be of at least $w_i$ social ability points to go through the road. Moreover, Your social ability point will not decrease when passing roads but just need to be at least $w_i$​ if you want to go through the $i$-th road.</p><p> So as you can see, the life game is just living, working and traveling repeatedly. There are $q$ game saves. For each game save, the initial city and social ability point is given and the player has not lived or worked in any city. Now you, the real life game player, need to determine the maximum possible number of social ability points you can have in the end of the game and output it for each given game save.</p><p>这里来解释一下这个题意。</p><p>就是说有一个 $n$ 点 $m$ 边的无向带权图，每个点上有权值。当你经过一个点，你能获得一定能力值，每个地方的能力值只能获得一次，只有能力值不小于边权我才能通过这条边到达另一个点。给定起点和初始能力值，问你最后最多有多少能力值。</p><p>所以，我们能不能到达另一个点取决于整条路经的最大值是否大于我的能力值，若大于则我不能通过这条路到达该点，如果该最大值最小，则以我目前能力值无法到达该点。</p><p>我们就使用 $\text{Kruskal}$ 构造树，寻找它的祖先节点，可以证明，它祖先节点一定不是叶节点，所以如果我的能力值大于该祖先节点的值，那么我可以任意访问以这个祖先节点为根节点的任意节点，能力值可以直接加上这么多，然后再去寻找祖先节点，直到连它的父亲都无法到达或者是当前节点已经是根节点了，那就结束，那么我最终获得的能力值就是当前节点为根节点的子树的所有能力值之和加上初始值。</p><p>以某某节点为根节点的子树能力值之和可以通过 dfs 在 $O(E)$ 的复杂度得出，排序+ $\text{Kruskal}$ 构造树 $O(E)+O(Elog_2E)$ 的复杂度。寻找根节点可以用预处理倍增查询的方式去得到。这样最终我们每次查询的复杂度就是 $O(log_2n)$ 的复杂度。在本题我们可以认为它都是 $n$ ，因为它们的最大值都是一样的，这样的复杂度最终能被接受。</p><p>这里给出我写的程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">//int不够直接int改long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cin&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> eee &amp;a)&#123;<span class="comment">//重载小于号便于排序</span></span><br><span class="line">        <span class="keyword">return</span> w&lt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> v[maxn&lt;&lt;<span class="number">1</span>],root[maxn&lt;&lt;<span class="number">1</span>],fa[maxn&lt;&lt;<span class="number">1</span>],value[maxn&lt;&lt;<span class="number">1</span>],a[maxn&lt;&lt;<span class="number">1</span>],dep[maxn&lt;&lt;<span class="number">1</span>],n,m,q,cnt;</span><br><span class="line"><span class="keyword">int</span> lca[maxn&lt;&lt;<span class="number">1</span>][<span class="number">30</span>];<span class="comment">//这里忘开两倍内存导致2小时的TLE RE WA各种的问题。</span></span><br><span class="line"><span class="comment">//v表示节点权值，value表示子树a和，a表示该点的能量 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++)fa[i]=i;<span class="comment">//初始化集合</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> from=e[i].from,to=e[i].to;</span><br><span class="line">        from=<span class="built_in">find</span>(from),to=<span class="built_in">find</span>(to);<span class="comment">//寻找并查集</span></span><br><span class="line">        <span class="keyword">if</span>(from==to)<span class="keyword">continue</span>;</span><br><span class="line">        v[++j+n]=e[i].w;<span class="comment">//新建一个点，点权为该边边权，并连接这两个点</span></span><br><span class="line">        <span class="built_in">add</span>(from,j+n);<span class="comment">//添加两个边。</span></span><br><span class="line">        <span class="built_in">add</span>(j+n,from);</span><br><span class="line">        <span class="built_in">add</span>(to,j+n);</span><br><span class="line">        <span class="built_in">add</span>(j+n,to);</span><br><span class="line">        fa[from]=fa[j+n];<span class="comment">//让这两个点的父亲都指向这个节点，这其实相当于一个集合的合并。</span></span><br><span class="line">        fa[to]=fa[j+n];</span><br><span class="line">        <span class="keyword">if</span>(j==n<span class="number">-1</span>)<span class="keyword">break</span>;<span class="comment">//寻找到n-1条边之后则直接退出</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=a[now];</span><br><span class="line">    fa[now]=father;</span><br><span class="line">    lca[now][<span class="number">0</span>]=father;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line">        lca[now][i]=lca[lca[now][i<span class="number">-1</span>]][i<span class="number">-1</span>]<span class="comment">//直接整，暴力出log_2(1e5)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;<span class="comment">//朴实无华的深搜</span></span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==father)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">    value[now]=ans;<span class="comment">//保存该节点为根节点时的所有子孙节点上的能力值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        e[i].<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上为输入</span></span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m);<span class="comment">//边按照权值排序</span></span><br><span class="line">    <span class="built_in">Kruskal</span>();<span class="comment">//重构树</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">2</span>*n<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">//深搜填value，获得以每个节点为根节点能获得的能力值，顺便处理一下LCA</span></span><br><span class="line">    v[<span class="number">0</span>]=<span class="number">1e18</span>;<span class="comment">//防止到0之后无法终止递归</span></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,k;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;k;</span><br><span class="line">        <span class="keyword">int</span> t=x;</span><br><span class="line">        <span class="keyword">int</span> now=value[x]+k;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> las = x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> fa = lca[x][i];</span><br><span class="line">                <span class="keyword">if</span>(now &gt;= v[fa]) x = fa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x == las)<span class="keyword">break</span>;</span><br><span class="line">            now = value[x] + k;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//完结撒花</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序注释提到了，咱因为数组越界查了两个小时的错误，硬生生没看到LCA没有开两倍的内存。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/5.png" alt="5"></p><p>又一图论算法收入囊中，挺开心的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;比赛遇到了新鲜的图论题，特此记录。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="Kruskal重构" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/Kruskal%E9%87%8D%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>最小费用最大流笔记</title>
    <link href="http://example.com/2022/03/05/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/03/05/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T18:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.841Z</updated>
    
    <content type="html"><![CDATA[<p>时隔多日，又一模板收入其中：最小费用最大流。</p><span id="more"></span><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><ul><li>费用：对每条有向边新增的一个属性，费用表示每个经过这条边的一个单位流量将会添加这么多费用。</li></ul><p>将抽象的问题具象化：在一张高速网中有 $n$ 个收费站，$m$ 条单向通行的道路，每走完一条道路就会到那边的收费站收费，收费价格会根据你走的哪条路收费，而不是固定的收费点就收固定的钱，这个也很合逻辑吧。然后一条道路最多同行 $w$ 辆车，也就是说这条路一旦走过超过 $w$ 辆车那这条路将不再放行，虽然不符合我们的认知但是他就这么规定了你也没办法嘛对吧。在 $n$ 个收费站有一个源收费站一个目的收费站，问最多有多少辆车能从源收费站到目的收费站，总费用最小的通行方案是多少。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>乍一听好像没啥思路，但是从一个司机的角度去考虑，这就会变得简单了，因为对于一个司机来说，我的目标是到达目的收费站且使我花费最少。那么起点终点确定了，每条路收费确定了，收费站之间的道路也确定了，那么我以收费为边权计算我到终点的单源最短路不就可以了么，走单源最短路一定会使得我的花费最少，因为边权是费用，最短在某种意义上就是费用最少啦。</p><p> 但是我们是不可能为每一个司机考虑的，我们可以搜出一条单源最短路，那么就很容易计算这条路上的总费用和最小流量。那么这一次我就相当于通过了，<strong>最小流量</strong> 辆车，费用相当于多了 <strong>最小流量$\times$ 总费用</strong> 。这里就跟网络流有点类似了，我求单源最短路的过程也可以视为找一条增广路。在结果保存之后我们依然要添加反向边，然后对应流量减少，反向边流量增加。但是这里我们还需要注意这个反向边费用是多少呢？其实很好理解，我一辆车过去，再回来，对车来说相当于没过去，也就没有花费<del>虽然实际情况不是这样</del>，所以我们添加反向边的时候要给路径长度为负边权。这样就决定了我们只能考虑某已死算法，虽然你可以给所有边权加上一个最大值使得每个边权为正，最后跑完 $\text{dijkstra}$ 之后再每条边减去这么多。但是实际我写出来并不行，也不知道为什么，但是听说网络流有不成文的规定：</p><p>有以下情况之一的：</p><ol><li>网络流卡 $\text{Dinic}$ 算法。</li><li>费用流卡 $\text{spfa}$ 算法。</li></ol><p>按照规定其族谱将被万人问候。</p><p>最后一点需要注意：一条边流量为 $0$ 之后，它应被视为断开。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><p>模板题：<a href="https://www.luogu.com.cn/problem/P3381">P3381</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppp</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> edge;</span><br><span class="line">&#125;pre[maxn];</span><br><span class="line"><span class="keyword">int</span> s,t,ans,n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> root[maxn],dis[maxn],inque[maxn],vis[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,d,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));<span class="comment">//最大初始化</span></span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);<span class="comment">//源点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!edge[i].w)<span class="keyword">continue</span>;<span class="comment">//如果这条边没有流量则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+edge[i].d)&#123;<span class="comment">//三角形不等式判定</span></span><br><span class="line">                dis[v]=dis[u]+edge[i].d;</span><br><span class="line">                pre[v].v=u;<span class="comment">//记录路径</span></span><br><span class="line">                pre[v].edge=i;</span><br><span class="line">                <span class="keyword">if</span>(!inque[v])&#123;<span class="comment">//经典spfa</span></span><br><span class="line">                    inque[v]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> k=inf;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            k=<span class="built_in">min</span>(edge[pre[i].edge].w,k);<span class="comment">//计算最小流量</span></span><br><span class="line">            f+=edge[pre[i].edge].d; <span class="comment">//统计总费用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].edge].w-=k;<span class="comment">//正向边流量-</span></span><br><span class="line">            edge[pre[i].edge^<span class="number">1</span>].w+=k;<span class="comment">//反向边流量+</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans+=k;<span class="comment">//计算流量</span></span><br><span class="line">        w+=k*f;<span class="comment">//计算费用</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3381_8.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w,c;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(u,v,w,c);</span><br><span class="line">        <span class="built_in">add</span>(v,u,<span class="number">0</span>,-c);<span class="comment">//添加负费用的反向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;时隔多日，又一模板收入其中：最小费用最大流。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    
  </entry>
  
  <entry>
    <title>网络流学习笔记</title>
    <link href="http://example.com/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-03T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.873Z</updated>
    
    <content type="html"><![CDATA[<p>最近花点时间看了看网络流，也深度地学习了一下网络流的各个算法，虽然还有一个没学，但是不影响。</p><span id="more"></span><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>首先我们要先理解一下什么是网络，网络与有向图虽然长得一模一样，但是概念略微不一样，首先网络的边权不代表路径长度，代表流量或者花费。</p><ol><li>源点：入读为0的点，只出不进</li><li>汇点：出度为0的点，只进不出</li></ol><p>在网络中，对于非源点和汇点的所有点，需要满足流入流量之和等于流出流量之和，中间节点不存储任何流量，任何一条边的流量受限于自己的容量限制。</p><p>于是有的人就想要求出：这张网络运作起来的时候，总流量最大能有多少。由于容量限制比较复杂，似乎不容易规划一个最佳方案。</p><p>such as:</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><p>在这里，很容易得出 $s\to t$ 的最大流量就是2，上面一条路，下面一条路，边上的限制都是1，因此总流量为2。这里我们再给出两个概念：</p><ol><li>增广 :在现有流量基础上发现新的路径,扩大发现的最大流量(<strong>注意</strong>:增加量不一定是这条路径的流量,而是新的流量与上次流量之差)</li><li>增广路:在现有流量基础上发现的新路径.(快来找茬,和上一条有何不同?)</li></ol><p>因此我们有了第一个算法：FF。</p><p>虽然一般来说基本通不过测试点，但是还是有必要学的。</p><h2 id="FF算法"><a href="#FF算法" class="headerlink" title="FF算法"></a>FF算法</h2><p>从源点开始寻找增广路，如过找到那么整条路径的流量减去整个路径上的最小流量，然后重复寻找增广路，直到找不到增广路为止，最大流即是每次增广路减少的流量的和，这个结论是很容易证明的，所以咱就不证了。</p><p>很有幸，咱还是写过了这个算法，每次 $\text{dfs}$ 得到一个增广路，这个算法过得了图为树时候的最大流，但是过不去标板，标板的数据量才200个点，还能 TLE 很多点。</p><p>但是有一个问题，如果我一开始走了错误的路线，比如上面的图中，假如我走了中间那条路，那么就会导致接下来找不到增广路了，所以我们在走的时候会增加反悔功能，这条反向边就是防止走了错误路线给你反悔用的，假设你走了 $s\to a \to b\to t$ ，那么此时图变成这样：</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="2"></p><p>那么在往下走的过程中我就能经过 $s \to b\to a\to t$，然后到达汇点。中间这条边经过两次，变回一开始的样子，相当于就是没走，这个反向边添加在所有的网络流算法都会用到，因此一定要理解。</p><p>这里给出练习这个算法的板子吧——<a href="https://www.luogu.com.cn/problem/P3931">P3931</a></p><p>我写的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> r,n,cnt=<span class="number">1</span>,root[maxn],fa[maxn],dest[maxn];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;root[x],y,w&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(fa[u]==to)<span class="keyword">continue</span>;</span><br><span class="line">        fa[to]=u;</span><br><span class="line">        <span class="comment">//edge[i^1].w=0;</span></span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!edge[root[u]].next&amp;&amp;u!=r)&#123;</span><br><span class="line">        dest[u]=<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_path</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> from,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest[now])<span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> qw=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to,w=edge[i].w;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf(&quot;to is %d w is %d\n&quot;,to,w);</span></span><br><span class="line">        <span class="keyword">if</span>(to==from)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        path.<span class="built_in">push</span>(i);</span><br><span class="line">        qw=<span class="built_in">find_path</span>(to,now,<span class="built_in">min</span>(flow,w));</span><br><span class="line">        <span class="keyword">if</span>(qw==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">find_path</span>(r,<span class="number">0</span>,<span class="number">0x7fffffff</span>);</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="number">0</span>&amp;&amp;l!=<span class="number">0x7fffffff</span>)&#123;</span><br><span class="line">            ans+=l;</span><br><span class="line">            <span class="keyword">while</span>(path.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> e=path.<span class="built_in">top</span>();</span><br><span class="line">                path.<span class="built_in">pop</span>();</span><br><span class="line">                edge[e].w-=l;</span><br><span class="line">                edge[e^<span class="number">1</span>].w+=l; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3931_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(r);</span><br><span class="line">    <span class="built_in">maxflow</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个数据量 $\text{10w}$ 都能过为啥能过呢，据评论区大佬说，因为树是二分图，因此增广路不会超过 $log_2n$ 条，因此这题我这么写能过，但是遇到非树的毒瘤图那真的 $200$ 都能卡住的，而且我下了一下标板的测试点，貌似就是会陷入死循环，我不知道哪里写出来的问题了。</p><h2 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h2><p>在高中的时候我们老师就讲过，在一般情况下，$\text{dfs}$ 一定是没有 $\text{bfs}$ 优的。因此我们每次都挑一个看上去路径最短的增广路，既然要求最短了我们就可以用 $\text{bfs}$ 去寻找增广路了。</p><p>EK算法可以通过标板——<a href="https://www.luogu.com.cn/problem/P3376">P3376</a></p><p>我写的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[<span class="number">5005</span>&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> edge;</span><br><span class="line">&#125;pre[<span class="number">5005</span>&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[maxn],inque[maxn],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(inque,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inque));</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0xff</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    inque[s]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!inque[v]&amp;&amp;edge[i].w)&#123;</span><br><span class="line">                pre[v]=&#123;u,i&#125;;</span><br><span class="line">                <span class="keyword">if</span>(v==t)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                inque[v]=<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;%lld\n&quot;,sizeof(ans));</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mi=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            mi=<span class="built_in">min</span>(mi,edge[pre[i].edge].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].edge].w-=mi;</span><br><span class="line">            edge[pre[i].edge^<span class="number">1</span>].w+=mi;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=mi;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3376_7.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><p>EK算法虽然比较优了，但是有一个情况还是比较费时的，如下图所示</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><p>假设我 $S\to A$ 再经过更多的点，$A$ 后面的分支更多，那么每一次都要 $\text{bfs}$  开销也是很大的的，重要的是很多路我们会重复遍历。这里就体现出了 $\text{Dinic}$ 算法的优了。</p><p>它只需要开始一次 $\text{bfs}$ 就能处理多条路径，它的思想是这样的：先对网络进行 $\text{bfs}$ 分层，我只找这样的增广路：</p><p>对于路径上任意 $u\to v$ 的边，都有 $v$ 在 $u$ 的下一层。我一次可以处理多条增广路，如果没有增广路那么我将对网络重新分层，直到 $\text{bfs}$ 无法遍历到汇点时。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxe 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxe&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],dep[maxn],cnt=<span class="number">1</span>,s,t,n,m,ans;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//网络分层 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//puts(&quot;1&quot;);</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(!dep[v]&amp;&amp;w)&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从u出发，目前已有in的流量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> in;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>&amp;&amp;w)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(in,w));</span><br><span class="line">            edge[i].w-=res;</span><br><span class="line">            edge[i^<span class="number">1</span>].w+=res;</span><br><span class="line">            in-=res;</span><br><span class="line">            ans+=res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)dep[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(s,<span class="number">0x7fffffffffffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又一个板子收入囊中，网络流应该会 $\text{Dcini}$ 差不多了吧qwq。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近花点时间看了看网络流，也深度地学习了一下网络流的各个算法，虽然还有一个没学，但是不影响。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    
  </entry>
  
  <entry>
    <title>线段树的学习笔记</title>
    <link href="http://example.com/2022/02/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/02/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-25T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.867Z</updated>
    
    <content type="html"><![CDATA[<p>最近复习一下线段树的板子。</p><span id="more"></span><p>就随便写吧，就写给自己看看的，因为即便是我学过板子，也基本会交错很多次。首先一个就是一定在开头加上一句话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br></pre></td></tr></table></figure><p>然后就是push_down的操作，一定是有标记的时候已经加完了，push_down的时候就是把标记分发下去然后给子节点加上值和lazy标记。</p><p>在add操作的时候一定要加上先push_down再加。</p><h2 id="线段树解决问题的范围"><a href="#线段树解决问题的范围" class="headerlink" title="线段树解决问题的范围"></a>线段树解决问题的范围</h2><p>要求在线，并且含有区间加法和区间查询的操作，下面是洛谷的板子题并给出标程，也可以当板子用。</p><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lazy;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> eee &amp;a)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum+a.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r ,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    tree[now].l=l;</span><br><span class="line">    tree[now].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[now].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>]+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="comment">//if(tree[now].l==tree[now].r)return;</span></span><br><span class="line">    <span class="keyword">int</span> lazy=tree[now].lazy;</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>].sum+=lazy*tree[now&lt;&lt;<span class="number">1</span>].<span class="built_in">length</span>();</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>].lazy+=lazy;</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=lazy*tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">length</span>();</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=lazy;</span><br><span class="line">    tree[now].lazy=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;</span><br><span class="line">        tree[i].sum+=num*(tree[i].r-tree[i].l+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//tree[i].sum%=mod;</span></span><br><span class="line">        tree[i].lazy+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy)<span class="built_in">push_down</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(l,r,num,i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(l,r,num,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[i].sum=(tree[i&lt;&lt;<span class="number">1</span>].sum+tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum);<span class="comment">//%mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;</span><br><span class="line">        ans+=tree[i].sum;</span><br><span class="line">    <span class="comment">//    ans%=mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy)<span class="built_in">push_down</span>(i);</span><br><span class="line">        <span class="keyword">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">query</span>(l,r,i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">query</span>(l,r,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,y,z;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            <span class="built_in">add</span>(x,y,z,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">query</span>(x,y,<span class="number">1</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近复习一下线段树的板子。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="数据结构" scheme="http://example.com/categories/icpc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="http://example.com/categories/icpc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2-SAT学习笔记</title>
    <link href="http://example.com/2022/02/23/2-SAT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/02/23/2-SAT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-23T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.695Z</updated>
    
    <content type="html"><![CDATA[<p>很开心，图论的知识也是积少成多，回首往昔，我对图论的算法仅限于最短路算法($\text {dijkstra}$)和最小生成树($\text {kruskal&amp;prime}$) 。今天来学学这个 $\text {2-SAT}$ 问题。</p><span id="more"></span><h2 id="2-SAT简介"><a href="#2-SAT简介" class="headerlink" title="2-SAT简介"></a>2-SAT简介</h2><blockquote><p>$\text {SAT}$ 是适定性（Satisfiability）问题的简称。一般形式为 k - 适定性问题，简称 k-SAT。而当 $k&gt;2$ 时该问题为 NP 完全的。所以我们只研究 $k=2$ 的情况。</p><p>$\text {2-SAT}$，简单的说就是给出 个集合，每个集合有两个元素，已知若干个 ，表示 与 矛盾（其中 与 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 个两两不矛盾的元素。显然可能有多种选择方案，一般题中只需要求出一种即可。(from OI WIKI)</p></blockquote><p>我想上面说的也比我说的稍微清楚点了，那么他的现实意义是什么呢？比较常见的就是逻辑推导了。</p><p>告诉你现在有 A，B，C三个人，且A和B是男生，如果B是男生，那么C是女生。问你这三个人的性别分别是什么，我们很容易可以知道A，B为男，C为女。</p><p>现在主要就是让计算机去计算这个问题怎么办呢？首先有一点可以确定的就是，一个人不能既是男又是女。如果存在这样的断言：如果A是男，那么A是女，这样的话A只能是女，因为A不可能既是男又是女，这个规定就为我们解决 $\text {2-SAT}$ 问题提供了思路。</p><p>我们假设有 $n$ 个人，那么我们建一个 $2\times n$ 个点的有向图，第如果 $i\le n$ 那么第 $i$ 个点表示 $i$ 为男，$i&gt;n$ 那么第 $i$ 个点表示第 $i-n$ 个人为女。$i\to j$有向边很显然表：如果选择点 $i$，那么一定要选择点 $j$，如果我们选择点 $i$ ，那么点 $i+n$ 或者是点 $i-n$ 一定不能被选中，否则我们就说点 $i$ 不能被选择。所以，如果 $i$ 与 $i$ 的对立面同时不能被选择，即它们在同一个强连通分量内，那么整个问题都是无解的，因为有一个人的性别无论怎么选始终无法满足要求。</p><p>一般情况下，解不唯一，我们通常只需要输出是否有解即可，因为如果输出方案的话它们还要设置check脚本。但是洛谷它还就搞了，神不神奇。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4782">洛谷P4782</a></p><p>典型的 $\text {2-SAT}$ 问题，需要注意的是，它这里每个给出的条件都是或的关系，我们需要转换成边，那么我们想想怎么转换成一条边？如果它的条件给了 $x=1 \ or\ y=1 $ 。那么 $x=1$ 和 $y=1$ 是没有什么关系的，因为 $x=1$ 的时候 $y$ 没有限制，可以为 $1$ 可以为 $0$。但是呢，如果 $x=0$ 则一定推的出 $y=1$ 因为两个必须有一个满足，一个不满足会导致另一个一定要满足。所以我们就把一个条件的反面连接到另一个条件，同样另一个条件的反面也连到这个条件。</p><p>得到了一张有向图之后呢，我们先跑 $\text {tarjan}$ 强连通分量，观察是否存在 $i\le n$ 使得 $i$ 和 $i+n$ 是否属于同一个强连通分量，如果是，则无解。如果不是，则有解。(敲黑板)，这里需要注意了啊，这里跑 $\text{tarjan}$ 需要跑 $2\times n$ 个点。如果选中 $i$ 发现产生冲突那么选择该时事件的对立面则一定不会发生冲突。这里我们跑 $\text{dfs}$ ，把与之相连的所有点都打上被选中的标记，如果存在两个状态同时被选中，则返回 $\text{false}$ 并且逐层回溯，如果到最后都没发生冲突则已选中的状态固定，继续去搜索没有被打标记的状态。直到所有的状态都有一个对应的值，最后输出这个状态。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>],e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],root2[maxn],dfn[maxn],low[maxn],degree[maxn],vis[maxn],num[maxn],s[maxn],cnt,tot,top,cnt2,deep,n,m;</span><br><span class="line"><span class="keyword">int</span> sel[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;root[x],y&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++cnt2]=&#123;root2[x],y&#125;;</span><br><span class="line">    root2[x]=cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++deep;</span><br><span class="line">    s[++top]=u;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[v],low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        num[u]=++tot;</span><br><span class="line">        <span class="keyword">while</span>(s[top]!=u)&#123;</span><br><span class="line">            vis[s[top]]=<span class="number">0</span>;</span><br><span class="line">            num[s[top--]]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sel[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sel[(u<span class="number">-1</span>)%n+<span class="number">1</span>]&amp;&amp;sel[(u<span class="number">-1</span>)%n+n+<span class="number">1</span>])&#123;</span><br><span class="line">        sel[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(sel[v]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(v))&#123;</span><br><span class="line">                sel[u]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x+(y)*n,z+(!w)*n);</span><br><span class="line">        <span class="built_in">add</span>(z+(w)*n,x+(!y)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]==num[i+n])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sel[i]==<span class="number">0</span>&amp;&amp;sel[i+n]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i))&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i+n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;POSSIBLE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sel[i]&gt;sel[i+n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;很开心，图论的知识也是积少成多，回首往昔，我对图论的算法仅限于最短路算法($\text {dijkstra}$)和最小生成树($\text {kruskal&amp;amp;prime}$) 。今天来学学这个 $\text {2-SAT}$ 问题。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="2-SAT" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/2-SAT/"/>
    
    
  </entry>
  
  <entry>
    <title>差分约束的学习笔记</title>
    <link href="http://example.com/2022/02/22/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/02/22/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-22T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.837Z</updated>
    
    <content type="html"><![CDATA[<p>差分约束系统，就是给出一组形如 $x_i-x_j\le d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>那我们转换一下，假设 $x_i$ 为点 $i$ 的单源最短路长度，$x_j$ 为点 $j$ 的单源最短路长度。那么以上不等式就可以转换成 $dis[i]-dis[j]\le d\to dis[i]\le dis[j]+d$。</p><p>那么这个就转变成了 $j\to i$ 一条权值为 $d$ 的边的最短路搜索了。因为如果一条边 $i\to j$ 权值为 $d$ ，那么必然有 $dis[i]\le dis[j]+d$ ，如果不满足这个条件。我们用反证法证明一下这个结论，设一条边 $i\to j$ 权值为 $d$，且满足 $dis[i] &gt; dis[j]+d$，那么在一次单源最短路算法时，必然会导致 $i$ 点被松弛。即发生</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[i]&gt;dis[j]+d)&#123;</span><br><span class="line">    dis[i]=dis[j]+d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以得出结论：$dis[i]$ 一定不会比 $dis[j]+d$ 大，当 $i\to j$ 有一条权值为 $d$ 的边时。当然可以比它小，如果其它边有更短的走法。</p><p>所以当存在不等式 $x_i-x_j\le d$ 的时候，我们只需要建一条 $i\to j$ 权值为 $d$ 的边就能满足这个不等式了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们就根据不等式组建图，然后跑单源最短路。这里需要注意的是，如果图不连通，那并不是无解，说明它们不在同一个不等式组，相互之间都没有关联，那就分别求单源最短路即可。为了防止这个情况，我们一般都会添加一个超级源点，这个源点为 $0$ 或者是 $n+1$。然后建立一条源点到其它所有点的一条权值为 $d$ 的有向边。 </p><p>我们添加了 $0\to i(1\le i\le n)$ 权值为 $0$ 的有向边，相当于增加了以下约束条件：</p><p>$dis[i]\le dis[0]+0$ </p><p>添加这个约束条件问题是不大的，因为我们很容易看出来，在找到一组解的时候，给所有的未知数都加上一个相同的值，是不会影响结果的。这个结论是很容易的出来的，因为我们的表达式都是一正一负，然后带进不等式之后加上的常数都会消掉，还能解决图不连通的问题，一举多得。添加这个约束条件之后，我们可以发现得到的值一定都是负数，那么如果一定要正解的话，那么直接给所有的dis加上一个 $\max(dis)$ 就完了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P5960">洛谷P5960</a></p><p>就依然是一个板子，然后最后判断以下负环无解的情况，没有就输出所有的 $dis$。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],degree[maxn],dis[maxn],e_cnt[maxn],in_que[maxn],cnt,n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].next=root[x];</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    degree[y]++;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    e_cnt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    in_que[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                e_cnt[v]++;</span><br><span class="line">                <span class="keyword">if</span>(e_cnt[v]&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> M=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;差分约束系统，就是给出一组形如 $x_i-x_j\le d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="差分约束" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
    <category term="单源最短路" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="spfa" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/spfa/"/>
    
    
  </entry>
  
  <entry>
    <title>负环判断</title>
    <link href="http://example.com/2022/02/21/%E8%B4%9F%E7%8E%AF%E5%88%A4%E6%96%AD/"/>
    <id>http://example.com/2022/02/21/%E8%B4%9F%E7%8E%AF%E5%88%A4%E6%96%AD/</id>
    <published>2022-02-21T04:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.877Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲到了<code>spfa</code>，然后有一个判断负环的操作，这个判断负环有更好的思路。</p><span id="more"></span><p>设$cnt[i]$为$s$到$i$的最短路中已经经过的路径条数，如果超过 $n$ 个边，那就说明有 $n-1$ 个点，必产生了负环，如果没有负环绝对是不会找到回路的。</p><h2 id="洛谷P3385"><a href="#洛谷P3385" class="headerlink" title="洛谷P3385"></a><a href="https://www.luogu.com.cn/problem/P3385">洛谷P3385</a></h2><p>emm直接给标程吧，就是最朴实无华的 $spfa$ 负环判断。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],dis[maxn],e_cnt[maxn],in_que[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(e_cnt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(e_cnt));</span><br><span class="line">    <span class="built_in">memset</span>(in_que,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in_que));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    e_cnt[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    e_cnt[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(e_cnt[v]&gt;n)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3385_9.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">        <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(edge));</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,w;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">            <span class="built_in">add</span>(x,y,w);</span><br><span class="line">            <span class="keyword">if</span>(w&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(y,x,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">spfa</span>(<span class="number">1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面讲到了&lt;code&gt;spfa&lt;/code&gt;，然后有一个判断负环的操作，这个判断负环有更好的思路。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="负环" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E8%B4%9F%E7%8E%AF/"/>
    
    <category term="spfa" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/spfa/"/>
    
    
  </entry>
  
  <entry>
    <title>spfa算法的学习</title>
    <link href="http://example.com/2022/02/21/spfa%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/02/21/spfa%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-02-21T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.801Z</updated>
    
    <content type="html"><![CDATA[<p>勇敢小鸡，不怕困难。时隔多日，又来复习图论算法了，本来想的是搞一下差分约束的，但是发现前置知识是<code>spfa</code>算法，所以就先来学习一下这个。</p><span id="more"></span><h2 id="spfa算法介绍"><a href="#spfa算法介绍" class="headerlink" title="spfa算法介绍"></a>spfa算法介绍</h2><p>SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。<strong>其优于dijkstra算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。但算法可以进行若干种优化，提高了效率。</strong></p><p>算法的思路：<br>我们用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止</p><p>我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：</p><ol><li>开始算法前，调用拓扑排序进行判断（一般不采用，浪费时间）</li><li>如果某个点进入队列的次数超过N次则存在负环（N为图的顶点数）</li></ol><h2 id="spfa算法浅谈"><a href="#spfa算法浅谈" class="headerlink" title="spfa算法浅谈"></a>spfa算法浅谈</h2><p><code>spfa</code>算法的话，一般单源最短路基本用不到 ，<code>dijkstra</code>算法比它优很多，唯有需要处理负权图的时候会想到他。差分约束无解的情况就是存在负环，因此这个得学。</p><p>大概流程可以描述为以下文字。</p><ol><li>源点入队，源点距离初始化为0，其它初始化为 $inf$。</li><li>出队一个点并遍历与之之间相连的点，进行松弛操作。也就是我们经常见到的 <code>if(dis[to]&gt;w+dis[from])dis[to]=dis[from+w]</code>。</li><li>如果对一个点进行了松弛那么判断它有没有在队列中，如果不在则入队，并判断入队次数有没有超过点的个数，如果超过则goto 6。</li><li>如果队列不为空则goto 2。</li><li>结束，输出结果。</li><li>结束，输出存在负环的对应答案。</li></ol><p>下面来一道例题。</p><h2 id="洛谷P1396"><a href="#洛谷P1396" class="headerlink" title="洛谷P1396"></a><a href="https://www.luogu.com.cn/problem/P1396">洛谷P1396</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 t 区，而自己在 s区。</p><p>该市有 m 条大道连接 n 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 s 至 t 的路线，使得经过道路的拥挤度最大值最小。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题其实有点差强人意，因为这个是要判断所经过边的最大值的最小值，但是我们主要还是练习spfa为主。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt,dis[maxn],in_que[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="comment">//printf(&quot;%d %d %d\n&quot;,u,v,w);</span></span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;<span class="built_in">max</span>(dis[u],w))&#123;</span><br><span class="line">                dis[v]=<span class="built_in">max</span>(dis[u],w);</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P1396_1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;勇敢小鸡，不怕困难。时隔多日，又来复习图论算法了，本来想的是搞一下差分约束的，但是发现前置知识是&lt;code&gt;spfa&lt;/code&gt;算法，所以就先来学习一下这个。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路径" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    <category term="spfa" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/spfa/"/>
    
    
  </entry>
  
  <entry>
    <title>manacher的学习</title>
    <link href="http://example.com/2022/02/18/manacher%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/02/18/manacher%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-02-18T03:00:00.000Z</published>
    <updated>2022-04-18T06:51:22.787Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习一下新的字符串算法——manacher算法。</p><span id="more"></span><h2 id="manacher简介"><a href="#manacher简介" class="headerlink" title="manacher简介"></a>manacher简介</h2><blockquote><p><strong>最长回文子串</strong>（英语：<strong>Longest palindromic substring</strong>）是计算机科学中的问题，在一个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>中查找一个最长的连续的<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%96%87">回文</a>的子串，例如“banana”最长回文子串是“anana”。最长回文子串并不一定是唯一的，比如在“abracadabra”中，没有超过3个字符的回文子串，但是有两个回文字符串长度都是3：“ada”和“aca”。在一些应用中，我们求出全部的极大回文子串（不被其他回文串包含的回文子串）。</p><p>Manacher于1975年发现了一种线性时间算法[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-1">1]</a>，可以在列出给定字符串中从任意位置开始的所有回文子串。并且，Apostolico, Breslauer &amp; Galil [<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-2">2]</a>发现，同样的算法也可以在任意位置查找全部极大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。另外，Jeuring (1994)[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-3">3]</a>, Gusfield (1997)[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-4">4]</a>发现了基于后缀树的算法。也存在已知的高效并行算法。(from wiki)</p></blockquote><h2 id="manacher实现"><a href="#manacher实现" class="headerlink" title="manacher实现"></a>manacher实现</h2><p>实现起来的话，其实我个人认为是比较简单的。首先防止奇偶序列的问题，我们在所有的字符之间以及末尾添加<code>#</code>让它变成奇数，再在首尾分别添加<code>$</code>和<code>~</code>作为截至判断的区分。</p><p>我将变量做如下定义：</p><ul><li>$s$ ：所求字符串</li><li>$p[i]$ ：代表以字符 $s[i]$ 为中心的最长回文半径。即满足在 $0\le j\le p[i]$ 的条件下 $s[i+j]==s[i-j]$ 永远成立。</li><li>$wx$ ：目前所求的最远回文半径延伸的地方。即当前情况下的 $\max(i+p[i])$。  </li><li>$idx$ ：代表之前所求最远回文半径的中心。即取得wx时的 $i$ 的值。</li></ul><p>那么有了这个定义之后我们主要就是求这个p数组了，怎么求呢？</p><p>首先，如果我所在的位置在之前一个大的回文半径当中，那么我可以直接参考之前对称的那个位置上的p的值，比如下面这个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a a a a b a a a a...</span><br><span class="line">    ↑   ↑   ↑   ↑</span><br><span class="line">    j idx   i   wx</span><br></pre></td></tr></table></figure><p>这种情况下，我们不难发现，$p[i]$ 至少是大于等于 $p[j]$ 的，如果省略号后面马上跟一个 $b$ 的话，那么它的 $p$ 的值可能会涨，但是我们就不用判断它周围两边相不相等了啊。如果多了，那么我比较的次数就更少了。但是呢，其实可以发现，我们管的范围只能到wx，多余wx我们肯定不敢保证数据完全对称可用，所以这里我们限制一下 $p[i]$ 最大可赋值为 $wx-i$ 即可。</p><p>所以我们的核心代码就是这样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len2;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx&gt;i)&#123;</span><br><span class="line">        p[i]=<span class="built_in">min</span>(p[<span class="number">2</span>*idx-i],mx-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">            p[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(new_s[i+p[i]]==new_s[i-p[i]])&#123;<span class="comment">//继续扩展看看有没有可能</span></span><br><span class="line">        p[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+p[i]&gt;mx)&#123;    </span><br><span class="line">        mx=i+p[i];</span><br><span class="line">        idx=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 22000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> new_s[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    new_s[<span class="number">0</span>]=<span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    new_s[<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(s),len2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">        new_s[<span class="number">2</span>*i+<span class="number">3</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        new_s[<span class="number">2</span>*i+<span class="number">2</span>]=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    len2=<span class="built_in">strlen</span>(new_s)+<span class="number">1</span>;</span><br><span class="line">    new_s[len2<span class="number">-1</span>]=<span class="string">&#x27;~&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,idx=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)&#123;</span><br><span class="line">            p[i]=<span class="built_in">min</span>(p[<span class="number">2</span>*idx-i],mx-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(new_s[i+p[i]]==new_s[i-p[i]])&#123;</span><br><span class="line">            p[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]&gt;mx)&#123;</span><br><span class="line">            mx=i+p[i];</span><br><span class="line">            idx=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天学习一下新的字符串算法——manacher算法。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="字符串" scheme="http://example.com/categories/icpc/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="manacher" scheme="http://example.com/categories/icpc/%E5%AD%97%E7%AC%A6%E4%B8%B2/manacher/"/>
    
    <category term="回文串" scheme="http://example.com/categories/icpc/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
    
  </entry>
  
</feed>
